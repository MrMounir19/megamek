


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Armor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common.verifier</a>
</div>

<h1>Coverage Summary for Class: Armor (megamek.common.verifier)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Armor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (4/16)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;/*
&nbsp; * Author: Reinhard Vicinus
&nbsp; */
&nbsp;
&nbsp;package megamek.common.verifier;
&nbsp;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import megamek.common.*;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.util.StringUtil;
&nbsp;
&nbsp;/**
&nbsp; * Abstract parent class for testing and validating instantiations of &lt;code&gt;
&nbsp; * Entity&lt;/code&gt; subclasses.
&nbsp; *
&nbsp; */
&nbsp;public abstract class TestEntity implements TestEntityOption {
&nbsp;    public static enum Ceil {
&nbsp;        TON(1.0), HALFTON(2.0), QUARTERTON(4.0), TENTHTON(10.0), KILO(1000.0);
&nbsp;        
&nbsp;        public final double mult;
&nbsp;        
&nbsp;        private Ceil(double mult) {
&nbsp;            this.mult = mult;
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    protected Engine engine = null;
&nbsp;    protected Armor[] armor = null;
&nbsp;    protected Structure structure = null;
&nbsp;    private TestEntityOption options = null;
&nbsp;
&nbsp;    public abstract Entity getEntity();
&nbsp;
&nbsp;    public abstract boolean isTank();
&nbsp;
&nbsp;    public abstract boolean isMech();
&nbsp;
&nbsp;    public abstract boolean isAero();
&nbsp;    
&nbsp;    public abstract boolean isSmallCraft();
&nbsp;    
&nbsp;    public abstract boolean isAdvancedAerospace();
&nbsp;    
&nbsp;    public abstract boolean isProtomech();
&nbsp;
&nbsp;    public abstract double getWeightControls();
&nbsp;
&nbsp;    public abstract double getWeightMisc();
&nbsp;
&nbsp;    public abstract double getWeightHeatSinks();
&nbsp;
&nbsp;    public abstract boolean hasDoubleHeatSinks();
&nbsp;
&nbsp;    public abstract int getCountHeatSinks();
&nbsp;
&nbsp;    public abstract String printWeightMisc();
&nbsp;
&nbsp;    public abstract String printWeightControls();
&nbsp;
&nbsp;    public abstract boolean correctEntity(StringBuffer buff);
&nbsp;
&nbsp;    public abstract boolean correctEntity(StringBuffer buff, int ammoTechLvl);
&nbsp;
&nbsp;    public abstract StringBuffer printEntity();
&nbsp;
&nbsp;    public abstract String getName();
&nbsp;
&nbsp;    public String fileString = null; // where the unit came from
&nbsp;
&nbsp;    public TestEntity(TestEntityOption options, Engine engine, Armor[] armor,
&nbsp;            Structure structure) {
&nbsp;        this.options = options;
&nbsp;        this.engine = engine;
&nbsp;        this.armor = armor;
&nbsp;        this.structure = structure;
&nbsp;    }
&nbsp;
&nbsp;    public boolean isClan() {
&nbsp;        return getEntity().isClan();
&nbsp;    }
&nbsp;
&nbsp;    public boolean isClanArmor() {
&nbsp;        return getEntity().isClanArmor(0) &amp;&amp; !getEntity().hasPatchworkArmor();
&nbsp;    }
&nbsp;
&nbsp;    public double getWeight() {
&nbsp;        return getEntity().getWeight();
&nbsp;    }
&nbsp;
&nbsp;    public int getTotalOArmor() {
&nbsp;        return getEntity().getTotalOArmor();
&nbsp;    }
&nbsp;
&nbsp;    public String getLocationAbbr(int location) {
&nbsp;        return getEntity().getLocationAbbr(location);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingEngine() {
&nbsp;        return options.getWeightCeilingEngine();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingStructure() {
&nbsp;        return options.getWeightCeilingStructure();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingArmor() {
&nbsp;        return options.getWeightCeilingArmor();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingControls() {
&nbsp;        return options.getWeightCeilingControls();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingWeapons() {
&nbsp;        return options.getWeightCeilingWeapons();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingTargComp() {
&nbsp;        return options.getWeightCeilingTargComp();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingGyro() {
&nbsp;        return options.getWeightCeilingGyro();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingTurret() {
&nbsp;        return options.getWeightCeilingTurret();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingLifting() {
&nbsp;        return options.getWeightCeilingLifting();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ceil getWeightCeilingPowerAmp() {
&nbsp;        return options.getWeightCeilingPowerAmp();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double getMaxOverweight() {
&nbsp;        return options.getMaxOverweight();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean showOverweightedEntity() {
&nbsp;        return options.showOverweightedEntity();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double getMinUnderweight() {
&nbsp;        return options.getMinUnderweight();
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean showUnderweightedEntity() {
&nbsp;        return options.showUnderweightedEntity();
&nbsp;    }
&nbsp;
&nbsp;    public boolean showCorrectArmor() {
&nbsp;        return options.showCorrectArmor();
&nbsp;    }
&nbsp;
&nbsp;    public boolean showCorrectCritical() {
&nbsp;        return options.showCorrectCritical();
&nbsp;    }
&nbsp;
&nbsp;    public boolean showFailedEquip() {
&nbsp;        return options.showFailedEquip();
&nbsp;    }
&nbsp;
&nbsp;    public boolean ignoreFailedEquip(String name) {
&nbsp;        return options.ignoreFailedEquip(name);
&nbsp;    }
&nbsp;    
&nbsp;    public boolean showIncorrectIntroYear() {
&nbsp;        return options.showIncorrectIntroYear();
&nbsp;    }
&nbsp;    
&nbsp;    public int getIntroYearMargin() {
&nbsp;        return options.getIntroYearMargin();
&nbsp;    }
&nbsp;
&nbsp;    public boolean skip() {
&nbsp;        return options.skip();
&nbsp;    }
&nbsp;
&nbsp;    public int getTargCompCrits() {
&nbsp;        return options.getTargCompCrits();
&nbsp;    }
&nbsp;
&nbsp;    public int getPrintSize() {
&nbsp;        return options.getPrintSize();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to round values up based on the specified type.
&nbsp;     *
&nbsp;     * @param f     Value to round
&nbsp;     * @param type  Specifies the number of decimals to round to, see
&nbsp;     *              TestEntity.CEIL_TON, etc.
&nbsp;     * @return      Rounded value
&nbsp;     */
&nbsp;    public static double ceil(double f, Ceil type) {
&nbsp;        return Math.ceil(f * type.mult) / type.mult;
&nbsp;    }
&nbsp;
&nbsp;    public static double ceilMaxHalf(double f, Ceil type) {
&nbsp;        if (type == Ceil.TON) {
&nbsp;            return TestEntity.ceil(f, Ceil.HALFTON);
&nbsp;        }
&nbsp;        return TestEntity.ceil(f, type);
&nbsp;    }
&nbsp;
&nbsp;    public static double floor(double f, Ceil type) {
&nbsp;        return Math.floor(f * type.mult) / type.mult;
&nbsp;    }
&nbsp;
&nbsp;    public static double round(double f, Ceil type) {
&nbsp;        return Math.round(f * type.mult) / type.mult;
&nbsp;    }
&nbsp;
&nbsp;    static String makeWeightString(double weight) {
&nbsp;        return makeWeightString(weight, false);
&nbsp;    }
&nbsp;
&nbsp;    static String makeWeightString(double weight, boolean kg) {
&nbsp;        if (kg) {
&nbsp;            weight *= 1000;
&nbsp;        }
&nbsp;        if (weight &lt; 0.5) {
&nbsp;            // For small equipment show as many decimal places as needed.
&nbsp;            return DecimalFormat.getInstance().format(weight);
&nbsp;        } else {
&nbsp;            return String.format(&quot;%3.1f%s&quot;, weight, (kg ? &quot; kg&quot; : &quot;&quot;));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows a value to be truncuated to an arbitrary number of decimal places.
&nbsp;     *
&nbsp;     * @param value
&nbsp;     *            The input value
&nbsp;     * @param precision
&nbsp;     *            The number of decimals to truncate at
&nbsp;     *
&nbsp;     * @return The input value truncated to the number of decimal places
&nbsp;     *         supplied
&nbsp;     */
&nbsp;    public static double setPrecision(double value, int precision) {
&nbsp;        return Math.round(value * Math.pow(10, precision))
&nbsp;                / Math.pow(10, precision);
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Filters all armor according to given tech constraints
&nbsp;     *
&nbsp;     * @param etype         The entity type bit mask
&nbsp;     * @param industrial    For mechs; industrial mechs can only use certain armor types
&nbsp;     *                      unless allowing experimental rules
&nbsp;     * @param primitive     Whether the unit is primitive/retrotech
&nbsp;     * @param movementMode  For vehicles; hardened armor is illegal for some movement modes 
&nbsp;     * @param techManager   The constraints used to filter the armor types
&nbsp;     * @return A list of all armors that meet the tech constraints
&nbsp;     */
&nbsp;    public static List&lt;EquipmentType&gt; legalArmorsFor(long etype, boolean industrial, boolean primitive,
&nbsp;            EntityMovementMode movementMode, ITechManager techManager) {
&nbsp;        if ((etype &amp; Entity.ETYPE_BATTLEARMOR) != 0) {
&nbsp;            return TestBattleArmor.legalArmorsFor(techManager);
&nbsp;        } else if ((etype &amp; Entity.ETYPE_SMALL_CRAFT) != 0) {
&nbsp;            return TestSmallCraft.legalArmorsFor(techManager);
&nbsp;        } else if ((etype &amp; Entity.ETYPE_JUMPSHIP) != 0) {
&nbsp;            return TestAdvancedAerospace.legalArmorsFor(techManager, primitive);
&nbsp;        } else if ((etype &amp; (Entity.ETYPE_FIXED_WING_SUPPORT | Entity.ETYPE_SUPPORT_TANK | Entity.ETYPE_SUPPORT_VTOL)) != 0) {
&nbsp;            return TestSupportVehicle.legalArmorsFor(techManager);
&nbsp;        } else if ((etype &amp; Entity.ETYPE_AERO) != 0) {
&nbsp;            return TestAero.legalArmorsFor(techManager);
&nbsp;        } else if ((etype &amp; Entity.ETYPE_TANK) != 0) {
&nbsp;            return TestTank.legalArmorsFor(movementMode, techManager);
&nbsp;        } else if ((etype &amp; Entity.ETYPE_MECH) != 0) {
&nbsp;            return TestMech.legalArmorsFor(etype, industrial, techManager);
&nbsp;        } else {
&nbsp;            return Collections.emptyList();
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public static List&lt;EquipmentType&gt; validJumpJets(long entitytype, boolean industrial) {
&nbsp;        if ((entitytype &amp; Entity.ETYPE_MECH) != 0) {
&nbsp;            return TestMech.MechJumpJets.allJJs(industrial);
&nbsp;        } else if ((entitytype &amp; Entity.ETYPE_TANK) != 0) {
&nbsp;            return Collections.singletonList(EquipmentType.get(EquipmentTypeLookup.VEHICLE_JUMP_JET));
&nbsp;        } else if ((entitytype &amp; Entity.ETYPE_BATTLEARMOR) != 0) {
&nbsp;            return TestBattleArmor.BAMotiveSystems.allSystems();
&nbsp;        } else if ((entitytype &amp; Entity.ETYPE_PROTOMECH) != 0) {
&nbsp;            // Until we have a TestProtomech
&nbsp;            return Arrays.asList(new EquipmentType[] {
&nbsp;                EquipmentType.get(EquipmentTypeLookup.PROTOMECH_JUMP_JET),
&nbsp;                EquipmentType.get(EquipmentTypeLookup.EXTENDED_JUMP_JET_SYSTEM),
&nbsp;                EquipmentType.get(EquipmentTypeLookup.PROTOMECH_UMU)});
&nbsp;        } else {
&nbsp;            return Collections.emptyList();
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Additional crew requirements for vehicles and aerospace vessels for certain types of
&nbsp;     * equipment.
&nbsp;     */
&nbsp;    public static int equipmentCrewRequirements(Mounted mounted) {
&nbsp;        if (mounted.getType() instanceof MiscType) {
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_MOBILE_FIELD_BASE)) {
&nbsp;                return 5;
&nbsp;            }
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_MASH)) {
&nbsp;                return 5 * (int) mounted.getSize();
&nbsp;            }
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_FIELD_KITCHEN)) {
&nbsp;                return 3;
&nbsp;            }
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {
&nbsp;                return (int) mounted.getTonnage();
&nbsp;            }
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_MOBILE_HPG)) {
&nbsp;                // Mobile HPG has crew requirement of 10; ground-mobile has requirement of 1.
&nbsp;                return mounted.getType().hasFlag(MiscType.F_TANK_EQUIPMENT)? 1 : 10;
&nbsp;            }
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {
&nbsp;                return 6;
&nbsp;            }
&nbsp;            if (mounted.getType().hasFlag(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {
&nbsp;                return 12;
&nbsp;            }
&nbsp;        }
&nbsp;        return 0;
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Determines whether a type of equipment requires a particular location on an {@link Entity}.
&nbsp;     * What this means depends on the type of unit, but typically it does not take up a slot or
&nbsp;     * is not assigned a firing arc.
&nbsp;     * 
&nbsp;     * @param entity The Entity the equipment is to be placed on
&nbsp;     * @param eq     The equipment to place on the Entity
&nbsp;     * @return       Whether the equipment requires a location
&nbsp;     * @see #getSystemWideLocation(Entity)
&nbsp;     */
&nbsp;    public static boolean eqRequiresLocation(Entity entity, EquipmentType eq) {
&nbsp;        if (entity.hasETypeFlag(Entity.ETYPE_AERO)) {
&nbsp;            return TestAero.eqRequiresLocation(eq, entity.isFighter());
&nbsp;        } else if (entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {
&nbsp;            return TestProtomech.requiresSlot(eq);
&nbsp;        } else if (entity.hasETypeFlag(Entity.ETYPE_TANK)) {
&nbsp;            return !TestTank.isBodyEquipment(eq);
&nbsp;        }
&nbsp;        return true;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines where to place equipment that does not require a specific location. What
&nbsp;     * this means varies by {@link Entity} type.
&nbsp;     * 
&nbsp;     * @param entity  The Entity to place the equipment in
&nbsp;     * @return        The location to place equipment that is not required to be assigned a location,
&nbsp;     *                defaulting to Entity.LOC_NONE for unit types that do not have such a location.
&nbsp;     */
&nbsp;    public static int getSystemWideLocation(Entity entity) {
&nbsp;        if (entity.hasETypeFlag(Entity.ETYPE_JUMPSHIP)) {
&nbsp;            return Jumpship.LOC_HULL;
&nbsp;        } else if (entity.hasETypeFlag(Entity.ETYPE_SMALL_CRAFT)) {
&nbsp;            return SmallCraft.LOC_HULL;
&nbsp;        } else if (entity.hasETypeFlag(Entity.ETYPE_AERO)) {
&nbsp;            return Aero.LOC_FUSELAGE;
&nbsp;        } else if (entity.hasETypeFlag(Entity.ETYPE_TANK)) {
&nbsp;            return Tank.LOC_BODY;
&nbsp;        } else if (entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {
&nbsp;            return Protomech.LOC_BODY;
&nbsp;        }
&nbsp;        return Entity.LOC_NONE;
&nbsp;    }
&nbsp;
&nbsp;    private boolean hasMASC() {
&nbsp;        if (getEntity() instanceof Mech) {
&nbsp;            return ((Mech) getEntity()).hasMASC();
&nbsp;        }
&nbsp;        return false;
&nbsp;    }
&nbsp;    
&nbsp;    public String printShortMovement() {
&nbsp;        return &quot;Movement: &quot;
&nbsp;                + Integer.toString(getEntity().getOriginalWalkMP())
&nbsp;                + &quot;/&quot;
&nbsp;                + Integer.toString((int) Math.ceil(getEntity()
&nbsp;                        .getOriginalWalkMP() * 1.5))
&nbsp;                + (hasMASC() ? &quot;(&quot;
&nbsp;                        + Integer.toString(getEntity().getOriginalWalkMP() * 2)
&nbsp;                        + &quot;)&quot; : &quot;&quot;)
&nbsp;                + (getEntity().getOriginalJumpMP() != 0 ? &quot;/&quot;
&nbsp;                        + Integer.toString(getEntity().getOriginalJumpMP())
&nbsp;                        : &quot;&quot;) + &quot;\n&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public String printWeightHeatSinks() {
&nbsp;        return StringUtil.makeLength(
&nbsp;                &quot;Heat Sinks: &quot;
&nbsp;                        + Integer.toString(getCountHeatSinks())
&nbsp;                        + (hasDoubleHeatSinks() ? &quot; [&quot;
&nbsp;                                + Integer.toString(2 * getCountHeatSinks())
&nbsp;                                + &quot;]&quot; : &quot;&quot;), getPrintSize() - 5)
&nbsp;                + TestEntity.makeWeightString(getWeightHeatSinks(), usesKgStandard()) + &quot;\n&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public String printWeightEngine() {
&nbsp;        return StringUtil.makeLength(&quot;Engine: &quot; + ((null != engine) ? engine.getEngineName() : &quot;---&quot;),
&nbsp;                getPrintSize() - 5)
&nbsp;                + TestEntity.makeWeightString(getWeightEngine(), usesKgStandard()) + &quot;\n&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightEngine() {
&nbsp;        return ((null != engine) ? engine.getWeightEngine(getEntity()) : 0);
&nbsp;    }
&nbsp;
&nbsp;    public String printWeightStructure() {
&nbsp;        return StringUtil.makeLength(
&nbsp;                &quot;Structure: &quot;
&nbsp;                        + Integer.toString(getEntity().getTotalOInternal())
&nbsp;                        + &quot; &quot; + structure.getShortName(), getPrintSize() - 5)
&nbsp;                + TestEntity.makeWeightString(getWeightStructure(), usesKgStandard()) + &quot;\n&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightStructure() {
&nbsp;        return structure.getWeightStructure(getWeight(),
&nbsp;                getWeightCeilingStructure());
&nbsp;    }
&nbsp;
&nbsp;    public String printWeightArmor() {
&nbsp;        if (!getEntity().hasPatchworkArmor()) {
&nbsp;            return StringUtil.makeLength(
&nbsp;                    &quot;Armor: &quot; + Integer.toString(getTotalOArmor()) + &quot; &quot;
&nbsp;                            + armor[0].getShortName(), getPrintSize() - 5)
&nbsp;                    + TestEntity.makeWeightString(getWeightArmor(), usesKgStandard()) + &quot;\n&quot;;
&nbsp;        } else {
&nbsp;            return StringUtil.makeLength(
&nbsp;                    &quot;Armor: &quot; + Integer.toString(getTotalOArmor()) + &quot; &quot;
&nbsp;                            + &quot;Patchwork&quot;, getPrintSize() - 5)
&nbsp;                    + TestEntity.makeWeightString(getWeightArmor(), usesKgStandard()) + &quot;\n&quot;;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightArmor() {
&nbsp;        return getEntity().getLabArmorTonnage();
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightAllocatedArmor() {
&nbsp;        if (!getEntity().hasPatchworkArmor()) {
&nbsp;            return (armor[0].getWeightArmor(getTotalOArmor(), getWeightCeilingArmor()));
&nbsp;        } else {
&nbsp;            double armorWeight = 0;
&nbsp;            for (int i = 0; i &lt; armor.length; i++) {
&nbsp;                int points = getEntity().getOArmor(i);
&nbsp;                if (getEntity().hasRearArmor(i) &amp;&amp;
&nbsp;                        (getEntity().getOArmor(i, true) &gt; 0)) {
&nbsp;                    points += getEntity().getOArmor(i, true);
&nbsp;                }
&nbsp;                armorWeight += armor[i].getRawWeightArmor(points);
&nbsp;            }
&nbsp;            return TestEntity.ceilMaxHalf(armorWeight, getWeightCeilingArmor());
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gives subclasses a chance to exclude certain misc equipment if it is accounted for in a different
&nbsp;     * category.
&nbsp;     *
&nbsp;     * @param misc The misc equipment type
&nbsp;     * @return     Whether to include the equipment in the misc equipment category
&nbsp;     * @see #getWeightMiscEquip()
&nbsp;     */
&nbsp;    protected boolean includeMiscEquip(MiscType misc) {
&nbsp;        return true;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightMiscEquip() {
&nbsp;        double weightSum = 0.0;
&nbsp;        for (Mounted m : getEntity().getMisc()) {
&nbsp;            MiscType mt = (MiscType) m.getType();
&nbsp;            if (!includeMiscEquip(mt)
&nbsp;                    || mt.hasFlag(MiscType.F_ENDO_STEEL)
&nbsp;                    || mt.hasFlag(MiscType.F_ENDO_COMPOSITE)
&nbsp;                    || mt.hasFlag(MiscType.F_ENDO_STEEL_PROTO)
&nbsp;                    || mt.hasFlag(MiscType.F_ENDO_COMPOSITE)
&nbsp;                    || mt.hasFlag(MiscType.F_COMPOSITE)
&nbsp;                    || mt.hasFlag(MiscType.F_INDUSTRIAL_STRUCTURE)
&nbsp;                    || mt.hasFlag(MiscType.F_REINFORCED)
&nbsp;                    || mt.hasFlag(MiscType.F_FERRO_FIBROUS)
&nbsp;                    || mt.hasFlag(MiscType.F_FERRO_FIBROUS_PROTO)
&nbsp;                    || mt.hasFlag(MiscType.F_FERRO_LAMELLOR)
&nbsp;                    || mt.hasFlag(MiscType.F_LIGHT_FERRO)
&nbsp;                    || mt.hasFlag(MiscType.F_HEAVY_FERRO)
&nbsp;                    || mt.hasFlag(MiscType.F_REACTIVE)
&nbsp;                    || mt.hasFlag(MiscType.F_REFLECTIVE)
&nbsp;                    || mt.hasFlag(MiscType.F_HARDENED_ARMOR)
&nbsp;                    || mt.hasFlag(MiscType.F_PRIMITIVE_ARMOR)
&nbsp;                    || mt.hasFlag(MiscType.F_COMMERCIAL_ARMOR)
&nbsp;                    || mt.hasFlag(MiscType.F_INDUSTRIAL_ARMOR)
&nbsp;                    || mt.hasFlag(MiscType.F_HEAVY_INDUSTRIAL_ARMOR)
&nbsp;                    || mt.hasFlag(MiscType.F_ANTI_PENETRATIVE_ABLATIVE)
&nbsp;                    || mt.hasFlag(MiscType.F_HEAT_DISSIPATING)
&nbsp;                    || mt.hasFlag(MiscType.F_IMPACT_RESISTANT)
&nbsp;                    || mt.hasFlag(MiscType.F_BALLISTIC_REINFORCED)
&nbsp;                    || mt.hasFlag(MiscType.F_ELECTRIC_DISCHARGE_ARMOR)
&nbsp;                    || mt.hasFlag(MiscType.F_HEAT_SINK)
&nbsp;                    || mt.hasFlag(MiscType.F_DOUBLE_HEAT_SINK)
&nbsp;                    || mt.hasFlag(MiscType.F_IS_DOUBLE_HEAT_SINK_PROTOTYPE)) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            weightSum += m.getTonnage();
&nbsp;        }
&nbsp;        return weightSum;
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printMiscEquip() {
&nbsp;        return printMiscEquip(new StringBuffer());
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printMiscEquip(StringBuffer buff) {
&nbsp;        return printMiscEquip(buff, 20, getPrintSize());
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printMiscEquip(StringBuffer buff, int posLoc,
&nbsp;            int posWeight) {
&nbsp;        for (Mounted m : getEntity().getMisc()) {
&nbsp;            MiscType mt = (MiscType) m.getType();
&nbsp;
&nbsp;            if (m.getLocation() == Entity.LOC_NONE) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            if (mt.hasFlag(MiscType.F_ENDO_COMPOSITE)
&nbsp;                    || mt.hasFlag(MiscType.F_ENDO_STEEL)
&nbsp;                    || mt.hasFlag(MiscType.F_ENDO_STEEL_PROTO)
&nbsp;                    || mt.hasFlag(MiscType.F_REINFORCED)
&nbsp;                    || mt.hasFlag(MiscType.F_FERRO_FIBROUS)
&nbsp;                    || mt.hasFlag(MiscType.F_FERRO_FIBROUS_PROTO)
&nbsp;                    || mt.hasFlag(MiscType.F_LIGHT_FERRO)
&nbsp;                    || mt.hasFlag(MiscType.F_HEAVY_FERRO)
&nbsp;                    || mt.hasFlag(MiscType.F_REACTIVE)
&nbsp;                    || mt.hasFlag(MiscType.F_REFLECTIVE)
&nbsp;                    || mt.hasFlag(MiscType.F_FERRO_LAMELLOR)
&nbsp;                    || mt.hasFlag(MiscType.F_INDUSTRIAL_STRUCTURE)) {
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            if (m.getTonnage() == 0f) {
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            buff.append(StringUtil.makeLength(m.getName(), 20));
&nbsp;            buff.append(
&nbsp;                    StringUtil.makeLength(getLocationAbbr(m.getLocation()),
&nbsp;                            getPrintSize() - 5 - 20)).append(
&nbsp;                    TestEntity.makeWeightString(m.getTonnage(), usesKgStandard()));
&nbsp;            buff.append(&quot;\n&quot;);
&nbsp;        }
&nbsp;        return buff;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightWeapon() {
&nbsp;        double weight = 0.0;
&nbsp;        for (Mounted m : getEntity().getTotalWeaponList()) {
&nbsp;            if (m.isWeaponGroup()) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            weight += m.getTonnage();
&nbsp;        }
&nbsp;        return weight;
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printWeapon() {
&nbsp;        return printWeapon(new StringBuffer());
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printWeapon(StringBuffer buff) {
&nbsp;        return printWeapon(buff, 20, getPrintSize());
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printWeapon(StringBuffer buff, int posLoc, int posWeight) {
&nbsp;        for (Mounted m : getEntity().getWeaponList()) {
&nbsp;            WeaponType mt = (WeaponType) m.getType();
&nbsp;
&nbsp;            // Don&#39;t think this can happen, but ...
&nbsp;            if (m.getLocation() == Entity.LOC_NONE) {
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            buff.append(StringUtil.makeLength(mt.getName(), 20));
&nbsp;            buff.append(
&nbsp;                    StringUtil.makeLength(getLocationAbbr(m.getLocation()),
&nbsp;                            getPrintSize() - 5 - 20))
&nbsp;                    .append(TestEntity.makeWeightString(m.getTonnage(), usesKgStandard())).append(&quot;\n&quot;);
&nbsp;        }
&nbsp;        return buff;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightAmmo() {
&nbsp;        double weight = 0.0;
&nbsp;        for (Mounted m : getEntity().getAmmo()) {
&nbsp;
&nbsp;            // One Shot Ammo
&nbsp;            if (m.getLocation() == Entity.LOC_NONE) {
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            // Bombs on ASF don&#39;t count!
&nbsp;            if ((getEntity() instanceof Aero) &amp;&amp; (m.getType() instanceof BombType)) {
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            weight += m.getTonnage();
&nbsp;        }
&nbsp;        return weight;
&nbsp;    }
&nbsp;
&nbsp;    public abstract double getWeightPowerAmp();
&nbsp;
&nbsp;    public StringBuffer printAmmo() {
&nbsp;        return printAmmo(new StringBuffer());
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printAmmo(StringBuffer buff) {
&nbsp;        return printAmmo(buff, 20, getPrintSize());
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printAmmo(StringBuffer buff, int posLoc, int posWeight) {
&nbsp;        for (Mounted m : getEntity().getAmmo()) {
&nbsp;            AmmoType mt = (AmmoType) m.getType();
&nbsp;
&nbsp;            // Don&#39;t think this can happen, but ...
&nbsp;            if (m.getLocation() == Entity.LOC_NONE) {
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            buff.append(StringUtil.makeLength(mt.getName(), 20));
&nbsp;            buff.append(&quot; &quot;).append(
&nbsp;                    StringUtil.makeLength(getLocationAbbr(m.getLocation()),
&nbsp;                            getPrintSize() - 5 - 20))
&nbsp;                    .append(TestEntity.makeWeightString(m.getTonnage(), usesKgStandard())).append(&quot;\n&quot;);
&nbsp;        }
&nbsp;        return buff;
&nbsp;    }
&nbsp;
&nbsp;    public String printLocations() {
&nbsp;        StringBuffer buff = new StringBuffer();
&nbsp;        for (int i = 0; i &lt; getEntity().locations(); i++) {
&nbsp;            String locationName = getEntity().getLocationName(i);
&nbsp;            buff.append(locationName + &quot;:&quot;);
&nbsp;            buff.append(&quot;\n&quot;);
&nbsp;            for (int j = 0; j &lt; getEntity().getNumberOfCriticals(i); j++) {
&nbsp;                CriticalSlot slot = getEntity().getCritical(i, j);
&nbsp;                if (slot == null) {
&nbsp;                    buff.append(Integer.toString(j) + &quot;. -Emtpy-&quot;);
&nbsp;                    buff.append(&quot;\n&quot;);
&nbsp;                } else if (slot.getType() == CriticalSlot.TYPE_SYSTEM) {
&nbsp;                    if (isMech()) {
&nbsp;                        buff.append(Integer.toString(j));
&nbsp;                        buff.append(&quot;. &quot;);
&nbsp;                        buff.append(((Mech) getEntity()).getSystemName(slot
&nbsp;                                .getIndex()));
&nbsp;                        buff.append(&quot;\n&quot;);
&nbsp;                    } else {
&nbsp;                        buff.append(Integer.toString(j)
&nbsp;                                + &quot;. UNKNOWN SYSTEM NAME&quot;);
&nbsp;                        buff.append(&quot;\n&quot;);
&nbsp;                    }
&nbsp;                } else if (slot.getType() == CriticalSlot.TYPE_EQUIPMENT) {
&nbsp;                    EquipmentType e = getEntity().getEquipmentType(slot);
&nbsp;                    buff.append(Integer.toString(j) + &quot;. &quot;
&nbsp;                            + e.getInternalName());
&nbsp;                    buff.append(&quot;\n&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        return buff.toString();
&nbsp;    }
&nbsp;
&nbsp;    public int calcMiscCrits(MiscType mt, double size) {
&nbsp;        if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; (mt.hasSubType(MiscType.S_HATCHET)
&nbsp;                        || mt.hasSubType(MiscType.S_SWORD)
&nbsp;                        || mt.hasSubType(MiscType.S_CHAIN_WHIP) || mt
&nbsp;                            .hasSubType(MiscType.S_MACE_THB))) {
&nbsp;            return (int) Math.ceil(getWeight() / 15.0);
&nbsp;        } else if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; mt.hasSubType(MiscType.S_MACE)) {
&nbsp;            return (int) Math.ceil(getWeight() / 10.0);
&nbsp;        } else if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; mt.hasSubType(MiscType.S_RETRACTABLE_BLADE)) {
&nbsp;            return 1 + (int) Math.ceil(getWeight() / 20.0);
&nbsp;        } else if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; mt.hasSubType(MiscType.S_PILE_DRIVER)) {
&nbsp;            return 8;
&nbsp;        } else if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; mt.hasSubType(MiscType.S_CHAINSAW)) {
&nbsp;            return 5;
&nbsp;        } else if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; mt.hasSubType(MiscType.S_DUAL_SAW)) {
&nbsp;            return 7;
&nbsp;        } else if (mt.hasFlag(MiscType.F_CLUB)
&nbsp;                &amp;&amp; mt.hasSubType(MiscType.S_BACKHOE)) {
&nbsp;            return 6;
&nbsp;        } else if (mt.hasFlag(MiscType.F_MASC)) {
&nbsp;            if (mt.getInternalName().equals(&quot;ISMASC&quot;)) {
&nbsp;                return (int) Math.round(getWeight() / 20.0);
&nbsp;            } else if (mt.getInternalName().equals(&quot;CLMASC&quot;)) {
&nbsp;                return (int) Math.round(getWeight() / 25.0);
&nbsp;            }
&nbsp;        } else if (mt.hasFlag(MiscType.F_TARGCOMP)) {
&nbsp;            double fTons = 0.0f;
&nbsp;            for (Mounted mo : getEntity().getWeaponList()) {
&nbsp;                WeaponType wt = (WeaponType) mo.getType();
&nbsp;                if (wt.hasFlag(WeaponType.F_DIRECT_FIRE)) {
&nbsp;                    fTons += mo.getTonnage();
&nbsp;                }
&nbsp;            }
&nbsp;            for (Mounted mo : getEntity().getMisc()) {
&nbsp;                MiscType mt2 = (MiscType) mo.getType();
&nbsp;                if (mt2.hasFlag(MiscType.F_RISC_LASER_PULSE_MODULE)) {
&nbsp;                    fTons += mo.getTonnage();
&nbsp;                }
&nbsp;            }
&nbsp;            double weight = 0.0f;
&nbsp;            if (mt.getInternalName().equals(&quot;ISTargeting Computer&quot;)) {
&nbsp;                weight = TestEntity.ceil(fTons / 4.0f,
&nbsp;                        getWeightCeilingTargComp());
&nbsp;            } else if (mt.getInternalName().equals(&quot;CLTargeting Computer&quot;)) {
&nbsp;                weight = TestEntity.ceil(fTons / 5.0f,
&nbsp;                        getWeightCeilingTargComp());
&nbsp;            }
&nbsp;            switch (getTargCompCrits()) {
&nbsp;                case CEIL_TARGCOMP_CRITS:
&nbsp;                    return (int) Math.ceil(weight);
&nbsp;                case ROUND_TARGCOMP_CRITS:
&nbsp;                    return (int) Math.round(weight);
&nbsp;                case FLOOR_TARGCOMP_CRITS:
&nbsp;                    return (int) Math.floor(weight);
&nbsp;            }
&nbsp;        } else if (EquipmentType.getArmorTypeName(
&nbsp;                EquipmentType.T_ARMOR_FERRO_FIBROUS).equals(
&nbsp;                mt.getInternalName())) {
&nbsp;            if (isClanArmor()) {
&nbsp;                return 7;
&nbsp;            }
&nbsp;            return 14;
&nbsp;        } else if (EquipmentType.getArmorTypeName(
&nbsp;                EquipmentType.T_ARMOR_FERRO_FIBROUS_PROTO).equals(
&nbsp;                mt.getInternalName())) {
&nbsp;            return 16;
&nbsp;        } else if (EquipmentType.getArmorTypeName(
&nbsp;                EquipmentType.T_ARMOR_LIGHT_FERRO).equals(mt.getInternalName())) {
&nbsp;            return 7;
&nbsp;        } else if (EquipmentType.getArmorTypeName(
&nbsp;                EquipmentType.T_ARMOR_HEAVY_FERRO).equals(mt.getInternalName())) {
&nbsp;            return 21;
&nbsp;        } else if (mt.hasFlag(MiscType.F_ENDO_STEEL)) {
&nbsp;            if (isClan()
&nbsp;                    || mt.getInternalName()
&nbsp;                            .equals(&quot;Clan &quot;
&nbsp;                                    + EquipmentType
&nbsp;                                            .getStructureTypeName(EquipmentType.T_STRUCTURE_ENDO_STEEL))) {
&nbsp;                return 7;
&nbsp;            }
&nbsp;            return 14;
&nbsp;        } else if (mt.hasFlag(MiscType.F_ENDO_STEEL_PROTO)) {
&nbsp;            return 16;
&nbsp;        } else if (mt.hasFlag(MiscType.F_ENDO_COMPOSITE)) {
&nbsp;            if (isClan()
&nbsp;                    || mt.getInternalName()
&nbsp;                            .equals(&quot;Clan &quot;
&nbsp;                                    + EquipmentType
&nbsp;                                            .getStructureTypeName(EquipmentType.T_STRUCTURE_ENDO_COMPOSITE))) {
&nbsp;                return 4;
&nbsp;            }
&nbsp;            return 7;
&nbsp;        } else if (mt.hasFlag(MiscType.F_REACTIVE)) {
&nbsp;            if (isClanArmor()) {
&nbsp;                return 7;
&nbsp;            }
&nbsp;            return 14;
&nbsp;        } else if (mt.hasFlag(MiscType.F_REFLECTIVE)) {
&nbsp;            if (isClanArmor()) {
&nbsp;                return 5;
&nbsp;            }
&nbsp;            return 10;
&nbsp;        }
&nbsp;        return mt.getCriticals(getEntity(), size);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes heat sink requirement for heat-neutral units (vehicles, conventional fighters,
&nbsp;     * protomechs). This is a total of energy weapons that don&#39;t use ammo and some other miscellaneous
&nbsp;     * equipment.
&nbsp;     * 
&nbsp;     * @return The number of heat sinks required in construction
&nbsp;     */
&nbsp;    protected int heatNeutralHSRequirement() {
&nbsp;        return calcHeatNeutralHSRequirement(getEntity());
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes heat sink requirement for heat-neutral units (vehicles, conventional fighters,
&nbsp;     * protomechs). This is a total of energy weapons that don&#39;t use ammo and some other miscellaneous
&nbsp;     * equipment.
&nbsp;     *
&nbsp;     * @return The number of heat sinks required in construction
&nbsp;     */
&nbsp;    public static int calcHeatNeutralHSRequirement(Entity entity) {
&nbsp;        int heat = 0;
&nbsp;        for (Mounted m : entity.getWeaponList()) {
&nbsp;            WeaponType wt = (WeaponType) m.getType();
&nbsp;            if ((wt.hasFlag(WeaponType.F_LASER) &amp;&amp; (wt.getAmmoType() == AmmoType.T_NA))
&nbsp;                    || wt.hasFlag(WeaponType.F_PPC)
&nbsp;                    || wt.hasFlag(WeaponType.F_PLASMA)
&nbsp;                    || wt.hasFlag(WeaponType.F_PLASMA_MFUK)
&nbsp;                    || (wt.hasFlag(WeaponType.F_FLAMER) &amp;&amp; (wt.getAmmoType() == AmmoType.T_NA))) {
&nbsp;                heat += wt.getHeat();
&nbsp;            }
&nbsp;            // laser insulator reduce heat by 1, to a minimum of 1
&nbsp;            if (wt.hasFlag(WeaponType.F_LASER) &amp;&amp; (m.getLinkedBy() != null)
&nbsp;                    &amp;&amp; !m.getLinkedBy().isInoperable()
&nbsp;                    &amp;&amp; m.getLinkedBy().getType().hasFlag(MiscType.F_LASER_INSULATOR)) {
&nbsp;                heat -= 1;
&nbsp;                if (heat == 0) {
&nbsp;                    heat++;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            if ((m.getLinkedBy() != null) &amp;&amp; (m.getLinkedBy().getType() instanceof
&nbsp;                    MiscType) &amp;&amp; m.getLinkedBy().getType().
&nbsp;                    hasFlag(MiscType.F_PPC_CAPACITOR)) {
&nbsp;                heat += 5;
&nbsp;            }
&nbsp;        }
&nbsp;        for (Mounted m : entity.getMisc()) {
&nbsp;            // Spot welders are treated as energy weapons on units that don&#39;t have a fusion or fission engine
&nbsp;            if (m.getType().hasFlag(MiscType.F_CLUB) &amp;&amp; m.getType().hasSubType(MiscType.S_SPOT_WELDER)
&nbsp;                &amp;&amp; entity.hasEngine() &amp;&amp; (entity.getEngine().isFusion()
&nbsp;                                                || (entity.getEngine().getEngineType() == Engine.FISSION))) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            heat += m.getType().getHeat();
&nbsp;        }
&nbsp;        if (entity.hasStealth()) {
&nbsp;            heat += 10;
&nbsp;        }
&nbsp;        return heat;
&nbsp;    }
&nbsp;
&nbsp;    public double calculateWeight() {
&nbsp;        double weight = 0;
&nbsp;        weight += getWeightEngine();
&nbsp;        weight += getWeightStructure();
&nbsp;        weight += getWeightControls();
&nbsp;        weight += getWeightHeatSinks();
&nbsp;        weight += getWeightArmor();
&nbsp;        weight += getWeightMisc();
&nbsp;
&nbsp;        weight += getWeightMiscEquip();
&nbsp;        weight += getWeightWeapon();
&nbsp;        weight += getWeightAmmo();
&nbsp;        weight += getWeightPowerAmp();
&nbsp;
&nbsp;        weight += getWeightCarryingSpace();
&nbsp;
&nbsp;        weight += getArmoredComponentWeight();
&nbsp;        // If the unit used kg standard, we just need to get rid of floating-point math anomalies.
&nbsp;        // Otherwise accumulated kg-scale equipment needs to be rounded up to the nearest half-ton.
&nbsp;        weight = round(weight, Ceil.KILO);
&nbsp;        if (usesKgStandard()) {
&nbsp;            return weight;
&nbsp;        } else {
&nbsp;            return ceil(weight, Ceil.HALFTON);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public String printWeightCalculation() {
&nbsp;        return printWeightEngine() + printWeightStructure()
&nbsp;                + printWeightControls() + printWeightHeatSinks()
&nbsp;                + printWeightArmor() + printWeightMisc()
&nbsp;                + printWeightCarryingSpace() + &quot;Equipment:\n&quot;
&nbsp;                + printMiscEquip() + printWeapon() + printAmmo();
&nbsp;    }
&nbsp;
&nbsp;    public boolean correctWeight(StringBuffer buff) {
&nbsp;        return correctWeight(buff, showOverweightedEntity(),
&nbsp;                showUnderweightedEntity());
&nbsp;    }
&nbsp;
&nbsp;    public boolean correctWeight(StringBuffer buff, boolean showO, boolean showU) {
&nbsp;        double weightSum = calculateWeight();
&nbsp;        double weight = getWeight();
&nbsp;
&nbsp;        if (showO &amp;&amp; ((weight + getMaxOverweight()) &lt; weightSum)) {
&nbsp;            buff.append(&quot;Weight: &quot;).append(calculateWeight())
&nbsp;                    .append(&quot; is greater than &quot;).append(getWeight())
&nbsp;                    .append(&quot;\n&quot;);
&nbsp;            // buff.append(printWeightCalculation()).append(&quot;\n&quot;);
&nbsp;            return false;
&nbsp;        }
&nbsp;        if (showU &amp;&amp; ((weight - getMinUnderweight()) &gt; weightSum)) {
&nbsp;            buff.append(&quot;Weight: &quot;).append(calculateWeight())
&nbsp;                    .append(&quot; is less than &quot;).append(getWeight()).append(&quot;\n&quot;);
&nbsp;            // buff.append(printWeightCalculation()).append(&quot;\n&quot;);
&nbsp;            return false;
&nbsp;        }
&nbsp;        return true;
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasIllegalTechLevels(StringBuffer buff) {
&nbsp;        return hasIllegalTechLevels(buff, getEntity().getTechLevel());
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasIllegalTechLevels(StringBuffer buff, int ammoTechLvl) {
&nbsp;        /* A large number of units have official tech levels lower than their components at the
&nbsp;         * intro date. We test instead whether the stated tech level is ever possible based on the
&nbsp;         * equipment. We also test for mixed IS/Clan tech in units that are not designated as mixed.
&nbsp;         */
&nbsp;        boolean retVal = false;
&nbsp;        int eTechLevel = SimpleTechLevel.convertCompoundToSimple(getEntity().getTechLevel()).ordinal();
&nbsp;        int ammoRulesLevel = SimpleTechLevel.convertCompoundToSimple(ammoTechLvl).ordinal();
&nbsp;        int eRulesLevel = getEntity().findMinimumRulesLevel().ordinal();
&nbsp;        if ((eTechLevel &gt;= eRulesLevel) &amp;&amp; (getEntity().getEarliestTechDate() &lt;= getEntity().getYear())) {
&nbsp;            return false;
&nbsp;        }
&nbsp;        
&nbsp;        int eTLYear = getEntity().getTechLevelYear();
&nbsp;        for (Mounted mounted : getEntity().getEquipment()) {
&nbsp;            EquipmentType nextE = mounted.getType();
&nbsp;            int eqRulesLevel = getEntity().isMixedTech()?
&nbsp;                    nextE.findMinimumRulesLevel().ordinal() : nextE.findMinimumRulesLevel(getEntity().isClan()).ordinal();
&nbsp;            boolean illegal = eqRulesLevel &gt; eRulesLevel;
&nbsp;            if (!getEntity().isMixedTech()) {
&nbsp;                illegal |= getEntity().isClan() &amp;&amp; nextE.getTechBase() == ITechnology.TECH_BASE_IS;
&nbsp;                illegal |= !getEntity().isClan() &amp;&amp; nextE.getTechBase() == ITechnology.TECH_BASE_CLAN;
&nbsp;            }
&nbsp;            int eqTechLevel = TechConstants.convertFromSimplelevel(eqRulesLevel, nextE.isClan());
&nbsp;            if (nextE instanceof AmmoType) {
&nbsp;                if (eqRulesLevel &gt; ammoRulesLevel) {
&nbsp;                    if (!retVal) {
&nbsp;                        buff.append(&quot;Ammo illegal at unit&#39;s tech level (&quot;);
&nbsp;                        buff.append(TechConstants
&nbsp;                                .getLevelDisplayableName(ammoTechLvl));
&nbsp;                        buff.append(&quot;, &quot;);
&nbsp;                        buff.append(eTLYear);
&nbsp;                        buff.append(&quot;):\n&quot;);
&nbsp;                    }
&nbsp;                    retVal = true;
&nbsp;                    buff.append(nextE.getName());
&nbsp;                    buff.append(&quot;, (&quot;);
&nbsp;                    buff.append(TechConstants
&nbsp;                            .getLevelDisplayableName(eqTechLevel));
&nbsp;                    buff.append(&quot;)\n&quot;);
&nbsp;                }
&nbsp;            } else if (illegal) {
&nbsp;                if (!retVal) {
&nbsp;                    buff.append(&quot;Equipment illegal at unit&#39;s tech level &quot;);
&nbsp;                    buff.append(TechConstants
&nbsp;                            .getLevelDisplayableName(ammoTechLvl));
&nbsp;                    buff.append(&quot;, &quot;);
&nbsp;                    buff.append(eTLYear);
&nbsp;                    buff.append(&quot;):\n&quot;);
&nbsp;                }
&nbsp;                retVal = true;
&nbsp;                buff.append(nextE.getName());
&nbsp;                buff.append(&quot;, (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(eqTechLevel));
&nbsp;                buff.append(&quot;)\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        // Check cockpit TL
&nbsp;        ITechnology cockpit = null;
&nbsp;        String cockpitName = null;
&nbsp;        if (getEntity().getEntityType() == Entity.ETYPE_AERO) {
&nbsp;            cockpit = ((Aero)getEntity()).getCockpitTechAdvancement();
&nbsp;            cockpitName = ((Aero)getEntity()).getCockpitTypeString();
&nbsp;        } else if (getEntity() instanceof Mech) {
&nbsp;            cockpit = ((Mech)getEntity()).getCockpitTechAdvancement();
&nbsp;            cockpitName = ((Mech)getEntity()).getCockpitTypeString();
&nbsp;        }
&nbsp;        if (cockpit != null) {
&nbsp;            int eqRulesLevel = getEntity().isMixedTech()?
&nbsp;                    cockpit.findMinimumRulesLevel().ordinal() : cockpit.findMinimumRulesLevel(getEntity().isClan()).ordinal();
&nbsp;            boolean illegal = eqRulesLevel &gt; eRulesLevel;
&nbsp;            if (!getEntity().isMixedTech()) {
&nbsp;                illegal |= getEntity().isClan() &amp;&amp; cockpit.getTechBase() == ITechnology.TECH_BASE_IS;
&nbsp;                illegal |= !getEntity().isClan() &amp;&amp; cockpit.getTechBase() == ITechnology.TECH_BASE_CLAN;                
&nbsp;            }
&nbsp;            if (illegal) {
&nbsp;                buff.append(&quot;Cockpit is illegal at unit&#39;s tech level (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(eTechLevel));
&nbsp;                buff.append(&quot;, &quot;);
&nbsp;                buff.append(eTLYear);
&nbsp;                buff.append(&quot;): &quot;);
&nbsp;                buff.append(cockpitName);
&nbsp;                buff.append(&quot; (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(TechConstants.convertFromSimplelevel(eqRulesLevel, cockpit.isClan())));
&nbsp;                buff.append(&quot;)\n&quot;);
&nbsp;                retVal = true;
&nbsp;            }
&nbsp;        }
&nbsp;        if (getEntity() instanceof Mech) {
&nbsp;            ITechnology gyro = ((Mech)getEntity()).getGyroTechAdvancement();
&nbsp;            if (gyro != null) {
&nbsp;                int eqRulesLevel = getEntity().isMixedTech()?
&nbsp;                        gyro.findMinimumRulesLevel().ordinal() : gyro.findMinimumRulesLevel(getEntity().isClan()).ordinal();
&nbsp;                boolean illegal = eqRulesLevel &gt; eRulesLevel;
&nbsp;                if (!getEntity().isMixedTech()) {
&nbsp;                    illegal |= getEntity().isClan() &amp;&amp; gyro.getTechBase() == ITechnology.TECH_BASE_IS;
&nbsp;                    illegal |= !getEntity().isClan() &amp;&amp; gyro.getTechBase() == ITechnology.TECH_BASE_CLAN;                
&nbsp;                }
&nbsp;                if (illegal) {
&nbsp;                    buff.append(&quot;Gyro is illegal at unit&#39;s tech level (&quot;);
&nbsp;                    buff.append(TechConstants
&nbsp;                            .getLevelDisplayableName(eTechLevel));
&nbsp;                    buff.append(&quot;, &quot;);
&nbsp;                    buff.append(eTLYear);
&nbsp;                    buff.append(&quot;): &quot;);
&nbsp;                    buff.append(((Mech)getEntity()).getGyroTypeString());
&nbsp;                    buff.append(&quot; (&quot;);
&nbsp;                    buff.append(TechConstants
&nbsp;                            .getLevelDisplayableName(TechConstants.convertFromSimplelevel(eqRulesLevel,
&nbsp;                                    gyro.isClan())));
&nbsp;                    buff.append(&quot;)\n&quot;);
&nbsp;                    retVal = true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        if (getEntity().hasEngine()) {
&nbsp;            ITechnology engine = getEntity().getEngine().getTechAdvancement();
&nbsp;            int eqRulesLevel = getEntity().isMixedTech()?
&nbsp;                    engine.findMinimumRulesLevel().ordinal() : engine.findMinimumRulesLevel(getEntity().isClan()).ordinal();
&nbsp;            boolean illegal = eqRulesLevel &gt; eRulesLevel;
&nbsp;            if (!getEntity().isMixedTech()) {
&nbsp;                illegal |= getEntity().isClan() &amp;&amp; engine.getTechBase() == ITechnology.TECH_BASE_IS;
&nbsp;                illegal |= !getEntity().isClan() &amp;&amp; engine.getTechBase() == ITechnology.TECH_BASE_CLAN;                
&nbsp;            }
&nbsp;            if (illegal) {
&nbsp;                buff.append(&quot;Engine is illegal at unit&#39;s tech level (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(eTechLevel));
&nbsp;                buff.append(&quot;, &quot;);
&nbsp;                buff.append(eTLYear);
&nbsp;                buff.append(&quot;): &quot;);
&nbsp;                buff.append(getEntity().getEngine().getShortEngineName());
&nbsp;                buff.append(&quot; (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(TechConstants.convertFromSimplelevel(eqRulesLevel,
&nbsp;                                engine.isClan())));
&nbsp;                buff.append(&quot;)\n&quot;);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;                retVal = true;
&nbsp;            }
&nbsp;        }
&nbsp;        Set&lt;String&gt; armors;
&nbsp;        if (!getEntity().hasPatchworkArmor()) {
&nbsp;            armors = Collections.singleton(EquipmentType.getArmorTypeName(getEntity().getArmorType(1),
&nbsp;                    TechConstants.isClan(getEntity().getArmorTechLevel(1))));
&nbsp;        } else {
&nbsp;            int eqRulesLevel = getEntity().isMixedTech()?
&nbsp;                    Entity.getPatchworkArmorAdvancement().findMinimumRulesLevel().ordinal() :
&nbsp;                        Entity.getPatchworkArmorAdvancement().findMinimumRulesLevel(getEntity().isClan()).ordinal();
&nbsp;            if (eqRulesLevel &gt; eRulesLevel) {
&nbsp;                buff.append(&quot;Armor is illegal at unit&#39;s tech level (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(eTechLevel));
&nbsp;                buff.append(&quot;, &quot;);
&nbsp;                buff.append(eTLYear);
&nbsp;                buff.append(&quot;): Patchwork (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(TechConstants.convertFromSimplelevel(eqRulesLevel,
&nbsp;                                getEntity().isClan())));
&nbsp;                buff.append(&quot;)\n&quot;);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;                retVal = true;
&nbsp;            }
&nbsp;            
&nbsp;            armors = new HashSet&lt;&gt;();
&nbsp;            for (int loc = 0; loc &lt; getEntity().locations(); loc++) {
&nbsp;                armors.add(EquipmentType.getArmorTypeName(getEntity().getArmorType(loc),
&nbsp;                        TechConstants.isClan(getEntity().getArmorTechLevel(loc))));
&nbsp;            }
&nbsp;        }
&nbsp;        for (String atName : armors) {
&nbsp;            EquipmentType at = EquipmentType.get(atName);
&nbsp;            // Can be null in the case of vehicle body or asf wings.   
&nbsp;            if (null ==  at) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            int eqRulesLevel = getEntity().isMixedTech()?
&nbsp;                    at.findMinimumRulesLevel().ordinal() : at.findMinimumRulesLevel(getEntity().isClan()).ordinal();
&nbsp;            boolean illegal = eqRulesLevel &gt; eRulesLevel;
&nbsp;            if (!getEntity().isMixedTech()) {
&nbsp;                illegal |= getEntity().isClan() &amp;&amp; at.getTechBase() == ITechnology.TECH_BASE_IS;
&nbsp;                illegal |= !getEntity().isClan() &amp;&amp; at.getTechBase() == ITechnology.TECH_BASE_CLAN;                
&nbsp;            }
&nbsp;            if (illegal) {
&nbsp;                buff.append(&quot;Armor is illegal at unit&#39;s tech level (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(eTechLevel));
&nbsp;                buff.append(&quot;, &quot;);
&nbsp;                buff.append(eTLYear);
&nbsp;                buff.append(&quot;): &quot;);
&nbsp;                buff.append(atName);
&nbsp;                buff.append(&quot; (&quot;);
&nbsp;                buff.append(TechConstants
&nbsp;                        .getLevelDisplayableName(TechConstants.convertFromSimplelevel(eqRulesLevel,
&nbsp;                                at.isClan())));
&nbsp;                buff.append(&quot;)\n&quot;);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;                retVal = true;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return retVal;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compares intro dates of all components to the unit intro year.
&nbsp;     * 
&nbsp;     * @param buff Descriptions of problems will be added to the buffer.
&nbsp;     * @return     Whether the unit has an intro year equal to or later than all the components.
&nbsp;     */
&nbsp;    public boolean hasIncorrectIntroYear(StringBuffer buff) {
&nbsp;        boolean retVal = false;
&nbsp;        if (getEntity().getEarliestTechDate() &lt;= getEntity().getYear() + getIntroYearMargin()) {
&nbsp;            return false;
&nbsp;        }
&nbsp;        int useIntroYear = getEntity().getYear() + getIntroYearMargin();
&nbsp;        if (getEntity().isOmni()) {
&nbsp;            int introDate = Entity.getOmniAdvancement(getEntity())
&nbsp;                    .getIntroductionDate(getEntity().isClan() || getEntity().isMixedTech());
&nbsp;            if (useIntroYear &lt; introDate) {
&nbsp;                retVal = true;
&nbsp;                buff.append(&quot;Omni technology has intro date of &quot;);
&nbsp;                buff.append(introDate);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        Set&lt;EquipmentType&gt; checked = new HashSet&lt;&gt;();
&nbsp;        for (Mounted mounted : getEntity().getEquipment()) {
&nbsp;            final EquipmentType nextE = mounted.getType();
&nbsp;            if (checked.contains(nextE) || (nextE instanceof AmmoType)) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            checked.add(nextE);
&nbsp;            int introDate = nextE.getIntroductionDate(getEntity().isClan());
&nbsp;            if (getEntity().isMixedTech()) {
&nbsp;                introDate = nextE.getIntroductionDate();
&nbsp;            }
&nbsp;            if (introDate &gt; useIntroYear) {
&nbsp;                retVal = true;
&nbsp;                buff.append(nextE.getName());
&nbsp;                buff.append(&quot; has intro date of &quot;);
&nbsp;                buff.append(introDate);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        Set&lt;String&gt; armors;
&nbsp;        if (!getEntity().hasPatchworkArmor()) {
&nbsp;            armors = Collections.singleton(EquipmentType.getArmorTypeName(getEntity().getArmorType(1),
&nbsp;                    TechConstants.isClan(getEntity().getArmorTechLevel(1))));
&nbsp;        } else {
&nbsp;            int intro = getEntity().isMixedTech()?
&nbsp;                    Entity.getPatchworkArmorAdvancement().getIntroductionDate() :
&nbsp;                        Entity.getPatchworkArmorAdvancement().getIntroductionDate(getEntity().isClan());
&nbsp;            if (useIntroYear &lt; intro) {
&nbsp;                retVal = true;
&nbsp;                buff.append(&quot;Patchwork armor has intro date of &quot;);
&nbsp;                buff.append(intro);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;            }
&nbsp;            armors = new HashSet&lt;&gt;();
&nbsp;            for (int loc = 0; loc &lt; getEntity().locations(); loc++) {
&nbsp;                armors.add(EquipmentType.getArmorTypeName(getEntity().getArmorType(loc),
&nbsp;                        TechConstants.isClan(getEntity().getArmorTechLevel(loc))));
&nbsp;            }
&nbsp;        }
&nbsp;        for (String atName : armors) {
&nbsp;            EquipmentType at = EquipmentType.get(atName);
&nbsp;            if (checked.contains(at)) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            checked.add(at);
&nbsp;            // Can be null in the case of vehicle body or asf wings.   
&nbsp;            if (null ==  at) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            int introDate = at.getIntroductionDate(getEntity().isClan());
&nbsp;            if (getEntity().isMixedTech()) {
&nbsp;                introDate = at.getIntroductionDate();
&nbsp;            }
&nbsp;            if (introDate &gt; useIntroYear) {
&nbsp;                retVal = true;
&nbsp;                buff.append(at.getName());
&nbsp;                buff.append(&quot; armor has intro date of &quot;);
&nbsp;                buff.append(introDate);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        // Check cockpit TL
&nbsp;        ITechnology cockpit = null;
&nbsp;        String cockpitName = null;
&nbsp;        if ((getEntity() instanceof Aero) &amp;&amp; !getEntity().isSupportVehicle()) {
&nbsp;            cockpit = ((Aero)getEntity()).getCockpitTechAdvancement();
&nbsp;            cockpitName = ((Aero)getEntity()).getCockpitTypeString();
&nbsp;        } else if (getEntity() instanceof Mech) {
&nbsp;            cockpit = ((Mech)getEntity()).getCockpitTechAdvancement();
&nbsp;            cockpitName = ((Mech)getEntity()).getCockpitTypeString();
&nbsp;        }
&nbsp;        if (null != cockpit) {
&nbsp;            int introDate = cockpit.getIntroductionDate(getEntity().isClan());
&nbsp;            if (getEntity().isMixedTech()) {
&nbsp;                introDate = cockpit.getIntroductionDate();
&nbsp;            }
&nbsp;            if (introDate &gt; useIntroYear) {
&nbsp;                retVal = true;
&nbsp;                buff.append(cockpitName);
&nbsp;                buff.append(&quot; has intro date of &quot;);
&nbsp;                buff.append(introDate);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        if (getEntity() instanceof Mech) {
&nbsp;            ITechnology gyro = ((Mech)getEntity()).getGyroTechAdvancement();
&nbsp;            if (null != gyro) {
&nbsp;                int introDate = gyro.getIntroductionDate(getEntity().isClan());
&nbsp;                if (getEntity().isMixedTech()) {
&nbsp;                    introDate = gyro.getIntroductionDate();
&nbsp;                }
&nbsp;                if (introDate &gt; useIntroYear) {
&nbsp;                    retVal = true;
&nbsp;                    buff.append(((Mech)getEntity()).getGyroTypeString());
&nbsp;                    buff.append(&quot; has intro date of &quot;);
&nbsp;                    buff.append(introDate);
&nbsp;                    buff.append(&quot;\n&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        if (getEntity().hasEngine()) {
&nbsp;            ITechnology engine = getEntity().getEngine().getTechAdvancement();
&nbsp;            int introDate = engine.getIntroductionDate(getEntity().isClan());
&nbsp;            if (getEntity().isMixedTech()) {
&nbsp;                introDate = engine.getIntroductionDate();
&nbsp;            }
&nbsp;            if (introDate &gt; useIntroYear) {
&nbsp;                retVal = true;
&nbsp;                buff.append(getEntity().getEngine().getShortEngineName());
&nbsp;                buff.append(&quot; has intro date of &quot;);
&nbsp;                buff.append(introDate);
&nbsp;                buff.append(&quot;\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return retVal;
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasFailedEquipment(StringBuffer buff) {
&nbsp;        boolean hasFailedEquipment = false;
&nbsp;        for (Iterator&lt;String&gt; e = getEntity().getFailedEquipment(); e.hasNext();) {
&nbsp;            String name = e.next();
&nbsp;            if (!ignoreFailedEquip(name)) {
&nbsp;                if (!hasFailedEquipment) {
&nbsp;                    buff.append(&quot;Equipment that Failed to Load:\n&quot;);
&nbsp;                }
&nbsp;                buff.append(name).append(&quot;\n&quot;);
&nbsp;                hasFailedEquipment = true;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return hasFailedEquipment;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the unit has combinations of equipment which are not allowed in
&nbsp;     * the construction rules.
&nbsp;     *
&nbsp;     * @param buff
&nbsp;     *            diagnostics are appended to this
&nbsp;     * @return true if the entity is illegal
&nbsp;     */
&nbsp;    public boolean hasIllegalEquipmentCombinations(StringBuffer buff) {
&nbsp;        boolean illegal = false;
&nbsp;        int fieldKitchenCount = 0;
&nbsp;        int minesweeperCount = 0;
&nbsp;        boolean hasHarjelII = false;
&nbsp;        boolean hasHarjelIII = false;
&nbsp;        boolean hasCoolantPod = false;
&nbsp;        int emergencyCoolantCount = 0;
&nbsp;        int networks = 0;
&nbsp;        boolean countedC3 = false;
&nbsp;        int robotics = 0;
&nbsp;        boolean hasExternalFuelTank = false;
&nbsp;        int liftHoists = 0;
&nbsp;        Map&lt;Integer, Integer&gt; bridgeLayersByLocation = new HashMap&lt;&gt;();
&nbsp;        Map&lt;Integer, List&lt;EquipmentType&gt;&gt; physicalWeaponsByLocation = new HashMap&lt;&gt;();
&nbsp;
&nbsp;        for (Mounted m : getEntity().getAmmo()) {
&nbsp;            if (((AmmoType)m.getType()).getAmmoType() == AmmoType.T_COOLANT_POD) {
&nbsp;                hasCoolantPod = true;
&nbsp;            }
&nbsp;        }
&nbsp;        for (Mounted m : getEntity().getMisc()) {
&nbsp;            if (m.getType().hasFlag(MiscType.F_EMERGENCY_COOLANT_SYSTEM)) {
&nbsp;                emergencyCoolantCount++;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_FIELD_KITCHEN)) {
&nbsp;                fieldKitchenCount++;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_MINESWEEPER)) {
&nbsp;                minesweeperCount++;
&nbsp;            }
&nbsp;
&nbsp;            if (m.getType().hasFlag(MiscType.F_LIGHT_FLUID_SUCTION_SYSTEM)) {
&nbsp;                if (getEntity() instanceof Protomech) {
&nbsp;                    illegal = true;
&nbsp;                    buff.append(&quot;ProtoMech can&#39;t mount light fluid suction system\n&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_VOIDSIG)
&nbsp;                    &amp;&amp; !getEntity().hasWorkingMisc(MiscType.F_ECM)) {
&nbsp;                illegal = true;
&nbsp;                buff.append(&quot;void signature system needs ECM suite\n&quot;);
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_HARJEL_II)) {
&nbsp;                hasHarjelII = true;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_HARJEL_III)) {
&nbsp;                hasHarjelIII = true;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_FUEL)) {
&nbsp;                hasExternalFuelTank = true;
&nbsp;            }
&nbsp;            if ((m.getType().hasFlag(MiscType.F_C3S) || m.getType().hasFlag(MiscType.F_C3SBS)) &amp;&amp; !countedC3) {
&nbsp;                networks++;
&nbsp;                countedC3 = true;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_C3I) || m.getType().hasFlag(MiscType.F_NOVA)) {
&nbsp;                networks++;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_SRCS) || m.getType().hasFlag(MiscType.F_SASRCS)
&nbsp;                    || m.getType().hasFlag(MiscType.F_CASPAR) || m.getType().hasFlag(MiscType.F_CASPARII)) {
&nbsp;                robotics++;
&nbsp;            }
&nbsp;            if (m.getType().hasFlag(MiscType.F_LIFTHOIST)) {
&nbsp;                liftHoists++;
&nbsp;            } else if ((m.getLocation() &gt; 0)
&nbsp;                    &amp;&amp; ((m.getType().hasFlag(MiscType.F_CLUB) &amp;&amp; !((MiscType) m.getType()).isShield())
&nbsp;                    || m.getType().hasFlag(MiscType.F_BULLDOZER)
&nbsp;                    || m.getType().hasFlag(MiscType.F_HAND_WEAPON))) {
&nbsp;                physicalWeaponsByLocation.computeIfAbsent(m.getLocation(), ArrayList::new).add(m.getType());
&nbsp;            } else if (m.getType().hasFlag(MiscType.F_LIGHT_BRIDGE_LAYER)
&nbsp;                    || m.getType().hasFlag(MiscType.F_MEDIUM_BRIDGE_LAYER)
&nbsp;                    || m.getType().hasFlag(MiscType.F_HEAVY_BRIDGE_LAYER)) {
&nbsp;                bridgeLayersByLocation.merge(m.getLocation(), 1, Integer::sum);
&nbsp;            }
&nbsp;        }
&nbsp;        if ((networks &gt; 0) &amp;&amp; !countedC3) {
&nbsp;            for (Mounted m : getEntity().getIndividualWeaponList()) {
&nbsp;                if (m.getType().hasFlag(WeaponType.F_C3M) || m.getType().hasFlag(WeaponType.F_C3MBS)) {
&nbsp;                    networks++;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        if ((isMech() || isTank() || isAero())
&nbsp;                &amp;&amp; (!getEntity().hasEngine()
&nbsp;                        || (!getEntity().getEngine().isFusion()
&nbsp;                                &amp;&amp; (getEntity().getEngine().getEngineType() != Engine.FISSION)))) {
&nbsp;            for (Mounted m : getEntity().getWeaponList()) {
&nbsp;                if (((WeaponType) m.getType()).getAmmoType() == AmmoType.T_IGAUSS_HEAVY) {
&nbsp;                    buff.append(&quot;Improved Heavy Gauss requires a fusion or fission engine.\n&quot;);
&nbsp;                    illegal = true;
&nbsp;                } else if (m.getType().hasFlag(WeaponType.F_FLAMER)
&nbsp;                        &amp;&amp; (((WeaponType) m.getType()).getAmmoType() == AmmoType.T_NA)
&nbsp;                        &amp;&amp; (!getEntity().hasEngine() || (!getEntity().getEngine().isFusion()
&nbsp;                                &amp;&amp; (getEntity().getEngine().getEngineType() != Engine.FISSION)))) {
&nbsp;                    buff.append(&quot;Standard flamers require a fusion or fission engine.\n&quot;);
&nbsp;                    illegal = true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        if (hasExternalFuelTank
&nbsp;                &amp;&amp; (!getEntity().hasEngine() ||((getEntity().getEngine().getEngineType() != Engine.COMBUSTION_ENGINE)
&nbsp;                &amp;&amp; (getEntity().getEngine().getEngineType() != Engine.FUEL_CELL)))) {
&nbsp;            illegal = true;
&nbsp;            buff.append(&quot;Extended fuel tanks can only be used with internal combustion or fuel cell engines.\n&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (minesweeperCount &gt; 1) {
&nbsp;            buff.append(&quot;Unit has more than one minesweeper!\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if (fieldKitchenCount &gt; 3) {
&nbsp;            buff.append(&quot;Unit has more than three Field Kitchens\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;
&nbsp;        if (hasCoolantPod &amp;&amp; (emergencyCoolantCount &gt; 0)) {
&nbsp;            buff.append(&quot;Unit has coolant pod and RISC emergency coolant system\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if (emergencyCoolantCount &gt; 1) {
&nbsp;            buff.append(&quot;Unit has more than one RISC emergency coolant system\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if (!(getEntity() instanceof Mech) &amp;&amp; (hasHarjelII || hasHarjelIII)) {
&nbsp;            buff.append(&quot;Cannot mount HarJel repair system on non-Mech\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if (networks &gt; 1) {
&nbsp;            buff.append(&quot;Cannot have multiple network types on the same unit.\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if (robotics &gt; 1) {
&nbsp;            buff.append(&quot;Unit has multiple drone control systems.\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if (getEntity().hasStealth() &amp;&amp; !getEntity().hasWorkingMisc(MiscType.F_ECM)) {
&nbsp;            buff.append(&quot;Stealth armor requires an ECM generator.\n&quot;);
&nbsp;            illegal = true;
&nbsp;        }
&nbsp;        if ((getEntity() instanceof Mech) &amp;&amp; (liftHoists &gt; 2)) {
&nbsp;            illegal = true;
&nbsp;            buff.append(&quot;Can mount a maximum of two lift hoists.\n&quot;);
&nbsp;        } else if ((getEntity().isSupportVehicle() || (getEntity() instanceof Tank)) &amp;&amp; (liftHoists &gt; 4)) {
&nbsp;            illegal = true;
&nbsp;            buff.append(&quot;Can mount a maximum of four lift hoists.\n&quot;);
&nbsp;        }
&nbsp;        for (List&lt;EquipmentType&gt; list : physicalWeaponsByLocation.values()) {
&nbsp;            if (list.size() &gt; 1) {
&nbsp;                illegal = true;
&nbsp;                buff.append(list.stream().map(EquipmentType::getName).collect(Collectors.joining(&quot;, &quot;)))
&nbsp;                        .append(&quot; cannot be mounted in the same location.\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        for (int count : bridgeLayersByLocation.values()) {
&nbsp;            if (count &gt; 1) {
&nbsp;                illegal = true;
&nbsp;                buff.append(&quot;Cannot mount more than one bridge builder in the same location.\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        if (getEntity().isOmni()) {
&nbsp;            for (Mounted m : getEntity().getEquipment()) {
&nbsp;                if (m.isOmniPodMounted() &amp;&amp; m.getType().isOmniFixedOnly()) {
&nbsp;                    illegal = true;
&nbsp;                    buff.append(m.getType().getName()).append(&quot; cannot be pod mounted.&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
&nbsp;            for (Mounted m : getEntity().getEquipment()) {
&nbsp;                if (m.isOmniPodMounted()) {
&nbsp;                    buff.append(m.getType().getName()).append(&quot; is pod mounted in non-omni unit\n&quot;);
&nbsp;                    illegal = true;
&nbsp;                }
&nbsp;            }
&nbsp;            for (Transporter t : getEntity().getTransports()) {
&nbsp;                if (getEntity().isPodMountedTransport(t)) {
&nbsp;                    buff.append(&quot;Pod mounted troop space in non-omni unit\n&quot;);
&nbsp;                    illegal = true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        for (Mounted mounted : getEntity().getEquipment()) {
&nbsp;            if (mounted.getLocation() &gt; Entity.LOC_NONE) {
&nbsp;                illegal |= !isValidLocation(getEntity(), mounted.getType(), mounted.getLocation(), buff);
&nbsp;            }
&nbsp;        }
&nbsp;        return illegal;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param entity    The entity
&nbsp;     * @param eq        The equipment
&nbsp;     * @param location  A location index on the Entity
&nbsp;     * @param buffer    If non-null and the location is invalid, will be appended with an explanation
&nbsp;     * @return          Whether the equipment can be mounted in the location on the Entity
&nbsp;     */
&nbsp;    public static boolean isValidLocation(Entity entity, EquipmentType eq, int location,
&nbsp;                                          @Nullable StringBuffer buffer) {
&nbsp;        if (entity instanceof Mech) {
&nbsp;            return TestMech.isValidMechLocation((Mech) entity, eq, location, buffer);
&nbsp;        } else if (entity instanceof Tank) {
&nbsp;            return TestTank.isValidTankLocation((Tank) entity, eq, location, buffer);
&nbsp;        } else if (entity instanceof Protomech) {
&nbsp;            return TestProtomech.isValidProtomechLocation((Protomech) entity, eq, location, buffer);
&nbsp;        } else if (entity.isFighter()) {
&nbsp;            return TestAero.isValidAeroLocation(eq, location, buffer);
&nbsp;        }
&nbsp;        return true;
&nbsp;    }
&nbsp;
&nbsp;    public StringBuffer printFailedEquipment(StringBuffer buff) {
&nbsp;        if (getEntity().getFailedEquipment().hasNext()) {
&nbsp;            buff.append(&quot;Equipment that Failed to Load:\n&quot;);
&nbsp;        }
&nbsp;        for (Iterator&lt;String&gt; e = getEntity().getFailedEquipment(); e.hasNext();) {
&nbsp;            buff.append(e.next()).append(&quot;\n&quot;);
&nbsp;        }
&nbsp;        return buff;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightCarryingSpace() {
&nbsp;        double weight = getEntity().getTroopCarryingSpace();
&nbsp;        for (Bay bay : getEntity().getTransportBays()) {
&nbsp;            if (!bay.isQuarters()) {
&nbsp;                TestEntity.ceil(weight += bay.getWeight(), Ceil.KILO);
&nbsp;            }
&nbsp;        }
&nbsp;        return weight;
&nbsp;    }
&nbsp;
&nbsp;    public String printWeightCarryingSpace() {
&nbsp;        String carryingSpace = &quot;&quot;;
&nbsp;        if (getEntity().getTroopCarryingSpace() != 0) {
&nbsp;            carryingSpace = StringUtil.makeLength(&quot;Carrying Capacity:&quot;,
&nbsp;                    getPrintSize() - 5)
&nbsp;                    + TestEntity.makeWeightString(getEntity()
&nbsp;                            .getTroopCarryingSpace(), usesKgStandard()) + &quot;\n&quot;;
&nbsp;        }
&nbsp;        String cargoWeightString = &quot;&quot;;
&nbsp;        double cargoWeight = 0;
&nbsp;        for (Bay bay : getEntity().getTransportBays()) {
&nbsp;            cargoWeight += bay.getWeight();
&nbsp;        }
&nbsp;        if (cargoWeight &gt; 0) {
&nbsp;            cargoWeightString = StringUtil.makeLength(&quot;Cargo Weight:&quot;,
&nbsp;                    getPrintSize() - 5)
&nbsp;                    + TestEntity.makeWeightString(cargoWeight, usesKgStandard()) + &quot;\n&quot;;
&nbsp;        }
&nbsp;        return carryingSpace + cargoWeightString;
&nbsp;    }
&nbsp;
&nbsp;    public String printArmorLocation(int loc) {
&nbsp;        if (getEntity().hasRearArmor(loc)) {
&nbsp;            return StringUtil.makeLength(
&nbsp;                    getEntity().getLocationAbbr(loc) + &quot;:&quot;, 5)
&nbsp;                    + StringUtil.makeLength(getEntity().getOInternal(loc), 4)
&nbsp;                    + StringUtil.makeLength(getEntity().getOArmor(loc), 3)
&nbsp;                    + &quot; / &quot;
&nbsp;                    + StringUtil
&nbsp;                            .makeLength(getEntity().getOArmor(loc, true), 2);
&nbsp;        }
&nbsp;        return StringUtil.makeLength(getEntity().getLocationAbbr(loc) + &quot;:&quot;, 5)
&nbsp;                + StringUtil.makeLength(getEntity().getOInternal(loc), 4)
&nbsp;                + StringUtil.makeLength(getEntity().getOArmor(loc), 6) + &quot;  &quot;;
&nbsp;    }
&nbsp;
&nbsp;    public String printArmorPlacement() {
&nbsp;        StringBuffer buff = new StringBuffer();
&nbsp;        buff.append(&quot;Armor Placement:\n&quot;);
&nbsp;        for (int loc = 0; loc &lt; getEntity().locations(); loc++) {
&nbsp;            buff.append(printArmorLocation(loc)).append(&quot;\n&quot;);
&nbsp;        }
&nbsp;        return buff.toString();
&nbsp;    }
&nbsp;
&nbsp;    public String printSource(){
&nbsp;        return &quot;Source: &quot; + getEntity().getSource() + &quot;\n&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public String printTechLevel() {
&nbsp;        return &quot;Chassis: &quot; + getEntity().getDisplayName() + &quot; - &quot;
&nbsp;                + TechConstants.getLevelName(getEntity().getTechLevel()) + &quot; (&quot;
&nbsp;                + getEntity().getYear() + &quot;)\n&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public double getArmoredComponentWeight() {
&nbsp;        return 0.0;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean usesKgStandard(Entity entity) {
&nbsp;        return entity.hasETypeFlag(Entity.ETYPE_BATTLEARMOR)
&nbsp;                || entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)
&nbsp;                || (EntityWeightClass.getWeightClass(entity.getWeight(), entity)
&nbsp;                        == EntityWeightClass.WEIGHT_SMALL_SUPPORT);
&nbsp;    }
&nbsp;
&nbsp;    boolean usesKgStandard() {
&nbsp;        return usesKgStandard(getEntity());
&nbsp;    }
&nbsp;
&nbsp;} // End class TestEntity
&nbsp;
&nbsp;class Armor {
&nbsp;    public static final int CLAN_ARMOR = 0x01;
&nbsp;
&nbsp;    private int armorType;
&nbsp;
&nbsp;    private int armorFlags;
&nbsp;
<b class="fc">&nbsp;    public Armor(int armorType, int armorFlags) {</b>
<b class="fc">&nbsp;        this.armorType = armorType;</b>
<b class="fc">&nbsp;        this.armorFlags = armorFlags;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public double getWeightArmor(int totalOArmor, TestEntity.Ceil roundWeight) {
<b class="nc">&nbsp;        return Armor.getWeightArmor(armorType, armorFlags, totalOArmor,</b>
&nbsp;                roundWeight);
&nbsp;    }
&nbsp;    
&nbsp;    public double getRawWeightArmor(int totalOArmor) {
<b class="nc">&nbsp;        return Armor.getRawWeightArmor(armorType, armorFlags, totalOArmor);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public static double getRawWeightArmor(int armorType, int armorFlags,
&nbsp;            int totalOArmor) {
<b class="nc">&nbsp;        double points = totalOArmor;</b>
&nbsp;        int techLevel;
<b class="nc">&nbsp;        if ((armorFlags &amp; CLAN_ARMOR) != 0) {</b>
<b class="nc">&nbsp;            techLevel = TechConstants.T_CLAN_TW;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            techLevel = TechConstants.T_IS_TW_NON_BOX;</b>
&nbsp;        }
<b class="nc">&nbsp;        double multiplier = EquipmentType.getArmorPointMultiplier(armorType,</b>
&nbsp;                techLevel);
<b class="nc">&nbsp;        points /= multiplier;</b>
<b class="nc">&nbsp;        double pointsPerTon = 16.0f;</b>
<b class="nc">&nbsp;        return points / pointsPerTon;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static double getWeightArmor(int armorType, int armorFlags,
&nbsp;            int totalOArmor, TestEntity.Ceil roundWeight) {
<b class="nc">&nbsp;        return TestEntity.ceilMaxHalf(getRawWeightArmor(armorType, armorFlags, totalOArmor), roundWeight);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getShortName() {
<b class="nc">&nbsp;        return &quot;(&quot; + EquipmentType.getArmorTypeName(armorType) + &quot;)&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;} // end class Armor
&nbsp;
&nbsp;class Structure {
&nbsp;
&nbsp;    private int structureType;
&nbsp;    private boolean isSuperHeavy;
&nbsp;    private EntityMovementMode movementmode;
&nbsp;
&nbsp;    public Structure() {
&nbsp;    }
&nbsp;
&nbsp;    public Structure(int structureType, boolean superHeavy,
&nbsp;            EntityMovementMode movementMode) {
&nbsp;        this.structureType = structureType;
&nbsp;        isSuperHeavy = superHeavy;
&nbsp;        movementmode = movementMode;
&nbsp;    }
&nbsp;
&nbsp;    public double getWeightStructure(double weight, TestEntity.Ceil roundWeight) {
&nbsp;        return Structure.getWeightStructure(structureType, weight, roundWeight,
&nbsp;                isSuperHeavy, movementmode);
&nbsp;    }
&nbsp;
&nbsp;    public static double getWeightStructure(int structureType, double weight,
&nbsp;            TestEntity.Ceil roundWeight, boolean isSuperHeavy,
&nbsp;            EntityMovementMode movementmode) {
&nbsp;        double multiplier = 1.0;
&nbsp;        if (movementmode == EntityMovementMode.TRIPOD) {
&nbsp;            multiplier = 1.1;
&nbsp;        }
&nbsp;        if (structureType == EquipmentType.T_STRUCTURE_ENDO_STEEL) {
&nbsp;            if (isSuperHeavy) {
&nbsp;                return TestEntity.ceilMaxHalf((weight / 10.0f) * multiplier,
&nbsp;                        roundWeight);
&nbsp;            } else {
&nbsp;                return TestEntity.ceilMaxHalf((weight / 20.0f) * multiplier,
&nbsp;                        roundWeight);
&nbsp;            }
&nbsp;        } else if (structureType == EquipmentType.T_STRUCTURE_ENDO_PROTOTYPE) {
&nbsp;            return TestEntity.ceilMaxHalf((weight / 20.0f) * multiplier,
&nbsp;                    roundWeight);
&nbsp;        } else if (structureType == EquipmentType.T_STRUCTURE_REINFORCED) {
&nbsp;            return TestEntity.ceilMaxHalf((weight / 5.0f) * multiplier,
&nbsp;                    roundWeight);
&nbsp;        } else if (structureType == EquipmentType.T_STRUCTURE_COMPOSITE) {
&nbsp;            return TestEntity.ceilMaxHalf((weight / 20.0f) * multiplier,
&nbsp;                    roundWeight);
&nbsp;        } else if (structureType == EquipmentType.T_STRUCTURE_INDUSTRIAL) {
&nbsp;            if (isSuperHeavy) {
&nbsp;                return TestEntity.ceilMaxHalf((weight / 2.5f) * multiplier,
&nbsp;                        roundWeight);
&nbsp;            } else {
&nbsp;                return TestEntity.ceilMaxHalf((weight / 5.0f) * multiplier,
&nbsp;                        roundWeight);
&nbsp;            }
&nbsp;
&nbsp;        } else if (structureType == EquipmentType.T_STRUCTURE_ENDO_COMPOSITE) {
&nbsp;            if (isSuperHeavy) {
&nbsp;                return TestEntity.ceilMaxHalf((weight / 10.0f) * 1.5f
&nbsp;                        * multiplier, roundWeight);
&nbsp;            } else {
&nbsp;                return TestEntity.ceilMaxHalf((weight / 10.0f) * 0.75f
&nbsp;                        * multiplier, roundWeight);
&nbsp;            }
&nbsp;        }
&nbsp;        if (isSuperHeavy
&nbsp;                &amp;&amp; ((movementmode != EntityMovementMode.NAVAL)
&nbsp;                        &amp;&amp; (movementmode != EntityMovementMode.SUBMARINE))) {
&nbsp;            return TestEntity.ceilMaxHalf((weight / 5.0f) * multiplier,
&nbsp;                    roundWeight);
&nbsp;        } else {
&nbsp;            return TestEntity.ceilMaxHalf((weight / 10.0f) * multiplier,
&nbsp;                    roundWeight);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public String getShortName() {
&nbsp;        return &quot;(&quot; + EquipmentType.getStructureTypeName(structureType) + &quot;)&quot;;
&nbsp;    }
&nbsp;
&nbsp;} // End class Structure
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
