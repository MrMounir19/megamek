


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > EntitySprite</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ui.swing.boardview</a>
</div>

<h1>Coverage Summary for Class: EntitySprite (megamek.client.ui.swing.boardview)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EntitySprite</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/587)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EntitySprite$Positioning</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EntitySprite$Status</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/611)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2014-2020 - The MegaMek Team. All Rights Reserved.
&nbsp; *
&nbsp; * This file is part of MegaMek.
&nbsp; *
&nbsp; * MegaMek is free software: you can redistribute it and/or modify
&nbsp; * it under the terms of the GNU General Public License as published by
&nbsp; * the Free Software Foundation, either version 3 of the License, or
&nbsp; * (at your option) any later version.
&nbsp; *
&nbsp; * MegaMek is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
&nbsp; * GNU General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU General Public License
&nbsp; * along with MegaMek. If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; */
&nbsp;package megamek.client.ui.swing.boardview;
&nbsp;
&nbsp;import java.awt.AlphaComposite;
&nbsp;import java.awt.BasicStroke;
&nbsp;import java.awt.Color;
&nbsp;import java.awt.Font;
&nbsp;import java.awt.Graphics2D;
&nbsp;import java.awt.GraphicsConfiguration;
&nbsp;import java.awt.GraphicsEnvironment;
&nbsp;import java.awt.Image;
&nbsp;import java.awt.Point;
&nbsp;import java.awt.Rectangle;
&nbsp;import java.awt.Stroke;
&nbsp;import java.awt.Transparency;
&nbsp;import java.io.File;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map.Entry;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import megamek.client.ui.Messages;
&nbsp;import megamek.client.ui.swing.GUIPreferences;
&nbsp;import megamek.client.ui.swing.util.EntityWreckHelper;
&nbsp;import megamek.common.Aero;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Configuration;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementType;
&nbsp;import megamek.common.EntityVisibilityUtils;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.IAero;
&nbsp;import megamek.common.IArmorState;
&nbsp;import megamek.common.IBoard;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.IPlayer;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.QuadVee;
&nbsp;import megamek.common.RangeType;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.TechConstants;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.icons.AbstractIcon;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.options.PilotOptions;
&nbsp;
&nbsp;/**
&nbsp; * Sprite for an entity. Changes whenever the entity changes. Consists of an
&nbsp; * image, drawn from the Tile Manager; facing and possibly secondary facing
&nbsp; * arrows; armor and internal bars; and an identification label.
&nbsp; */
<b class="nc">&nbsp;class EntitySprite extends Sprite {</b>
&nbsp;
&nbsp;    // Statics
&nbsp;    private static final int SMALL = 0;
&nbsp;    private static final boolean DIRECT = true;
<b class="nc">&nbsp;    private static final Color LABEL_TEXT_COLOR = Color.WHITE;</b>
<b class="nc">&nbsp;    private static final Color LABEL_CRITICAL_BACK = new Color(200,0,0,200);</b>
<b class="nc">&nbsp;    private static final Color LABEL_SPACE_BACK = new Color(0,0,200,200);</b>
<b class="nc">&nbsp;    private static final Color LABEL_GROUND_BACK = new Color(50,50,50,200);</b>
&nbsp;    private static Color LABEL_BACK;
<b class="nc">&nbsp;    enum Positioning { LEFT, RIGHT }</b>
&nbsp;    
&nbsp;    // Individuals
&nbsp;    final Entity entity;
&nbsp;
&nbsp;    private final Image radarBlipImage;
&nbsp;    private final int secondaryPos;
&nbsp;
&nbsp;    private Rectangle entityRect;
&nbsp;    private Rectangle labelRect;
&nbsp;    private Font labelFont;
&nbsp;    private Point hexOrigin;
&nbsp;    private boolean criticalStatus;
&nbsp;    private Positioning labelPos;
&nbsp;    /** Used to color the label when this unit is selected for movement etc. */
&nbsp;    private boolean isSelected;
&nbsp;    
&nbsp;    // Keep track of ECM state, as it&#39;s too expensive to compute on the fly.
<b class="nc">&nbsp;    private boolean isAffectedByECM = false;</b>
&nbsp;
&nbsp;    public EntitySprite(BoardView1 boardView1, final Entity entity,
&nbsp;            int secondaryPos, Image radarBlipImage) {
<b class="nc">&nbsp;        super(boardView1);</b>
<b class="nc">&nbsp;        this.entity = entity;</b>
<b class="nc">&nbsp;        this.radarBlipImage = radarBlipImage;</b>
<b class="nc">&nbsp;        this.secondaryPos = secondaryPos;</b>
<b class="nc">&nbsp;        if (bv.game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            LABEL_BACK = LABEL_SPACE_BACK;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            LABEL_BACK = LABEL_GROUND_BACK;</b>
&nbsp;        }
<b class="nc">&nbsp;        getBounds();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private String getAdjShortName() {
<b class="nc">&nbsp;        if (onlyDetectedBySensors()) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;BoardView1.sensorReturn&quot;); //$NON-NLS-1$</b>
&nbsp;        } else {
<b class="nc">&nbsp;            String name = entity.getShortName();</b>
<b class="nc">&nbsp;            int firstApo = name.indexOf(&#39;\&#39;&#39;);</b>
<b class="nc">&nbsp;            int secondApo = name.indexOf(&#39;\&#39;&#39;, name.indexOf(&#39;\&#39;&#39;)+1);</b>
<b class="nc">&nbsp;            if ((firstApo &gt;= 0) &amp;&amp; (secondApo &gt;= 0)) {</b>
<b class="nc">&nbsp;                name = name</b>
<b class="nc">&nbsp;                        .substring(firstApo+1, secondApo)</b>
<b class="nc">&nbsp;                        .toUpperCase();</b>
&nbsp;            }
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Rectangle getBounds() {
&nbsp;        // Start with the hex and add the label
<b class="nc">&nbsp;        bounds = new Rectangle(0,0,bv.hex_size.width, bv.hex_size.height);</b>
<b class="nc">&nbsp;        updateLabel();</b>
<b class="nc">&nbsp;        bounds.add(labelRect);</b>
&nbsp;        // Add space for 4 little status boxes
<b class="nc">&nbsp;        if (labelPos == Positioning.RIGHT) {</b>
<b class="nc">&nbsp;            bounds.add(-4*(labelRect.height+2)+labelRect.x, labelRect.y);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bounds.add(4*(labelRect.height+2)+labelRect.x+labelRect.width, labelRect.y);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Move to board position, save this origin for correct drawing
<b class="nc">&nbsp;        hexOrigin = bounds.getLocation();</b>
&nbsp;        Point ePos;
<b class="nc">&nbsp;        if (secondaryPos == -1) {</b>
<b class="nc">&nbsp;            ePos = bv.getHexLocation(entity.getPosition());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ePos = bv.getHexLocation(entity.getSecondaryPositions().get(secondaryPos));</b>
&nbsp;        }
<b class="nc">&nbsp;        bounds.setLocation(hexOrigin.x + ePos.x, hexOrigin.y + ePos.y);</b>
&nbsp;        
<b class="nc">&nbsp;        entityRect = new Rectangle(bounds.x + (int) (20 * bv.scale), bounds.y</b>
&nbsp;                + (int) (14 * bv.scale), (int) (44 * bv.scale),
&nbsp;                (int) (44 * bv.scale));
&nbsp;
<b class="nc">&nbsp;        return bounds;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateLabel() {
<b class="nc">&nbsp;        Rectangle oldRect = new Rectangle();</b>
<b class="nc">&nbsp;        if (labelRect != null)</b>
<b class="nc">&nbsp;            oldRect = new Rectangle(labelRect);</b>
&nbsp;        
<b class="nc">&nbsp;        int face = (entity.isCommander() &amp;&amp; !onlyDetectedBySensors()) ? </b>
<b class="nc">&nbsp;                Font.ITALIC : Font.PLAIN;</b>
<b class="nc">&nbsp;        labelFont = new Font(&quot;SansSerif&quot;, face, (int)(10*Math.max(bv.scale,0.9))); //$NON-NLS-1$</b>
&nbsp;        
&nbsp;        // Check the hexes in directions 2,5,1,4 if they are free of entities
&nbsp;        // and place the label in the direction of the first free hex
&nbsp;        // if none are free, the label will be centered in the current hex
<b class="nc">&nbsp;        labelRect = new Rectangle(</b>
<b class="nc">&nbsp;                bv.getFontMetrics(labelFont).stringWidth(getAdjShortName())+4, </b>
<b class="nc">&nbsp;                bv.getFontMetrics(labelFont).getAscent()+2);</b>
&nbsp;        
<b class="nc">&nbsp;        Coords position = entity.getPosition();</b>
<b class="nc">&nbsp;        if (bv.game.getEntitiesVector(position.translated(&quot;SE&quot;), true).isEmpty()) {</b>
<b class="nc">&nbsp;            labelRect.setLocation((int)(bv.hex_size.width*0.55), (int)(0.75*bv.hex_size.height));</b>
<b class="nc">&nbsp;            labelPos = Positioning.RIGHT;</b>
<b class="nc">&nbsp;        } else if (bv.game.getEntitiesVector(position.translated(&quot;NW&quot;), true).isEmpty()) {</b>
<b class="nc">&nbsp;            labelRect.setLocation((int)(bv.hex_size.width*0.45)-labelRect.width, </b>
&nbsp;                    (int)(0.25*bv.hex_size.height)-labelRect.height);
<b class="nc">&nbsp;            labelPos = Positioning.LEFT;</b>
<b class="nc">&nbsp;        } else if (bv.game.getEntitiesVector(position.translated(&quot;NE&quot;), true).isEmpty()) {</b>
<b class="nc">&nbsp;            labelRect.setLocation((int)(bv.hex_size.width*0.55), </b>
&nbsp;                    (int)(0.25*bv.hex_size.height)-labelRect.height);
<b class="nc">&nbsp;            labelPos = Positioning.RIGHT;</b>
<b class="nc">&nbsp;        } else if (bv.game.getEntitiesVector(position.translated(&quot;SW&quot;), true).isEmpty()) {</b>
<b class="nc">&nbsp;            labelRect.setLocation((int)(bv.hex_size.width*0.45)-labelRect.width, </b>
&nbsp;                    (int)(0.75*bv.hex_size.height));
<b class="nc">&nbsp;            labelPos = Positioning.LEFT;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            labelRect.setLocation(bv.hex_size.width/2-labelRect.width/2, </b>
&nbsp;                    (int)(0.75*bv.hex_size.height));
<b class="nc">&nbsp;            labelPos = Positioning.RIGHT;</b>
&nbsp;        } 
&nbsp;
&nbsp;        // If multiple units are present in a hex, fan out the labels
&nbsp;        // In the deployment phase, indexOf returns -1 for the current unit
<b class="nc">&nbsp;        int indexEntity = bv.game.getEntitiesVector(position).indexOf(entity);</b>
<b class="nc">&nbsp;        if (indexEntity != -1) {</b>
<b class="nc">&nbsp;            labelRect.y += (bv.getFontMetrics(labelFont).getAscent()+4) * </b>
&nbsp;                    indexEntity;
&nbsp;        } else {
<b class="nc">&nbsp;            labelRect.y += (bv.getFontMetrics(labelFont).getAscent()+4) * </b>
<b class="nc">&nbsp;                    bv.game.getEntitiesVector(position).size();</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the label has changed, force a redraw (necessary
&nbsp;        // for the Deployment phase
<b class="nc">&nbsp;        if (!labelRect.equals(oldRect)) image = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Happy little class to hold status info until it gets drawn
&nbsp;    private class Status {
&nbsp;        final Color color;
&nbsp;        final String status;
&nbsp;        final boolean small;
&nbsp;
<b class="nc">&nbsp;        Status(Color c, String s) {</b>
<b class="nc">&nbsp;            color = c;</b>
<b class="nc">&nbsp;            status = Messages.getString(&quot;BoardView1.&quot;+s);</b>
<b class="nc">&nbsp;            small = false;</b>
<b class="nc">&nbsp;            if (color.equals(Color.RED)) criticalStatus = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Status(Color c, String s, Object objs[]) {</b>
<b class="nc">&nbsp;            color = c;</b>
<b class="nc">&nbsp;            status = Messages.getString(&quot;BoardView1.&quot;+s, objs);</b>
<b class="nc">&nbsp;            small = false;</b>
<b class="nc">&nbsp;            if (color.equals(Color.RED)) criticalStatus = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Status(Color c, String s, boolean direct) {</b>
<b class="nc">&nbsp;            color = c;</b>
<b class="nc">&nbsp;            status = s;</b>
<b class="nc">&nbsp;            small = false;</b>
<b class="nc">&nbsp;            if (color.equals(Color.RED)) criticalStatus = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Status(Color c, String s, int t) {</b>
<b class="nc">&nbsp;            color = c;</b>
<b class="nc">&nbsp;            status = s;</b>
<b class="nc">&nbsp;            small = true;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Status(Color c, int b, int t) {</b>
<b class="nc">&nbsp;            color = c;</b>
<b class="nc">&nbsp;            status = null;</b>
<b class="nc">&nbsp;            small = true;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;    
&nbsp;    private void drawStatusStrings(Graphics2D g, ArrayList&lt;Status&gt; statusStrings) {
<b class="nc">&nbsp;        if (statusStrings.isEmpty()) return;</b>
&nbsp;        
&nbsp;        // The small info blobs
<b class="nc">&nbsp;        g.setFont(labelFont);</b>
&nbsp;        
<b class="nc">&nbsp;        Rectangle stR = new Rectangle(labelRect.x, labelRect.y, labelRect.height, labelRect.height);</b>
<b class="nc">&nbsp;        if (labelPos == Positioning.LEFT) {</b>
<b class="nc">&nbsp;            stR.translate(labelRect.width-labelRect.height, 0);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        for (Status curStatus: statusStrings) {</b>
<b class="nc">&nbsp;            if (curStatus.small) { </b>
<b class="nc">&nbsp;                if (labelPos == Positioning.RIGHT) {</b>
<b class="nc">&nbsp;                    stR.translate(-labelRect.height-2,0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stR.translate(labelRect.height+2,0);</b>
&nbsp;                }
<b class="nc">&nbsp;                g.setColor(LABEL_BACK);</b>
<b class="nc">&nbsp;                g.fillRoundRect(stR.x, stR.y, stR.width, stR.height, 5, 5);</b>
<b class="nc">&nbsp;                if (curStatus.status == null) {</b>
<b class="nc">&nbsp;                    Color damageColor = getDamageColor();</b>
<b class="nc">&nbsp;                    if (damageColor != null) {</b>
<b class="nc">&nbsp;                        g.setColor(damageColor);</b>
<b class="nc">&nbsp;                        g.fillRoundRect(stR.x+2, stR.y+2, stR.width-4, stR.height-4, 5, 5);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    bv.drawCenteredText(g, curStatus.status, </b>
&nbsp;                            stR.x+stR.height*0.5f-0.5f, stR.y+stR.height*0.5f-2, curStatus.color, false);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // When zoomed far out, status wouldn&#39;t be readable, therefore
&nbsp;        // draw a big &quot;!&quot; (and the label is red)
<b class="nc">&nbsp;        if (bv.scale &lt; 0.55 &amp;&amp; criticalStatus) {</b>
<b class="nc">&nbsp;            Font bigFont = new Font(&quot;SansSerif&quot;,Font.BOLD,(int)(42*bv.scale));</b>
<b class="nc">&nbsp;            g.setFont(bigFont);</b>
<b class="nc">&nbsp;            Point pos = new Point(bv.hex_size.width/2, bv.hex_size.height/2);</b>
<b class="nc">&nbsp;            bv.drawTextShadow(g, &quot;!&quot;, pos, bigFont);</b>
<b class="nc">&nbsp;            bv.drawCenteredText(g, &quot;!&quot;, pos, Color.RED, false);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        
&nbsp;        // Critical status text
<b class="nc">&nbsp;        Font boldFont = new Font(&quot;SansSerif&quot;,Font.BOLD,(int)(12*bv.scale));</b>
<b class="nc">&nbsp;        g.setFont(boldFont);</b>
<b class="nc">&nbsp;        int y = (int)(bv.hex_size.height * 0.6);</b>
<b class="nc">&nbsp;        for (Status curStatus: statusStrings) {</b>
<b class="nc">&nbsp;            if (!curStatus.small) { // Critical status</b>
<b class="nc">&nbsp;                bv.drawTextShadow(g, curStatus.status, new Point(bv.hex_size.width/2,y), boldFont);</b>
<b class="nc">&nbsp;                bv.drawCenteredText(g, curStatus.status, bv.hex_size.width/2, y, curStatus.color, false);</b>
<b class="nc">&nbsp;                y -= 14*bv.scale;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Creates the sprite for this entity. Fortunately it is no longer
&nbsp;     * an extra pain to create transparent images in AWT.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void prepare() {
<b class="nc">&nbsp;        final IBoard board = bv.game.getBoard();</b>
<b class="nc">&nbsp;        final GUIPreferences guip = GUIPreferences.getInstance();</b>
&nbsp;        // recalculate bounds &amp; label
<b class="nc">&nbsp;        getBounds();</b>
&nbsp;        
&nbsp;        // create image for buffer
&nbsp;        GraphicsConfiguration config = GraphicsEnvironment
<b class="nc">&nbsp;                .getLocalGraphicsEnvironment().getDefaultScreenDevice()</b>
<b class="nc">&nbsp;                .getDefaultConfiguration();</b>
<b class="nc">&nbsp;        image = config.createCompatibleImage(bounds.width, bounds.height,</b>
&nbsp;                Transparency.TRANSLUCENT);
<b class="nc">&nbsp;        Graphics2D graph = (Graphics2D)image.getGraphics();</b>
<b class="nc">&nbsp;        GUIPreferences.AntiAliasifSet(graph);</b>
&nbsp;        
&nbsp;        // translate everything (=correction for label placement)
<b class="nc">&nbsp;        graph.translate(-hexOrigin.x, -hexOrigin.y);</b>
&nbsp;
<b class="nc">&nbsp;        if (!bv.useIsometric()) {</b>
&nbsp;            // The entity sprite is drawn when the hexes are rendered.
&nbsp;            // So do not include the sprite info here.
<b class="nc">&nbsp;            if (onlyDetectedBySensors()) {</b>
<b class="nc">&nbsp;                graph.drawImage(bv.getScaledImage(radarBlipImage, true), 0, 0, this);</b>
&nbsp;            } else {
&nbsp;                // draw the unit icon translucent if:
&nbsp;                // hidden from the enemy (and activated graphics setting); or
&nbsp;                // submerged
<b class="nc">&nbsp;                boolean translucentHiddenUnits = guip</b>
<b class="nc">&nbsp;                        .getBoolean(GUIPreferences.ADVANCED_TRANSLUCENT_HIDDEN_UNITS);</b>
<b class="nc">&nbsp;                boolean shouldBeTranslucent = (trackThisEntitiesVisibilityInfo(entity)</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.isVisibleToEnemy()) || entity.isHidden();</b>
<b class="nc">&nbsp;                if ((shouldBeTranslucent &amp;&amp; translucentHiddenUnits)</b>
<b class="nc">&nbsp;                        || (entity.relHeight() &lt; 0)) {</b>
<b class="nc">&nbsp;                    graph.setComposite(AlphaComposite.getInstance(</b>
&nbsp;                            AlphaComposite.SRC_OVER, 0.5f));
&nbsp;                }
&nbsp;                
&nbsp;                // draw the &#39;fuel leak&#39; decal where appropriate
<b class="nc">&nbsp;                boolean drawFuelLeak = EntityWreckHelper.displayFuelLeak(entity);</b>
&nbsp;                
<b class="nc">&nbsp;                if(drawFuelLeak) {</b>
<b class="nc">&nbsp;                    Image fuelLeak = bv.getScaledImage(bv.tileManager.bottomLayerFuelLeakMarkerFor(entity), true);</b>
<b class="nc">&nbsp;                    if (null != fuelLeak) {</b>
<b class="nc">&nbsp;                        graph.drawImage(fuelLeak, 0, 0, this);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                
&nbsp;                // draw the &#39;tires&#39; or &#39;tracks&#39; decal where appropriate
<b class="nc">&nbsp;                boolean drawMotiveWreckage = EntityWreckHelper.displayMotiveDamage(entity);</b>
&nbsp;                
<b class="nc">&nbsp;                if(drawMotiveWreckage) {</b>
<b class="nc">&nbsp;                    Image motiveWreckage = bv.getScaledImage(bv.tileManager.bottomLayerMotiveMarkerFor(entity), true);</b>
<b class="nc">&nbsp;                    if (null != motiveWreckage) {</b>
<b class="nc">&nbsp;                        graph.drawImage(motiveWreckage, 0, 0, this);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                graph.drawImage(bv.getScaledImage(bv.tileManager.imageFor(entity, secondaryPos), true),</b>
&nbsp;                        0, 0, this);
<b class="nc">&nbsp;                graph.setComposite(AlphaComposite.getInstance(</b>
&nbsp;                        AlphaComposite.SRC_OVER, 1.0f));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // scale the following draws according to board zoom
<b class="nc">&nbsp;        graph.scale(bv.scale, bv.scale);</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isInfantry = (entity instanceof Infantry);</b>
<b class="nc">&nbsp;        boolean isAero = entity.isAero();</b>
&nbsp;        
<b class="nc">&nbsp;        if ((isAero &amp;&amp; ((IAero) entity).isSpheroid() &amp;&amp; !board.inSpace())</b>
&nbsp;                &amp;&amp; (secondaryPos == 1)) {
<b class="nc">&nbsp;            graph.setColor(Color.WHITE);</b>
<b class="nc">&nbsp;            graph.draw(bv.facingPolys[entity.getFacing()]);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((secondaryPos == -1) || (secondaryPos == 6)) {</b>
&nbsp;            
&nbsp;            // Gather unit conditions
<b class="nc">&nbsp;            ArrayList&lt;Status&gt; stStr = new ArrayList&lt;Status&gt;();</b>
<b class="nc">&nbsp;            criticalStatus = false;</b>
&nbsp;            
&nbsp;            // Determine if the entity has a locked turret,
&nbsp;            // and if it is a gun emplacement
<b class="nc">&nbsp;            boolean turretLocked = false;</b>
<b class="nc">&nbsp;            int crewStunned = 0;</b>
<b class="nc">&nbsp;            boolean ge = false;</b>
<b class="nc">&nbsp;            if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                turretLocked = !((Tank) entity).hasNoTurret()</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.canChangeSecondaryFacing();</b>
<b class="nc">&nbsp;                crewStunned = ((Tank) entity).getStunnedTurns();</b>
<b class="nc">&nbsp;                ge = entity instanceof GunEmplacement;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // draw elevation/altitude if non-zero
<b class="nc">&nbsp;            if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                if (!board.inSpace()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.CYAN, &quot;A&quot;, SMALL));</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.CYAN, Integer.toString(entity.getAltitude()), SMALL));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity.getElevation() != 0) {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.CYAN, Integer.toString(entity.getElevation()), SMALL));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Shutdown
<b class="nc">&nbsp;            if (entity.isManualShutdown()) {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.YELLOW, &quot;SHUTDOWN&quot;));</b>
<b class="nc">&nbsp;            } else if (entity.isShutDown()) {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;SHUTDOWN&quot;));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Prone, Hulldown, Stuck, Immobile, Jammed
<b class="nc">&nbsp;            if (entity.isProne()) </b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;PRONE&quot;));</b>
<b class="nc">&nbsp;            if (entity.isHiddenActivating())</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;ACTIVATING&quot;));</b>
<b class="nc">&nbsp;            if (entity.isHidden())</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;HIDDEN&quot;));</b>
<b class="nc">&nbsp;            if (entity.isGyroDestroyed())</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;NO_GYRO&quot;));</b>
<b class="nc">&nbsp;            if (entity.isHullDown())</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.ORANGE, &quot;HULLDOWN&quot;));</b>
<b class="nc">&nbsp;            if ((entity.isStuck()))</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.ORANGE, &quot;STUCK&quot;));</b>
<b class="nc">&nbsp;            if (!ge &amp;&amp; entity.isImmobile())</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;IMMOBILE&quot;));</b>
<b class="nc">&nbsp;            if (isAffectedByECM())</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.YELLOW, &quot;Jammed&quot;));</b>
&nbsp;            
&nbsp;            // Turret Lock 
<b class="nc">&nbsp;            if (turretLocked) stStr.add(new Status(Color.YELLOW, &quot;LOCKED&quot;));</b>
&nbsp;            
&nbsp;            // Grappling &amp; Swarming
<b class="nc">&nbsp;            if (entity.getGrappled() != Entity.NONE) {</b>
<b class="nc">&nbsp;                if (entity.isGrappleAttacker()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.YELLOW, &quot;GRAPPLER&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stStr.add(new Status(Color.RED, &quot;GRAPPLED&quot;));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (entity.getSwarmAttackerId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.RED, &quot;SWARMED&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // Transporting
<b class="nc">&nbsp;            if (entity.getLoadedUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.YELLOW, &quot;T&quot;, SMALL));</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (entity.getAllTowedUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.YELLOW, &quot;TOWING&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // Hidden, Unseen Unit
<b class="nc">&nbsp;            if (trackThisEntitiesVisibilityInfo(entity)) {</b>
<b class="nc">&nbsp;                if (!entity.isEverSeenByEnemy()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.GREEN, &quot;U&quot;, SMALL));</b>
<b class="nc">&nbsp;                } else if (!entity.isVisibleToEnemy()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.GREEN, &quot;H&quot;, SMALL));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Large Craft Ejecting
<b class="nc">&nbsp;            if (entity instanceof Aero) {</b>
<b class="nc">&nbsp;                if (((Aero)entity).isEjecting()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.YELLOW, &quot;EJECTING&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Crew
<b class="nc">&nbsp;            if (entity.getCrew().isDead()) stStr.add(new Status(Color.RED, &quot;CrewDead&quot;));</b>
<b class="nc">&nbsp;            if (crewStunned &gt; 0)  {</b>
<b class="nc">&nbsp;                stStr.add(new Status(Color.YELLOW, &quot;STUNNED&quot;, new Object[] { crewStunned }));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Infantry
<b class="nc">&nbsp;            if (isInfantry) {</b>
<b class="nc">&nbsp;                Infantry inf = ((Infantry) entity);</b>
<b class="nc">&nbsp;                int dig = inf.getDugIn();</b>
<b class="nc">&nbsp;                if (dig == Infantry.DUG_IN_COMPLETE) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.PINK, &quot;D&quot;, SMALL));</b>
<b class="nc">&nbsp;                } else if (dig != Infantry.DUG_IN_NONE) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.YELLOW, &quot;Working&quot;, DIRECT));</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.PINK, &quot;D&quot;, SMALL));</b>
<b class="nc">&nbsp;                } else if (inf.isTakingCover()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.YELLOW, &quot;TakingCover&quot;));</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                if (inf.turnsLayingExplosives &gt;= 0) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.YELLOW, &quot;Working&quot;, DIRECT));</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.PINK, &quot;E&quot;, SMALL));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Aero
<b class="nc">&nbsp;            if (isAero) {</b>
<b class="nc">&nbsp;                IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                if (a.isRolled()) stStr.add(new Status(Color.YELLOW, &quot;ROLLED&quot;));</b>
<b class="nc">&nbsp;                if (a.getCurrentFuel() &lt;= 0) stStr.add(new Status(Color.RED, &quot;FUEL&quot;));</b>
<b class="nc">&nbsp;                if (entity.isEvading()) stStr.add(new Status(Color.GREEN, &quot;EVADE&quot;));</b>
&nbsp;                
<b class="nc">&nbsp;                if (a.isOutControlTotal() &amp; a.isRandomMove()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.RED, &quot;RANDOM&quot;));</b>
<b class="nc">&nbsp;                } else if (a.isOutControlTotal()) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(Color.RED, &quot;CONTROL&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (guip.getShowDamageLevel()) {</b>
<b class="nc">&nbsp;                Color damageColor = getDamageColor();</b>
<b class="nc">&nbsp;                if (damageColor != null) {</b>
<b class="nc">&nbsp;                    stStr.add(new Status(damageColor, 0, SMALL));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            
&nbsp;            // Unit Label
&nbsp;            // no scaling for the label, its size is changed by varying
&nbsp;            // the font size directly =&gt; better control
<b class="nc">&nbsp;            graph.scale(1/bv.scale, 1/bv.scale);</b>
&nbsp;            
&nbsp;            // Label background
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL)) {</b>
<b class="nc">&nbsp;                if (criticalStatus) {</b>
<b class="nc">&nbsp;                    graph.setColor(LABEL_CRITICAL_BACK);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    graph.setColor(LABEL_BACK);</b>
&nbsp;                }
<b class="nc">&nbsp;                graph.fillRoundRect(labelRect.x, labelRect.y, labelRect.width,</b>
&nbsp;                        labelRect.height, 5, 10);
&nbsp;
&nbsp;                // Draw a label border with player colors or team coloring
<b class="nc">&nbsp;                if (guip.getUnitLabelBorder()) {</b>
<b class="nc">&nbsp;                    if (guip.getTeamColoring()) {</b>
<b class="nc">&nbsp;                        boolean isLocalTeam = entity.getOwner().getTeam() == bv.clientgui.getClient().getLocalPlayer().getTeam();</b>
<b class="nc">&nbsp;                        boolean isLocalPlayer = entity.getOwner().equals(bv.clientgui.getClient().getLocalPlayer());</b>
<b class="nc">&nbsp;                        if (isLocalPlayer) {</b>
<b class="nc">&nbsp;                            graph.setColor(GUIPreferences.getInstance().getMyUnitColor());</b>
<b class="nc">&nbsp;                        } else if (isLocalTeam) {</b>
<b class="nc">&nbsp;                            graph.setColor(GUIPreferences.getInstance().getAllyUnitColor());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            graph.setColor(GUIPreferences.getInstance().getEnemyUnitColor());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        graph.setColor(entity.getOwner().getColour().getColour(false));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Stroke oldStroke = graph.getStroke();</b>
<b class="nc">&nbsp;                    graph.setStroke(new BasicStroke(3));</b>
<b class="nc">&nbsp;                    graph.drawRoundRect(labelRect.x - 1, labelRect.y - 1,</b>
&nbsp;                            labelRect.width + 1, labelRect.height + 1, 5, 10);
<b class="nc">&nbsp;                    graph.setStroke(oldStroke);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Label text
<b class="nc">&nbsp;                graph.setFont(labelFont);</b>
<b class="nc">&nbsp;                Color textColor = LABEL_TEXT_COLOR;</b>
<b class="nc">&nbsp;                if (!entity.isDone() &amp;&amp; !onlyDetectedBySensors()) {</b>
<b class="nc">&nbsp;                    textColor = guip.getColor(</b>
&nbsp;                            GUIPreferences.ADVANCED_UNITOVERVIEW_VALID_COLOR);
&nbsp;                }
<b class="nc">&nbsp;                if (isSelected) {</b>
<b class="nc">&nbsp;                    textColor = guip.getColor(</b>
&nbsp;                            GUIPreferences.ADVANCED_UNITOVERVIEW_SELECTED_COLOR);
&nbsp;                }
<b class="nc">&nbsp;                bv.drawCenteredText(graph, getAdjShortName(),</b>
&nbsp;                        labelRect.x + labelRect.width / 2,
&nbsp;                        labelRect.y + labelRect.height / 2 - 1, textColor,
<b class="nc">&nbsp;                        (entity.isDone() &amp;&amp; !onlyDetectedBySensors()));</b>
&nbsp;            }
&nbsp;
&nbsp;            // Past here, everything is drawing status that shouldn&#39;t be seen
&nbsp;            // on a sensor return, so we&#39;ll just quit here
<b class="nc">&nbsp;            if (onlyDetectedBySensors()) {</b>
<b class="nc">&nbsp;                graph.dispose();</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            
&nbsp;            // Draw all the status information now
<b class="nc">&nbsp;            drawStatusStrings(graph, stStr);</b>
&nbsp;            
&nbsp;            // from here, scale the following draws according to board zoom
<b class="nc">&nbsp;            graph.scale(bv.scale, bv.scale);</b>
&nbsp;            
&nbsp;            // draw facing
<b class="nc">&nbsp;            graph.setColor(Color.white);</b>
<b class="nc">&nbsp;            if ((entity.getFacing() != -1)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(isInfantry &amp;&amp; !((Infantry) entity).hasFieldGun()</b>
<b class="nc">&nbsp;                            &amp;&amp; !((Infantry) entity).isTakingCover())</b>
<b class="nc">&nbsp;                    &amp;&amp; !(isAero &amp;&amp; ((IAero) entity).isSpheroid() &amp;&amp; !board</b>
<b class="nc">&nbsp;                            .inSpace())) {</b>
<b class="nc">&nbsp;                graph.draw(bv.facingPolys[entity.getFacing()]);</b>
&nbsp;            }
&nbsp;
&nbsp;            // determine secondary facing for non-mechs &amp; flipped arms
<b class="nc">&nbsp;            int secFacing = entity.getFacing();</b>
<b class="nc">&nbsp;            if (!((entity instanceof Mech) || (entity instanceof Protomech))</b>
&nbsp;                    || (entity instanceof QuadVee)) {
<b class="nc">&nbsp;                secFacing = entity.getSecondaryFacing();</b>
<b class="nc">&nbsp;            } else if (entity.getArmsFlipped()) {</b>
<b class="nc">&nbsp;                secFacing = (entity.getFacing() + 3) % 6;</b>
&nbsp;            }
&nbsp;            // draw red secondary facing arrow if necessary
<b class="nc">&nbsp;            if ((secFacing != -1) &amp;&amp; (secFacing != entity.getFacing())) {</b>
<b class="nc">&nbsp;                graph.setColor(Color.red);</b>
<b class="nc">&nbsp;                graph.draw(bv.facingPolys[secFacing]);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.isAero() &amp;&amp; this.bv.game.useVectorMove()) {</b>
<b class="nc">&nbsp;                for (int head : entity.getHeading()) {</b>
<b class="nc">&nbsp;                    graph.setColor(Color.red);</b>
<b class="nc">&nbsp;                    graph.draw(bv.facingPolys[head]);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // armor and internal status bars
<b class="nc">&nbsp;            int baseBarLength = 23;</b>
<b class="nc">&nbsp;            int barLength = 0;</b>
<b class="nc">&nbsp;            double percentRemaining = 0.00;</b>
&nbsp;
<b class="nc">&nbsp;            percentRemaining = entity.getArmorRemainingPercent();</b>
<b class="nc">&nbsp;            barLength = (int) (baseBarLength * percentRemaining);</b>
&nbsp;
<b class="nc">&nbsp;            graph.setColor(Color.darkGray);</b>
<b class="nc">&nbsp;            graph.fillRect(56, 7, 23, 3);</b>
<b class="nc">&nbsp;            graph.setColor(Color.lightGray);</b>
<b class="nc">&nbsp;            graph.fillRect(55, 6, 23, 3);</b>
<b class="nc">&nbsp;            graph.setColor(getStatusBarColor(percentRemaining));</b>
<b class="nc">&nbsp;            graph.fillRect(55, 6, barLength, 3);</b>
&nbsp;
<b class="nc">&nbsp;            if (!ge) {</b>
&nbsp;                // Gun emplacements don&#39;t have internal structure
<b class="nc">&nbsp;                percentRemaining = entity.getInternalRemainingPercent();</b>
<b class="nc">&nbsp;                barLength = (int) (baseBarLength * percentRemaining);</b>
&nbsp;
<b class="nc">&nbsp;                graph.setColor(Color.darkGray);</b>
<b class="nc">&nbsp;                graph.fillRect(56, 11, 23, 3);</b>
<b class="nc">&nbsp;                graph.setColor(Color.lightGray);</b>
<b class="nc">&nbsp;                graph.fillRect(55, 10, 23, 3);</b>
<b class="nc">&nbsp;                graph.setColor(getStatusBarColor(percentRemaining));</b>
<b class="nc">&nbsp;                graph.fillRect(55, 10, barLength, 3);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        graph.dispose();</b>
&nbsp;    }
&nbsp;
&nbsp;    private Color getDamageColor() {
<b class="nc">&nbsp;        switch (entity.getDamageLevel()) {</b>
&nbsp;            case Entity.DMG_CRIPPLED:
<b class="nc">&nbsp;                return Color.black;</b>
&nbsp;            case Entity.DMG_HEAVY:
<b class="nc">&nbsp;                return Color.red;</b>
&nbsp;            case Entity.DMG_MODERATE:
<b class="nc">&nbsp;                return Color.yellow;</b>
&nbsp;            case Entity.DMG_LIGHT:
<b class="nc">&nbsp;                return Color.green;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * We only want to show double-blind visibility indicators on our own
&nbsp;     * mechs and teammates mechs (assuming team vision option).
&nbsp;     */
&nbsp;    private boolean trackThisEntitiesVisibilityInfo(Entity e) {
<b class="nc">&nbsp;        return EntityVisibilityUtils.trackThisEntitiesVisibilityInfo(bv.getLocalPlayer(), e);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine if this EntitySprite is only detected by an enemies
&nbsp;     * sensors and hence should only be a sensor return.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean onlyDetectedBySensors() {
<b class="nc">&nbsp;        return EntityVisibilityUtils.onlyDetectedBySensors(bv.getLocalPlayer(), entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Color getStatusBarColor(double percentRemaining) {
<b class="nc">&nbsp;        if (percentRemaining &lt;= .25) {</b>
<b class="nc">&nbsp;            return Color.red;</b>
<b class="nc">&nbsp;        } else if (percentRemaining &lt;= .75) {</b>
<b class="nc">&nbsp;            return Color.yellow;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new Color(16, 196, 16);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Overrides to provide for a smaller sensitive area.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isInside(Point point) {
<b class="nc">&nbsp;        return entityRect.contains(point.x, point.y);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Coords getPosition() {
<b class="nc">&nbsp;        return entity.getPosition();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private StringBuffer tooltipString;
<b class="nc">&nbsp;    private final boolean BR = true;</b>
<b class="nc">&nbsp;    private final boolean NOBR = false;</b>
<b class="nc">&nbsp;    private boolean skipBRafterTable = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Builds a small table representing a unit&#39;s armor using visual block characters
&nbsp;     * and adds it to the current tooltipString.
&nbsp;     */
&nbsp;    private void addArmorMiniVisToTT() {
<b class="nc">&nbsp;        String armorChar = GUIPreferences.getInstance().getString(&quot;AdvancedArmorMiniArmorChar&quot;);</b>
<b class="nc">&nbsp;        String internalChar = GUIPreferences.getInstance().getString(&quot;AdvancedArmorMiniISChar&quot;);</b>
<b class="nc">&nbsp;        String destroyedChar = GUIPreferences.getInstance().getString(&quot;AdvancedArmorMiniDestroyedChar&quot;);</b>
<b class="nc">&nbsp;        String fontSize = Integer.toString(GUIPreferences.getInstance().getInt(&quot;AdvancedArmorMiniFrontSizeMod&quot;));</b>
&nbsp;        // HTML color String from Preferences
&nbsp;        String colorIntact = Integer
<b class="nc">&nbsp;                .toHexString(GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                        .getColor(&quot;AdvancedArmorMiniColorIntact&quot;).getRGB() &amp; 0xFFFFFF);</b>
&nbsp;        String colorPartialDmg = Integer
<b class="nc">&nbsp;                .toHexString(GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                        .getColor(&quot;AdvancedArmorMiniColorPartialDmg&quot;).getRGB() &amp; 0xFFFFFF);</b>
&nbsp;        String colorDamaged = Integer
<b class="nc">&nbsp;                .toHexString(GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                        .getColor(&quot;AdvancedArmorMiniColorDamaged&quot;).getRGB() &amp; 0xFFFFFF);</b>
<b class="nc">&nbsp;        int visUnit = GUIPreferences.getInstance().getInt(&quot;AdvancedArmorMiniUnitsPerBlock&quot;);</b>
<b class="nc">&nbsp;        addToTT(&quot;ArmorMiniPanelStart&quot;, BR);</b>
<b class="nc">&nbsp;        for (int loc = 0 ; loc &lt; entity.locations(); loc++) {</b>
&nbsp;            // addToTT(&quot;ArmorMiniPanelPart&quot;, BR, entity.getLocationAbbr(loc));
&nbsp;            // If location is destroyed, mark it and move on
<b class="nc">&nbsp;            if (entity.getInternal(loc) == IArmorState.ARMOR_DOOMED ||</b>
<b class="nc">&nbsp;                    entity.getInternal(loc) == IArmorState.ARMOR_DESTROYED) {</b>
&nbsp;                // This is a really awkward way of making sure
<b class="nc">&nbsp;                addToTT(&quot;ArmorMiniPanelPartNoRear&quot;, BR, entity.getLocationAbbr(loc), fontSize);</b>
<b class="nc">&nbsp;                for (int a = 0; a &lt;= entity.getOInternal(loc)/visUnit; a++) {</b>
<b class="nc">&nbsp;                    addToTT(&quot;BlockColored&quot;, NOBR, destroyedChar, fontSize, colorDamaged);</b>
&nbsp;                }
&nbsp;
&nbsp;            } else {
&nbsp;                // Put rear armor blocks first, with some spacing, if unit has any.
<b class="nc">&nbsp;                if (entity.hasRearArmor(loc)) {</b>
<b class="nc">&nbsp;                    addToTT(&quot;ArmorMiniPanelPartRear&quot;, BR, entity.getLocationAbbr(loc), fontSize);</b>
<b class="nc">&nbsp;                    for (int a = 0; a &lt;= (entity.getOArmor(loc, true)/visUnit); a++) {</b>
<b class="nc">&nbsp;                        if (a &lt; (entity.getArmor(loc, true)/visUnit)) {</b>
<b class="nc">&nbsp;                            addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorIntact);</b>
<b class="nc">&nbsp;                        } else if (a == (entity.getArmor(loc, true)/visUnit) &amp;&amp;</b>
<b class="nc">&nbsp;                                (entity.getArmor(loc, true) % visUnit) &gt; 0) {</b>
&nbsp;                            // Fraction of a visUnit left, but still display a &quot;full&quot; if at starting max armor
<b class="nc">&nbsp;                            if (entity.getArmor(loc, true) == entity.getOArmor(loc, true)) {</b>
<b class="nc">&nbsp;                                addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorIntact);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorPartialDmg);;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } else if ((entity.getOArmor(loc, true) % visUnit) &gt; 0) {</b>
<b class="nc">&nbsp;                            addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorDamaged);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    tooltipString.append(&quot;&amp;nbsp;&amp;nbsp;&quot;);</b>
<b class="nc">&nbsp;                    addToTT(&quot;ArmorMiniPanelPart&quot;, BR, entity.getLocationAbbr(loc), fontSize);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    addToTT(&quot;ArmorMiniPanelPartNoRear&quot;, BR, entity.getLocationAbbr(loc), fontSize);</b>
&nbsp;                }
&nbsp;                // Add IS shade blocks.
<b class="nc">&nbsp;                for (int a = 0; a &lt;= (entity.getOInternal(loc)/visUnit); a++) {</b>
<b class="nc">&nbsp;                    if (a &lt; (entity.getInternal(loc)/visUnit)) {</b>
<b class="nc">&nbsp;                        addToTT(&quot;BlockColored&quot;, NOBR, internalChar, fontSize, colorIntact);</b>
<b class="nc">&nbsp;                    } else if (a == (entity.getInternal(loc)/visUnit) &amp;&amp;</b>
<b class="nc">&nbsp;                            (entity.getInternal(loc) % visUnit) &gt; 0) {</b>
&nbsp;                        // Fraction of a visUnit left, but still display a &quot;full&quot; if at starting max armor
<b class="nc">&nbsp;                        if (entity.getInternal(loc) == entity.getOInternal(loc)) {</b>
<b class="nc">&nbsp;                            addToTT(&quot;BlockColored&quot;, NOBR, internalChar, fontSize, colorIntact);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            addToTT(&quot;BlockColored&quot;, NOBR, internalChar, fontSize, colorPartialDmg);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if ((entity.getOInternal(loc) % visUnit) &gt; 0) {</b>
<b class="nc">&nbsp;                        addToTT(&quot;BlockColored&quot;, NOBR, internalChar, fontSize, colorDamaged);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Add main armor blocks.
<b class="nc">&nbsp;                for (int a = 0; a &lt;= (entity.getOArmor(loc)/visUnit); a++) {</b>
<b class="nc">&nbsp;                    if (a &lt; (entity.getArmor(loc)/visUnit)) {</b>
<b class="nc">&nbsp;                        addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorIntact);</b>
<b class="nc">&nbsp;                    } else if (a == (entity.getArmor(loc)/visUnit) &amp;&amp;</b>
<b class="nc">&nbsp;                            (entity.getArmor(loc) % visUnit) &gt; 0) {</b>
&nbsp;                        // Fraction of a visUnit left, but still display a &quot;full&quot; if at starting max armor
<b class="nc">&nbsp;                        if (entity.getArmor(loc) == entity.getOArmor(loc)) {</b>
<b class="nc">&nbsp;                            addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorIntact);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorPartialDmg);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if ((entity.getOArmor(loc) % visUnit) &gt; 0){</b>
<b class="nc">&nbsp;                        addToTT(&quot;BlockColored&quot;, NOBR, armorChar, fontSize, colorDamaged);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        addToTT(&quot;ArmorMiniPanelEnd&quot;, NOBR);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a resource string to the entity tooltip
&nbsp;     * 
&nbsp;     * @param ttSName The resource string name. &quot;BoardView1.Tooltip.&quot; will be added in front, so
&nbsp;     * &quot;Pilot&quot; will retrieve BoardView1.Tooltip.Pilot
&nbsp;     * @param startBR = true will start the string with a &amp;lt;BR&amp;gt;; The constants BR and NOBR can be used here. 
&nbsp;     * @param ttO a list of Objects to insert into the {x} places in the resource.
&nbsp;     */
&nbsp;    private void addToTT(String ttSName, boolean startBR, Object... ttO) {
<b class="nc">&nbsp;        if (startBR == BR){</b>
<b class="nc">&nbsp;            if (skipBRafterTable) {</b>
<b class="nc">&nbsp;                skipBRafterTable = false;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                tooltipString.append(&quot;&lt;BR&gt;&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (ttO != null) {</b>
<b class="nc">&nbsp;            tooltipString.append(Messages.getString(&quot;BoardView1.Tooltip.&quot;</b>
&nbsp;                    + ttSName, ttO));
&nbsp;        } else {
<b class="nc">&nbsp;            tooltipString.append(Messages.getString(&quot;BoardView1.Tooltip.&quot;</b>
&nbsp;                    + ttSName));
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Adds a resource string to the entity tooltip
&nbsp;     * 
&nbsp;     * @param ttSName The resource string name. &quot;BoardView1.Tooltip.&quot; will be added in front, so
&nbsp;     * &quot;Pilot&quot; will retrieve BoardView1.Tooltip.Pilot
&nbsp;     * @param startBR = true will start the string with a &amp;lt;BR&amp;gt;; The constants BR and NOBR can be used here. 
&nbsp;     */
&nbsp;    private void addToTT(String ttSName, boolean startBR) {
<b class="nc">&nbsp;        addToTT(ttSName, startBR, (Object[]) null);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public StringBuffer getTooltip() {
&nbsp;
&nbsp;        // Tooltip info for a sensor blip
<b class="nc">&nbsp;        if (onlyDetectedBySensors())</b>
<b class="nc">&nbsp;            return new StringBuffer(Messages.getString(&quot;BoardView1.sensorReturn&quot;));</b>
&nbsp;
&nbsp;        // No sensor blip...
<b class="nc">&nbsp;        Infantry thisInfantry = null;</b>
<b class="nc">&nbsp;        if (entity instanceof Infantry) thisInfantry = (Infantry) entity;</b>
<b class="nc">&nbsp;        GunEmplacement thisGunEmp = null;</b>
<b class="nc">&nbsp;        if (entity instanceof GunEmplacement) thisGunEmp = (GunEmplacement) entity;</b>
<b class="nc">&nbsp;        IAero thisAero = null;</b>
<b class="nc">&nbsp;        if (entity.isAero()) thisAero = (IAero) entity;</b>
&nbsp;
<b class="nc">&nbsp;        tooltipString = new StringBuffer();</b>
&nbsp;
&nbsp;        // Unit Chassis and Player
<b class="nc">&nbsp;        addToTT(&quot;Unit&quot;, NOBR, entity.getOwner().getColour().getHexString(),</b>
<b class="nc">&nbsp;                entity.getChassis(), entity.getOwner().getName());</b>
&nbsp;
&nbsp;        // Pilot Info
&nbsp;        //put everything in table to allow for a pilot photo in second column
<b class="nc">&nbsp;        addToTT(&quot;PilotStart&quot;, BR);</b>
&nbsp;
&nbsp;        // Nickname &gt; Name &gt; &quot;Pilot&quot;
<b class="nc">&nbsp;        for (int i = 0; i &lt; entity.getCrew().getSlotCount(); i++) {</b>
<b class="nc">&nbsp;            String pnameStr = &quot;Pilot&quot;;</b>
&nbsp;
<b class="nc">&nbsp;            if (entity.getCrew().isMissing(i)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity.getCrew().getName(i) != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.getCrew().getName(i).equals(&quot;&quot;))</b>
<b class="nc">&nbsp;                pnameStr = entity.getCrew().getName(i);</b>
&nbsp;
<b class="nc">&nbsp;            if ((entity.getCrew().getNickname(i) != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.getCrew().getNickname(i).equals(&quot;&quot;))</b>
<b class="nc">&nbsp;                pnameStr = &quot;&#39;&quot; + entity.getCrew().getNickname(i) + &quot;&#39;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;            if (entity.getCrew().getSlotCount() &gt; 1) {</b>
<b class="nc">&nbsp;                pnameStr += &quot; (&quot; + entity.getCrew().getCrewType().getRoleName(i) + &quot;)&quot;;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            addToTT(&quot;Pilot&quot;, NOBR, pnameStr, entity.getCrew().getSkillsAsString(</b>
<b class="nc">&nbsp;                    bv.game.getOptions().booleanOption(OptionsConstants.RPG_RPG_GUNNERY)));</b>
&nbsp;
&nbsp;            // Pilot Status
<b class="nc">&nbsp;            if (!entity.getCrew().getStatusDesc(i).equals(&quot;&quot;)) {</b>
<b class="nc">&nbsp;                addToTT(&quot;PilotStatus&quot;, NOBR, entity.getCrew().getStatusDesc(i));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Pilot Advantages
<b class="nc">&nbsp;        int numAdv = entity.getCrew().countOptions(PilotOptions.LVL3_ADVANTAGES);</b>
<b class="nc">&nbsp;        if (numAdv == 1) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Adv1&quot;, NOBR, numAdv);</b>
<b class="nc">&nbsp;        } else if (numAdv &gt; 1) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Advs&quot;, NOBR, numAdv);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Pilot Manei Domini
<b class="nc">&nbsp;        if ((entity.getCrew().countOptions(PilotOptions.MD_ADVANTAGES) &gt; 0)) {</b>
<b class="nc">&nbsp;            addToTT(&quot;MD&quot;, NOBR);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            Infantry inf = (Infantry) entity;</b>
<b class="nc">&nbsp;            int spec = inf.getSpecializations();</b>
<b class="nc">&nbsp;            if (spec &gt; 0) {</b>
<b class="nc">&nbsp;                addToTT(&quot;InfSpec&quot;, BR, Infantry.getSpecializationName(spec));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        //add portrait?
<b class="nc">&nbsp;        if (null != entity.getCrew()) {</b>
<b class="nc">&nbsp;            AbstractIcon icon = entity.getCrew().getPortrait(0);</b>
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getBoolean(GUIPreferences.SHOW_PILOT_PORTRAIT_TT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (icon.getCategory() != null) &amp;&amp; (icon.getFilename() != null)) {</b>
<b class="nc">&nbsp;                String imagePath = Configuration.portraitImagesDir() + &quot;/&quot; + icon.getCategory()</b>
<b class="nc">&nbsp;                        + icon.getFilename();</b>
<b class="nc">&nbsp;                File f = new File(imagePath);</b>
<b class="nc">&nbsp;                if (f.exists()) {</b>
&nbsp;                    // HACK: Get the real portrait to find the size of the image
&nbsp;                    // and scale the tooltip HTML IMG accordingly
<b class="nc">&nbsp;                    Image portrait = icon.getImage(0, 0);</b>
<b class="nc">&nbsp;                    if (portrait.getWidth(null) &gt; portrait.getHeight(null)) {</b>
<b class="nc">&nbsp;                        float h = 60f * portrait.getHeight(null) / portrait.getWidth(null);</b>
<b class="nc">&nbsp;                        addToTT(&quot;PilotPortraitW&quot;, BR, imagePath, (int) h);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        float w = 60f * portrait.getWidth(null) / portrait.getHeight(null);</b>
<b class="nc">&nbsp;                        addToTT(&quot;PilotPortraitH&quot;, BR, imagePath, (int) w);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        addToTT(&quot;PilotEnd&quot;,NOBR);</b>
&nbsp;
&nbsp;        // Unit movement ability
<b class="nc">&nbsp;        if (thisGunEmp == null) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Movement&quot;, BR, entity.getWalkMP(), entity.getRunMPasString());</b>
<b class="nc">&nbsp;            if (entity.getJumpMP() &gt; 0) {</b>
<b class="nc">&nbsp;                tooltipString.append(&quot;/&quot;).append(entity.getJumpMP());</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Armor and Internals
<b class="nc">&nbsp;        addToTT(&quot;ArmorInternals&quot;, BR, entity.getTotalArmor(), entity.getTotalInternal());</b>
&nbsp;
&nbsp;        // Build a &quot;status bar&quot; visual representation of each
&nbsp;        // component of the unit using block element characters.
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getBoolean(GUIPreferences.SHOW_ARMOR_MINIVIS_TT)) {</b>
<b class="nc">&nbsp;            addArmorMiniVisToTT();</b>
<b class="nc">&nbsp;            skipBRafterTable = true;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // BV Info
&nbsp;        // Only show this if we aren&#39;t in double blind and hide enemy bv isn&#39;t selected.
&nbsp;        // Should always see this on your own Entities.
<b class="nc">&nbsp;        boolean suppressEnemyBV = bv.game.getOptions().booleanOption(OptionsConstants.ADVANCED_SUPPRESS_DB_BV) &amp;&amp;</b>
<b class="nc">&nbsp;                bv.game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND);</b>
&nbsp;
<b class="nc">&nbsp;        if (!(suppressEnemyBV &amp;&amp; !trackThisEntitiesVisibilityInfo(entity))) {</b>
<b class="nc">&nbsp;            int currentBV = entity.calculateBattleValue(false, false);</b>
<b class="nc">&nbsp;            int initialBV = entity.getInitialBV();</b>
<b class="nc">&nbsp;            double percentage = (double) currentBV / initialBV;</b>
&nbsp;
<b class="nc">&nbsp;            addToTT(&quot;BV&quot;, BR, currentBV, initialBV, percentage);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Heat, not shown for units with 999 heat sinks (vehicles)
<b class="nc">&nbsp;        if (entity.getHeatCapacity() != 999) {</b>
<b class="nc">&nbsp;            if (entity.heat == 0) </b>
<b class="nc">&nbsp;                addToTT(&quot;Heat0&quot;, BR);</b>
&nbsp;            else 
<b class="nc">&nbsp;                addToTT(&quot;Heat&quot;, BR, entity.heat);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Actual Movement
<b class="nc">&nbsp;        if (thisGunEmp == null) {</b>
&nbsp;            // In the Movement Phase, unit not done
<b class="nc">&nbsp;            if (!entity.isDone() &amp;&amp; this.bv.game.getPhase() == Phase.PHASE_MOVEMENT) {</b>
&nbsp;                // &quot;Has not yet moved&quot; only during movement phase
<b class="nc">&nbsp;                addToTT(&quot;NotYetMoved&quot;, BR);</b>
&nbsp;                
&nbsp;            // In the Movement Phase, unit is done - or in the Firing Phase
<b class="nc">&nbsp;            } else if (</b>
<b class="nc">&nbsp;                    (entity.isDone() &amp;&amp; this.bv.game.getPhase() == Phase.PHASE_MOVEMENT) </b>
<b class="nc">&nbsp;                    || this.bv.game.getPhase() == Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;                int tmm = Compute.getTargetMovementModifier(bv.game,</b>
<b class="nc">&nbsp;                        entity.getId()).getValue();</b>
&nbsp;                // Unit didn&#39;t move
<b class="nc">&nbsp;                if (entity.moved == EntityMovementType.MOVE_NONE) {</b>
<b class="nc">&nbsp;                    addToTT(&quot;NoMove&quot;, BR, tmm);</b>
&nbsp;                    
&nbsp;                // Unit did move
&nbsp;                } else {
&nbsp;                    // Actual movement and modifier
<b class="nc">&nbsp;                    addToTT(&quot;MovementF&quot;, BR,</b>
<b class="nc">&nbsp;                            entity.getMovementString(entity.moved),</b>
<b class="nc">&nbsp;                            entity.delta_distance,</b>
<b class="nc">&nbsp;                            tmm);</b>
&nbsp;                }
&nbsp;                // Special Moves
<b class="nc">&nbsp;                if (entity.isEvading()) </b>
<b class="nc">&nbsp;                    addToTT(&quot;Evade&quot;, NOBR);</b>
&nbsp;                
<b class="nc">&nbsp;                if ((thisInfantry != null) &amp;&amp; (thisInfantry.isTakingCover())) </b>
<b class="nc">&nbsp;                    addToTT(&quot;TakingCover&quot;, NOBR);</b>
&nbsp;
<b class="nc">&nbsp;                if (entity.isCharging()) </b>
<b class="nc">&nbsp;                    addToTT(&quot;Charging&quot;, NOBR);</b>
&nbsp;                
<b class="nc">&nbsp;                if (entity.isMakingDfa()) </b>
<b class="nc">&nbsp;                    addToTT(&quot;DFA&quot;, NOBR);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // ASF Velocity
<b class="nc">&nbsp;        if (thisAero != null) {</b>
<b class="nc">&nbsp;            addToTT(&quot;AeroVelocity&quot;, BR, thisAero.getCurrentVelocity());</b>
&nbsp;        }
&nbsp;            
&nbsp;        // Gun Emplacement Status
<b class="nc">&nbsp;        if (thisGunEmp != null) {  </b>
<b class="nc">&nbsp;            if (thisGunEmp.isTurret() &amp;&amp; thisGunEmp.isTurretLocked(thisGunEmp.getLocTurret())) </b>
<b class="nc">&nbsp;                addToTT(&quot;TurretLocked&quot;, BR);</b>
&nbsp;        }
&nbsp;       
&nbsp;        // Unit Immobile
<b class="nc">&nbsp;        if ((thisGunEmp == null) &amp;&amp; (entity.isImmobile()))</b>
<b class="nc">&nbsp;            addToTT(&quot;Immobile&quot;, BR);</b>
&nbsp;
<b class="nc">&nbsp;        if (entity.isHiddenActivating()) {</b>
<b class="nc">&nbsp;            addToTT(&quot;HiddenActivating&quot;, BR,</b>
<b class="nc">&nbsp;                    IGame.Phase.getDisplayableName(entity</b>
<b class="nc">&nbsp;                            .getHiddenActivationPhase()));</b>
<b class="nc">&nbsp;        } else if (entity.isHidden()) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Hidden&quot;, BR);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Jammed by ECM
<b class="nc">&nbsp;        if (isAffectedByECM()) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Jammed&quot;, BR);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Swarmed
<b class="nc">&nbsp;        if (entity.getSwarmAttackerId() != Entity.NONE) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Swarmed&quot;, BR,</b>
<b class="nc">&nbsp;                    bv.game.getEntity(entity.getSwarmAttackerId())</b>
<b class="nc">&nbsp;                            .getDisplayName());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Spotting
<b class="nc">&nbsp;        if (entity.isSpotting()) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Spotting&quot;, BR, bv.game.getEntity(entity.getSpotTargetId()).getDisplayName());</b>
&nbsp;        }
&nbsp;
&nbsp;        // If DB, add information about who sees this Entity
<b class="nc">&nbsp;        if (bv.game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)) {</b>
<b class="nc">&nbsp;            StringBuffer playerList = new StringBuffer();</b>
<b class="nc">&nbsp;            boolean teamVision = bv.game.getOptions().booleanOption(</b>
&nbsp;                    OptionsConstants.ADVANCED_TEAM_VISION);
<b class="nc">&nbsp;            for (IPlayer player : entity.getWhoCanSee()) {</b>
<b class="nc">&nbsp;                if (player.isEnemyOf(entity.getOwner()) || !teamVision) {</b>
<b class="nc">&nbsp;                    playerList.append(player.getName());</b>
<b class="nc">&nbsp;                    playerList.append(&quot;, &quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (playerList.length() &gt; 1) {</b>
<b class="nc">&nbsp;                playerList.delete(playerList.length() - 2, playerList.length());</b>
<b class="nc">&nbsp;                addToTT(&quot;SeenBy&quot;, BR, playerList.toString());</b>
&nbsp;            }            
&nbsp;        }
&nbsp;
&nbsp;        // If sensors, display what sensors this unit is using
<b class="nc">&nbsp;        if (bv.game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)</b>
<b class="nc">&nbsp;                || bv.game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)) {</b>
<b class="nc">&nbsp;            addToTT(&quot;Sensors&quot;, BR, entity.getSensorDesc());</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Towing
<b class="nc">&nbsp;        if (entity.getAllTowedUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;            String unitList = entity.getAllTowedUnits().stream()</b>
<b class="nc">&nbsp;                    .map(id -&gt; entity.getGame().getEntity(id).getDisplayName())</b>
<b class="nc">&nbsp;                    .collect(Collectors.joining(&quot;, &quot;));</b>
<b class="nc">&nbsp;            if (unitList.length() &gt; 1) {</b>
<b class="nc">&nbsp;                addToTT(&quot;Towing&quot;, BR, unitList);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Weapon List
<b class="nc">&nbsp;        if (GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                .getBoolean(GUIPreferences.SHOW_WPS_IN_TT)) {</b>
&nbsp;
<b class="nc">&nbsp;            ArrayList&lt;Mounted&gt; weapons = entity.getWeaponList();</b>
<b class="nc">&nbsp;            HashMap&lt;String, Integer&gt; wpNames = new HashMap&lt;String,Integer&gt;();</b>
&nbsp;
&nbsp;            // Gather names, counts, Clan/IS
&nbsp;            // When clan then the number will be stored as negative
<b class="nc">&nbsp;            for (Mounted curWp: weapons) {</b>
<b class="nc">&nbsp;                String weapDesc = curWp.getDesc();</b>
&nbsp;                // Append ranges
<b class="nc">&nbsp;                WeaponType wtype = (WeaponType)curWp.getType();</b>
&nbsp;                int ranges[];
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    ranges = wtype.getATRanges();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ranges = wtype.getRanges(curWp);</b>
&nbsp;                }
<b class="nc">&nbsp;                String rangeString = &quot; \u22EF &quot;;</b>
<b class="nc">&nbsp;                if ((ranges[RangeType.RANGE_MINIMUM] != WeaponType.WEAPON_NA) </b>
&nbsp;                        &amp;&amp; (ranges[RangeType.RANGE_MINIMUM] != 0)) {
<b class="nc">&nbsp;                    rangeString += &quot;(&quot; + ranges[RangeType.RANGE_MINIMUM] + &quot;) &quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                int maxRange = RangeType.RANGE_LONG;</b>
<b class="nc">&nbsp;                if (bv.game.getOptions().booleanOption(</b>
&nbsp;                        OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) {
<b class="nc">&nbsp;                    maxRange = RangeType.RANGE_EXTREME;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int i = RangeType.RANGE_SHORT; i &lt;= maxRange; i++) {</b>
<b class="nc">&nbsp;                    rangeString += ranges[i];</b>
<b class="nc">&nbsp;                    if (i != maxRange) {</b>
<b class="nc">&nbsp;                        rangeString += &quot;\u2B1D&quot;;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                weapDesc += rangeString;</b>
<b class="nc">&nbsp;                if (wpNames.containsKey(weapDesc)) {</b>
<b class="nc">&nbsp;                    int number = wpNames.get(weapDesc);</b>
<b class="nc">&nbsp;                    if (number &gt; 0) </b>
<b class="nc">&nbsp;                        wpNames.put(weapDesc, number + 1);</b>
&nbsp;                    else 
<b class="nc">&nbsp;                        wpNames.put(weapDesc, number - 1);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    WeaponType wpT = ((WeaponType)curWp.getType());</b>
&nbsp;
<b class="nc">&nbsp;                    if (entity.isClan() &amp;&amp; TechConstants.isClan(wpT.getTechLevel(entity.getYear()))) </b>
<b class="nc">&nbsp;                        wpNames.put(weapDesc, -1);</b>
&nbsp;                    else
<b class="nc">&nbsp;                        wpNames.put(weapDesc, 1);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Print to Tooltip
<b class="nc">&nbsp;            tooltipString.append(&quot;&lt;FONT SIZE=\&quot;-2\&quot;&gt;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            for (Entry&lt;String, Integer&gt; entry : wpNames.entrySet()) {</b>
&nbsp;                // Check if weapon is destroyed, text gray and strikethrough if so, remove the &quot;x &quot;/&quot;*&quot;
&nbsp;                // Also remove &quot;+&quot;, means currently selected for firing
<b class="nc">&nbsp;                boolean wpDest = false;</b>
<b class="nc">&nbsp;                String nameStr = entry.getKey();</b>
<b class="nc">&nbsp;                if (entry.getKey().startsWith(&quot;x &quot;)) { </b>
<b class="nc">&nbsp;                    nameStr = entry.getKey().substring(2, entry.getKey().length());</b>
<b class="nc">&nbsp;                    wpDest = true;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (entry.getKey().startsWith(&quot;*&quot;)) { </b>
<b class="nc">&nbsp;                    nameStr = entry.getKey().substring(1, entry.getKey().length());</b>
<b class="nc">&nbsp;                    wpDest = true;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (entry.getKey().startsWith(&quot;+&quot;)) { </b>
<b class="nc">&nbsp;                    nameStr = entry.getKey().substring(1, entry.getKey().length());</b>
<b class="nc">&nbsp;                    nameStr = nameStr.concat(&quot; &lt;I&gt;(Firing)&lt;/I&gt;&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // normal coloring 
<b class="nc">&nbsp;                tooltipString.append(&quot;&lt;FONT COLOR=#8080FF&gt;&quot;);</b>
&nbsp;                // but: color gray and strikethrough when weapon destroyed
<b class="nc">&nbsp;                if (wpDest) tooltipString.append(&quot;&lt;FONT COLOR=#a0a0a0&gt;&lt;S&gt;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                String clanStr = &quot;&quot;;</b>
<b class="nc">&nbsp;                if (entry.getValue() &lt; 0) clanStr = Messages.getString(&quot;BoardView1.Tooltip.Clan&quot;);</b>
&nbsp;
&nbsp;                // when more than 5 weapons are present, they will be grouped
&nbsp;                // and listed with a multiplier
<b class="nc">&nbsp;                if (weapons.size() &gt; 5) {</b>
<b class="nc">&nbsp;                    addToTT(&quot;WeaponN&quot;, BR, Math.abs(entry.getValue()), clanStr, nameStr);</b>
&nbsp;
&nbsp;                } else { // few weapons: list each weapon separately
<b class="nc">&nbsp;                    for (int i = 0; i &lt; Math.abs(entry.getValue()); i++) {</b>
<b class="nc">&nbsp;                        addToTT(&quot;Weapon&quot;, BR, Math.abs(entry.getValue()), clanStr, nameStr);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Weapon destroyed? End strikethrough
<b class="nc">&nbsp;                if (wpDest) tooltipString.append(&quot;&lt;/S&gt;&quot;);</b>
<b class="nc">&nbsp;                tooltipString.append(&quot;&lt;/FONT&gt;&quot;); </b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            tooltipString.append(&quot;&lt;/FONT&gt;&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return tooltipString;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public String getPlayerColor() {
<b class="nc">&nbsp;        if (onlyDetectedBySensors()) {</b>
&nbsp;            // TODO : Make me customizable
<b class="nc">&nbsp;            return &quot;C0C0C0&quot;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return entity.getOwner().getColour().getHexString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public boolean isAffectedByECM() {
<b class="nc">&nbsp;        return isAffectedByECM;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setAffectedByECM(boolean isAffectedByECM) {
<b class="nc">&nbsp;        boolean changed = isAffectedByECM != this.isAffectedByECM;</b>
<b class="nc">&nbsp;        this.isAffectedByECM = isAffectedByECM;</b>
&nbsp;        // We need to prepare the icon again if the value changed
<b class="nc">&nbsp;        if (changed) {</b>
<b class="nc">&nbsp;            prepare();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /** Marks the entity as selected for movement etc., recoloring the label */
&nbsp;    public void setSelected(boolean status) {
<b class="nc">&nbsp;        if (isSelected != status) {</b>
<b class="nc">&nbsp;            isSelected = status;</b>
<b class="nc">&nbsp;            prepare();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /** Returns if the entity is marked as selected for movement etc., recoloring the label */
&nbsp;    public boolean getSelected() {
<b class="nc">&nbsp;        return isSelected;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int getSpritePriority() {
<b class="nc">&nbsp;        return entity.getSpriteDrawPriority();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
