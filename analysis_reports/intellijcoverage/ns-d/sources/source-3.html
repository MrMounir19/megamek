


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > BoardView1</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ui.swing.boardview</a>
</div>

<h1>Coverage Summary for Class: BoardView1 (megamek.client.ui.swing.boardview)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BoardView1</td>
<td class="coverageStat">
  <span class="percent">
    0.5%
  </span>
  <span class="absValue">
    (1/196)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.7%
  </span>
  <span class="absValue">
    (21/3143)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BoardView1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/106)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$19</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$MovingUnit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BoardView1$RedrawWorker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0.4%
  </span>
  <span class="absValue">
    (1/263)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.6%
  </span>
  <span class="absValue">
    (21/3494)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2018 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.client.ui.swing.boardview;
&nbsp;
&nbsp;import java.awt.AlphaComposite;
&nbsp;import java.awt.BasicStroke;
&nbsp;import java.awt.Color;
&nbsp;import java.awt.Component;
&nbsp;import java.awt.Composite;
&nbsp;import java.awt.Cursor;
&nbsp;import java.awt.Dimension;
&nbsp;import java.awt.Font;
&nbsp;import java.awt.FontMetrics;
&nbsp;import java.awt.GradientPaint;
&nbsp;import java.awt.Graphics;
&nbsp;import java.awt.Graphics2D;
&nbsp;import java.awt.GraphicsConfiguration;
&nbsp;import java.awt.GraphicsEnvironment;
&nbsp;import java.awt.Image;
&nbsp;import java.awt.MediaTracker;
&nbsp;import java.awt.Point;
&nbsp;import java.awt.Polygon;
&nbsp;import java.awt.Rectangle;
&nbsp;import java.awt.RenderingHints;
&nbsp;import java.awt.Shape;
&nbsp;import java.awt.Toolkit;
&nbsp;import java.awt.Transparency;
&nbsp;import java.awt.event.ActionEvent;
&nbsp;import java.awt.event.KeyEvent;
&nbsp;import java.awt.event.MouseEvent;
&nbsp;import java.awt.event.MouseListener;
&nbsp;import java.awt.event.MouseMotionAdapter;
&nbsp;import java.awt.event.MouseMotionListener;
&nbsp;import java.awt.event.MouseWheelEvent;
&nbsp;import java.awt.event.MouseWheelListener;
&nbsp;import java.awt.font.GlyphVector;
&nbsp;import java.awt.geom.AffineTransform;
&nbsp;import java.awt.geom.Path2D;
&nbsp;import java.awt.geom.Point2D;
&nbsp;import java.awt.image.BufferedImage;
&nbsp;import java.awt.image.BufferedImageOp;
&nbsp;import java.awt.image.ConvolveOp;
&nbsp;import java.awt.image.ImageObserver;
&nbsp;import java.awt.image.ImageProducer;
&nbsp;import java.awt.image.Kernel;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import javax.imageio.ImageIO;
&nbsp;import javax.swing.AbstractAction;
&nbsp;import javax.swing.JOptionPane;
&nbsp;import javax.swing.JPanel;
&nbsp;import javax.swing.JPopupMenu;
&nbsp;import javax.swing.JScrollBar;
&nbsp;import javax.swing.JScrollPane;
&nbsp;import javax.swing.JViewport;
&nbsp;import javax.swing.ScrollPaneLayout;
&nbsp;import javax.swing.Scrollable;
&nbsp;import javax.swing.SwingConstants;
&nbsp;import javax.swing.SwingUtilities;
&nbsp;import javax.swing.ToolTipManager;
&nbsp;import javax.swing.plaf.metal.DefaultMetalTheme;
&nbsp;import javax.swing.plaf.metal.MetalTheme;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.client.TimerSingleton;
&nbsp;import megamek.client.bot.princess.BotGeometry.ConvexBoardArea;
&nbsp;import megamek.client.bot.princess.PathEnumerator;
&nbsp;import megamek.client.bot.princess.Princess;
&nbsp;import megamek.client.event.BoardViewEvent;
&nbsp;import megamek.client.event.BoardViewListener;
&nbsp;import megamek.client.event.MechDisplayEvent;
&nbsp;import megamek.client.ui.IBoardView;
&nbsp;import megamek.client.ui.IDisplayable;
&nbsp;import megamek.client.ui.Messages;
&nbsp;import megamek.client.ui.SharedUtility;
&nbsp;import megamek.client.ui.swing.ChatterBox2;
&nbsp;import megamek.client.ui.swing.ClientGUI;
&nbsp;import megamek.client.ui.swing.GUIPreferences;
&nbsp;import megamek.client.ui.swing.MovementDisplay;
&nbsp;import megamek.client.ui.swing.tileset.HexTileset;
&nbsp;import megamek.client.ui.swing.tileset.TilesetManager;
&nbsp;import megamek.client.ui.swing.util.CommandAction;
&nbsp;import megamek.client.ui.swing.util.ImageCache;
&nbsp;import megamek.client.ui.swing.util.KeyCommandBind;
&nbsp;import megamek.client.ui.swing.util.MegaMekController;
&nbsp;import megamek.client.ui.swing.widget.MegamekBorder;
&nbsp;import megamek.client.ui.swing.widget.SkinSpecification;
&nbsp;import megamek.client.ui.swing.widget.SkinXMLHandler;
&nbsp;import megamek.common.ArtilleryTracker;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.Building.BasementType;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.ComputeECM;
&nbsp;import megamek.common.Configuration;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.ECMInfo;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityVisibilityUtils;
&nbsp;import megamek.common.Flare;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.IBoard;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.IPlayer;
&nbsp;import megamek.common.ITerrain;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.LosEffects;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.Minefield;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.MoveStep;
&nbsp;import megamek.common.PlanetaryConditions;
&nbsp;import megamek.common.QuadMech;
&nbsp;import megamek.common.SpecialHexDisplay;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.TripodMech;
&nbsp;import megamek.common.UnitLocation;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.ChargeAttackAction;
&nbsp;import megamek.common.actions.ClubAttackAction;
&nbsp;import megamek.common.actions.DfaAttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.KickAttackAction;
&nbsp;import megamek.common.actions.PhysicalAttackAction;
&nbsp;import megamek.common.actions.ProtomechPhysicalAttackAction;
&nbsp;import megamek.common.actions.PunchAttackAction;
&nbsp;import megamek.common.actions.PushAttackAction;
&nbsp;import megamek.common.actions.SearchlightAttackAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.event.BoardEvent;
&nbsp;import megamek.common.event.BoardListener;
&nbsp;import megamek.common.event.GameBoardChangeEvent;
&nbsp;import megamek.common.event.GameBoardNewEvent;
&nbsp;import megamek.common.event.GameEntityChangeEvent;
&nbsp;import megamek.common.event.GameEntityNewEvent;
&nbsp;import megamek.common.event.GameEntityRemoveEvent;
&nbsp;import megamek.common.event.GameListener;
&nbsp;import megamek.common.event.GameListenerAdapter;
&nbsp;import megamek.common.event.GameNewActionEvent;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.logging.LogLevel;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.BoardClusterTracker;
&nbsp;import megamek.common.pathfinder.BoardClusterTracker.BoardCluster;
&nbsp;import megamek.common.preference.IClientPreferences;
&nbsp;import megamek.common.preference.IPreferenceChangeListener;
&nbsp;import megamek.common.preference.PreferenceChangeEvent;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;import megamek.common.util.FiringSolution;
&nbsp;import megamek.common.util.ImageUtil;
&nbsp;import megamek.common.util.fileUtils.MegaMekFile;
&nbsp;
&nbsp;/**
&nbsp; * Displays the board; lets the user scroll around and select points on it.
&nbsp; */
<b class="nc">&nbsp;public class BoardView1 extends JPanel implements IBoardView, Scrollable,</b>
&nbsp;        BoardListener, MouseListener, IPreferenceChangeListener {
&nbsp;
&nbsp;    private static final long serialVersionUID = -5582195884759007416L;
&nbsp;
&nbsp;    static final int TRANSPARENT = 0xFFFF00FF;
&nbsp;
&nbsp;    private static final int BOARD_HEX_CLICK = 1;
&nbsp;    private static final int BOARD_HEX_DOUBLECLICK = 2;
&nbsp;    private static final int BOARD_HEX_DRAG = 3;
&nbsp;    private static final int BOARD_HEX_POPUP = 4;
&nbsp;
&nbsp;    // the dimensions of megamek&#39;s hex images
&nbsp;    public static final int HEX_W = HexTileset.HEX_W;
&nbsp;    public static final int HEX_H = HexTileset.HEX_H;
<b class="fc">&nbsp;    public static final int HEX_DIAG = (int)Math.round(Math.sqrt(HEX_W * HEX_W + HEX_H * HEX_H));</b>
&nbsp;
&nbsp;    private static final int HEX_WC = HEX_W - (HEX_W / 4);
&nbsp;    static final int HEX_ELEV = 12;
&nbsp;
<b class="fc">&nbsp;    private static final float[] ZOOM_FACTORS = { 0.30f, 0.41f, 0.50f, 0.60f,</b>
&nbsp;            0.68f, 0.79f, 0.90f, 1.00f, 1.09f, 1.17f, 1.3f };
&nbsp;
<b class="fc">&nbsp;    private static final int[] ZOOM_SCALE_TYPES = {</b>
&nbsp;            ImageUtil.IMAGE_SCALE_AVG_FILTER, ImageUtil.IMAGE_SCALE_AVG_FILTER,
&nbsp;            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
&nbsp;            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
&nbsp;            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
&nbsp;            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
&nbsp;            ImageUtil.IMAGE_SCALE_BICUBIC };
&nbsp;
<b class="fc">&nbsp;    public static final int [] allDirections = {0,1,2,3,4,5};</b>
&nbsp;
&nbsp;    // Set to TRUE to draw hexes with isometric elevation.
<b class="nc">&nbsp;    private boolean drawIsometric = GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                                                  .getIsometricEnabled();</b>
&nbsp;
<b class="nc">&nbsp;    int DROPSHDW_DIST = 20;</b>
&nbsp;
&nbsp;    // the index of zoom factor 1.00f
&nbsp;    static final int BASE_ZOOM_INDEX = 7;
&nbsp;
&nbsp;    // Initial zoom index
<b class="nc">&nbsp;    public int zoomIndex = BASE_ZOOM_INDEX;</b>
&nbsp;
&nbsp;    // line width of the c3 network lines
&nbsp;    static final int C3_LINE_WIDTH = 1;
&nbsp;
&nbsp;    // line width of the fly over lines
&nbsp;    static final int FLY_OVER_LINE_WIDTH = 3;
&nbsp;
<b class="fc">&nbsp;    private static Font FONT_7 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 7); //$NON-NLS-1$</b>
<b class="fc">&nbsp;    private static Font FONT_8 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 8); //$NON-NLS-1$</b>
<b class="fc">&nbsp;    private static Font FONT_9 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 9); //$NON-NLS-1$</b>
<b class="fc">&nbsp;    private static Font FONT_10 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 10); //$NON-NLS-1$</b>
<b class="fc">&nbsp;    private static Font FONT_12 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 12); //$NON-NLS-1$</b>
&nbsp;
<b class="nc">&nbsp;    Dimension hex_size = null;</b>
&nbsp;
<b class="nc">&nbsp;    private Font font_note = FONT_10;</b>
<b class="nc">&nbsp;    private Font font_hexnum = FONT_10;</b>
<b class="nc">&nbsp;    private Font font_elev = FONT_9;</b>
<b class="nc">&nbsp;    private Font font_minefield = FONT_12;</b>
&nbsp;
&nbsp;    public final IGame game;
&nbsp;    ClientGUI clientgui;
&nbsp;
&nbsp;    private Dimension boardSize;
<b class="nc">&nbsp;    private Dimension preferredSize = new Dimension(0, 0);</b>
&nbsp;
&nbsp;    // scrolly stuff:
<b class="nc">&nbsp;    private JScrollPane scrollpane = null;</b>
&nbsp;    private JScrollBar vbar;
&nbsp;    private JScrollBar hbar;
<b class="nc">&nbsp;    private int scrollXDifference = 0;</b>
<b class="nc">&nbsp;    private int scrollYDifference = 0;</b>
&nbsp;    // are we drag-scrolling?
<b class="nc">&nbsp;    private boolean dragging = false;</b>
&nbsp;    /** True when the right mouse button was pressed to start a drag */
<b class="nc">&nbsp;    private boolean shouldScroll = false;</b>
&nbsp;
&nbsp;    // entity sprites
<b class="nc">&nbsp;    private Queue&lt;EntitySprite&gt; entitySprites = new PriorityQueue&lt;EntitySprite&gt;();</b>
<b class="nc">&nbsp;    private Queue&lt;IsometricSprite&gt; isometricSprites = new PriorityQueue&lt;IsometricSprite&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private ArrayList&lt;FlareSprite&gt; flareSprites = new ArrayList&lt;FlareSprite&gt;();</b>
&nbsp;    /**
&nbsp;     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
&nbsp;     * that the key is a List where the first entry will be the Entity ID and
&nbsp;     * the second entry will be which secondary position the sprite belongs to;
&nbsp;     * if the Entity has no secondary positions, the first element will be the
&nbsp;     * ID and the second element will be -1.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;List&lt;Integer&gt;, EntitySprite&gt; entitySpriteIds = new HashMap&lt;&gt;();</b>
&nbsp;    /**
&nbsp;     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
&nbsp;     * that the key is a List where the first entry will be the Entity ID and
&nbsp;     * the second entry will be which secondary position the sprite belongs to;
&nbsp;     * if the Entity has no secondary positions, the first element will be the
&nbsp;     * ID and the second element will be -1.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; isometricSpriteIds = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    // sprites for the three selection cursors
&nbsp;    private CursorSprite cursorSprite;
&nbsp;    private CursorSprite highlightSprite;
&nbsp;    private CursorSprite selectedSprite;
&nbsp;    private CursorSprite firstLOSSprite;
&nbsp;    private CursorSprite secondLOSSprite;
&nbsp;
&nbsp;    // sprite for current movement
<b class="nc">&nbsp;    ArrayList&lt;StepSprite&gt; pathSprites = new ArrayList&lt;StepSprite&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private ArrayList&lt;Coords&gt; strafingCoords = new ArrayList&lt;Coords&gt;(5);</b>
&nbsp;
<b class="nc">&nbsp;    private ArrayList&lt;FiringSolutionSprite&gt; firingSprites = new ArrayList&lt;FiringSolutionSprite&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private ArrayList&lt;MovementEnvelopeSprite&gt; moveEnvSprites = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private ArrayList&lt;MovementModifierEnvelopeSprite&gt; moveModEnvSprites = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    // vector of sprites for all firing lines
<b class="nc">&nbsp;    ArrayList&lt;AttackSprite&gt; attackSprites = new ArrayList&lt;AttackSprite&gt;();</b>
&nbsp;
&nbsp;    // vector of sprites for all movement paths (using vectored movement)
<b class="nc">&nbsp;    private ArrayList&lt;MovementSprite&gt; movementSprites = new ArrayList&lt;MovementSprite&gt;();</b>
&nbsp;
&nbsp;    // vector of sprites for C3 network lines
<b class="nc">&nbsp;    private ArrayList&lt;C3Sprite&gt; c3Sprites = new ArrayList&lt;C3Sprite&gt;();</b>
&nbsp;
&nbsp;    // list of sprites for declared VTOL/airmech bombing/strafing targets
<b class="nc">&nbsp;    private ArrayList&lt;VTOLAttackSprite&gt; vtolAttackSprites = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    // vector of sprites for aero flyover lines
<b class="nc">&nbsp;    private ArrayList&lt;FlyOverSprite&gt; flyOverSprites = new ArrayList&lt;FlyOverSprite&gt;();</b>
&nbsp;
&nbsp;    // List of sprites for the weapon field of fire
<b class="nc">&nbsp;    private ArrayList&lt;HexSprite&gt; fieldofFireSprites = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    public int[][] fieldofFireRanges = { new int[5], new int[5] };</b>
&nbsp;    public int fieldofFireWpArc;
&nbsp;    public Entity fieldofFireUnit;
&nbsp;    public int fieldofFireWpLoc;
&nbsp;    // int because it acts as an array index
<b class="nc">&nbsp;    public int fieldofFireWpUnderwater = 0;</b>
<b class="fc">&nbsp;    private static final String[] rangeTexts = { &quot;min&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;E&quot; };</b>
&nbsp;
<b class="nc">&nbsp;    TilesetManager tileManager = null;</b>
&nbsp;
&nbsp;    // polygons for a few things
&nbsp;    static Polygon hexPoly;
&nbsp;    static {
&nbsp;        // hex polygon
<b class="fc">&nbsp;        hexPoly = new Polygon();</b>
<b class="fc">&nbsp;        hexPoly.addPoint(21, 0);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(62, 0);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(83, 35);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(83, 36);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(62, 71);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(21, 71);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(0, 36);</b>
<b class="fc">&nbsp;        hexPoly.addPoint(0, 35);</b>
&nbsp;    }
&nbsp;
&nbsp;    Shape[] movementPolys;
&nbsp;    Shape[] facingPolys;
&nbsp;    Shape[] finalFacingPolys;
&nbsp;    Shape upArrow;
&nbsp;    Shape downArrow;
&nbsp;
&nbsp;    // Image to hold the complete board shadow map
&nbsp;    BufferedImage shadowMap;
<b class="nc">&nbsp;    double[] lightDirection = { -19, 7 };</b>
<b class="fc">&nbsp;    private static Kernel kernel = new Kernel(5, 5,</b>
&nbsp;            new float[] {
&nbsp;                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
&nbsp;                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
&nbsp;                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
&nbsp;                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
&nbsp;                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f});
<b class="fc">&nbsp;    private static BufferedImageOp blurOp = new ConvolveOp(kernel);</b>
&nbsp;
&nbsp;    // the player who owns this BoardView&#39;s client
<b class="nc">&nbsp;    private IPlayer localPlayer = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Stores the currently deploying entity, used for highlighting deployment
&nbsp;     * hexes.
&nbsp;     */
<b class="nc">&nbsp;    private Entity en_Deployer = null;</b>
&nbsp;
&nbsp;    // should be able to turn it off(board editor)
<b class="nc">&nbsp;    private boolean useLOSTool = true;</b>
&nbsp;
&nbsp;    // Initial scale factor for sprites and map
<b class="nc">&nbsp;    float scale = 1.00f;</b>
<b class="nc">&nbsp;    private ImageCache&lt;Integer, Image&gt; scaledImageCache =</b>
&nbsp;            new ImageCache&lt;Integer, Image&gt;();
<b class="nc">&nbsp;    private ImageCache&lt;Integer, BufferedImage&gt; shadowImageCache =</b>
&nbsp;            new ImageCache&lt;Integer, BufferedImage&gt;();
&nbsp;
<b class="nc">&nbsp;    private Set&lt;Integer&gt; animatedImages = new HashSet&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    // Displayables (Chat box, etc.)
<b class="nc">&nbsp;    ArrayList&lt;IDisplayable&gt; displayables = new ArrayList&lt;IDisplayable&gt;();</b>
&nbsp;
&nbsp;    // Move units step by step
<b class="nc">&nbsp;    private ArrayList&lt;MovingUnit&gt; movingUnits = new ArrayList&lt;MovingUnit&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private long moveWait = 0;</b>
&nbsp;
&nbsp;    // moving entity sprites
<b class="nc">&nbsp;    private List&lt;MovingEntitySprite&gt; movingEntitySprites = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private HashMap&lt;Integer, MovingEntitySprite&gt; movingEntitySpriteIds = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private ArrayList&lt;GhostEntitySprite&gt; ghostEntitySprites = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    protected transient ArrayList&lt;BoardViewListener&gt; boardListeners = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    // wreck sprites
<b class="nc">&nbsp;    private ArrayList&lt;WreckSprite&gt; wreckSprites = new ArrayList&lt;WreckSprite&gt;();</b>
<b class="nc">&nbsp;    private ArrayList&lt;IsometricWreckSprite&gt; isometricWreckSprites = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    private Coords rulerStart;
&nbsp;    private Coords rulerEnd;
&nbsp;    private Color rulerStartColor;
&nbsp;    private Color rulerEndColor;
&nbsp;
&nbsp;    private Coords lastCursor;
&nbsp;    private Coords highlighted;
&nbsp;    Coords selected;
&nbsp;    private Coords firstLOS;
&nbsp;
&nbsp;    /** stores the theme last selected to override all hex themes */
<b class="nc">&nbsp;    private String selectedTheme = null;</b>
&nbsp;
&nbsp;    // selected entity and weapon for artillery display
<b class="nc">&nbsp;    Entity selectedEntity = null;</b>
<b class="nc">&nbsp;    private Mounted selectedWeapon = null;</b>
&nbsp;
&nbsp;    // hexes with ECM effect
<b class="nc">&nbsp;    private Map&lt;Coords, Color&gt; ecmHexes = null;</b>
&nbsp;    // hexes that are teh centers of ECM effects
<b class="nc">&nbsp;    private Map&lt;Coords, Color&gt; ecmCenters = null;</b>
&nbsp;    // hexes with ECM effect
<b class="nc">&nbsp;    private Map&lt;Coords, Color&gt; eccmHexes = null;</b>
&nbsp;    // hexes that are teh centers of ECCM effects
<b class="nc">&nbsp;    private Map&lt;Coords, Color&gt; eccmCenters = null;</b>
&nbsp;
&nbsp;    // reference to our timertask for redraw
<b class="nc">&nbsp;    private TimerTask ourTask = null;</b>
&nbsp;
<b class="nc">&nbsp;    BufferedImage bvBgImage = null;</b>
<b class="nc">&nbsp;    boolean bvBgShouldTile = false;</b>
<b class="nc">&nbsp;    BufferedImage scrollPaneBgBuffer = null;</b>
<b class="nc">&nbsp;    Image scrollPaneBgImg = null;</b>
&nbsp;
<b class="nc">&nbsp;    List&lt;Image&gt; boardBackgrounds = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    private static final int FRAMES = 24;
&nbsp;    private long totalTime;
&nbsp;    private long averageTime;
&nbsp;    private int frameCount;
<b class="nc">&nbsp;    private Font fpsFont = new Font(&quot;SansSerif&quot;, 0, 20); //$NON-NLS-1$</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether we have an active ChatterBox2
&nbsp;     */
<b class="nc">&nbsp;    private boolean chatterBoxActive = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether an outside source tells the BoardView that it
&nbsp;     * should ignore keyboard commands.
&nbsp;     */
<b class="nc">&nbsp;    private boolean shouldIgnoreKeys = false;</b>
&nbsp;
&nbsp;    FovHighlightingAndDarkening fovHighlightingAndDarkening;
&nbsp;
<b class="nc">&nbsp;    private String FILENAME_FLARE_IMAGE = &quot;flare.png&quot;;</b>
&nbsp;
<b class="nc">&nbsp;    private String FILENAME_RADAR_BLIP_IMAGE = &quot;radarBlip.png&quot;;</b>
&nbsp;
&nbsp;    private Image flareImage;
&nbsp;
&nbsp;    private Image radarBlipImage;
&nbsp;
&nbsp;    /**
&nbsp;    * Cache that stores hex images for different coords
&nbsp;    */
&nbsp;    ImageCache&lt;Coords, HexImageCacheEntry&gt; hexImageCache;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether all deployment zones should
&nbsp;     * be shown in the Arty Auto Hit Designation phase
&nbsp;     */
<b class="nc">&nbsp;    public boolean showAllDeployment = false;</b>
&nbsp;
&nbsp;    private long paintCompsStartTime;
&nbsp;
<b class="nc">&nbsp;    private Rectangle displayablesRect = new Rectangle();</b>
&nbsp;
&nbsp;    // Soft Centering ---
&nbsp;
&nbsp;    /** True when the board is in the process of centering to a spot. */
<b class="nc">&nbsp;    private boolean isSoftCentering = false;</b>
&nbsp;    /** The final position of a soft centering relative to board size (x, y=0...1). */
<b class="nc">&nbsp;    private Point2D softCenterTarget = new Point2D.Double();</b>
<b class="nc">&nbsp;    private Point2D oldCenter = new Point2D.Double();</b>
&nbsp;    private long waitTimer;
&nbsp;    /** Speed of soft centering of the board, less is faster */
&nbsp;    private static final int SOFT_CENTER_SPEED = 8;
&nbsp;
&nbsp;    // Tooltip Info ---
&nbsp;    /** Holds the final Coords for a planned movement. Set by MovementDisplay,
&nbsp;     *  used to display the distance in the board tooltip. */
&nbsp;    private Coords movementTarget;
&nbsp;
&nbsp;    // Used to track the previous x/y for tooltip display
<b class="nc">&nbsp;    int prevTipX = -1, prevTipY = -1;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag to indicate if we should display informatin about illegal terrain in hexes.
&nbsp;     */
<b class="nc">&nbsp;    boolean displayInvalidHexInfo = false;</b>
&nbsp;
&nbsp;    /** Stores the correct tooltip dismiss delay so it can be restored when exiting the boardview */
<b class="nc">&nbsp;    private int dismissDelay = ToolTipManager.sharedInstance().getDismissDelay();</b>
&nbsp;    
&nbsp;    /** A map overlay showing some important keybinds. */ 
&nbsp;    KeyBindingsOverlay keybindOverlay;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new board view for the specified game
&nbsp;     */
&nbsp;    public BoardView1(final IGame game, final MegaMekController controller, ClientGUI clientgui)
<b class="nc">&nbsp;            throws java.io.IOException {</b>
<b class="nc">&nbsp;        this.game = game;</b>
<b class="nc">&nbsp;        this.clientgui = clientgui;</b>
&nbsp;
<b class="nc">&nbsp;        hexImageCache = new ImageCache&lt;Coords, HexImageCacheEntry&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        tileManager = new TilesetManager(this);</b>
<b class="nc">&nbsp;        ToolTipManager.sharedInstance().registerComponent(this);</b>
&nbsp;
<b class="nc">&nbsp;        game.addGameListener(gameListener);</b>
<b class="nc">&nbsp;        game.getBoard().addBoardListener(this);</b>
&nbsp;        
<b class="nc">&nbsp;        keybindOverlay = new KeyBindingsOverlay(game, clientgui);</b>
<b class="nc">&nbsp;        addDisplayable(keybindOverlay);</b>
<b class="nc">&nbsp;        ourTask = scheduleRedrawTimer();// call only once</b>
<b class="nc">&nbsp;        clearSprites();</b>
<b class="nc">&nbsp;        addMouseListener(this);</b>
<b class="nc">&nbsp;        addMouseWheelListener(new MouseWheelListener() {</b>
&nbsp;            public void mouseWheelMoved(MouseWheelEvent we) {
<b class="nc">&nbsp;                Point mousePoint = we.getPoint();</b>
<b class="nc">&nbsp;                Point dispPoint = new Point(mousePoint.x + getBounds().x, mousePoint.y + getBounds().y);</b>
&nbsp;                
&nbsp;                // If the mouse is over an IDisplayable, have it react instead of the board
&nbsp;                // Currently only implemented for the ChatterBox
<b class="nc">&nbsp;                for (int i = 0; i &lt; displayables.size(); i++) {</b>
<b class="nc">&nbsp;                    IDisplayable disp = displayables.get(i);</b>
<b class="nc">&nbsp;                    if (!(disp instanceof ChatterBox2)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    double width = scrollpane.getViewport().getSize().getWidth();</b>
<b class="nc">&nbsp;                    double height = scrollpane.getViewport().getSize().getHeight();</b>
<b class="nc">&nbsp;                    Dimension drawDimension = new Dimension();</b>
<b class="nc">&nbsp;                    drawDimension.setSize(width, height);</b>
&nbsp;                    // we need to adjust the point, because it should be against
&nbsp;                    // the displayable dimension
<b class="nc">&nbsp;                    if (disp.isMouseOver(dispPoint, drawDimension)) {</b>
<b class="nc">&nbsp;                        ChatterBox2 cb2 = (ChatterBox2) disp;</b>
<b class="nc">&nbsp;                        if (we.getWheelRotation() &gt; 0) {</b>
<b class="nc">&nbsp;                            cb2.scrollDown();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            cb2.scrollUp();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        refreshDisplayables();</b>
&nbsp;                        return;
&nbsp;                    }
&nbsp;                }
&nbsp;                
&nbsp;                // calculate a few things to reposition the map
<b class="nc">&nbsp;                Coords zoomCenter = getCoordsAt(we.getPoint());</b>
<b class="nc">&nbsp;                Point hexL = getCentreHexLocation(zoomCenter);</b>
<b class="nc">&nbsp;                Point inhexDelta = new Point(we.getPoint());</b>
<b class="nc">&nbsp;                inhexDelta.translate(-HEX_W, -HEX_H);</b>
<b class="nc">&nbsp;                inhexDelta.translate(-hexL.x, -hexL.y);</b>
<b class="nc">&nbsp;                double ihdx = ((double)inhexDelta.x)/((double)HEX_W)/scale;</b>
<b class="nc">&nbsp;                double ihdy = ((double)inhexDelta.y)/((double)HEX_H)/scale;</b>
<b class="nc">&nbsp;                int oldzoomIndex = zoomIndex;</b>
&nbsp;                
<b class="nc">&nbsp;                boolean ZoomNoCtrl = GUIPreferences.getInstance().getMouseWheelZoom();</b>
<b class="nc">&nbsp;                boolean wheelFlip = GUIPreferences.getInstance().getMouseWheelZoomFlip();</b>
<b class="nc">&nbsp;                boolean zoomIn = (we.getWheelRotation() &gt; 0) ^ wheelFlip; // = XOR</b>
<b class="nc">&nbsp;                boolean doZoom = ZoomNoCtrl ^ we.isControlDown(); // = XOR</b>
<b class="nc">&nbsp;                boolean horizontalScroll = !doZoom &amp;&amp; we.isShiftDown();</b>
&nbsp;
<b class="nc">&nbsp;                if (doZoom) {</b>
<b class="nc">&nbsp;                    if (zoomIn) {</b>
<b class="nc">&nbsp;                        zoomIn();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        zoomOut();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (zoomIndex != oldzoomIndex) {</b>
<b class="nc">&nbsp;                        adjustVisiblePosition(zoomCenter, dispPoint, ihdx, ihdy);</b>
&nbsp;                    }
&nbsp;                } else { // SCROLL
<b class="nc">&nbsp;                    if (horizontalScroll) {</b>
<b class="nc">&nbsp;                        hbar.setValue((int) (hbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    stopSoftCentering();</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                pingMinimap();</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {</b>
&nbsp;            @Override
&nbsp;            public void mouseMoved(MouseEvent e) {
<b class="nc">&nbsp;                Point point = e.getPoint();</b>
<b class="nc">&nbsp;                if (null == point) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (IDisplayable disp: displayables) {</b>
<b class="nc">&nbsp;                    if (disp.isBeingDragged()) {</b>
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    double width = Math.min(boardSize.getWidth(), scrollpane</b>
<b class="nc">&nbsp;                            .getViewport().getSize().getWidth());</b>
<b class="nc">&nbsp;                    double height = Math.min(boardSize.getHeight(), scrollpane</b>
<b class="nc">&nbsp;                            .getViewport().getSize().getHeight());</b>
<b class="nc">&nbsp;                    Dimension drawDimension = new Dimension();</b>
<b class="nc">&nbsp;                    drawDimension.setSize(width, height);</b>
<b class="nc">&nbsp;                    disp.isMouseOver(point, drawDimension);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void mouseDragged(MouseEvent e) {
<b class="nc">&nbsp;                Point point = e.getPoint();</b>
<b class="nc">&nbsp;                if (null == point) {</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                for (int i = 0; i &lt; displayables.size(); i++) {</b>
<b class="nc">&nbsp;                    IDisplayable disp = displayables.get(i);</b>
<b class="nc">&nbsp;                    Point adjustPoint = new Point((int) Math.min(</b>
<b class="nc">&nbsp;                            boardSize.getWidth(), -getBounds().getX()),</b>
<b class="nc">&nbsp;                                                  (int) Math.min(boardSize.getHeight(), -getBounds()</b>
<b class="nc">&nbsp;                                                          .getY()));</b>
<b class="nc">&nbsp;                    Point dispPoint = new Point();</b>
<b class="nc">&nbsp;                    dispPoint.x = point.x - adjustPoint.x;</b>
<b class="nc">&nbsp;                    dispPoint.y = point.y - adjustPoint.y;</b>
<b class="nc">&nbsp;                    double width = Math.min(boardSize.getWidth(), scrollpane</b>
<b class="nc">&nbsp;                            .getViewport().getSize().getWidth());</b>
<b class="nc">&nbsp;                    double height = Math.min(boardSize.getHeight(), scrollpane</b>
<b class="nc">&nbsp;                            .getViewport().getSize().getHeight());</b>
<b class="nc">&nbsp;                    Dimension drawDimension = new Dimension();</b>
<b class="nc">&nbsp;                    drawDimension.setSize(width, height);</b>
<b class="nc">&nbsp;                    if (disp.isDragged(dispPoint, drawDimension)) {</b>
<b class="nc">&nbsp;                        repaint();</b>
&nbsp;                        return;
&nbsp;                    }
&nbsp;                }
&nbsp;                // only scroll when we should
<b class="nc">&nbsp;                if (!shouldScroll) {</b>
<b class="nc">&nbsp;                    mouseAction(getCoordsAt(point), BOARD_HEX_DRAG,</b>
<b class="nc">&nbsp;                                e.getModifiers());</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;                // if we have not yet been dragging, set the var so popups don&#39;t
&nbsp;                // appear when we stop scrolling
<b class="nc">&nbsp;                if (!dragging) {</b>
<b class="nc">&nbsp;                    dragging = true;</b>
<b class="nc">&nbsp;                    setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));</b>
&nbsp;                }
<b class="nc">&nbsp;                Point p = scrollpane.getViewport().getViewPosition();</b>
<b class="nc">&nbsp;                int newX = p.x - (e.getX() - scrollXDifference);</b>
<b class="nc">&nbsp;                int newY = p.y - (e.getY() - scrollYDifference);</b>
<b class="nc">&nbsp;                int maxX = getWidth() - scrollpane.getViewport().getWidth();</b>
<b class="nc">&nbsp;                int maxY = getHeight() - scrollpane.getViewport().getHeight();</b>
<b class="nc">&nbsp;                if (newX &lt; 0) {</b>
<b class="nc">&nbsp;                    newX = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (newX &gt; maxX) {</b>
<b class="nc">&nbsp;                    newX = maxX;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (newY &lt; 0) {</b>
<b class="nc">&nbsp;                    newY = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (newY &gt; maxY) {</b>
<b class="nc">&nbsp;                    newY = maxY;</b>
&nbsp;                }
&nbsp;                // don&#39;t scroll horizontally if the board fits into the window
<b class="nc">&nbsp;                if (scrollpane.getViewport().getWidth() &gt;= getWidth()) {</b>
<b class="nc">&nbsp;                    newX = scrollpane.getViewport().getViewPosition().x;</b>
&nbsp;                }
<b class="nc">&nbsp;                scrollpane.getViewport().setViewPosition(new Point(newX, newY));</b>
&nbsp;            }
&nbsp;        };
<b class="nc">&nbsp;        addMouseMotionListener(mouseMotionListener);</b>
&nbsp;
<b class="nc">&nbsp;        if (controller != null) {</b>
<b class="nc">&nbsp;            registerKeyboardCommands(this, controller);</b>
&nbsp;        }
&nbsp;
&nbsp;        // setAutoscrolls(true);
&nbsp;
<b class="nc">&nbsp;        updateBoardSize();</b>
&nbsp;
<b class="nc">&nbsp;        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</b>
&nbsp;
<b class="nc">&nbsp;        initPolys();</b>
&nbsp;
<b class="nc">&nbsp;        cursorSprite = new CursorSprite(this, Color.cyan);</b>
<b class="nc">&nbsp;        highlightSprite = new CursorSprite(this, Color.white);</b>
<b class="nc">&nbsp;        selectedSprite = new CursorSprite(this, Color.blue);</b>
<b class="nc">&nbsp;        firstLOSSprite = new CursorSprite(this, Color.red);</b>
<b class="nc">&nbsp;        secondLOSSprite = new CursorSprite(this, Color.red);</b>
&nbsp;
<b class="nc">&nbsp;        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);</b>
<b class="nc">&nbsp;        GUIPreferences.getInstance().addPreferenceChangeListener(this);</b>
&nbsp;
<b class="nc">&nbsp;        SpecialHexDisplay.Type.ARTILLERY_HIT.init();</b>
<b class="nc">&nbsp;        SpecialHexDisplay.Type.ARTILLERY_INCOMING.init();</b>
<b class="nc">&nbsp;        SpecialHexDisplay.Type.ARTILLERY_TARGET.init();</b>
<b class="nc">&nbsp;        SpecialHexDisplay.Type.ARTILLERY_ADJUSTED.init();</b>
<b class="nc">&nbsp;        SpecialHexDisplay.Type.ARTILLERY_AUTOHIT.init();</b>
<b class="nc">&nbsp;        SpecialHexDisplay.Type.PLAYER_NOTE.init();</b>
&nbsp;
<b class="nc">&nbsp;        fovHighlightingAndDarkening = new FovHighlightingAndDarkening(this);</b>
&nbsp;
<b class="nc">&nbsp;        flareImage = ImageUtil.loadImageFromFile(</b>
<b class="nc">&nbsp;                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_FLARE_IMAGE)</b>
<b class="nc">&nbsp;                        .toString());</b>
<b class="nc">&nbsp;        radarBlipImage = ImageUtil.loadImageFromFile(</b>
<b class="nc">&nbsp;                new MegaMekFile(Configuration.miscImagesDir(),</b>
<b class="nc">&nbsp;                        FILENAME_RADAR_BLIP_IMAGE).toString());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void registerKeyboardCommands(final BoardView1 bv,
&nbsp;            final MegaMekController controller) {
&nbsp;        // Register the action for TOGGLE_ISO
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TOGGLE_ISO.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        GUIPreferences guip = GUIPreferences.getInstance();</b>
<b class="nc">&nbsp;                        guip.setIsometricEnabled(toggleIsometric());</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for TOGGLE_CHAT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        if (!getChatterBoxActive()) {</b>
<b class="nc">&nbsp;                            setChatterBoxActive(true);</b>
<b class="nc">&nbsp;                            for (IDisplayable disp : displayables) {</b>
<b class="nc">&nbsp;                                if (disp instanceof ChatterBox2) {</b>
<b class="nc">&nbsp;                                    ((ChatterBox2) disp).slideUp();</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            requestFocus();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for TOGGLE_CHAT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT_CMD.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        if (!getChatterBoxActive()) {</b>
<b class="nc">&nbsp;                            setChatterBoxActive(true);</b>
<b class="nc">&nbsp;                            for (IDisplayable disp : displayables) {</b>
<b class="nc">&nbsp;                                if (disp instanceof ChatterBox2) {</b>
<b class="nc">&nbsp;                                    ((ChatterBox2) disp).slideUp();</b>
<b class="nc">&nbsp;                                    ((ChatterBox2) disp).setMessage(&quot;/&quot;);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            requestFocus();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for CENTER_ON_SELECTED
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.CENTER_ON_SELECTED.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (shouldIgnoreKeyCommands() || (selectedEntity == null)) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        if (selectedEntity != null) {</b>
<b class="nc">&nbsp;                            centerOnHex(selectedEntity.getPosition());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for SCROLL_NORTH
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.SCROLL_NORTH.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        controller.stopRepeating(KeyCommandBind.SCROLL_SOUTH);</b>
<b class="nc">&nbsp;                        vbar.setValue((int) (vbar.getValue() - (HEX_H * scale)));</b>
<b class="nc">&nbsp;                        stopSoftCentering();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void releaseAction() {
<b class="nc">&nbsp;                        pingMinimap();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean hasReleaseAction() {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for SCROLL_SOUTH
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.SCROLL_SOUTH.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        controller.stopRepeating(KeyCommandBind.SCROLL_NORTH);</b>
<b class="nc">&nbsp;                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale)));</b>
<b class="nc">&nbsp;                        stopSoftCentering();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void releaseAction() {
<b class="nc">&nbsp;                        pingMinimap();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean hasReleaseAction() {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for SCROLL_EAST
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.SCROLL_EAST.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        controller.stopRepeating(KeyCommandBind.SCROLL_WEST);</b>
<b class="nc">&nbsp;                        hbar.setValue((int) (hbar.getValue() + (HEX_W * scale)));</b>
<b class="nc">&nbsp;                        stopSoftCentering();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void releaseAction() {
<b class="nc">&nbsp;                        pingMinimap();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean hasReleaseAction() {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for SCROLL_WEST
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.SCROLL_WEST.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        controller.stopRepeating(KeyCommandBind.SCROLL_EAST);</b>
<b class="nc">&nbsp;                        hbar.setValue((int) (hbar.getValue() - (HEX_W * scale)));</b>
<b class="nc">&nbsp;                        stopSoftCentering();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void releaseAction() {
<b class="nc">&nbsp;                        pingMinimap();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean hasReleaseAction() {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for Showing the Field of Fire
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.FIELD_FIRE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        GUIPreferences guip = GUIPreferences.getInstance();</b>
<b class="nc">&nbsp;                        guip.setShowFieldOfFire(!guip.getShowFieldOfFire());</b>
<b class="nc">&nbsp;                        repaint();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for Toggling drawing unit labels
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TOGGLE_DRAW_LABELS.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        GUIPreferences guip = GUIPreferences.getInstance();</b>
<b class="nc">&nbsp;                        boolean drawLabels = guip.getBoolean(</b>
&nbsp;                                GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL);
<b class="nc">&nbsp;                        guip.setValue(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL,</b>
&nbsp;                                !drawLabels);
<b class="nc">&nbsp;                        updateEntityLabels();</b>
<b class="nc">&nbsp;                        for (Sprite s: wreckSprites) {</b>
<b class="nc">&nbsp;                            s.prepare();</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        for (Sprite s: isometricWreckSprites) {</b>
<b class="nc">&nbsp;                            s.prepare();</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;        
&nbsp;        // Register the action for TOGGLE_KEYBIND_DISPLAY
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TOGGLE_KEYBIND_DISPLAY.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        toggleKeybindsOverlay();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                });
&nbsp;        
&nbsp;        // Register the action for TOGGLE_HEX_COORDS
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TOGGLE_HEX_COORDS.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        return !shouldIgnoreKeyCommands();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        boolean coordsShown = GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS);</b>
<b class="nc">&nbsp;                        GUIPreferences.getInstance().setValue(GUIPreferences.ADVANCED_SHOW_COORDS, !coordsShown);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                });
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean shouldIgnoreKeyCommands() {
<b class="nc">&nbsp;        return getChatterBoxActive() || !isVisible()</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_LOUNGE)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_END_REPORT)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_MOVEMENT_REPORT)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_TARGETING_REPORT)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_FIRING_REPORT)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_PHYSICAL_REPORT)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_OFFBOARD_REPORT)</b>
<b class="nc">&nbsp;               || (game.getPhase() == Phase.PHASE_INITIATIVE_REPORT)</b>
&nbsp;               || shouldIgnoreKeys;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected final RedrawWorker redrawWorker = new RedrawWorker();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * this should only be called once!! this will cause a timer to schedule
&nbsp;     * constant screen updates every 20 milliseconds!
&nbsp;     */
&nbsp;    protected TimerTask scheduleRedrawTimer() {
<b class="nc">&nbsp;        final TimerTask redraw = new TimerTask() {</b>
&nbsp;            @Override
&nbsp;            public void run() {
&nbsp;                try {
<b class="nc">&nbsp;                    SwingUtilities.invokeLater(redrawWorker);</b>
<b class="nc">&nbsp;                } catch (Exception ie) {</b>
<b class="nc">&nbsp;                    System.err.print(&quot;Error scheduleRedrawTimer &quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    System.err.print(ie.getMessage());</b>
<b class="nc">&nbsp;                    System.err.print(&quot;: &quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    System.err.println(&quot;ignoring&quot;);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        };
<b class="nc">&nbsp;        TimerSingleton.getInstance().schedule(redraw, 20, 20);</b>
<b class="nc">&nbsp;        return redraw;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void scheduleRedraw() {
&nbsp;        try {
<b class="nc">&nbsp;            SwingUtilities.invokeLater(redrawWorker);</b>
<b class="nc">&nbsp;        } catch (Exception ie) {</b>
<b class="nc">&nbsp;            System.err.print(&quot;Error scheduleRedraw &quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            System.err.print(ie.getMessage());</b>
<b class="nc">&nbsp;            System.err.print(&quot;: &quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            System.err.println(&quot;ignoring&quot;);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void preferenceChange(PreferenceChangeEvent e) {
<b class="nc">&nbsp;        if (e.getName().equals(IClientPreferences.MAP_TILESET)) {</b>
<b class="nc">&nbsp;            updateBoard();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (e.getName().equals(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.UNIT_LABEL_BORDER)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.TEAM_COLORING)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_DECAL)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_LEVEL)) {</b>
<b class="nc">&nbsp;            updateEntityLabels();</b>
<b class="nc">&nbsp;            for (Sprite s: wreckSprites) {</b>
<b class="nc">&nbsp;                s.prepare();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            for (Sprite s: isometricWreckSprites) {</b>
<b class="nc">&nbsp;                s.prepare();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (e.getName().equals(GUIPreferences.AOHEXSHADOWS)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FLOATINGISO)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.LEVELHIGHLIGHT)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.ADVANCED_SHOW_COORDS)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_DARKEN)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_DARKEN_ALPHA)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_GRAYSCALE)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_ALPHA)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_STRIPES)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_COLORS_HSB)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_RADII)</b>
<b class="nc">&nbsp;                || e.getName().equals(GUIPreferences.SHADOWMAP)) {</b>
<b class="nc">&nbsp;            clearHexImageCache();</b>
<b class="nc">&nbsp;            repaint();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (e.getName().equals(GUIPreferences.INCLINES)) {</b>
<b class="nc">&nbsp;            game.getBoard().initializeAllAutomaticTerrain();</b>
<b class="nc">&nbsp;            clearHexImageCache();</b>
<b class="nc">&nbsp;            repaint();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the specified board listener to receive board events from this
&nbsp;     * board.
&nbsp;     *
&nbsp;     * @param listener the board listener.
&nbsp;     */
&nbsp;    public void addBoardViewListener(BoardViewListener listener) {
<b class="nc">&nbsp;        if (!boardListeners.contains(listener)) {</b>
<b class="nc">&nbsp;            boardListeners.add(listener);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the specified board listener.
&nbsp;     *
&nbsp;     * @param listener the board listener.
&nbsp;     */
&nbsp;    public void removeBoardViewListener(BoardViewListener listener) {
<b class="nc">&nbsp;        boardListeners.remove(listener);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Notifies attached board listeners of the event.
&nbsp;     *
&nbsp;     * @param event the board event.
&nbsp;     */
&nbsp;    public void processBoardViewEvent(BoardViewEvent event) {
<b class="nc">&nbsp;        if (boardListeners == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (BoardViewListener l : boardListeners) {</b>
<b class="nc">&nbsp;            switch (event.getType()) {</b>
&nbsp;                case BoardViewEvent.BOARD_HEX_CLICKED:
&nbsp;                case BoardViewEvent.BOARD_HEX_DOUBLECLICKED:
&nbsp;                case BoardViewEvent.BOARD_HEX_DRAGGED:
&nbsp;                case BoardViewEvent.BOARD_HEX_POPUP:
<b class="nc">&nbsp;                    l.hexMoused(event);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.BOARD_HEX_CURSOR:
<b class="nc">&nbsp;                    l.hexCursor(event);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.BOARD_HEX_HIGHLIGHTED:
<b class="nc">&nbsp;                    l.boardHexHighlighted(event);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.BOARD_HEX_SELECTED:
<b class="nc">&nbsp;                    l.hexSelected(event);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.BOARD_FIRST_LOS_HEX:
<b class="nc">&nbsp;                    l.firstLOSHex(event);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.BOARD_SECOND_LOS_HEX:
<b class="nc">&nbsp;                    l.secondLOSHex(event, getFirstLOS());</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.FINISHED_MOVING_UNITS:
<b class="nc">&nbsp;                    l.finishedMovingUnits(event);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BoardViewEvent.SELECT_UNIT:
<b class="nc">&nbsp;                    l.unitSelected(event);</b>
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    void addMovingUnit(Entity entity, Vector&lt;UnitLocation&gt; movePath) {
<b class="nc">&nbsp;        if (!movePath.isEmpty()) {</b>
<b class="nc">&nbsp;            MovingUnit m = new MovingUnit(entity, movePath);</b>
<b class="nc">&nbsp;            movingUnits.add(m);</b>
&nbsp;
<b class="nc">&nbsp;            GhostEntitySprite ghostSprite = new GhostEntitySprite(this, entity);</b>
<b class="nc">&nbsp;            ghostEntitySprites.add(ghostSprite);</b>
&nbsp;
&nbsp;            // Center on the starting hex of the moving unit.
<b class="nc">&nbsp;            UnitLocation loc = movePath.get(0);</b>
<b class="nc">&nbsp;            centerOnHex(loc.getCoords());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addDisplayable(IDisplayable disp) {
<b class="nc">&nbsp;        displayables.add(disp);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeDisplayable(IDisplayable disp) {
<b class="nc">&nbsp;        displayables.remove(disp);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draw the screen!
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void paintComponent(Graphics g) {
<b class="nc">&nbsp;        GUIPreferences guip = GUIPreferences.getInstance();</b>
&nbsp;
<b class="nc">&nbsp;        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</b>
<b class="nc">&nbsp;            paintCompsStartTime = System.nanoTime();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (guip.getAntiAliasing()) {</b>
<b class="nc">&nbsp;            ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,</b>
&nbsp;                    RenderingHints.VALUE_ANTIALIAS_ON);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!isTileImagesLoaded()) {</b>
<b class="nc">&nbsp;            g.drawString(Messages.getString(&quot;BoardView1.loadingImages&quot;), 20, 50); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            if (!tileManager.isStarted()) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;boardview1: loading images for board&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                tileManager.loadNeededImages(game);</b>
&nbsp;            }
&nbsp;            // wait 1 second, then repaint
<b class="nc">&nbsp;            repaint(1000);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Rectangle viewRect = scrollpane.getVisibleRect();</b>
<b class="nc">&nbsp;        if (bvBgShouldTile &amp;&amp; (bvBgImage != null)) {</b>
<b class="nc">&nbsp;            Rectangle clipping = g.getClipBounds();</b>
<b class="nc">&nbsp;            int x = 0;</b>
<b class="nc">&nbsp;            int y = 0;</b>
<b class="nc">&nbsp;            int w = bvBgImage.getWidth();</b>
<b class="nc">&nbsp;            int h = bvBgImage.getHeight();</b>
<b class="nc">&nbsp;            while (y &lt; clipping.getHeight()) {</b>
<b class="nc">&nbsp;                int yRem = 0;</b>
<b class="nc">&nbsp;                if (y == 0) {</b>
<b class="nc">&nbsp;                    yRem = clipping.y % h;</b>
&nbsp;                }
<b class="nc">&nbsp;                x = 0;</b>
<b class="nc">&nbsp;                while (x &lt; clipping.getWidth()) {</b>
<b class="nc">&nbsp;                    int xRem = 0;</b>
<b class="nc">&nbsp;                    if (x == 0) {</b>
<b class="nc">&nbsp;                        xRem = clipping.x % w;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((xRem &gt; 0) || (yRem &gt; 0)) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            g.drawImage(</b>
<b class="nc">&nbsp;                                    bvBgImage.getSubimage(xRem, yRem, w - xRem,</b>
&nbsp;                                            h - yRem),
&nbsp;                                    clipping.x + x, clipping.y + y, this);
<b class="nc">&nbsp;                        } catch (Exception e) {</b>
&nbsp;                            // if we somehow messed up the math, log the error and simply act as if we have no background image.
<b class="nc">&nbsp;                            Rectangle rasterBounds = bvBgImage.getRaster().getBounds();</b>
&nbsp;                            
<b class="nc">&nbsp;                            String errorData = String.format(&quot;Error drawing background image. Raster Bounds: %.2f, %.2f, width:%.2f, height:%.2f, Attempted Draw Coordinates: %d, %d, width:%d, height:%d&quot;,</b>
<b class="nc">&nbsp;                                    rasterBounds.getMinX(), rasterBounds.getMinY(), rasterBounds.getWidth(), rasterBounds.getHeight(),</b>
<b class="nc">&nbsp;                                    xRem, yRem, w - xRem, h - yRem);</b>
<b class="nc">&nbsp;                            MegaMek.getLogger().error(this, errorData);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        g.drawImage(bvBgImage, clipping.x + x, clipping.y + y,</b>
&nbsp;                                this);
&nbsp;                    }
<b class="nc">&nbsp;                    x += w - xRem;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                y += h - yRem;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (bvBgImage != null) {</b>
<b class="nc">&nbsp;            g.drawImage(bvBgImage, -getX(), -getY(), (int) viewRect.getWidth(),</b>
<b class="nc">&nbsp;                    (int) viewRect.getHeight(), this);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            MetalTheme theme = new DefaultMetalTheme();</b>
<b class="nc">&nbsp;            g.setColor(theme.getControl());</b>
<b class="nc">&nbsp;            g.fillRect(-getX(), -getY(), (int) viewRect.getWidth(),</b>
<b class="nc">&nbsp;                    (int) viewRect.getHeight());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Used to pad the board edge
<b class="nc">&nbsp;        g.translate(HEX_W, HEX_H);</b>
&nbsp;
&nbsp;        // Initialize the shadow map when its not yet present
<b class="nc">&nbsp;        if (shadowMap == null) {</b>
<b class="nc">&nbsp;            updateShadowMap();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        drawHexes(g, g.getClipBounds());</b>
&nbsp;
&nbsp;        // draw wrecks
<b class="nc">&nbsp;        if (guip.getShowWrecks() &amp;&amp; !useIsometric()) {</b>
<b class="nc">&nbsp;            drawSprites(g, wreckSprites);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Field of Fire
<b class="nc">&nbsp;        if (!useIsometric()</b>
<b class="nc">&nbsp;                &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</b>
<b class="nc">&nbsp;            drawSprites(g, fieldofFireSprites);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</b>
<b class="nc">&nbsp;            drawSprites(g, moveEnvSprites);</b>
<b class="nc">&nbsp;            drawSprites(g, moveModEnvSprites);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Minefield signs all over the place!
<b class="nc">&nbsp;        drawMinefields(g);</b>
&nbsp;
&nbsp;        // Artillery targets
<b class="nc">&nbsp;        drawArtilleryHexes(g);</b>
&nbsp;
&nbsp;        // draw highlight border
<b class="nc">&nbsp;        drawSprite(g, highlightSprite);</b>
&nbsp;
&nbsp;        // draw cursors
<b class="nc">&nbsp;        drawSprite(g, cursorSprite);</b>
<b class="nc">&nbsp;        drawSprite(g, selectedSprite);</b>
<b class="nc">&nbsp;        drawSprite(g, firstLOSSprite);</b>
<b class="nc">&nbsp;        drawSprite(g, secondLOSSprite);</b>
&nbsp;
&nbsp;        // draw deployment indicators.
&nbsp;        // For Isometric rendering, this is done during drawHexes
<b class="nc">&nbsp;        if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</b>
<b class="nc">&nbsp;            drawDeployment(g);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES)</b>
&nbsp;                &amp;&amp; (showAllDeployment)) {
<b class="nc">&nbsp;            drawAllDeployment(g);</b>
&nbsp;        }
&nbsp;
&nbsp;        // draw Flare Sprites
<b class="nc">&nbsp;        drawSprites(g, flareSprites);</b>
&nbsp;
&nbsp;        // draw C3 links
<b class="nc">&nbsp;        drawSprites(g, c3Sprites);</b>
&nbsp;
&nbsp;        // draw flyover routes
<b class="nc">&nbsp;        if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            drawSprites(g, vtolAttackSprites);</b>
<b class="nc">&nbsp;            drawSprites(g, flyOverSprites);</b>
&nbsp;        }
&nbsp;
&nbsp;        // draw onscreen entities
<b class="nc">&nbsp;        drawSprites(g, entitySprites);</b>
&nbsp;
&nbsp;        // draw moving onscreen entities
<b class="nc">&nbsp;        drawSprites(g, movingEntitySprites);</b>
&nbsp;
&nbsp;        // draw ghost onscreen entities
<b class="nc">&nbsp;        drawSprites(g, ghostEntitySprites);</b>
&nbsp;
&nbsp;        // draw onscreen attacks
<b class="nc">&nbsp;        drawSprites(g, attackSprites);</b>
&nbsp;
&nbsp;        // draw movement vectors.
<b class="nc">&nbsp;        if (game.useVectorMove()</b>
<b class="nc">&nbsp;            &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</b>
<b class="nc">&nbsp;            drawSprites(g, movementSprites);</b>
&nbsp;        }
&nbsp;
&nbsp;        // draw movement, if valid
<b class="nc">&nbsp;        drawSprites(g, pathSprites);</b>
&nbsp;
&nbsp;        // draw firing solution sprites, but only during the firing phase
<b class="nc">&nbsp;        if ((game.getPhase() == Phase.PHASE_FIRING) ||</b>
<b class="nc">&nbsp;            (game.getPhase() == Phase.PHASE_OFFBOARD)) {</b>
<b class="nc">&nbsp;            drawSprites(g, firingSprites);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getPhase() == Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;            for (Coords c : strafingCoords) {</b>
<b class="nc">&nbsp;                drawHexBorder(g, getHexLocation(c), Color.yellow, 0, 3);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // draw the ruler line
<b class="nc">&nbsp;        if (rulerStart != null) {</b>
<b class="nc">&nbsp;            Point start = getCentreHexLocation(rulerStart);</b>
<b class="nc">&nbsp;            if (rulerEnd != null) {</b>
<b class="nc">&nbsp;                Point end = getCentreHexLocation(rulerEnd);</b>
<b class="nc">&nbsp;                g.setColor(Color.yellow);</b>
<b class="nc">&nbsp;                g.drawLine(start.x, start.y, end.x, end.y);</b>
&nbsp;
<b class="nc">&nbsp;                g.setColor(rulerEndColor);</b>
<b class="nc">&nbsp;                g.fillRect(end.x - 1, end.y - 1, 2, 2);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            g.setColor(rulerStartColor);</b>
<b class="nc">&nbsp;            g.fillRect(start.x - 1, start.y - 1, 2, 2);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Undo the previous translation
<b class="nc">&nbsp;        g.translate(-HEX_W, -HEX_H);</b>
&nbsp;
&nbsp;
&nbsp;        // draw all the &quot;displayables&quot;
<b class="nc">&nbsp;        if (displayablesRect == null) {</b>
<b class="nc">&nbsp;            displayablesRect = new Rectangle();</b>
&nbsp;        }
<b class="nc">&nbsp;        displayablesRect.x = -getX();</b>
<b class="nc">&nbsp;        displayablesRect.y = -getY();</b>
<b class="nc">&nbsp;        displayablesRect.width = scrollpane.getViewport().getViewRect().width;</b>
<b class="nc">&nbsp;        displayablesRect.height = scrollpane.getViewport().getViewRect().height;</b>
<b class="nc">&nbsp;        for (IDisplayable disp: displayables) {</b>
<b class="nc">&nbsp;            disp.draw(g, displayablesRect);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</b>
<b class="nc">&nbsp;            if (frameCount == FRAMES) {</b>
<b class="nc">&nbsp;                averageTime = totalTime / FRAMES;</b>
<b class="nc">&nbsp;                totalTime = 0;</b>
<b class="nc">&nbsp;                frameCount = 0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                totalTime += System.nanoTime() - paintCompsStartTime;</b>
<b class="nc">&nbsp;                frameCount++;</b>
&nbsp;            }
<b class="nc">&nbsp;            String s = String.format(&quot;%1$5.3f&quot;, averageTime / 1000000d);</b>
<b class="nc">&nbsp;            g.setFont(fpsFont);</b>
<b class="nc">&nbsp;            g.setColor(Color.YELLOW);</b>
<b class="nc">&nbsp;            g.drawString(s, -getX() + 5, -getY() + 20);</b>
&nbsp;        }
&nbsp;
&nbsp;        // debugging method that renders the bounding box of a unit&#39;s movement envelope.
&nbsp;        //renderClusters((Graphics2D) g);
&nbsp;        //renderMovementBoundingBox((Graphics2D) g);
&nbsp;        //renderDonut(g, new Coords(10, 10), 2);
&nbsp;        //renderApproxHexDirection((Graphics2D) g);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Debugging method that renders a hex in the approximate direction 
&nbsp;     * from the selected entity to the selected hex, of both exist.
&nbsp;     * @param g Graphics object on which to draw.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void renderApproxHexDirection(Graphics2D g) {
<b class="nc">&nbsp;        if(selectedEntity == null || selected == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        int direction = selectedEntity.getPosition().approximateDirection(selected, 0, 0);</b>
&nbsp;        
<b class="nc">&nbsp;        Coords donutCoords = selectedEntity.getPosition().translated(direction);</b>
&nbsp;        
<b class="nc">&nbsp;        Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</b>
<b class="nc">&nbsp;        p.translate(HEX_W  / 2, HEX_H  / 2);</b>
<b class="nc">&nbsp;        drawHexBorder(g, p, Color.BLUE, 0, 6);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Debugging method that renders the bounding hex of a unit&#39;s movement envelope.
&nbsp;     * Warning: very slow when rendering the bounding hex for really fast units.
&nbsp;     * @param g Graphics object on which to draw.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void renderMovementBoundingBox(Graphics2D g) {
<b class="nc">&nbsp;        if(selectedEntity != null) {</b>
<b class="nc">&nbsp;            Princess princess = new Princess(&quot;test&quot;, &quot;localhost&quot;, 2020, LogLevel.DEBUG);</b>
<b class="nc">&nbsp;            princess.getGame().setBoard(this.game.getBoard());</b>
<b class="nc">&nbsp;            PathEnumerator pathEnum = new PathEnumerator(princess, this.game);</b>
<b class="nc">&nbsp;            pathEnum.recalculateMovesFor(this.selectedEntity);</b>
&nbsp;
<b class="nc">&nbsp;            ConvexBoardArea cba = pathEnum.getUnitMovableAreas().get(this.selectedEntity.getId());</b>
<b class="nc">&nbsp;            for(int x = 0; x &lt; game.getBoard().getWidth(); x++) {</b>
<b class="nc">&nbsp;                for(int y = 0; y &lt; game.getBoard().getHeight(); y++) {</b>
<b class="nc">&nbsp;                    Point p = getCentreHexLocation(x, y, true);</b>
<b class="nc">&nbsp;                    p.translate(HEX_W  / 2, HEX_H  / 2);</b>
<b class="nc">&nbsp;                    Coords c = new Coords(x, y);</b>
&nbsp;
<b class="nc">&nbsp;                    if(cba.contains(c)) {</b>
&nbsp;
<b class="nc">&nbsp;                        drawHexBorder(g, p, Color.PINK, 0, 6);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for(Integer x = 0; x &lt; 6; x++) {</b>
<b class="nc">&nbsp;                Coords c = cba.getVertexNum(x);</b>
<b class="nc">&nbsp;                if(c == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Point p = getCentreHexLocation(c.getX(), c.getY(), true);</b>
<b class="nc">&nbsp;                p.translate(HEX_W / 2, HEX_H  / 2);</b>
&nbsp;
<b class="nc">&nbsp;                drawHexBorder(g, p, Color.yellow, 0, 3);</b>
<b class="nc">&nbsp;                String s = x.toString();</b>
<b class="nc">&nbsp;                this.drawCenteredText((Graphics2D) g, s, p, Color.yellow, false);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Debugging method that renders a hex donut around the given coordinates, with the given radius.
&nbsp;     * @param g Graphics object on which to draw.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void renderDonut(Graphics2D g, Coords coords, int radius) {
<b class="nc">&nbsp;        List&lt;Coords&gt; donut = coords.allAtDistance(radius);</b>
&nbsp;
<b class="nc">&nbsp;        for(Coords donutCoords : donut) {</b>
<b class="nc">&nbsp;            Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</b>
<b class="nc">&nbsp;            p.translate(HEX_W  / 2, HEX_H  / 2);</b>
<b class="nc">&nbsp;            drawHexBorder(g, p, Color.PINK, 0, 6);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Debugging method that renders a obnoxious pink lines around hexes in &quot;Board Clusters&quot;
&nbsp;     * @param g Graphics object on which to draw.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void renderClusters(Graphics2D g) {
<b class="nc">&nbsp;        BoardClusterTracker bct = new BoardClusterTracker();</b>
<b class="nc">&nbsp;        Map&lt;Coords, BoardCluster&gt; clusterMap = bct.generateClusters(selectedEntity, false, true);</b>
&nbsp;        
<b class="nc">&nbsp;        for(BoardCluster cluster : clusterMap.values().stream().distinct().collect(Collectors.toList())) {</b>
<b class="nc">&nbsp;            for (Coords coords : cluster.contents.keySet()) {</b>
<b class="nc">&nbsp;                Point p = getCentreHexLocation(coords.getX(), coords.getY(), true);</b>
<b class="nc">&nbsp;                p.translate(HEX_W  / 2, HEX_H  / 2);</b>
<b class="nc">&nbsp;                drawHexBorder(g, p, new Color(0, 0, (20 * cluster.id) % 255), 0, 6);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     *  @return a list of {@link Coords} of all hexes on the board.
&nbsp;     *          Returns ONLY hexes where board.getHex != null.
&nbsp;     */
&nbsp;    private List&lt;Coords&gt; allBoardHexes() {
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
<b class="nc">&nbsp;        if (board == null) {</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;Coords&gt; coordList = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; board.getWidth(); i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; board.getHeight(); j++) {</b>
<b class="nc">&nbsp;                if (board.getHex(i, j) != null) {</b>
<b class="nc">&nbsp;                    coordList.add(new Coords(i, j));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return coordList;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Image createBlurredShadow(Image orig) {
<b class="nc">&nbsp;        if ((orig == null) ||</b>
<b class="nc">&nbsp;                orig.getWidth(this) &lt; 0 ||</b>
<b class="nc">&nbsp;                orig.getHeight(this) &lt; 0) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        BufferedImage mask = shadowImageCache.get(orig.hashCode());</b>
<b class="nc">&nbsp;        if (mask == null) {</b>
&nbsp;            GraphicsConfiguration config = GraphicsEnvironment
<b class="nc">&nbsp;                    .getLocalGraphicsEnvironment().getDefaultScreenDevice()</b>
<b class="nc">&nbsp;                    .getDefaultConfiguration();</b>
&nbsp;
&nbsp;            // a slightly bigger image to give room for blurring
<b class="nc">&nbsp;            mask = config.createCompatibleImage(orig.getWidth(this)+4, orig.getHeight(this)+4,</b>
&nbsp;                    Transparency.TRANSLUCENT);
<b class="nc">&nbsp;            Graphics g = mask.getGraphics();</b>
<b class="nc">&nbsp;            g.drawImage(orig,2,2,null);</b>
<b class="nc">&nbsp;            g.dispose();</b>
<b class="nc">&nbsp;            mask = createShadowMask(mask);</b>
<b class="nc">&nbsp;            mask = blurOp.filter(mask, null);</b>
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().getLight() != PlanetaryConditions.L_DAY) {</b>
<b class="nc">&nbsp;                mask = blurOp.filter(mask, null);</b>
&nbsp;            }
<b class="nc">&nbsp;            shadowImageCache.put(orig.hashCode(), mask);</b>
&nbsp;        }
<b class="nc">&nbsp;        return mask;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Prepares a shadow map for the board, drawing shadows for hills/trees/buildings.
&nbsp;     *  The shadow map is an image the size of the whole board.
&nbsp;     */
&nbsp;    private void updateShadowMap() {
&nbsp;        // Issues:
&nbsp;        // Bridge shadows show a gap towards connected hexes. I don&#39;t know why.
&nbsp;        // More than one super image on a hex (building+road) doesnt work. how do I get
&nbsp;        //   the super for a hex for a specific terrain? This would also help
&nbsp;        //   with building shadowing other buildings.
&nbsp;        // AO shadows might be handled by this too. But:
&nbsp;        // this seems to need a lot of additional copying (paint shadow on a clean map for this level alone; soften up; copy to real shadow
&nbsp;        // map with clipping area active; get new clean shadow map for next shadowed level;
&nbsp;        // too much hassle currently; it works so beautifully
<b class="nc">&nbsp;        if (!GUIPreferences.getInstance().getShadowMap()) return;</b>
&nbsp;
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
<b class="nc">&nbsp;        if (board == null) return;</b>
<b class="nc">&nbsp;        if (board.inSpace()) return;</b>
<b class="nc">&nbsp;        if (boardSize == null) updateBoardSize();</b>
<b class="nc">&nbsp;        if (!isTileImagesLoaded()) return;</b>
&nbsp;        // Map editor? No shadows
<b class="nc">&nbsp;        if (game.getPhase() == IGame.Phase.PHASE_UNKNOWN) return;</b>
&nbsp;
<b class="nc">&nbsp;        long stT = System.nanoTime();</b>
&nbsp;
&nbsp;        // 1) create or get the hex shadow
<b class="nc">&nbsp;        Image hexShadow = createBlurredShadow(tileManager.getHexMask());</b>
<b class="nc">&nbsp;        if (hexShadow == null) {</b>
<b class="nc">&nbsp;            repaint(1000);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // the shadowmap needs to be painted as if scale == 1
&nbsp;        // therefore some of the methods of boardview1 cannot be used
<b class="nc">&nbsp;        int width = game.getBoard().getWidth() * HEX_WC + (int) (HEX_W / 4);</b>
<b class="nc">&nbsp;        int height = game.getBoard().getHeight() * (int) (HEX_H) + (int) (HEX_H / 2);</b>
&nbsp;
&nbsp;        GraphicsConfiguration config = GraphicsEnvironment
<b class="nc">&nbsp;                .getLocalGraphicsEnvironment().getDefaultScreenDevice()</b>
<b class="nc">&nbsp;                .getDefaultConfiguration();</b>
&nbsp;
<b class="nc">&nbsp;        shadowMap = config.createCompatibleImage(width, height,</b>
&nbsp;                Transparency.TRANSLUCENT);
&nbsp;
<b class="nc">&nbsp;        Graphics2D g = (Graphics2D)(shadowMap.createGraphics());</b>
&nbsp;
<b class="nc">&nbsp;        if ((game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_MOONLESS) ||</b>
<b class="nc">&nbsp;        (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_PITCH_BLACK)) {</b>
<b class="nc">&nbsp;            lightDirection = new double[] { 0, 0 };</b>
<b class="nc">&nbsp;        } else if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DUSK) {</b>
&nbsp;            // TODO: replace when made user controlled
<b class="nc">&nbsp;            lightDirection = new double[] { -38, 14 };</b>
&nbsp;        } else {
<b class="nc">&nbsp;            lightDirection = new double[] { -19, 7 };</b>
&nbsp;        }
&nbsp;
&nbsp;        // Shadows for elevation
&nbsp;        // 1a) Sort the board hexes by elevation
&nbsp;        // 1b) Create a reduced list of shadowcasting hexes
<b class="nc">&nbsp;        double angle = Math.atan2(-lightDirection[1], lightDirection[0]);</b>
<b class="nc">&nbsp;        int mDir = (int)(0.5+1.5-angle/Math.PI*3); // +0.5 to counter the (int)</b>
<b class="nc">&nbsp;        int[] sDirs = { mDir%6, (mDir+1)%6, (mDir+5)%6 };</b>
<b class="nc">&nbsp;        HashMap&lt;Integer,Set&lt;Coords&gt;&gt; sortedHexes = new HashMap&lt;Integer,Set&lt;Coords&gt;&gt;();</b>
<b class="nc">&nbsp;        HashMap&lt;Integer,Set&lt;Coords&gt;&gt; shadowCastingHexes = new HashMap&lt;Integer,Set&lt;Coords&gt;&gt;();</b>
<b class="nc">&nbsp;        for (Coords c: allBoardHexes()) {</b>
<b class="nc">&nbsp;            IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;            int level = hex.getLevel();</b>
<b class="nc">&nbsp;            if (!sortedHexes.containsKey(level)) { // no hexes yet for this height</b>
<b class="nc">&nbsp;                sortedHexes.put(level, new HashSet&lt;Coords&gt;());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!shadowCastingHexes.containsKey(level)) { // no hexes yet for this height</b>
<b class="nc">&nbsp;                shadowCastingHexes.put(level, new HashSet&lt;Coords&gt;());</b>
&nbsp;            }
<b class="nc">&nbsp;            sortedHexes.get(level).add(c);</b>
&nbsp;            // add a hex to the shadowcasting hexes only
&nbsp;            // if it is nor surrounded by same height hexes
<b class="nc">&nbsp;            boolean surrounded = true;</b>
<b class="nc">&nbsp;            for (int dir: sDirs) {</b>
<b class="nc">&nbsp;                if (!board.contains(c.translated(dir))) {</b>
<b class="nc">&nbsp;                    surrounded = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    IHex nhex = board.getHex(c.translated(dir));</b>
<b class="nc">&nbsp;                    int lv = nhex.getLevel();</b>
<b class="nc">&nbsp;                    if (lv &lt; level)</b>
<b class="nc">&nbsp;                        surrounded = false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!surrounded) shadowCastingHexes.get(level).add(c);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // 2) Create clipping areas
<b class="nc">&nbsp;        HashMap&lt;Integer,Shape&gt; levelClips = new HashMap&lt;Integer,Shape&gt;();</b>
<b class="nc">&nbsp;        for (Integer h: sortedHexes.keySet()) {</b>
<b class="nc">&nbsp;            Path2D path = new Path2D.Float();</b>
<b class="nc">&nbsp;            for (Coords c: sortedHexes.get(h)) {</b>
<b class="nc">&nbsp;                Point p = getHexLocationLargeTile(c.getX(), c.getY(), 1);</b>
<b class="nc">&nbsp;                AffineTransform t = AffineTransform.getTranslateInstance(p.x+HEX_W/2, p.y+HEX_H/2);</b>
<b class="nc">&nbsp;                t.scale(1.02, 1.02);</b>
<b class="nc">&nbsp;                t.translate(-HEX_W/2, -HEX_H/2);</b>
<b class="nc">&nbsp;                path.append(t.createTransformedShape(hexPoly), false);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            levelClips.put(h, path);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;
&nbsp;        // 3) Find all level differences
<b class="nc">&nbsp;        final int maxDiff = 35; // limit all diffs to this value</b>
<b class="nc">&nbsp;        Set&lt;Integer&gt; lDiffs = new TreeSet&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        for (int shadowed = board.getMinElevation();</b>
<b class="nc">&nbsp;                shadowed &lt; board.getMaxElevation();</b>
<b class="nc">&nbsp;                shadowed++) {</b>
<b class="nc">&nbsp;            if (levelClips.get(shadowed) == null) continue;</b>
&nbsp;
<b class="nc">&nbsp;            for (int shadowcaster = shadowed+1;</b>
<b class="nc">&nbsp;                    shadowcaster &lt;= board.getMaxElevation();</b>
<b class="nc">&nbsp;                    shadowcaster++) {</b>
<b class="nc">&nbsp;                if (levelClips.get(shadowcaster) == null) continue;</b>
&nbsp;
<b class="nc">&nbsp;                lDiffs.add(Math.min(shadowcaster-shadowed, maxDiff));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // 4) Elevation Shadow images for all level differences present
<b class="nc">&nbsp;        int n = 10;</b>
<b class="nc">&nbsp;        double deltaX = lightDirection[0]/n;</b>
<b class="nc">&nbsp;        double deltaY = lightDirection[1]/n;</b>
<b class="nc">&nbsp;        Map&lt;Integer,BufferedImage&gt; hS = new HashMap&lt;Integer,BufferedImage&gt;();</b>
<b class="nc">&nbsp;        for (int lDiff: lDiffs) {</b>
<b class="nc">&nbsp;            Dimension eSize = new Dimension(</b>
<b class="nc">&nbsp;                    (int)(Math.abs(lightDirection[0])*lDiff+HEX_W)*2,</b>
<b class="nc">&nbsp;                    (int)(Math.abs(lightDirection[1])*lDiff+HEX_H)*2);</b>
&nbsp;
<b class="nc">&nbsp;            BufferedImage elevShadow = config.createCompatibleImage(eSize.width, eSize.height,</b>
&nbsp;                    Transparency.TRANSLUCENT);
<b class="nc">&nbsp;            Graphics gS = elevShadow.getGraphics();</b>
<b class="nc">&nbsp;            Point2D p1 = new Point2D.Double(eSize.width/2, eSize.height/2);</b>
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getHexInclines()) {</b>
&nbsp;                // With inclines, the level 1 shadows are only very slight
<b class="nc">&nbsp;                int beg = 4;</b>
<b class="nc">&nbsp;                p1.setLocation(p1.getX()+deltaX*beg, p1.getY()+deltaY*beg);</b>
<b class="nc">&nbsp;                for (int i = beg; i&lt;n*(lDiff-0.4); i++) {</b>
<b class="nc">&nbsp;                    gS.drawImage(hexShadow, (int)p1.getX(), (int)p1.getY(), null);</b>
<b class="nc">&nbsp;                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</b>
&nbsp;                }   
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                for (int i = 0; i&lt;n*lDiff; i++) {</b>
<b class="nc">&nbsp;                    gS.drawImage(hexShadow, (int)p1.getX(), (int)p1.getY(), null);</b>
<b class="nc">&nbsp;                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</b>
&nbsp;                }
&nbsp;                
&nbsp;            }
<b class="nc">&nbsp;            gS.dispose();</b>
<b class="nc">&nbsp;            hS.put(lDiff, elevShadow);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // 5) Actually draw the elevation shadows
<b class="nc">&nbsp;        for (int shadowed = board.getMinElevation();</b>
<b class="nc">&nbsp;                shadowed &lt; board.getMaxElevation();</b>
<b class="nc">&nbsp;                shadowed++) {</b>
<b class="nc">&nbsp;            if (levelClips.get(shadowed) == null) continue;</b>
&nbsp;
<b class="nc">&nbsp;            Shape saveClip = g.getClip();</b>
<b class="nc">&nbsp;            g.setClip(levelClips.get(shadowed));</b>
&nbsp;
<b class="nc">&nbsp;            for (int shadowcaster = shadowed+1;</b>
<b class="nc">&nbsp;                    shadowcaster &lt;= board.getMaxElevation();</b>
<b class="nc">&nbsp;                    shadowcaster++) {</b>
<b class="nc">&nbsp;                if (levelClips.get(shadowcaster) == null) continue;</b>
<b class="nc">&nbsp;                int lDiff = shadowcaster - shadowed;</b>
&nbsp;
<b class="nc">&nbsp;                for (Coords c: shadowCastingHexes.get(shadowcaster)) {</b>
<b class="nc">&nbsp;                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</b>
<b class="nc">&nbsp;                    g.drawImage(hS.get(Math.min(lDiff, maxDiff)),</b>
<b class="nc">&nbsp;                            (int)p0.getX()-(int)(Math.abs(lightDirection[0])*Math.min(lDiff, maxDiff)+HEX_W),</b>
<b class="nc">&nbsp;                            (int)p0.getY()-(int)(Math.abs(lightDirection[1])*Math.min(lDiff, maxDiff)+HEX_H), null);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            g.setClip(saveClip);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        n = 5;</b>
<b class="nc">&nbsp;        deltaX = lightDirection[0]/n;</b>
<b class="nc">&nbsp;        deltaY = lightDirection[1]/n;</b>
&nbsp;
&nbsp;        // 4) woods and bulding shadows
<b class="nc">&nbsp;        for (int shadowed = board.getMinElevation();</b>
<b class="nc">&nbsp;                shadowed &lt;= board.getMaxElevation();</b>
<b class="nc">&nbsp;                shadowed++) {</b>
<b class="nc">&nbsp;            if (levelClips.get(shadowed) == null) continue;</b>
&nbsp;
<b class="nc">&nbsp;            Shape saveClip = g.getClip();</b>
<b class="nc">&nbsp;            g.setClip(levelClips.get(shadowed));</b>
&nbsp;
<b class="nc">&nbsp;            for (int shadowcaster = board.getMinElevation();</b>
<b class="nc">&nbsp;                    shadowcaster &lt;= board.getMaxElevation();</b>
<b class="nc">&nbsp;                    shadowcaster++) {</b>
<b class="nc">&nbsp;                if (levelClips.get(shadowcaster) == null) continue;</b>
&nbsp;
<b class="nc">&nbsp;                for (Coords c: sortedHexes.get(shadowcaster)) {</b>
<b class="nc">&nbsp;                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</b>
<b class="nc">&nbsp;                    Point2D p1 = new Point2D.Double();</b>
&nbsp;
&nbsp;                    // Woods Shadow
<b class="nc">&nbsp;                    IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;                    List&lt;Image&gt; supers = tileManager.supersFor(hex);</b>
&nbsp;
<b class="nc">&nbsp;                    if (!supers.isEmpty()) {</b>
<b class="nc">&nbsp;                        Image lastSuper = createBlurredShadow(supers.get(supers.size()-1));</b>
<b class="nc">&nbsp;                        if (lastSuper == null) {</b>
<b class="nc">&nbsp;                            clearShadowMap();</b>
<b class="nc">&nbsp;                            return;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (hex.containsTerrain(Terrains.WOODS) ||</b>
<b class="nc">&nbsp;                                hex.containsTerrain(Terrains.JUNGLE)) {</b>
&nbsp;                            // Woods are 2 levels high, but then shadows
&nbsp;                            // appear very extreme, therefore only
&nbsp;                            // 1.5 levels: (shadowcaster+1.5-shadowed)
<b class="nc">&nbsp;                            double shadowHeight = .75 * hex.terrainLevel(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                            p1.setLocation(p0);</b>
<b class="nc">&nbsp;                            if ((shadowcaster + shadowHeight - shadowed) &gt; 0) {</b>
<b class="nc">&nbsp;                                for (int i = 0; i &lt; n * (shadowcaster + shadowHeight - shadowed); i++) {</b>
<b class="nc">&nbsp;                                    g.drawImage(lastSuper, (int)p1.getX(), (int)p1.getY(), null);</b>
<b class="nc">&nbsp;                                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;
&nbsp;                        // Buildings Shadow
<b class="nc">&nbsp;                        if (hex.containsTerrain(Terrains.BUILDING))</b>
&nbsp;                        {
<b class="nc">&nbsp;                            int h = hex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;                            if ((shadowcaster+h-shadowed) &gt; 0) {</b>
<b class="nc">&nbsp;                                p1.setLocation(p0);</b>
<b class="nc">&nbsp;                                for (int i = 0; i&lt;n*(shadowcaster+h-shadowed); i++) {</b>
<b class="nc">&nbsp;                                    g.drawImage(lastSuper, (int)p1.getX(), (int)p1.getY(), null);</b>
<b class="nc">&nbsp;                                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                    // Bridge Shadow
<b class="nc">&nbsp;                    if (hex.containsTerrain(Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                        supers = tileManager.orthoFor(hex);</b>
<b class="nc">&nbsp;                        if (supers.isEmpty()) break;</b>
<b class="nc">&nbsp;                        Image maskB = createBlurredShadow(supers.get(supers.size()-1));</b>
<b class="nc">&nbsp;                        if (maskB == null) {</b>
<b class="nc">&nbsp;                            clearShadowMap();</b>
<b class="nc">&nbsp;                            return;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        int h = hex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;                        p1.setLocation(p0.getX()+deltaX*n*(shadowcaster+h-shadowed),</b>
<b class="nc">&nbsp;                                p0.getY()+deltaY*n*(shadowcaster+h-shadowed));</b>
&nbsp;                        // the shadowmask is translucent, therefore draw n times
&nbsp;                        // stupid hack
<b class="nc">&nbsp;                        for (int i=0;i&lt;n;i++)</b>
<b class="nc">&nbsp;                            g.drawImage(maskB, (int)p1.getX(), (int)p1.getY(), null);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            g.setClip(saveClip);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long tT5 = System.nanoTime()-stT;</b>
<b class="nc">&nbsp;        System.out.println(&quot;Time to prepare the shadow map: &quot;+tT5/1e6+&quot; ms&quot;);</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearShadowMap() {
<b class="nc">&nbsp;        shadowMap = null;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the boardSize variable with the proper values for this board.
&nbsp;     */
&nbsp;    private void updateBoardSize() {
<b class="nc">&nbsp;        int width = (game.getBoard().getWidth() * (int) (HEX_WC * scale))</b>
&nbsp;                    + (int) ((HEX_W / 4) * scale);
<b class="nc">&nbsp;        int height = (game.getBoard().getHeight() * (int) (HEX_H * scale))</b>
&nbsp;                     + (int) ((HEX_H / 2) * scale);
<b class="nc">&nbsp;        boardSize = new Dimension(width, height);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Looks through a vector of buffered images and draws them if they&#39;re
&nbsp;     * onscreen.
&nbsp;     */
&nbsp;    private synchronized void drawSprites(Graphics g,
&nbsp;            Collection&lt;? extends Sprite&gt; spriteArrayList) {
<b class="nc">&nbsp;        for (Sprite sprite : spriteArrayList) {</b>
<b class="nc">&nbsp;            drawSprite(g, sprite);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private synchronized void drawHexSpritesForHex(Coords c, Graphics g,
&nbsp;            ArrayList&lt;? extends HexSprite&gt; spriteArrayList) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
&nbsp;
<b class="nc">&nbsp;        for (HexSprite sprite : spriteArrayList) {</b>
<b class="nc">&nbsp;            Coords cp = sprite.getPosition();</b>
&nbsp;            // This can potentially be an expensive operation
<b class="nc">&nbsp;            Rectangle spriteBounds = sprite.getBounds();</b>
<b class="nc">&nbsp;            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds)</b>
<b class="nc">&nbsp;                    &amp;&amp; !sprite.isHidden()) {</b>
<b class="nc">&nbsp;                if (!sprite.isReady()) {</b>
<b class="nc">&nbsp;                    sprite.prepare();</b>
&nbsp;                }
<b class="nc">&nbsp;                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</b>
&nbsp;                        this, false);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the Entity for the given hex. This function is used by the
&nbsp;     * isometric rendering process so that sprites are drawn in the order that
&nbsp;     * hills are rendered to create the appearance that the sprite is behind the
&nbsp;     * hill.
&nbsp;     *
&nbsp;     * @param c               The Coordinates of the hex that the sprites should be drawn
&nbsp;     *                        for.
&nbsp;     * @param g               The Graphics object for this board.
&nbsp;     * @param spriteArrayList The complete list of all IsometricSprite on the board.
&nbsp;     */
&nbsp;    private synchronized void drawIsometricSpritesForHex(Coords c, Graphics g,
&nbsp;            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
<b class="nc">&nbsp;        for (IsometricSprite sprite : spriteArrayList) {</b>
<b class="nc">&nbsp;            Coords cp = sprite.getPosition();</b>
&nbsp;            // This can potentially be an expensive operation
<b class="nc">&nbsp;            Rectangle spriteBounds = sprite.getBounds();</b>
<b class="nc">&nbsp;            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds)</b>
<b class="nc">&nbsp;                &amp;&amp; !sprite.isHidden()) {</b>
<b class="nc">&nbsp;                if (!sprite.isReady()) {</b>
<b class="nc">&nbsp;                    sprite.prepare();</b>
&nbsp;                }
<b class="nc">&nbsp;                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this, false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the wrecksprites for the given hex. This function is used by the
&nbsp;     * isometric rendering process so that sprites are drawn in the order that
&nbsp;     * hills are rendered to create the appearance that the sprite is behind the
&nbsp;     * hill.
&nbsp;     *
&nbsp;     * @param c               The Coordinates of the hex that the sprites should be drawn
&nbsp;     *                        for.
&nbsp;     * @param g               The Graphics object for this board.
&nbsp;     * @param spriteArrayList The complete list of all IsometricSprite on the board.
&nbsp;     */
&nbsp;    private synchronized void drawIsometricWreckSpritesForHex(Coords c,
&nbsp;            Graphics g, ArrayList&lt;IsometricWreckSprite&gt; spriteArrayList) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
<b class="nc">&nbsp;        for (IsometricWreckSprite sprite : spriteArrayList) {</b>
<b class="nc">&nbsp;            Coords cp = sprite.getPosition();</b>
<b class="nc">&nbsp;            if (cp.equals(c) &amp;&amp; view.intersects(sprite.getBounds())</b>
<b class="nc">&nbsp;                &amp;&amp; !sprite.isHidden()) {</b>
<b class="nc">&nbsp;                if (!sprite.isReady()) {</b>
<b class="nc">&nbsp;                    sprite.prepare();</b>
&nbsp;                }
<b class="nc">&nbsp;                sprite.drawOnto(g, sprite.getBounds().x, sprite.getBounds().y,</b>
&nbsp;                                this, false);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a translucent sprite without any of the companion graphics, if it
&nbsp;     * is in the current view. This is used only when performing isometric
&nbsp;     * rending. This function is used to show units (with 50% transparency) that
&nbsp;     * are hidden behind a hill.
&nbsp;     * &lt;p/&gt;
&nbsp;     * TODO: Optimize this function so that it is only applied to sprites that
&nbsp;     * are actually hidden. This implementation performs the second rendering
&nbsp;     * for all sprites.
&nbsp;     */
&nbsp;    private final void drawIsometricSprites(Graphics g,
&nbsp;            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
<b class="nc">&nbsp;        for (IsometricSprite sprite : spriteArrayList) {</b>
&nbsp;            // This can potentially be an expensive operation
<b class="nc">&nbsp;            Rectangle spriteBounds = sprite.getBounds();</b>
<b class="nc">&nbsp;            if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</b>
<b class="nc">&nbsp;                if (!sprite.isReady()) {</b>
<b class="nc">&nbsp;                    sprite.prepare();</b>
&nbsp;                }
<b class="nc">&nbsp;                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</b>
&nbsp;                                this, true);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a sprite, if it is in the current view
&nbsp;     */
&nbsp;    private final void drawSprite(Graphics g, Sprite sprite) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
&nbsp;        // This can potentially be an expensive operation
<b class="nc">&nbsp;        Rectangle spriteBounds = sprite.getBounds();</b>
<b class="nc">&nbsp;        if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</b>
<b class="nc">&nbsp;            if (!sprite.isReady()) {</b>
<b class="nc">&nbsp;                sprite.prepare();</b>
&nbsp;            }
<b class="nc">&nbsp;            sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draw an outline around legal deployment hexes
&nbsp;     */
&nbsp;    private void drawDeployment(Graphics g) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
&nbsp;        // only update visible hexes
<b class="nc">&nbsp;        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</b>
<b class="nc">&nbsp;        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</b>
&nbsp;
<b class="nc">&nbsp;        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</b>
<b class="nc">&nbsp;        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</b>
&nbsp;
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
&nbsp;        // loop through the hexes
<b class="nc">&nbsp;        for (int i = 0; i &lt; drawHeight; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; drawWidth; j++) {</b>
<b class="nc">&nbsp;                Coords c = new Coords(j + drawX, i + drawY);</b>
<b class="nc">&nbsp;                if (board.isLegalDeployment(c, en_Deployer.getStartingPos())) {</b>
<b class="nc">&nbsp;                    drawHexBorder(g, getHexLocation(c), Color.yellow);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draw indicators for the deployment zones of all players
&nbsp;     */
&nbsp;    private void drawAllDeployment(Graphics g) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
&nbsp;        // only update visible hexes
<b class="nc">&nbsp;        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</b>
<b class="nc">&nbsp;        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</b>
&nbsp;
<b class="nc">&nbsp;        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</b>
<b class="nc">&nbsp;        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</b>
&nbsp;
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
&nbsp;        // loop through the hexes
<b class="nc">&nbsp;        for (int i = 0; i &lt; drawHeight; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; drawWidth; j++) {</b>
<b class="nc">&nbsp;                Coords c = new Coords(j + drawX, i + drawY);</b>
<b class="nc">&nbsp;                Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</b>
&nbsp;                IPlayer cp;
<b class="nc">&nbsp;                int pCount = 0;</b>
<b class="nc">&nbsp;                int bThickness = 1 + 10 / game.getNoOfPlayers();</b>
&nbsp;                // loop through all players
<b class="nc">&nbsp;                while (allP.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    cp = allP.nextElement();</b>
<b class="nc">&nbsp;                    if (board.isLegalDeployment(c, cp.getStartingPos())) {</b>
<b class="nc">&nbsp;                        Color bC = cp.getColour().getColour();</b>
<b class="nc">&nbsp;                        drawHexBorder(g, getHexLocation(c), bC, (bThickness+2)</b>
&nbsp;                                * pCount, bThickness);
<b class="nc">&nbsp;                        pCount++;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Darkens a hexes in the viewing area if there is no line of sight between
&nbsp;     * them and the supplied source hex. Used in non-isometric view.
&nbsp;     *
&nbsp;     * @param p
&nbsp;     *            The source hex for which line of sight originates
&nbsp;     * @param g
&nbsp;     *            The graphics object to draw on.
&nbsp;     * @param col
&nbsp;     *            The what color to use.
&nbsp;     * @param outOfFOV
&nbsp;     *            The destination hex for computing the line of sight
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Draw a layer of a solid color (alpha possible) on the hex at Point p no
&nbsp;     * padding by default
&nbsp;     */
&nbsp;    void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV) {
<b class="nc">&nbsp;        drawHexLayer(p, g, col, outOfFOV, 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draw a layer of a solid color (alpha possible) on the hex at Point p with
&nbsp;     * some padding around the border
&nbsp;     */
&nbsp;    private void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV,
&nbsp;            double pad) {
<b class="nc">&nbsp;        Graphics2D g2D = (Graphics2D)g;</b>
<b class="nc">&nbsp;        g.setColor(col);</b>
&nbsp;
&nbsp;        // create stripe effect for FOV darkening but not for colored weapon
&nbsp;        // ranges
<b class="nc">&nbsp;        int fogStripes = GUIPreferences.getInstance().getFovStripes();</b>
<b class="nc">&nbsp;        if (outOfFOV &amp;&amp; (fogStripes &gt; 0) &amp;&amp; (g instanceof Graphics2D)) {</b>
<b class="nc">&nbsp;            float lineSpacing = fogStripes;</b>
&nbsp;            // totally transparent here hurts the eyes
<b class="nc">&nbsp;            Color c2 = new Color(col.getRed() / 2, col.getGreen() / 2,</b>
<b class="nc">&nbsp;                    col.getBlue() / 2, col.getAlpha() / 2);</b>
&nbsp;
&nbsp;            // the numbers make the lines align across hexes
<b class="nc">&nbsp;            GradientPaint gp = new GradientPaint(42.0f / lineSpacing, 0.0f,</b>
&nbsp;                    col, 104.0f / lineSpacing, 106.0f / lineSpacing, c2, true);
<b class="nc">&nbsp;            g2D.setPaint(gp);</b>
&nbsp;        }
<b class="nc">&nbsp;        Composite svComposite = g2D.getComposite();</b>
<b class="nc">&nbsp;        g2D.setComposite(AlphaComposite.SrcAtop);</b>
<b class="nc">&nbsp;        g2D.fillRect(0, 0, hex_size.width, hex_size.height);</b>
<b class="nc">&nbsp;        g2D.setComposite(svComposite);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void drawHexBorder(Graphics g, Color col, double pad,
&nbsp;            double linewidth) {
<b class="nc">&nbsp;        drawHexBorder(g, new Point(0,0), col, pad, linewidth);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawHexBorder(Graphics g, Point p, Color col, double pad,
&nbsp;            double linewidth) {
<b class="nc">&nbsp;        g.setColor(col);</b>
<b class="nc">&nbsp;        ((Graphics2D)g).fill(</b>
<b class="nc">&nbsp;                AffineTransform.getTranslateInstance(p.x, p.y).createTransformedShape(</b>
<b class="nc">&nbsp;                AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</b>
<b class="nc">&nbsp;                HexDrawUtilities.getHexFullBorderArea(linewidth, pad))));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draw an outline around the hex at Point p no padding and a width of 1
&nbsp;     */
&nbsp;    private void drawHexBorder(Graphics g, Point p, Color col) {
<b class="nc">&nbsp;        drawHexBorder(g, p, col, 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draw an outline around the hex at Point p padded around the border by pad
&nbsp;     * and a line-width of 1
&nbsp;     */
&nbsp;    private void drawHexBorder(Graphics g, Point p, Color col, double pad) {
<b class="nc">&nbsp;        drawHexBorder(g, p, col, pad, 1);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * returns the weapon selected in the mech display, or null if none selected
&nbsp;     * or it is not artillery or null if the selected entity is not owned
&nbsp;     */
&nbsp;    public Mounted getSelectedArtilleryWeapon() {
&nbsp;        // We don&#39;t want to display artillery auto-hit/adjusted fire hexes
&nbsp;        // during
&nbsp;        // the artyautohithexes phase. These could be displayed if the player
&nbsp;        // uses the /reset command in some situations
<b class="nc">&nbsp;        if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((selectedEntity == null) || (selectedWeapon == null)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!selectedEntity.getOwner().equals(localPlayer)) {</b>
<b class="nc">&nbsp;            return null; // Not my business to see this</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (selectedEntity.getEquipmentNum(selectedWeapon) == -1) {</b>
<b class="nc">&nbsp;            return null; // inconsistent state - weapon not on entity</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!((selectedWeapon.getType() instanceof WeaponType) &amp;&amp; selectedWeapon</b>
<b class="nc">&nbsp;                .getType().hasFlag(WeaponType.F_ARTILLERY))) {</b>
<b class="nc">&nbsp;            return null; // not artillery</b>
&nbsp;        }
&nbsp;
&nbsp;        // otherwise, a weapon is selected, and it is artillery
<b class="nc">&nbsp;        return selectedWeapon;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Display artillery modifier in pretargeted hexes
&nbsp;     */
&nbsp;    private void drawArtilleryHexes(Graphics g) {
<b class="nc">&nbsp;        Mounted weapon = getSelectedArtilleryWeapon();</b>
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
&nbsp;
&nbsp;        // Compute the origin of the viewing area
<b class="nc">&nbsp;        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</b>
<b class="nc">&nbsp;        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</b>
&nbsp;
&nbsp;        // Compute size of viewing area
<b class="nc">&nbsp;        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</b>
<b class="nc">&nbsp;        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</b>
&nbsp;
&nbsp;        Image artyIconImage;
&nbsp;
&nbsp;        // Draw incoming artillery sprites - requires server to update client&#39;s
&nbsp;        // view of game
<b class="nc">&nbsp;        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game</b>
<b class="nc">&nbsp;                .getArtilleryAttacks(); attacks.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            ArtilleryAttackAction a = attacks.nextElement();</b>
<b class="nc">&nbsp;            Coords c = a.getTarget(game).getPosition();</b>
&nbsp;            // Is the Coord within the viewing area?
<b class="nc">&nbsp;            if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</b>
<b class="nc">&nbsp;                &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</b>
&nbsp;
<b class="nc">&nbsp;                Point p = getHexLocation(c);</b>
<b class="nc">&nbsp;                artyIconImage = tileManager</b>
<b class="nc">&nbsp;                        .getArtilleryTarget(TilesetManager.ARTILLERY_INCOMING);</b>
<b class="nc">&nbsp;                g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Draw pre-designated auto-hit hexes
<b class="nc">&nbsp;        if (localPlayer != null) // Could be null, like in map-editor</b>
&nbsp;        {
<b class="nc">&nbsp;            for (Coords c : localPlayer.getArtyAutoHitHexes()) {</b>
&nbsp;                // Is the Coord within the viewing area?
<b class="nc">&nbsp;                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</b>
<b class="nc">&nbsp;                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</b>
&nbsp;
<b class="nc">&nbsp;                    Point p = getHexLocation(c);</b>
<b class="nc">&nbsp;                    artyIconImage = tileManager</b>
<b class="nc">&nbsp;                            .getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</b>
<b class="nc">&nbsp;                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Draw modifiers for selected entity and weapon
<b class="nc">&nbsp;        if (weapon != null) {</b>
&nbsp;            // Loop through all of the attack modifiers for this weapon
<b class="nc">&nbsp;            for (ArtilleryTracker.ArtilleryModifier attackMod : selectedEntity.aTracker</b>
<b class="nc">&nbsp;                    .getWeaponModifiers(weapon)) {</b>
<b class="nc">&nbsp;                Coords c = attackMod.getCoords();</b>
&nbsp;                // Is the Coord within the viewing area?
<b class="nc">&nbsp;                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</b>
<b class="nc">&nbsp;                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</b>
&nbsp;
<b class="nc">&nbsp;                    Point p = getHexLocation(c);</b>
&nbsp;                    // draw the crosshairs
<b class="nc">&nbsp;                    if (attackMod.getModifier() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
&nbsp;                        // predesignated or already hit
<b class="nc">&nbsp;                        artyIconImage = tileManager</b>
<b class="nc">&nbsp;                                .getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        artyIconImage = tileManager</b>
<b class="nc">&nbsp;                                .getArtilleryTarget(TilesetManager.ARTILLERY_ADJUSTED);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * NOTENOTENOTE: (itmo) wouldnt this be simpler with two arrays. One with
&nbsp;     * the strings {&quot;BoardView1.thunderblaablaa&quot;,&quot;BoardView1.Conventi..&quot;} one
&nbsp;     * with the offsets {51,51,42} etc Preferably indexed by an enum: enum{
&nbsp;     * Conventional, Thunder; } or something?
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Writes &quot;MINEFIELD&quot; in minefield hexes...
&nbsp;     */
&nbsp;    private void drawMinefields(Graphics g) {
<b class="nc">&nbsp;        Rectangle view = g.getClipBounds();</b>
&nbsp;        // only update visible hexes
<b class="nc">&nbsp;        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</b>
<b class="nc">&nbsp;        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</b>
&nbsp;
<b class="nc">&nbsp;        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</b>
<b class="nc">&nbsp;        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</b>
&nbsp;
<b class="nc">&nbsp;        int maxX = drawX + drawWidth;</b>
<b class="nc">&nbsp;        int maxY = drawY + drawHeight;</b>
&nbsp;
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
<b class="nc">&nbsp;        for (Enumeration&lt;Coords&gt; minedCoords = game.getMinedCoords();</b>
<b class="nc">&nbsp;             minedCoords.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            Coords c = minedCoords.nextElement();</b>
&nbsp;            // If the coords aren&#39;t visible, skip
<b class="nc">&nbsp;            if ((c.getX() &lt; drawX) || (c.getX() &gt; maxX) || (c.getY() &lt; drawY) || (c.getY() &gt; maxY)</b>
<b class="nc">&nbsp;                || !board.contains(c)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Point p = getHexLocation(c);</b>
<b class="nc">&nbsp;            Image mineImg = getScaledImage(tileManager.getMinefieldSign(), true);</b>
<b class="nc">&nbsp;            g.drawImage(mineImg, p.x + (int) (13 * scale), p.y</b>
&nbsp;                                                           + (int) (13 * scale), this);
&nbsp;
<b class="nc">&nbsp;            g.setColor(Color.black);</b>
<b class="nc">&nbsp;            int nbrMfs = game.getNbrMinefields(c);</b>
<b class="nc">&nbsp;            if (nbrMfs &gt; 1) {</b>
<b class="nc">&nbsp;                drawCenteredString(</b>
<b class="nc">&nbsp;                        Messages.getString(&quot;BoardView1.Multiple&quot;), //$NON-NLS-1$</b>
&nbsp;                        p.x, p.y + (int) (51 * scale), font_minefield, g);
<b class="nc">&nbsp;            } else if (nbrMfs == 1) {</b>
<b class="nc">&nbsp;                Minefield mf = game.getMinefields(c).get(0);</b>
&nbsp;
<b class="nc">&nbsp;                switch (mf.getType()) {</b>
&nbsp;                    case (Minefield.TYPE_CONVENTIONAL):
<b class="nc">&nbsp;                        drawCenteredString(</b>
<b class="nc">&nbsp;                                Messages.getString(&quot;BoardView1.Conventional&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</b>
&nbsp;                                p.x, p.y + (int) (51 * scale),
&nbsp;                                font_minefield, g);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case (Minefield.TYPE_INFERNO):
<b class="nc">&nbsp;                        drawCenteredString(</b>
<b class="nc">&nbsp;                                Messages.getString(&quot;BoardView1.Inferno&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</b>
&nbsp;                                p.x, p.y + (int) (51 * scale),
&nbsp;                                font_minefield, g);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case (Minefield.TYPE_ACTIVE):
<b class="nc">&nbsp;                        drawCenteredString(</b>
<b class="nc">&nbsp;                                Messages.getString(&quot;BoardView1.Active&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                + mf.getDensity() + &quot;)&quot;,  //$NON-NLS-2$</b>
&nbsp;                                p.x, p.y + (int) (51 * scale),
&nbsp;                                font_minefield, g);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case (Minefield.TYPE_COMMAND_DETONATED):
<b class="nc">&nbsp;                        drawCenteredString(</b>
<b class="nc">&nbsp;                                Messages.getString(&quot;BoardView1.Command-&quot;), //$NON-NLS-1$</b>
&nbsp;                                p.x, p.y + (int) (51 * scale),
&nbsp;                                font_minefield, g);
<b class="nc">&nbsp;                        drawCenteredString(</b>
<b class="nc">&nbsp;                                Messages.getString(&quot;BoardView1.detonated&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                                   + mf.getDensity() + &quot;)&quot;), //$NON-NLS-1$</b>
&nbsp;                                p.x, p.y + (int) (60 * scale),
&nbsp;                                font_minefield, g);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case (Minefield.TYPE_VIBRABOMB):
<b class="nc">&nbsp;                        drawCenteredString(</b>
<b class="nc">&nbsp;                                Messages.getString(&quot;BoardView1.Vibrabomb&quot;), //$NON-NLS-1$</b>
&nbsp;                                p.x, p.y + (int) (51 * scale),
&nbsp;                                font_minefield, g);
<b class="nc">&nbsp;                        if (mf.getPlayerId() == localPlayer.getId()) {</b>
<b class="nc">&nbsp;                            drawCenteredString(&quot;(&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                               + mf.getSetting() + &quot;)&quot;, //$NON-NLS-1$</b>
&nbsp;                                               p.x, p.y + (int) (60 * scale),
&nbsp;                                               font_minefield, g);
&nbsp;                        }
&nbsp;                        break;
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void drawCenteredString(String string, int x, int y, Font font,
&nbsp;                                    Graphics graph) {
<b class="nc">&nbsp;        FontMetrics currentMetrics = getFontMetrics(font);</b>
<b class="nc">&nbsp;        int stringWidth = currentMetrics.stringWidth(string);</b>
&nbsp;
<b class="nc">&nbsp;        x += ((hex_size.width - stringWidth) / 2);</b>
&nbsp;
<b class="nc">&nbsp;        graph.setFont(font);</b>
<b class="nc">&nbsp;        graph.drawString(string, x, y);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This method creates an image the size of the entire board (all
&nbsp;     * mapsheets), draws the hexes onto it, and returns that image.
&nbsp;     */
&nbsp;    public BufferedImage getEntireBoardImage(boolean ignoreUnits) {
&nbsp;        // Set zoom to base, so we get a consist board image
&nbsp;
<b class="nc">&nbsp;        int oldZoom = zoomIndex;</b>
<b class="nc">&nbsp;        zoomIndex = BASE_ZOOM_INDEX;</b>
<b class="nc">&nbsp;        zoom();</b>
&nbsp;
<b class="nc">&nbsp;        Image entireBoard = createImage(boardSize.width, boardSize.height);</b>
<b class="nc">&nbsp;        Graphics2D boardGraph = (Graphics2D) entireBoard.getGraphics();</b>
<b class="nc">&nbsp;        boardGraph.setClip(0, 0, boardSize.width, boardSize.height);</b>
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getAntiAliasing()) {</b>
<b class="nc">&nbsp;            boardGraph.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</b>
&nbsp;                                        RenderingHints.VALUE_ANTIALIAS_ON);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (shadowMap == null) {</b>
<b class="nc">&nbsp;            updateShadowMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Draw hexes
<b class="nc">&nbsp;        drawHexes(boardGraph, new Rectangle(boardSize), ignoreUnits);</b>
&nbsp;
&nbsp;        // If we aren&#39;t ignoring units, draw everything else
<b class="nc">&nbsp;        if (!ignoreUnits) {</b>
&nbsp;            // draw wrecks
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getShowWrecks()</b>
<b class="nc">&nbsp;                    &amp;&amp; !useIsometric()) {</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, wreckSprites);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Field of Fire
<b class="nc">&nbsp;            if (!useIsometric()</b>
<b class="nc">&nbsp;                    &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, fieldofFireSprites);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, moveEnvSprites);</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, moveModEnvSprites);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Minefield signs all over the place!
<b class="nc">&nbsp;            drawMinefields(boardGraph);</b>
&nbsp;
&nbsp;            // Artillery targets
<b class="nc">&nbsp;            drawArtilleryHexes(boardGraph);</b>
&nbsp;
&nbsp;            // draw highlight border
<b class="nc">&nbsp;            drawSprite(boardGraph, highlightSprite);</b>
&nbsp;
&nbsp;            // draw cursors
<b class="nc">&nbsp;            drawSprite(boardGraph, cursorSprite);</b>
<b class="nc">&nbsp;            drawSprite(boardGraph, selectedSprite);</b>
<b class="nc">&nbsp;            drawSprite(boardGraph, firstLOSSprite);</b>
<b class="nc">&nbsp;            drawSprite(boardGraph, secondLOSSprite);</b>
&nbsp;
&nbsp;            // draw deployment indicators.
&nbsp;            // For Isometric rendering, this is done during drawHexes
<b class="nc">&nbsp;            if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</b>
<b class="nc">&nbsp;                drawDeployment(boardGraph);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES)</b>
&nbsp;                    &amp;&amp; (showAllDeployment)) {
<b class="nc">&nbsp;                drawAllDeployment(boardGraph);</b>
&nbsp;            }
&nbsp;
&nbsp;            // draw Flare Sprites
<b class="nc">&nbsp;            drawSprites(boardGraph, flareSprites);</b>
&nbsp;
&nbsp;            // draw C3 links
<b class="nc">&nbsp;            drawSprites(boardGraph, c3Sprites);</b>
&nbsp;
&nbsp;            // draw flyover routes
<b class="nc">&nbsp;            if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, vtolAttackSprites);</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, flyOverSprites);</b>
&nbsp;            }
&nbsp;
&nbsp;            // draw onscreen entities
<b class="nc">&nbsp;            drawSprites(boardGraph, entitySprites);</b>
&nbsp;
&nbsp;            // draw moving onscreen entities
<b class="nc">&nbsp;            drawSprites(boardGraph, movingEntitySprites);</b>
&nbsp;
&nbsp;            // draw ghost onscreen entities
<b class="nc">&nbsp;            drawSprites(boardGraph, ghostEntitySprites);</b>
&nbsp;
&nbsp;            // draw onscreen attacks
<b class="nc">&nbsp;            drawSprites(boardGraph, attackSprites);</b>
&nbsp;
&nbsp;            // draw movement vectors.
<b class="nc">&nbsp;            if (game.useVectorMove()</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, movementSprites);</b>
&nbsp;            }
&nbsp;
&nbsp;            // draw movement, if valid
<b class="nc">&nbsp;            drawSprites(boardGraph, pathSprites);</b>
&nbsp;
&nbsp;            // draw firing solution sprites, but only during the firing phase
<b class="nc">&nbsp;            if ((game.getPhase() == Phase.PHASE_FIRING) ||</b>
<b class="nc">&nbsp;                (game.getPhase() == Phase.PHASE_OFFBOARD)) {</b>
<b class="nc">&nbsp;                drawSprites(boardGraph, firingSprites);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (game.getPhase() == Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;                for (Coords c : strafingCoords) {</b>
<b class="nc">&nbsp;                    drawHexBorder(boardGraph, getHexLocation(c), Color.yellow, 0, 3);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        boardGraph.dispose();</b>
&nbsp;
&nbsp;        // Restore the zoom setting
<b class="nc">&nbsp;        zoomIndex = oldZoom;</b>
<b class="nc">&nbsp;        zoom();</b>
&nbsp;
<b class="nc">&nbsp;        return (BufferedImage) entireBoard;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void drawHexes(Graphics g, Rectangle view) {
<b class="nc">&nbsp;        drawHexes(g, view, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Redraws all hexes in the specified rectangle
&nbsp;     */
&nbsp;    private void drawHexes(Graphics g, Rectangle view, boolean saveBoardImage) {
&nbsp;        // only update visible hexes
<b class="nc">&nbsp;        double xs = (int) (HEX_WC*scale);</b>
<b class="nc">&nbsp;        double ys = (int) (HEX_H*scale);</b>
&nbsp;
<b class="nc">&nbsp;        int drawX = (int) (view.x / xs) - 1;</b>
<b class="nc">&nbsp;        int drawY = (int) (view.y / ys) - 1;</b>
&nbsp;
<b class="nc">&nbsp;        int drawWidth = (int) (view.width / xs) + 3;</b>
<b class="nc">&nbsp;        int drawHeight = (int) (view.height / ys) + 3;</b>
&nbsp;
&nbsp;        // draw some hexes.
<b class="nc">&nbsp;        if (useIsometric()) {</b>
<b class="nc">&nbsp;            IBoard board = game.getBoard();</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; drawHeight; y++) {</b>
&nbsp;                // Half of each row is one-half hex
&nbsp;                // farther back (above) the other; draw those first
<b class="nc">&nbsp;                for (int s = 0; s &lt;= 1; s++) {</b>
<b class="nc">&nbsp;                    for (int x = s; x &lt; drawWidth+s+1; x=x+2) {</b>
&nbsp;                        // For s == 0 the x coordinate MUST be an even number
&nbsp;                        // to get correct occlusion; drawX may be any int though
<b class="nc">&nbsp;                        Coords c = new Coords(x + drawX/2*2, y + drawY);</b>
<b class="nc">&nbsp;                        IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;                        if ((hex != null)) {</b>
<b class="nc">&nbsp;                            drawHex(c, g, saveBoardImage);</b>
<b class="nc">&nbsp;                            if (GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                                    .getShowFieldOfFire()) {</b>
<b class="nc">&nbsp;                                drawHexSpritesForHex(c, g, fieldofFireSprites);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            drawHexSpritesForHex(c, g, moveEnvSprites);</b>
<b class="nc">&nbsp;                            drawHexSpritesForHex(c, g, moveModEnvSprites);</b>
<b class="nc">&nbsp;                            if ((en_Deployer != null)</b>
<b class="nc">&nbsp;                                    &amp;&amp; board.isLegalDeployment(c,</b>
<b class="nc">&nbsp;                                            en_Deployer.getStartingPos())) {</b>
<b class="nc">&nbsp;                                drawHexBorder(g, getHexLocation(c),</b>
&nbsp;                                        Color.yellow);
&nbsp;                            }
<b class="nc">&nbsp;                            drawOrthograph(c, g);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                for (int x = 0; x &lt; drawWidth; x++) {</b>
<b class="nc">&nbsp;                    Coords c = new Coords(x + drawX, y + drawY);</b>
<b class="nc">&nbsp;                    IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;                    if (hex != null) {</b>
<b class="nc">&nbsp;                        if (!saveBoardImage) {</b>
<b class="nc">&nbsp;                            if (GUIPreferences.getInstance().getShowWrecks()) {</b>
<b class="nc">&nbsp;                                drawIsometricWreckSpritesForHex(c, g,</b>
&nbsp;                                        isometricWreckSprites);
&nbsp;                            }
<b class="nc">&nbsp;                            drawIsometricSpritesForHex(c, g, isometricSprites);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!saveBoardImage) {</b>
&nbsp;                // If we are using Isometric rendering, redraw the entity
&nbsp;                // sprites at 50% transparent so sprites hidden behind hills can
&nbsp;                // still be seen by the user.
<b class="nc">&nbsp;                drawIsometricSprites(g, isometricSprites);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Draw hexes without regard to elevation when
&nbsp;            // not using Isometric, since it does not matter.
<b class="nc">&nbsp;            for (int i = 0; i &lt; drawHeight; i++) {</b>
<b class="nc">&nbsp;                for (int j = 0; j &lt; drawWidth; j++) {</b>
<b class="nc">&nbsp;                    Coords c = new Coords(j + drawX, i + drawY);</b>
<b class="nc">&nbsp;                    drawHex(c, g, saveBoardImage);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a hex onto the board buffer. This assumes that drawRect is current,
&nbsp;     * and does not check if the hex is visible.
&nbsp;     */
&nbsp;    private void drawHex(Coords c, Graphics boardGraph,
&nbsp;                         boolean saveBoardImage) {
<b class="nc">&nbsp;        if (!game.getBoard().contains(c)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final GUIPreferences guip = GUIPreferences.getInstance();</b>
<b class="nc">&nbsp;        final IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        final Point hexLoc = getHexLocation(c);</b>
&nbsp;
&nbsp;        // Check the cache to see if we already have the image
<b class="nc">&nbsp;        HexImageCacheEntry cacheEntry = hexImageCache.get(c);</b>
<b class="nc">&nbsp;        if ((cacheEntry != null) &amp;&amp; !cacheEntry.needsUpdating) {</b>
<b class="nc">&nbsp;            boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int level = hex.getLevel();</b>
<b class="nc">&nbsp;        int depth = hex.depth(false);</b>
&nbsp;
<b class="nc">&nbsp;        ITerrain basement = hex.getTerrain(Terrains.BLDG_BASEMENT_TYPE);</b>
<b class="nc">&nbsp;        if (basement != null) {</b>
<b class="nc">&nbsp;            depth = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int height = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),</b>
<b class="nc">&nbsp;                              hex.terrainLevel(Terrains.BRIDGE_ELEV));</b>
<b class="nc">&nbsp;        height = Math.max(height, hex.terrainLevel(Terrains.INDUSTRIAL));</b>
&nbsp;
<b class="nc">&nbsp;        Image boardBgHexImg = getBoardBackgroundHexImage(c, hex);</b>
&nbsp;        // get the base tile image
&nbsp;        Image baseImage, scaledImage;
<b class="nc">&nbsp;        if (boardBgHexImg != null) {</b>
<b class="nc">&nbsp;            baseImage = boardBgHexImg;</b>
<b class="nc">&nbsp;            scaledImage = boardBgHexImg;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            baseImage = tileManager.baseFor(hex);</b>
<b class="nc">&nbsp;            scaledImage = getScaledImage(baseImage, true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Some hex images shouldn&#39;t be cached, like if they are animated
<b class="nc">&nbsp;        boolean dontCache = animatedImages.contains(baseImage.hashCode());</b>
&nbsp;
&nbsp;        // check if this is a standard tile image 84x72 or something different
<b class="nc">&nbsp;        boolean standardTile = (baseImage.getHeight(null) == HEX_H)</b>
<b class="nc">&nbsp;                &amp;&amp; (baseImage.getWidth(null) == HEX_W);</b>
&nbsp;
&nbsp;        int imgHeight, imgWidth;
<b class="nc">&nbsp;        imgWidth = scaledImage.getWidth(null);</b>
<b class="nc">&nbsp;        imgHeight = scaledImage.getHeight(null);</b>
&nbsp;
&nbsp;        // do not make larger than hex images even when the input image is big
<b class="nc">&nbsp;        int origImgWidth = imgWidth; // save for later, needed for large tiles</b>
<b class="nc">&nbsp;        int origImgHeight = imgHeight;</b>
&nbsp;
<b class="nc">&nbsp;        imgWidth = Math.min(imgWidth,(int)(HEX_W*scale));</b>
<b class="nc">&nbsp;        imgHeight = Math.min(imgHeight,(int)(HEX_H*scale));</b>
&nbsp;
<b class="nc">&nbsp;        if (useIsometric()) {</b>
<b class="nc">&nbsp;            int largestLevelDiff = 0;</b>
<b class="nc">&nbsp;            for (int dir: allDirections) {</b>
<b class="nc">&nbsp;                IHex adjHex = game.getBoard().getHexInDir(c, dir);</b>
<b class="nc">&nbsp;                if (adjHex == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                int levelDiff = Math.abs(level - adjHex.getLevel());</b>
<b class="nc">&nbsp;                if (levelDiff &gt; largestLevelDiff) {</b>
<b class="nc">&nbsp;                    largestLevelDiff = levelDiff;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            imgHeight += HEX_ELEV * scale * largestLevelDiff;</b>
&nbsp;        }
&nbsp;        // If the base image isn&#39;t ready, we should signal a repaint and stop
<b class="nc">&nbsp;        if ((imgWidth &lt; 0) || (imgHeight &lt; 0)) {</b>
<b class="nc">&nbsp;            repaint();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        BufferedImage hexImage = new BufferedImage(imgWidth, imgHeight,</b>
&nbsp;                BufferedImage.TYPE_INT_ARGB);
&nbsp;
<b class="nc">&nbsp;        Graphics2D g = (Graphics2D)(hexImage.getGraphics());</b>
<b class="nc">&nbsp;        GUIPreferences.AntiAliasifSet(g);</b>
&nbsp;
<b class="nc">&nbsp;        if (standardTile) { // is the image hex-sized, 84*72?</b>
<b class="nc">&nbsp;            g.drawImage(scaledImage, 0, 0, this);</b>
&nbsp;        } else { // Draw image for a texture larger than a hex
<b class="nc">&nbsp;            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY());</b>
<b class="nc">&nbsp;            p1SRC.x = p1SRC.x % origImgWidth;</b>
<b class="nc">&nbsp;            p1SRC.y = p1SRC.y % origImgHeight;</b>
<b class="nc">&nbsp;            Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</b>
&nbsp;                    (int) (p1SRC.y + HEX_H * scale));
<b class="nc">&nbsp;            Point p2DST = new Point((int) (HEX_W * scale),</b>
&nbsp;                    (int) (HEX_H * scale));
&nbsp;
&nbsp;            // hex mask to limit drawing to the hex shape
&nbsp;            // TODO: this is not ideal yet but at least it draws
&nbsp;            // without leaving gaps at any zoom
<b class="nc">&nbsp;            Image hexMask = getScaledImage(tileManager.getHexMask(), true);</b>
<b class="nc">&nbsp;            g.drawImage(hexMask, 0, 0, this);</b>
<b class="nc">&nbsp;            Composite svComp = g.getComposite();</b>
<b class="nc">&nbsp;            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</b>
&nbsp;                    1f));
&nbsp;
&nbsp;            // paint the right slice from the big pic
<b class="nc">&nbsp;            g.drawImage(scaledImage, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</b>
&nbsp;                    p2SRC.x, p2SRC.y, null);
&nbsp;
&nbsp;            // Handle wrapping of the image
<b class="nc">&nbsp;            if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &lt;= origImgHeight) {</b>
<b class="nc">&nbsp;                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</b>
&nbsp;                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
&nbsp;                        null); // paint addtl slice on the left side
<b class="nc">&nbsp;            } else if (p2SRC.x &lt;= origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</b>
<b class="nc">&nbsp;                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</b>
&nbsp;                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
&nbsp;                        null); // paint addtl slice on the top
<b class="nc">&nbsp;            } else if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</b>
<b class="nc">&nbsp;                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</b>
&nbsp;                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
&nbsp;                        null); // paint addtl slice on the top
<b class="nc">&nbsp;                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</b>
&nbsp;                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
&nbsp;                        null); // paint addtl slice on the left side
&nbsp;                // paint addtl slice on the top left side
<b class="nc">&nbsp;                g.drawImage(scaledImage, origImgWidth - p1SRC.x, origImgHeight</b>
&nbsp;                        - p1SRC.y, p2DST.x, p2DST.y, 0, 0, p2SRC.x
&nbsp;                        - origImgWidth, p2SRC.y - origImgHeight, null);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            g.setComposite(svComp);</b>
&nbsp;        }
&nbsp;
&nbsp;        // To place roads under the shadow map, supers for hexes with roads
&nbsp;        // have to be drawn before the shadow map, otherwise the supers are
&nbsp;        // drawn after.  Unfortunately I dont think the supers images
&nbsp;        // themselves can be checked for roads.
<b class="nc">&nbsp;        List&lt;Image&gt; supers = tileManager.supersFor(hex);</b>
<b class="nc">&nbsp;        boolean supersUnderShadow = false;</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.ROAD) ||</b>
<b class="nc">&nbsp;                hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            supersUnderShadow = true;</b>
<b class="nc">&nbsp;            if (supers != null) {</b>
<b class="nc">&nbsp;                for (Image image : supers) {</b>
<b class="nc">&nbsp;                    if (animatedImages.contains(image.hashCode())) {</b>
<b class="nc">&nbsp;                        dontCache = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    scaledImage = getScaledImage(image, true);</b>
<b class="nc">&nbsp;                    g.drawImage(scaledImage, 0, 0, this);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Add the terrain &amp; building shadows
<b class="nc">&nbsp;        if (guip.getBoolean(GUIPreferences.SHADOWMAP) &amp;&amp;</b>
&nbsp;            (shadowMap != null)) {
<b class="nc">&nbsp;            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY(), 1);</b>
<b class="nc">&nbsp;            Point p2SRC = new Point(p1SRC.x + HEX_W, p1SRC.y + HEX_H);</b>
<b class="nc">&nbsp;            Point p2DST = new Point(hex_size.width, hex_size.height);</b>
&nbsp;
<b class="nc">&nbsp;            Composite svComp = g.getComposite();</b>
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DAY) {</b>
<b class="nc">&nbsp;                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.55f));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.45f));</b>
&nbsp;            }
&nbsp;
&nbsp;            // paint the right slice from the big pic
<b class="nc">&nbsp;            g.drawImage(shadowMap, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</b>
&nbsp;                    p2SRC.x, p2SRC.y, null);
<b class="nc">&nbsp;            g.setComposite(svComp);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!supersUnderShadow) {</b>
<b class="nc">&nbsp;            if (supers != null) {</b>
<b class="nc">&nbsp;                for (Image image : supers) {</b>
<b class="nc">&nbsp;                    if (null != image) {</b>
<b class="nc">&nbsp;                        if (animatedImages.contains(image.hashCode())) {</b>
<b class="nc">&nbsp;                            dontCache = true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        scaledImage = getScaledImage(image, true);</b>
<b class="nc">&nbsp;                        g.drawImage(scaledImage, 0, 0, this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // AO Hex Shadow in this hex when a higher one is adjacent
<b class="nc">&nbsp;        if (guip.getBoolean(GUIPreferences.AOHEXSHADOWS)</b>
&nbsp;               ) {
<b class="nc">&nbsp;            for (int dir : allDirections) {</b>
<b class="nc">&nbsp;                Shape ShadowShape = getElevationShadowArea(c, dir);</b>
<b class="nc">&nbsp;                GradientPaint gpl = getElevationShadowGP(c, dir);</b>
<b class="nc">&nbsp;                if (ShadowShape != null &amp;&amp; gpl != null) {</b>
<b class="nc">&nbsp;                    g.setPaint(gpl);</b>
<b class="nc">&nbsp;                    g.fill(getElevationShadowArea(c, dir));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Orthos (bridges)
<b class="nc">&nbsp;        List&lt;Image&gt; orthos = tileManager.orthoFor(hex);</b>
<b class="nc">&nbsp;        if (orthos != null) {</b>
<b class="nc">&nbsp;            for (Image image : orthos) {</b>
<b class="nc">&nbsp;                if (animatedImages.contains(image.hashCode())) {</b>
<b class="nc">&nbsp;                    dontCache = true;</b>
&nbsp;                }
<b class="nc">&nbsp;                scaledImage = getScaledImage(image, true);</b>
<b class="nc">&nbsp;                if (!useIsometric()) {</b>
<b class="nc">&nbsp;                    g.drawImage(scaledImage, 0, 0, this);</b>
&nbsp;                }
&nbsp;                // draw a shadow for bridge hex.
<b class="nc">&nbsp;                if (useIsometric()</b>
<b class="nc">&nbsp;                        &amp;&amp; !guip.getBoolean(GUIPreferences.SHADOWMAP)</b>
<b class="nc">&nbsp;                        &amp;&amp; (hex.terrainLevel(Terrains.BRIDGE_ELEV) &gt; 0)) {</b>
<b class="nc">&nbsp;                    Image shadow = createShadowMask(scaledImage);</b>
<b class="nc">&nbsp;                    g.drawImage(shadow, 0, 0, this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Shade and add static noise to hexes that are in an ECM field
<b class="nc">&nbsp;        if (ecmHexes != null) {</b>
<b class="nc">&nbsp;            Color tint = ecmHexes.get(c);</b>
<b class="nc">&nbsp;            if (tint != null) {</b>
<b class="nc">&nbsp;                Color origColor = g.getColor();</b>
<b class="nc">&nbsp;                g.setColor(tint);</b>
<b class="nc">&nbsp;                AffineTransform sc = new AffineTransform();</b>
<b class="nc">&nbsp;                sc.scale(scale, scale);</b>
<b class="nc">&nbsp;                g.fill(sc.createTransformedShape(hexPoly));</b>
<b class="nc">&nbsp;                g.setColor(origColor);</b>
<b class="nc">&nbsp;                Image staticImage = getScaledImage(</b>
<b class="nc">&nbsp;                        tileManager.getEcmStaticImage(tint), false);</b>
<b class="nc">&nbsp;                g.drawImage(staticImage, 0, 0, staticImage.getWidth(null),</b>
<b class="nc">&nbsp;                        staticImage.getHeight(null), this);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Shade hexes that are in an ECCM field
<b class="nc">&nbsp;        if (eccmHexes != null) {</b>
<b class="nc">&nbsp;            Color tint = eccmHexes.get(c);</b>
<b class="nc">&nbsp;            if (tint != null) {</b>
<b class="nc">&nbsp;                Color origColor = g.getColor();</b>
<b class="nc">&nbsp;                g.setColor(tint);</b>
<b class="nc">&nbsp;                AffineTransform sc = new AffineTransform();</b>
<b class="nc">&nbsp;                sc.scale(scale, scale);</b>
<b class="nc">&nbsp;                g.fill(sc.createTransformedShape(hexPoly));</b>
<b class="nc">&nbsp;                g.setColor(origColor);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Highlight hexes that contain the source of an ECM field
<b class="nc">&nbsp;        if (ecmCenters != null) {</b>
<b class="nc">&nbsp;            Color tint = ecmCenters.get(c);</b>
<b class="nc">&nbsp;            if (tint != null) {</b>
<b class="nc">&nbsp;                drawHexBorder(g, tint.darker(), 5, 10);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Highlight hexes that contain the source of an ECCM field
<b class="nc">&nbsp;        if (eccmCenters != null) {</b>
<b class="nc">&nbsp;            Color tint = eccmCenters.get(c);</b>
<b class="nc">&nbsp;            if (tint != null) {</b>
<b class="nc">&nbsp;                drawHexBorder(g, tint.darker(), 5, 10);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Darken the hex for night-time, if applicable
<b class="nc">&nbsp;        if (guip.getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</b>
<b class="nc">&nbsp;                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</b>
<b class="nc">&nbsp;                    hexImage.setRGB(x, y, getNightDarkenedColor(hexImage.getRGB(x, y)));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Set the text color according to Preferences or Light Gray in space
<b class="nc">&nbsp;        g.setColor(guip.getMapTextColor());</b>
<b class="nc">&nbsp;        if (game.getBoard().inSpace())</b>
<b class="nc">&nbsp;            g.setColor(Color.LIGHT_GRAY);</b>
&nbsp;
&nbsp;        // draw special stuff for the hex
<b class="nc">&nbsp;        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard()</b>
<b class="nc">&nbsp;                .getSpecialHexDisplay(c);</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (shdList != null) {</b>
<b class="nc">&nbsp;                for (SpecialHexDisplay shd : shdList) {</b>
<b class="nc">&nbsp;                    if (shd.drawNow(game.getPhase(), game.getRoundCount(),</b>
&nbsp;                            localPlayer)) {
<b class="nc">&nbsp;                        scaledImage = getScaledImage(shd.getType()</b>
<b class="nc">&nbsp;                                .getDefaultImage(), true);</b>
<b class="nc">&nbsp;                        g.drawImage(scaledImage, 0, 0, this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            System.err.println(&quot;Illegal argument exception, probably &quot;</b>
&nbsp;                    + &quot;can&#39;t load file.&quot;);
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;            drawCenteredString(&quot;Loading Error&quot;, 0, 0</b>
&nbsp;                    + (int) (50 * scale), font_note, g);
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // write hex coordinate unless deactivated or scale factor too small
<b class="nc">&nbsp;        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS)</b>
&nbsp;                &amp;&amp; (scale &gt;= 0.5)) {
<b class="nc">&nbsp;            drawCenteredString(c.getBoardNum(), 0, 0</b>
&nbsp;                    + (int) (12 * scale), font_hexnum, g);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getDisplayInvalidHexInfo() &amp;&amp; !hex.isValid(null)) {</b>
<b class="nc">&nbsp;            Point hexCenter = new Point((int)(HEX_W / 2 * scale), (int)(HEX_H / 2 * scale));</b>
<b class="nc">&nbsp;            drawCenteredText(g, Messages.getString(&quot;BoardEditor.INVALID&quot;), hexCenter, Color.RED, false,</b>
&nbsp;                    new Font(&quot;SansSerif&quot;, Font.BOLD, 14));
&nbsp;        }
&nbsp;
&nbsp;        // write terrain level / water depth / building height
<b class="nc">&nbsp;        if (scale &gt; 0.5f) {</b>
<b class="nc">&nbsp;            int ypos = HEX_H-2;</b>
<b class="nc">&nbsp;            if (level != 0) {</b>
<b class="nc">&nbsp;                drawCenteredString(</b>
<b class="nc">&nbsp;                        Messages.getString(&quot;BoardView1.LEVEL&quot;) + level, //$NON-NLS-1$</b>
&nbsp;                        0, (int) (ypos * scale), font_elev, g);
<b class="nc">&nbsp;                ypos -= 10;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (depth != 0) {</b>
<b class="nc">&nbsp;                drawCenteredString(</b>
<b class="nc">&nbsp;                        Messages.getString(&quot;BoardView1.DEPTH&quot;) + depth, //$NON-NLS-1$</b>
&nbsp;                        0, (int) (ypos * scale), font_elev, g);
<b class="nc">&nbsp;                ypos -= 10;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (height &gt; 0) {</b>
<b class="nc">&nbsp;                g.setColor(GUIPreferences.getInstance().getColor(</b>
&nbsp;                        &quot;AdvancedBuildingTextColor&quot;));                 //$NON-NLS-1$
<b class="nc">&nbsp;                drawCenteredString(</b>
<b class="nc">&nbsp;                        Messages.getString(&quot;BoardView1.HEIGHT&quot;) + height, //$NON-NLS-1$</b>
&nbsp;                        0, (int) (ypos * scale), font_elev, g);
<b class="nc">&nbsp;                ypos -= 10;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hex.terrainLevel(Terrains.FOLIAGE_ELEV) == 1) {</b>
<b class="nc">&nbsp;                g.setColor(GUIPreferences.getInstance().getColor(</b>
&nbsp;                        GUIPreferences.ADVANCED_LOW_FOLIAGE_COLOR));  
<b class="nc">&nbsp;                drawCenteredString(Messages.getString(&quot;BoardView1.LowFoliage&quot;), </b>
&nbsp;                        0, (int) (ypos * scale), font_elev, g);
<b class="nc">&nbsp;                ypos -= 10;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Used to make the following draw calls shorter
<b class="nc">&nbsp;        int s21 = (int)(21*scale);</b>
<b class="nc">&nbsp;        int s71 = (int)(71*scale);</b>
<b class="nc">&nbsp;        int s35 = (int)(35*scale);</b>
<b class="nc">&nbsp;        int s36 = (int)(36*scale);</b>
<b class="nc">&nbsp;        int s62 = (int)(62*scale);</b>
<b class="nc">&nbsp;        int s83 = (int)(83*scale);</b>
&nbsp;
<b class="nc">&nbsp;        Point p1 = new Point(s62, 0);</b>
<b class="nc">&nbsp;        Point p2 = new Point(s21, 0);</b>
<b class="nc">&nbsp;        Point p3 = new Point(s83, s35);</b>
<b class="nc">&nbsp;        Point p4 = new Point(s83, s36);</b>
<b class="nc">&nbsp;        Point p5 = new Point(s62, s71);</b>
<b class="nc">&nbsp;        Point p6 = new Point(s21, s71);</b>
<b class="nc">&nbsp;        Point p7 = new Point(0, s36);</b>
<b class="nc">&nbsp;        Point p8 = new Point(0, s35);</b>
&nbsp;
<b class="nc">&nbsp;        g.setColor(Color.black);</b>
<b class="nc">&nbsp;        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</b>
&nbsp;                1f));
&nbsp;
&nbsp;        // draw elevation borders
<b class="nc">&nbsp;        if (drawElevationLine(c, 0)) {</b>
<b class="nc">&nbsp;            drawIsometricElevation(c, Color.GRAY, p1, p2, 0, g);</b>
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</b>
<b class="nc">&nbsp;                g.drawLine(s21, 0, s62, 0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (drawElevationLine(c, 1)) {</b>
<b class="nc">&nbsp;            drawIsometricElevation(c, Color.DARK_GRAY, p3, p1, 1, g);</b>
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</b>
<b class="nc">&nbsp;                g.drawLine(s62, 0, s83, s35);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (drawElevationLine(c, 2)) {</b>
<b class="nc">&nbsp;            drawIsometricElevation(c, Color.LIGHT_GRAY, p4, p5, 2, g);</b>
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</b>
<b class="nc">&nbsp;                g.drawLine(s83, s36, s62, s71);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (drawElevationLine(c, 3)) {</b>
<b class="nc">&nbsp;            drawIsometricElevation(c, Color.GRAY, p6, p5, 3, g);</b>
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</b>
<b class="nc">&nbsp;                g.drawLine(s62, s71, s21, s71);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (drawElevationLine(c, 4)) {</b>
<b class="nc">&nbsp;            drawIsometricElevation(c, Color.DARK_GRAY, p7, p6, 4, g);</b>
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</b>
<b class="nc">&nbsp;                g.drawLine(s21, s71, 0, s36);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (drawElevationLine(c, 5)) {</b>
<b class="nc">&nbsp;            drawIsometricElevation(c, Color.LIGHT_GRAY, p8, p2, 5, g);</b>
<b class="nc">&nbsp;            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</b>
<b class="nc">&nbsp;                g.drawLine(0, s35, s21, 0);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean hasLoS = fovHighlightingAndDarkening.draw(g, c, 0, 0,</b>
&nbsp;                saveBoardImage);
&nbsp;
&nbsp;        // draw mapsheet borders
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getShowMapsheets()) {</b>
<b class="nc">&nbsp;            g.setColor(GUIPreferences.getInstance().getColor(</b>
&nbsp;                    GUIPreferences.ADVANCED_MAPSHEET_COLOR));
<b class="nc">&nbsp;            if ((c.getX() % 16) == 0) {</b>
&nbsp;                // left edge of sheet (edge 4 &amp; 5)
<b class="nc">&nbsp;                g.drawLine(s21, s71, 0, s36);</b>
<b class="nc">&nbsp;                g.drawLine(0, s35, s21, 0);</b>
<b class="nc">&nbsp;            } else if ((c.getX() % 16) == 15) {</b>
&nbsp;                // right edge of sheet (edge 1 &amp; 2)
<b class="nc">&nbsp;                g.drawLine(s62, 0, s83, s35);</b>
<b class="nc">&nbsp;                g.drawLine(s83, s36, s62, s71);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((c.getY() % 17) == 0) {</b>
&nbsp;                // top edge of sheet (edge 0 and possible 1 &amp; 5)
<b class="nc">&nbsp;                g.drawLine(s21, 0, s62, 0);</b>
<b class="nc">&nbsp;                if ((c.getX() % 2) == 0) {</b>
<b class="nc">&nbsp;                    g.drawLine(s62, 0, s83, s35);</b>
<b class="nc">&nbsp;                    g.drawLine(0, s35, s21, 0);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((c.getY() % 17) == 16) {</b>
&nbsp;                // bottom edge of sheet (edge 3 and possible 2 &amp; 4)
<b class="nc">&nbsp;                g.drawLine(s62, s71, s21, s71);</b>
<b class="nc">&nbsp;                if ((c.getX() % 2) == 1) {</b>
<b class="nc">&nbsp;                    g.drawLine(s83, s36, s62, s71);</b>
<b class="nc">&nbsp;                    g.drawLine(s21, s71, 0, s36);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!hasLoS &amp;&amp; guip.getFovGrayscale()) {</b>
&nbsp;            // rework the pixels to grayscale
<b class="nc">&nbsp;            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</b>
<b class="nc">&nbsp;                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</b>
<b class="nc">&nbsp;                    int rgb = hexImage.getRGB(x, y);</b>
<b class="nc">&nbsp;                    int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</b>
<b class="nc">&nbsp;                    int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</b>
<b class="nc">&nbsp;                    int bl = (rgb &amp; 0xFF);</b>
<b class="nc">&nbsp;                    int al = (rgb &gt;&gt; 24);</b>
&nbsp;
<b class="nc">&nbsp;                    int grayLevel = (rd + gr + bl) / 3;</b>
<b class="nc">&nbsp;                    int gray = (al &lt;&lt; 24) + (grayLevel &lt;&lt; 16) + (grayLevel &lt;&lt; 8) + grayLevel;</b>
<b class="nc">&nbsp;                    hexImage.setRGB(x, y, gray);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        cacheEntry = new HexImageCacheEntry(hexImage);</b>
<b class="nc">&nbsp;        if (!dontCache) {</b>
<b class="nc">&nbsp;            hexImageCache.put(c, cacheEntry);</b>
&nbsp;        }
<b class="nc">&nbsp;        boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a orthographic hex onto the board buffer. This assumes that
&nbsp;     * drawRect is current, and does not check if the hex is visible.
&nbsp;     */
&nbsp;    private void drawOrthograph(Coords c, Graphics boardGraph) {
<b class="nc">&nbsp;        if (!game.getBoard().contains(c)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final IHex oHex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        final Point oHexLoc = getHexLocation(c);</b>
&nbsp;
&nbsp;        // We need to adjust the height based on several cases
<b class="nc">&nbsp;        int elevOffset = oHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
&nbsp;
<b class="nc">&nbsp;        int orthX = oHexLoc.x;</b>
<b class="nc">&nbsp;        int orthY = oHexLoc.y - (int) (HEX_ELEV * scale * elevOffset);</b>
<b class="nc">&nbsp;        if (!useIsometric()) {</b>
<b class="nc">&nbsp;            orthY = oHexLoc.y;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (tileManager.orthoFor(oHex) != null) {</b>
<b class="nc">&nbsp;            for (Image image : tileManager.orthoFor(oHex)) {</b>
<b class="nc">&nbsp;                BufferedImage scaledImage = ImageUtil.createAcceleratedImage(getScaledImage(image, true));</b>
&nbsp;
&nbsp;                // Darken the hex for night-time, if applicable
<b class="nc">&nbsp;                if (GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</b>
<b class="nc">&nbsp;                        &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</b>
<b class="nc">&nbsp;                        &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</b>
<b class="nc">&nbsp;                    for (int x = 0; x &lt; scaledImage.getWidth(null); ++x) {</b>
<b class="nc">&nbsp;                        for (int y = 0; y &lt; scaledImage.getHeight(); ++y) {</b>
<b class="nc">&nbsp;                            scaledImage.setRGB(x, y, getNightDarkenedColor(scaledImage.getRGB(x, y)));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // draw orthogonal
<b class="nc">&nbsp;                boardGraph.drawImage(scaledImage, orthX, orthY, this);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    final boolean useIsometric() {
<b class="nc">&nbsp;        return drawIsometric;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the Isometric elevation for the hex at the given coordinates (c) on
&nbsp;     * the side indicated by the direction (dir). This method only draws a
&nbsp;     * triangle for the elevation, the companion triangle representing the
&nbsp;     * adjacent hex is also needed. The two triangles when drawn together make a
&nbsp;     * complete rectangle representing the complete elevated hex side.
&nbsp;     * &lt;p/&gt;
&nbsp;     * By drawing the elevated hex as two separate triangles we avoid clipping
&nbsp;     * problems with other hexes because the lower elevation is rendered before
&nbsp;     * the higher elevation. Thus any hexes that have a higher elevation than
&nbsp;     * the lower hex will overwrite the lower hex.
&nbsp;     * &lt;p/&gt;
&nbsp;     * The Triangle for each hex side is formed by points p1, p2, and p3. Where
&nbsp;     * p1 and p2 are the original hex edges, and p3 has the same X value as p1,
&nbsp;     * but the y value has been increased (or decreased) based on the difference
&nbsp;     * in elevation between the given hex and the adjacent hex.
&nbsp;     *
&nbsp;     * @param c          Coordinates of the source hex.
&nbsp;     * @param color      Color to use for the elevation polygons.
&nbsp;     * @param p1         The First point on the edge of the hex.
&nbsp;     * @param p2         The second point on the edge of the hex.
&nbsp;     * @param dir        The side of the hex to have the elevation drawn on.
&nbsp;     * @param g
&nbsp;     */
&nbsp;    private final void drawIsometricElevation(Coords c, Color color, Point p1,
&nbsp;            Point p2, int dir, Graphics g) {
<b class="nc">&nbsp;        final IHex dest = game.getBoard().getHexInDir(c, dir);</b>
<b class="nc">&nbsp;        final IHex src = game.getBoard().getHex(c);</b>
&nbsp;
<b class="nc">&nbsp;        if (!useIsometric() ||</b>
<b class="nc">&nbsp;                GUIPreferences.getInstance().getBoolean(GUIPreferences.FLOATINGISO)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Pad polygon size slightly to avoid rounding errors from scale float.
<b class="nc">&nbsp;        int fudge = -1;</b>
<b class="nc">&nbsp;        if ((dir == 2) || (dir == 4) || (dir == 3)) {</b>
<b class="nc">&nbsp;            fudge = 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int elev = src.getLevel();</b>
&nbsp;        // If the Destination is null, draw the complete elevation side.
<b class="nc">&nbsp;        if ((dest == null) &amp;&amp; (elev &gt; 0)</b>
&nbsp;            &amp;&amp; ((dir == 2) || (dir == 3) || (dir == 4))) {
&nbsp;
&nbsp;            // Determine the depth of the edge that needs to be drawn.
<b class="nc">&nbsp;            int height = elev;</b>
<b class="nc">&nbsp;            IHex southHex = game.getBoard().getHexInDir(c, 3);</b>
<b class="nc">&nbsp;            if ((dir != 3) &amp;&amp; (southHex != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (elev &gt; southHex.getLevel())) {</b>
<b class="nc">&nbsp;                height = elev - southHex.getLevel();</b>
&nbsp;            }
<b class="nc">&nbsp;            int scaledHeight = (int) (HEX_ELEV * scale * height);</b>
&nbsp;
<b class="nc">&nbsp;            Polygon p = new Polygon(new int[] { p1.x, p2.x, p2.x, p1.x },</b>
&nbsp;                    new int[] { p1.y + fudge, p2.y + fudge,
&nbsp;                            p2.y + scaledHeight, p1.y + scaledHeight }, 4);
<b class="nc">&nbsp;            g.setColor(color);</b>
<b class="nc">&nbsp;            g.drawPolygon(p);</b>
<b class="nc">&nbsp;            g.fillPolygon(p);</b>
&nbsp;
<b class="nc">&nbsp;            g.setColor(Color.BLACK);</b>
<b class="nc">&nbsp;            if ((dir == 2) || (dir == 4)) {</b>
<b class="nc">&nbsp;                g.drawLine(p1.x, p1.y, p1.x, p1.y + scaledHeight);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (dest == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int delta = elev - dest.getLevel();</b>
&nbsp;        // Don&#39;t draw the elevation if there is no exposed edge for the player
&nbsp;        // to see.
<b class="nc">&nbsp;        if ((delta == 0)</b>
&nbsp;            || (((dir == 0) || (dir == 1) || (dir == 5)) &amp;&amp; (delta &gt; 0))
&nbsp;            || (((dir == 2) || (dir == 3) || (dir == 4)) &amp;&amp; (delta &lt; 0))) {
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (dir == 1) {</b>
&nbsp;            /*
&nbsp;            // Draw a little bit of shadow to improve the 3d isometric effect.
&nbsp;            Polygon shadow1 = new Polygon(new int[] { p1.x, p2.x,
&nbsp;                    p2.x - (int) (HEX_ELEV * scale) }, new int[] { p1.y, p2.y,
&nbsp;                    p2.y }, 3);
&nbsp;            if ((p2.x - (int) (HEX_ELEV * scale)) &lt; 0) {
&nbsp;                System.out.println(&quot;Negative X value!: &quot; + (p2.x - (int) (HEX_ELEV * scale)));
&nbsp;            }
&nbsp;            g.setColor(new Color(0, 0, 0, 0.4f));
&nbsp;            g.fillPolygon(shadow1);*/
&nbsp;            // not necessary with the shadowmap
&nbsp;            // people not using the shadowmap will probably not need this shadow either
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((dir == 2) || (dir == 3) || (dir == 4)) {</b>
<b class="nc">&nbsp;            int scaledDelta = (int) (HEX_ELEV * scale * delta);</b>
<b class="nc">&nbsp;            Point p3 = new Point(p1.x, p1.y + scaledDelta + fudge);</b>
&nbsp;
<b class="nc">&nbsp;            Polygon p = new Polygon(new int[] { p1.x, p2.x, p2.x, p1.x },</b>
&nbsp;                    new int[] { p1.y + fudge, p2.y + fudge,
&nbsp;                            p2.y + fudge + scaledDelta,
&nbsp;                            p1.y + fudge + scaledDelta }, 4);
&nbsp;
<b class="nc">&nbsp;            if ((p1.y + fudge) &lt; 0) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Negative Y value (Fudge)!: &quot; + (p1.y + fudge));</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((p2.y + fudge) &lt; 0) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Negative Y value (Fudge)!: &quot; + (p2.y + fudge));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((p2.y + fudge + scaledDelta) &lt; 0) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Negative Y value!: &quot; + (p2.y + fudge + scaledDelta));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (( p1.y + fudge + scaledDelta) &lt; 0) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Negative Y value!: &quot; + ( p1.y + fudge + scaledDelta));</b>
&nbsp;            }
<b class="nc">&nbsp;            g.setColor(color);</b>
<b class="nc">&nbsp;            g.drawPolygon(p);</b>
<b class="nc">&nbsp;            g.fillPolygon(p);</b>
&nbsp;
<b class="nc">&nbsp;            g.setColor(Color.BLACK);</b>
<b class="nc">&nbsp;            if ((dir == 1) || (dir == 2) || (dir == 5) || (dir == 4)) {</b>
<b class="nc">&nbsp;                g.drawLine(p1.x, p1.y, p3.x, p3.y);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if an elevation line should be drawn between the starting
&nbsp;     * hex and the hex in the direction specified. Results should be transitive,
&nbsp;     * that is, if a line is drawn in one direction, it should be drawn in the
&nbsp;     * opposite direction as well.
&nbsp;     */
&nbsp;    private final boolean drawElevationLine(Coords src, int direction) {
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHexInDir(src, direction);</b>
<b class="nc">&nbsp;        if ((destHex == null) &amp;&amp; (srcHex.getLevel() != 0)) {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } else if (destHex == null) {</b>
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        } else if (srcHex.getLevel() != destHex.getLevel()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return (srcHex.floor() != destHex.floor());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given an int-packed RGB value, apply a modifier for the light level and return the result.
&nbsp;     *
&nbsp;     * @param rgb int-packed ARGB value.
&nbsp;     * @return An int-packed ARGB value, which is an adjusted value of the input, based on the light level
&nbsp;     */
&nbsp;    public int getNightDarkenedColor(int rgb) {
<b class="nc">&nbsp;        int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</b>
<b class="nc">&nbsp;        int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</b>
<b class="nc">&nbsp;        int bl = rgb &amp; 0xFF;</b>
<b class="nc">&nbsp;        int al = (rgb &gt;&gt; 24);</b>
&nbsp;
<b class="nc">&nbsp;        switch (game.getPlanetaryConditions().getLight()) {</b>
&nbsp;        case PlanetaryConditions.L_FULL_MOON:
<b class="nc">&nbsp;            rd = rd / 4; // 1/4 red</b>
<b class="nc">&nbsp;            gr = gr / 4; // 1/4 green</b>
<b class="nc">&nbsp;            bl = bl / 2; // half blue</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PlanetaryConditions.L_PITCH_BLACK:
<b class="nc">&nbsp;            int gy = (rd + gr + bl) / 16;</b>
<b class="nc">&nbsp;            if (Math.random() &lt; 0.3) {</b>
<b class="nc">&nbsp;                gy = gy * 4 / 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (Math.random() &lt; 0.3) {</b>
<b class="nc">&nbsp;                gy = gy * 5 / 4;</b>
&nbsp;            }
<b class="nc">&nbsp;            rd = gy + rd / 5;</b>
<b class="nc">&nbsp;            gr = gy + gr / 5;</b>
<b class="nc">&nbsp;            bl = gy + bl / 5;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PlanetaryConditions.L_MOONLESS:
<b class="nc">&nbsp;            rd = rd / 4;</b>
<b class="nc">&nbsp;            gr = gr / 4;</b>
<b class="nc">&nbsp;            bl = bl / 2;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PlanetaryConditions.L_DUSK:
<b class="nc">&nbsp;            bl = bl * 3 / 4;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        default:
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return (al &lt;&lt; 24) + (rd &lt;&lt; 16) + (gr &lt;&lt; 8) + bl;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a Shape drawing area for the hex shadow effect in a lower hex
&nbsp;     * when a higher hex is found in direction.
&nbsp;     */
&nbsp;    private final Shape getElevationShadowArea(Coords src, int direction) {
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHexInDir(src, direction);</b>
&nbsp;
&nbsp;        // When at the board edge, create a shadow in hexes of level &lt; 0
<b class="nc">&nbsp;        if (destHex == null)</b>
&nbsp;        {
<b class="nc">&nbsp;            if (srcHex.getLevel() &gt;= 0) return null;</b>
&nbsp;        }
&nbsp;        else
&nbsp;        {
&nbsp;            // no shadow area when the current hex is not lower than the next hex in direction
<b class="nc">&nbsp;            if (srcHex.getLevel() &gt;= destHex.getLevel()) return null;</b>
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getHexInclines()</b>
<b class="nc">&nbsp;                    &amp;&amp; (destHex.getLevel() - srcHex.getLevel() &lt; 2)</b>
<b class="nc">&nbsp;                    &amp;&amp; !destHex.hasCliffTopTowards(srcHex)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return(AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</b>
<b class="nc">&nbsp;                HexDrawUtilities.getHexBorderArea(direction, HexDrawUtilities.CUT_BORDER, 36)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a fill gradient which is rotated and aligned properly for
&nbsp;     * the drawing area for a hex shadow effect in a lower hex.
&nbsp;     */
&nbsp;    private final GradientPaint getElevationShadowGP(Coords src, int direction) {
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHexInDir(src, direction);</b>
&nbsp;
<b class="nc">&nbsp;        if (destHex == null) return null;</b>
&nbsp;
<b class="nc">&nbsp;        int ldiff = destHex.getLevel()-srcHex.getLevel();</b>
&nbsp;        // the shadow strength depends on the level difference,
&nbsp;        // but only to a maximum difference of 3 levels
<b class="nc">&nbsp;        ldiff = Math.min(ldiff*5,15);</b>
&nbsp;
<b class="nc">&nbsp;        Color c1 = new Color(30,30,50,255); // dark end of shadow</b>
<b class="nc">&nbsp;        Color c2 = new Color(50,50,70,0);   // light end of shadow</b>
&nbsp;
<b class="nc">&nbsp;        Point2D p1 = new Point2D.Double(41.5,-25+ldiff);</b>
<b class="nc">&nbsp;        Point2D p2 = new Point2D.Double(41.5,8.0+ldiff);</b>
&nbsp;
<b class="nc">&nbsp;        AffineTransform t = new AffineTransform();</b>
<b class="nc">&nbsp;        t.scale(scale,scale);</b>
<b class="nc">&nbsp;        t.rotate(Math.toRadians(direction*60),41.5,35.5);</b>
<b class="nc">&nbsp;        t.transform(p1,p1);</b>
<b class="nc">&nbsp;        t.transform(p2,p2);</b>
&nbsp;
<b class="nc">&nbsp;        return(new GradientPaint(p1,c1,p2,c2));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the absolute position of the upper-left hand corner of the hex
&nbsp;     * graphic
&nbsp;     */
&nbsp;    private Point getHexLocation(int x, int y, boolean ignoreElevation) {
<b class="nc">&nbsp;        float elevationAdjust = 0.0f;</b>
&nbsp;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(x, y);</b>
<b class="nc">&nbsp;        if ((hex != null) &amp;&amp; useIsometric() &amp;&amp; !ignoreElevation) {</b>
<b class="nc">&nbsp;            elevationAdjust = hex.getLevel() * HEX_ELEV * scale * -1.0f;</b>
&nbsp;        }
<b class="nc">&nbsp;        int ypos = (y * (int) (HEX_H * scale))</b>
<b class="nc">&nbsp;                   + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * scale) : 0);</b>
<b class="nc">&nbsp;        return new Point(x * (int) (HEX_WC * scale), ypos + (int) elevationAdjust);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For large tile texture: Returns the absolute position of the upper-left
&nbsp;     * hand corner of the hex graphic When using large tiles multiplying the
&nbsp;     * rounding errors from the (int) cast must be avoided however this cannot
&nbsp;     * be used for small tiles as it will make gaps appear between hexes This
&nbsp;     * will not factor in Isometric as this would be incorrect for large tiles
&nbsp;     */
&nbsp;    private Point getHexLocationLargeTile(int x, int y, float tscale) {
<b class="nc">&nbsp;        int ypos = (int) (y * HEX_H * tscale)</b>
<b class="nc">&nbsp;                + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * tscale) : 0);</b>
<b class="nc">&nbsp;        return new Point((int) (x * HEX_WC * tscale), ypos);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Point getHexLocationLargeTile(int x, int y) {
<b class="nc">&nbsp;        return getHexLocationLargeTile(x, y, scale);</b>
&nbsp;    }
&nbsp;
&nbsp;    Point getHexLocation(Coords c) {
<b class="nc">&nbsp;        return getHexLocation(c.getX(), c.getY(), false);</b>
&nbsp;    }
&nbsp;
&nbsp;     /**
&nbsp;     * Returns the absolute position of the centre of the hex graphic
&nbsp;     */
&nbsp;    private Point getCentreHexLocation(int x, int y, boolean ignoreElevation) {
<b class="nc">&nbsp;        Point p = getHexLocation(x, y, ignoreElevation);</b>
<b class="nc">&nbsp;        p.x += ((HEX_W / 2) * scale);</b>
<b class="nc">&nbsp;        p.y += ((HEX_H / 2) * scale);</b>
<b class="nc">&nbsp;        return p;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Point getCentreHexLocation(Coords c) {
<b class="nc">&nbsp;        return getCentreHexLocation(c.getX(), c.getY(), false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Point getCentreHexLocation(Coords c, boolean ignoreElevation) {
<b class="nc">&nbsp;        return getCentreHexLocation(c.getX(), c.getY(), ignoreElevation);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void drawRuler(Coords s, Coords e, Color sc, Color ec) {
<b class="nc">&nbsp;        rulerStart = s;</b>
<b class="nc">&nbsp;        rulerEnd = e;</b>
<b class="nc">&nbsp;        rulerStartColor = sc;</b>
<b class="nc">&nbsp;        rulerEndColor = ec;</b>
&nbsp;
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the coords at the specified point
&nbsp;     */
&nbsp;    Coords getCoordsAt(Point p) {
&nbsp;        // We must account for the board translation to add padding
<b class="nc">&nbsp;        p.x -= HEX_W;</b>
<b class="nc">&nbsp;        p.y -= HEX_H;</b>
&nbsp;
&nbsp;        // base values
<b class="nc">&nbsp;        int x = p.x / (int) (HEX_WC * scale);</b>
<b class="nc">&nbsp;        int y = p.y / (int) (HEX_H * scale);</b>
&nbsp;        // correction for the displaced odd columns
<b class="nc">&nbsp;        if ((float) p.y / (scale * HEX_H) - y &lt; 0.5)</b>
<b class="nc">&nbsp;            y -= x % 2;</b>
&nbsp;
&nbsp;        // check the surrounding hexes if they contain p
&nbsp;        // checking at most 3 hexes would be sufficient
&nbsp;        // but which ones? This is failsafer.
<b class="nc">&nbsp;        Coords cc = new Coords(x, y);</b>
<b class="nc">&nbsp;        if (!HexDrawUtilities.getHexFull(getHexLocation(cc),scale).contains(p)) {</b>
<b class="nc">&nbsp;            boolean hasMatch = false;</b>
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6 &amp;&amp; !hasMatch; dir++) {</b>
<b class="nc">&nbsp;                Coords cn = cc.translated(dir);</b>
<b class="nc">&nbsp;                if (HexDrawUtilities.getHexFull(getHexLocation(cn),scale).contains(p)) {</b>
<b class="nc">&nbsp;                    cc = cn;</b>
<b class="nc">&nbsp;                    hasMatch = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (useIsometric()) {</b>
&nbsp;            // When using isometric rendering, a lower hex can obscure the
&nbsp;            // normal hex. Iterate over all hexes from highest to lowest,
&nbsp;            // looking for a hex that contains the selected mouse click point.
<b class="nc">&nbsp;            final int minElev = Math.min(0, game.getBoard().getMinElevation());</b>
<b class="nc">&nbsp;            final int maxElev = Math.max(0, game.getBoard().getMaxElevation());</b>
<b class="nc">&nbsp;            final int delta = (int) Math</b>
<b class="nc">&nbsp;                    .ceil(((double) maxElev - minElev) / 3.0f);</b>
<b class="nc">&nbsp;            final int minHexSpan = Math.max(y - delta, 0);</b>
<b class="nc">&nbsp;            final int maxHexSpan = Math.min(y + delta, game.getBoard()</b>
<b class="nc">&nbsp;                                                           .getHeight());</b>
<b class="nc">&nbsp;            for (int elev = maxElev; elev &gt;= minElev; elev--) {</b>
<b class="nc">&nbsp;                for (int i = minHexSpan; i &lt;= maxHexSpan; i++) {</b>
<b class="nc">&nbsp;                    for (int dx = -1; dx &lt; 2; dx++) {</b>
<b class="nc">&nbsp;                        Coords c1 = new Coords(x + dx, i);</b>
<b class="nc">&nbsp;                        IHex hexAlt = game.getBoard().getHex(c1);</b>
<b class="nc">&nbsp;                        if (HexDrawUtilities.getHexFull(getHexLocation(c1),scale).contains(p)</b>
&nbsp;                                &amp;&amp; (hexAlt != null)
<b class="nc">&nbsp;                                &amp;&amp; (hexAlt.getLevel() == elev)) {</b>
&nbsp;                            // Return immediately with highest hex found.
<b class="nc">&nbsp;                            return c1;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // nothing found
<b class="nc">&nbsp;            return new Coords(-1,-1);</b>
&nbsp;        }
&nbsp;        else {
&nbsp;            // not Isometric
<b class="nc">&nbsp;            return cc;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void redrawMovingEntity(Entity entity, Coords position, int facing,
&nbsp;            int elevation) {
<b class="nc">&nbsp;        Integer entityId = Integer.valueOf(entity.getId());</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; spriteKey = getIdAndLoc(entityId, -1);</b>
<b class="nc">&nbsp;        EntitySprite sprite = entitySpriteIds.get(spriteKey);</b>
<b class="nc">&nbsp;        IsometricSprite isoSprite = isometricSpriteIds.get(spriteKey);</b>
&nbsp;        // We can ignore secondary locations for now, as we don&#39;t have moving
&nbsp;        // multi-location entitys (will need to change for mobile structures)
&nbsp;
&nbsp;        PriorityQueue&lt;EntitySprite&gt; newSprites;
&nbsp;        PriorityQueue&lt;IsometricSprite&gt; isoSprites;
&nbsp;        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds;
&nbsp;        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds;
&nbsp;
&nbsp;        // Remove sprite for Entity, so it&#39;s not displayed while moving
<b class="nc">&nbsp;        if (sprite != null) {</b>
<b class="nc">&nbsp;            newSprites = new PriorityQueue&lt;EntitySprite&gt;(entitySprites);</b>
<b class="nc">&nbsp;            newSpriteIds = new HashMap&lt;&gt;(entitySpriteIds);</b>
&nbsp;
<b class="nc">&nbsp;            newSprites.remove(sprite);</b>
<b class="nc">&nbsp;            newSpriteIds.remove(spriteKey);</b>
&nbsp;
<b class="nc">&nbsp;            entitySprites = newSprites;</b>
<b class="nc">&nbsp;            entitySpriteIds = newSpriteIds;</b>
&nbsp;        }
&nbsp;        // Remove iso sprite for Entity, so it&#39;s not displayed while moving
<b class="nc">&nbsp;        if (isoSprite != null) {</b>
<b class="nc">&nbsp;            isoSprites = new PriorityQueue&lt;IsometricSprite&gt;(isometricSprites);</b>
<b class="nc">&nbsp;            newIsoSpriteIds = new HashMap&lt;&gt;(isometricSpriteIds);</b>
&nbsp;
<b class="nc">&nbsp;            isoSprites.remove(isoSprite);</b>
<b class="nc">&nbsp;            newIsoSpriteIds.remove(spriteKey);</b>
&nbsp;
<b class="nc">&nbsp;            isometricSprites = isoSprites;</b>
<b class="nc">&nbsp;            isometricSpriteIds = newIsoSpriteIds;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        MovingEntitySprite mSprite = movingEntitySpriteIds.get(entityId);</b>
<b class="nc">&nbsp;        List&lt;MovingEntitySprite&gt; newMovingSprites = new ArrayList&lt;&gt;(</b>
&nbsp;                movingEntitySprites);
<b class="nc">&nbsp;        HashMap&lt;Integer, MovingEntitySprite&gt; newMovingSpriteIds = new HashMap&lt;&gt;(</b>
&nbsp;                movingEntitySpriteIds);
&nbsp;        // Remove any old movement sprite
<b class="nc">&nbsp;        if (mSprite != null) {</b>
<b class="nc">&nbsp;            newMovingSprites.remove(mSprite);</b>
&nbsp;        }
&nbsp;        // Create new movement sprite
<b class="nc">&nbsp;        if (entity.getPosition() != null) {</b>
<b class="nc">&nbsp;            mSprite = new MovingEntitySprite(this, entity, position, facing,</b>
&nbsp;                    elevation);
<b class="nc">&nbsp;            newMovingSprites.add(mSprite);</b>
<b class="nc">&nbsp;            newMovingSpriteIds.put(entityId, mSprite);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        movingEntitySprites = newMovingSprites;</b>
<b class="nc">&nbsp;        movingEntitySpriteIds = newMovingSpriteIds;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isMovingUnits() {
<b class="nc">&nbsp;        return movingUnits.size() &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
&nbsp;     * the old sprite with the new! Try to prevent annoying
&nbsp;     * ConcurrentModificationExceptions
&nbsp;     */
&nbsp;    public void redrawEntity(Entity entity) {
<b class="nc">&nbsp;        redrawEntity(entity, null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for returning a Key value for the entitySpriteIds and
&nbsp;     * isometricSprite maps. The List contains as the first element the Entity
&nbsp;     * ID and as the second element it&#39;s location ID: either -1 if the Entity
&nbsp;     * has no secondary locations, or the index of its secondary location.
&nbsp;     *
&nbsp;     * @param entityId
&nbsp;     *            The Entity ID
&nbsp;     * @param secondaryLoc
&nbsp;     *            the secondary loc index, or -1 for Entitys without secondary
&nbsp;     *            positions
&nbsp;     * @return
&nbsp;     */
&nbsp;    private List&lt;Integer&gt; getIdAndLoc(Integer entityId, int secondaryLoc) {
<b class="nc">&nbsp;        List&lt;Integer&gt; idLoc = new ArrayList&lt;Integer&gt;(2);</b>
<b class="nc">&nbsp;        idLoc.add(entityId);</b>
<b class="nc">&nbsp;        idLoc.add(secondaryLoc);</b>
<b class="nc">&nbsp;        return idLoc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
&nbsp;     * the old sprite with the new! Takes a reference to the Entity object
&nbsp;     * before changes, in case it contained important state information, like
&nbsp;     * Dropships taking off (airborne dropships lose their secondary hexes). Try
&nbsp;     * to prevent annoying ConcurrentModificationExceptions
&nbsp;     */
&nbsp;    public void redrawEntity(Entity entity, Entity oldEntity) {
<b class="nc">&nbsp;        Integer entityId = Integer.valueOf(entity.getId());</b>
<b class="nc">&nbsp;        if (oldEntity == null) {</b>
<b class="nc">&nbsp;            oldEntity = entity;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the entity we are updating doesn&#39;t have a position, ensure we
&nbsp;        // remove all of its old sprites
<b class="nc">&nbsp;        if (entity.getPosition() == null) {</b>
&nbsp;            Iterator&lt;EntitySprite&gt; spriteIter;
&nbsp;
&nbsp;            // Remove Entity Sprites
<b class="nc">&nbsp;            spriteIter = entitySprites.iterator();</b>
<b class="nc">&nbsp;            while (spriteIter.hasNext()) {</b>
<b class="nc">&nbsp;                EntitySprite sprite = spriteIter.next();</b>
<b class="nc">&nbsp;                if (sprite.entity.equals(entity)) {</b>
<b class="nc">&nbsp;                    spriteIter.remove();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //  Update ID -&gt; Sprite map
<b class="nc">&nbsp;            spriteIter = entitySpriteIds.values().iterator();</b>
<b class="nc">&nbsp;            while (spriteIter.hasNext()) {</b>
<b class="nc">&nbsp;                EntitySprite sprite = spriteIter.next();</b>
<b class="nc">&nbsp;                if (sprite.entity.equals(entity)) {</b>
<b class="nc">&nbsp;                    spriteIter.remove();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            Iterator&lt;IsometricSprite&gt; isoSpriteIter;
&nbsp;
&nbsp;            // Remove IsometricSprites
<b class="nc">&nbsp;            isoSpriteIter = isometricSprites.iterator();</b>
<b class="nc">&nbsp;            while (isoSpriteIter.hasNext()) {</b>
<b class="nc">&nbsp;                IsometricSprite sprite = isoSpriteIter.next();</b>
<b class="nc">&nbsp;                if (sprite.entity.equals(entity)) {</b>
<b class="nc">&nbsp;                    isoSpriteIter.remove();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Update ID -&gt; Iso Sprite Map
<b class="nc">&nbsp;            isoSpriteIter  = isometricSpriteIds.values().iterator();</b>
<b class="nc">&nbsp;            while (isoSpriteIter.hasNext()) {</b>
<b class="nc">&nbsp;                IsometricSprite sprite = isoSpriteIter.next();</b>
<b class="nc">&nbsp;                if (sprite.entity.equals(entity)) {</b>
<b class="nc">&nbsp;                    isoSpriteIter.remove();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Create a copy of the sprite list
<b class="nc">&nbsp;        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;&gt;(entitySprites);</b>
<b class="nc">&nbsp;        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds =</b>
&nbsp;                new HashMap&lt;&gt;(entitySpriteIds);
<b class="nc">&nbsp;        Queue&lt;IsometricSprite&gt; isoSprites = new PriorityQueue&lt;&gt;(</b>
&nbsp;                isometricSprites);
<b class="nc">&nbsp;        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds =</b>
&nbsp;                new HashMap&lt;&gt;(isometricSpriteIds);
&nbsp;
&nbsp;        // Remove the sprites we are going to update
<b class="nc">&nbsp;        EntitySprite sprite = entitySpriteIds.get(getIdAndLoc(entityId, -1));</b>
<b class="nc">&nbsp;        IsometricSprite isoSprite = isometricSpriteIds.get(getIdAndLoc(</b>
&nbsp;                entityId, -1));
<b class="nc">&nbsp;        if (sprite != null) {</b>
<b class="nc">&nbsp;            newSprites.remove(sprite);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isoSprite != null) {</b>
<b class="nc">&nbsp;            isoSprites.remove(isoSprite);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int secondaryPos : oldEntity.getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;            sprite = entitySpriteIds.get(getIdAndLoc(entityId, secondaryPos));</b>
<b class="nc">&nbsp;            if (sprite != null) {</b>
<b class="nc">&nbsp;                newSprites.remove(sprite);</b>
&nbsp;            }
<b class="nc">&nbsp;            isoSprite = isometricSpriteIds.get(getIdAndLoc(entityId,</b>
&nbsp;                    secondaryPos));
<b class="nc">&nbsp;            if (isoSprite != null) {</b>
<b class="nc">&nbsp;                isoSprites.remove(isoSprite);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Create the new sprites
<b class="nc">&nbsp;        Coords position = entity.getPosition();</b>
<b class="nc">&nbsp;        boolean canSee = EntityVisibilityUtils.detectedOrHasVisual(localPlayer, game, entity);</b>
&nbsp;
<b class="nc">&nbsp;        if ((position != null) &amp;&amp; canSee) {</b>
&nbsp;            // Add new EntitySprite
&nbsp;            // If no secondary positions, add a sprite for the central position
<b class="nc">&nbsp;            if (entity.getSecondaryPositions().isEmpty()) {</b>
<b class="nc">&nbsp;                sprite = new EntitySprite(this, entity, -1, radarBlipImage);</b>
<b class="nc">&nbsp;                newSprites.add(sprite);</b>
<b class="nc">&nbsp;                newSpriteIds.put(getIdAndLoc(entityId, -1), sprite);</b>
&nbsp;            } else { // Add all secondary position sprites, which includes a
&nbsp;                // sprite for the central hex
<b class="nc">&nbsp;                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                    sprite = new EntitySprite(this, entity, secondaryPos,</b>
&nbsp;                            radarBlipImage);
<b class="nc">&nbsp;                    newSprites.add(sprite);</b>
<b class="nc">&nbsp;                    newSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</b>
&nbsp;                            sprite);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // Add new IsometricSprite
&nbsp;            // If no secondary positions, add a sprite for the central position
<b class="nc">&nbsp;            if (entity.getSecondaryPositions().isEmpty()) {</b>
<b class="nc">&nbsp;                isoSprite = new IsometricSprite(this, entity, -1,</b>
&nbsp;                        radarBlipImage);
<b class="nc">&nbsp;                isoSprites.add(isoSprite);</b>
<b class="nc">&nbsp;                newIsoSpriteIds.put(getIdAndLoc(entityId, -1), isoSprite);</b>
&nbsp;            } else { // Add all secondary position sprites, which includes a
&nbsp;                // sprite for the central hex
<b class="nc">&nbsp;                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                    isoSprite = new IsometricSprite(this, entity, secondaryPos,</b>
&nbsp;                            radarBlipImage);
<b class="nc">&nbsp;                    isoSprites.add(isoSprite);</b>
<b class="nc">&nbsp;                    newIsoSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</b>
&nbsp;                            isoSprite);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Update Sprite state with new collections
<b class="nc">&nbsp;        entitySprites = newSprites;</b>
<b class="nc">&nbsp;        entitySpriteIds = newSpriteIds;</b>
<b class="nc">&nbsp;        isometricSprites = isoSprites;</b>
<b class="nc">&nbsp;        isometricSpriteIds = newIsoSpriteIds;</b>
&nbsp;
&nbsp;        // Remove C3 sprites
<b class="nc">&nbsp;        for (Iterator&lt;C3Sprite&gt; i = c3Sprites.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final C3Sprite c3sprite = i.next();</b>
<b class="nc">&nbsp;            if ((c3sprite.entityId == entity.getId())</b>
<b class="nc">&nbsp;                || (c3sprite.masterId == entity.getId())) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Update C3 link, if necessary
<b class="nc">&nbsp;        if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</b>
<b class="nc">&nbsp;            addC3Link(entity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Iterator&lt;VTOLAttackSprite&gt; iter = vtolAttackSprites.iterator(); iter.hasNext();) {</b>
<b class="nc">&nbsp;            final VTOLAttackSprite s = iter.next();</b>
<b class="nc">&nbsp;            if (s.getEntity().getId() == entity.getId()) {</b>
<b class="nc">&nbsp;                iter.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Remove Flyover Sprites
<b class="nc">&nbsp;        Iterator&lt;FlyOverSprite&gt; flyOverIt = flyOverSprites.iterator();</b>
<b class="nc">&nbsp;        while (flyOverIt.hasNext()) {</b>
<b class="nc">&nbsp;            final FlyOverSprite flyOverSprite = flyOverIt.next();</b>
<b class="nc">&nbsp;            if (flyOverSprite.getEntityId() == entity.getId()) {</b>
<b class="nc">&nbsp;                flyOverIt.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Add Flyover path, if necessary
<b class="nc">&nbsp;        if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</b>
<b class="nc">&nbsp;            addFlyOverPath(entity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        updateEcmList();</b>
<b class="nc">&nbsp;        highlightSelectedEntity();</b>
<b class="nc">&nbsp;        scheduleRedraw();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clears all old entity sprites out of memory and sets up new ones.
&nbsp;     */
&nbsp;    void redrawAllEntities() {
<b class="nc">&nbsp;        int numEntities = game.getNoOfEntities();</b>
&nbsp;        // Prevent IllegalArgumentException
<b class="nc">&nbsp;        numEntities = Math.max(1, numEntities);</b>
<b class="nc">&nbsp;        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;EntitySprite&gt;(</b>
&nbsp;                numEntities);
<b class="nc">&nbsp;        Queue&lt;IsometricSprite&gt; newIsometricSprites = new PriorityQueue&lt;&gt;(</b>
&nbsp;                numEntities);
<b class="nc">&nbsp;        Map&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds = new HashMap&lt;&gt;(</b>
&nbsp;                numEntities);
<b class="nc">&nbsp;        Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds = new HashMap&lt;&gt;(</b>
&nbsp;                numEntities);
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;WreckSprite&gt; newWrecks = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;IsometricWreckSprite&gt; newIsometricWrecks = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;Entity&gt; e = game.getWreckedEntities();</b>
<b class="nc">&nbsp;        while (e.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Entity entity = e.nextElement();</b>
<b class="nc">&nbsp;            if (!(entity instanceof Infantry) &amp;&amp; (entity.getPosition() != null)) {</b>
&nbsp;                WreckSprite ws;
&nbsp;                IsometricWreckSprite iws;
<b class="nc">&nbsp;                if (entity.getSecondaryPositions().isEmpty()) {</b>
<b class="nc">&nbsp;                    ws = new WreckSprite(this, entity, -1);</b>
<b class="nc">&nbsp;                    newWrecks.add(ws);</b>
<b class="nc">&nbsp;                    iws = new IsometricWreckSprite(this, entity, -1);</b>
<b class="nc">&nbsp;                    newIsometricWrecks.add(iws);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    for (int secondaryPos : entity.getSecondaryPositions()</b>
<b class="nc">&nbsp;                            .keySet()) {</b>
<b class="nc">&nbsp;                        ws = new WreckSprite(this, entity, secondaryPos);</b>
<b class="nc">&nbsp;                        newWrecks.add(ws);</b>
<b class="nc">&nbsp;                        iws = new IsometricWreckSprite(this, entity,</b>
&nbsp;                                secondaryPos);
<b class="nc">&nbsp;                        newIsometricWrecks.add(iws);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        clearC3Networks();</b>
<b class="nc">&nbsp;        clearFlyOverPaths();</b>
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (entity.getPosition() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((localPlayer != null)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.hasSeenEntity(localPlayer)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.hasDetectedEntity(localPlayer)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((localPlayer != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.isHidden()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.getSecondaryPositions().isEmpty()) {</b>
<b class="nc">&nbsp;                EntitySprite sprite = new EntitySprite(this, entity, -1,</b>
&nbsp;                        radarBlipImage);
<b class="nc">&nbsp;                newSprites.add(sprite);</b>
<b class="nc">&nbsp;                newSpriteIds.put(getIdAndLoc(entity.getId(), -1), sprite);</b>
<b class="nc">&nbsp;                IsometricSprite isosprite = new IsometricSprite(this, entity,</b>
&nbsp;                        -1, radarBlipImage);
<b class="nc">&nbsp;                newIsometricSprites.add(isosprite);</b>
<b class="nc">&nbsp;                newIsoSpriteIds.put(getIdAndLoc(entity.getId(), -1), isosprite);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                    EntitySprite sprite = new EntitySprite(this, entity,</b>
&nbsp;                            secondaryPos, radarBlipImage);
<b class="nc">&nbsp;                    newSprites.add(sprite);</b>
<b class="nc">&nbsp;                    newSpriteIds.put(getIdAndLoc(entity.getId(), secondaryPos),</b>
&nbsp;                            sprite);
&nbsp;
<b class="nc">&nbsp;                    IsometricSprite isosprite = new IsometricSprite(this,</b>
&nbsp;                            entity, secondaryPos, radarBlipImage);
<b class="nc">&nbsp;                    newIsometricSprites.add(isosprite);</b>
<b class="nc">&nbsp;                    newIsoSpriteIds.put(</b>
<b class="nc">&nbsp;                            getIdAndLoc(entity.getId(), secondaryPos),</b>
&nbsp;                            isosprite);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</b>
<b class="nc">&nbsp;                addC3Link(entity);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</b>
<b class="nc">&nbsp;                addFlyOverPath(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        entitySprites = newSprites;</b>
<b class="nc">&nbsp;        entitySpriteIds = newSpriteIds;</b>
&nbsp;
<b class="nc">&nbsp;        isometricSprites = newIsometricSprites;</b>
<b class="nc">&nbsp;        isometricSpriteIds = newIsoSpriteIds;</b>
&nbsp;
<b class="nc">&nbsp;        wreckSprites = newWrecks;</b>
<b class="nc">&nbsp;        isometricWreckSprites = newIsometricWrecks;</b>
&nbsp;
&nbsp;        // Update ECM list, to ensure that Sprites are updated with ECM info
<b class="nc">&nbsp;        updateEcmList();</b>
&nbsp;        // Re-highlight a selected entity, if present
<b class="nc">&nbsp;        highlightSelectedEntity();</b>
&nbsp;
<b class="nc">&nbsp;        scheduleRedraw();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void redrawAllFlares() {
<b class="nc">&nbsp;        flareSprites.clear();</b>
<b class="nc">&nbsp;        for (Flare f : game.getFlares()) {</b>
<b class="nc">&nbsp;            flareSprites.add(new FlareSprite(this, f));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Image getFlareImage() {
<b class="nc">&nbsp;        return flareImage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Moves the cursor to the new position, or hides it, if newPos is null
&nbsp;     */
&nbsp;    private void moveCursor(CursorSprite cursor, Coords newPos) {
<b class="nc">&nbsp;        final Rectangle oldBounds = new Rectangle(cursor.getBounds());</b>
<b class="nc">&nbsp;        if (newPos != null) {</b>
<b class="nc">&nbsp;            cursor.setHexLocation(newPos);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            cursor.setOffScreen();</b>
&nbsp;        }
&nbsp;        // repaint affected area
<b class="nc">&nbsp;        repaint(oldBounds);</b>
<b class="nc">&nbsp;        repaint(cursor.getBounds());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** Centers the board on hex c. Uses smooth centering
&nbsp;     * if activated in the client settings. */
&nbsp;    public void centerOnHex(Coords c) {
<b class="nc">&nbsp;        if (c == null) return;</b>
&nbsp;
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getBoolean(&quot;SOFTCENTER&quot;)) {</b>
&nbsp;            // Soft Centering:
&nbsp;            // set the target point
<b class="nc">&nbsp;            Point p = getCentreHexLocation(c);</b>
<b class="nc">&nbsp;            softCenterTarget.setLocation(</b>
<b class="nc">&nbsp;                    (double)p.x/boardSize.getWidth(),</b>
<b class="nc">&nbsp;                    (double)p.y/boardSize.getHeight());</b>
&nbsp;
&nbsp;            // adjust the target point because the board can&#39;t
&nbsp;            // center on points too close to an edge
<b class="nc">&nbsp;            double w = scrollpane.getViewport().getWidth();</b>
<b class="nc">&nbsp;            double h = scrollpane.getViewport().getHeight();</b>
<b class="nc">&nbsp;            double bw = boardSize.getWidth();</b>
<b class="nc">&nbsp;            double bh = boardSize.getHeight();</b>
&nbsp;
<b class="nc">&nbsp;            double minX = (w/2-HEX_W)/bw;</b>
<b class="nc">&nbsp;            double minY = (h/2-HEX_H)/bh;</b>
<b class="nc">&nbsp;            double maxX = (bw+HEX_W-w/2)/bw;</b>
<b class="nc">&nbsp;            double maxY = (bh+HEX_H-h/2)/bh;</b>
&nbsp;
&nbsp;            // here the order is important because the top/left
&nbsp;            // edges always stop the board, the bottom/right
&nbsp;            // only when the board is big enough
<b class="nc">&nbsp;            softCenterTarget.setLocation(</b>
<b class="nc">&nbsp;                    Math.min(softCenterTarget.getX(), maxX),</b>
<b class="nc">&nbsp;                    Math.min(softCenterTarget.getY(), maxY));</b>
&nbsp;
<b class="nc">&nbsp;            softCenterTarget.setLocation(</b>
<b class="nc">&nbsp;                    Math.max(softCenterTarget.getX(), minX),</b>
<b class="nc">&nbsp;                    Math.max(softCenterTarget.getY(), minY));</b>
&nbsp;
&nbsp;            // get the current board center point
<b class="nc">&nbsp;            double[] v = getVisibleArea();</b>
<b class="nc">&nbsp;            oldCenter.setLocation((v[0]+v[2])/2, (v[1]+v[3])/2);</b>
&nbsp;
<b class="nc">&nbsp;            waitTimer = 0;</b>
<b class="nc">&nbsp;            isSoftCentering = true;</b>
&nbsp;
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // no soft centering:
&nbsp;            // center on c directly
<b class="nc">&nbsp;            Point p = getCentreHexLocation(c);</b>
<b class="nc">&nbsp;            centerOnPointRel(</b>
<b class="nc">&nbsp;                    (double)p.x/boardSize.getWidth(),</b>
<b class="nc">&nbsp;                    (double)p.y/boardSize.getHeight());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** Moves the board one step towards the final
&nbsp;     * position in during soft centering.
&nbsp;     */
&nbsp;    private synchronized void centerOnHexSoftStep(long deltaTime) {
<b class="nc">&nbsp;        if (isSoftCentering) {</b>
&nbsp;            // don&#39;t move the board if 20ms haven&#39;t passed since the last move
<b class="nc">&nbsp;            waitTimer += deltaTime;</b>
<b class="nc">&nbsp;            if (waitTimer &lt; 20) return;</b>
<b class="nc">&nbsp;            waitTimer = 0;</b>
&nbsp;
&nbsp;            // move the board by a fraction of the distance to the target
<b class="nc">&nbsp;            Point2D newCenter = new Point2D.Double(</b>
<b class="nc">&nbsp;                    oldCenter.getX() + (softCenterTarget.getX() - oldCenter.getX())/SOFT_CENTER_SPEED,</b>
<b class="nc">&nbsp;                    oldCenter.getY() + (softCenterTarget.getY() - oldCenter.getY())/SOFT_CENTER_SPEED );</b>
<b class="nc">&nbsp;            centerOnPointRel(newCenter.getX(), newCenter.getY());</b>
&nbsp;
<b class="nc">&nbsp;            oldCenter = newCenter;</b>
&nbsp;
&nbsp;            // stop the motion when close enough to the final position
<b class="nc">&nbsp;            if (softCenterTarget.distance(newCenter) &lt; 0.0005) {</b>
<b class="nc">&nbsp;                stopSoftCentering();</b>
<b class="nc">&nbsp;                pingMinimap();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void stopSoftCentering() {
<b class="nc">&nbsp;        isSoftCentering = false;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void adjustVisiblePosition(Coords c, Point dispPoint, double ihdx, double ihdy) {
<b class="nc">&nbsp;        if ((c == null) || (dispPoint == null)) return;</b>
&nbsp;
<b class="nc">&nbsp;        Point hexPoint = getCentreHexLocation(c);</b>
&nbsp;        // correct for upper left board padding
<b class="nc">&nbsp;        hexPoint.translate(HEX_W, HEX_H);</b>
<b class="nc">&nbsp;        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</b>
<b class="nc">&nbsp;        hscroll.setValue(hexPoint.x-dispPoint.x+(int)(ihdx*scale*HEX_W));</b>
<b class="nc">&nbsp;        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</b>
<b class="nc">&nbsp;        vscroll.setValue(hexPoint.y-dispPoint.y+(int)(ihdy*scale*HEX_H));</b>
<b class="nc">&nbsp;        pingMinimap();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Centers the board to a point
&nbsp;     * @param xrel the x position relative to board width.
&nbsp;     * @param yrel the y position relative to board height.
&nbsp;     * Both xrel and yrel should be between 0 and 1.
&nbsp;     * The method will clip both values to this range.
&nbsp;     */
&nbsp;    public void centerOnPointRel(double xrel, double yrel) {
&nbsp;        // restrict both values to between 0 and 1
<b class="nc">&nbsp;        xrel = Math.max(0,xrel);</b>
<b class="nc">&nbsp;        xrel = Math.min(1,xrel);</b>
<b class="nc">&nbsp;        yrel = Math.max(0,yrel);</b>
<b class="nc">&nbsp;        yrel = Math.min(1,yrel);</b>
<b class="nc">&nbsp;        Point p = new Point(</b>
<b class="nc">&nbsp;                (int)((double)boardSize.getWidth()*xrel)+HEX_W,</b>
<b class="nc">&nbsp;                (int)((double)boardSize.getHeight()*yrel)+HEX_H);</b>
<b class="nc">&nbsp;        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</b>
<b class="nc">&nbsp;        vscroll.setValue(p.y - (vscroll.getVisibleAmount() / 2));</b>
<b class="nc">&nbsp;        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</b>
<b class="nc">&nbsp;        hscroll.setValue(p.x - (hscroll.getVisibleAmount() / 2));</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the currently visible area of the board.
&nbsp;     * @return an array of 4 double values indicating the relative size,
&nbsp;     * where the first two values indicate the x and y position of the upper left
&nbsp;     * corner of the visible area and the second two values the x and y position of
&nbsp;     * the lower right corner.
&nbsp;     * So when the whole board is visible, the values should be 0,0,1,1.
&nbsp;     * When the lower right corner of the board is visible
&nbsp;     * and 90% of width and height: 0.1,0.1,1,1
&nbsp;     * Due to board padding the values can be outside of [0;1]
&nbsp;     */
&nbsp;    public double[] getVisibleArea() {
<b class="nc">&nbsp;        double[] values = new double[4];</b>
<b class="nc">&nbsp;        double x = scrollpane.getViewport().getViewPosition().getX();</b>
<b class="nc">&nbsp;        double y = scrollpane.getViewport().getViewPosition().getY();</b>
<b class="nc">&nbsp;        double w = scrollpane.getViewport().getWidth();</b>
<b class="nc">&nbsp;        double h = scrollpane.getViewport().getHeight();</b>
<b class="nc">&nbsp;        double bw = boardSize.getWidth();</b>
<b class="nc">&nbsp;        double bh = boardSize.getHeight();</b>
&nbsp;
<b class="nc">&nbsp;        values[0] = (x-HEX_W)/bw;</b>
<b class="nc">&nbsp;        values[1] = (y-HEX_H)/bh;</b>
<b class="nc">&nbsp;        values[2] = (x-HEX_W+w)/bw;</b>
<b class="nc">&nbsp;        values[3] = (y-HEX_H+h)/bh;</b>
&nbsp;
<b class="nc">&nbsp;        return values;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clears the old movement data and draws the new.
&nbsp;     */
&nbsp;    public void drawMovementData(Entity entity, MovePath md) {
<b class="nc">&nbsp;        MoveStep previousStep = null;</b>
&nbsp;
<b class="nc">&nbsp;        clearMovementData();</b>
&nbsp;
&nbsp;        // Nothing to do if we don&#39;t have a MovePath
<b class="nc">&nbsp;        if (md == null) {</b>
<b class="nc">&nbsp;            movementTarget = null;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // need to update the movement sprites based on the move path for this
&nbsp;        // entity
&nbsp;        // only way to do this is to clear and refresh (seems wasteful)
&nbsp;
&nbsp;        // first get the color for the vector
<b class="nc">&nbsp;        Color col = Color.blue;</b>
<b class="nc">&nbsp;        if (md.getLastStep() != null) {</b>
<b class="nc">&nbsp;            switch (md.getLastStep().getMovementType(true)) {</b>
&nbsp;                case MOVE_RUN:
&nbsp;                case MOVE_VTOL_RUN:
&nbsp;                case MOVE_OVER_THRUST:
<b class="nc">&nbsp;                    col = GUIPreferences.getInstance().getColor(</b>
&nbsp;                            &quot;AdvancedMoveRunColor&quot;);
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case MOVE_SPRINT:
&nbsp;                case MOVE_VTOL_SPRINT:
<b class="nc">&nbsp;                    col = GUIPreferences.getInstance().getColor(</b>
&nbsp;                            &quot;AdvancedMoveSprintColor&quot;);
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case MOVE_JUMP:
<b class="nc">&nbsp;                    col = GUIPreferences.getInstance().getColor(</b>
&nbsp;                            &quot;AdvancedMoveJumpColor&quot;);
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case MOVE_ILLEGAL:
<b class="nc">&nbsp;                    col = GUIPreferences.getInstance().getColor(</b>
&nbsp;                            &quot;AdvancedMoveIllegalColor&quot;);
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    col = GUIPreferences.getInstance().getColor(</b>
&nbsp;                            &quot;AdvancedMoveDefaultColor&quot;);
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            movementTarget = md.getLastStep().getPosition();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            movementTarget = null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        refreshMoveVectors(entity, md, col);</b>
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;            if ((null != previousStep)</b>
<b class="nc">&nbsp;                &amp;&amp; ((step.getType() == MoveStepType.UP)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.DOWN)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.ACC)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.DEC)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.ACCN)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.DECN))) {</b>
&nbsp;                // Mark the previous elevation change sprite hidden
&nbsp;                // so that we can draw a new one in it&#39;s place without
&nbsp;                // having overlap.
<b class="nc">&nbsp;                pathSprites.get(pathSprites.size() - 1).setHidden(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (previousStep != null</b>
&nbsp;                    // for advanced movement, we always need to hide prior
&nbsp;                    // because costs will overlap and we only want the current
&nbsp;                    // facing
<b class="nc">&nbsp;                    &amp;&amp; (game.useVectorMove()</b>
&nbsp;                            // A LAM converting from AirMech to Biped uses two convert steps and we
&nbsp;                            // only want to show the last.
<b class="nc">&nbsp;                            || (step.getType() == MoveStepType.CONVERT_MODE</b>
<b class="nc">&nbsp;                            &amp;&amp; previousStep.getType() == MoveStepType.CONVERT_MODE)</b>
<b class="nc">&nbsp;                            || step.getType() == MoveStepType.BOOTLEGGER)) {</b>
<b class="nc">&nbsp;                pathSprites.get(pathSprites.size() - 1).setHidden(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            pathSprites.add(new StepSprite(this, step, md.isEndStep(step)));</b>
<b class="nc">&nbsp;            previousStep = step;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        repaint(100);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clears current movement data from the screen
&nbsp;     */
&nbsp;    public void clearMovementData() {
<b class="nc">&nbsp;        pathSprites = new ArrayList&lt;StepSprite&gt;();</b>
<b class="nc">&nbsp;        movementTarget = null;</b>
<b class="nc">&nbsp;        checkFoVHexImageCacheClear();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;        refreshMoveVectors();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setFiringSolutions(Entity attacker,
&nbsp;            Map&lt;Integer, FiringSolution&gt; firingSolutions) {
&nbsp;
<b class="nc">&nbsp;        clearFiringSolutionData();</b>
<b class="nc">&nbsp;        if (firingSolutions == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (FiringSolution sln : firingSolutions.values()) {</b>
<b class="nc">&nbsp;            FiringSolutionSprite sprite = new FiringSolutionSprite(this, sln);</b>
<b class="nc">&nbsp;            firingSprites.add(sprite);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearFiringSolutionData() {
<b class="nc">&nbsp;        firingSprites.clear();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addStrafingCoords(Coords c) {
<b class="nc">&nbsp;        strafingCoords.add(c);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearStrafingCoords() {
<b class="nc">&nbsp;        strafingCoords.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setMovementEnvelope(Map&lt;Coords, Integer&gt; mvEnvData, int walk,
&nbsp;            int run, int jump, int gear) {
<b class="nc">&nbsp;        clearMovementEnvelope();</b>
&nbsp;
<b class="nc">&nbsp;        if (mvEnvData == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        GUIPreferences guip = GUIPreferences.getInstance();</b>
<b class="nc">&nbsp;        for (Coords loc : mvEnvData.keySet()) {</b>
<b class="nc">&nbsp;            Color spriteColor = null;</b>
<b class="nc">&nbsp;            int mvType = -1;</b>
<b class="nc">&nbsp;            if (gear == MovementDisplay.GEAR_JUMP || gear == MovementDisplay.GEAR_DFA) {</b>
<b class="nc">&nbsp;                if (mvEnvData.get(loc) &lt;= jump) {</b>
<b class="nc">&nbsp;                    spriteColor = guip</b>
<b class="nc">&nbsp;                            .getColor(GUIPreferences.ADVANCED_MOVE_JUMP_COLOR);</b>
<b class="nc">&nbsp;                    mvType = 1;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (mvEnvData.get(loc) &lt;= walk) {</b>
<b class="nc">&nbsp;                    spriteColor = guip</b>
<b class="nc">&nbsp;                            .getColor(GUIPreferences.ADVANCED_MOVE_DEFAULT_COLOR);</b>
<b class="nc">&nbsp;                    mvType = 2;</b>
&nbsp;
<b class="nc">&nbsp;                } else if (mvEnvData.get(loc) &lt;= run) {</b>
<b class="nc">&nbsp;                    spriteColor = guip</b>
<b class="nc">&nbsp;                            .getColor(GUIPreferences.ADVANCED_MOVE_RUN_COLOR);</b>
<b class="nc">&nbsp;                    mvType = 3;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    spriteColor = guip</b>
<b class="nc">&nbsp;                            .getColor(GUIPreferences.ADVANCED_MOVE_SPRINT_COLOR);</b>
<b class="nc">&nbsp;                    mvType = 4;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Next: check the adjacent hexes and find
&nbsp;            // those with the same movement type,
&nbsp;            // send this to the Sprite so it paints only
&nbsp;            // the borders of the movement type areas
&nbsp;            int mvAdjType;
<b class="nc">&nbsp;            int edgesToPaint = 0;</b>
&nbsp;            // cycle through hexes
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                mvAdjType = 0;</b>
<b class="nc">&nbsp;                Coords adjacentHex = loc.translated(dir);</b>
&nbsp;                // get the movement type
<b class="nc">&nbsp;                Integer Adjmv = mvEnvData.get(adjacentHex);</b>
<b class="nc">&nbsp;                if (Adjmv != null) {</b>
<b class="nc">&nbsp;                    if (gear == MovementDisplay.GEAR_JUMP) {</b>
<b class="nc">&nbsp;                        if (Adjmv &lt;= jump) mvAdjType = 1;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (Adjmv &lt;= walk) mvAdjType = 2;</b>
<b class="nc">&nbsp;                        else if (Adjmv &lt;= run) mvAdjType = 3;</b>
<b class="nc">&nbsp;                        else mvAdjType = 4;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // other movement type: paint a border in this direction
<b class="nc">&nbsp;                if (mvAdjType != mvType) edgesToPaint += (1 &lt;&lt; dir);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (spriteColor != null) {</b>
<b class="nc">&nbsp;                MovementEnvelopeSprite mvSprite = new MovementEnvelopeSprite(</b>
&nbsp;                        this, spriteColor, loc, edgesToPaint);
<b class="nc">&nbsp;                moveEnvSprites.add(mvSprite);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        repaint();</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setMovementModifierEnvelope(Collection&lt;MovePath&gt; movePaths) {
<b class="nc">&nbsp;        moveModEnvSprites.clear();</b>
<b class="nc">&nbsp;        for (MovePath mp : movePaths) {</b>
<b class="nc">&nbsp;            moveModEnvSprites.add(new MovementModifierEnvelopeSprite(this, mp));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearMovementEnvelope() {
<b class="nc">&nbsp;        moveEnvSprites.clear();</b>
<b class="nc">&nbsp;        moveModEnvSprites.clear();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the given &lt;code&gt;text&lt;/code&gt; in the currently active font of the Graphics &lt;code&gt;g2D&lt;/code&gt;
&nbsp;     * at font size &lt;code&gt;fontSize&lt;/code&gt;. The text is centered in both
&nbsp;     * x and y directions around the position &lt;code&gt;pos&lt;/code&gt;. The text is colored with
&nbsp;     * the given &lt;code&gt;color&lt;/code&gt;, made translucent if the flag is set. The outline of the text
&nbsp;     * will be dark gray.
&nbsp;     * @param g2D the graphics to draw to, as &lt;code&gt;Graphics2D&lt;/code&gt;
&nbsp;     * @param text the string to write
&nbsp;     * @param pos the board pixel position
&nbsp;     * @param fontSize the font size. This will be scaled by the current board zoom
&nbsp;     * @param color the color to draw the text in
&nbsp;     * @param translucent (optional)  makes the text translucent if set to true. Defaults to false
&nbsp;     * @param cOutline (optional) the color of the outline. Defaults to Color.DARK_GRAY
&nbsp;     */
&nbsp;    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
&nbsp;            float fontSize, Color color, boolean translucent, Color cOutline) {
<b class="nc">&nbsp;        g2D.setFont(g2D.getFont().deriveFont(fontSize));</b>
<b class="nc">&nbsp;        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</b>
&nbsp;        // Center the text around pos
<b class="nc">&nbsp;        int cx = pos.x - (fm.stringWidth(text) / 2);</b>
<b class="nc">&nbsp;        int cy = pos.y + (fm.getAscent() - fm.getDescent()) / 2;</b>
&nbsp;
&nbsp;        // get text shape and position it
<b class="nc">&nbsp;        GlyphVector gv = g2D.getFont().createGlyphVector(g2D.getFontRenderContext(), text);</b>
<b class="nc">&nbsp;        Shape shape = gv.getOutline();</b>
<b class="nc">&nbsp;        shape = AffineTransform.getTranslateInstance(cx,cy).</b>
<b class="nc">&nbsp;                createTransformedShape(shape);</b>
&nbsp;
&nbsp;        // text area fill
<b class="nc">&nbsp;        if (translucent)</b>
<b class="nc">&nbsp;            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</b>
<b class="nc">&nbsp;        g2D.setColor(color);</b>
<b class="nc">&nbsp;        g2D.fill(shape);</b>
&nbsp;
&nbsp;        // outline
<b class="nc">&nbsp;        g2D.setStroke(new BasicStroke(0.5f));</b>
<b class="nc">&nbsp;        Color lineColor = cOutline;</b>
<b class="nc">&nbsp;        if (translucent)</b>
<b class="nc">&nbsp;            lineColor = new Color(lineColor.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</b>
<b class="nc">&nbsp;        g2D.setColor(lineColor);</b>
<b class="nc">&nbsp;        g2D.draw(shape);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
&nbsp;            float fontSize, Color color, boolean translucent) {
<b class="nc">&nbsp;        drawOutlineText(g2D, text, pos, fontSize, color, translucent, Color.DARK_GRAY);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
&nbsp;            float fontSize, Color color) {
<b class="nc">&nbsp;        drawOutlineText(g2D, text, pos, fontSize, color, false, Color.DARK_GRAY);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawTextShadow(Graphics2D g2D, String text, Point pos,
&nbsp;            Font font) {
<b class="nc">&nbsp;        g2D.setFont(font);</b>
&nbsp;        // to keep the shadow always 1 px wide,
&nbsp;        // counteract the current graph scaling
<b class="nc">&nbsp;        double scX = g2D.getTransform().getScaleX();</b>
<b class="nc">&nbsp;        double scY = g2D.getTransform().getScaleY();</b>
&nbsp;
<b class="nc">&nbsp;        drawCenteredText(g2D, text, (float)pos.x+(1.0f)/(float)scX,(float)pos.y, Color.BLACK, false);</b>
<b class="nc">&nbsp;        drawCenteredText(g2D, text, (float)pos.x-(1.0f)/(float)scX,(float)pos.y, Color.BLACK, false);</b>
<b class="nc">&nbsp;        drawCenteredText(g2D, text, (float)pos.x,(float)pos.y+(1.0f)/(float)scY, Color.BLACK, false);</b>
<b class="nc">&nbsp;        drawCenteredText(g2D, text, (float)pos.x,(float)pos.y-(1.0f)/(float)scY, Color.BLACK, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
&nbsp;            Color color, boolean translucent) {
<b class="nc">&nbsp;        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</b>
&nbsp;        // Center the text around pos
<b class="nc">&nbsp;        int cx = pos.x - (fm.stringWidth(text) / 2);</b>
<b class="nc">&nbsp;        int cy = pos.y - fm.getAscent()/2-fm.getDescent() / 2+fm.getAscent();</b>
&nbsp;
<b class="nc">&nbsp;        if (translucent)</b>
<b class="nc">&nbsp;            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</b>
<b class="nc">&nbsp;        g2D.setColor(color);</b>
<b class="nc">&nbsp;        g2D.drawString(text, cx, cy);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // This method is used to draw text shadows even when the g2D is scaled
&nbsp;    public void drawCenteredText(Graphics2D g2D, String text, float posx, float posy,
&nbsp;            Color color, boolean translucent) {
<b class="nc">&nbsp;        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</b>
&nbsp;        // Center the text around pos
<b class="nc">&nbsp;        float cx = posx - (fm.stringWidth(text) / 2);</b>
<b class="nc">&nbsp;        float cy = posy - fm.getAscent()/2-fm.getDescent() / 2+fm.getAscent();</b>
&nbsp;
<b class="nc">&nbsp;        if (translucent)</b>
<b class="nc">&nbsp;            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</b>
<b class="nc">&nbsp;        g2D.setColor(color);</b>
<b class="nc">&nbsp;        g2D.drawString(text, cx, cy);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
&nbsp;            Color color, boolean translucent, Font font) {
<b class="nc">&nbsp;        g2D.setFont(font);</b>
<b class="nc">&nbsp;        drawCenteredText(g2D, text, pos, color, translucent);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
&nbsp;            Color color, boolean translucent, int fontSize) {
<b class="nc">&nbsp;        g2D.setFont(g2D.getFont().deriveFont(fontSize));</b>
<b class="nc">&nbsp;        drawCenteredText(g2D, text, pos, color, translucent);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setLocalPlayer(IPlayer p) {
<b class="nc">&nbsp;        localPlayer = p;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public IPlayer getLocalPlayer() {
<b class="nc">&nbsp;        return localPlayer;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies that this should mark the deployment hexes for a player. If the
&nbsp;     * player is set to null, no hexes will be marked.
&nbsp;     */
&nbsp;    public void markDeploymentHexesFor(Entity ce) {
<b class="nc">&nbsp;        en_Deployer = ce;</b>
<b class="nc">&nbsp;        repaint(100);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity that is currently being deployed
&nbsp;     */
&nbsp;    public Entity getDeployingEntity() {
<b class="nc">&nbsp;        return en_Deployer;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * add a fly over path to the sprite list
&nbsp;     */
&nbsp;    public void addFlyOverPath(Entity e) {
<b class="nc">&nbsp;        if (e.getPosition() == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (e.isMakingVTOLGroundAttack()) {</b>
<b class="nc">&nbsp;            vtolAttackSprites.add(new VTOLAttackSprite(this, e));</b>
&nbsp;        }
<b class="nc">&nbsp;        flyOverSprites.add(new FlyOverSprite(this, e));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public List&lt;Entity&gt; getEntitiesFlyingOver(Coords c) {
<b class="nc">&nbsp;        List&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for (FlyOverSprite fsprite : flyOverSprites) {</b>
&nbsp;            //Spaceborne units shouldn&#39;t count here. They show up incorrectly in the firing display when sensors are in use.
<b class="nc">&nbsp;            if (fsprite.getEntity().getPassedThrough().contains(c) &amp;&amp; !fsprite.getEntity().isSpaceborne()) {</b>
<b class="nc">&nbsp;                entities.add(fsprite.getEntity());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return entities;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a c3 line to the sprite list.
&nbsp;     */
&nbsp;    public void addC3Link(Entity e) {
<b class="nc">&nbsp;        if (e.getPosition() == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (e.hasC3i()) {</b>
<b class="nc">&nbsp;            for (Entity fe : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (fe.getPosition() == null) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (e.onSameC3NetworkAs(fe)</b>
<b class="nc">&nbsp;                        &amp;&amp; !fe.equals(e)</b>
<b class="nc">&nbsp;                        &amp;&amp; !ComputeECM.isAffectedByECM(e, e.getPosition(),</b>
<b class="nc">&nbsp;                                fe.getPosition())) {</b>
<b class="nc">&nbsp;                    c3Sprites.add(new C3Sprite(this, e, fe));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (e.hasNavalC3()) {</b>
<b class="nc">&nbsp;            for (Entity fe : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (fe.getPosition() == null) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (e.onSameC3NetworkAs(fe) &amp;&amp; !fe.equals(e)) {</b>
<b class="nc">&nbsp;                    c3Sprites.add(new C3Sprite(this, e, fe));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (e.hasActiveNovaCEWS()) {</b>
&nbsp;            // WOR Nova CEWS
<b class="nc">&nbsp;            for (Entity fe : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (fe.getPosition() == null) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                ECMInfo ecmInfo = ComputeECM.getECMEffects(e, e.getPosition(),</b>
<b class="nc">&nbsp;                        fe.getPosition(), true, null);</b>
<b class="nc">&nbsp;                if (e.onSameC3NetworkAs(fe)</b>
<b class="nc">&nbsp;                    &amp;&amp; !fe.equals(e)</b>
&nbsp;                    &amp;&amp; (ecmInfo != null)
<b class="nc">&nbsp;                    &amp;&amp; !ecmInfo.isNovaECM()) {</b>
<b class="nc">&nbsp;                    c3Sprites.add(new C3Sprite(this, e, fe));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (e.getC3Master() != null) {</b>
<b class="nc">&nbsp;            Entity eMaster = e.getC3Master();</b>
<b class="nc">&nbsp;            if (eMaster.getPosition() == null) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // ECM cuts off the network
<b class="nc">&nbsp;            boolean blocked = false;</b>
<b class="nc">&nbsp;            if (e.hasBoostedC3() &amp;&amp; eMaster.hasBoostedC3()) {</b>
<b class="nc">&nbsp;                blocked = ComputeECM.isAffectedByAngelECM(e, e.getPosition(),</b>
<b class="nc">&nbsp;                        eMaster.getPosition())</b>
<b class="nc">&nbsp;                        || ComputeECM.isAffectedByAngelECM(eMaster,</b>
<b class="nc">&nbsp;                                eMaster.getPosition(), eMaster.getPosition());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                blocked = ComputeECM.isAffectedByECM(e, e.getPosition(),</b>
<b class="nc">&nbsp;                        eMaster.getPosition())</b>
<b class="nc">&nbsp;                        || ComputeECM.isAffectedByECM(eMaster,</b>
<b class="nc">&nbsp;                                eMaster.getPosition(), eMaster.getPosition());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!blocked) {</b>
<b class="nc">&nbsp;                c3Sprites.add(new C3Sprite(this, e, e.getC3Master()));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an attack to the sprite list.
&nbsp;     */
&nbsp;    public synchronized void addAttack(AttackAction aa) {
&nbsp;        // Don&#39;t make sprites for unknown entities and sensor returns
<b class="nc">&nbsp;        Entity ae = game.getEntity(aa.getEntityId());</b>
<b class="nc">&nbsp;        Targetable t = game.getTarget(aa.getTargetType(), aa.getTargetId());</b>
<b class="nc">&nbsp;        if ((ae == null) || (t == null)</b>
<b class="nc">&nbsp;            || (t.getTargetType() == Targetable.TYPE_INARC_POD)</b>
<b class="nc">&nbsp;            || (t.getPosition() == null) || (ae.getPosition() == null)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(ae.getId(),</b>
<b class="nc">&nbsp;                ae.getSecondaryPositions().size() &gt; 0 ? 0 : -1));</b>
<b class="nc">&nbsp;        if (eSprite != null &amp;&amp; eSprite.onlyDetectedBySensors()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        repaint(100);</b>
<b class="nc">&nbsp;        for (AttackSprite sprite : attackSprites) {</b>
&nbsp;            // can we just add this attack to an existing one?
<b class="nc">&nbsp;            if ((sprite.getEntityId() == aa.getEntityId())</b>
<b class="nc">&nbsp;                &amp;&amp; (sprite.getTargetId() == aa.getTargetId())) {</b>
&nbsp;                // use existing attack, but add this weapon
<b class="nc">&nbsp;                if (aa instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                    WeaponAttackAction waa = (WeaponAttackAction) aa;</b>
<b class="nc">&nbsp;                    if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;                        sprite.addWeapon(waa);</b>
<b class="nc">&nbsp;                    } else if (waa.getEntity(game).getOwner().getId() == localPlayer</b>
<b class="nc">&nbsp;                            .getId()) {</b>
<b class="nc">&nbsp;                        sprite.addWeapon(waa);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof KickAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((KickAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof PunchAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((PunchAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof PushAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((PushAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof ClubAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((ClubAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof ChargeAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((ChargeAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof DfaAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((DfaAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof ProtomechPhysicalAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((ProtomechPhysicalAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aa instanceof SearchlightAttackAction) {</b>
<b class="nc">&nbsp;                    sprite.addWeapon((SearchlightAttackAction) aa);</b>
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // no re-use possible, add a new one
&nbsp;        // don&#39;t add a sprite for an artillery attack made by the other player
<b class="nc">&nbsp;        if (aa instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;            WeaponAttackAction waa = (WeaponAttackAction) aa;</b>
<b class="nc">&nbsp;            if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;                attackSprites.add(new AttackSprite(this, aa));</b>
<b class="nc">&nbsp;            } else if (waa.getEntity(game).getOwner().getId() == localPlayer</b>
<b class="nc">&nbsp;                    .getId()) {</b>
<b class="nc">&nbsp;                attackSprites.add(new AttackSprite(this, aa));</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            attackSprites.add(new AttackSprite(this, aa));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all attack sprites from a certain entity
&nbsp;     */
&nbsp;    public synchronized void removeAttacksFor(Entity e) {
<b class="nc">&nbsp;        if (e == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        int entityId = e.getId();</b>
<b class="nc">&nbsp;        for (Iterator&lt;AttackSprite&gt; i = attackSprites.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            AttackSprite sprite = i.next();</b>
<b class="nc">&nbsp;            if (sprite.getEntityId() == entityId) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        repaint(100);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clears out all attacks and re-adds the ones in the current game.
&nbsp;     */
&nbsp;    public void refreshAttacks() {
<b class="nc">&nbsp;        clearAllAttacks();</b>
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;            if (ea instanceof AttackAction) {</b>
<b class="nc">&nbsp;                addAttack((AttackAction) ea);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Enumeration&lt;AttackAction&gt; i = game.getCharges(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;            if (ea instanceof PhysicalAttackAction) {</b>
<b class="nc">&nbsp;                addAttack((AttackAction) ea);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        repaint(100);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void refreshMoveVectors() {
<b class="nc">&nbsp;        clearAllMoveVectors();</b>
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.getPosition() != null) {</b>
<b class="nc">&nbsp;                movementSprites.add(new MovementSprite(this, e, e.getVectors(),</b>
&nbsp;                                                       Color.gray, false));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void refreshMoveVectors(Entity en, MovePath md, Color col) {
<b class="nc">&nbsp;        clearAllMoveVectors();</b>
&nbsp;        // same as normal but when I find the active entity I used the MovePath
&nbsp;        // to get vector
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.getPosition() != null) {</b>
<b class="nc">&nbsp;                if ((en != null) &amp;&amp; (e.getId() == en.getId())) {</b>
<b class="nc">&nbsp;                    movementSprites.add(new MovementSprite(this, e, md</b>
<b class="nc">&nbsp;                            .getFinalVectors(), col, true));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementSprites.add(new MovementSprite(this, e, e.getVectors(),</b>
&nbsp;                                                           col, false));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearC3Networks() {
<b class="nc">&nbsp;        c3Sprites.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearFlyOverPaths() {
<b class="nc">&nbsp;        vtolAttackSprites.clear();</b>
<b class="nc">&nbsp;        flyOverSprites.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clears out all attacks that were being drawn
&nbsp;     */
&nbsp;    public void clearAllAttacks() {
<b class="nc">&nbsp;        attackSprites.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clears out all movement vectors that were being drawn
&nbsp;     */
&nbsp;    public void clearAllMoveVectors() {
<b class="nc">&nbsp;        movementSprites.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void firstLOSHex(Coords c) {
<b class="nc">&nbsp;        if (useLOSTool) {</b>
<b class="nc">&nbsp;            moveCursor(secondLOSSprite, null);</b>
<b class="nc">&nbsp;            moveCursor(firstLOSSprite, c);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void secondLOSHex(Coords c2, Coords c1) {
<b class="nc">&nbsp;        if (useLOSTool) {</b>
&nbsp;
<b class="nc">&nbsp;            Entity ae = chooseEntity(c1);</b>
<b class="nc">&nbsp;            Entity te = chooseEntity(c2);</b>
&nbsp;
<b class="nc">&nbsp;            StringBuffer message = new StringBuffer();</b>
&nbsp;            LosEffects le;
<b class="nc">&nbsp;            if ((ae == null) || (te == null)) {</b>
<b class="nc">&nbsp;                boolean mechInFirst = GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                                                    .getMechInFirst();</b>
<b class="nc">&nbsp;                boolean mechInSecond = GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                                                     .getMechInSecond();</b>
<b class="nc">&nbsp;                LosEffects.AttackInfo ai = new LosEffects.AttackInfo();</b>
<b class="nc">&nbsp;                ai.attackPos = c1;</b>
<b class="nc">&nbsp;                ai.targetPos = c2;</b>
<b class="nc">&nbsp;                ai.attackHeight = mechInFirst ? 1 : 0;</b>
<b class="nc">&nbsp;                ai.targetHeight = mechInSecond ? 1 : 0;</b>
<b class="nc">&nbsp;                ai.targetIsMech = mechInSecond;</b>
<b class="nc">&nbsp;                ai.attackerIsMech = mechInFirst;</b>
<b class="nc">&nbsp;                ai.attackAbsHeight = game.getBoard().getHex(c1).floor()</b>
&nbsp;                                     + ai.attackHeight;
<b class="nc">&nbsp;                ai.targetAbsHeight = game.getBoard().getHex(c2).floor()</b>
&nbsp;                                     + ai.targetHeight;
<b class="nc">&nbsp;                le = LosEffects.calculateLos(game, ai);</b>
<b class="nc">&nbsp;                message.append(Messages</b>
<b class="nc">&nbsp;                                       .getString(</b>
&nbsp;                                               &quot;BoardView1.Attacker&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                                    mechInFirst ? Messages</b>
<b class="nc">&nbsp;                                                                                            .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</b>
<b class="nc">&nbsp;                                                                                    c1.getBoardNum()}));</b>
<b class="nc">&nbsp;                message.append(Messages</b>
<b class="nc">&nbsp;                                       .getString(</b>
&nbsp;                                               &quot;BoardView1.Target&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                                  mechInSecond ? Messages</b>
<b class="nc">&nbsp;                                                                                          .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</b>
<b class="nc">&nbsp;                                                                                  c2.getBoardNum()}));</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                le = LosEffects.calculateLos(game, ae.getId(), te);</b>
<b class="nc">&nbsp;                message.append(Messages.getString(</b>
&nbsp;                        &quot;BoardView1.Attacker&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                             ae.getDisplayName(), c1.getBoardNum()}));</b>
<b class="nc">&nbsp;                message.append(Messages.getString(</b>
&nbsp;                        &quot;BoardView1.Target&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                           te.getDisplayName(), c2.getBoardNum()}));</b>
&nbsp;            }
&nbsp;            // Check to see if LoS is blocked
<b class="nc">&nbsp;            if (!le.canSee()) {</b>
<b class="nc">&nbsp;                message.append(Messages.getString(&quot;BoardView1.LOSBlocked&quot;,</b>
&nbsp;                                                  new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                Integer.valueOf(c1.distance(c2))}));</b>
<b class="nc">&nbsp;                ToHitData thd = le.losModifiers(game);</b>
<b class="nc">&nbsp;                message.append(&quot;\t&quot; + thd.getDesc() + &quot;\n&quot;);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                message.append(Messages.getString(&quot;BoardView1.LOSNotBlocked&quot;,</b>
&nbsp;                                                  new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                Integer.valueOf(c1.distance(c2))}));</b>
<b class="nc">&nbsp;                if (le.getHeavyWoods() &gt; 0) {</b>
<b class="nc">&nbsp;                    message.append(Messages.getString(</b>
&nbsp;                            &quot;BoardView1.HeavyWoods&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                   Integer.valueOf(le.getHeavyWoods())}));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (le.getLightWoods() &gt; 0) {</b>
<b class="nc">&nbsp;                    message.append(Messages.getString(</b>
&nbsp;                            &quot;BoardView1.LightWoods&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                   Integer.valueOf(le.getLightWoods())}));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (le.getLightSmoke() &gt; 0) {</b>
<b class="nc">&nbsp;                    message.append(Messages.getString(</b>
&nbsp;                            &quot;BoardView1.LightSmoke&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                   Integer.valueOf(le.getLightSmoke())}));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (le.getHeavySmoke() &gt; 0) {</b>
<b class="nc">&nbsp;                    message.append(Messages.getString(</b>
&nbsp;                            &quot;BoardView1.HeavySmoke&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                   Integer.valueOf(le.getHeavySmoke())}));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (le.isTargetCover() &amp;&amp; le.canSee()) {</b>
<b class="nc">&nbsp;                    message.append(Messages</b>
<b class="nc">&nbsp;                                           .getString(</b>
&nbsp;                                                   &quot;BoardView1.TargetPartialCover&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                                                  LosEffects.getCoverName(</b>
<b class="nc">&nbsp;                                                                                                          le.getTargetCover(), true)}));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (le.isAttackerCover() &amp;&amp; le.canSee()) {</b>
<b class="nc">&nbsp;                    message.append(Messages.getString(</b>
&nbsp;                            &quot;BoardView1.AttackerPartialCover&quot;, new Object[]{ //$NON-NLS-1$
<b class="nc">&nbsp;                                                                             LosEffects.getCoverName(le.getAttackerCover(),</b>
&nbsp;                                                                                                     false)}));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            JOptionPane.showMessageDialog(getRootPane(), message.toString(),</b>
<b class="nc">&nbsp;                                          Messages.getString(&quot;BoardView1.LOSTitle&quot;),</b>
&nbsp;                                          JOptionPane.INFORMATION_MESSAGE);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes the various overlay polygons with their vertices.
&nbsp;     */
&nbsp;    public void initPolys() {
&nbsp;
<b class="nc">&nbsp;        AffineTransform facingRotate = new AffineTransform();</b>
&nbsp;
&nbsp;        // facing polygons
<b class="nc">&nbsp;        Polygon facingPolyTmp = new Polygon();</b>
<b class="nc">&nbsp;        facingPolyTmp.addPoint(41, 3);</b>
<b class="nc">&nbsp;        facingPolyTmp.addPoint(35, 9);</b>
<b class="nc">&nbsp;        facingPolyTmp.addPoint(41, 7);</b>
<b class="nc">&nbsp;        facingPolyTmp.addPoint(42, 7);</b>
<b class="nc">&nbsp;        facingPolyTmp.addPoint(48, 9);</b>
<b class="nc">&nbsp;        facingPolyTmp.addPoint(42, 3);</b>
&nbsp;
&nbsp;        // create the rotated shapes
<b class="nc">&nbsp;        facingPolys = new Shape[8];</b>
<b class="nc">&nbsp;        for (int dir : allDirections) {</b>
<b class="nc">&nbsp;            facingPolys[dir] = facingRotate.createTransformedShape(facingPolyTmp);</b>
<b class="nc">&nbsp;            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</b>
&nbsp;        }
&nbsp;
&nbsp;        // final facing polygons
<b class="nc">&nbsp;        Polygon finalFacingPolyTmp = new Polygon();</b>
<b class="nc">&nbsp;        finalFacingPolyTmp.addPoint(41, 3);</b>
<b class="nc">&nbsp;        finalFacingPolyTmp.addPoint(21, 18);</b>
<b class="nc">&nbsp;        finalFacingPolyTmp.addPoint(41, 14);</b>
<b class="nc">&nbsp;        finalFacingPolyTmp.addPoint(42, 14);</b>
<b class="nc">&nbsp;        finalFacingPolyTmp.addPoint(61, 18);</b>
<b class="nc">&nbsp;        finalFacingPolyTmp.addPoint(42, 3);</b>
&nbsp;
&nbsp;        // create the rotated shapes
<b class="nc">&nbsp;        facingRotate.setToIdentity();</b>
<b class="nc">&nbsp;        finalFacingPolys = new Shape[8];</b>
<b class="nc">&nbsp;        for (int dir : allDirections) {</b>
<b class="nc">&nbsp;            finalFacingPolys[dir] = facingRotate.createTransformedShape(finalFacingPolyTmp);</b>
<b class="nc">&nbsp;            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</b>
&nbsp;        }
&nbsp;
&nbsp;        // movement polygons
<b class="nc">&nbsp;        Polygon movementPolyTmp = new Polygon();</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(47, 67);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(48, 66);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(42, 62);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(41, 62);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(35, 66);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(36, 67);</b>
&nbsp;
<b class="nc">&nbsp;        movementPolyTmp.addPoint(47, 67);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(45, 68);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(38, 68);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(38, 69);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(45, 69);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(45, 68);</b>
&nbsp;
<b class="nc">&nbsp;        movementPolyTmp.addPoint(45, 70);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(38, 70);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(38, 71);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(45, 71);</b>
<b class="nc">&nbsp;        movementPolyTmp.addPoint(45, 68);</b>
&nbsp;
&nbsp;        // create the rotated shapes
<b class="nc">&nbsp;        facingRotate.setToIdentity();</b>
<b class="nc">&nbsp;        movementPolys = new Shape[8];</b>
<b class="nc">&nbsp;        for (int dir : allDirections) {</b>
<b class="nc">&nbsp;            movementPolys[dir] = facingRotate.createTransformedShape(movementPolyTmp);</b>
<b class="nc">&nbsp;            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Up and Down Arrows
<b class="nc">&nbsp;        facingRotate.setToIdentity();</b>
<b class="nc">&nbsp;        facingRotate.translate(0, -31);</b>
<b class="nc">&nbsp;        upArrow = facingRotate.createTransformedShape(movementPolyTmp);</b>
&nbsp;
<b class="nc">&nbsp;        facingRotate.setToIdentity();</b>
<b class="nc">&nbsp;        facingRotate.rotate(Math.toRadians(180), HEX_W / 2, HEX_H / 2);</b>
<b class="nc">&nbsp;        facingRotate.translate(0, -31);</b>
<b class="nc">&nbsp;        downArrow = facingRotate.createTransformedShape(movementPolyTmp);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    synchronized boolean doMoveUnits(long idleTime) {
<b class="nc">&nbsp;        boolean movingSomething = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (movingUnits.size() &gt; 0) {</b>
<b class="nc">&nbsp;            moveWait += idleTime;</b>
&nbsp;
<b class="nc">&nbsp;            if (moveWait &gt; GUIPreferences.getInstance().getInt(</b>
&nbsp;                    &quot;AdvancedMoveStepDelay&quot;)) {
&nbsp;
<b class="nc">&nbsp;                ArrayList&lt;MovingUnit&gt; spent = new ArrayList&lt;MovingUnit&gt;();</b>
&nbsp;
<b class="nc">&nbsp;                for (MovingUnit move : movingUnits) {</b>
<b class="nc">&nbsp;                    movingSomething = true;</b>
<b class="nc">&nbsp;                    Entity ge = game.getEntity(move.entity.getId());</b>
<b class="nc">&nbsp;                    if (move.path.size() &gt; 0) {</b>
&nbsp;
<b class="nc">&nbsp;                        UnitLocation loc = move.path.get(0);</b>
&nbsp;
<b class="nc">&nbsp;                        if (ge != null) {</b>
<b class="nc">&nbsp;                            redrawMovingEntity(move.entity, loc.getCoords(),</b>
<b class="nc">&nbsp;                                    loc.getFacing(), loc.getElevation());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        move.path.remove(0);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        if (ge != null) {</b>
<b class="nc">&nbsp;                            redrawEntity(ge);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        spent.add(move);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                for (MovingUnit move : spent) {</b>
<b class="nc">&nbsp;                    movingUnits.remove(move);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                moveWait = 0;</b>
&nbsp;
<b class="nc">&nbsp;                if (movingUnits.size() == 0) {</b>
<b class="nc">&nbsp;                    movingEntitySpriteIds.clear();</b>
<b class="nc">&nbsp;                    movingEntitySprites.clear();</b>
<b class="nc">&nbsp;                    ghostEntitySprites.clear();</b>
<b class="nc">&nbsp;                    processBoardViewEvent(new BoardViewEvent(this,</b>
&nbsp;                            BoardViewEvent.FINISHED_MOVING_UNITS));
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return movingSomething;</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // MouseListener
&nbsp;    //
&nbsp;    public void mousePressed(MouseEvent me) {
<b class="nc">&nbsp;        requestFocusInWindow();</b>
<b class="nc">&nbsp;        stopSoftCentering();</b>
<b class="nc">&nbsp;        Point point = me.getPoint();</b>
<b class="nc">&nbsp;        if (null == point) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Button 4: Hide/Show the minimap and unitDisplay
<b class="nc">&nbsp;        if (me.getButton() == 4) {</b>
<b class="nc">&nbsp;            if (clientgui != null) clientgui.toggleMMUDDisplays();</b>
&nbsp;        }
&nbsp;
&nbsp;        // we clicked the right mouse button,
&nbsp;        // remember the position if we start to scroll
&nbsp;        // if we drag, we should scroll
<b class="nc">&nbsp;        if (SwingUtilities.isRightMouseButton(me)) {</b>
<b class="nc">&nbsp;            scrollXDifference = me.getX();</b>
<b class="nc">&nbsp;            scrollYDifference = me.getY();</b>
<b class="nc">&nbsp;            shouldScroll = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (me.isPopupTrigger() &amp;&amp; !dragging) {</b>
<b class="nc">&nbsp;            mouseAction(getCoordsAt(point), BOARD_HEX_POPUP, me.getModifiers());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; displayables.size(); i++) {</b>
<b class="nc">&nbsp;            IDisplayable disp = displayables.get(i);</b>
<b class="nc">&nbsp;            double width = scrollpane.getViewport().getSize()</b>
<b class="nc">&nbsp;                                     .getWidth();</b>
<b class="nc">&nbsp;            double height = scrollpane.getViewport().getSize()</b>
<b class="nc">&nbsp;                                      .getHeight();</b>
<b class="nc">&nbsp;            Dimension dispDimension = new Dimension();</b>
<b class="nc">&nbsp;            dispDimension.setSize(width, height);</b>
&nbsp;            // we need to adjust the point, because it should be against the
&nbsp;            // displayable dimension
<b class="nc">&nbsp;            Point dispPoint = new Point();</b>
<b class="nc">&nbsp;            dispPoint.setLocation(point.x + getBounds().x, point.y</b>
<b class="nc">&nbsp;                                                           + getBounds().y);</b>
<b class="nc">&nbsp;            if (disp.isHit(dispPoint, dispDimension)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void mouseReleased(MouseEvent me) {
&nbsp;        // don&#39;t show the popup if we are drag-scrolling
<b class="nc">&nbsp;        if (me.isPopupTrigger() &amp;&amp; !dragging) {</b>
<b class="nc">&nbsp;            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_POPUP,</b>
<b class="nc">&nbsp;                        me.getModifiers());</b>
&nbsp;            // stop scrolling
<b class="nc">&nbsp;            shouldScroll = false;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we released the right mouse button, there&#39;s no more
&nbsp;        // scrolling
<b class="nc">&nbsp;        if (SwingUtilities.isRightMouseButton(me)) {</b>
<b class="nc">&nbsp;            scrollXDifference = 0;</b>
<b class="nc">&nbsp;            scrollYDifference = 0;</b>
<b class="nc">&nbsp;            dragging = false;</b>
<b class="nc">&nbsp;            shouldScroll = false;</b>
<b class="nc">&nbsp;            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; displayables.size(); i++) {</b>
<b class="nc">&nbsp;            IDisplayable disp = displayables.get(i);</b>
<b class="nc">&nbsp;            if (disp.isReleased()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (me.getClickCount() == 1) {</b>
<b class="nc">&nbsp;            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_CLICK,</b>
<b class="nc">&nbsp;                        me.getModifiers());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_DOUBLECLICK,</b>
<b class="nc">&nbsp;                        me.getModifiers());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void mouseEntered(MouseEvent me) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void mouseExited(MouseEvent me) {
&nbsp;        // Reset the tooltip dismissal delay to the preference
&nbsp;        // value so that elements outside the boardview can
&nbsp;        // use tooltips
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</b>
<b class="nc">&nbsp;            ToolTipManager.sharedInstance().setDismissDelay(</b>
<b class="nc">&nbsp;                    GUIPreferences.getInstance().getTooltipDismissDelay());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void mouseClicked(MouseEvent me) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private class MovingUnit {
&nbsp;        public Entity entity;
&nbsp;
&nbsp;        public ArrayList&lt;UnitLocation&gt; path;
&nbsp;
<b class="nc">&nbsp;        MovingUnit(Entity entity, Vector&lt;UnitLocation&gt; path) {</b>
<b class="nc">&nbsp;            this.entity = entity;</b>
<b class="nc">&nbsp;            this.path = new ArrayList&lt;UnitLocation&gt;(path);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the tile manager&#39;s images have been loaded.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if all images have been loaded.
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if more need to be loaded.
&nbsp;     */
&nbsp;    public boolean isTileImagesLoaded() {
<b class="nc">&nbsp;        return tileManager.isLoaded();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUseLOSTool(boolean use) {
<b class="nc">&nbsp;        useLOSTool = use;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public TilesetManager getTilesetManager() {
<b class="nc">&nbsp;        return tileManager;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param lastCursor The lastCursor to set.
&nbsp;     */
&nbsp;    public void setLastCursor(Coords lastCursor) {
<b class="nc">&nbsp;        this.lastCursor = lastCursor;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return Returns the lastCursor.
&nbsp;     */
&nbsp;    public Coords getLastCursor() {
<b class="nc">&nbsp;        return lastCursor;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param highlighted The highlighted to set.
&nbsp;     */
&nbsp;    public void setHighlighted(Coords highlighted) {
<b class="nc">&nbsp;        this.highlighted = highlighted;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return Returns the highlighted.
&nbsp;     */
&nbsp;    public Coords getHighlighted() {
<b class="nc">&nbsp;        return highlighted;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param selected The selected to set.
&nbsp;     */
&nbsp;    public void setSelected(Coords selected) {
<b class="nc">&nbsp;        if (this.selected != selected) {</b>
<b class="nc">&nbsp;            this.selected = selected;</b>
<b class="nc">&nbsp;            checkFoVHexImageCacheClear();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return Returns the selected.
&nbsp;     */
&nbsp;    public Coords getSelected() {
<b class="nc">&nbsp;        return selected;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param firstLOS The firstLOS to set.
&nbsp;     */
&nbsp;    public void setFirstLOS(Coords firstLOS) {
<b class="nc">&nbsp;        this.firstLOS = firstLOS;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return Returns the firstLOS.
&nbsp;     */
&nbsp;    public Coords getFirstLOS() {
<b class="nc">&nbsp;        return firstLOS;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Board contains the Coords, and if so, &quot;selects&quot; that
&nbsp;     * Coords.
&nbsp;     *
&nbsp;     * @param coords the Coords.
&nbsp;     */
&nbsp;    public void select(Coords coords) {
<b class="nc">&nbsp;        if ((coords == null) || game.getBoard().contains(coords)) {</b>
<b class="nc">&nbsp;            setSelected(coords);</b>
<b class="nc">&nbsp;            moveCursor(selectedSprite, coords);</b>
<b class="nc">&nbsp;            moveCursor(firstLOSSprite, null);</b>
<b class="nc">&nbsp;            moveCursor(secondLOSSprite, null);</b>
<b class="nc">&nbsp;            processBoardViewEvent(new BoardViewEvent(this, coords, null,</b>
&nbsp;                                                     BoardViewEvent.BOARD_HEX_SELECTED, 0));
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * &quot;Selects&quot; the specified Coords.
&nbsp;     *
&nbsp;     * @param x the x coordinate.
&nbsp;     * @param y the y coordinate.
&nbsp;     */
&nbsp;    public void select(int x, int y) {
<b class="nc">&nbsp;        select(new Coords(x, y));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Board contains the Coords, and if so, highlights that
&nbsp;     * Coords.
&nbsp;     *
&nbsp;     * @param coords the Coords.
&nbsp;     */
&nbsp;    public void highlight(Coords coords) {
<b class="nc">&nbsp;        if ((coords == null) || game.getBoard().contains(coords)) {</b>
<b class="nc">&nbsp;            setHighlighted(coords);</b>
<b class="nc">&nbsp;            moveCursor(highlightSprite, coords);</b>
<b class="nc">&nbsp;            moveCursor(firstLOSSprite, null);</b>
<b class="nc">&nbsp;            moveCursor(secondLOSSprite, null);</b>
<b class="nc">&nbsp;            processBoardViewEvent(new BoardViewEvent(this, coords, null,</b>
&nbsp;                                                     BoardViewEvent.BOARD_HEX_HIGHLIGHTED, 0));
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setHighlightColor(Color c) {
<b class="nc">&nbsp;        highlightSprite.setColor(c);</b>
<b class="nc">&nbsp;        highlightSprite.prepare();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Highlights the specified Coords.
&nbsp;     *
&nbsp;     * @param x the x coordinate.
&nbsp;     * @param y the y coordinate.
&nbsp;     */
&nbsp;    public void highlight(int x, int y) {
<b class="nc">&nbsp;        highlight(new Coords(x, y));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public synchronized void highlightSelectedEntity() {
<b class="nc">&nbsp;        for (EntitySprite sprite: entitySprites) {</b>
<b class="nc">&nbsp;            if (sprite.entity.equals(selectedEntity)) {</b>
<b class="nc">&nbsp;                sprite.setSelected(true);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sprite.setSelected(false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Board contains the Coords, and if so, &quot;cursors&quot; that
&nbsp;     * Coords.
&nbsp;     *
&nbsp;     * @param coords the Coords.
&nbsp;     */
&nbsp;    public void cursor(Coords coords) {
<b class="nc">&nbsp;        if ((coords == null) || game.getBoard().contains(coords)) {</b>
<b class="nc">&nbsp;            if ((getLastCursor() == null) || (coords == null)</b>
<b class="nc">&nbsp;                || !coords.equals(getLastCursor())) {</b>
<b class="nc">&nbsp;                setLastCursor(coords);</b>
<b class="nc">&nbsp;                moveCursor(cursorSprite, coords);</b>
<b class="nc">&nbsp;                moveCursor(firstLOSSprite, null);</b>
<b class="nc">&nbsp;                moveCursor(secondLOSSprite, null);</b>
<b class="nc">&nbsp;                processBoardViewEvent(new BoardViewEvent(this, coords, null,</b>
&nbsp;                                                         BoardViewEvent.BOARD_HEX_CURSOR, 0));
&nbsp;            } else {
<b class="nc">&nbsp;                setLastCursor(coords);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * &quot;Cursors&quot; the specified Coords.
&nbsp;     *
&nbsp;     * @param x the x coordinate.
&nbsp;     * @param y the y coordinate.
&nbsp;     */
&nbsp;    public void cursor(int x, int y) {
<b class="nc">&nbsp;        cursor(new Coords(x, y));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void checkLOS(Coords c) {
<b class="nc">&nbsp;        if ((c == null) || game.getBoard().contains(c)) {</b>
<b class="nc">&nbsp;            if (getFirstLOS() == null) {</b>
<b class="nc">&nbsp;                setFirstLOS(c);</b>
<b class="nc">&nbsp;                firstLOSHex(c);</b>
<b class="nc">&nbsp;                processBoardViewEvent(new BoardViewEvent(this, c, null,</b>
&nbsp;                                                         BoardViewEvent.BOARD_FIRST_LOS_HEX, 0));
&nbsp;            } else {
<b class="nc">&nbsp;                secondLOSHex(c, getFirstLOS());</b>
<b class="nc">&nbsp;                processBoardViewEvent(new BoardViewEvent(this, c, null,</b>
&nbsp;                                                         BoardViewEvent.BOARD_SECOND_LOS_HEX, 0));
<b class="nc">&nbsp;                setFirstLOS(null);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Board contains the (x, y) Coords, and if so, notifies
&nbsp;     * listeners about the specified mouse action.
&nbsp;     */
&nbsp;    public void mouseAction(int x, int y, int mtype, int modifiers) {
<b class="nc">&nbsp;        if (game.getBoard().contains(x, y)) {</b>
<b class="nc">&nbsp;            Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;            switch (mtype) {</b>
&nbsp;                case BOARD_HEX_CLICK:
<b class="nc">&nbsp;                    if ((modifiers &amp; java.awt.event.InputEvent.CTRL_MASK) != 0) {</b>
<b class="nc">&nbsp;                        checkLOS(c);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        processBoardViewEvent(new BoardViewEvent(this, c, null,</b>
&nbsp;                                BoardViewEvent.BOARD_HEX_CLICKED, modifiers));
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BOARD_HEX_DOUBLECLICK:
<b class="nc">&nbsp;                    processBoardViewEvent(new BoardViewEvent(this, c, null,</b>
&nbsp;                            BoardViewEvent.BOARD_HEX_DOUBLECLICKED, modifiers));
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BOARD_HEX_DRAG:
<b class="nc">&nbsp;                    processBoardViewEvent(new BoardViewEvent(this, c, null,</b>
&nbsp;                            BoardViewEvent.BOARD_HEX_DRAGGED, modifiers));
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case BOARD_HEX_POPUP:
<b class="nc">&nbsp;                    processBoardViewEvent(new BoardViewEvent(this, c, null,</b>
&nbsp;                            BoardViewEvent.BOARD_HEX_POPUP, modifiers));
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Notifies listeners about the specified mouse action.
&nbsp;     *
&nbsp;     * @param coords the Coords.
&nbsp;     */
&nbsp;    public void mouseAction(Coords coords, int mtype, int modifiers) {
<b class="nc">&nbsp;        mouseAction(coords.getX(), coords.getY(), mtype, modifiers);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     *
&nbsp;     * @see
&nbsp;     * megamek.common.BoardListener#boardNewBoard(megamek.common.BoardEvent)
&nbsp;     */
&nbsp;    public void boardNewBoard(BoardEvent b) {
<b class="nc">&nbsp;        updateBoard();</b>
<b class="nc">&nbsp;        clearHexImageCache();</b>
<b class="nc">&nbsp;        clearShadowMap();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     *
&nbsp;     * @see
&nbsp;     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
&nbsp;     */
&nbsp;    public void boardChangedHex(BoardEvent b) {
<b class="nc">&nbsp;        hexImageCache.remove(b.getCoords());</b>
&nbsp;        // Also repaint the surrounding hexes because of shadows, border etc.
<b class="nc">&nbsp;        for (int dir: allDirections) { </b>
<b class="nc">&nbsp;            hexImageCache.remove(b.getCoords().translated(dir));</b>
&nbsp;        }
<b class="nc">&nbsp;        clearShadowMap();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     *
&nbsp;     * @see
&nbsp;     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
&nbsp;     */
&nbsp;    public synchronized void boardChangedAllHexes(BoardEvent b) {
<b class="nc">&nbsp;        clearHexImageCache();</b>
<b class="nc">&nbsp;        clearShadowMap();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    private GameListener gameListener = new GameListenerAdapter() {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameEntityNew(GameEntityNewEvent e) {
<b class="nc">&nbsp;            updateEcmList();</b>
<b class="nc">&nbsp;            redrawAllEntities();</b>
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;                refreshMoveVectors();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameEntityRemove(GameEntityRemoveEvent e) {
<b class="nc">&nbsp;            updateEcmList();</b>
<b class="nc">&nbsp;            redrawAllEntities();</b>
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;                refreshMoveVectors();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameEntityChange(GameEntityChangeEvent e) {
<b class="nc">&nbsp;            final Vector&lt;UnitLocation&gt; mp = e.getMovePath();</b>
<b class="nc">&nbsp;            final Entity en = e.getEntity();</b>
<b class="nc">&nbsp;            final GameOptions gopts = game.getOptions();</b>
<b class="nc">&nbsp;            GUIPreferences guip = GUIPreferences.getInstance();</b>
&nbsp;
<b class="nc">&nbsp;            updateEcmList();</b>
&nbsp;            
&nbsp;            //For Entities that have converted to another mode, check for a different sprite
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT</b>
<b class="nc">&nbsp;                    &amp;&amp; en.isConvertingNow()) {</b>
<b class="nc">&nbsp;                tileManager.reloadImage(en);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // for units that have been blown up, damaged or ejected, force a reload
<b class="nc">&nbsp;            if((e.getOldEntity() != null) &amp;&amp;</b>
<b class="nc">&nbsp;                    ((en.getDamageLevel() != e.getOldEntity().getDamageLevel()) ||</b>
<b class="nc">&nbsp;                    (en.isDestroyed() != e.getOldEntity().isDestroyed()) ||</b>
<b class="nc">&nbsp;                    (en.getCrew().isEjected() != e.getOldEntity().getCrew().isEjected()))) {</b>
<b class="nc">&nbsp;                tileManager.reloadImage(en);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            redrawAllEntities();</b>
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;                refreshMoveVectors();</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((mp != null) &amp;&amp; (mp.size() &gt; 0) &amp;&amp; guip.getShowMoveStep()</b>
<b class="nc">&nbsp;                    &amp;&amp; !gopts.booleanOption(OptionsConstants.INIT_SIMULTANEOUS_MOVEMENT)) {</b>
<b class="nc">&nbsp;                if ((localPlayer == null)</b>
<b class="nc">&nbsp;                        || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                        || !en.getOwner().isEnemyOf(localPlayer)</b>
<b class="nc">&nbsp;                        || en.hasSeenEntity(localPlayer)) {</b>
<b class="nc">&nbsp;                    addMovingUnit(en, mp);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameNewAction(GameNewActionEvent e) {
<b class="nc">&nbsp;            EntityAction ea = e.getAction();</b>
<b class="nc">&nbsp;            if (ea instanceof AttackAction) {</b>
<b class="nc">&nbsp;                addAttack((AttackAction) ea);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameBoardNew(GameBoardNewEvent e) {
<b class="nc">&nbsp;            IBoard b = e.getOldBoard();</b>
<b class="nc">&nbsp;            if (b != null) {</b>
<b class="nc">&nbsp;                b.removeBoardListener(BoardView1.this);</b>
&nbsp;            }
<b class="nc">&nbsp;            b = e.getNewBoard();</b>
<b class="nc">&nbsp;            if (b != null) {</b>
<b class="nc">&nbsp;                b.addBoardListener(BoardView1.this);</b>
&nbsp;            }
<b class="nc">&nbsp;            boardBackgrounds.clear();</b>
<b class="nc">&nbsp;            if (b.hasBoardBackground()) {</b>
<b class="nc">&nbsp;                ListIterator&lt;Boolean&gt; flipItHoriz = b.getFlipBGHoriz()</b>
<b class="nc">&nbsp;                        .listIterator();</b>
<b class="nc">&nbsp;                ListIterator&lt;Boolean&gt; flipItVert = b.getFlipBGVert()</b>
<b class="nc">&nbsp;                        .listIterator();</b>
<b class="nc">&nbsp;                for (String path : b.getBackgroundPaths()) {</b>
<b class="nc">&nbsp;                    boolean flipHoriz = flipItHoriz.next();</b>
<b class="nc">&nbsp;                    boolean flipVert = flipItVert.next();</b>
<b class="nc">&nbsp;                    if (path == null) {</b>
<b class="nc">&nbsp;                        boardBackgrounds.add(null);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        Image bgImg = ImageUtil.loadImageFromFile(path);</b>
<b class="nc">&nbsp;                        ImageProducer prod = bgImg.getSource();</b>
<b class="nc">&nbsp;                        if (flipHoriz || flipVert) {</b>
<b class="nc">&nbsp;                            AffineTransform at = new AffineTransform();</b>
&nbsp;
<b class="nc">&nbsp;                            if (flipHoriz) {</b>
<b class="nc">&nbsp;                                at.concatenate(AffineTransform</b>
<b class="nc">&nbsp;                                        .getScaleInstance(1, -1));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (flipVert) {</b>
<b class="nc">&nbsp;                                at.concatenate(AffineTransform</b>
<b class="nc">&nbsp;                                        .getTranslateInstance(0,</b>
<b class="nc">&nbsp;                                                -bgImg.getHeight(null)));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            ((Graphics2D) bgImg.getGraphics()).setTransform(at);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        boardBackgrounds.add(Toolkit.getDefaultToolkit()</b>
<b class="nc">&nbsp;                                .createImage(prod));</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            clearHexImageCache();</b>
<b class="nc">&nbsp;            updateBoard();</b>
<b class="nc">&nbsp;            clearShadowMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameBoardChanged(GameBoardChangeEvent e) {
<b class="nc">&nbsp;            clearHexImageCache();</b>
<b class="nc">&nbsp;            boardChanged();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gamePhaseChange(GamePhaseChangeEvent e) {
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getGameSummaryBoardView() &amp;&amp; ((e.getOldPhase() == Phase.PHASE_DEPLOYMENT)</b>
<b class="nc">&nbsp;                    || (e.getOldPhase() == Phase.PHASE_MOVEMENT) || (e.getOldPhase() == Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                    || (e.getOldPhase() == Phase.PHASE_FIRING) || (e.getOldPhase() == Phase.PHASE_PHYSICAL))) {</b>
<b class="nc">&nbsp;                File dir = new File(Configuration.gameSummaryImagesBVDir(), game.getUUIDString());</b>
<b class="nc">&nbsp;                if (!dir.exists()) {</b>
<b class="nc">&nbsp;                    dir.mkdirs();</b>
&nbsp;                }
<b class="nc">&nbsp;                File imgFile = new File(dir, &quot;round_&quot; + game.getRoundCount() + &quot;_&quot; + e.getOldPhase().ordinal() + &quot;_&quot;</b>
<b class="nc">&nbsp;                        + IGame.Phase.getDisplayableName(e.getOldPhase()) + &quot;.png&quot;);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    ImageIO.write(getEntireBoardImage(false), &quot;png&quot;, imgFile);</b>
<b class="nc">&nbsp;                } catch (IOException e1) {</b>
<b class="nc">&nbsp;                    e1.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            refreshAttacks();</b>
&nbsp;
&nbsp;            // Clear some information regardless of what phase it is
<b class="nc">&nbsp;            clearFiringSolutionData();</b>
<b class="nc">&nbsp;            clearMovementEnvelope();</b>
&nbsp;
<b class="nc">&nbsp;            switch (e.getNewPhase()) {</b>
&nbsp;                case PHASE_MOVEMENT:
<b class="nc">&nbsp;                    refreshMoveVectors();</b>
&nbsp;                case PHASE_FIRING:
<b class="nc">&nbsp;                    clearAllMoveVectors();</b>
&nbsp;                case PHASE_PHYSICAL:
<b class="nc">&nbsp;                    refreshAttacks();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_INITIATIVE:
<b class="nc">&nbsp;                    clearAllAttacks();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_END:
&nbsp;                case PHASE_VICTORY:
<b class="nc">&nbsp;                    clearSprites();</b>
&nbsp;                case PHASE_LOUNGE:
<b class="nc">&nbsp;                    clearHexImageCache();</b>
<b class="nc">&nbsp;                    clearAllMoveVectors();</b>
<b class="nc">&nbsp;                    clearAllAttacks();</b>
<b class="nc">&nbsp;                    clearSprites();</b>
<b class="nc">&nbsp;                    select(null);</b>
<b class="nc">&nbsp;                    cursor(null);</b>
<b class="nc">&nbsp;                    highlight(null);</b>
&nbsp;                default:
&nbsp;            }
<b class="nc">&nbsp;            for (Entity en: game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if ((en.getDamageLevel() != Entity.DMG_NONE) &amp;&amp; </b>
&nbsp;                        ((en.damageThisRound != 0) || (en instanceof GunEmplacement))) {
<b class="nc">&nbsp;                    tileManager.reloadImage(en);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    synchronized void boardChanged() {
<b class="nc">&nbsp;        redrawAllEntities();</b>
<b class="nc">&nbsp;        redrawAllFlares();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    void clearSprites() {
<b class="nc">&nbsp;        pathSprites.clear();</b>
<b class="nc">&nbsp;        firingSprites.clear();</b>
<b class="nc">&nbsp;        attackSprites.clear();</b>
<b class="nc">&nbsp;        c3Sprites.clear();</b>
<b class="nc">&nbsp;        vtolAttackSprites.clear();</b>
<b class="nc">&nbsp;        flyOverSprites.clear();</b>
<b class="nc">&nbsp;        movementSprites.clear();</b>
<b class="nc">&nbsp;        fieldofFireSprites.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public synchronized void updateBoard() {
<b class="nc">&nbsp;        updateBoardSize();</b>
<b class="nc">&nbsp;        redrawAllEntities();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * the old redrawworker converted to a runnable which is called now and then
&nbsp;     * from the event thread
&nbsp;     */
<b class="nc">&nbsp;    protected class RedrawWorker implements Runnable {</b>
&nbsp;
<b class="nc">&nbsp;        protected long lastTime = System.currentTimeMillis();</b>
&nbsp;
<b class="nc">&nbsp;        protected long currentTime = System.currentTimeMillis();</b>
&nbsp;
&nbsp;        public void run() {
<b class="nc">&nbsp;            currentTime = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            if (isShowing()) {</b>
<b class="nc">&nbsp;                boolean redraw = false;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; displayables.size(); i++) {</b>
<b class="nc">&nbsp;                    IDisplayable disp = displayables.get(i);</b>
<b class="nc">&nbsp;                    if (!disp.isSliding()) {</b>
<b class="nc">&nbsp;                        disp.setIdleTime(currentTime - lastTime, true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        redraw = redraw || disp.slide();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                redraw = redraw || doMoveUnits(currentTime - lastTime);</b>
<b class="nc">&nbsp;                if (redraw) {</b>
<b class="nc">&nbsp;                    repaint();</b>
&nbsp;                }
<b class="nc">&nbsp;                centerOnHexSoftStep(currentTime - lastTime);</b>
&nbsp;            }
<b class="nc">&nbsp;            lastTime = currentTime;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void selectEntity(Entity e) {
<b class="nc">&nbsp;        selectedEntity = e;</b>
<b class="nc">&nbsp;        checkFoVHexImageCacheClear();</b>
&nbsp;        // If we don&#39;t do this, the selectedWeapon might not correspond to this
&nbsp;        // entity
<b class="nc">&nbsp;        selectedWeapon = null;</b>
<b class="nc">&nbsp;        updateEcmList();</b>
<b class="nc">&nbsp;        highlightSelectedEntity();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public synchronized void weaponSelected(MechDisplayEvent b) {
<b class="nc">&nbsp;        selectedEntity = b.getEntity();</b>
<b class="nc">&nbsp;        selectedWeapon = b.getEquip();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     *  Updates maps that determine how to shade hexes affected by E(C)CM. This
&nbsp;     *  is expensive, so precalculate only when entity changes occur
&nbsp;     **/
&nbsp;    public void updateEcmList() {
<b class="nc">&nbsp;        Map&lt;Coords, Color&gt; newECMHexes = new HashMap&lt;Coords, Color&gt;();</b>
<b class="nc">&nbsp;        Map&lt;Coords, Color&gt; newECMCenters = new HashMap&lt;Coords, Color&gt;();</b>
<b class="nc">&nbsp;        Map&lt;Coords, Color&gt; newECCMHexes = new HashMap&lt;Coords, Color&gt;();</b>
<b class="nc">&nbsp;        Map&lt;Coords, Color&gt; newECCMCenters = new HashMap&lt;Coords, Color&gt;();</b>
&nbsp;
&nbsp;        // Compute info about all E(C)CM on the board
<b class="nc">&nbsp;        final List&lt;ECMInfo&gt; allEcmInfo = ComputeECM</b>
<b class="nc">&nbsp;                .computeAllEntitiesECMInfo(game.getEntitiesVector());</b>
&nbsp;
&nbsp;        // First, mark the sources of E(C)CM
&nbsp;        // Used for highlighting hexes and tooltips
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.getPosition() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // If this unit isn&#39;t spotted somehow, it&#39;s ECM doesn&#39;t show up
<b class="nc">&nbsp;            if ((localPlayer != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                    &amp;&amp; e.getOwner().isEnemyOf(localPlayer)</b>
<b class="nc">&nbsp;                    &amp;&amp; !e.hasSeenEntity(localPlayer)</b>
<b class="nc">&nbsp;                    &amp;&amp; !e.hasDetectedEntity(localPlayer)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final Color ecmColor = ECMEffects.getECMColor(e.getOwner());</b>
&nbsp;            // Update ECM center information
<b class="nc">&nbsp;            if (e.getECMInfo() != null) {</b>
<b class="nc">&nbsp;                newECMCenters.put(e.getPosition(), ecmColor);</b>
&nbsp;            }
&nbsp;            // Update ECCM center information
<b class="nc">&nbsp;            if (e.getECCMInfo() != null) {</b>
<b class="nc">&nbsp;                newECCMCenters.put(e.getPosition(), ecmColor);</b>
&nbsp;            }
&nbsp;            // Update Entity sprite&#39;s ECM status
<b class="nc">&nbsp;            int secondaryIdx = -1;</b>
<b class="nc">&nbsp;            if (e.getSecondaryPositions().size() &gt; 0) {</b>
<b class="nc">&nbsp;                secondaryIdx = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(e.getId(),</b>
&nbsp;                    secondaryIdx));
<b class="nc">&nbsp;            if (eSprite != null) {</b>
<b class="nc">&nbsp;                Coords pos = e.getPosition();</b>
<b class="nc">&nbsp;                eSprite.setAffectedByECM(ComputeECM.isAffectedByECM(e, pos,</b>
&nbsp;                        pos, allEcmInfo));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Keep track of allied ECM and enemy ECCM
<b class="nc">&nbsp;        Map&lt;Coords, ECMEffects&gt; ecmAffectedCoords =</b>
&nbsp;                new HashMap&lt;Coords, ECMEffects&gt;();
&nbsp;        // Keep track of allied ECCM and enemy ECM
<b class="nc">&nbsp;        Map&lt;Coords, ECMEffects&gt; eccmAffectedCoords =</b>
&nbsp;                new HashMap&lt;Coords, ECMEffects&gt;();
<b class="nc">&nbsp;        for (ECMInfo ecmInfo : allEcmInfo) {</b>
&nbsp;            // Can&#39;t see ECM field of unspotted unit
<b class="nc">&nbsp;            if ((ecmInfo.getEntity() != null) &amp;&amp; (localPlayer != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                    &amp;&amp; ecmInfo.getEntity().getOwner().isEnemyOf(localPlayer)</b>
<b class="nc">&nbsp;                    &amp;&amp; !ecmInfo.getEntity().hasSeenEntity(localPlayer)</b>
<b class="nc">&nbsp;                    &amp;&amp; !ecmInfo.getEntity().hasDetectedEntity(localPlayer)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final Coords ecmPos = ecmInfo.getPos();</b>
<b class="nc">&nbsp;            final int range = ecmInfo.getRange();</b>
&nbsp;
&nbsp;            // Add each Coords within range to the list of ECM Coords
<b class="nc">&nbsp;            for (int x = -range; x &lt;= range; x++) {</b>
<b class="nc">&nbsp;                for (int y = -range; y &lt;= range; y++) {</b>
<b class="nc">&nbsp;                    Coords c = new Coords(x + ecmPos.getX(), y + ecmPos.getY());</b>
<b class="nc">&nbsp;                    int dist = ecmPos.distance(c);</b>
<b class="nc">&nbsp;                    int dir = ecmInfo.getDirection();</b>
&nbsp;                    // Direction is the facing of the owning Entity
<b class="nc">&nbsp;                    boolean inArc = (dir == -1)</b>
&nbsp;                            || Compute
<b class="nc">&nbsp;                                    .isInArc(ecmPos, dir, c, Compute.ARC_NOSE);</b>
<b class="nc">&nbsp;                    if ((dist &gt; range) || !inArc) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Check for allied ECCM or enemy ECM
<b class="nc">&nbsp;                    if ((!ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())</b>
<b class="nc">&nbsp;                            || (ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())) {</b>
<b class="nc">&nbsp;                        ECMEffects ecmEffects = eccmAffectedCoords.get(c);</b>
<b class="nc">&nbsp;                        if (ecmEffects == null) {</b>
<b class="nc">&nbsp;                            ecmEffects = new ECMEffects();</b>
<b class="nc">&nbsp;                            eccmAffectedCoords.put(c, ecmEffects);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        ecmEffects.addECM(ecmInfo);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        ECMEffects ecmEffects = ecmAffectedCoords.get(c);</b>
<b class="nc">&nbsp;                        if (ecmEffects == null) {</b>
<b class="nc">&nbsp;                            ecmEffects = new ECMEffects();</b>
<b class="nc">&nbsp;                            ecmAffectedCoords.put(c, ecmEffects);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        ecmEffects.addECM(ecmInfo);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Finally, determine the color for each affected hex
<b class="nc">&nbsp;        for (Coords c : ecmAffectedCoords.keySet()) {</b>
<b class="nc">&nbsp;            ECMEffects ecm = ecmAffectedCoords.get(c);</b>
<b class="nc">&nbsp;            ECMEffects eccm = eccmAffectedCoords.get(c);</b>
<b class="nc">&nbsp;            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Coords c : eccmAffectedCoords.keySet()) {</b>
<b class="nc">&nbsp;            ECMEffects ecm = ecmAffectedCoords.get(c);</b>
<b class="nc">&nbsp;            ECMEffects eccm = eccmAffectedCoords.get(c);</b>
&nbsp;            // Already processed all ECM affected coords
<b class="nc">&nbsp;            if (ecm != null) {</b>
<b class="nc">&nbsp;             continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;Coords&gt; updatedHexes = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        if (ecmHexes != null) {</b>
<b class="nc">&nbsp;            updatedHexes.addAll(ecmHexes.keySet());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (eccmHexes != null) {</b>
<b class="nc">&nbsp;            updatedHexes.addAll(eccmHexes.keySet());</b>
&nbsp;        }
<b class="nc">&nbsp;        updatedHexes.addAll(newECMHexes.keySet());</b>
<b class="nc">&nbsp;        updatedHexes.addAll(newECCMHexes.keySet());</b>
<b class="nc">&nbsp;        clearHexImageCache(updatedHexes);</b>
&nbsp;
<b class="nc">&nbsp;        synchronized (this) {</b>
<b class="nc">&nbsp;            ecmHexes    = newECMHexes;</b>
<b class="nc">&nbsp;            ecmCenters  = newECMCenters;</b>
<b class="nc">&nbsp;            eccmHexes   = newECCMHexes;</b>
<b class="nc">&nbsp;            eccmCenters = newECCMCenters;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void processAffectedCoords(Coords c, ECMEffects ecm,
&nbsp;            ECMEffects eccm, Map&lt;Coords, Color&gt; newECMHexes,
&nbsp;            Map&lt;Coords, Color&gt; newECCMHexes) {
<b class="nc">&nbsp;        Color hexColorECM = null;</b>
<b class="nc">&nbsp;        if (ecm != null) {</b>
<b class="nc">&nbsp;            hexColorECM = ecm.getHexColor();</b>
&nbsp;        }
<b class="nc">&nbsp;        Color hexColorECCM = null;</b>
<b class="nc">&nbsp;        if (eccm != null) {</b>
<b class="nc">&nbsp;            hexColorECCM = eccm.getHexColor();</b>
&nbsp;        }
&nbsp;        // Hex color is null if all effects cancel out
<b class="nc">&nbsp;        if ((hexColorECM == null) &amp;&amp; (hexColorECCM == null)) {</b>
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if ((hexColorECM != null) &amp;&amp; (hexColorECCM == null)) {</b>
<b class="nc">&nbsp;            if (ecm.isECCM()) {</b>
<b class="nc">&nbsp;                newECCMHexes.put(c, hexColorECM);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                newECMHexes.put(c, hexColorECM);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if ((hexColorECM == null) &amp;&amp; (hexColorECCM != null)) {</b>
<b class="nc">&nbsp;            if (eccm.isECCM()) {</b>
<b class="nc">&nbsp;                newECCMHexes.put(c, hexColorECCM);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                newECMHexes.put(c, hexColorECCM);</b>
&nbsp;            }
&nbsp;        } else { // Both are non-null
<b class="nc">&nbsp;            newECMHexes.put(c, hexColorECM);</b>
<b class="nc">&nbsp;            newECCMHexes.put(c, hexColorECCM);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Dimension getPreferredScrollableViewportSize() {
<b class="nc">&nbsp;        return getPreferredSize();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getScrollableBlockIncrement(Rectangle arg0, int arg1, int arg2) {
<b class="nc">&nbsp;        final Dimension size = scrollpane.getViewport().getSize();</b>
<b class="nc">&nbsp;        if (arg1 == SwingConstants.VERTICAL) {</b>
<b class="nc">&nbsp;            return size.height;</b>
&nbsp;        }
<b class="nc">&nbsp;        return size.width;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean getScrollableTracksViewportHeight() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean getScrollableTracksViewportWidth() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getScrollableUnitIncrement(Rectangle arg0, int arg1, int arg2) {
<b class="nc">&nbsp;        if (arg1 == SwingConstants.VERTICAL) {</b>
<b class="nc">&nbsp;            return (int) ((scale * HEX_H) / 2.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        return (int) ((scale * HEX_W) / 2.0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setPreferredSize(Dimension d) {
<b class="nc">&nbsp;        super.setPreferredSize(d);</b>
<b class="nc">&nbsp;        preferredSize = new Dimension(d);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Dimension getPreferredSize() {
&nbsp;        // If the board is small, we want the preferred size to fill the whole
&nbsp;        //  ScrollPane viewport, for purposes of drawing the tiled background
&nbsp;        //  icon.
&nbsp;        // However, we also need the scrollable client to be as big as the
&nbsp;        //  board plus the pad size.
<b class="nc">&nbsp;        return new Dimension(</b>
<b class="nc">&nbsp;                Math.max(boardSize.width + (2 * HEX_W), preferredSize.width),</b>
<b class="nc">&nbsp;                Math.max(boardSize.height + (2 * HEX_W), preferredSize.height));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Have the player select an Entity from the entities at the given coords.
&nbsp;     *
&nbsp;     * @param pos - the &lt;code&gt;Coords&lt;/code&gt; containing targets.
&nbsp;     */
&nbsp;    private Entity chooseEntity(Coords pos) {
&nbsp;
&nbsp;        // Assume that we have *no* choice.
<b class="nc">&nbsp;        Entity choice = null;</b>
&nbsp;
&nbsp;        // Get the available choices.
<b class="nc">&nbsp;        List&lt;Entity&gt; entities = game.getEntitiesVector(pos);</b>
&nbsp;
&nbsp;
&nbsp;        // Do we have a single choice?
<b class="nc">&nbsp;        if (entities.size() == 1) {</b>
&nbsp;            // Return that choice.
<b class="nc">&nbsp;            choice = entities.get(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we have multiple choices, display a selection dialog.
<b class="nc">&nbsp;        else if (entities.size() &gt; 1) {</b>
<b class="nc">&nbsp;            String input = (String) JOptionPane</b>
<b class="nc">&nbsp;                    .showInputDialog(</b>
&nbsp;                            null,
<b class="nc">&nbsp;                            Messages.getString(</b>
<b class="nc">&nbsp;                                    &quot;BoardView1.ChooseEntityDialog.message&quot;, new Object[]{pos.getBoardNum()}), //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            Messages.getString(&quot;BoardView1.ChooseEntityDialog.title&quot;), //$NON-NLS-1$</b>
&nbsp;                            JOptionPane.QUESTION_MESSAGE, null, SharedUtility
<b class="nc">&nbsp;                                    .getDisplayArray(entities), null);</b>
<b class="nc">&nbsp;            choice = (Entity) SharedUtility.getTargetPicked(entities, input);</b>
&nbsp;        } // End have-choices
&nbsp;
&nbsp;        // Return the chosen unit.
<b class="nc">&nbsp;        return choice;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * The text to be displayed when the mouse is at a certain point.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getToolTipText(MouseEvent e) {
&nbsp;        // If new instance of mouse event, redraw obscured hexes and elevations.
<b class="nc">&nbsp;        repaint();</b>
&nbsp;
<b class="nc">&nbsp;        StringBuffer txt = new StringBuffer();</b>
<b class="nc">&nbsp;        IHex mhex = null;</b>
<b class="nc">&nbsp;        final Point point = e.getPoint();</b>
<b class="nc">&nbsp;        if (prevTipX &gt; 0 &amp;&amp; prevTipY &gt; 0) {</b>
<b class="nc">&nbsp;            int deltaX = point.x - prevTipX;</b>
<b class="nc">&nbsp;            int deltaY = point.y - prevTipY;</b>
<b class="nc">&nbsp;            double deltaMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);</b>
<b class="nc">&nbsp;            if (deltaMagnitude &gt; GUIPreferences.getInstance().getTooltipDistSuppression()) {</b>
<b class="nc">&nbsp;                prevTipX = -1; prevTipY = -1;</b>
&nbsp;                // Set the dismissal delay to 0 so that the tooltip
&nbsp;                // goes away and does not reappear until the mouse
&nbsp;                // has moved more than the suppression distance
<b class="nc">&nbsp;                ToolTipManager.sharedInstance().setDismissDelay(0);</b>
<b class="nc">&nbsp;                return new String(&quot;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        prevTipX = point.x; prevTipY = point.y;</b>
<b class="nc">&nbsp;        final Coords mcoords = getCoordsAt(point);</b>
<b class="nc">&nbsp;        final ArrayList&lt;ArtilleryAttackAction&gt; artilleryAttacks =</b>
<b class="nc">&nbsp;                getArtilleryAttacksAtLocation(mcoords);</b>
<b class="nc">&nbsp;        final Mounted curWeapon = getSelectedArtilleryWeapon();</b>
&nbsp;
<b class="nc">&nbsp;        if (game.getBoard().contains(mcoords))</b>
<b class="nc">&nbsp;            mhex = game.getBoard().getHex(mcoords);</b>
&nbsp;
<b class="nc">&nbsp;        txt.append(&quot;&lt;html&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
&nbsp;
&nbsp;        // Hex Terrain
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getShowMapHexPopup() &amp;&amp; (mhex != null)) {</b>
&nbsp;
<b class="nc">&nbsp;            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#DDFFDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
<b class="nc">&nbsp;            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Hex&quot;, //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    new Object[] { mcoords.getBoardNum(), mhex.getLevel() }));</b>
<b class="nc">&nbsp;            txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
&nbsp;            // cycle through the terrains and report types found
&nbsp;            // this will skip buildings and other constructed units
<b class="nc">&nbsp;            int terrainTypes[] = mhex.getTerrainTypes();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; terrainTypes.length; i++) {</b>
<b class="nc">&nbsp;                int terType = terrainTypes[i];</b>
<b class="nc">&nbsp;                if (mhex.containsTerrain(terType)) {</b>
<b class="nc">&nbsp;                    int tf = mhex.getTerrain(terType).getTerrainFactor();</b>
<b class="nc">&nbsp;                    int ttl = mhex.getTerrain(terType).getLevel();</b>
<b class="nc">&nbsp;                    String name = Terrains.getDisplayName(terType, ttl);</b>
<b class="nc">&nbsp;                    if (tf &gt; 0) {</b>
<b class="nc">&nbsp;                        name = name + &quot; (TF: &quot; + tf + &quot;)&quot;; //$NON-NLS-1$ //$NON-NLS-2$</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (name != null) {</b>
<b class="nc">&nbsp;                        txt.append(name);</b>
<b class="nc">&nbsp;                        txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
&nbsp;            // Distance from the selected unit and a planned movement end point
<b class="nc">&nbsp;            if ((selectedEntity != null) &amp;&amp;</b>
<b class="nc">&nbsp;                    (selectedEntity.getPosition() != null)) {</b>
<b class="nc">&nbsp;                int distance = selectedEntity</b>
<b class="nc">&nbsp;                        .getPosition()</b>
<b class="nc">&nbsp;                        .distance(mcoords);</b>
<b class="nc">&nbsp;                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                if (distance == 1) {</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Distance1&quot;)); //$NON-NLS-1$</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceN&quot;, //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            new Object[] { distance }));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</b>
<b class="nc">&nbsp;                    LosEffects los = fovHighlightingAndDarkening.getCachedLosEffects(selectedEntity.getPosition(), mcoords);</b>
<b class="nc">&nbsp;                    int bracket = Compute.getSensorRangeBracket(selectedEntity, null,</b>
&nbsp;                            fovHighlightingAndDarkening.cachedAllECMInfo);
<b class="nc">&nbsp;                    int range = Compute.getSensorRangeByBracket(game, selectedEntity, null, los);</b>
&nbsp;
<b class="nc">&nbsp;                    int maxSensorRange = bracket * range;</b>
<b class="nc">&nbsp;                    int minSensorRange = Math.max((bracket - 1) * range, 0);</b>
<b class="nc">&nbsp;                    if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</b>
<b class="nc">&nbsp;                        minSensorRange = 0;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    txt.append(&quot;&lt;BR&gt;&quot;);</b>
<b class="nc">&nbsp;                    if ((distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange)) {</b>
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexInRange&quot;));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexNotInRange&quot;));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp;</b>
&nbsp;                        (movementTarget != null)) {
<b class="nc">&nbsp;                    txt.append(&quot;&lt;BR&gt;&quot;);</b>
<b class="nc">&nbsp;                    int disPM = movementTarget.distance(mcoords);</b>
<b class="nc">&nbsp;                    if (disPM == 1) {</b>
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMove1&quot;)); //$NON-NLS-1$</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMoveN&quot;, //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                new Object[] { disPM }));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;
&nbsp;            // Fuel Tank
<b class="nc">&nbsp;            if (mhex.containsTerrain(Terrains.FUEL_TANK)) {</b>
&nbsp;                // In the BoardEditor, buildings have no entry in the
&nbsp;                // buildings list of the board, so get the info from the hex
<b class="nc">&nbsp;                if (clientgui == null) {</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, new Object[] { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</b>
<b class="nc">&nbsp;                            Terrains.getEditorName(Terrains.FUEL_TANK),</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.FUEL_TANK_CF),</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.FUEL_TANK_MAGN)</b>
&nbsp;                    }));
&nbsp;                } else {
<b class="nc">&nbsp;                    Building bldg = game.getBoard().getBuildingAt(mcoords);</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, new Object[] { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</b>
<b class="nc">&nbsp;                            bldg.toString(),</b>
<b class="nc">&nbsp;                            bldg.getCurrentCF(mcoords)</b>
&nbsp;                    }));
&nbsp;                }
<b class="nc">&nbsp;                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;
&nbsp;            // Building
<b class="nc">&nbsp;            if (mhex.containsTerrain(Terrains.BUILDING)) {</b>
&nbsp;                // In the BoardEditor, buildings have no entry in the
&nbsp;                // buildings list of the board, so get the info from the hex
<b class="nc">&nbsp;                if (clientgui == null) {</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, new Object[] { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.BLDG_ELEV),</b>
<b class="nc">&nbsp;                            Terrains.getEditorName(Terrains.BUILDING),</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.BLDG_CF),</b>
<b class="nc">&nbsp;                            Math.max(mhex.terrainLevel(Terrains.BLDG_ARMOR),0),</b>
<b class="nc">&nbsp;                            BasementType.getType(mhex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)).toString()</b>
&nbsp;                    }));
&nbsp;                } else {
<b class="nc">&nbsp;                    Building bldg = game.getBoard().getBuildingAt(mcoords);</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#CCCC99 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, new Object[] { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.BLDG_ELEV),</b>
<b class="nc">&nbsp;                            bldg.toString(),</b>
<b class="nc">&nbsp;                            bldg.getCurrentCF(mcoords),</b>
<b class="nc">&nbsp;                            bldg.getArmor(mcoords),</b>
<b class="nc">&nbsp;                            bldg.getBasement(mcoords).getDesc()</b>
&nbsp;                    }));
&nbsp;
<b class="nc">&nbsp;                    if (bldg.getBasementCollapsed(mcoords)) {</b>
<b class="nc">&nbsp;                        txt.append(Messages</b>
<b class="nc">&nbsp;                                .getString(&quot;BoardView1.Tooltip.BldgBasementCollapsed&quot;)); //$NON-NLS-1$</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;
&nbsp;            // Bridge
<b class="nc">&nbsp;            if (mhex.containsTerrain(Terrains.BRIDGE)) {</b>
&nbsp;                // In the BoardEditor, buildings have no entry in the
&nbsp;                // buildings list of the board, so get the info from the hex
<b class="nc">&nbsp;                if (clientgui == null) {</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, new Object[] { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.BRIDGE_ELEV),</b>
<b class="nc">&nbsp;                            Terrains.getEditorName(Terrains.BRIDGE),</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.BRIDGE_CF),</b>
&nbsp;                    }));
&nbsp;                } else {
<b class="nc">&nbsp;                    Building bldg = game.getBoard().getBuildingAt(mcoords);</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, new Object[] { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            mhex.terrainLevel(Terrains.BRIDGE_ELEV),</b>
<b class="nc">&nbsp;                            bldg.toString(),</b>
<b class="nc">&nbsp;                            bldg.getCurrentCF(mcoords),</b>
&nbsp;                    }));
&nbsp;                }
<b class="nc">&nbsp;                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (game.containsMinefield(mcoords)) {</b>
<b class="nc">&nbsp;                Vector&lt;Minefield&gt; minefields = game.getMinefields(mcoords);</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; minefields.size(); i++) {</b>
<b class="nc">&nbsp;                    Minefield mf = minefields.elementAt(i);</b>
<b class="nc">&nbsp;                    String owner = &quot; (&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                   + game.getPlayer(mf.getPlayerId()).getName()</b>
&nbsp;                                   + &quot;)&quot;; //$NON-NLS-1$
&nbsp;
<b class="nc">&nbsp;                    switch (mf.getType()) {</b>
&nbsp;                        case (Minefield.TYPE_CONVENTIONAL):
<b class="nc">&nbsp;                            txt.append(mf.getName()</b>
<b class="nc">&nbsp;                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case (Minefield.TYPE_COMMAND_DETONATED):
<b class="nc">&nbsp;                            txt.append(mf.getName()</b>
<b class="nc">&nbsp;                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case (Minefield.TYPE_VIBRABOMB):
<b class="nc">&nbsp;                            if (mf.getPlayerId() == localPlayer.getId()) {</b>
<b class="nc">&nbsp;                                txt.append(mf.getName()</b>
&nbsp;                                           + Messages
<b class="nc">&nbsp;                                        .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                           + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot;(&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                           + mf.getSetting() + &quot;) &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                txt.append(mf.getName()</b>
&nbsp;                                           + Messages
<b class="nc">&nbsp;                                        .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                           + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</b>
&nbsp;                            }
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case (Minefield.TYPE_ACTIVE):
<b class="nc">&nbsp;                            txt.append(mf.getName()</b>
<b class="nc">&nbsp;                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case (Minefield.TYPE_INFERNO):
<b class="nc">&nbsp;                            txt.append(mf.getName()</b>
<b class="nc">&nbsp;                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</b>
&nbsp;                            break;
&nbsp;                    }
<b class="nc">&nbsp;                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (displayInvalidHexInfo) {</b>
<b class="nc">&nbsp;                StringBuffer errBuff = new StringBuffer();</b>
<b class="nc">&nbsp;                if (!mhex.isValid(errBuff)) {</b>
<b class="nc">&nbsp;                    txt.append(Messages.getString(&quot;BoardView1.invalidHex&quot;));</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    String errors = errBuff.toString();</b>
<b class="nc">&nbsp;                    errors = errors.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;);</b>
<b class="nc">&nbsp;                    txt.append(errors);</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Show the player(s) that may deploy here
&nbsp;        // in the artillery autohit designation phase
<b class="nc">&nbsp;        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) &amp;&amp; (mhex != null)) {</b>
<b class="nc">&nbsp;            txt.append(&quot;&lt;TABLE BORDER=0 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</b>
<b class="nc">&nbsp;            boolean foundPlayer = false;</b>
&nbsp;            // loop through all players
<b class="nc">&nbsp;            while (allP.hasMoreElements())</b>
&nbsp;            {
<b class="nc">&nbsp;                IPlayer cp = allP.nextElement();</b>
<b class="nc">&nbsp;                if (game.getBoard().isLegalDeployment(mcoords, cp.getStartingPos())) {</b>
<b class="nc">&nbsp;                    if (!foundPlayer) {</b>
<b class="nc">&nbsp;                        foundPlayer = true;</b>
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHeader&quot;)); //$NON-NLS-1$</b>
&nbsp;                    }
<b class="nc">&nbsp;                    txt.append(&quot;&lt;B&gt;&lt;FONT COLOR=#&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(cp.getColour().getHexString());</b>
<b class="nc">&nbsp;                    txt.append(&quot;&gt;&amp;nbsp;&amp;nbsp;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(cp.getName());</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;/FONT&gt;&lt;/B&gt;&lt;BR&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (foundPlayer) txt.append(&quot;&lt;BR&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
&nbsp;            // Add a hint with keybind that the zones can be shown graphically
<b class="nc">&nbsp;            String keybindText = KeyEvent.getKeyModifiersText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).modifiers);</b>
<b class="nc">&nbsp;            if (!keybindText.isEmpty()) keybindText += &quot;+&quot;;</b>
<b class="nc">&nbsp;            keybindText += KeyEvent.getKeyText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).key);</b>
<b class="nc">&nbsp;            txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHint&quot;, keybindText));</b>
&nbsp;
<b class="nc">&nbsp;            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // check if it&#39;s on any flares
<b class="nc">&nbsp;        for (FlareSprite fSprite : flareSprites) {</b>
<b class="nc">&nbsp;            if (fSprite.isInside(point)) {</b>
<b class="nc">&nbsp;                txt.append(fSprite.getTooltip().toString());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check if it&#39;s on any attacks
<b class="nc">&nbsp;        for (AttackSprite aSprite : attackSprites) {</b>
<b class="nc">&nbsp;            if (aSprite.isInside(point)) {</b>
<b class="nc">&nbsp;                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                txt.append(aSprite.getTooltip().toString());</b>
<b class="nc">&nbsp;                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Entity tooltips
<b class="nc">&nbsp;        int entityCount = 0;</b>
&nbsp;        // Maximum number of entities to show in the tooltip
<b class="nc">&nbsp;        int maxShown = 4;</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;Entity&gt; coordEnts = new HashSet&lt;&gt;(game.getEntitiesVector(mcoords));</b>
<b class="nc">&nbsp;        Set&lt;Entity&gt; usedSet = new HashSet&lt;Entity&gt;(entitySprites.size());</b>
<b class="nc">&nbsp;        for (EntitySprite eSprite : entitySprites) {</b>
<b class="nc">&nbsp;            if ((eSprite.isInside(point) || coordEnts.contains(eSprite.entity))</b>
<b class="nc">&nbsp;                    &amp;&amp; !usedSet.contains(eSprite.entity)) {</b>
<b class="nc">&nbsp;                usedSet.add(eSprite.entity);</b>
<b class="nc">&nbsp;                entityCount++;</b>
&nbsp;
&nbsp;                // List only the first four units
<b class="nc">&nbsp;                if (entityCount &lt;= maxShown) {</b>
&nbsp;                    // Table to add a bar to the left of an entity in
&nbsp;                    // the player&#39;s color
<b class="nc">&nbsp;                    txt.append(&quot;&lt;hr style=width:90%&gt;&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;TABLE&gt;&lt;TR&gt;&lt;TD bgcolor=#&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    txt.append(eSprite.getPlayerColor());</b>
<b class="nc">&nbsp;                    txt.append(&quot; width=6&gt;&lt;/TD&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
&nbsp;                    // TT generated by Sprite
<b class="nc">&nbsp;                    txt.append(eSprite.getTooltip());</b>
&nbsp;
&nbsp;                    // ECM and ECCM source
<b class="nc">&nbsp;                    if (eSprite.entity.hasActiveECM()) {</b>
<b class="nc">&nbsp;                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                + Configuration.widgetsDir()</b>
&nbsp;                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.ecmSource&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        txt.append(&quot;&lt;/FONT&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (eSprite.entity.hasActiveECCM()) {</b>
<b class="nc">&nbsp;                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                                + Configuration.widgetsDir()</b>
&nbsp;                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<b class="nc">&nbsp;                        txt.append(Messages.getString(&quot;BoardView1.eccmSource&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        txt.append(&quot;&lt;/FONT&gt;&quot;);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Info block if there are more than 4 units in that hex
<b class="nc">&nbsp;        if (entityCount &gt; maxShown)</b>
&nbsp;        {
<b class="nc">&nbsp;            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#000060 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT COLOR=WHITE&gt;There &quot;);</b>
<b class="nc">&nbsp;            if (entityCount-maxShown == 1)</b>
<b class="nc">&nbsp;                txt.append(&quot;is 1 more&lt;BR&gt;unit&quot;);</b>
&nbsp;            else
<b class="nc">&nbsp;                txt.append(&quot;are &quot;+(entityCount-maxShown)+&quot; more&lt;BR&gt;units&quot;);</b>
<b class="nc">&nbsp;            txt.append(&quot; in this hex...&lt;/FONT&gt;&quot;);</b>
<b class="nc">&nbsp;            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Artillery attacks
<b class="nc">&nbsp;        for (ArtilleryAttackAction aaa : artilleryAttacks) {</b>
&nbsp;            // Default texts if no real names can be found
<b class="nc">&nbsp;            String wpName = Messages.getString(&quot;BoardView1.Artillery&quot;);</b>
<b class="nc">&nbsp;            String ammoName = &quot;Unknown&quot;;</b>
&nbsp;
&nbsp;            // Get real weapon and ammo name
<b class="nc">&nbsp;            final Entity artyEnt = game.getEntity(aaa.getEntityId());</b>
<b class="nc">&nbsp;            if (artyEnt != null) {</b>
<b class="nc">&nbsp;                if (aaa.getWeaponId() &gt; -1) {</b>
<b class="nc">&nbsp;                    wpName = artyEnt.getEquipment(aaa.getWeaponId()).getName();</b>
<b class="nc">&nbsp;                    if (aaa.getAmmoId() &gt; -1) {</b>
<b class="nc">&nbsp;                        ammoName =  artyEnt.getEquipment(aaa.getAmmoId()).getName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;);</b>
<b class="nc">&nbsp;            if (aaa.getTurnsTilHit() == 1)</b>
<b class="nc">&nbsp;                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttack1&quot;,</b>
&nbsp;                        new Object[] { wpName, ammoName }));
&nbsp;            else
<b class="nc">&nbsp;                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttackN&quot;,</b>
<b class="nc">&nbsp;                        new Object[] { wpName, ammoName, aaa.getTurnsTilHit() }));</b>
<b class="nc">&nbsp;            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Artillery fire adjustment
<b class="nc">&nbsp;        if ((curWeapon != null) &amp;&amp; (selectedEntity != null)) {</b>
&nbsp;            // process targetted hexes
<b class="nc">&nbsp;            int amod = 0;</b>
&nbsp;            // Check the predesignated hexes
<b class="nc">&nbsp;            if (selectedEntity.getOwner().getArtyAutoHitHexes()</b>
<b class="nc">&nbsp;                              .contains(mcoords)) {</b>
<b class="nc">&nbsp;                amod = TargetRoll.AUTOMATIC_SUCCESS;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                amod = selectedEntity.aTracker.getModifier(curWeapon, mcoords);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (amod == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;                txt.append(Messages</b>
<b class="nc">&nbsp;                                   .getString(&quot;BoardView1.ArtilleryAutohit&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            } else {
<b class="nc">&nbsp;                txt.append(Messages.getString(</b>
&nbsp;                        &quot;BoardView1.ArtilleryAdjustment&quot;, //$NON-NLS-1$
<b class="nc">&nbsp;                        new Object[]{Integer.valueOf(amod)}));</b>
<b class="nc">&nbsp;                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard()</b>
<b class="nc">&nbsp;                .getSpecialHexDisplay(mcoords);</b>
<b class="nc">&nbsp;        final Phase currPhase = game.getPhase();</b>
<b class="nc">&nbsp;        int round = game.getRoundCount();</b>
<b class="nc">&nbsp;        if (shdList != null) {</b>
<b class="nc">&nbsp;            boolean isHexAutoHit = localPlayer.getArtyAutoHitHexes().contains(</b>
&nbsp;                    mcoords);
<b class="nc">&nbsp;            for (SpecialHexDisplay shd : shdList) {</b>
<b class="nc">&nbsp;                boolean isTypeAutoHit = shd.getType()</b>
&nbsp;                        == SpecialHexDisplay.Type.ARTILLERY_AUTOHIT;
&nbsp;                // Don&#39;t draw if this SHD is obscured from this player
&nbsp;                // The SHD list may also contain stale SHDs, so don&#39;t show
&nbsp;                // tooltips for SHDs that aren&#39;t drawn.
&nbsp;                // The exception is auto hits.  There will be an icon for auto
&nbsp;                // hits, so we need to draw a tooltip
<b class="nc">&nbsp;                if (!shd.isObscured(localPlayer)</b>
<b class="nc">&nbsp;                        &amp;&amp; (shd.drawNow(currPhase, round, localPlayer)</b>
&nbsp;                                || (isHexAutoHit &amp;&amp; isTypeAutoHit))) {
<b class="nc">&nbsp;                    if (shd.getType() == SpecialHexDisplay.Type.PLAYER_NOTE) {</b>
<b class="nc">&nbsp;                        if (localPlayer.equals(shd.getOwner())) {</b>
<b class="nc">&nbsp;                            txt.append(&quot;Note: &quot;);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            txt.append(&quot;Note (&quot; + shd.getOwner().getName()</b>
&nbsp;                                       + &quot;): &quot;);
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    String buf = shd.getInfo();</b>
<b class="nc">&nbsp;                    buf = buf.replaceAll(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;);</b>
<b class="nc">&nbsp;                    txt.append(buf);</b>
<b class="nc">&nbsp;                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        txt.append(&quot;&lt;/html&gt;&quot;); //$NON-NLS-1$</b>
&nbsp;
&nbsp;        // Check to see if the tool tip is completely empty
<b class="nc">&nbsp;        if (txt.toString().equals(&quot;&lt;html&gt;&lt;/html&gt;&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;            return new String(&quot;&quot;); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now that a valid tooltip text seems to be present,
&nbsp;        // (re)set the tooltip dismissal delay time to the preference
&nbsp;        // value so that the tooltip actually appears
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</b>
<b class="nc">&nbsp;            ToolTipManager.sharedInstance().setDismissDelay(</b>
<b class="nc">&nbsp;                    GUIPreferences.getInstance().getTooltipDismissDelay());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return txt.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    private ArrayList&lt;ArtilleryAttackAction&gt; getArtilleryAttacksAtLocation(
&nbsp;            Coords c) {
<b class="nc">&nbsp;        ArrayList&lt;ArtilleryAttackAction&gt; v = new ArrayList&lt;ArtilleryAttackAction&gt;();</b>
<b class="nc">&nbsp;        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game</b>
<b class="nc">&nbsp;                .getArtilleryAttacks(); attacks.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            ArtilleryAttackAction a = attacks.nextElement();</b>
<b class="nc">&nbsp;            if (a.getTarget(game).getPosition().equals(c)) {</b>
<b class="nc">&nbsp;                v.add(a);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return v;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Component getComponent() {
<b class="nc">&nbsp;        return getComponent(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Component getComponent(boolean scrollBars) {
&nbsp;        // If we&#39;re already configured, return the scrollpane
<b class="nc">&nbsp;        if (scrollpane != null) {</b>
<b class="nc">&nbsp;            return scrollpane;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        SkinSpecification bvSkinSpec = SkinXMLHandler</b>
<b class="nc">&nbsp;                .getSkin(SkinSpecification.UIComponents.BoardView.getComp());</b>
&nbsp;
&nbsp;        // Setup background icons
&nbsp;        try {
&nbsp;            File file;
<b class="nc">&nbsp;            if (bvSkinSpec.backgrounds.size() &gt; 0) {</b>
<b class="nc">&nbsp;                file = new MegaMekFile(Configuration.widgetsDir(),</b>
<b class="nc">&nbsp;                                bvSkinSpec.backgrounds.get(0)).getFile();</b>
<b class="nc">&nbsp;                if (!file.exists()) {</b>
<b class="nc">&nbsp;                    System.err.println(&quot;BoardView1 Error: icon doesn&#39;t exist: &quot;</b>
<b class="nc">&nbsp;                                       + file.getAbsolutePath());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    bvBgImage = (BufferedImage) ImageUtil.loadImageFromFile(</b>
<b class="nc">&nbsp;                            file.getAbsolutePath());</b>
<b class="nc">&nbsp;                    bvBgShouldTile = bvSkinSpec.tileBackground;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (bvSkinSpec.backgrounds.size() &gt; 1) {</b>
<b class="nc">&nbsp;                file = new MegaMekFile(Configuration.widgetsDir(),</b>
<b class="nc">&nbsp;                                bvSkinSpec.backgrounds.get(1)).getFile();</b>
<b class="nc">&nbsp;                if (!file.exists()) {</b>
<b class="nc">&nbsp;                    System.err.println(&quot;BoardView1 Error: icon doesn&#39;t exist: &quot;</b>
<b class="nc">&nbsp;                                       + file.getAbsolutePath());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    scrollPaneBgImg = ImageUtil.loadImageFromFile(</b>
<b class="nc">&nbsp;                            file.getAbsolutePath());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;Error loading BoardView background images!&quot;);</b>
<b class="nc">&nbsp;            System.out.println(e.getMessage());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Place the board viewer in a set of scrollbars.
<b class="nc">&nbsp;        scrollpane = new JScrollPane(this) {</b>
&nbsp;
&nbsp;            /**
&nbsp;             *
&nbsp;             */
&nbsp;            private static final long serialVersionUID = 5973610449428194319L;
&nbsp;
&nbsp;            @Override
&nbsp;            protected void paintComponent(Graphics g) {
<b class="nc">&nbsp;                if (scrollPaneBgImg == null) {</b>
<b class="nc">&nbsp;                    super.paintComponent(g);</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                int w = getWidth();</b>
<b class="nc">&nbsp;                int h = getHeight();</b>
<b class="nc">&nbsp;                int iW = scrollPaneBgImg.getWidth(null);</b>
<b class="nc">&nbsp;                int iH = scrollPaneBgImg.getHeight(null);</b>
<b class="nc">&nbsp;                if ((scrollPaneBgBuffer == null)</b>
<b class="nc">&nbsp;                    || (scrollPaneBgBuffer.getWidth() != w)</b>
<b class="nc">&nbsp;                    || (scrollPaneBgBuffer.getHeight() != h)) {</b>
<b class="nc">&nbsp;                    scrollPaneBgBuffer = new BufferedImage(w, h,</b>
&nbsp;                            BufferedImage.TYPE_INT_RGB);
<b class="nc">&nbsp;                    Graphics bgGraph = scrollPaneBgBuffer.getGraphics();</b>
&nbsp;                    // If the unit icon not loaded, prevent infinite loop
<b class="nc">&nbsp;                    if ((iW &lt; 1) || (iH &lt; 1)) {</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int x = 0; x &lt; w; x += iW) {</b>
<b class="nc">&nbsp;                        for (int y = 0; y &lt; h; y += iH) {</b>
<b class="nc">&nbsp;                            bgGraph.drawImage(scrollPaneBgImg, x, y, null);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    bgGraph.dispose();</b>
&nbsp;                }
<b class="nc">&nbsp;                g.drawImage(scrollPaneBgBuffer, 0, 0, null);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        };
<b class="nc">&nbsp;        scrollpane.setBorder(new MegamekBorder(bvSkinSpec));</b>
<b class="nc">&nbsp;        scrollpane.setLayout(new ScrollPaneLayout());</b>
&nbsp;        // we need to use the simple scroll mode because otherwise the
&nbsp;        // IDisplayables that are drawn in fixed positions in the viewport
&nbsp;        // leave artifacts when scrolling
<b class="nc">&nbsp;        scrollpane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);</b>
&nbsp;
&nbsp;        // Prevent the default arrow key scrolling
<b class="nc">&nbsp;        scrollpane.getActionMap().put(&quot;unitScrollRight&quot;, DoNothing);</b>
<b class="nc">&nbsp;        scrollpane.getActionMap().put(&quot;unitScrollDown&quot;, DoNothing);</b>
<b class="nc">&nbsp;        scrollpane.getActionMap().put(&quot;unitScrollLeft&quot;, DoNothing);</b>
<b class="nc">&nbsp;        scrollpane.getActionMap().put(&quot;unitScrollUp&quot;, DoNothing);</b>
&nbsp;
<b class="nc">&nbsp;        vbar = scrollpane.getVerticalScrollBar();</b>
<b class="nc">&nbsp;        hbar = scrollpane.getHorizontalScrollBar();</b>
&nbsp;
<b class="nc">&nbsp;        if (!scrollBars &amp;&amp; !bvSkinSpec.showScrollBars) {</b>
<b class="nc">&nbsp;            vbar.setPreferredSize(new Dimension(0, vbar.getHeight()));</b>
<b class="nc">&nbsp;            hbar.setPreferredSize(new Dimension(hbar.getWidth(), 0));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return scrollpane;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    AbstractAction DoNothing = new AbstractAction() {</b>
&nbsp;        private static final long serialVersionUID = 5944877465265121983L;
&nbsp;
&nbsp;        @Override
&nbsp;        public void actionPerformed(ActionEvent e) {
<b class="nc">&nbsp;        }</b>
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * refresh the IDisplayables
&nbsp;     */
&nbsp;    public void refreshDisplayables() {
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void pingMinimap() {
&nbsp;        // send the minimap a hex moused event to make it
&nbsp;        // update the visible area rectangle
<b class="nc">&nbsp;        BoardViewEvent bve = new BoardViewEvent(this,BoardViewEvent.BOARD_HEX_DRAGGED);</b>
<b class="nc">&nbsp;        if (boardListeners != null) {</b>
<b class="nc">&nbsp;            for (BoardViewListener l : boardListeners) l.hexMoused(bve);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void showPopup(Object popup, Coords c) {
<b class="nc">&nbsp;        Point p = getHexLocation(c);</b>
<b class="nc">&nbsp;        p.x += ((int) (HEX_WC * scale) - scrollpane.getX()) + HEX_W;</b>
<b class="nc">&nbsp;        p.y += ((int) ((HEX_H * scale) / 2) - scrollpane.getY()) + HEX_H;</b>
<b class="nc">&nbsp;        if (((JPopupMenu) popup).getParent() == null) {</b>
<b class="nc">&nbsp;            add((JPopupMenu) popup);</b>
&nbsp;        }
<b class="nc">&nbsp;        ((JPopupMenu) popup).show(this, p.x, p.y);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void refreshMinefields() {
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Increases zoomIndex and refreshes the map.
&nbsp;     */
&nbsp;    public void zoomIn() {
<b class="nc">&nbsp;        if (zoomIndex == (ZOOM_FACTORS.length - 1)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        zoomIndex++;</b>
<b class="nc">&nbsp;        zoom();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Decreases zoomIndex and refreshes the map.
&nbsp;     */
&nbsp;    public void zoomOut() {
<b class="nc">&nbsp;        if (zoomIndex == 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        zoomIndex--;</b>
<b class="nc">&nbsp;        zoom();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void hideTooltip() {
<b class="nc">&nbsp;        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void checkZoomIndex() {
<b class="nc">&nbsp;        if (zoomIndex &gt; (ZOOM_FACTORS.length - 1)) {</b>
<b class="nc">&nbsp;            zoomIndex = ZOOM_FACTORS.length - 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (zoomIndex &lt; 0) {</b>
<b class="nc">&nbsp;            zoomIndex = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Changes hex dimensions and refreshes the map with the new scale
&nbsp;     */
&nbsp;    private void zoom() {
&nbsp;
<b class="nc">&nbsp;        checkZoomIndex();</b>
<b class="nc">&nbsp;        stopSoftCentering();</b>
<b class="nc">&nbsp;        scale = ZOOM_FACTORS[zoomIndex];</b>
<b class="nc">&nbsp;        GUIPreferences.getInstance().setMapZoomIndex(zoomIndex);</b>
&nbsp;
<b class="nc">&nbsp;        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</b>
&nbsp;
<b class="nc">&nbsp;        scaledImageCache = new ImageCache&lt;Integer, Image&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        cursorSprite.prepare();</b>
<b class="nc">&nbsp;        highlightSprite.prepare();</b>
<b class="nc">&nbsp;        selectedSprite.prepare();</b>
<b class="nc">&nbsp;        firstLOSSprite.prepare();</b>
<b class="nc">&nbsp;        secondLOSSprite.prepare();</b>
<b class="nc">&nbsp;        for (Sprite spr : moveEnvSprites) {</b>
<b class="nc">&nbsp;            spr.prepare();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Sprite spr : moveModEnvSprites) {</b>
<b class="nc">&nbsp;            spr.prepare();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Sprite spr : fieldofFireSprites) {</b>
<b class="nc">&nbsp;            spr.prepare();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        updateFontSizes();</b>
<b class="nc">&nbsp;        updateBoard();</b>
<b class="nc">&nbsp;        for (StepSprite sprite : pathSprites) {</b>
<b class="nc">&nbsp;            sprite.refreshZoomLevel();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (FiringSolutionSprite sprite : firingSprites) {</b>
<b class="nc">&nbsp;            sprite.prepare();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        this.setSize(boardSize);</b>
&nbsp;
<b class="nc">&nbsp;        clearHexImageCache();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void updateFontSizes() {
<b class="nc">&nbsp;        if (zoomIndex &lt;= 4) {</b>
<b class="nc">&nbsp;            font_elev = FONT_7;</b>
<b class="nc">&nbsp;            font_hexnum = FONT_7;</b>
<b class="nc">&nbsp;            font_minefield = FONT_7;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((zoomIndex &lt;= 5) &amp; (zoomIndex &gt; 4)) {</b>
<b class="nc">&nbsp;            font_elev = FONT_8;</b>
<b class="nc">&nbsp;            font_hexnum = FONT_8;</b>
<b class="nc">&nbsp;            font_minefield = FONT_8;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (zoomIndex &gt; 5) {</b>
<b class="nc">&nbsp;            font_elev = FONT_9;</b>
<b class="nc">&nbsp;            font_hexnum = FONT_9;</b>
<b class="nc">&nbsp;            font_minefield = FONT_9;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Return a scaled version of the input.  If the useCache flag is set, the
&nbsp;     * scaled image will be stored in an image cache for later retrieval.
&nbsp;     *
&nbsp;     * @param base     The image to get a scaled copy of.  The current zoom level
&nbsp;     *                 is used to determine the scale.
&nbsp;     * @param useCache This flag determines whether the scaled image should
&nbsp;     *                 be stored in a cache for later retrieval.
&nbsp;     */
&nbsp;    Image getScaledImage(Image base, boolean useCache) {
<b class="nc">&nbsp;        if (base == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (zoomIndex == BASE_ZOOM_INDEX) {</b>
<b class="nc">&nbsp;            return base;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        Image scaled;
<b class="nc">&nbsp;        if (useCache) {</b>
&nbsp;            // Check the cache
<b class="nc">&nbsp;            scaled = scaledImageCache.get(base.hashCode());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            scaled = null;</b>
&nbsp;        }
&nbsp;        // Compute the scaled image
<b class="nc">&nbsp;        if (scaled == null) {</b>
<b class="nc">&nbsp;            MediaTracker tracker = new MediaTracker(this);</b>
<b class="nc">&nbsp;            if ((base.getWidth(null) == -1) || (base.getHeight(null) == -1)) {</b>
<b class="nc">&nbsp;                tracker.addImage(base, 0);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    tracker.waitForID(0);</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    e.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (tracker.isErrorAny()) {</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                tracker.removeImage(base);</b>
&nbsp;            }
<b class="nc">&nbsp;            int width = (int) (base.getWidth(null) * scale);</b>
<b class="nc">&nbsp;            int height = (int) (base.getHeight(null) * scale);</b>
&nbsp;
<b class="nc">&nbsp;            if ((width &lt; 1) || (height &lt; 1)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            scaled = scale(base, width, height);</b>
<b class="nc">&nbsp;            tracker.addImage(scaled, 1);</b>
&nbsp;            // Wait for image to load
&nbsp;            try {
<b class="nc">&nbsp;                tracker.waitForID(1);</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                e.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            tracker.removeImage(scaled);</b>
&nbsp;            // Cache the image if the flag is set
<b class="nc">&nbsp;            if (useCache) {</b>
<b class="nc">&nbsp;                scaledImageCache.put(base.hashCode(), scaled);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return scaled;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The actual scaling code.
&nbsp;     */
&nbsp;    private Image scale(Image img, int width, int height) {
<b class="nc">&nbsp;        return ImageUtil.getScaledImage(img, width, height,</b>
&nbsp;                ZOOM_SCALE_TYPES[zoomIndex]);
&nbsp;    }
&nbsp;
&nbsp;    public boolean toggleIsometric() {
<b class="nc">&nbsp;        drawIsometric = !drawIsometric;</b>
<b class="nc">&nbsp;        for (Sprite spr : moveEnvSprites) spr.prepare();</b>
<b class="nc">&nbsp;        for (Sprite spr : moveModEnvSprites) spr.prepare();</b>
<b class="nc">&nbsp;        for (Sprite spr : fieldofFireSprites) spr.prepare();</b>
<b class="nc">&nbsp;        clearHexImageCache();</b>
<b class="nc">&nbsp;        updateBoard();</b>
<b class="nc">&nbsp;        for (MovementEnvelopeSprite sprite: moveEnvSprites)</b>
<b class="nc">&nbsp;            sprite.updateBounds();</b>
<b class="nc">&nbsp;        for (MovementModifierEnvelopeSprite sprite: moveModEnvSprites)</b>
<b class="nc">&nbsp;            sprite.updateBounds();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;        return drawIsometric;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void updateEntityLabels() {
<b class="nc">&nbsp;        for (Entity e: game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            e.generateShortName();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (EntitySprite eS: entitySprites) {</b>
<b class="nc">&nbsp;            eS.prepare();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    BufferedImage createShadowMask(Image image) {
<b class="nc">&nbsp;        int hashCode = image.hashCode();</b>
<b class="nc">&nbsp;        BufferedImage mask = shadowImageCache.get(hashCode);</b>
<b class="nc">&nbsp;        if (mask != null) {</b>
<b class="nc">&nbsp;            return mask;</b>
&nbsp;        }
<b class="nc">&nbsp;        mask = new BufferedImage(image.getWidth(null),</b>
<b class="nc">&nbsp;                image.getHeight(null), BufferedImage.TYPE_INT_ARGB);</b>
<b class="nc">&nbsp;        float opacity = 0.4f;</b>
<b class="nc">&nbsp;        Graphics2D g2d = mask.createGraphics();</b>
<b class="nc">&nbsp;        g2d.drawImage(image, 0, 0, null);</b>
<b class="nc">&nbsp;        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_IN,</b>
&nbsp;                                                    opacity));
<b class="nc">&nbsp;        g2d.setColor(Color.BLACK);</b>
<b class="nc">&nbsp;        g2d.fillRect(0, 0, image.getWidth(null), image.getHeight(null));</b>
<b class="nc">&nbsp;        g2d.dispose();</b>
<b class="nc">&nbsp;        shadowImageCache.put(hashCode, mask);</b>
<b class="nc">&nbsp;        return mask;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void die() {
<b class="nc">&nbsp;        ourTask.cancel();</b>
<b class="nc">&nbsp;        fovHighlightingAndDarkening.die();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the BoardView has an active chatter box else false.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean getChatterBoxActive() {
<b class="nc">&nbsp;        return chatterBoxActive;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets whether the BoardView has an active chatter box or not.
&nbsp;     *
&nbsp;     * @param cba
&nbsp;     */
&nbsp;    public void setChatterBoxActive(boolean cba) {
<b class="nc">&nbsp;        chatterBoxActive = cba;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setShouldIgnoreKeys(boolean shouldIgnoreKeys) {
<b class="nc">&nbsp;        this.shouldIgnoreKeys = shouldIgnoreKeys;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean imageUpdate(Image img, int flags, int x, int y, int w, int h) {
&nbsp;        // If FRAMEBITS is set, then new frame from a multi-frame image is ready
&nbsp;        // This indicates an animated image, which shouldn&#39;t be cached
<b class="nc">&nbsp;        if ((flags &amp; ImageObserver.FRAMEBITS) != 0) {</b>
<b class="nc">&nbsp;            animatedImages.add(img.hashCode());</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.imageUpdate(img, flags, x, y, w, h);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void clearHexImageCache() {
<b class="nc">&nbsp;        hexImageCache.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clear a specific list of Coords from the hex image cache.
&nbsp;     * @param coords
&nbsp;     */
&nbsp;    public void clearHexImageCache(Set&lt;Coords&gt; coords) {
<b class="nc">&nbsp;        for (Coords c : coords) {</b>
<b class="nc">&nbsp;            hexImageCache.remove(c);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if the HexImageCache should be cleared because of
&nbsp;     * field-of-view changes.
&nbsp;     */
&nbsp;    public void checkFoVHexImageCacheClear() {
<b class="nc">&nbsp;        boolean darken = GUIPreferences.getInstance().getBoolean(</b>
&nbsp;                GUIPreferences.FOV_DARKEN);
<b class="nc">&nbsp;        boolean highlight = GUIPreferences.getInstance().getBoolean(</b>
&nbsp;                GUIPreferences.FOV_HIGHLIGHT);
<b class="nc">&nbsp;        if ((game.getPhase() == Phase.PHASE_MOVEMENT)</b>
&nbsp;                &amp;&amp; (darken || highlight)) {
<b class="nc">&nbsp;            clearHexImageCache();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Polygon getHexPoly() {
<b class="nc">&nbsp;        return hexPoly;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void clearFieldofF() {
<b class="nc">&nbsp;        fieldofFireWpArc = -1;</b>
<b class="nc">&nbsp;        fieldofFireUnit = null;</b>
<b class="nc">&nbsp;        fieldofFireSprites.clear();</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // this is called from MovementDisplay and checks if
&nbsp;    // the unit ends up underwater
&nbsp;    public void setWeaponFieldofFire(Entity ce, MovePath cmd) {
&nbsp;        // if lack of data: clear and return
<b class="nc">&nbsp;        if ((fieldofFireUnit == null)</b>
&nbsp;            || (ce == null)
&nbsp;            || (cmd == null)) {
<b class="nc">&nbsp;            clearFieldofF();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the field of fire is not dispalyed
&nbsp;        // for the active unit, then don&#39;t change anything
<b class="nc">&nbsp;        if (fieldofFireUnit.equals(ce)) {</b>
&nbsp;
<b class="nc">&nbsp;            fieldofFireWpUnderwater = 0;</b>
&nbsp;            // check if the weapon ends up underwater
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(cmd.getFinalCoords());</b>
&nbsp;
<b class="nc">&nbsp;            if ((hex.terrainLevel(Terrains.WATER) &gt; 0) &amp;&amp; !cmd.isJumping()</b>
<b class="nc">&nbsp;                    &amp;&amp; (cmd.getFinalElevation() &lt; 0)) {</b>
<b class="nc">&nbsp;                if ((fieldofFireUnit instanceof Mech) &amp;&amp; !fieldofFireUnit.isProne()</b>
<b class="nc">&nbsp;                        &amp;&amp; (hex.terrainLevel(Terrains.WATER) == 1)) {</b>
<b class="nc">&nbsp;                    if ((fieldofFireWpLoc == Mech.LOC_RLEG)</b>
&nbsp;                        || (fieldofFireWpLoc == Mech.LOC_LLEG))
<b class="nc">&nbsp;                        fieldofFireWpUnderwater = 1;</b>
&nbsp;
<b class="nc">&nbsp;                    if (fieldofFireUnit instanceof QuadMech) {</b>
<b class="nc">&nbsp;                        if ((fieldofFireWpLoc == Mech.LOC_RARM)</b>
&nbsp;                            || (fieldofFireWpLoc == Mech.LOC_LARM))
<b class="nc">&nbsp;                            fieldofFireWpUnderwater = 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (fieldofFireUnit instanceof TripodMech) {</b>
<b class="nc">&nbsp;                        if (fieldofFireWpLoc == Mech.LOC_CLEG)</b>
<b class="nc">&nbsp;                            fieldofFireWpUnderwater = 1;</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    fieldofFireWpUnderwater = 1;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            setWeaponFieldofFire(cmd.getFinalFacing(), cmd.getFinalCoords());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // prepares the sprites for a field of fire
&nbsp;    public void setWeaponFieldofFire(int fac, Coords c) {
<b class="nc">&nbsp;        if (fieldofFireUnit == null) {</b>
<b class="nc">&nbsp;            clearFieldofF();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Do not display anything for offboard units
<b class="nc">&nbsp;        if (fieldofFireUnit.isOffBoard()) {</b>
<b class="nc">&nbsp;            clearFieldofF();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check if extreme range is used
<b class="nc">&nbsp;        int maxrange = 4;</b>
<b class="nc">&nbsp;        if (game.getOptions().</b>
<b class="nc">&nbsp;                booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) maxrange = 5;</b>
&nbsp;
&nbsp;        // create the lists of hexes
<b class="nc">&nbsp;        List&lt;Set&lt;Coords&gt;&gt; fieldFire = new ArrayList&lt;Set&lt;Coords&gt;&gt;(5);</b>
<b class="nc">&nbsp;        int range = 1;</b>
&nbsp;        // for all available range brackets Min/S/M/L/E ...
<b class="nc">&nbsp;        for (int bracket = 0; bracket &lt; maxrange; bracket++) {</b>
<b class="nc">&nbsp;            fieldFire.add(new HashSet&lt;Coords&gt;());</b>
&nbsp;            // Add all hexes up to the weapon range to separate lists
<b class="nc">&nbsp;            while (range&lt;=fieldofFireRanges[fieldofFireWpUnderwater][bracket]) {</b>
<b class="nc">&nbsp;                fieldFire.get(bracket).addAll(c.allAtDistance(range));</b>
<b class="nc">&nbsp;                range++;</b>
<b class="nc">&nbsp;                if (range&gt;100) break; // only to avoid hangs</b>
&nbsp;            }
&nbsp;
&nbsp;            // Remove hexes that are not on the board or not in the arc
<b class="nc">&nbsp;            for (Iterator&lt;Coords&gt; iterator = fieldFire.get(bracket).iterator(); iterator.hasNext();) {</b>
<b class="nc">&nbsp;                Coords h = iterator.next();</b>
<b class="nc">&nbsp;                if (!game.getBoard().contains(h)</b>
<b class="nc">&nbsp;                        || !Compute.isInArc(c, fac, h, fieldofFireWpArc)) {</b>
<b class="nc">&nbsp;                    iterator.remove();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // create the sprites
&nbsp;        //
<b class="nc">&nbsp;        fieldofFireSprites.clear();</b>
&nbsp;
&nbsp;        // for all available range brackets Min/S/M/L/E ...
<b class="nc">&nbsp;        for (int bracket = 0; bracket &lt; fieldFire.size(); bracket++) {</b>
<b class="nc">&nbsp;            if (fieldFire.get(bracket) == null) continue;</b>
<b class="nc">&nbsp;            for (Coords loc : fieldFire.get(bracket)) {</b>
&nbsp;                // check surrounding hexes
<b class="nc">&nbsp;                int edgesToPaint = 0;</b>
<b class="nc">&nbsp;                for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                    Coords adjacentHex = loc.translated(dir);</b>
<b class="nc">&nbsp;                    if (!fieldFire.get(bracket).contains(adjacentHex)) edgesToPaint += (1 &lt;&lt; dir);</b>
&nbsp;                }
&nbsp;                // create sprite if there&#39;s a border to paint
<b class="nc">&nbsp;                if (edgesToPaint &gt; 0) {</b>
<b class="nc">&nbsp;                    FieldofFireSprite ffSprite = new FieldofFireSprite(</b>
&nbsp;                            this, bracket, loc, edgesToPaint);
<b class="nc">&nbsp;                    fieldofFireSprites.add(ffSprite);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // Add range markers (m, S, M, L, E)
&nbsp;            // this looks for a hex in the middle of the range bracket;
&nbsp;            // if outside the board, nearer hexes will be tried until
&nbsp;            // the inner edge of the range bracket is reached
&nbsp;            // the directions tested are those that fall between the
&nbsp;            // hex facings because this makes for a better placement
&nbsp;            // ... most of the time...
&nbsp;
&nbsp;            // The directions[][] is used to make the marker placement
&nbsp;            // fairly symmetrical to the unit facing which a simple for
&nbsp;            // loop over the hex facings doesn&#39;t do
<b class="nc">&nbsp;            int[][] directions = { {0,1},{0,5},{3,2},{3,4},{1,2},{5,4} };</b>
&nbsp;            // don&#39;t paint too many &quot;min&quot; markers
<b class="nc">&nbsp;            int numMinMarkers = 0;</b>
<b class="nc">&nbsp;            for (int[] dir: directions) {</b>
&nbsp;                // find the middle of the range bracket
<b class="nc">&nbsp;                int rangeend = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket],0);</b>
<b class="nc">&nbsp;                int rangebegin = 1;</b>
<b class="nc">&nbsp;                if (bracket&gt;0)</b>
<b class="nc">&nbsp;                    rangebegin = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket-1]+1,1);</b>
<b class="nc">&nbsp;                int dist = (rangeend + rangebegin)/2;</b>
&nbsp;                // translate to the middle of the range bracket
<b class="nc">&nbsp;                Coords mark = c.translated((dir[0]+fac)%6,(dist+1)/2)</b>
<b class="nc">&nbsp;                        .translated((dir[1]+fac)%6,dist/2);</b>
&nbsp;                // traverse back to the unit until a hex is onboard
<b class="nc">&nbsp;                while (!game.getBoard().contains(mark))</b>
<b class="nc">&nbsp;                    mark = Coords.nextHex(mark, c);</b>
&nbsp;
&nbsp;                // add a text range marker if the found position is good
<b class="nc">&nbsp;                if (game.getBoard().contains(mark) &amp;&amp; fieldFire.get(bracket).contains(mark)</b>
&nbsp;                        &amp;&amp; ((bracket &gt; 0) || (numMinMarkers &lt; 2))) {
<b class="nc">&nbsp;                    TextMarkerSprite tS = new TextMarkerSprite(this, mark,</b>
&nbsp;                            rangeTexts[bracket], FieldofFireSprite.fieldofFireColors[bracket]);
<b class="nc">&nbsp;                    fieldofFireSprites.add(tS);</b>
<b class="nc">&nbsp;                    if (bracket == 0) numMinMarkers++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** Displays a dialog and changes the theme of all
&nbsp;     *  board hexes to the user-chosen theme.
&nbsp;     */
&nbsp;    public void changeTheme() {
<b class="nc">&nbsp;        if (game == null) return;</b>
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
<b class="nc">&nbsp;        if (board.inSpace()) return;</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;String&gt; themes = tileManager.getThemes();</b>
<b class="nc">&nbsp;        if (themes.remove(&quot;&quot;)) themes.add(&quot;(No Theme)&quot;);</b>
<b class="nc">&nbsp;        themes.add(&quot;(Original Theme)&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        setShouldIgnoreKeys(true);</b>
<b class="nc">&nbsp;        selectedTheme = (String)JOptionPane.showInputDialog(</b>
&nbsp;                null,
&nbsp;                &quot;Choose the desired theme:&quot;,
&nbsp;                &quot;Theme Selection&quot;,
&nbsp;                JOptionPane.PLAIN_MESSAGE,
&nbsp;                null,
<b class="nc">&nbsp;                themes.toArray(),</b>
&nbsp;                selectedTheme);
<b class="nc">&nbsp;        setShouldIgnoreKeys(false);</b>
&nbsp;
<b class="nc">&nbsp;        if (selectedTheme == null) {</b>
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (selectedTheme.equals(&quot;(Original Theme)&quot;)) {</b>
<b class="nc">&nbsp;            selectedTheme = null;</b>
<b class="nc">&nbsp;        } else if (selectedTheme.equals(&quot;(No Theme)&quot;)) {</b>
<b class="nc">&nbsp;            selectedTheme = &quot;&quot;;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        board.setTheme(selectedTheme);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Image getBoardBackgroundHexImage(Coords c, IHex hex) {
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
<b class="nc">&nbsp;        if ((hex == null) || (board == null) || (hex.getTheme() == null)</b>
<b class="nc">&nbsp;                || !hex.getTheme().equals(HexTileset.TRANSPARENT_THEME)</b>
<b class="nc">&nbsp;                || !board.hasBoardBackground()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // Determine what sub-board the hex came from
<b class="nc">&nbsp;        int boardX = (int)((c.getX() + 0.0) / board.getSubBoardWidth());</b>
<b class="nc">&nbsp;        int boardY = (int)((c.getY() + 0.0) / board.getSubBoardHeight());</b>
<b class="nc">&nbsp;        int linIdx = boardY * board.getNumBoardsWidth() + boardX;</b>
<b class="nc">&nbsp;        if (linIdx &lt; 0 || linIdx &gt; boardBackgrounds.size() - 1) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;Error computing linear index or &quot;</b>
&nbsp;                    + &quot;missing background images &quot;
&nbsp;                    + &quot;in BoardView1.getBoardBackgroundHexImage!&quot;);
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Image bgImg = getScaledImage(boardBackgrounds.get(linIdx), true);</b>
<b class="nc">&nbsp;        int bgImgWidth = bgImg.getWidth(null);</b>
<b class="nc">&nbsp;        int bgImgHeight = bgImg.getHeight(null);</b>
&nbsp;
<b class="nc">&nbsp;        Point p1SRC = getHexLocationLargeTile(</b>
<b class="nc">&nbsp;                c.getX() - (boardX * board.getSubBoardWidth()),</b>
<b class="nc">&nbsp;                c.getY() - (boardY * board.getSubBoardHeight()));</b>
<b class="nc">&nbsp;        p1SRC.x = p1SRC.x % bgImgWidth;</b>
<b class="nc">&nbsp;        p1SRC.y = p1SRC.y % bgImgHeight;</b>
<b class="nc">&nbsp;        Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</b>
&nbsp;                (int) (p1SRC.y + HEX_H * scale));
<b class="nc">&nbsp;        Point p2DST = new Point((int) (HEX_W * scale),</b>
&nbsp;                (int) (HEX_H * scale));
&nbsp;
<b class="nc">&nbsp;        Image hexImage = new BufferedImage(HEX_W,  HEX_H,</b>
&nbsp;                BufferedImage.TYPE_INT_ARGB);
<b class="nc">&nbsp;        Graphics2D g = (Graphics2D)hexImage.getGraphics();</b>
&nbsp;
&nbsp;        // hex mask to limit drawing to the hex shape
&nbsp;        // TODO: this is not ideal yet but at least it draws
&nbsp;        // without leaving gaps at any zoom
<b class="nc">&nbsp;        Image hexMask = getScaledImage(tileManager.getHexMask(), true);</b>
<b class="nc">&nbsp;        g.drawImage(hexMask, 0, 0, this);</b>
<b class="nc">&nbsp;        Composite svComp = g.getComposite();</b>
<b class="nc">&nbsp;        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</b>
&nbsp;              1f));
&nbsp;
&nbsp;        // paint the right slice from the big pic
<b class="nc">&nbsp;        g.drawImage(bgImg, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</b>
&nbsp;                p2SRC.x, p2SRC.y, null);
&nbsp;
&nbsp;        // Handle wrapping of the image
<b class="nc">&nbsp;        if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &lt;= bgImgHeight) {</b>
<b class="nc">&nbsp;            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</b>
&nbsp;                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
&nbsp;                    null); // paint addtl slice on the left side
<b class="nc">&nbsp;        } else if (p2SRC.x &lt;= bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</b>
<b class="nc">&nbsp;            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</b>
&nbsp;                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
&nbsp;                    null); // paint addtl slice on the top
<b class="nc">&nbsp;        } else if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</b>
<b class="nc">&nbsp;            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</b>
&nbsp;                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
&nbsp;                    null); // paint addtl slice on the top
<b class="nc">&nbsp;            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</b>
&nbsp;                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
&nbsp;                    null); // paint addtl slice on the left side
&nbsp;            // paint addtl slice on the top left side
<b class="nc">&nbsp;            g.drawImage(bgImg, bgImgWidth - p1SRC.x,</b>
&nbsp;                    bgImgHeight - p1SRC.y, p2DST.x, p2DST.y, 0, 0,
&nbsp;                    p2SRC.x - bgImgWidth, p2SRC.y - bgImgHeight, null);
&nbsp;        }
<b class="nc">&nbsp;        g.setComposite(svComp);</b>
<b class="nc">&nbsp;        return hexImage;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDisplayInvalidHexInfo(boolean v) {
<b class="nc">&nbsp;        displayInvalidHexInfo = v;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getDisplayInvalidHexInfo() {
<b class="nc">&nbsp;        return displayInvalidHexInfo;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Rectangle getDisplayablesRect() {
<b class="nc">&nbsp;        return displayablesRect;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void toggleKeybindsOverlay() {
<b class="nc">&nbsp;        keybindOverlay.setVisible(!keybindOverlay.isVisible());</b>
<b class="nc">&nbsp;        repaint();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
