


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SharedUtility</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ui</a>
</div>

<h1>Coverage Summary for Class: SharedUtility (megamek.client.ui)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SharedUtility</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/513)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2008 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.client.ui;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import megamek.client.Client;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.EjectedCrew;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementMode;
&nbsp;import megamek.common.EntityMovementType;
&nbsp;import megamek.common.EscapePods;
&nbsp;import megamek.common.IAero;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.MoveStep;
&nbsp;import megamek.common.PilotingRollData;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.QuadVee;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.TeleMissile;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.VTOL;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.server.Server;
&nbsp;
<b class="nc">&nbsp;public class SharedUtility {</b>
&nbsp;
&nbsp;    public static String doPSRCheck(MovePath md) {
<b class="nc">&nbsp;        return (String) doPSRCheck(md, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static List&lt;TargetRoll&gt; getPSRList(MovePath md) {
&nbsp;        // certain types of entities, such as airborne aero units, do not require many of the checks
&nbsp;        // carried out in the full PSR Check. So, we call a method that skips most of those.
<b class="nc">&nbsp;        if(md.getEntity().isAirborne() &amp;&amp; md.getEntity().isAero()) {</b>
<b class="nc">&nbsp;            return (List&lt;TargetRoll&gt;) getAeroSpecificPSRList(md, false);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return (List&lt;TargetRoll&gt;) doPSRCheck(md, false);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Function that carries out PSR checks specific only to airborne aero units
&nbsp;     * @param md The path to check
&nbsp;     * @param stringResult Whether to return the report as a string
&nbsp;     * @return Collection of PSRs that will be required for this activity
&nbsp;     */
&nbsp;    private static Object getAeroSpecificPSRList(MovePath md, boolean stringResult) {
<b class="nc">&nbsp;        StringBuffer nagReport = new StringBuffer();</b>
<b class="nc">&nbsp;        List&lt;TargetRoll&gt; psrList = new ArrayList&lt;TargetRoll&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        final Entity entity = md.getEntity();</b>
<b class="nc">&nbsp;        final IGame game = entity.getGame();</b>
&nbsp;        // okay, proceed with movement calculations
<b class="nc">&nbsp;        Coords curPos = entity.getPosition();</b>
<b class="nc">&nbsp;        int curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;        EntityMovementType moveType = EntityMovementType.MOVE_NONE;</b>
<b class="nc">&nbsp;        EntityMovementType overallMoveType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        
&nbsp;        PilotingRollData rollTarget;
&nbsp;
&nbsp;        // Compile the move
<b class="nc">&nbsp;        md.clipToPossible();</b>
&nbsp;
<b class="nc">&nbsp;        overallMoveType = md.getLastStepMovementType();</b>
&nbsp;
&nbsp;        // iterate through steps
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
&nbsp;            
&nbsp;            // stop for illegal movement
<b class="nc">&nbsp;            if (step.getMovementType(md.isEndStep(step)) == EntityMovementType.MOVE_ILLEGAL) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for more than one roll
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            rollTarget = a.checkRolls(step, overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
<b class="nc">&nbsp;            rollTarget = a.checkManeuver(step, overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // set most step parameters
<b class="nc">&nbsp;            moveType = step.getMovementType(md.isEndStep(step));</b>
&nbsp;
&nbsp;            // set last step parameters
<b class="nc">&nbsp;            curPos = step.getPosition();</b>
<b class="nc">&nbsp;            curFacing = step.getFacing();</b>
&nbsp;
&nbsp;            //check for vertical takeoff
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.VTAKEOFF) {</b>
<b class="nc">&nbsp;                rollTarget = ((IAero)entity).checkVerticalTakeOff();</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            //check for landing
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.LAND) {</b>
<b class="nc">&nbsp;                rollTarget = ((IAero) entity).checkLanding(moveType,</b>
<b class="nc">&nbsp;                        step.getVelocity(), curPos, curFacing, false);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.VLAND) {</b>
<b class="nc">&nbsp;                rollTarget = ((IAero) entity).checkLanding(moveType,</b>
<b class="nc">&nbsp;                        step.getVelocity(), curPos, curFacing, true);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Check for Ejecting
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.EJECT </b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.isFighter())) {</b>
<b class="nc">&nbsp;                rollTarget = Server.getEjectModifiers(game, entity, 0, false);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check to see if thrust exceeded SI
<b class="nc">&nbsp;        IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;        int thrust = md.getMpUsed();</b>
<b class="nc">&nbsp;        rollTarget = a.checkThrustSITotal(thrust, overallMoveType);</b>
<b class="nc">&nbsp;        checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;        // Atmospheric checks
<b class="nc">&nbsp;        if (!game.getBoard().inSpace() &amp;&amp; !md.contains(MoveStepType.LAND)</b>
<b class="nc">&nbsp;                &amp;&amp; !md.contains(MoveStepType.VLAND)) {</b>
&nbsp;            // check to see if velocity is 2x thrust
<b class="nc">&nbsp;            rollTarget = a.checkVelocityDouble(md.getFinalVelocity(),</b>
&nbsp;                    overallMoveType);
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // check to see if descended more than two hexes
<b class="nc">&nbsp;            rollTarget = a.checkDown(md.getFinalNDown(), overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // stalling out
<b class="nc">&nbsp;            rollTarget = a.checkStall(md);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // check for hovering
<b class="nc">&nbsp;            rollTarget = a.checkHover(md);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (stringResult) {</b>
<b class="nc">&nbsp;            return nagReport.toString();</b>
&nbsp;        }
<b class="nc">&nbsp;        return psrList;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Checks to see if piloting skill rolls are needed for the currently
&nbsp;     * selected movement. This code is basically a simplified version of
&nbsp;     * Server.processMovement(), except that it just reads information (no
&nbsp;     * writing). Note that MovePath.clipToPossible() is called though, which
&nbsp;     * changes the md object.
&nbsp;     */
&nbsp;    private static Object doPSRCheck(MovePath md, boolean stringResult) {
&nbsp;
<b class="nc">&nbsp;        StringBuffer nagReport = new StringBuffer();</b>
<b class="nc">&nbsp;        List&lt;TargetRoll&gt; psrList = new ArrayList&lt;TargetRoll&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        final Entity entity = md.getEntity();</b>
<b class="nc">&nbsp;        final IGame game = entity.getGame();</b>
&nbsp;        // okay, proceed with movement calculations
<b class="nc">&nbsp;        Coords lastPos = entity.getPosition();</b>
<b class="nc">&nbsp;        Coords curPos = entity.getPosition();</b>
<b class="nc">&nbsp;        int lastElevation = entity.getElevation();</b>
<b class="nc">&nbsp;        int curElevation = entity.getElevation();</b>
<b class="nc">&nbsp;        int curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;        int distance = 0;</b>
<b class="nc">&nbsp;        EntityMovementType moveType = EntityMovementType.MOVE_NONE;</b>
<b class="nc">&nbsp;        EntityMovementType overallMoveType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        boolean firstStep;
<b class="nc">&nbsp;        int prevFacing = curFacing;</b>
<b class="nc">&nbsp;        IHex prevHex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;        final boolean isInfantry = (entity instanceof Infantry);</b>
&nbsp;
&nbsp;        PilotingRollData rollTarget;
&nbsp;
&nbsp;        // Compile the move
<b class="nc">&nbsp;        md.clipToPossible();</b>
&nbsp;
<b class="nc">&nbsp;        overallMoveType = md.getLastStepMovementType();</b>
&nbsp;
&nbsp;        // iterate through steps
<b class="nc">&nbsp;        firstStep = true;</b>
&nbsp;        /* Bug 754610: Revert fix for bug 702735. */
<b class="nc">&nbsp;        MoveStep prevStep = null;</b>
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;            boolean isPavementStep = step.isPavementStep();</b>
&nbsp;
&nbsp;            // stop for illegal movement
<b class="nc">&nbsp;            if (step.getMovementType(md.isEndStep(step)) == EntityMovementType.MOVE_ILLEGAL) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.isAirborne() &amp;&amp; entity.isAero()) {</b>
&nbsp;                // check for more than one roll
<b class="nc">&nbsp;                IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                rollTarget = a.checkRolls(step, overallMoveType);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
<b class="nc">&nbsp;                rollTarget = a.checkManeuver(step, overallMoveType);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check piloting skill for getting up
<b class="nc">&nbsp;            rollTarget = entity.checkGetUp(step, overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // set most step parameters
<b class="nc">&nbsp;            moveType = step.getMovementType(md.isEndStep(step));</b>
<b class="nc">&nbsp;            distance = step.getDistance();</b>
&nbsp;
&nbsp;            // set last step parameters
<b class="nc">&nbsp;            curPos = step.getPosition();</b>
<b class="nc">&nbsp;            curFacing = step.getFacing();</b>
<b class="nc">&nbsp;            curElevation = step.getElevation();</b>
&nbsp;
<b class="nc">&nbsp;            final IHex curHex = game.getBoard().getHex(curPos);</b>
&nbsp;
&nbsp;            //check for vertical takeoff
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.VTAKEOFF)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;                rollTarget = ((IAero)entity).checkVerticalTakeOff();</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            //check for landing
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.LAND)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;                rollTarget = ((IAero) entity).checkLanding(moveType,</b>
<b class="nc">&nbsp;                        step.getVelocity(), curPos, curFacing, false);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.VLAND)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;                rollTarget = ((IAero) entity).checkLanding(moveType,</b>
<b class="nc">&nbsp;                        step.getVelocity(), curPos, curFacing, true);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for leap
<b class="nc">&nbsp;            if (!lastPos.equals(curPos) &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP) &amp;&amp; (entity instanceof Mech)</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isAirborne() &amp;&amp; (step.getClearance() &lt;= 0) // Don&#39;t check airborne LAMs</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEAPING)) {</b>
<b class="nc">&nbsp;                int leapDistance = (lastElevation + game.getBoard().getHex(lastPos).getLevel())</b>
<b class="nc">&nbsp;                        - (curElevation + curHex.getLevel());</b>
<b class="nc">&nbsp;                if (leapDistance &gt; 2) {</b>
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                    entity.addPilotingModifierForTerrain(rollTarget, curPos);</b>
<b class="nc">&nbsp;                    rollTarget.append(new PilotingRollData(entity.getId(), 2 * leapDistance, &quot;leaping (leg damage)&quot;));</b>
<b class="nc">&nbsp;                    SharedUtility.checkNag(rollTarget, nagReport, psrList);</b>
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                    entity.addPilotingModifierForTerrain(rollTarget, curPos);</b>
<b class="nc">&nbsp;                    rollTarget.append(new PilotingRollData(entity.getId(), leapDistance, &quot;leaping (fall)&quot;));</b>
<b class="nc">&nbsp;                    SharedUtility.checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Check for skid.
<b class="nc">&nbsp;            rollTarget = entity.checkSkid(moveType, prevHex, overallMoveType,</b>
&nbsp;                    prevStep, step, prevFacing, curFacing, lastPos, curPos,
&nbsp;                    isInfantry, distance - 1);
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // check if we&#39;ve moved into rubble
<b class="nc">&nbsp;            boolean isLastStep = md.getLastStep().equals(step);</b>
<b class="nc">&nbsp;            rollTarget = entity.checkRubbleMove(step, overallMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, isLastStep, isPavementStep);
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            
&nbsp;            
&nbsp;
<b class="nc">&nbsp;            int lightPenalty = entity.getGame().getPlanetaryConditions()</b>
<b class="nc">&nbsp;                    .getLightPilotPenalty();</b>
<b class="nc">&nbsp;            if (lightPenalty &gt; 0) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(lightPenalty, entity.getGame()</b>
<b class="nc">&nbsp;                        .getPlanetaryConditions().getLightDisplayableName());</b>
&nbsp;            }
&nbsp;
&nbsp;            //check if we are moving recklessly
<b class="nc">&nbsp;            rollTarget = entity.checkRecklessMove(step, overallMoveType,</b>
&nbsp;                    curHex, lastPos, curPos, prevHex);
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // check for crossing ice
<b class="nc">&nbsp;            if (curHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;                    &amp;&amp; curHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(curPos.equals(lastPos))</b>
<b class="nc">&nbsp;                    &amp;&amp; (step.getElevation() == 0)</b>
&nbsp;                    &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP)
&nbsp;                    &amp;&amp; !(entity instanceof Infantry)
&nbsp;                    &amp;&amp; !(isPavementStep &amp;&amp; curHex
<b class="nc">&nbsp;                            .containsTerrain(Terrains.BRIDGE))) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages.getString(&quot;MovementDisplay.IceMoving&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // check if we&#39;ve moved into water
<b class="nc">&nbsp;            rollTarget = entity.checkWaterMove(step, overallMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, isPavementStep);
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // check for non-mech entering a fire
<b class="nc">&nbsp;            boolean underwater = curHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (curHex.depth() &gt; 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (step.getElevation() &lt; curHex.surface());</b>
<b class="nc">&nbsp;            if (curHex.containsTerrain(Terrains.FIRE) &amp;&amp; !underwater</b>
<b class="nc">&nbsp;                    &amp;&amp; !(entity instanceof Mech) &amp;&amp; (step.getElevation() &lt;= 1)</b>
&nbsp;                    &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                    &amp;&amp; !(curPos.equals(lastPos))) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages.getString(</b>
&nbsp;                        &quot;MovementDisplay.FireMoving&quot;,
<b class="nc">&nbsp;                        new Object[] { Integer.valueOf(8) }));</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for magma
<b class="nc">&nbsp;            int level = curHex.terrainLevel(Terrains.MAGMA);</b>
<b class="nc">&nbsp;            if ((level == 1) &amp;&amp; (step.getElevation() == 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
&nbsp;                    &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                    &amp;&amp; !(curPos.equals(lastPos))) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;MovementDisplay.MagmaCrustMoving&quot;));</b>
<b class="nc">&nbsp;            } else if ((level == 2) &amp;&amp; (step.getElevation() == 0)</b>
&nbsp;                    &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                    &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(curPos.equals(lastPos))) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;MovementDisplay.MagmaLiquidMoving&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for sideslip
<b class="nc">&nbsp;            if ((entity instanceof VTOL)</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                            &amp;&amp; step.getClearance() &gt; 0)) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkSideSlip(moveType, prevHex,</b>
&nbsp;                        overallMoveType, prevStep, prevFacing, curFacing,
&nbsp;                        lastPos, curPos, distance);
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check if we&#39;ve moved into swamp
<b class="nc">&nbsp;            rollTarget = entity.checkBogDown(step, overallMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, lastElevation, isPavementStep);
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // Check if used more MPs than Mech/Vehicle would have w/o gravity
<b class="nc">&nbsp;            if (!i.hasMoreElements() &amp;&amp; !firstStep) {</b>
<b class="nc">&nbsp;                if ((entity instanceof Mech) || (entity instanceof Tank)) {</b>
<b class="nc">&nbsp;                    if ((moveType == EntityMovementType.MOVE_WALK)</b>
&nbsp;                            || (moveType == EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                            || (moveType == EntityMovementType.MOVE_RUN)
&nbsp;                            || (moveType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                            || (moveType == EntityMovementType.MOVE_SPRINT)
&nbsp;                            || (moveType == EntityMovementType.MOVE_VTOL_SPRINT)) {
<b class="nc">&nbsp;                        int limit = entity.getRunningGravityLimit();</b>
<b class="nc">&nbsp;                        if (step.isOnlyPavement() &amp;&amp; entity.isEligibleForPavementBonus()) {</b>
<b class="nc">&nbsp;                            limit++;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (step.getMpUsed() &gt; limit) {</b>
<b class="nc">&nbsp;                            rollTarget = entity.checkMovedTooFast(step, overallMoveType);</b>
<b class="nc">&nbsp;                            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (moveType == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;                        int origWalkMP = entity.getWalkMP(false, false);</b>
<b class="nc">&nbsp;                        int gravWalkMP = entity.getWalkMP();</b>
<b class="nc">&nbsp;                        if (step.getMpUsed() &gt; entity.getJumpMP(false)) {</b>
<b class="nc">&nbsp;                            rollTarget = entity.checkMovedTooFast(step, overallMoveType);</b>
<b class="nc">&nbsp;                            checkNag(rollTarget, nagReport, psrList);</b>
<b class="nc">&nbsp;                        } else if ((game.getPlanetaryConditions().getGravity() &gt; 1)</b>
&nbsp;                                &amp;&amp; ((origWalkMP - gravWalkMP) &gt; 0)) {
<b class="nc">&nbsp;                            rollTarget = entity.getBasePilotingRoll(md.getLastStepMovementType());</b>
<b class="nc">&nbsp;                            entity.addPilotingModifierForTerrain(rollTarget, step);</b>
<b class="nc">&nbsp;                            int gravMod = game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                    .getGravityPilotPenalty();</b>
<b class="nc">&nbsp;                            if ((gravMod != 0) &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                                rollTarget.addModifier(gravMod, game</b>
<b class="nc">&nbsp;                                        .getPlanetaryConditions().getGravity()</b>
&nbsp;                                        + &quot;G gravity&quot;);
&nbsp;                            }
<b class="nc">&nbsp;                            rollTarget.append(new PilotingRollData(entity</b>
<b class="nc">&nbsp;                                    .getId(), 0, &quot;jumped in high gravity&quot;));</b>
<b class="nc">&nbsp;                            SharedUtility.checkNag(rollTarget, nagReport,</b>
&nbsp;                                    psrList);
&nbsp;                        }
<b class="nc">&nbsp;                        if (step.getMpUsed() &gt; entity.getSprintMP(false, false, false)) {</b>
<b class="nc">&nbsp;                            rollTarget = entity.checkMovedTooFast(step, overallMoveType);</b>
<b class="nc">&nbsp;                            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Sheer Cliffs, TO p.39
&nbsp;            // Roads over cliffs cancel the cliff effects for units that move on roads
<b class="nc">&nbsp;            boolean vehicleAffectedByCliff = entity instanceof Tank </b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isAirborneVTOLorWIGE();</b>
<b class="nc">&nbsp;            boolean quadveeVehMode = entity instanceof QuadVee</b>
<b class="nc">&nbsp;                    &amp;&amp; ((QuadVee)entity).getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</b>
<b class="nc">&nbsp;            boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech)</b>
&nbsp;                    &amp;&amp; moveType != EntityMovementType.MOVE_JUMP
<b class="nc">&nbsp;                    &amp;&amp; !entity.isAero();</b>
&nbsp;            // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
&nbsp;            // Everything that does not have a 1 or 2 level drop shouldn&#39;t be handled as a cliff
<b class="nc">&nbsp;            int stepHeight = curElevation + curHex.getLevel() </b>
<b class="nc">&nbsp;                    - (lastElevation + prevHex.getLevel());</b>
<b class="nc">&nbsp;            boolean isUpCliff = !lastPos.equals(curPos) </b>
<b class="nc">&nbsp;                    &amp;&amp; curHex.hasCliffTopTowards(prevHex)</b>
&nbsp;                    &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<b class="nc">&nbsp;            boolean isDownCliff = !lastPos.equals(curPos) </b>
<b class="nc">&nbsp;                    &amp;&amp; prevHex.hasCliffTopTowards(curHex)</b>
&nbsp;                    &amp;&amp; (stepHeight == -1 || stepHeight == -2);
&nbsp;
&nbsp;            // Vehicles (exc. WIGE/VTOL) moving down a cliff
<b class="nc">&nbsp;            if (vehicleAffectedByCliff &amp;&amp; isDownCliff &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                rollTarget.append(new PilotingRollData(entity.getId(), 0, &quot;moving down a sheer cliff&quot;));</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Mechs moving down a cliff
&nbsp;            // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133
&nbsp;            // Protomechs as Meks
<b class="nc">&nbsp;            if (mechAffectedByCliff &amp;&amp; !quadveeVehMode &amp;&amp; isDownCliff &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                rollTarget.append(new PilotingRollData(entity.getId(), -stepHeight - 1, &quot;moving down a sheer cliff&quot;));</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Mechs moving up a cliff
<b class="nc">&nbsp;            if (mechAffectedByCliff &amp;&amp; !quadveeVehMode &amp;&amp; isUpCliff &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                rollTarget.append(new PilotingRollData(entity.getId(), stepHeight, &quot;moving up a sheer cliff&quot;));</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Handle non-infantry moving into a building.
<b class="nc">&nbsp;            int buildingMove = entity.checkMovementInBuilding(step, prevStep,</b>
&nbsp;                    curPos, lastPos);
<b class="nc">&nbsp;            if ((buildingMove &gt; 1) &amp;&amp; !(entity instanceof Protomech)) {</b>
&nbsp;
&nbsp;                // Get the building being entered.
<b class="nc">&nbsp;                Building bldg = null;</b>
<b class="nc">&nbsp;                String reason =&quot;entering&quot;;</b>
<b class="nc">&nbsp;                if ((buildingMove &amp; 2) == 2) {</b>
<b class="nc">&nbsp;                    bldg = game.getBoard().getBuildingAt(curPos);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (bldg != null) {</b>
<b class="nc">&nbsp;                    rollTarget = entity.rollMovementInBuilding(bldg, distance,</b>
&nbsp;                            reason, overallMoveType);
<b class="nc">&nbsp;                    SharedUtility.checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.GO_PRONE) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkDislodgeSwarmers(step, overallMoveType);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            IHex lastHex = game.getBoard().getHex(lastPos);</b>
<b class="nc">&nbsp;            if (((step.getType() == MoveStepType.BACKWARDS)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS))</b>
<b class="nc">&nbsp;                    &amp;&amp; !(md.isJumping() &amp;&amp; (entity.getJumpType() == Mech.JUMP_BOOSTER))</b>
<b class="nc">&nbsp;                    &amp;&amp; (lastHex.getLevel() + lastElevation != (curHex.getLevel() + step.getElevation()))</b>
&nbsp;                    &amp;&amp; !(entity instanceof VTOL)
<b class="nc">&nbsp;                    &amp;&amp; !(md.getFinalClimbMode()</b>
<b class="nc">&nbsp;                            &amp;&amp; curHex.containsTerrain(Terrains.BRIDGE) &amp;&amp; ((curHex</b>
<b class="nc">&nbsp;                            .terrainLevel(Terrains.BRIDGE_ELEV) + curHex</b>
<b class="nc">&nbsp;                            .getLevel()) == (prevHex.getLevel() + (prevHex</b>
<b class="nc">&nbsp;                            .containsTerrain(Terrains.BRIDGE) ? prevHex</b>
<b class="nc">&nbsp;                            .terrainLevel(Terrains.BRIDGE_ELEV) : 0))))) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;MovementDisplay.BackWardsElevationChange&quot;));</b>
<b class="nc">&nbsp;                SharedUtility.checkNag(</b>
<b class="nc">&nbsp;                        entity.getBasePilotingRoll(overallMoveType), nagReport,</b>
&nbsp;                        psrList);
&nbsp;            }
&nbsp;            
&nbsp;            // Check for Ejecting
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.EJECT </b>
&nbsp;                    &amp;&amp; (entity instanceof Mech)) {
<b class="nc">&nbsp;                rollTarget = Server.getEjectModifiers(game, entity, 0, false);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.UNLOAD) {</b>
<b class="nc">&nbsp;                Targetable targ = step.getTarget(game);</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_ZIPLINES)</b>
&nbsp;                        &amp;&amp; (entity instanceof VTOL)
<b class="nc">&nbsp;                        &amp;&amp; (md.getFinalElevation() &gt; 0)</b>
&nbsp;                        &amp;&amp; (targ instanceof Infantry)
<b class="nc">&nbsp;                        &amp;&amp; (((Entity)targ).getJumpMP() &lt; 1)</b>
<b class="nc">&nbsp;                        &amp;&amp; !((Infantry) targ).isMechanized()) {</b>
<b class="nc">&nbsp;                    rollTarget = Server.getEjectModifiers(game, (Entity) targ, 0,</b>
<b class="nc">&nbsp;                            false, entity.getPosition(), &quot;zip lining&quot;);</b>
&nbsp;                    // Factor in Elevation
<b class="nc">&nbsp;                    if (entity.getElevation() &gt; 0) {</b>
<b class="nc">&nbsp;                        rollTarget.addModifier(entity.getElevation(), &quot;elevation&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (step.isTurning()) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkTurnModeFailure(overallMoveType,</b>
<b class="nc">&nbsp;                        prevStep == null? 0 : prevStep.getNStraight(), md.getMpUsed(), curPos);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.BOOTLEGGER) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
<b class="nc">&nbsp;                entity.addPilotingModifierForTerrain(rollTarget);</b>
<b class="nc">&nbsp;                rollTarget.addModifier(0, &quot;bootlegger maneuver&quot;);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;
&nbsp;            // update lastPos, prevStep, prevFacing &amp; prevHex
<b class="nc">&nbsp;            if (!curPos.equals(lastPos)) {</b>
<b class="nc">&nbsp;                prevFacing = curFacing;</b>
&nbsp;            }
<b class="nc">&nbsp;            lastPos = curPos;</b>
<b class="nc">&nbsp;            prevStep = step;</b>
<b class="nc">&nbsp;            prevHex = curHex;</b>
<b class="nc">&nbsp;            lastElevation = step.getElevation();</b>
&nbsp;
<b class="nc">&nbsp;            firstStep = false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // running with destroyed hip or gyro needs a check
<b class="nc">&nbsp;        rollTarget = entity.checkRunningWithDamage(overallMoveType);</b>
<b class="nc">&nbsp;        checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;        //if we sprinted with MASC or a supercharger, then we need a PSR
<b class="nc">&nbsp;        rollTarget = entity.checkSprintingWithMASC(overallMoveType, md.getMpUsed());</b>
<b class="nc">&nbsp;        checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
<b class="nc">&nbsp;        rollTarget = entity.checkSprintingWithSupercharger(overallMoveType, md.getMpUsed());</b>
<b class="nc">&nbsp;        checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
<b class="nc">&nbsp;        rollTarget = entity.checkUsingOverdrive(overallMoveType);</b>
<b class="nc">&nbsp;        checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            
<b class="nc">&nbsp;        rollTarget = entity.checkGunningIt(overallMoveType);</b>
<b class="nc">&nbsp;        checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;        // but the danger isn&#39;t over yet! landing from a jump can be risky!
<b class="nc">&nbsp;        if ((overallMoveType == EntityMovementType.MOVE_JUMP) &amp;&amp; !entity.isMakingDfa()) {</b>
&nbsp;            // check for damaged criticals
<b class="nc">&nbsp;            rollTarget = entity.checkLandingWithDamage(overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            // check for landing with prototype JJs
<b class="nc">&nbsp;            rollTarget = entity.checkLandingWithPrototypeJJ(overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            // jumped into water?
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(curPos);</b>
&nbsp;            // check for jumping into heavy woods
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_PSR_JUMP_HEAVY_WOODS)) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkLandingInHeavyWoods(overallMoveType,</b>
&nbsp;                        hex);
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
<b class="nc">&nbsp;            int waterLevel = hex.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.ICE) &amp;&amp; (waterLevel &gt; 0)) {</b>
<b class="nc">&nbsp;                if(!(entity instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    nagReport.append(Messages.getString(&quot;MovementDisplay.IceLanding&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (!(prevStep.climbMode() &amp;&amp; hex.containsTerrain(Terrains.BRIDGE))) {</b>
<b class="nc">&nbsp;                if (!(entity.getMovementMode() == EntityMovementMode.HOVER)) {</b>
<b class="nc">&nbsp;                    rollTarget = entity.checkWaterMove(waterLevel, overallMoveType);</b>
<b class="nc">&nbsp;                    checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            
&nbsp;            // check for magma
<b class="nc">&nbsp;            int level = hex.terrainLevel(Terrains.MAGMA);</b>
<b class="nc">&nbsp;            if ((level == 1) &amp;&amp; (lastElevation == 0)) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages.getString(&quot;MovementDisplay.MagmaCrustJumpLanding&quot;));</b>
<b class="nc">&nbsp;            } else if ((level == 2) &amp;&amp; (lastElevation == 0)) {</b>
<b class="nc">&nbsp;                nagReport.append(Messages.getString(&quot;MovementDisplay.MagmaLiquidMoving&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.isAirborne() &amp;&amp; entity.isAero()) {</b>
&nbsp;            // check to see if thrust exceeded SI
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            int thrust = md.getMpUsed();</b>
<b class="nc">&nbsp;            rollTarget = a.checkThrustSITotal(thrust, overallMoveType);</b>
<b class="nc">&nbsp;            checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;            // Atmospheric checks
<b class="nc">&nbsp;            if (!game.getBoard().inSpace() &amp;&amp; !md.contains(MoveStepType.LAND)</b>
<b class="nc">&nbsp;                    &amp;&amp; !md.contains(MoveStepType.VLAND)) {</b>
&nbsp;                // check to see if velocity is 2x thrust
<b class="nc">&nbsp;                rollTarget = a.checkVelocityDouble(md.getFinalVelocity(),</b>
&nbsp;                        overallMoveType);
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;                // check to see if descended more than two hexes
<b class="nc">&nbsp;                rollTarget = a.checkDown(md.getFinalNDown(), overallMoveType);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;                // stalling out
<b class="nc">&nbsp;                rollTarget = a.checkStall(md);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;                // check for hovering
<b class="nc">&nbsp;                rollTarget = a.checkHover(md);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (stringResult) {</b>
<b class="nc">&nbsp;            return nagReport.toString();</b>
&nbsp;        }
<b class="nc">&nbsp;        return psrList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param rollTarget
&nbsp;     * @param nagReport
&nbsp;     * @param psrList
&nbsp;     */
&nbsp;    private static void checkNag(PilotingRollData rollTarget,
&nbsp;            StringBuffer nagReport, List&lt;TargetRoll&gt; psrList) {
<b class="nc">&nbsp;        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;            psrList.add(rollTarget);</b>
<b class="nc">&nbsp;            Object[] objs = new Object[] { rollTarget.getValueAsString(),</b>
<b class="nc">&nbsp;                    rollTarget.getDesc() };</b>
<b class="nc">&nbsp;            nagReport</b>
<b class="nc">&nbsp;                    .append(Messages.getString(&quot;MovementDisplay.addNag&quot;, objs));//$NON-NLS-1$</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if piloting skill rolls are needed for excessive use of
&nbsp;     * thrust.
&nbsp;     */
&nbsp;    public static String doThrustCheck(MovePath md, Client client) {
&nbsp;
<b class="nc">&nbsp;        StringBuffer nagReport = new StringBuffer();</b>
<b class="nc">&nbsp;        List&lt;TargetRoll&gt; psrList = new ArrayList&lt;TargetRoll&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        if(client.getGame().useVectorMove()) {</b>
<b class="nc">&nbsp;            return nagReport.toString();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Entity entity = md.getEntity();</b>
<b class="nc">&nbsp;        if(!entity.isAero()) {</b>
<b class="nc">&nbsp;            return nagReport.toString();</b>
&nbsp;        }
<b class="nc">&nbsp;        EntityMovementType overallMoveType = EntityMovementType.MOVE_NONE;</b>
&nbsp;
<b class="nc">&nbsp;        IAero a = (IAero) entity;</b>
&nbsp;
&nbsp;        PilotingRollData rollTarget;
&nbsp;
<b class="nc">&nbsp;        overallMoveType = md.getLastStepMovementType();</b>
&nbsp;
&nbsp;        // cycle through movement. Collect thrust used until position changes.
<b class="nc">&nbsp;        int thrustUsed = 0;</b>
<b class="nc">&nbsp;        int j = 0;</b>
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;            j++;</b>
&nbsp;            // how do I figure out last step?
<b class="nc">&nbsp;            if ((step.getDistance() == 0) &amp;&amp; (md.length() != j)) {</b>
<b class="nc">&nbsp;                thrustUsed += step.getMp();</b>
&nbsp;            } else {
&nbsp;                // if this was the last move and distance was zero, then add
&nbsp;                // thrust
<b class="nc">&nbsp;                if ((step.getDistance() == 0) &amp;&amp; (md.length() == j)) {</b>
<b class="nc">&nbsp;                    thrustUsed += step.getMp();</b>
&nbsp;                }
&nbsp;                // then we moved to a new hex or the last step so check
&nbsp;                // conditions
&nbsp;                // structural damage
<b class="nc">&nbsp;                rollTarget = a.checkThrustSI(thrustUsed, overallMoveType);</b>
<b class="nc">&nbsp;                checkNag(rollTarget, nagReport, psrList);</b>
&nbsp;
&nbsp;                // check for pilot damage
<b class="nc">&nbsp;                int hits = entity.getCrew().getHits();</b>
<b class="nc">&nbsp;                int health = 6 - hits;</b>
&nbsp;
<b class="nc">&nbsp;                if (thrustUsed &gt; (2 * health)) {</b>
<b class="nc">&nbsp;                    int targetroll = 2 + (thrustUsed - (2 * health))</b>
&nbsp;                            + (2 * hits);
<b class="nc">&nbsp;                    nagReport</b>
<b class="nc">&nbsp;                            .append(Messages.getString(</b>
&nbsp;                                    &quot;MovementDisplay.addNag&quot;,
&nbsp;                                    new Object[] {
<b class="nc">&nbsp;                                            Integer.toString(targetroll),</b>
&nbsp;                                            &quot;Thrust exceeded twice pilot&#39;s health in single hex&quot; }));
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                thrustUsed = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return nagReport.toString();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static MovePath moveAero(MovePath md, Client client) {
<b class="nc">&nbsp;        final Entity entity = md.getEntity();</b>
<b class="nc">&nbsp;        final IGame game = entity.getGame();</b>
&nbsp;        // Don&#39;t process further unless the entity belongs in space
<b class="nc">&nbsp;        if (!entity.isAero() &amp;&amp; !(entity instanceof EjectedCrew)) {</b>
<b class="nc">&nbsp;            return md;</b>
&nbsp;        }
&nbsp;        // Ejected crew/pilots and lifeboats can&#39;t move, so just add the inherited move steps and be done with it
<b class="nc">&nbsp;        if (entity instanceof EjectedCrew || (entity instanceof EscapePods &amp;&amp; (entity.getOriginalWalkMP() &lt;= 0))) {</b>
<b class="nc">&nbsp;            md = addSteps(md, client);</b>
<b class="nc">&nbsp;            return md;</b>
&nbsp;        }
<b class="nc">&nbsp;        IAero a = (IAero) entity;</b>
&nbsp;
&nbsp;        // need to check and see
&nbsp;        // if the units current velocity is zero
&nbsp;
<b class="nc">&nbsp;        boolean isRamming = false;</b>
<b class="nc">&nbsp;        if ((md.getLastStep() != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (md.getLastStep().getType() == MoveStepType.RAM)) {</b>
<b class="nc">&nbsp;            isRamming = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if using advanced movement then I need to add on movement
&nbsp;        // steps to get the vessel from point a to point b
<b class="nc">&nbsp;        if (game.useVectorMove()) {</b>
&nbsp;            // if the unit is ramming then this is already done
<b class="nc">&nbsp;            if (!isRamming) {</b>
<b class="nc">&nbsp;                md = addSteps(md, client);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (a.isOutControlTotal()) {</b>
&nbsp;            // OOC units need a new movement path
<b class="nc">&nbsp;            MovePath oldmd = md;</b>
<b class="nc">&nbsp;            md = new MovePath(game, entity);</b>
<b class="nc">&nbsp;            int vel = a.getCurrentVelocity();</b>
&nbsp;
<b class="nc">&nbsp;            while (vel &gt; 0) {</b>
<b class="nc">&nbsp;                int steps = 1;</b>
&nbsp;                //if moving on the ground map, then 16 hexes forward
<b class="nc">&nbsp;                if(game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                    steps = 16;</b>
&nbsp;                }
<b class="nc">&nbsp;                while(steps &gt; 0 &amp;&amp;</b>
<b class="nc">&nbsp;                        game.getBoard().contains(md.getFinalCoords())) {</b>
<b class="nc">&nbsp;                    md.addStep(MoveStepType.FORWARDS);</b>
<b class="nc">&nbsp;                    steps--;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!game.getBoard().contains(md.getFinalCoords())) {</b>
<b class="nc">&nbsp;                    md.removeLastStep();</b>
<b class="nc">&nbsp;                    if(game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_RETURN_FLYOVER)) {</b>
&nbsp;                        //Telemissiles shouldn&#39;t get a return option
<b class="nc">&nbsp;                        if (entity instanceof TeleMissile) {</b>
<b class="nc">&nbsp;                            md.addStep(MoveStepType.OFF);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            md.addStep(MoveStepType.RETURN);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        md.addStep(MoveStepType.OFF);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (a.isRandomMove()) {</b>
<b class="nc">&nbsp;                    int roll = Compute.d6(1);</b>
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        md.addStep(MoveStepType.TURN_LEFT);</b>
<b class="nc">&nbsp;                        md.addStep(MoveStepType.TURN_LEFT);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        md.addStep(MoveStepType.TURN_LEFT);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        md.addStep(MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        md.addStep(MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;                        md.addStep(MoveStepType.TURN_RIGHT);</b>
&nbsp;                        break;
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                vel--;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // check to see if old movement path contained a launch
<b class="nc">&nbsp;            if (oldmd.contains(MoveStepType.LAUNCH)) {</b>
&nbsp;                // since launches have to be the last step
<b class="nc">&nbsp;                MoveStep lastStep = oldmd.getLastStep();</b>
<b class="nc">&nbsp;                if (lastStep.getType() == MoveStepType.LAUNCH) {</b>
<b class="nc">&nbsp;                    md.addStep(lastStep.getType(), lastStep.getLaunched());</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // check to see if old movement path contained an undocking
<b class="nc">&nbsp;            if (oldmd.contains(MoveStepType.UNDOCK)) {</b>
&nbsp;                // since launches have to be the last step
<b class="nc">&nbsp;                MoveStep lastStep = oldmd.getLastStep();</b>
<b class="nc">&nbsp;                if (lastStep.getType() == MoveStepType.UNDOCK) {</b>
<b class="nc">&nbsp;                    md.addStep(lastStep.getType(), lastStep.getLaunched());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return md;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add steps for advanced vector movement based on the given vectors when
&nbsp;     * splitting hexes, choose the hex with less tonnage in case OOC
&nbsp;     */
&nbsp;    private static MovePath addSteps(MovePath md, Client client) {
<b class="nc">&nbsp;        Entity en = md.getEntity();</b>
<b class="nc">&nbsp;        IGame game = en.getGame();</b>
&nbsp;
&nbsp;        // if the last step is a launch or recovery, then I want to keep that at
&nbsp;        // the end
<b class="nc">&nbsp;        MoveStep lastStep = md.getLastStep();</b>
<b class="nc">&nbsp;        if ((lastStep != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((lastStep.getType() == MoveStepType.LAUNCH) || (lastStep</b>
<b class="nc">&nbsp;                        .getType() == MoveStepType.RECOVER) || (lastStep</b>
<b class="nc">&nbsp;                        .getType() == MoveStepType.UNDOCK))) {</b>
<b class="nc">&nbsp;            md.removeLastStep();</b>
&nbsp;        }
&nbsp;
&nbsp;        // get the start and end
<b class="nc">&nbsp;        Coords start = en.getPosition();</b>
<b class="nc">&nbsp;        Coords end = Compute.getFinalPosition(start, md.getFinalVectors());</b>
&nbsp;
<b class="nc">&nbsp;        boolean leftMap = false;</b>
&nbsp;
&nbsp;        // (see LosEffects.java)
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; in = Coords.intervening(start, end);</b>
&nbsp;        // first check whether we are splitting hexes
<b class="nc">&nbsp;        boolean split = false;</b>
<b class="nc">&nbsp;        double degree = start.degree(end);</b>
<b class="nc">&nbsp;        if ((degree % 60) == 30) {</b>
<b class="nc">&nbsp;            split = true;</b>
<b class="nc">&nbsp;            in = Coords.intervening(start, end, true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Coords current = start;</b>
<b class="nc">&nbsp;        int facing = md.getFinalFacing();</b>
<b class="nc">&nbsp;        for (int i = 1; i &lt; in.size(); i++) {</b>
&nbsp;
<b class="nc">&nbsp;            Coords c = in.get(i);</b>
&nbsp;            // check for split hexes
&nbsp;            // check for some number after a multiple of 3 (1,4,7,etc)
<b class="nc">&nbsp;            if (((i % 3) == 1) &amp;&amp; split) {</b>
&nbsp;
<b class="nc">&nbsp;                Coords left = in.get(i);</b>
<b class="nc">&nbsp;                Coords right = in.get(i + 1);</b>
&nbsp;
&nbsp;                // get the total tonnage in each hex
<b class="nc">&nbsp;                double leftTonnage = 0;</b>
<b class="nc">&nbsp;                for (Entity ent : game.getEntitiesVector(left)) {</b>
<b class="nc">&nbsp;                    leftTonnage += ent.getWeight();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                
<b class="nc">&nbsp;                double rightTonnage = 0;</b>
<b class="nc">&nbsp;                for (Entity ent : game.getEntitiesVector(right)) {</b>
<b class="nc">&nbsp;                    rightTonnage += ent.getWeight();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                // TODO: I will need to update this to account for asteroids
&nbsp;
&nbsp;                // I need to consider both of these passed through
&nbsp;                // for purposes of bombing
<b class="nc">&nbsp;                en.addPassedThrough(right);</b>
<b class="nc">&nbsp;                en.addPassedThrough(left);</b>
<b class="nc">&nbsp;                if(client !=  null) {</b>
<b class="nc">&nbsp;                    client.sendUpdateEntity(en);</b>
&nbsp;                }
&nbsp;
&nbsp;                // if the left is preferred, increment i so next one is skipped
<b class="nc">&nbsp;                if ((leftTonnage &lt; rightTonnage)</b>
<b class="nc">&nbsp;                        || !game.getBoard().contains(right)) {</b>
<b class="nc">&nbsp;                    i++;</b>
&nbsp;                } else {
&nbsp;                    continue;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(!game.getBoard().contains(c)) {</b>
<b class="nc">&nbsp;                if(game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_RETURN_FLYOVER)) {</b>
&nbsp;                    //Telemissiles shouldn&#39;t get a return option
<b class="nc">&nbsp;                    if (en instanceof TeleMissile) {</b>
<b class="nc">&nbsp;                        md.addStep(MoveStepType.OFF);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        md.addStep(MoveStepType.RETURN);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    md.addStep(MoveStepType.OFF);</b>
&nbsp;                }
<b class="nc">&nbsp;                leftMap = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // which direction is this from the current hex?
<b class="nc">&nbsp;            int dir = current.direction(c);</b>
&nbsp;            // what kind of step do I need to get there?
<b class="nc">&nbsp;            int diff = dir - facing;</b>
<b class="nc">&nbsp;            if (diff == 0) {</b>
<b class="nc">&nbsp;                md.addStep(MoveStepType.FORWARDS);</b>
<b class="nc">&nbsp;            } else if ((diff == 1) || (diff == -5)) {</b>
<b class="nc">&nbsp;                md.addStep(MoveStepType.LATERAL_RIGHT);</b>
<b class="nc">&nbsp;            } else if ((diff == -2) || (diff == 4)) {</b>
<b class="nc">&nbsp;                md.addStep(MoveStepType.LATERAL_RIGHT_BACKWARDS);</b>
<b class="nc">&nbsp;            } else if ((diff == -1) || (diff == 5)) {</b>
<b class="nc">&nbsp;                md.addStep(MoveStepType.LATERAL_LEFT);</b>
<b class="nc">&nbsp;            } else if ((diff == 2) || (diff == -4)) {</b>
<b class="nc">&nbsp;                md.addStep(MoveStepType.LATERAL_LEFT_BACKWARDS);</b>
<b class="nc">&nbsp;            } else if ((diff == 3) || (diff == -3)) {</b>
<b class="nc">&nbsp;                md.addStep(MoveStepType.BACKWARDS);</b>
&nbsp;            }
<b class="nc">&nbsp;            current = c;</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // do I now need to add on the last step again?
<b class="nc">&nbsp;        if (!leftMap &amp;&amp; (lastStep != null) &amp;&amp; (lastStep.getType() == MoveStepType.LAUNCH)) {</b>
<b class="nc">&nbsp;            md.addStep(MoveStepType.LAUNCH, lastStep.getLaunched());</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (!leftMap &amp;&amp; (lastStep != null) &amp;&amp; (lastStep.getType() == MoveStepType.UNDOCK)) {</b>
<b class="nc">&nbsp;            md.addStep(MoveStepType.UNDOCK, lastStep.getLaunched());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!leftMap &amp;&amp; (lastStep != null) &amp;&amp; (lastStep.getType() == MoveStepType.RECOVER)) {</b>
<b class="nc">&nbsp;            md.addStep(MoveStepType.RECOVER, lastStep.getRecoveryUnit(), -1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return md;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String[] getDisplayArray(List&lt;? extends Targetable&gt; entities) {
<b class="nc">&nbsp;        String[] retVal = new String[entities.size()];</b>
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        for (Targetable ent : entities) {</b>
<b class="nc">&nbsp;            retVal[i++] = ent.getDisplayName();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Targetable getTargetPicked(
&nbsp;            List&lt;? extends Targetable&gt; targets, String input) {
<b class="nc">&nbsp;        if (input == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Targetable ent : targets) {</b>
<b class="nc">&nbsp;            if (input.equals(ent.getDisplayName())) {</b>
<b class="nc">&nbsp;                return ent;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Should never get here!
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
