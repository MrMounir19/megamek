


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > LongestPathFinder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common.pathfinder</a>
</div>

<h1>Coverage Summary for Class: LongestPathFinder (megamek.common.pathfinder)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LongestPathFinder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
</tr>
  <tr>
    <td class="name">LongestPathFinder$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LongestPathFinder$AeroMultiPathComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LongestPathFinder$AeroMultiPathRelaxer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LongestPathFinder$LongestPathRelaxer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LongestPathFinder$MovePathMinMPMaxDistanceComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/131)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2014 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.common.pathfinder;
&nbsp;
&nbsp;import java.util.ArrayDeque;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Deque;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.MoveStep;
&nbsp;import megamek.common.Tank;
&nbsp;
&nbsp;/**
&nbsp; * Path finder that specialises in finding paths that can enter a single hex
&nbsp; * multiple times. For example longest path searches.
&nbsp; *
&nbsp; * @author Saginatio
&nbsp; *
&nbsp; *
&nbsp; */
&nbsp;public class LongestPathFinder extends MovePathFinder&lt;Deque&lt;MovePath&gt;&gt; {
<b class="nc">&nbsp;    private boolean aero = false;</b>
&nbsp;
&nbsp;    protected LongestPathFinder(EdgeRelaxer&lt;Deque&lt;MovePath&gt;, MovePath&gt; edgeRelaxer,
&nbsp;            AdjacencyMap&lt;MovePath&gt; edgeAdjacencyMap, Comparator&lt;MovePath&gt; comparator,
&nbsp;            IGame game) {
<b class="nc">&nbsp;        super(edgeRelaxer, edgeAdjacencyMap, comparator, game);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Produces a path finder that searches for all paths that travel the max
&nbsp;     * distance ( since the last direction change ). This path finder also finds
&nbsp;     * (shorter) longest paths that require less mp to travel.
&nbsp;     *
&nbsp;     * @param maxMP - the maximal movement points available for an entity
&nbsp;     * @param stepType - if equal to MoveStepType.BACKWARDS, then searcher also
&nbsp;     *            includes backward steps. Otherwise only forward movement is
&nbsp;     *            allowed
&nbsp;     * @param game
&nbsp;     * @return a longest path finder
&nbsp;     */
&nbsp;    public static LongestPathFinder newInstanceOfLongestPath(int maxMP, MoveStepType stepType, IGame game) {
<b class="nc">&nbsp;        LongestPathFinder lpf = new LongestPathFinder(new LongestPathRelaxer(),</b>
&nbsp;                new NextStepsAdjacencyMap(stepType),
&nbsp;                new MovePathMinMPMaxDistanceComparator(),
&nbsp;                game);
<b class="nc">&nbsp;        lpf.addFilter(new MovePathLengthFilter(maxMP));</b>
<b class="nc">&nbsp;        lpf.addFilter(new MovePathLegalityFilter(game));</b>
<b class="nc">&nbsp;        return lpf;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Produces a path finder for aero units that searches for all paths that
&nbsp;     * travel the max distance. On a ground map this can be very computational
&nbsp;     * heavy.
&nbsp;     *
&nbsp;     * @param maxMP - the maximal thrust points available for an aero
&nbsp;     * @param game
&nbsp;     * @return a longest path finder for aeros
&nbsp;     */
&nbsp;    public static LongestPathFinder newInstanceOfAeroPath(int maxMP, IGame game) {
<b class="nc">&nbsp;        LongestPathFinder lpf = new LongestPathFinder(new AeroMultiPathRelaxer(!game.getBoard().inSpace()),</b>
&nbsp;                new NextStepsAdjacencyMap(MoveStepType.FORWARDS),
&nbsp;                new AeroMultiPathComparator(),
&nbsp;                game);
<b class="nc">&nbsp;        lpf.aero = true;</b>
<b class="nc">&nbsp;        lpf.addFilter(new MovePathLengthFilter(maxMP));</b>
<b class="nc">&nbsp;        lpf.addFilter(new MovePathLegalityFilter(game));</b>
<b class="nc">&nbsp;        return lpf;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Comparator that sorts MovePaths based on lexicographical order of pairs:&lt;br&gt;
&nbsp;     *
&nbsp;     *
&nbsp;     * {@code ( movement points used; -(hexes moved) )}
&nbsp;     *
&nbsp;     */
<b class="nc">&nbsp;    public static class MovePathMinMPMaxDistanceComparator extends MovePathMPCostComparator {</b>
&nbsp;        @Override
&nbsp;        public int compare(MovePath first, MovePath second) {
<b class="nc">&nbsp;            int s = super.compare(first, second);</b>
<b class="nc">&nbsp;            if (s != 0) {</b>
<b class="nc">&nbsp;                return s;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return second.getHexesMoved() - first.getHexesMoved();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Relaxer for longest path movement. Current implementation needs
&nbsp;     * Comparator that preserves MovePathMinMPMaxDistanceComparator contract.
&nbsp;     *
&nbsp;     * It adds a path to &#39;interesting&#39; paths in a hex when candidate travelled
&nbsp;     * more hexes.
&nbsp;     *
&nbsp;     */
<b class="nc">&nbsp;    static public class LongestPathRelaxer implements EdgeRelaxer&lt;Deque&lt;MovePath&gt;, MovePath&gt; {</b>
&nbsp;        @Override
&nbsp;        public Deque&lt;MovePath&gt; doRelax(Deque&lt;MovePath&gt; v, MovePath mpCandidate, Comparator&lt;MovePath&gt; comparator) {
<b class="nc">&nbsp;            if (mpCandidate == null) {</b>
<b class="nc">&nbsp;                throw new NullPointerException();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (v == null) {</b>
<b class="nc">&nbsp;                return new ArrayDeque&lt;&gt;(Collections.singleton(mpCandidate));</b>
&nbsp;            }
<b class="nc">&nbsp;            while (!v.isEmpty()) { //we could get rid of this loop, since we require a proper comparator</b>
<b class="nc">&nbsp;                MovePath topMP = v.getLast();</b>
&nbsp;
&nbsp;                //standing up is always reasonable for mechs
<b class="nc">&nbsp;                boolean vprone = topMP.getFinalProne(), eprone = mpCandidate.getFinalProne();</b>
<b class="nc">&nbsp;                if (vprone != eprone) {</b>
<b class="nc">&nbsp;                    if (vprone) {</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (!(topMP.getEntity() instanceof Tank)) {</b>
<b class="nc">&nbsp;                    boolean vhdown = topMP.getFinalHullDown(), ehdown = mpCandidate.getFinalHullDown();</b>
<b class="nc">&nbsp;                    if (vhdown != ehdown) {</b>
<b class="nc">&nbsp;                        if (vhdown) {</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return null;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                /*
&nbsp;                 * We require that the priority queue v of MovePath is sorted
&nbsp;                 * lexicographically using product MPUsed x (-HexesMoved).
&nbsp;                 */
<b class="nc">&nbsp;                int topMpUsed = topMP.getMpUsed(), mpCMpUsed = mpCandidate.getMpUsed();</b>
&nbsp;
<b class="nc">&nbsp;                if (topMpUsed &gt; mpCMpUsed) {</b>
&nbsp;                    /*
&nbsp;                     * topMP should have less or equal &#39;movement points used&#39;
&nbsp;                     * since it was taken from candidates priority queue earlier
&nbsp;                     *
&nbsp;                     * Current implementation of doRelax() assumes that v is
&nbsp;                     * sorted in such way that this situation is impossible.
&nbsp;                     */
<b class="nc">&nbsp;                    System.err.println(new IllegalStateException(</b>
&nbsp;                            &quot;Top Move Path uses more MPs than Move Path Candidate.&quot;));
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (topMP.getHexesMoved() &gt; mpCandidate.getHexesMoved()) {</b>
<b class="nc">&nbsp;                        return null; //topMP path is longer and uses less or same mp.</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (topMP.getHexesMoved() == mpCandidate.getHexesMoved()) {</b>
&nbsp;                        //we want to preserve both forward and backward movements
&nbsp;                        //that end in the same spot with the same cost.
<b class="nc">&nbsp;                        MoveStep topStep = topMP.getLastStep();</b>
<b class="nc">&nbsp;                        boolean topBackwards = topStep != null &amp;&amp; topStep.isThisStepBackwards();</b>
<b class="nc">&nbsp;                        MoveStep mpCandStep = mpCandidate.getLastStep();</b>
<b class="nc">&nbsp;                        boolean mpCandBackwars = mpCandStep != null &amp;&amp; mpCandStep.isThisStepBackwards();</b>
<b class="nc">&nbsp;                        if (!(topMP.getEntity() instanceof Infantry) &amp;&amp; topBackwards != mpCandBackwars) {</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (topMpUsed == mpCMpUsed) {</b>
&nbsp;                        //mpCandidate is not strictly better than topMp so we won&#39;t use it.
<b class="nc">&nbsp;                        return null;</b>
<b class="nc">&nbsp;                    } else if (topMpUsed &lt; mpCMpUsed) {</b>
&nbsp;                        //topMP travels less but also uses less movement points so we should keep it
&nbsp;                        //and add mpCandidate to the list of optimal longest paths.
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            v.addLast(mpCandidate);</b>
<b class="nc">&nbsp;            return v;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Comparator that sorts MovePaths based on lexicographical order of
&nbsp;     * triples:&lt;br/&gt;
&nbsp;     * {@code (hexes traveled; thrust used; 0-(hexes flown in a straight line) )}
&nbsp;     * &lt;br/&gt;
&nbsp;     * Works only with aeros.
&nbsp;     *
&nbsp;     */
<b class="nc">&nbsp;    public static class AeroMultiPathComparator implements Comparator&lt;MovePath&gt; {</b>
&nbsp;        /**
&nbsp;         * compares MovePaths based on lexicographical order of triples ( hexes
&nbsp;         * traveled; thrust used; 0-( hexes flown in a straight line ) )
&nbsp;         *
&nbsp;         */
&nbsp;        @Override
&nbsp;        public int compare(MovePath mp1, MovePath mp2) {
<b class="nc">&nbsp;            if (!mp1.getEntity().isAero()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;wanted aero got:&quot; + mp1.getClass().toString());</b>
&nbsp;            }
&nbsp;            //we want to process shorter paths first
<b class="nc">&nbsp;            int dHT = mp1.getHexesMoved() - mp2.getHexesMoved();</b>
<b class="nc">&nbsp;            if (dHT != 0) {</b>
<b class="nc">&nbsp;                return dHT;</b>
&nbsp;            }
&nbsp;            //then those which used less thrust
<b class="nc">&nbsp;            int dMP = mp1.getMpUsed() - mp2.getMpUsed();</b>
<b class="nc">&nbsp;            if (dMP != 0) {</b>
<b class="nc">&nbsp;                return dMP;</b>
&nbsp;            }
&nbsp;            //lastly those with more hexes flown straight.
<b class="nc">&nbsp;            MoveStep lms1 = mp1.getLastStep(), lms2 = mp2.getLastStep();</b>
<b class="nc">&nbsp;            int hs1 = lms1 == null ? 0 : lms1.getNStraight();</b>
<b class="nc">&nbsp;            int hs2 = lms2 == null ? 0 : lms2.getNStraight();</b>
<b class="nc">&nbsp;            int dHS = hs1 - hs2;</b>
&nbsp;
<b class="nc">&nbsp;            return -dHS;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Relaxer for aero movement. Current implementation needs Comparator that
&nbsp;     * preserves AeroMultiPathComparator contract.
&nbsp;     *
&nbsp;     * It adds a path to &#39;interesting&#39; paths in a hex when: candidate 1)traveled
&nbsp;     * more hexes or either 2a)thrust_used is less or 2b)straight_hexes_flown is
&nbsp;     * greater than current top of the stack.
&nbsp;     *
&nbsp;     */
<b class="nc">&nbsp;    public static class AeroMultiPathRelaxer implements EdgeRelaxer&lt;Deque&lt;MovePath&gt;, MovePath&gt; {</b>
&nbsp;        boolean inAthmosphere;
&nbsp;
<b class="nc">&nbsp;        private AeroMultiPathRelaxer(boolean inAthmosphere) {</b>
<b class="nc">&nbsp;            this.inAthmosphere = inAthmosphere;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Deque&lt;MovePath&gt; doRelax(Deque&lt;MovePath&gt; v, MovePath mpCandidate, Comparator&lt;MovePath&gt; comparator) {
<b class="nc">&nbsp;            if (mpCandidate == null)</b>
<b class="nc">&nbsp;                throw new NullPointerException();</b>
<b class="nc">&nbsp;            if (v == null) {</b>
<b class="nc">&nbsp;                return new ArrayDeque&lt;&gt;(Collections.singleton(mpCandidate));</b>
&nbsp;            }
<b class="nc">&nbsp;            MovePath topMP = v.getLast();</b>
&nbsp;
&nbsp;            /*
&nbsp;             * consider hexes travelled. If we enter the hex with different
&nbsp;             * hexes travelled then totally different paths will emerge
&nbsp;             */
<b class="nc">&nbsp;            int dHT = topMP.getHexesMoved() - mpCandidate.getHexesMoved();</b>
<b class="nc">&nbsp;            if (dHT &gt; 0) {</b>
&nbsp;                /*
&nbsp;                 * Current implementation of doRelax() assumes that v is sorted
&nbsp;                 * in such way that this situation is impossible.
&nbsp;                 */
<b class="nc">&nbsp;                System.err.println(new IllegalStateException(&quot;Top Move Path moved more than Move Path Candidate.&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (dHT &lt; 0) {</b>
<b class="nc">&nbsp;                v.addLast(mpCandidate);</b>
<b class="nc">&nbsp;                return v;</b>
&nbsp;            }
&nbsp;
&nbsp;            // assert( topMP.getHexesMoved() == mpCandidate.getHexesMoved() );
<b class="nc">&nbsp;            int dMP = topMP.getMpUsed() - mpCandidate.getMpUsed();</b>
<b class="nc">&nbsp;            if (dMP &gt; 0) {</b>
&nbsp;                /*
&nbsp;                 * Current implementation of doRelax() assumes that v is sorted
&nbsp;                 * in such way that this situation is impossible.
&nbsp;                 */
<b class="nc">&nbsp;                System.err.println(new IllegalStateException(</b>
&nbsp;                        &quot;Top Move Path uses more MPs than Move Path Candidate. &quot;
&nbsp;                        + &quot;while traveling the same distance&quot;));
&nbsp;            }
&nbsp;
&nbsp;            //assert( topMP thrust used is less or equal than candidates and hexesMoved are equal)
<b class="nc">&nbsp;            if (!inAthmosphere) {</b>
<b class="nc">&nbsp;                return null; //there is no point considering hexes flown straight if we are not in athmo</b>
&nbsp;            }
&nbsp;
&nbsp;            //while in athmosphere we should consider paths that have higher thrust used but flew more hexes straight
<b class="nc">&nbsp;            MoveStep topLastStep = topMP.getLastStep();</b>
<b class="nc">&nbsp;            MoveStep candidateLastStep = mpCandidate.getLastStep();</b>
<b class="nc">&nbsp;            int hs1 = topLastStep == null ? 0 : topLastStep.getNStraight();</b>
<b class="nc">&nbsp;            int hs2 = candidateLastStep == null ? 0 : candidateLastStep.getNStraight();</b>
<b class="nc">&nbsp;            int dHS = hs1 - hs2;</b>
&nbsp;
<b class="nc">&nbsp;            if (-dHS &gt; 0) {</b>
<b class="nc">&nbsp;                if (dMP &gt;= 0) {</b>
<b class="nc">&nbsp;                    System.err.println(new IllegalStateException(</b>
&nbsp;                            &quot;Top Move Path uses more MPs than Move Path Candidate and &quot; +
&nbsp;                            &quot;Top Move Path moves a shorter straight line distance.&quot;));
&nbsp;                }
<b class="nc">&nbsp;                if (topLastStep != null &amp;&amp; !topLastStep.dueFreeTurn()) {</b>
<b class="nc">&nbsp;                    v.add(mpCandidate);</b>
<b class="nc">&nbsp;                    return v;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the longest move path to a hex at given coordinates. If multiple
&nbsp;     * paths reach coords with different final facings, the best one is chosen.
&nbsp;     * If none paths are present then {@code null} is returned.
&nbsp;     *
&nbsp;     * @param coords - the coordinates of the hex
&nbsp;     * @return the shortest move path to hex at given coordinates
&nbsp;     */
&nbsp;    public MovePath getComputedPath(Coords coords) {
<b class="nc">&nbsp;        Deque&lt;MovePath&gt; q = getCost(coords, new Comparator&lt;Deque&lt;MovePath&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public int compare(Deque&lt;MovePath&gt; q1, Deque&lt;MovePath&gt; q2) {
<b class="nc">&nbsp;                MovePath mp1 = q1.getLast(), mp2 = q2.getLast();</b>
<b class="nc">&nbsp;                int t = mp2.getHexesMoved() - mp1.getHexesMoved();</b>
<b class="nc">&nbsp;                if (t != 0) {</b>
<b class="nc">&nbsp;                    return t;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return mp1.getMpUsed() - mp2.getMpUsed();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        if (q != null) {</b>
<b class="nc">&nbsp;            if (!aero) {</b>
<b class="nc">&nbsp;                return q.getLast();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ArrayDeque&lt;MovePath&gt; tq = new ArrayDeque&lt;&gt;(q);</b>
<b class="nc">&nbsp;                MovePath mp = tq.removeLast();</b>
<b class="nc">&nbsp;                while (!tq.isEmpty()) {</b>
<b class="nc">&nbsp;                    MovePath qlast = tq.removeLast();</b>
<b class="nc">&nbsp;                    if (mp.getHexesMoved() == qlast.getHexesMoved() &amp;&amp; mp.getMpUsed() &gt; qlast.getMpUsed()) {</b>
<b class="nc">&nbsp;                        mp = qlast;</b>
&nbsp;                    } else {
&nbsp;                        break;
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return mp;</b>
&nbsp;            }
&nbsp;        } else
<b class="nc">&nbsp;            return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a map of all computed longest paths. This also includes paths
&nbsp;     * that are shorter but use strictly less movement points.
&nbsp;     *
&nbsp;     * @return a map of all computed shortest paths.
&nbsp;     */
&nbsp;    public List&lt;MovePath&gt; getAllComputedPathsUnordered() {
<b class="nc">&nbsp;        Collection&lt;Deque&lt;MovePath&gt;&gt; queues = getPathCostMap().values();</b>
<b class="nc">&nbsp;        List&lt;MovePath&gt; l = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Deque&lt;MovePath&gt; q : queues) {</b>
<b class="nc">&nbsp;            l.addAll(q);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return l;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a map of all computed longest paths. This only includes one
&nbsp;     * longest path to one Coords,Facing pair.
&nbsp;     *
&nbsp;     * @return a map of all computed shortest paths.
&nbsp;     */
&nbsp;    public List&lt;MovePath&gt; getLongestComputedPaths() {
<b class="nc">&nbsp;        Collection&lt;Deque&lt;MovePath&gt;&gt; queues = getPathCostMap().values();</b>
<b class="nc">&nbsp;        List&lt;MovePath&gt; l = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Deque&lt;MovePath&gt; q : queues) {</b>
<b class="nc">&nbsp;            l.add(q.getLast());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return l;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
