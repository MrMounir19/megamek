


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > BotClient</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot</a>
</div>

<h1>Coverage Summary for Class: BotClient (megamek.client.bot)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BotClient</td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (3/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2%
  </span>
  <span class="absValue">
    (10/489)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BotClient$1</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.1%
  </span>
  <span class="absValue">
    (1/48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BotClient$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BotClient$CalculateBotTurn</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$0uSmBnp5</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$1tBbUCMe</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$2OKfHDhi</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$4dbidmWN</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$4G9b7BWt</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$4NjeziV0</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$5ewfLlt4</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$6iVlkgL9</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$7Uq4wXyh</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$857et5kT</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$85g7FaeQ</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$8kifn9Du</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$8moGUGnS</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$9F1E0li6</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$9sHAoqzx</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$9Xcjdo9d</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$A42k6ZGs</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$ag7RNwDT</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Auc4TK7b</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$AULpkhSs</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$b0WKoJqx</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$B6NIQzwG</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$b9xFZ6WJ</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$BRrGmHQj</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$brzaR2w6</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$cdZ2Mbid</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$ClbXa9gQ</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$DdeHM0xr</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$DDjsIn6X</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$E05yJVhr</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$e9o3PJRm</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$EHFolYGa</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$FPfieap2</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$FRHDN5b8</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$GooOmEzX</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$gqfiNq81</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$gzZKVRRU</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$hcCj8lvp</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$hfInuPrs</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$HGSbn8cl</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$HGy5Jdgr</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$hNNI3lWA</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Hu8o18IJ</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$hWo6ZOLp</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$I6AXUtVN</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$i6HP0CKa</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$il9sUv53</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$IVzfWHLM</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$iX0X8ap4</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$jcGPNUJX</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$jerHtSVj</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$jH9saMJU</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Jo4qNKiT</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$jOIzA4WW</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$JP07reQh</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Jsp3Azd7</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$KHt6ZImB</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$kjIq15Kg</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$kQinv5s4</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Kt57p8Ze</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$leUP0pDD</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$llf7oxpN</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$LLn5MVg6</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$lv7Mffah</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$mBKz0n6s</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$MBXYWYfz</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$MdT6y7qY</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$MmLKBbFi</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$mQDTzC4d</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$MWmD56MB</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$mWXdUHsy</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$N6197Gse</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$NGBK5Hpr</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$NPxyojMg</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Odcmm6hM</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$OLkcOthE</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$OLKl1oXj</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$oW98nEhG</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$PAkpwMy0</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$pCEA04eA</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$PfKaTr8z</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$pJhdyOvn</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$PohWuUTs</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$pVdrA3NI</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$pZdcOhJv</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Q8OlAZKr</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$QDM8eQla</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$qfhuK7A7</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$QfvtUwBv</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$QLLasxON</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$qmrN2mzk</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$QP6q0v4X</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$QRdfEVDe</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$QRtRxxEZ</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$R9KiywV0</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$RazWViLj</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$rOlCiiHv</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$RSjzPw0i</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$RtOC4O2N</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$SgXaDMOe</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$SIsdFt5D</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$T1uisyDh</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$T9oZV1mT</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$trkQ0r39</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$TvYEdNnS</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$TxGiwYbr</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$U2PT0arW</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$uFv1IJ8z</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$UM4nwrT0</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$V6IRCUO0</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$vP4yaXFo</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$wkpK1gqv</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$wPsW6AZ6</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$wwY46LUU</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$X0WqAtfs</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$XBqKMLZL</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Xfb7q6Xq</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$xtnxeWIm</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$ydCjuwUf</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$yDZlCS6n</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$yEtZujCS</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$yk2J6YY7</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$YUhsFTs4</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$yw8f6TWM</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$yYRSS4Sb</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$Z6PGNcsb</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$ZP6Y3Jmn</td>
  </tr>
  <tr>
    <td class="name">BotClient$MockitoMock$837475273$auxiliary$ZZekkSn9</td>
  </tr>
  <tr>
    <td class="name">BotClient$RankedCoords</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    7.4%
  </span>
  <span class="absValue">
    (4/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.9%
  </span>
  <span class="absValue">
    (11/571)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; * This program is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU General Public License as published by the Free
&nbsp; * Software Foundation; either version 2 of the License, or (at your option)
&nbsp; * any later version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
&nbsp; * more details.
&nbsp; */
&nbsp;package megamek.client.bot;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.FileNotFoundException;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import javax.swing.JFrame;
&nbsp;import javax.swing.JOptionPane;
&nbsp;import javax.swing.JScrollPane;
&nbsp;import javax.swing.JTextPane;
&nbsp;import javax.swing.ScrollPaneConstants;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.client.Client;
&nbsp;import megamek.client.bot.princess.CardinalEdge;
&nbsp;import megamek.client.ui.swing.ClientGUI;
&nbsp;import megamek.client.ui.swing.ReportDisplay;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.ComputeECM;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.ECMInfo;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityListFile;
&nbsp;import megamek.common.EntityMovementMode;
&nbsp;import megamek.common.EquipmentType;
&nbsp;import megamek.common.GameTurn;
&nbsp;import megamek.common.IBoard;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.IPlayer;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.Minefield;
&nbsp;import megamek.common.MiscType;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.VTOL;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.event.GameCFREvent;
&nbsp;import megamek.common.event.GameListenerAdapter;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.event.GamePlayerChatEvent;
&nbsp;import megamek.common.event.GameReportEvent;
&nbsp;import megamek.common.event.GameTurnChangeEvent;
&nbsp;import megamek.common.net.Packet;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.BoardClusterTracker;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;import megamek.common.util.BoardUtilities;
&nbsp;import megamek.common.util.StringUtil;
&nbsp;
<b class="fc">&nbsp;public abstract class BotClient extends Client {</b>
&nbsp;	public static final int BOT_TURN_RETRY_COUNT = 3;
&nbsp;	
&nbsp;    private List&lt;Entity&gt; currentTurnEnemyEntities;
&nbsp;    private List&lt;Entity&gt; currentTurnFriendlyEntities;
&nbsp;    
&nbsp;    // a frame, to show stuff in
&nbsp;    public JFrame frame;
&nbsp;    
&nbsp;    /**
&nbsp;     * Keeps track of whether this client has started to calculate a turn this phase.
&nbsp;     */
<b class="fc">&nbsp;    boolean calculatedTurnThisPhase = false;</b>
<b class="fc">&nbsp;    int calculatedTurnsThisPhase = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Store a reference to the ClientGUI for the client who created this bot.
&nbsp;     * This is used to ensure keep the ClientGUI synchronized with changes to
&nbsp;     * this BotClient (particularly the bot&#39;s name).
&nbsp;     */
<b class="fc">&nbsp;    private ClientGUI clientgui = null;</b>
&nbsp;
<b class="nc">&nbsp;    public class CalculateBotTurn implements Runnable {</b>
&nbsp;        public void run() {
<b class="nc">&nbsp;            calculateMyTurn();</b>
<b class="nc">&nbsp;            flushConn();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public BotClient(String playerName, String host, int port) {
<b class="fc">&nbsp;        super(playerName, host, port);</b>
&nbsp;        
<b class="fc">&nbsp;        boardClusterTracker = new BoardClusterTracker();</b>
&nbsp;        
<b class="fc">&nbsp;        game.addGameListener(new GameListenerAdapter() {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void gamePlayerChat(GamePlayerChatEvent e) {
<b class="nc">&nbsp;                processChat(e);</b>
<b class="nc">&nbsp;                flushConn();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void gameTurnChange(GameTurnChangeEvent e) {
&nbsp;                // On simultaneous phases, each player ending their turn will generate a turn change
&nbsp;                // We want to ignore turns from other players and only listen to events we generated
<b class="nc">&nbsp;                boolean ignoreSimTurn = game.isPhaseSimultaneous() &amp;&amp; (e.getPreviousPlayerId() != localPlayerNumber)</b>
&nbsp;                        &amp;&amp; calculatedTurnThisPhase;
&nbsp;
&nbsp;                
<b class="nc">&nbsp;                if (isMyTurn() &amp;&amp; !ignoreSimTurn) {</b>
<b class="nc">&nbsp;                    calculatedTurnThisPhase = true;</b>
&nbsp;                    // Run bot&#39;s turn processing in a separate thread.
&nbsp;                    // So calling thread is free to process the other actions.
<b class="nc">&nbsp;                    Thread worker = new Thread(new CalculateBotTurn(),</b>
<b class="nc">&nbsp;                            getName() + &quot; Turn &quot; + game.getTurnIndex() + &quot; Calc Thread&quot;</b>
&nbsp;                    );
<b class="nc">&nbsp;                    worker.start();</b>
<b class="nc">&nbsp;                    calculatedTurnsThisPhase++;</b>
&nbsp;                }
&nbsp;
&nbsp;                // unloading &quot;stranded&quot; units happens as part of a game turn change, so that&#39;s where we do it.
<b class="nc">&nbsp;                if(canUnloadStranded()) {</b>
<b class="nc">&nbsp;                    sendUnloadStranded(getStrandedEntities());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void gamePhaseChange(GamePhaseChangeEvent e) {
<b class="nc">&nbsp;                calculatedTurnThisPhase = false;</b>
<b class="nc">&nbsp;                if (e.getOldPhase().isPhaseSimultaneous(game)) {</b>
<b class="nc">&nbsp;                    int numOwnedEntities = game.getEntitiesOwnedBy(getLocalPlayer());</b>
<b class="nc">&nbsp;                    System.out.println(&quot;BotClient calculated turns, &quot; + getName() + &quot; phase &quot; + e.getOldPhase()</b>
&nbsp;                            + &quot; &quot; + calculatedTurnsThisPhase + &quot;/&quot; + numOwnedEntities);
&nbsp;                }
<b class="nc">&nbsp;                calculatedTurnsThisPhase = 0;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void gameReport(GameReportEvent e) {
<b class="nc">&nbsp;                if (game.getPhase() == IGame.Phase.PHASE_INITIATIVE_REPORT) {</b>
&nbsp;                    // Opponent has used tactical genius, must press
&nbsp;                    // &quot;Done&quot; again to advance past initiative report.
<b class="nc">&nbsp;                    sendDone(true);</b>
<b class="nc">&nbsp;                    flushConn();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void gameClientFeedbackRequest(GameCFREvent evt) {
<b class="nc">&nbsp;                switch (evt.getCFRType()) {</b>
&nbsp;                    case Packet.COMMAND_CFR_DOMINO_EFFECT:
&nbsp;                        // This will always send a &quot;no action&quot; response.
&nbsp;                        // In effect, it works the way it did before.  However..
&nbsp;                        // TODO: Bots should figure out how to step out of a
&nbsp;                        //   domino effect
<b class="nc">&nbsp;                        sendDominoCFRResponse(null);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case Packet.COMMAND_CFR_AMS_ASSIGN:
&nbsp;                        // Picks the WAA with the highest expected damage,
&nbsp;                        //  essentially same as if the auto_ams option was on
<b class="nc">&nbsp;                        WeaponAttackAction waa =</b>
<b class="nc">&nbsp;                            Compute.getHighestExpectedDamage(game,</b>
<b class="nc">&nbsp;                                    evt.getWAAs(), true);</b>
<b class="nc">&nbsp;                        sendAMSAssignCFRResponse(evt.getWAAs().indexOf(waa));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case Packet.COMMAND_CFR_APDS_ASSIGN:
&nbsp;                        // Picks the WAA with the highest expected damage,
&nbsp;                        //  essentially same as if the auto_ams option was on
<b class="nc">&nbsp;                        waa =</b>
<b class="nc">&nbsp;                            Compute.getHighestExpectedDamage(game,</b>
<b class="nc">&nbsp;                                    evt.getWAAs(), true);</b>
<b class="nc">&nbsp;                        sendAPDSAssignCFRResponse(evt.getWAAs().indexOf(waa));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case Packet.COMMAND_CFR_HIDDEN_PBS:
&nbsp;                        try {
<b class="nc">&nbsp;                            Vector&lt;EntityAction&gt; pointBlankShots = calculatePointBlankShot(evt.getEntityId(), evt.getTargetId());</b>
&nbsp;                            
<b class="nc">&nbsp;                            if(pointBlankShots == null) {</b>
<b class="nc">&nbsp;                                sendHiddenPBSCFRResponse(null);</b>
&nbsp;                            } else {
&nbsp;                                // we send two packets because the server will ignore the first one
<b class="nc">&nbsp;                                sendHiddenPBSCFRResponse(new Vector&lt;EntityAction&gt;());</b>
<b class="nc">&nbsp;                                sendHiddenPBSCFRResponse(pointBlankShots);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch(Exception e) {</b>
&nbsp;                            // if we screw up, don&#39;t keep everyone else waiting
<b class="nc">&nbsp;                            sendHiddenPBSCFRResponse(null);</b>
<b class="nc">&nbsp;                            throw e;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        break;
&nbsp;                    case Packet.COMMAND_CFR_TAG_TARGET:
<b class="nc">&nbsp;                        sendTAGTargetCFRResponse(pickTagTarget(evt));</b>
&nbsp;                        break;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        });
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    BotConfiguration config = new BotConfiguration();</b>
&nbsp;
&nbsp;    protected BoardClusterTracker boardClusterTracker;
&nbsp;
&nbsp;    public abstract void initialize();
&nbsp;
&nbsp;    protected abstract void processChat(GamePlayerChatEvent ge);
&nbsp;
&nbsp;    protected abstract void initMovement();
&nbsp;
&nbsp;    protected abstract void initFiring();
&nbsp;
&nbsp;    /**
&nbsp;     * Determines which entity should be moved next and then calls to {@link #continueMovementFor(Entity)} with
&nbsp;     * that entity.
&nbsp;     *
&nbsp;     * @return The calculated move path.
&nbsp;     * @throws NullPointerException if no entity can be found to move.
&nbsp;     */
&nbsp;    protected abstract MovePath calculateMoveTurn();
&nbsp;
&nbsp;    protected abstract void calculateFiringTurn();
&nbsp;
&nbsp;    protected abstract void calculateDeployment();
&nbsp;
<b class="nc">&nbsp;    protected void initTargeting() { }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculates the targeting/offboard turn
&nbsp;     * This includes firing TAG and non-direct-fire artillery
&nbsp;     * Does nothing in this implementation.
&nbsp;     */
&nbsp;    protected void calculateTargetingOffBoardTurn() {
<b class="nc">&nbsp;        sendAttackData(game.getFirstEntityNum(getMyTurn()),</b>
&nbsp;                new Vector&lt;&gt;(0));
<b class="nc">&nbsp;        sendDone(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    @Nullable
&nbsp;    protected abstract PhysicalOption calculatePhysicalTurn();
&nbsp;    
&nbsp;    protected Vector&lt;EntityAction&gt; calculatePointBlankShot(int firingEntityID, int targetID) { 
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected int pickTagTarget(GameCFREvent evt) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the full {@link MovePath} for the given {@link Entity}.
&nbsp;     *
&nbsp;     * @param entity The entity who is to move.
&nbsp;     * @return The calculated move path.
&nbsp;     * @throws NullPointerException if entity is NULL.
&nbsp;     */
&nbsp;    protected abstract MovePath continueMovementFor(Entity entity);
&nbsp;
&nbsp;    protected abstract Vector&lt;Minefield&gt; calculateMinefieldDeployment();
&nbsp;
&nbsp;    protected abstract Vector&lt;Coords&gt; calculateArtyAutoHitHexes();
&nbsp;
&nbsp;    protected abstract void checkMoral();
&nbsp;
&nbsp;    @Override
&nbsp;    protected boolean keepGameLog() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function that determines which of this bot&#39;s entities are stranded inside immobilized transports. 
&nbsp;     * @return Array of entity IDs.
&nbsp;     */
&nbsp;    public int[] getStrandedEntities() {
<b class="nc">&nbsp;        List&lt;Integer&gt; entitiesToUnload = new ArrayList&lt;&gt;();</b>
&nbsp;        
&nbsp;        // Basically, we loop through all entities owned by the current player
&nbsp;        // And if the entity happens to be in a disabled transport, then we unload it
&nbsp;        // unless doing so would kill it or be illegal due to stacking violation
<b class="nc">&nbsp;        for(Entity currentEntity : getGame().getPlayerEntities(getLocalPlayer(), true)) {</b>
<b class="nc">&nbsp;            Entity transport = currentEntity.getTransportId() != Entity.NONE ? getGame().getEntity(currentEntity.getTransportId()) : null;</b>
&nbsp;            
<b class="nc">&nbsp;            if(transport != null &amp;&amp; transport.isPermanentlyImmobilized(true)) {</b>
<b class="nc">&nbsp;                boolean stackingViolation = null != Compute.stackingViolation(game, currentEntity.getId(), transport.getPosition());</b>
<b class="nc">&nbsp;                boolean unloadFatal = currentEntity.isBoardProhibited(getGame().getBoard().getType()) ||</b>
<b class="nc">&nbsp;                        currentEntity.isLocationProhibited(transport.getPosition());</b>
&nbsp;                        
<b class="nc">&nbsp;                if(!stackingViolation &amp;&amp; !unloadFatal) {</b>
<b class="nc">&nbsp;                    entitiesToUnload.add(currentEntity.getId());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        int[] entityIDs = new int[entitiesToUnload.size()];</b>
<b class="nc">&nbsp;        for(int x = 0; x &lt; entitiesToUnload.size(); x++) {</b>
<b class="nc">&nbsp;            entityIDs[x] = entitiesToUnload.get(x);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return entityIDs;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public List&lt;Entity&gt; getEntitiesOwned() {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(getLocalPlayer())</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getPosition() != null) &amp;&amp; !entity.isOffBoard()) {</b>
<b class="nc">&nbsp;                result.add(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected Entity getArbitraryEntity() {
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(getLocalPlayer())) {</b>
<b class="nc">&nbsp;                return entity;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Lazy-loaded list of enemy entities that we should consider firing at.
&nbsp;     * Only good for the current entity turn calculation, as this list can change between individual entity turns. 
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getEnemyEntities() {
<b class="nc">&nbsp;        if(currentTurnEnemyEntities == null) {</b>
<b class="nc">&nbsp;            currentTurnEnemyEntities = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (entity.getOwner().isEnemyOf(getLocalPlayer())</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getPosition() != null) &amp;&amp; !entity.isOffBoard()</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getCrew() != null) &amp;&amp; !entity.getCrew().isDead()) {</b>
&nbsp;    
<b class="nc">&nbsp;                    currentTurnEnemyEntities.add(entity);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return currentTurnEnemyEntities;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Lazy-loaded list of friendly entities.
&nbsp;     * Only good for the current entity turn calculation, as this list can change between individual entity turns. 
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getFriendEntities() {
<b class="nc">&nbsp;        if(currentTurnFriendlyEntities == null) {</b>
<b class="nc">&nbsp;            currentTurnFriendlyEntities = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (!entity.getOwner().isEnemyOf(getLocalPlayer()) &amp;&amp; (entity.getPosition() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isOffBoard()) {</b>
<b class="nc">&nbsp;                    currentTurnFriendlyEntities.add(entity);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return currentTurnFriendlyEntities;</b>
&nbsp;    }
&nbsp;
&nbsp;    // TODO: move initMovement to be called on phase end
&nbsp;    @Override
&nbsp;    public void changePhase(IGame.Phase phase) {
<b class="nc">&nbsp;        super.changePhase(phase);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            switch (phase) {</b>
&nbsp;                case PHASE_LOUNGE:
<b class="nc">&nbsp;                    sendChat(Messages.getString(&quot;BotClient.Hi&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_DEPLOYMENT:
<b class="nc">&nbsp;                    initialize();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_MOVEMENT:
&nbsp;                    /* Do not uncomment this. It is so that bots stick around till end of game
&nbsp;                     * for proper salvage. If the bot dies out here, the salvage for all but the
&nbsp;                     * last bot disappears for some reason
&nbsp;                    if (game.getEntitiesOwnedBy(getLocalPlayer()) == 0) {
&nbsp;                        sendChat(Messages.getString(&quot;BotClient.HowAbout&quot;)); //$NON-NLS-1$
&nbsp;                        die();
&nbsp;                    }
&nbsp;                     */
&nbsp;                    // if the game is not double blind and I can&#39;t see anyone
&nbsp;                    // else on the board I should kill myself.
<b class="nc">&nbsp;                    if (!(game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)) //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getEntitiesOwnedBy(getLocalPlayer())</b>
<b class="nc">&nbsp;                             - game.getNoOfEntities()) == 0)) {</b>
<b class="nc">&nbsp;                        die();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (Compute.randomInt(4) == 1) {</b>
<b class="nc">&nbsp;                        String message = getRandomBotMessage();</b>
<b class="nc">&nbsp;                        if (message != null) {</b>
<b class="nc">&nbsp;                            sendChat(message);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    initMovement();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_FIRING:
<b class="nc">&nbsp;                    initFiring();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_PHYSICAL:
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_TARGETING:
<b class="nc">&nbsp;                    initTargeting();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_END_REPORT:
&nbsp;                    // Check if stealth armor should be switched on/off
&nbsp;                    // Kinda cheap leaving this until the end phase, players
&nbsp;                    // can&#39;t do this
<b class="nc">&nbsp;                    toggleStealth();</b>
<b class="nc">&nbsp;                    endOfTurnProcessing();</b>
&nbsp;                    // intentional fallthrough: all reports must click &quot;done&quot;, otherwise the game never moves on.
&nbsp;                case PHASE_TARGETING_REPORT:
&nbsp;                case PHASE_INITIATIVE_REPORT:
&nbsp;                case PHASE_MOVEMENT_REPORT:
&nbsp;                case PHASE_OFFBOARD_REPORT:
&nbsp;                case PHASE_FIRING_REPORT:
&nbsp;                case PHASE_PHYSICAL_REPORT:
<b class="nc">&nbsp;                    sendDone(true);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PHASE_VICTORY:
<b class="nc">&nbsp;                    runEndGame();</b>
<b class="nc">&nbsp;                    sendChat(Messages.getString(&quot;BotClient.Bye&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    die();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;        } catch (Throwable t) {</b>
<b class="nc">&nbsp;            t.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void runEndGame() {
&nbsp;        // Make a list of the player&#39;s living units.
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; living = game.getPlayerEntities(getLocalPlayer(), false);</b>
&nbsp;
&nbsp;        // Be sure to include all units that have retreated.
<b class="nc">&nbsp;        for (Enumeration&lt;Entity&gt; iter = game.getRetreatedEntities(); iter.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            Entity ent = iter.nextElement();</b>
<b class="nc">&nbsp;            if (ent.getOwnerId() == getLocalPlayer().getId()) {</b>
<b class="nc">&nbsp;                living.add(ent);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (living.isEmpty()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String sLogDir = PreferenceManager.getClientPreferences().getLogDirectory();</b>
<b class="nc">&nbsp;        File logDir = new File(sLogDir);</b>
<b class="nc">&nbsp;        if (!logDir.exists()) {</b>
&nbsp;            //noinspection ResultOfMethodCallIgnored
<b class="nc">&nbsp;            logDir.mkdir();</b>
&nbsp;        }
<b class="nc">&nbsp;        String fileName = &quot;Bot_&quot; + getLocalPlayer().getName() + &quot;.mul&quot;;</b>
<b class="nc">&nbsp;        if (PreferenceManager.getClientPreferences().stampFilenames()) {</b>
<b class="nc">&nbsp;            fileName = StringUtil.addDateTimeStamp(fileName);</b>
&nbsp;        }
<b class="nc">&nbsp;        File unitFile = new File(sLogDir + File.separator + fileName);</b>
&nbsp;        try {
&nbsp;            // Save the entities to the file.
<b class="nc">&nbsp;            EntityListFile.saveTo(unitFile, living);</b>
<b class="nc">&nbsp;        } catch (IOException excep) {</b>
<b class="nc">&nbsp;            excep.printStackTrace(System.err);</b>
<b class="nc">&nbsp;            doAlertDialog(Messages.getString(&quot;ClientGUI.errorSavingFile&quot;), excep.getMessage()); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Entity getRandomUnmovedEntity() {
<b class="nc">&nbsp;        List&lt;Entity&gt; owned = getEntitiesOwned();</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; unMoved = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity e : owned) {</b>
<b class="nc">&nbsp;            if (e.isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                unMoved.add(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return unMoved.get(Compute.randomInt(unMoved.size()));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculate what to do on my turn.
&nbsp;     * Has a retry mechanism for when the turn calculation fails due to concurrency issues
&nbsp;     */
&nbsp;    private synchronized void calculateMyTurn() {
<b class="nc">&nbsp;    	int retryCount = 0;</b>
<b class="nc">&nbsp;        boolean success = false;</b>
&nbsp;        
<b class="nc">&nbsp;        while((retryCount &lt; BOT_TURN_RETRY_COUNT) &amp;&amp; !success) {</b>
<b class="nc">&nbsp;        	success = calculateMyTurnWorker();</b>
&nbsp;        	
<b class="nc">&nbsp;        	if(!success) {</b>
&nbsp;	        	// if we fail, take a nap for 500-1500 milliseconds, then try again
&nbsp;	            // as it may be due to some kind of thread-related issue
&nbsp;        		// limit number of retries so we&#39;re not endlessly spinning
&nbsp;        		// if we can&#39;t recover from the error
<b class="nc">&nbsp;	            retryCount++;</b>
&nbsp;	            try {
<b class="nc">&nbsp;					Thread.sleep(Compute.randomInt(1000) + 500);</b>
<b class="nc">&nbsp;				} catch (InterruptedException e) {</b>
<b class="nc">&nbsp;					MegaMek.getLogger().error(e.toString());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;	        }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Worker function for a single attempt to calculate the bot&#39;s turn.
&nbsp;     */
&nbsp;    private synchronized boolean calculateMyTurnWorker() {
&nbsp;        // clear out transient data
<b class="nc">&nbsp;        currentTurnEnemyEntities = null;</b>
<b class="nc">&nbsp;        currentTurnFriendlyEntities = null;</b>
&nbsp;        
&nbsp;        try {
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</b>
&nbsp;                MovePath mp;
<b class="nc">&nbsp;                if (game.getTurn() instanceof GameTurn.SpecificEntityTurn) {</b>
<b class="nc">&nbsp;                    GameTurn.SpecificEntityTurn turn = (GameTurn.SpecificEntityTurn) game</b>
<b class="nc">&nbsp;                            .getTurn();</b>
<b class="nc">&nbsp;                    Entity mustMove = game.getEntity(turn.getEntityNum());</b>
<b class="nc">&nbsp;                    mp = continueMovementFor(mustMove);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    if (config.isForcedIndividual()) {</b>
<b class="nc">&nbsp;                        Entity mustMove = getRandomUnmovedEntity();</b>
<b class="nc">&nbsp;                        mp = continueMovementFor(mustMove);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        mp = calculateMoveTurn();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                moveEntity(mp.getEntity().getId(), mp);</b>
<b class="nc">&nbsp;            } else if (game.getPhase() == IGame.Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;                calculateFiringTurn();</b>
<b class="nc">&nbsp;            } else if (game.getPhase() == IGame.Phase.PHASE_PHYSICAL) {</b>
<b class="nc">&nbsp;                PhysicalOption po = calculatePhysicalTurn();</b>
&nbsp;                // Bug #1072137: don&#39;t crash if the bot can&#39;t find a physical.
<b class="nc">&nbsp;                if (null != po) {</b>
<b class="nc">&nbsp;                    sendAttackData(po.attacker.getId(), po.getVector());</b>
&nbsp;                } else {
&nbsp;                    // Send a &quot;no attack&quot; to clear the game turn, if any.
<b class="nc">&nbsp;                    sendAttackData(game.getFirstEntityNum(getMyTurn()),</b>
&nbsp;                                   new Vector&lt;&gt;(0));
&nbsp;                }
<b class="nc">&nbsp;            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {</b>
<b class="nc">&nbsp;                calculateDeployment();</b>
<b class="nc">&nbsp;            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {</b>
<b class="nc">&nbsp;                Vector&lt;Minefield&gt; mines = calculateMinefieldDeployment();</b>
<b class="nc">&nbsp;                for (Minefield mine : mines) {</b>
<b class="nc">&nbsp;                    game.addMinefield(mine);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                sendDeployMinefields(mines);</b>
<b class="nc">&nbsp;                sendPlayerInfo();</b>
<b class="nc">&nbsp;            } else if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {</b>
&nbsp;                // For now, declare no autohit hexes.
<b class="nc">&nbsp;                Vector&lt;Coords&gt; autoHitHexes = calculateArtyAutoHitHexes();</b>
<b class="nc">&nbsp;                sendArtyAutoHitHexes(autoHitHexes);</b>
<b class="nc">&nbsp;            } else if ((game.getPhase() == IGame.Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                       || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)) {</b>
&nbsp;                // Princess implements arty targeting; no plans to do so for testbod
<b class="nc">&nbsp;                calculateTargetingOffBoardTurn();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } catch (Throwable t) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(t);            </b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public double getMassOfAllInBuilding(final IGame game, final Coords coords) {
<b class="nc">&nbsp;        double mass = 0;</b>
&nbsp;
&nbsp;        // Add the mass of anyone else standing in/on this building.
<b class="nc">&nbsp;        final IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        final int buildingElevation = hex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;        final int bridgeElevation = hex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; crowd = game.getEntities(coords);</b>
<b class="nc">&nbsp;        while (crowd.hasNext()) {</b>
<b class="nc">&nbsp;            Entity e = crowd.next();</b>
&nbsp;
<b class="nc">&nbsp;            if (buildingElevation &gt;= e.getElevation() || bridgeElevation &gt;= e.getElevation()) {</b>
<b class="nc">&nbsp;                mass += e.getWeight();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return mass;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Gets valid &amp; empty starting coords around the specified point. This
&nbsp;     * method iterates through the list of Coords and returns the first Coords
&nbsp;     * that does not have a stacking violation.
&nbsp;     */
&nbsp;    protected Coords getFirstValidCoords(Entity deployedUnit, List&lt;Coords&gt; possibleDeployCoords) {
&nbsp;        // Check all of the hexes in order.
<b class="nc">&nbsp;        for (Coords dest : possibleDeployCoords) {</b>
<b class="nc">&nbsp;            Entity violation = Compute.stackingViolation(game, deployedUnit,</b>
<b class="nc">&nbsp;                    dest, deployedUnit.getElevation(), dest, null);</b>
&nbsp;            // Ignore coords that could cause a stacking violation
<b class="nc">&nbsp;            if (violation != null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Make sure we don&#39;t overload any buildings in this hex.
<b class="nc">&nbsp;            Building building = game.getBoard().getBuildingAt(dest);</b>
<b class="nc">&nbsp;            if (null != building) {</b>
<b class="nc">&nbsp;                double mass = getMassOfAllInBuilding(game, dest) + deployedUnit.getWeight();</b>
<b class="nc">&nbsp;                if (mass &gt; building.getCurrentCF(dest)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return dest;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        System.out.println(&quot;Returning no deployment position; THIS IS BAD!&quot;);</b>
&nbsp;        // If NONE of them are acceptable, then just return null.
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected List&lt;Coords&gt; getStartingCoordsArray(Entity deployed_ent) {
&nbsp;        int highest_elev, lowest_elev, weapon_count;
&nbsp;        double av_range, ideal_elev;
&nbsp;        double adjusted_damage, max_damage, total_damage;
<b class="nc">&nbsp;        IBoard board = game.getBoard();</b>
&nbsp;        Coords highestHex;
<b class="nc">&nbsp;        List&lt;RankedCoords&gt; validCoords = new LinkedList&lt;&gt;();</b>
&nbsp;        Vector&lt;Entity&gt; valid_attackers;
&nbsp;        WeaponAttackAction test_attack;
<b class="nc">&nbsp;        List&lt;ECMInfo&gt; allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</b>
<b class="nc">&nbsp;                .getEntitiesVector());</b>
&nbsp;
&nbsp;        // Create array of hexes in the deployment zone that can be deployed to
&nbsp;        // Check for prohibited terrain, stacking limits
<b class="nc">&nbsp;        for (int x = 0; x &lt;= board.getWidth(); x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt;= board.getHeight(); y++) {</b>
<b class="nc">&nbsp;                Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;                if (board.isLegalDeployment(c, deployed_ent.getStartingPos())</b>
<b class="nc">&nbsp;                    &amp;&amp; !deployed_ent.isLocationProhibited(c)) {</b>
<b class="nc">&nbsp;                    validCoords.add(new RankedCoords(c, 0));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Randomize hexes to prevent clumping at the upper-left corner on
&nbsp;        // very flat maps
<b class="nc">&nbsp;        Collections.shuffle(validCoords);</b>
&nbsp;
&nbsp;        // Now get minimum and maximum elevation levels for these hexes
<b class="nc">&nbsp;        highest_elev = Integer.MIN_VALUE;</b>
&nbsp;
<b class="nc">&nbsp;        lowest_elev = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        for (RankedCoords c : validCoords) {</b>
<b class="nc">&nbsp;            int elev = board.getHex(c.getX(), c.getY()).getLevel();</b>
<b class="nc">&nbsp;            if (elev &gt; highest_elev) {</b>
<b class="nc">&nbsp;                highest_elev = board.getHex(c.getX(), c.getY()).getLevel();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (elev &lt; lowest_elev) {</b>
<b class="nc">&nbsp;                lowest_elev = board.getHex(c.getX(), c.getY()).getLevel();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Calculate average range of all weapons
&nbsp;        // Do not include ATMs, but DO include each bin of ATM ammo
&nbsp;        // Increase average range if the unit has an active c3 link
<b class="nc">&nbsp;        av_range = 0.0;</b>
<b class="nc">&nbsp;        weapon_count = 0;</b>
<b class="nc">&nbsp;        for (Mounted mounted : deployed_ent.getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="nc">&nbsp;            if ((!wtype.getName().equals(&quot;ATM 3&quot;))</b>
<b class="nc">&nbsp;                &amp;&amp; (!wtype.getName().equals(&quot;ATM 6&quot;))</b>
<b class="nc">&nbsp;                &amp;&amp; (!wtype.getName().equals(&quot;ATM 9&quot;))</b>
<b class="nc">&nbsp;                &amp;&amp; (!wtype.getName().equals(&quot;ATM 12&quot;))) {</b>
<b class="nc">&nbsp;                if (deployed_ent.getC3Master() != null) {</b>
<b class="nc">&nbsp;                    av_range += wtype.getLongRange() * 1.25;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    av_range += wtype.getLongRange();</b>
&nbsp;                }
<b class="nc">&nbsp;                weapon_count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Mounted mounted : deployed_ent.getAmmo()) {</b>
<b class="nc">&nbsp;            AmmoType atype = (AmmoType) mounted.getType();</b>
<b class="nc">&nbsp;            if (atype.getAmmoType() == AmmoType.T_ATM) {</b>
<b class="nc">&nbsp;                weapon_count++;</b>
<b class="nc">&nbsp;                av_range += 15.0;</b>
<b class="nc">&nbsp;                if (atype.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE) {</b>
<b class="nc">&nbsp;                    av_range -= 6;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (atype.getMunitionType() == AmmoType.M_EXTENDED_RANGE) {</b>
<b class="nc">&nbsp;                    av_range += 12.0;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (atype.getAmmoType() == AmmoType.T_MML) {</b>
<b class="nc">&nbsp;                weapon_count++;</b>
<b class="nc">&nbsp;                if (atype.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    av_range = 9.0;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    av_range = 21.0;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        av_range = av_range / weapon_count;</b>
&nbsp;
&nbsp;        // Calculate ideal elevation as a factor of average range of 18 being
&nbsp;        // highest elevation.  Fast, non-jumping units should deploy towards
&nbsp;        // the middle elevations to avoid getting stuck up a cliff.
<b class="nc">&nbsp;        if ((deployed_ent.getJumpMP() == 0) &amp;&amp;</b>
<b class="nc">&nbsp;            (deployed_ent.getWalkMP() &gt; 5)) {</b>
<b class="nc">&nbsp;            ideal_elev = lowest_elev + ((highest_elev - lowest_elev) / 3.0);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ideal_elev = lowest_elev</b>
&nbsp;                         + ((av_range / 18) * (highest_elev - lowest_elev));
&nbsp;        }
<b class="nc">&nbsp;        if (ideal_elev &gt; highest_elev) {</b>
<b class="nc">&nbsp;            ideal_elev = highest_elev;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double highestFitness = -5000;</b>
&nbsp;        
<b class="nc">&nbsp;        for (RankedCoords coord : validCoords) {</b>
&nbsp;
&nbsp;            // Calculate the fitness factor for each hex and save it to the array
&nbsp;            // -&gt; Absolute difference between hex elevation and ideal elevation decreases fitness
<b class="nc">&nbsp;            coord.setFitness(-1 * (Math.abs(ideal_elev - board.getHex(coord.getX(), coord.getY()).getLevel())));</b>
&nbsp;
<b class="nc">&nbsp;            total_damage = 0.0;</b>
<b class="nc">&nbsp;            deployed_ent.setPosition(coord.getCoords());</b>
&nbsp;
&nbsp;            // Create a list of potential attackers/targets for this location
<b class="nc">&nbsp;            List&lt;Entity&gt; potentialAttackers =</b>
<b class="nc">&nbsp;                    game.getValidTargets(deployed_ent);</b>
<b class="nc">&nbsp;            valid_attackers = new Vector&lt;&gt;(potentialAttackers.size());</b>
<b class="nc">&nbsp;            for (Entity e : potentialAttackers) {</b>
&nbsp;
&nbsp;                // Unit must be deployed and not off board, with valid position
<b class="nc">&nbsp;                if ((e.isDeployed()) &amp;&amp; !e.isOffBoard()</b>
<b class="nc">&nbsp;                    &amp;&amp; e.getPosition() != null) {</b>
<b class="nc">&nbsp;                    int dist = deployed_ent.getPosition().distance(</b>
<b class="nc">&nbsp;                            e.getPosition());</b>
&nbsp;                    // Approximation of effective range, we could use av_range,
&nbsp;                    //  however that could bad if deploy_ent is short ranged
&nbsp;                    //  and a potential  target is long range
<b class="nc">&nbsp;                    if (dist &lt; 18) {</b>
<b class="nc">&nbsp;                        valid_attackers.add(e);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // -&gt; Approximate total damage taken in the current position; this
&nbsp;            // keeps units from deploying into x-fires
<b class="nc">&nbsp;            for (Entity test_ent : valid_attackers) {</b>
<b class="nc">&nbsp;                for (Mounted mounted : test_ent.getWeaponList()) {</b>
<b class="nc">&nbsp;                    test_attack = new WeaponAttackAction(test_ent.getId(),</b>
<b class="nc">&nbsp;                                                         deployed_ent.getId(),</b>
<b class="nc">&nbsp;                                                         test_ent.getEquipmentNum(mounted));</b>
<b class="nc">&nbsp;                    adjusted_damage = BotClient.getDeployDamage(game,</b>
&nbsp;                                                                test_attack, allECMInfo);
<b class="nc">&nbsp;                    total_damage += adjusted_damage;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            coord.fitness -= (total_damage / 10);</b>
&nbsp;
&nbsp;            // -&gt; Find the best target for each weapon and approximate the
&nbsp;            // damage; maybe we can kill stuff without moving!
&nbsp;            // -&gt; Conventional infantry ALWAYS come out on the short end of the
&nbsp;            // stick in damage given/taken... solutions?
<b class="nc">&nbsp;            total_damage = 0.0;</b>
<b class="nc">&nbsp;            for (Mounted mounted : deployed_ent.getWeaponList()) {</b>
<b class="nc">&nbsp;                max_damage = 0.0;</b>
<b class="nc">&nbsp;                for (Entity test_ent : valid_attackers) {</b>
<b class="nc">&nbsp;                    test_attack = new WeaponAttackAction(deployed_ent.getId(),</b>
<b class="nc">&nbsp;                                                         test_ent.getId(),</b>
<b class="nc">&nbsp;                                                         deployed_ent.getEquipmentNum(mounted));</b>
<b class="nc">&nbsp;                    adjusted_damage = BotClient.getDeployDamage(game,</b>
&nbsp;                                                                test_attack, allECMInfo);
<b class="nc">&nbsp;                    if (adjusted_damage &gt; max_damage) {</b>
<b class="nc">&nbsp;                        max_damage = adjusted_damage;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                total_damage += max_damage;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            coord.fitness += (total_damage / 10);</b>
&nbsp;
&nbsp;            // Mech
<b class="nc">&nbsp;            if (deployed_ent.hasETypeFlag(Entity.ETYPE_MECH)) {</b>
&nbsp;                // -&gt; Trees are good, when they&#39;re tall enough
&nbsp;                // -&gt; Water isn&#39;t that great below depth 1 -&gt; this saves actual
&nbsp;                // ground space for infantry/vehicles (minor)
<b class="nc">&nbsp;                int x = coord.getX();</b>
<b class="nc">&nbsp;                int y = coord.getY();</b>
<b class="nc">&nbsp;                if (board.getHex(x, y).containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                        &amp;&amp; board.getHex(x, y).terrainLevel(Terrains.FOLIAGE_ELEV) &gt; 1) {</b>
<b class="nc">&nbsp;                    coord.fitness += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (board.getHex(x, y).containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                    if (board.getHex(x, y).depth() &gt; 1) {</b>
<b class="nc">&nbsp;                        coord.fitness -= board.getHex(x, y).depth();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                //If building, make sure not too heavy to safely move out of
<b class="nc">&nbsp;                coord.fitness -= potentialBuildingDamage(coord.getX(), coord.getY(),</b>
&nbsp;                                                         deployed_ent);
&nbsp;            }
&nbsp;
&nbsp;            // Infantry
&nbsp;
<b class="nc">&nbsp;            if (deployed_ent.hasETypeFlag(Entity.ETYPE_INFANTRY)) {</b>
&nbsp;                // -&gt; Trees and buildings make good cover, esp for conventional
&nbsp;                // infantry
&nbsp;                // rough is nice, too
&nbsp;                // -&gt; Massed infantry is more effective, so try to cluster them
<b class="nc">&nbsp;                if (board.getHex(coord.getX(), coord.getY()).containsTerrain(</b>
&nbsp;                        Terrains.ROUGH)) {
<b class="nc">&nbsp;                    coord.fitness += 1.5;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (board.getHex(coord.getX(), coord.getY()).containsTerrain(</b>
&nbsp;                        Terrains.WOODS)) {
<b class="nc">&nbsp;                    coord.fitness += 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (board.getHex(coord.getX(), coord.getY()).containsTerrain(</b>
&nbsp;                        Terrains.BUILDING)) {
<b class="nc">&nbsp;                    coord.fitness += 4;</b>
&nbsp;                }
<b class="nc">&nbsp;                highestHex = coord.getCoords();</b>
<b class="nc">&nbsp;                for (Entity test_ent : game.getEntitiesVector(highestHex)) {</b>
<b class="nc">&nbsp;                    if ((deployed_ent.getOwner().equals(test_ent.getOwner()))</b>
<b class="nc">&nbsp;                        &amp;&amp; !deployed_ent.equals(test_ent)) {</b>
<b class="nc">&nbsp;                        if (test_ent instanceof Infantry) {</b>
<b class="nc">&nbsp;                            coord.fitness += 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                boolean foundAdj = false;</b>
<b class="nc">&nbsp;                IPlayer owner = deployed_ent.getOwner();</b>
<b class="nc">&nbsp;                for (int x = 0; x &lt; 6 &amp;&amp; !foundAdj; x++) {</b>
<b class="nc">&nbsp;                    highestHex = coord.getCoords().translated(x);</b>
<b class="nc">&nbsp;                    for (Entity test_ent : game.getEntitiesVector(highestHex)) {</b>
<b class="nc">&nbsp;                        if ((owner.equals(test_ent.getOwner()))</b>
<b class="nc">&nbsp;                            &amp;&amp; !deployed_ent.equals(test_ent)</b>
&nbsp;                            &amp;&amp; (test_ent instanceof Infantry)) {
&nbsp;
<b class="nc">&nbsp;                            coord.fitness += 1;</b>
<b class="nc">&nbsp;                            foundAdj = true;</b>
&nbsp;
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                // Not sure why bot tries to deploy infantry in water, it SHOULD
&nbsp;                // be caught by the isHexProhibited method when
&nbsp;                // selecting hexes, but sometimes it has a mind of its own so...
<b class="nc">&nbsp;                if (board.getHex(coord.getX(), coord.getY()).containsTerrain(</b>
&nbsp;                        Terrains.WATER)) {
<b class="nc">&nbsp;                    coord.fitness -= 10;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // some criteria for deploying non-vtol tanks
<b class="nc">&nbsp;            if (deployed_ent.hasETypeFlag(Entity.ETYPE_TANK) &amp;&amp;</b>
<b class="nc">&nbsp;                    !deployed_ent.hasETypeFlag(Entity.ETYPE_VTOL)) {</b>
&nbsp;                // Tracked vehicle
&nbsp;                // -&gt; Trees increase fitness
<b class="nc">&nbsp;                if (deployed_ent.getMovementMode() == EntityMovementMode.TRACKED) {</b>
<b class="nc">&nbsp;                    if (board.getHex(coord.getX(), coord.getY()).containsTerrain(Terrains.WOODS)) {</b>
<b class="nc">&nbsp;                        coord.fitness += 2;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Wheeled vehicle
&nbsp;                // -&gt; Not sure what any benefits wheeled vehicles can get; for
&nbsp;                // now, just elevation and damage taken/given
&nbsp;                // Hover vehicle
&nbsp;                // -&gt; Water in hex increases fitness, hover vehicles have an
&nbsp;                // advantage in water areas
<b class="nc">&nbsp;                if (deployed_ent.getMovementMode() == EntityMovementMode.HOVER) {</b>
<b class="nc">&nbsp;                    if (board.getHex(coord.getX(), coord.getY()).containsTerrain(</b>
&nbsp;                            Terrains.WATER)) {
<b class="nc">&nbsp;                        coord.fitness += 2;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // If building, make sure not too heavy to safely move out of.
<b class="nc">&nbsp;                coord.fitness -= potentialBuildingDamage(coord.getX(), coord.getY(),</b>
&nbsp;                                                         deployed_ent);
&nbsp;            }
&nbsp;            
&nbsp;            // ProtoMech
&nbsp;            // -&gt;
&nbsp;            // -&gt; Trees increase fitness by +2 (minor)
<b class="nc">&nbsp;            if (deployed_ent instanceof Protomech) {</b>
<b class="nc">&nbsp;                if (board.getHex(coord.getX(), coord.getY()).containsTerrain(</b>
&nbsp;                        Terrains.WOODS)) {
<b class="nc">&nbsp;                    coord.fitness += 2;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Make sure I&#39;m not stuck in a dead-end.
<b class="nc">&nbsp;            coord.fitness += calculateEdgeAccessFitness(deployed_ent, board);</b>
&nbsp;            
<b class="nc">&nbsp;            if(coord.fitness &gt; highestFitness) {</b>
<b class="nc">&nbsp;                highestFitness = coord.fitness;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // now, we double check: did we get a bunch of coordinates with a value way below 0?
&nbsp;        // This indicates that we do not have a way of getting to the opposite board edge,
&nbsp;        // even when considering terrain destruction
&nbsp;        // attempt to deploy in the biggest area this unit can access instead
<b class="nc">&nbsp;        if(highestFitness &lt; -10) {</b>
<b class="nc">&nbsp;            for(RankedCoords rc : validCoords) {</b>
<b class="nc">&nbsp;                rc.fitness += getClusterTracker().getBoardClusterSize(deployed_ent, rc.coords, false);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Now sort the valid array.
<b class="nc">&nbsp;        Collections.sort(validCoords);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Coords&gt; result = new ArrayList&lt;&gt;(validCoords.size());</b>
<b class="nc">&nbsp;        for (RankedCoords rc : validCoords) {</b>
<b class="nc">&nbsp;            result.add(rc.getCoords());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the given entity has reasonable access to the &quot;opposite&quot; edge of the board from its
&nbsp;     * current position. Returns 0 if this can be accomplished without destroying any terrain, 
&nbsp;     * -50 if this can be accomplished but terrain must be destroyed,
&nbsp;     * -100 if this cannot be accomplished at all
&nbsp;     */
&nbsp;    private int calculateEdgeAccessFitness(Entity entity, IBoard board) {
&nbsp;        // Flying units can always get anywhere
<b class="nc">&nbsp;        if (entity.isAirborne() || entity instanceof VTOL) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        CardinalEdge destinationEdge = BoardUtilities.determineOppositeEdge(entity);</b>
&nbsp;        
<b class="nc">&nbsp;        int noReductionZoneSize = getClusterTracker().getDestinationCoords(entity, destinationEdge, false).size();</b>
<b class="nc">&nbsp;        int reductionZoneSize = getClusterTracker().getDestinationCoords(entity, destinationEdge, true).size();</b>
&nbsp;        
<b class="nc">&nbsp;        if (noReductionZoneSize &gt; 0) {</b>
<b class="nc">&nbsp;            return 0;</b>
<b class="nc">&nbsp;        } else if (reductionZoneSize &gt; 0) {</b>
<b class="nc">&nbsp;            return -50;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return -100;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private double potentialBuildingDamage(int x, int y, Entity entity) {
<b class="nc">&nbsp;        Coords coords = new Coords(x, y);</b>
<b class="nc">&nbsp;        Building building = game.getBoard().getBuildingAt(coords);</b>
<b class="nc">&nbsp;        if (building == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int potentialDmg = (int) Math.ceil((double) building.getCurrentCF(coords) / 10);</b>
<b class="nc">&nbsp;        boolean aptGunnery = entity.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</b>
<b class="nc">&nbsp;        double oddsTakeDmg = 1 - (Compute.oddsAbove(entity.getCrew().getPiloting(), aptGunnery) / 100);</b>
<b class="nc">&nbsp;        return potentialDmg * oddsTakeDmg;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Missile hits table
&nbsp;    // Some of these are interpolated for odd weapons sizes found in Protos and
&nbsp;    // new BAs
<b class="fc">&nbsp;    private static float[] expectedHitsByRackSize = {0.0f, 1.0f, 1.58f, 2.0f,</b>
&nbsp;                                                     2.63f, 3.17f, 4.0f, 4.49f, 4.98f, 5.47f, 6.31f, 7.23f, 8.14f,
&nbsp;                                                     8.59f, 9.04f, 9.5f, 0.0f, 0.0f, 0.0f, 0.0f, 12.7f};
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the expected damage of a weapon attack, based on to-hit, salvo
&nbsp;     * sizes, etc. This has been copied almost wholesale from
&nbsp;     * Compute.getExpectedDamage; the logfile print commands were removed due to
&nbsp;     * excessive data generated
&nbsp;     */
&nbsp;    private static float getDeployDamage(IGame g, WeaponAttackAction waa, List&lt;ECMInfo&gt; allECMInfo) {
<b class="nc">&nbsp;        Entity attacker = g.getEntity(waa.getEntityId());</b>
<b class="nc">&nbsp;        boolean naturalAptGunnery = attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</b>
<b class="nc">&nbsp;        Mounted weapon = attacker.getEquipment(waa.getWeaponId());</b>
<b class="nc">&nbsp;        ToHitData hitData = waa.toHit(g, allECMInfo);</b>
<b class="nc">&nbsp;        if (hitData.getValue() &gt; 12) {</b>
<b class="nc">&nbsp;            return 0.0f;</b>
&nbsp;        }
&nbsp;
&nbsp;        float fChance;
<b class="nc">&nbsp;        if (hitData.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            fChance = 1.0f;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            fChance = (float) Compute.oddsAbove(hitData.getValue(), naturalAptGunnery) / 100.0f;</b>
&nbsp;        }
&nbsp;
&nbsp;        // TODO : update for BattleArmor.
&nbsp;
&nbsp;        float fDamage;
<b class="nc">&nbsp;        WeaponType wt = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;        if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="nc">&nbsp;            if (weapon.getLinked() == null) {</b>
<b class="nc">&nbsp;                return 0.0f;</b>
&nbsp;            }
<b class="nc">&nbsp;            AmmoType at = (AmmoType) weapon.getLinked().getType();</b>
&nbsp;
&nbsp;            float fHits;
<b class="nc">&nbsp;            if ((wt.getAmmoType() == AmmoType.T_SRM_STREAK)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_MRM_STREAK)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_LRM_STREAK)) {</b>
<b class="nc">&nbsp;                fHits = wt.getRackSize();</b>
<b class="nc">&nbsp;            } else if ((wt.getRackSize() == 40) || (wt.getRackSize() == 30)) {</b>
<b class="nc">&nbsp;                fHits = 2.0f * expectedHitsByRackSize[wt.getRackSize() / 2];</b>
&nbsp;            } else {
<b class="nc">&nbsp;                fHits = expectedHitsByRackSize[wt.getRackSize()];</b>
&nbsp;            }
&nbsp;            // adjust for previous AMS
<b class="nc">&nbsp;            ArrayList&lt;Mounted&gt; vCounters = waa.getCounterEquipment();</b>
<b class="nc">&nbsp;            if (wt.hasFlag(WeaponType.F_MISSILE) &amp;&amp; vCounters != null) {</b>
<b class="nc">&nbsp;                for (Mounted vCounter : vCounters) {</b>
<b class="nc">&nbsp;                    EquipmentType type = vCounter.getType();</b>
<b class="nc">&nbsp;                    if ((type instanceof WeaponType)</b>
<b class="nc">&nbsp;                        &amp;&amp; type.hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;                        float fAMS = 3.5f * ((WeaponType) type).getDamage();</b>
<b class="nc">&nbsp;                        fHits = Math.max(0.0f, fHits - fAMS);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // damage is expected missiles * damage per missile
<b class="nc">&nbsp;            fDamage = fHits * at.getDamagePerShot();</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            fDamage = wt.getDamage();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        fDamage *= fChance;</b>
<b class="nc">&nbsp;        return fDamage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If the unit has stealth armor, turning it off is probably a good idea if
&nbsp;     * most of the enemy force is at &#39;short&#39; range or if in danger of
&nbsp;     * overheating
&nbsp;     */
&nbsp;
&nbsp;    private void toggleStealth() {
&nbsp;
<b class="nc">&nbsp;        initialize();</b>
&nbsp;
&nbsp;        int total_bv, known_bv, known_range, known_count, trigger_range;
&nbsp;        int new_stealth;
&nbsp;
<b class="nc">&nbsp;        for (Entity check_ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if ((check_ent.getOwnerId() == localPlayerNumber)</b>
&nbsp;                &amp;&amp; (check_ent instanceof Mech)) {
<b class="nc">&nbsp;                if (check_ent.hasStealth()</b>
<b class="nc">&nbsp;                        &amp;&amp; (check_ent.getPosition() != null)) {</b>
<b class="nc">&nbsp;                    for (Mounted mEquip : check_ent.getMisc()) {</b>
<b class="nc">&nbsp;                        MiscType mtype = (MiscType) mEquip.getType();</b>
<b class="nc">&nbsp;                        if (mtype.hasFlag(MiscType.F_STEALTH)) {</b>
&nbsp;
&nbsp;                            // If the Mech is in danger of shutting down (14+
&nbsp;                            // heat), consider shutting
&nbsp;                            // off the armor
&nbsp;
<b class="nc">&nbsp;                            trigger_range = 13 + Compute.randomInt(7);</b>
<b class="nc">&nbsp;                            if (check_ent.heat &gt; trigger_range) {</b>
<b class="nc">&nbsp;                                new_stealth = 0;</b>
&nbsp;                            } else {
&nbsp;
&nbsp;                                // Mech is not in danger of shutting down soon;
&nbsp;                                // if most of the
&nbsp;                                // enemy is right next to the Mech deactivate
&nbsp;                                // armor to free up
&nbsp;                                // heatsinks for weapons fire
&nbsp;
<b class="nc">&nbsp;                                total_bv = 0;</b>
<b class="nc">&nbsp;                                known_bv = 0;</b>
<b class="nc">&nbsp;                                known_range = 0;</b>
<b class="nc">&nbsp;                                known_count = 0;</b>
&nbsp;
<b class="nc">&nbsp;                                for (Entity test_ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                                    if (check_ent.isEnemyOf(test_ent)) {</b>
<b class="nc">&nbsp;                                        total_bv += test_ent</b>
<b class="nc">&nbsp;                                                .calculateBattleValue();</b>
<b class="nc">&nbsp;                                        if (test_ent.isVisibleToEnemy()) {</b>
<b class="nc">&nbsp;                                            known_count++;</b>
<b class="nc">&nbsp;                                            known_bv += test_ent</b>
<b class="nc">&nbsp;                                                    .calculateBattleValue();</b>
<b class="nc">&nbsp;                                            known_range += Compute</b>
<b class="nc">&nbsp;                                                    .effectiveDistance(game,</b>
&nbsp;                                                                       check_ent, test_ent);
&nbsp;                                        }
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                // If no or few enemy units are visible, they&#39;re
&nbsp;                                // hiding;
&nbsp;                                // Default to stealth armor on in this case
&nbsp;
<b class="nc">&nbsp;                                if ((known_count == 0)</b>
&nbsp;                                    || (known_bv &lt; (total_bv / 2))) {
<b class="nc">&nbsp;                                    new_stealth = 1;</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    if ((known_range / known_count) &lt;= (5 + Compute</b>
<b class="nc">&nbsp;                                            .randomInt(5))) {</b>
<b class="nc">&nbsp;                                        new_stealth = 0;</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        new_stealth = 1;</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            mEquip.setMode(new_stealth);</b>
<b class="nc">&nbsp;                            sendModeChange(check_ent.getId(), check_ent</b>
<b class="nc">&nbsp;                                    .getEquipmentNum(mEquip), new_stealth);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private String getRandomBotMessage() {
<b class="nc">&nbsp;        String message = &quot;&quot;;</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            String scrapFile = &quot;./mmconf/botmessages.txt&quot;;</b>
<b class="nc">&nbsp;            FileInputStream fis = new FileInputStream(scrapFile);</b>
<b class="nc">&nbsp;            BufferedReader dis = new BufferedReader(new InputStreamReader(fis));</b>
<b class="nc">&nbsp;            while (dis.ready()) {</b>
<b class="nc">&nbsp;                message = dis.readLine();</b>
<b class="nc">&nbsp;                if (Compute.randomInt(10) == 1) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            dis.close();</b>
<b class="nc">&nbsp;            fis.close();</b>
&nbsp;        }// File not found don&#39;t do anything just return a null and allow the
&nbsp;        // bot to remain silent
<b class="nc">&nbsp;        catch (FileNotFoundException fnfe) {</b>
&nbsp;            // no chat message found continue on.
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }// CYA exception
<b class="nc">&nbsp;        catch (Exception ex) {</b>
<b class="nc">&nbsp;            System.err.println(&quot;Error while reading ./mmconf/botmessages.txt.&quot;);</b>
<b class="nc">&nbsp;            ex.printStackTrace();</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return message;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Pops up a dialog box showing an alert
&nbsp;     */
&nbsp;    public void doAlertDialog(String title, String message) {
<b class="nc">&nbsp;        JTextPane textArea = new JTextPane();</b>
<b class="nc">&nbsp;        ReportDisplay.setupStylesheet(textArea);</b>
&nbsp;
<b class="nc">&nbsp;        textArea.setEditable(false);</b>
<b class="nc">&nbsp;        JScrollPane scrollPane = new JScrollPane(textArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,</b>
&nbsp;                                                 ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
<b class="nc">&nbsp;        textArea.setText(&quot;&lt;pre&gt;&quot; + message + &quot;&lt;/pre&gt;&quot;);</b>
<b class="nc">&nbsp;        JOptionPane.showMessageDialog(frame, scrollPane, title, JOptionPane.ERROR_MESSAGE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected void correctName(Packet inP) {
&nbsp;        // If we have a clientgui, it keeps track of a Name -&gt; Client map, and
&nbsp;        //  we need to update that map with this name change.
<b class="nc">&nbsp;        if (getClientGUI() != null) {</b>
<b class="nc">&nbsp;            Map&lt;String, Client&gt; bots = getClientGUI().getBots();</b>
<b class="nc">&nbsp;            String oldName = getName();</b>
<b class="nc">&nbsp;            String newName = (String) (inP.getObject(0));</b>
<b class="nc">&nbsp;            assert (equals(bots.get(oldName)));</b>
<b class="nc">&nbsp;            bots.remove(oldName);</b>
<b class="nc">&nbsp;            bots.put(newName, this);</b>
&nbsp;        }
<b class="nc">&nbsp;        setName((String) (inP.getObject(0)));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private ClientGUI getClientGUI() {
<b class="nc">&nbsp;        return clientgui;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setClientGUI(ClientGUI clientgui) {
<b class="nc">&nbsp;        this.clientgui = clientgui;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void endOfTurnProcessing() {
&nbsp;        // Do nothing;
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveBuildingCollapse(Packet packet) {
<b class="nc">&nbsp;        game.getBoard().collapseBuilding((Vector&lt;Coords&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public BoardClusterTracker getClusterTracker() {
<b class="nc">&nbsp;        return boardClusterTracker;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private class RankedCoords implements Comparable&lt;RankedCoords&gt; {</b>
&nbsp;        private Coords coords;
&nbsp;        private double fitness;
&nbsp;
<b class="nc">&nbsp;        RankedCoords(Coords coords, double fitness) {</b>
<b class="nc">&nbsp;            if (coords == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Coords cannot be null.&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            this.coords = coords;</b>
<b class="nc">&nbsp;            this.fitness = fitness;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Coords getCoords() {
<b class="nc">&nbsp;            return coords;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        public void setCoords(Coords coords) {
<b class="nc">&nbsp;            if (coords == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Coords cannot be null.&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            this.coords = coords;</b>
&nbsp;        }
&nbsp;
&nbsp;        public double getFitness() {
<b class="nc">&nbsp;            return fitness;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setFitness(double fitness) {
<b class="nc">&nbsp;            this.fitness = fitness;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="nc">&nbsp;            if (this == o) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!(o instanceof RankedCoords)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            RankedCoords coords1 = (RankedCoords) o;</b>
&nbsp;
<b class="nc">&nbsp;            if (Double.compare(coords1.fitness, fitness) != 0) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            //noinspection RedundantIfStatement
<b class="nc">&nbsp;            if (!coords.equals(coords1.coords)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
&nbsp;            int result;
&nbsp;            long temp;
<b class="nc">&nbsp;            result = coords.hashCode();</b>
<b class="nc">&nbsp;            temp = Double.doubleToLongBits(fitness);</b>
<b class="nc">&nbsp;            result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;RankedCoords{&quot; +</b>
&nbsp;                   &quot;coords=&quot; + coords +
&nbsp;                   &quot;, fitness=&quot; + fitness +
&nbsp;                   &#39;}&#39;;
&nbsp;        }
&nbsp;
&nbsp;        int getX() {
<b class="nc">&nbsp;            return coords.getX();</b>
&nbsp;        }
&nbsp;
&nbsp;        int getY() {
<b class="nc">&nbsp;            return coords.getY();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int compareTo(RankedCoords o) {
<b class="nc">&nbsp;            return -Double.compare(getFitness(), o.getFitness());</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
