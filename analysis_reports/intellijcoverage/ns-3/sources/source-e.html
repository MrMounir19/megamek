


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TestBot</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot</a>
</div>

<h1>Coverage Summary for Class: TestBot (megamek.client.bot)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestBot</td>
<td class="coverageStat">
  <span class="percent">
    3.3%
  </span>
  <span class="absValue">
    (1/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.1%
  </span>
  <span class="absValue">
    (1/1440)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestBot$CalculateEntityMove</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$06RhEx5q</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$0lKasIiw</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$0rhbNi1Z</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$0zUnib8I</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$18oABzpc</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$1w7ywdY7</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$29Q5KU1S</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$2jQnu3xs</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$2RFX3d3B</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$2xvurr7Q</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$3IYwQgXg</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$3O0FnPyE</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$3Sicmtqe</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$3X5d6urc</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$3zfSpQ88</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$4baZUw0w</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$4g8p58cZ</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$4k1URezk</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$5C4u8xk2</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$5KLRhPvC</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$6gz4BsiW</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$6JmLwBcR</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$6z4DvwXB</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$7hETpOV1</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$7jTWLVBm</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$7soXFShc</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$8BITtQTt</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Ac0iaCAs</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$AcAsBLJU</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$AJ6WocSw</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Am9BY6J1</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$AqcXeybL</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$aUlD8OAp</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$aVRnCtBr</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$B4kNN0Yf</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$BatC8hfr</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$bhgpXzZT</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$BKiFAkaD</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$bZaMc4qK</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$CACGprbJ</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$CmtYoa5C</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$CqIETMVv</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$d0SnCvqA</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$d4bTBMTA</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$D5tt3WWo</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$d73ytQkD</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$dDAnxHWC</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$EIg9L33E</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$ejvNEdZU</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$F4laWwZz</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$flKWjADu</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$fLR6fBYi</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$fOPiYqdj</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$fQkzhruW</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$fsOBYk2U</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$fuv0DvjL</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$g0F2c772</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$G0vyl0MX</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$GCauw8xc</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$GGNB9JrD</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$gH2ep8S0</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$GHfOMk1p</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$GKrZdj6E</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$gY1VEEoi</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$H7N2SR4P</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$HaapSuGj</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$hGMe4ujd</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$IElRhEKx</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$IgXSLGXP</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$iO4TkGfp</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$iYniafgL</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$iyvRHcwg</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Jez6aMNT</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$kbwuSLfD</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$KimVY4IN</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$kkO3Jvuw</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$kv0Kz175</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$l2zmhrWz</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$lmSa6oHp</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$loKohnNQ</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$LZPzxUQn</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$lZstNpsC</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$MnzRJ6Na</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$N8NyzjAa</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$NEKeqSON</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$ninUpNC0</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$nl4mKZq6</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$NqUBQNUr</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$o0ES33fL</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$o2mcI3as</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$o4E4GQf8</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$O8AQDqLW</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$o8xgNpWL</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$O9qvNm6a</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$ofUvnp0F</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$ogyMxwbW</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$oHf2zQwY</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$OJ7foXpr</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Ok4ZdHBk</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$olTfYFk7</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$oNgHYLlA</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$OV5bmlKF</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$p0nHtNy7</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$P8KqJA0Z</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$PgnoWdG6</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$PIjFB5DI</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$PMjBHv4E</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Qcyw6JGr</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$QfaRr4HP</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$r6DOtlHQ</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$rBl2wR6k</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$rLEoKi7q</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$rlrChdxG</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$rtlqNTRP</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$rw7eVVuj</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$S4WZ8p9d</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Sjgck7R5</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$SO23s7k9</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$tlCiPVVq</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$tMmYLP4V</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$TqH475rY</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$tTw0rEi7</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$VBDWWaN0</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$vWtBJ5A9</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$W5OaSwo4</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Wjr0sG5i</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$wMS40tT7</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$wRaNyumC</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$Ws8OV3z0</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$x2xzkOkm</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$X8qeauJi</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$XihI8T7G</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$XiwMN9sc</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$xNgAjqzM</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$XWqvMkDs</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$xZ8fG4bR</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$yCQ0w67V</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$YhU46RGs</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$YOQWR8PF</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$YpvCKLje</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$ySmVo12Y</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$YZ5LfrKh</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$zDdUXZV8</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$zg5L9eAr</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$ZlGFgWpL</td>
  </tr>
  <tr>
    <td class="name">TestBot$MockitoMock$2025136599$auxiliary$zPLjEWsh</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    2.9%
  </span>
  <span class="absValue">
    (1/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.1%
  </span>
  <span class="absValue">
    (1/1445)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; * This program is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU General Public License as published by the Free
&nbsp; * Software Foundation; either version 2 of the License, or (at your option)
&nbsp; * any later version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
&nbsp; * more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.client.bot;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.client.bot.MoveOption.DamageInfo;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementType;
&nbsp;import megamek.common.EquipmentType;
&nbsp;import megamek.common.IAimingModes;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.Minefield;
&nbsp;import megamek.common.MiscType;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.actions.ChargeAttackAction;
&nbsp;import megamek.common.actions.DfaAttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.TorsoTwistAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.containers.PlayerIDandList;
&nbsp;import megamek.common.event.GamePlayerChatEvent;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.BoardClusterTracker;
&nbsp;
<b class="fc">&nbsp;public class TestBot extends BotClient {</b>
&nbsp;
<b class="nc">&nbsp;    public CEntity.Table centities = new CEntity.Table(this);</b>
<b class="nc">&nbsp;    protected ChatProcessor chatp = new ChatProcessor();</b>
<b class="nc">&nbsp;    protected int ignore = 10;</b>
<b class="nc">&nbsp;    boolean debug = false;</b>
<b class="nc">&nbsp;    private int enemies_moved = 0;</b>
<b class="nc">&nbsp;    private GALance old_moves = null;</b>
&nbsp;
&nbsp;    public TestBot(String name, String host, int port) {
<b class="nc">&nbsp;        super(name, host, port);</b>
<b class="nc">&nbsp;        ignore = config.getIgnoreLevel();</b>
<b class="nc">&nbsp;        debug = config.isDebug();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void initialize() {
<b class="nc">&nbsp;        boardClusterTracker = new BoardClusterTracker();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public PhysicalOption calculatePhysicalTurn() {
<b class="nc">&nbsp;        return PhysicalCalculator.calculatePhysicalTurn(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used by the function calculateMoveTurn to run each entities movement
&nbsp;     * calculation in a separate thread.
&nbsp;     *
&nbsp;     * @author Mike Kiscaden
&nbsp;     */
&nbsp;    public class CalculateEntityMove implements Runnable {
&nbsp;        private Entity entity;
&nbsp;        private MoveOption[] result;
&nbsp;
<b class="nc">&nbsp;        CalculateEntityMove(Entity entity) {</b>
<b class="nc">&nbsp;            this.entity = entity;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void run() {
<b class="nc">&nbsp;            result = calculateMove(entity);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Entity getEntity() {
<b class="nc">&nbsp;            return entity;</b>
&nbsp;        }
&nbsp;
&nbsp;        public MoveOption[] getResult() {
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MovePath calculateMoveTurn() {
<b class="nc">&nbsp;        long enter = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        int initiative = 0;</b>
<b class="nc">&nbsp;        MoveOption min = null;</b>
&nbsp;
<b class="nc">&nbsp;        System.out.println(&quot;beginning movement calculations...&quot;);</b>
&nbsp;
&nbsp;        // first check and that someone else has moved so we don&#39;t replan
<b class="nc">&nbsp;        Object[] enemy_array = getEnemyEntities().toArray();</b>
<b class="nc">&nbsp;        for (int j = 0; j &lt; enemy_array.length; j++) {</b>
<b class="nc">&nbsp;            if (!((Entity) enemy_array[j]).isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                initiative++;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // if nobody&#39;s moved and we have a valid move waiting, use that
<b class="nc">&nbsp;        if ((initiative == enemies_moved) &amp;&amp; (old_moves != null)) {</b>
<b class="nc">&nbsp;            min = old_moves.getResult();</b>
<b class="nc">&nbsp;            if ((min == null)</b>
<b class="nc">&nbsp;                || !min.isMoveLegal()</b>
<b class="nc">&nbsp;                || (min.isPhysical &amp;&amp; centities.get(min</b>
<b class="nc">&nbsp;                                                            .getPhysicalTargetId()).isPhysicalTarget)) {</b>
<b class="nc">&nbsp;                old_moves = null;</b>
<b class="nc">&nbsp;                System.out</b>
<b class="nc">&nbsp;                        .println(&quot;recalculating moves since the old move was invalid&quot;);</b>
<b class="nc">&nbsp;                return calculateMoveTurn();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            enemies_moved = initiative;</b>
<b class="nc">&nbsp;            ArrayList&lt;MoveOption[]&gt; possible = new ArrayList&lt;MoveOption[]&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            for (Entity entity : game.getEntitiesVector()) {</b>
&nbsp;
&nbsp;                // ignore loaded and off-board units
<b class="nc">&nbsp;                if ((entity.getPosition() == null) || entity.isOffBoard()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                CEntity cen = centities.get(entity);</b>
<b class="nc">&nbsp;                cen.refresh();</b>
<b class="nc">&nbsp;                firstPass(cen);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            Iterator&lt;Entity&gt; i = getEntitiesOwned().iterator();</b>
<b class="nc">&nbsp;            boolean short_circuit = false;</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;();</b>
<b class="nc">&nbsp;            List&lt;CalculateEntityMove&gt; tasks = new ArrayList&lt;CalculateEntityMove&gt;();</b>
<b class="nc">&nbsp;            while (i.hasNext() &amp;&amp; !short_circuit) {</b>
<b class="nc">&nbsp;                Entity entity = i.next();</b>
&nbsp;
&nbsp;                // ignore loaded units
&nbsp;                // (not really necessary unless bot manages to load units)
<b class="nc">&nbsp;                if (entity.getPosition() == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // if we can&#39;t move this entity right now, ignore it
<b class="nc">&nbsp;                if (!game.getTurn().isValidEntity(entity, game)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                CalculateEntityMove task = new CalculateEntityMove(entity);</b>
<b class="nc">&nbsp;                tasks.add(task);</b>
<b class="nc">&nbsp;                Thread worker = new Thread(task);</b>
<b class="nc">&nbsp;                worker.setName(&quot;Entity:&quot; + entity.getId());</b>
<b class="nc">&nbsp;                worker.start();</b>
<b class="nc">&nbsp;                threads.add(worker);</b>
&nbsp;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            int running = 0;</b>
<b class="nc">&nbsp;            synchronized (this) {</b>
&nbsp;                do {
<b class="nc">&nbsp;                    running = 0;</b>
<b class="nc">&nbsp;                    for (Thread thread : threads) {</b>
<b class="nc">&nbsp;                        if (thread.isAlive()) {</b>
<b class="nc">&nbsp;                            running++;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Thread.sleep(5000);</b>
<b class="nc">&nbsp;                    } catch (InterruptedException e1) {</b>
<b class="nc">&nbsp;                        System.out</b>
<b class="nc">&nbsp;                                .println(&quot;Interrupted waiting for Bot to move.&quot;);</b>
<b class="nc">&nbsp;                        e1.printStackTrace();</b>
<b class="nc">&nbsp;                    } // Technically we should be using wait() but its not</b>
&nbsp;                    // waking up reliably.
<b class="nc">&nbsp;                    if (running &gt; 0) {</b>
<b class="nc">&nbsp;                        sendChat(&quot;Calculating the move for &quot; + running</b>
&nbsp;                                 + &quot; units. &quot;);
&nbsp;                    } else {
<b class="nc">&nbsp;                        sendChat(&quot;Finalizing move.&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } while (running &gt; 0);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Threads are done running. Process the results.
<b class="nc">&nbsp;            for (CalculateEntityMove task : tasks) {</b>
<b class="nc">&nbsp;                MoveOption[] result = task.getResult();</b>
<b class="nc">&nbsp;                CEntity cen = centities.get(task.getEntity());</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.BASE_SKIP_INELIGABLE_MOVEMENT)</b>
<b class="nc">&nbsp;                    &amp;&amp; cen.getEntity().isImmobile()) {</b>
<b class="nc">&nbsp;                    cen.moved = true;</b>
<b class="nc">&nbsp;                } else if (result == null) {</b>
<b class="nc">&nbsp;                    short_circuit = true;</b>
<b class="nc">&nbsp;                } else if (!cen.moved) {</b>
<b class="nc">&nbsp;                    if (result.length &lt; 6) {</b>
<b class="nc">&nbsp;                        min = result.length &gt; 0 ? (MoveOption) result[0] : null;</b>
<b class="nc">&nbsp;                        short_circuit = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    possible.add(result);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // should ignore mechs that are not engaged
&nbsp;            // and only do the below when there are 2 or mechs left to move
<b class="nc">&nbsp;            if (!short_circuit) {</b>
<b class="nc">&nbsp;                if ((getEntitiesOwned().size() &gt; 1) &amp;&amp; (possible.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                    GALance lance = new GALance(this, possible, 50, 80);</b>
<b class="nc">&nbsp;                    lance.evolve();</b>
<b class="nc">&nbsp;                    min = lance.getResult();</b>
<b class="nc">&nbsp;                    old_moves = lance;</b>
<b class="nc">&nbsp;                } else if (possible.size() &gt; 0 &amp;&amp; (possible.get(0) != null)</b>
<b class="nc">&nbsp;                           &amp;&amp; (possible.get(0).length &gt; 0)) {</b>
<b class="nc">&nbsp;                    min = possible.get(0)[0];</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (min == null) {</b>
<b class="nc">&nbsp;            min = new MoveOption(game, centities.get(getFirstEntityNum()));</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Object element : enemy_array) {</b>
<b class="nc">&nbsp;            Entity en = (Entity) element;</b>
&nbsp;
&nbsp;            // ignore loaded units
<b class="nc">&nbsp;            if (en.getPosition() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;            int enemy_hit_arc = CEntity.getThreatHitArc(</b>
<b class="nc">&nbsp;                    enemy.current.getFinalCoords(),</b>
<b class="nc">&nbsp;                    enemy.current.getFinalFacing(), min.getFinalCoords());</b>
<b class="nc">&nbsp;            MoveOption.DamageInfo di = min.damageInfos.get(enemy);</b>
<b class="nc">&nbsp;            if (di != null) {</b>
<b class="nc">&nbsp;                enemy.expected_damage[enemy_hit_arc] += di.min_damage;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (enemy.expected_damage[enemy_hit_arc] &gt; 0) {</b>
<b class="nc">&nbsp;                enemy.hasTakenDamage = true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (min.isPhysical) {</b>
<b class="nc">&nbsp;            centities.get(min.getPhysicalTargetId()).isPhysicalTarget = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(min);</b>
<b class="nc">&nbsp;        min.getCEntity().current = min;</b>
<b class="nc">&nbsp;        min.getCEntity().last = min;</b>
<b class="nc">&nbsp;        min.getCEntity().moved = true;</b>
&nbsp;
<b class="nc">&nbsp;        long exit = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        System.out.println(&quot;move turn took &quot; + (exit - enter) + &quot; ms&quot;);</b>
&nbsp;
&nbsp;        // If this unit has a jammed RAC, and it has only walked,
&nbsp;        // add an unjam action
<b class="nc">&nbsp;        if (min.getLastStep() != null) {</b>
<b class="nc">&nbsp;            if (min.getCEntity().entity.canUnjamRAC()) {</b>
<b class="nc">&nbsp;                if ((min.getLastStep().getMovementType(true) == EntityMovementType.MOVE_WALK)</b>
<b class="nc">&nbsp;                    || (min.getLastStep().getMovementType(true) == EntityMovementType.MOVE_VTOL_WALK)</b>
<b class="nc">&nbsp;                    || (min.getLastStep().getMovementType(true) == EntityMovementType.MOVE_NONE)) {</b>
&nbsp;                    // Cycle through all available weapons, only unjam if the
&nbsp;                    // jam(med)
&nbsp;                    // RACs count for a significant portion of possible damage
<b class="nc">&nbsp;                    int rac_damage = 0;</b>
<b class="nc">&nbsp;                    int other_damage = 0;</b>
<b class="nc">&nbsp;                    int clearance_range = 0;</b>
<b class="nc">&nbsp;                    for (Mounted equip : min.getCEntity().entity</b>
<b class="nc">&nbsp;                            .getWeaponList()) {</b>
<b class="nc">&nbsp;                        WeaponType test_weapon = new WeaponType();</b>
&nbsp;
<b class="nc">&nbsp;                        test_weapon = (WeaponType) equip.getType();</b>
<b class="nc">&nbsp;                        if (((test_weapon.getAmmoType() == AmmoType.T_AC_ROTARY)</b>
<b class="nc">&nbsp;                             || (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UAC_TWOROLLS)</b>
<b class="nc">&nbsp;                                 &amp;&amp; ((test_weapon.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                                     || (test_weapon.getAmmoType() == AmmoType.T_AC_ULTRA_THB))))</b>
<b class="nc">&nbsp;                            &amp;&amp; (equip.isJammed() == true)) {</b>
<b class="nc">&nbsp;                            rac_damage = rac_damage + (4 * (test_weapon.getDamage()));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (equip.canFire()) {</b>
<b class="nc">&nbsp;                                other_damage += test_weapon.getDamage();</b>
<b class="nc">&nbsp;                                if (test_weapon.getMediumRange() &gt; clearance_range) {</b>
<b class="nc">&nbsp;                                    clearance_range = test_weapon.getMediumRange();</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // Even if the jammed RAC doesn&#39;t make up a significant
&nbsp;                    // portion
&nbsp;                    // of the units damage, its still better to have it
&nbsp;                    // functional
&nbsp;                    // If nothing is &quot;close&quot; then unjam anyways
<b class="nc">&nbsp;                    int check_range = 100;</b>
<b class="nc">&nbsp;                    for (Entity enemy : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                        if ((min.getCEntity().entity.getPosition() != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; (enemy.getPosition() != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; (enemy.isEnemyOf(min.getCEntity().entity))) {</b>
<b class="nc">&nbsp;                            if (enemy.isVisibleToEnemy()) {</b>
<b class="nc">&nbsp;                                if (min.getCEntity().entity.getPosition()</b>
<b class="nc">&nbsp;                                                           .distance(enemy.getPosition()) &lt; check_range) {</b>
<b class="nc">&nbsp;                                    check_range = min.getCEntity().entity</b>
<b class="nc">&nbsp;                                            .getPosition().distance(</b>
<b class="nc">&nbsp;                                                    enemy.getPosition());</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if ((rac_damage &gt;= other_damage)</b>
&nbsp;                        || (check_range &lt; clearance_range)) {
<b class="nc">&nbsp;                        min.addStep(MoveStepType.UNJAM_RAC);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return min;</b>
&nbsp;    }
&nbsp;
&nbsp;    public MoveOption[] calculateMove(Entity entity) {
<b class="nc">&nbsp;        List&lt;Entity&gt; enemy_array = myEnemies(entity);</b>
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;(</b>
<b class="nc">&nbsp;                game.getEntitiesVector());</b>
<b class="nc">&nbsp;        CEntity self = centities.get(entity);</b>
&nbsp;        MoveOption[] move_array;
<b class="nc">&nbsp;        int friends = entities.size() - enemy_array.size();</b>
&nbsp;
<b class="nc">&nbsp;        move_array = secondPass(self, friends, enemy_array, entities);</b>
&nbsp;        // top balanced
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(1,</b>
&nbsp;                                                                             1), 50);
&nbsp;        // top damage
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(</b>
&nbsp;                .5, 1), 50);
&nbsp;
<b class="nc">&nbsp;        move_array = thirdPass(self, enemy_array);</b>
&nbsp;
&nbsp;        // top balanced
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(1,</b>
&nbsp;                                                                             1), 30);
&nbsp;        // top damage
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(</b>
&nbsp;                .5, 1), 30);
&nbsp;
&nbsp;        // reduce self threat, and add bonus for terrain
<b class="nc">&nbsp;        for (MoveOption option : self.pass.values()) {</b>
<b class="nc">&nbsp;            option.setState();</b>
<b class="nc">&nbsp;            option.self_damage *= .5;</b>
<b class="nc">&nbsp;            option.self_threat *= .5;</b>
&nbsp;            // TODO: should scale to the unit bv
<b class="nc">&nbsp;            double terrain = 2 * ((double) Compute.getTargetTerrainModifier(</b>
<b class="nc">&nbsp;                    game, option.getEntity()).getValue());</b>
<b class="nc">&nbsp;            if (debug) {</b>
<b class="nc">&nbsp;                option.tv.add(terrain + &quot; Terrain Adjusment &quot; + &quot;\n&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            option.self_threat -= terrain;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        move_array = fourthPass(self, enemy_array);</b>
&nbsp;        // top balanced
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(1,</b>
&nbsp;                                                                             1), 20);
&nbsp;        // top damage
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(</b>
&nbsp;                .5, 1), 20);
&nbsp;
&nbsp;        // reduce transient damage estimates
<b class="nc">&nbsp;        for (MoveOption option : self.pass.values()) {</b>
<b class="nc">&nbsp;            option.self_threat *= .5;</b>
<b class="nc">&nbsp;            option.self_damage *= .5;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        move_array = fifthPass(self, enemy_array);</b>
&nbsp;
&nbsp;        /*******************************************************************************************
&nbsp;         * Return top twenty moves to the lance algorithm
&nbsp;         ******************************************************************************************/
<b class="nc">&nbsp;        MoveOption[] result = new MoveOption[Math.min(move_array.length, 20)];</b>
<b class="nc">&nbsp;        int offset = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; Math.min(move_array.length, 20); i++) {</b>
<b class="nc">&nbsp;            MoveOption next = move_array[i];</b>
<b class="nc">&nbsp;            if (next.isPhysical</b>
&nbsp;                &amp;&amp; (self.range_damages[CEntity.RANGE_SHORT] &gt; 5)
&nbsp;                &amp;&amp; next.doomed) {
<b class="nc">&nbsp;                if ((offset + 20) &lt; move_array.length) {</b>
<b class="nc">&nbsp;                    next = move_array[offset + 20];</b>
<b class="nc">&nbsp;                    offset++;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            result[i] = next;</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Entity&gt; myEnemies(Entity me) {
<b class="nc">&nbsp;        List&lt;Entity&gt; possibles = game.getValidTargets(me);</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; retVal = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for (Entity ent : possibles) {</b>
<b class="nc">&nbsp;            if (ent.isEnemyOf(me)) {</b>
<b class="nc">&nbsp;                retVal.add(ent);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * ************************************************************************
&nbsp;     * first pass, filter moves based upon present case
&nbsp;     * ************************************************************************
&nbsp;     */
&nbsp;    private void firstPass(CEntity self) {
<b class="nc">&nbsp;        List&lt;Entity&gt; enemies = getEnemyEntities();</b>
&nbsp;        MoveOption[] move_array;
<b class="nc">&nbsp;        if (self.getEntity().isSelectableThisTurn() &amp;&amp; !self.moved) {</b>
<b class="nc">&nbsp;            move_array = self.getAllMoves(this).values()</b>
<b class="nc">&nbsp;                             .toArray(new MoveOption[0]);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            move_array = new MoveOption[]{self.current};</b>
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(self.getEntity().getShortName() + &quot; has &quot;</b>
&nbsp;                           + move_array.length + &quot; moves&quot;);
<b class="nc">&nbsp;        for (MoveOption option : move_array) {</b>
<b class="nc">&nbsp;            option.setState();</b>
<b class="nc">&nbsp;            boolean aptPiloting = option.getEntity().hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING);</b>
<b class="nc">&nbsp;            for (int e = 0; e &lt; enemies.size(); e++) { // for each enemy</b>
<b class="nc">&nbsp;                Entity en = enemies.get(e);</b>
&nbsp;
&nbsp;                // ignore loaded units
<b class="nc">&nbsp;                if (en.getPosition() == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;                int[] modifiers = option.getModifiers(enemy.getEntity());</b>
<b class="nc">&nbsp;                if ((modifiers[MoveOption.DEFENCE_MOD] == TargetRoll.IMPOSSIBLE)</b>
&nbsp;                    &amp;&amp; (modifiers[MoveOption.ATTACK_MOD] == TargetRoll.IMPOSSIBLE)) {
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                int enemy_hit_arc = CEntity</b>
<b class="nc">&nbsp;                        .getThreatHitArc(enemy.current.getFinalCoords(),</b>
<b class="nc">&nbsp;                                         enemy.current.getFinalFacing(),</b>
<b class="nc">&nbsp;                                         option.getFinalCoords());</b>
<b class="nc">&nbsp;                int self_hit_arc = CEntity.getThreatHitArc(</b>
<b class="nc">&nbsp;                        option.getFinalCoords(), option.getFinalFacing(),</b>
<b class="nc">&nbsp;                        enemy.current.getFinalCoords());</b>
<b class="nc">&nbsp;                if (!enemy.getEntity().isImmobile()</b>
&nbsp;                    &amp;&amp; (modifiers[MoveOption.DEFENCE_MOD] != TargetRoll.IMPOSSIBLE)) {
<b class="nc">&nbsp;                    self.engaged = true;</b>
<b class="nc">&nbsp;                    int mod = modifiers[MoveOption.DEFENCE_MOD];</b>
<b class="nc">&nbsp;                    double max = option.getMaxModifiedDamage(enemy.current,</b>
&nbsp;                                                             mod, modifiers[MoveOption.DEFENCE_PC]);
<b class="nc">&nbsp;                    if (en.isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                        enemy.current.addStep(MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;                        max = Math.max(option.getMaxModifiedDamage(</b>
&nbsp;                                enemy.current, mod + 1,
&nbsp;                                modifiers[MoveOption.DEFENCE_PC]), max);
<b class="nc">&nbsp;                        enemy.current.removeLastStep();</b>
<b class="nc">&nbsp;                        enemy.current.addStep(MoveStepType.TURN_LEFT);</b>
<b class="nc">&nbsp;                        max = Math.max(option.getMaxModifiedDamage(</b>
&nbsp;                                enemy.current, mod + 1,
&nbsp;                                modifiers[MoveOption.DEFENCE_PC]), max);
&nbsp;                        // return to original facing
<b class="nc">&nbsp;                        enemy.current.removeLastStep();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    max = self.getThreatUtility(max, self_hit_arc);</b>
<b class="nc">&nbsp;                    if (enemy.getEntity().isProne()) {</b>
<b class="nc">&nbsp;                        max *= enemy.base_psr_odds;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    MoveOption.DamageInfo di = option</b>
<b class="nc">&nbsp;                            .getDamageInfo(enemy, true);</b>
<b class="nc">&nbsp;                    di.threat = max;</b>
<b class="nc">&nbsp;                    di.max_threat = max;</b>
<b class="nc">&nbsp;                    option.threat += max;</b>
<b class="nc">&nbsp;                    if (debug) {</b>
<b class="nc">&nbsp;                        option.tv.add(max + &quot; Threat &quot; + e + &quot;\n&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                /*
&nbsp;                 * As a first approximation, take the maximum to a single target
&nbsp;                 */
<b class="nc">&nbsp;                if (!option.isPhysical) {</b>
<b class="nc">&nbsp;                    if (modifiers[MoveOption.ATTACK_MOD] != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                        self.engaged = true;</b>
<b class="nc">&nbsp;                        double max = enemy.current.getMaxModifiedDamage(option,</b>
&nbsp;                                                                        modifiers[0], modifiers[MoveOption.ATTACK_PC]);
<b class="nc">&nbsp;                        max = enemy.getThreatUtility(max, enemy_hit_arc);</b>
<b class="nc">&nbsp;                        MoveOption.DamageInfo di = option.getDamageInfo(enemy,</b>
&nbsp;                                                                        true);
<b class="nc">&nbsp;                        di.damage = max;</b>
<b class="nc">&nbsp;                        di.min_damage = max;</b>
<b class="nc">&nbsp;                        if (debug) {</b>
<b class="nc">&nbsp;                            option.tv.add(max + &quot; Damage &quot; + e + &quot;\n&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        option.damage = Math.max(max, option.damage);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    CEntity target = centities</b>
<b class="nc">&nbsp;                            .get(option.getPhysicalTargetId());</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        if (target.getEntity().getId() == enemy.getEntity()</b>
<b class="nc">&nbsp;                                                               .getId()) {</b>
<b class="nc">&nbsp;                            if (!target.isPhysicalTarget) {</b>
<b class="nc">&nbsp;                                ToHitData toHit = null;</b>
<b class="nc">&nbsp;                                double self_threat = 0;</b>
<b class="nc">&nbsp;                                double damage = 0;</b>
<b class="nc">&nbsp;                                if (option.isJumping()</b>
<b class="nc">&nbsp;                                    &amp;&amp; option.getEntity().canDFA()) {</b>
<b class="nc">&nbsp;                                    self.current.setState();</b>
<b class="nc">&nbsp;                                    toHit = DfaAttackAction.toHit(game, option</b>
<b class="nc">&nbsp;                                            .getEntity().getId(), target</b>
<b class="nc">&nbsp;                                                                          .getEntity(), option);</b>
<b class="nc">&nbsp;                                    damage = 2 * DfaAttackAction</b>
<b class="nc">&nbsp;                                            .getDamageFor(</b>
<b class="nc">&nbsp;                                                    option.getEntity(),</b>
<b class="nc">&nbsp;                                                    (target.getEntity() instanceof Infantry)</b>
&nbsp;                                                    &amp;&amp; !(target
<b class="nc">&nbsp;                                                            .getEntity() instanceof BattleArmor)</b>
&nbsp;                                                         );
<b class="nc">&nbsp;                                    self_threat = (option</b>
<b class="nc">&nbsp;                                                           .getCEntity()</b>
<b class="nc">&nbsp;                                                           .getThreatUtility(</b>
<b class="nc">&nbsp;                                                                   DfaAttackAction.getDamageTakenBy(option</b>
<b class="nc">&nbsp;                                                                                                            .getEntity()),</b>
&nbsp;                                                                   ToHitData.SIDE_REAR
&nbsp;                                                                            ) * Compute
<b class="nc">&nbsp;                                            .oddsAbove(toHit.getValue(), aptPiloting)) / 100;</b>
<b class="nc">&nbsp;                                    self_threat += option.getCEntity()</b>
<b class="nc">&nbsp;                                                         .getThreatUtility(</b>
<b class="nc">&nbsp;                                                                 .1 * self.getEntity()</b>
<b class="nc">&nbsp;                                                                          .getWeight(),</b>
&nbsp;                                                                 ToHitData.SIDE_REAR
&nbsp;                                                                          );
<b class="nc">&nbsp;                                    self_threat *= 100 / option.getCEntity()</b>
<b class="nc">&nbsp;                                                               .getEntity().getWeight();</b>
<b class="nc">&nbsp;                                } else if (option.getEntity().canCharge()) {</b>
<b class="nc">&nbsp;                                    self.current.setState();</b>
<b class="nc">&nbsp;                                    toHit = new ChargeAttackAction(</b>
<b class="nc">&nbsp;                                            option.getEntity(),</b>
<b class="nc">&nbsp;                                            target.getEntity()).toHit(game,</b>
&nbsp;                                                                      option);
<b class="nc">&nbsp;                                    damage = ChargeAttackAction.getDamageFor(</b>
<b class="nc">&nbsp;                                            option.getEntity(),</b>
<b class="nc">&nbsp;                                            target.getEntity(), false,</b>
<b class="nc">&nbsp;                                            option.getHexesMoved());</b>
<b class="nc">&nbsp;                                    self_threat = option</b>
<b class="nc">&nbsp;                                                          .getCEntity()</b>
<b class="nc">&nbsp;                                                          .getThreatUtility(</b>
&nbsp;                                                                  ChargeAttackAction
<b class="nc">&nbsp;                                                                          .getDamageTakenBy(</b>
<b class="nc">&nbsp;                                                                                  option.getEntity(),</b>
<b class="nc">&nbsp;                                                                                  target.getEntity()),</b>
&nbsp;                                                                  ToHitData.SIDE_FRONT
&nbsp;                                                                           )
<b class="nc">&nbsp;                                                  * (Compute.oddsAbove(toHit.getValue(), aptPiloting) / 100);</b>
<b class="nc">&nbsp;                                    option.setState();</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    toHit = new ToHitData(</b>
&nbsp;                                            TargetRoll.IMPOSSIBLE, &quot;&quot;);
&nbsp;                                }
<b class="nc">&nbsp;                                damage = (target.getThreatUtility(damage,</b>
<b class="nc">&nbsp;                                                                  toHit.getSideTable()) * Compute.oddsAbove(toHit.getValue(), aptPiloting)) / 100;</b>
&nbsp;                                // charging is a good tactic against larger
&nbsp;                                // mechs
<b class="nc">&nbsp;                                if (!option.isJumping()) {</b>
<b class="nc">&nbsp;                                    damage *= Math.sqrt((double) enemy.bv</b>
&nbsp;                                                        / (double) self.bv);
&nbsp;                                }
&nbsp;                                // these are always risky, just don&#39;t on 11 or
&nbsp;                                // 12
<b class="nc">&nbsp;                                if (toHit.getValue() &gt; 10) {</b>
<b class="nc">&nbsp;                                    damage = 0;</b>
&nbsp;                                }
&nbsp;                                // 7 or less is good
<b class="nc">&nbsp;                                if (toHit.getValue() &lt; 8) {</b>
<b class="nc">&nbsp;                                    damage *= 1.5;</b>
&nbsp;                                }
&nbsp;                                // this is all you are good for
<b class="nc">&nbsp;                                if (self.range_damages[CEntity.RANGE_SHORT] &lt; 5) {</b>
<b class="nc">&nbsp;                                    damage *= 2;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                MoveOption.DamageInfo di = option</b>
<b class="nc">&nbsp;                                        .getDamageInfo(enemy, true);</b>
<b class="nc">&nbsp;                                di.damage = damage;</b>
<b class="nc">&nbsp;                                di.min_damage = damage;</b>
<b class="nc">&nbsp;                                option.damage = damage;</b>
<b class="nc">&nbsp;                                option.movement_threat += self_threat;</b>
<b class="nc">&nbsp;                            } else {</b>
<b class="nc">&nbsp;                                option.threat += Integer.MAX_VALUE;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (Exception e1) {</b>
<b class="nc">&nbsp;                        e1.printStackTrace();</b>
<b class="nc">&nbsp;                        option.threat += Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            } // -- end while of each enemy
<b class="nc">&nbsp;            self.current.setState();</b>
&nbsp;        } // -- end while of first pass
&nbsp;        // top balanced
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(1,</b>
&nbsp;                                                                             1), 100);
&nbsp;        // top damage
<b class="nc">&nbsp;        filterMoves(move_array, self.pass, new MoveOption.WeightedComparator(</b>
&nbsp;                .5, 1), 100);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * ********************************************************************
&nbsp;     * Second pass, combination moves/firing based only on the present case,
&nbsp;     * since only one mech moves at a time
&nbsp;     * ********************************************************************
&nbsp;     */
&nbsp;    private MoveOption[] secondPass(CEntity self, int friends,
&nbsp;                                    List&lt;Entity&gt; enemy_array, ArrayList&lt;Entity&gt; entities) {
<b class="nc">&nbsp;        MoveOption[] move_array = self.pass.values().toArray(new MoveOption[0]);</b>
<b class="nc">&nbsp;        self.pass.clear();</b>
<b class="nc">&nbsp;        for (int j = 0; (j &lt; move_array.length) &amp;&amp; (friends &gt; 2); j++) {</b>
<b class="nc">&nbsp;            MoveOption option = move_array[j];</b>
<b class="nc">&nbsp;            for (int e = 0; e &lt; enemy_array.size(); e++) {</b>
<b class="nc">&nbsp;                Entity en = enemy_array.get(e);</b>
<b class="nc">&nbsp;                CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;                for (Entity other : entities) {</b>
<b class="nc">&nbsp;                    if (other.isEnemyOf(self.entity)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    MoveOption foption = centities.get(other).current;</b>
<b class="nc">&nbsp;                    double threat_divisor = 1;</b>
<b class="nc">&nbsp;                    MoveOption.DamageInfo di = option</b>
<b class="nc">&nbsp;                            .getDamageInfo(enemy, true);</b>
<b class="nc">&nbsp;                    if (foption.getDamageInfo(enemy, false) != null) {</b>
<b class="nc">&nbsp;                        option.damage += (enemy.canMove() ? .1 : .2)</b>
&nbsp;                                         * di.damage;
<b class="nc">&nbsp;                        threat_divisor += foption.getCEntity().canMove() ? .4</b>
<b class="nc">&nbsp;                                                                         : .6;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    option.threat -= di.threat;</b>
<b class="nc">&nbsp;                    di.threat /= threat_divisor;</b>
<b class="nc">&nbsp;                    option.threat += di.threat;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return move_array;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * ********************************************************************
&nbsp;     * third pass, (not so bad) oppurtunistic planner gives preference to good
&nbsp;     * ranges/defensive positions based upon the mech characterization
&nbsp;     * ********************************************************************
&nbsp;     */
&nbsp;    private MoveOption[] thirdPass(CEntity self, List&lt;Entity&gt; enemy_array) {
<b class="nc">&nbsp;        MoveOption[] move_array = self.pass.values().toArray(new MoveOption[0]);</b>
<b class="nc">&nbsp;        self.pass.clear();</b>
&nbsp;
<b class="nc">&nbsp;        for (MoveOption option : move_array) {</b>
<b class="nc">&nbsp;            option.setState();</b>
<b class="nc">&nbsp;            double adjustment = 0;</b>
<b class="nc">&nbsp;            double temp_adjustment = 0;</b>
<b class="nc">&nbsp;            for (int e = 0; e &lt; enemy_array.size(); e++) { // for each enemy</b>
<b class="nc">&nbsp;                Entity en = enemy_array.get(e);</b>
<b class="nc">&nbsp;                CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;                int current_range = self.current.getFinalCoords().distance(</b>
<b class="nc">&nbsp;                        enemy.current.getFinalCoords());</b>
<b class="nc">&nbsp;                int range = option.getFinalCoords().distance(</b>
<b class="nc">&nbsp;                        enemy.current.getFinalCoords());</b>
<b class="nc">&nbsp;                if (range &gt; self.long_range) {</b>
<b class="nc">&nbsp;                    temp_adjustment += (!(range &lt; enemy.long_range) ? .5 : 1)</b>
&nbsp;                                       * (1 + self.range_damages[self.range])
<b class="nc">&nbsp;                                       * (Math.max(</b>
&nbsp;                            range
&nbsp;                            - self.long_range
<b class="nc">&nbsp;                            - (.5 * Math.max(self.jumpMP,</b>
&nbsp;                                             .8 * self.runMP)), 0
&nbsp;                                                  ));
&nbsp;                }
<b class="nc">&nbsp;                if (((self.range == CEntity.RANGE_SHORT) &amp;&amp; ((current_range &gt; 5) || (range &gt; 9)))</b>
&nbsp;                    || ((self.range_damages[CEntity.RANGE_SHORT] &lt; 4) &amp;&amp; (current_range &gt; 10))) {
<b class="nc">&nbsp;                    temp_adjustment += ((enemy.range &gt; CEntity.RANGE_SHORT) ? .5</b>
<b class="nc">&nbsp;                                                                            : 1)</b>
<b class="nc">&nbsp;                                       * (Math.max(</b>
&nbsp;                            1 + self.range_damages[CEntity.RANGE_SHORT],
&nbsp;                            5))
<b class="nc">&nbsp;                                       * Math.max(</b>
&nbsp;                            range
<b class="nc">&nbsp;                            - (.5 * Math.max(self.jumpMP,</b>
&nbsp;                                             .8 * self.runMP)), 0
&nbsp;                                                 );
<b class="nc">&nbsp;                } else if (self.range == CEntity.RANGE_MEDIUM) {</b>
<b class="nc">&nbsp;                    temp_adjustment += (((current_range &lt; 6) || (current_range &gt; 12)) ? 1</b>
<b class="nc">&nbsp;                                                                                      : .25)</b>
<b class="nc">&nbsp;                                       * ((enemy.range &gt; CEntity.RANGE_SHORT) ? .5 : 1)</b>
&nbsp;                                       * (1 + self.range_damages[CEntity.RANGE_MEDIUM])
<b class="nc">&nbsp;                                       * Math.abs(range</b>
<b class="nc">&nbsp;                                                  - (.5 * Math.max(self.jumpMP,</b>
&nbsp;                                                                   .8 * self.runMP)));
<b class="nc">&nbsp;                } else if (option.damage &lt; (.25 * self.range_damages[CEntity.RANGE_LONG])) {</b>
<b class="nc">&nbsp;                    temp_adjustment += ((range &lt; 10) ? .25 : 1)</b>
<b class="nc">&nbsp;                                       * (Math.max(</b>
&nbsp;                            1 + self.range_damages[CEntity.RANGE_LONG],
&nbsp;                            3)) * (1 / (1 + option.threat));
&nbsp;                }
<b class="nc">&nbsp;                adjustment += Math.sqrt((temp_adjustment * enemy.bv) / self.bv);</b>
&nbsp;                // I would always like to face the opponent
<b class="nc">&nbsp;                if (!(enemy.getEntity().isProne() || enemy.getEntity()</b>
<b class="nc">&nbsp;                                                          .isImmobile())</b>
<b class="nc">&nbsp;                    &amp;&amp; (CEntity.getThreatHitArc(option.getFinalCoords(),</b>
<b class="nc">&nbsp;                                                option.getFinalFacing(), enemy.getEntity()</b>
<b class="nc">&nbsp;                                                                              .getPosition()</b>
&nbsp;                                               ) != ToHitData.SIDE_FRONT)) {
<b class="nc">&nbsp;                    int fa = CEntity.getFiringAngle(option.getFinalCoords(),</b>
<b class="nc">&nbsp;                                                    option.getFinalFacing(), enemy.getEntity()</b>
<b class="nc">&nbsp;                                                                                  .getPosition()</b>
&nbsp;                                                   );
<b class="nc">&nbsp;                    if ((fa &gt; 90) &amp;&amp; (fa &lt; 270)) {</b>
<b class="nc">&nbsp;                        int distance = option.getFinalCoords().distance(</b>
<b class="nc">&nbsp;                                enemy.current.getFinalCoords());</b>
<b class="nc">&nbsp;                        double mod = 1;</b>
<b class="nc">&nbsp;                        if ((fa &gt; 130) &amp;&amp; (fa &lt; 240)) {</b>
<b class="nc">&nbsp;                            mod = 2;</b>
&nbsp;                        }
&nbsp;                        // big formula that says don&#39;t do it
<b class="nc">&nbsp;                        mod *= (((Math.max(self.jumpMP, .8 * self.runMP) &lt; 5) ? 2</b>
<b class="nc">&nbsp;                                                                              : 1)</b>
&nbsp;                                * ((double) self.bv / (double) 50) * Math
<b class="nc">&nbsp;                                .sqrt(((double) self.bv) / enemy.bv))</b>
&nbsp;                               / (((double) distance / 6) + 1);
<b class="nc">&nbsp;                        option.self_threat += mod;</b>
<b class="nc">&nbsp;                        if (debug) {</b>
<b class="nc">&nbsp;                            option.tv.add(mod + &quot; &quot; + fa + &quot; Back to enemy\n&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            adjustment *= (self.overall_armor_percent * self.strategy.attack)</b>
<b class="nc">&nbsp;                          / enemy_array.size();</b>
&nbsp;            // fix for hiding in level 2 water
&nbsp;            // To a greedy bot, it always seems nice to stay in here...
<b class="nc">&nbsp;            IHex h = game.getBoard().getHex(option.getFinalCoords());</b>
<b class="nc">&nbsp;            if (h.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                &amp;&amp; (h.surface() &gt; (self.getEntity().getElevation() + ((option</b>
<b class="nc">&nbsp;                    .getFinalProne()) ? 0 : 1)))) {</b>
<b class="nc">&nbsp;                double mod = ((self.getEntity().heat + option</b>
<b class="nc">&nbsp;                        .getMovementheatBuildup()) &lt;= 7) ? 100 : 30;</b>
<b class="nc">&nbsp;                adjustment += self.bv / mod;</b>
&nbsp;            }
&nbsp;            // add them in now, then re-add them later
<b class="nc">&nbsp;            if (self.range &gt; CEntity.RANGE_SHORT) {</b>
<b class="nc">&nbsp;                int ele_dif = game.getBoard().getHex(option.getFinalCoords())</b>
<b class="nc">&nbsp;                                  .getLevel()</b>
<b class="nc">&nbsp;                              - game.getBoard().getHex(self.current.getFinalCoords())</b>
<b class="nc">&nbsp;                                    .getLevel();</b>
<b class="nc">&nbsp;                adjustment -= (Math.max(ele_dif, 0) + 1)</b>
<b class="nc">&nbsp;                              * ((double) Compute.getTargetTerrainModifier(game,</b>
<b class="nc">&nbsp;                                                                           option.getEntity()).getValue() + 1);</b>
&nbsp;            }
&nbsp;
&nbsp;            // close the range if nothing else and healthy
<b class="nc">&nbsp;            if ((option.damage &lt; (.25 * self.range_damages[self.range]))</b>
&nbsp;                &amp;&amp; (adjustment &lt; self.range_damages[self.range])) {
<b class="nc">&nbsp;                for (int e = 0; e &lt; enemy_array.size(); e++) {</b>
<b class="nc">&nbsp;                    Entity en = enemy_array.get(e);</b>
<b class="nc">&nbsp;                    CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;                    int range = option.getFinalCoords().distance(</b>
<b class="nc">&nbsp;                            enemy.current.getFinalCoords());</b>
<b class="nc">&nbsp;                    if (range &gt; 5) {</b>
<b class="nc">&nbsp;                        adjustment += (Math.pow(self.overall_armor_percent, 2) * Math</b>
<b class="nc">&nbsp;                                .sqrt(((double) (range - 4) * enemy.bv)</b>
&nbsp;                                      / self.bv))
<b class="nc">&nbsp;                                      / enemy_array.size();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (option.damage &lt; (.25 * (1 + self.range_damages[self.range]))) {</b>
<b class="nc">&nbsp;                option.self_threat += 2 * adjustment;</b>
<b class="nc">&nbsp;            } else if (option.damage &lt; (.5 * (1 + self.range_damages[self.range]))) {</b>
<b class="nc">&nbsp;                option.self_threat += adjustment;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (debug) {</b>
<b class="nc">&nbsp;                option.tv.add(option.self_threat</b>
&nbsp;                              + &quot; Initial Damage Adjustment &quot; + &quot;\n&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return move_array;</b>
&nbsp;    }
&nbsp;
&nbsp;    // pass should contains 30 ~ 60
&nbsp;
&nbsp;    /**
&nbsp;     * ********************************************************************
&nbsp;     * fourth pass, speculation on top moves use averaging to filter
&nbsp;     * ********************************************************************
&nbsp;     */
&nbsp;    private MoveOption[] fourthPass(CEntity self, List&lt;Entity&gt; enemy_array) {
<b class="nc">&nbsp;        MoveOption[] move_array = self.pass.values().toArray(new MoveOption[0]);</b>
<b class="nc">&nbsp;        self.pass.clear();</b>
<b class="nc">&nbsp;        for (int e = 0; e &lt; enemy_array.size(); e++) { // for each enemy</b>
<b class="nc">&nbsp;            Entity en = enemy_array.get(e);</b>
<b class="nc">&nbsp;            CEntity enemy = centities.get(en);</b>
&nbsp;            // engage in speculation on &quot;best choices&quot; when you loose iniative
<b class="nc">&nbsp;            if (enemy.canMove()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;MoveOption&gt; enemy_move_array = enemy.pass.getArray();</b>
<b class="nc">&nbsp;                ArrayList&lt;MoveOption&gt; to_check = new ArrayList&lt;MoveOption&gt;();</b>
&nbsp;                // check some enemy moves
<b class="nc">&nbsp;                for (MoveOption element : move_array) {</b>
<b class="nc">&nbsp;                    MoveOption option = null;</b>
<b class="nc">&nbsp;                    to_check.clear();</b>
<b class="nc">&nbsp;                    option = element;</b>
<b class="nc">&nbsp;                    option.setState();</b>
&nbsp;                    // check for damning hexes specifically
&nbsp;                    // could also look at intervening defensive
<b class="nc">&nbsp;                    ArrayList&lt;Coords&gt; coord = new ArrayList&lt;Coords&gt;();</b>
<b class="nc">&nbsp;                    Coords back = option.getFinalCoords().translated(</b>
<b class="nc">&nbsp;                            (option.getFinalFacing() + 3) % 6);</b>
<b class="nc">&nbsp;                    coord.add(back);</b>
<b class="nc">&nbsp;                    coord.add(back.translated((option.getFinalFacing() + 2) % 6));</b>
<b class="nc">&nbsp;                    coord.add(back.translated((option.getFinalFacing() + 4) % 6));</b>
<b class="nc">&nbsp;                    coord.add(option.getFinalCoords().translated(</b>
<b class="nc">&nbsp;                            (option.getFinalFacing())));</b>
<b class="nc">&nbsp;                    coord.add(option.getFinalCoords().translated(</b>
<b class="nc">&nbsp;                            (option.getFinalFacing() + 1) % 6));</b>
<b class="nc">&nbsp;                    coord.add(option.getFinalCoords().translated(</b>
<b class="nc">&nbsp;                            (option.getFinalFacing() + 2) % 6));</b>
<b class="nc">&nbsp;                    coord.add(option.getFinalCoords().translated(</b>
<b class="nc">&nbsp;                            (option.getFinalFacing() + 4) % 6));</b>
<b class="nc">&nbsp;                    coord.add(option.getFinalCoords().translated(</b>
<b class="nc">&nbsp;                            (option.getFinalFacing() + 5) % 6));</b>
<b class="nc">&nbsp;                    Iterator&lt;Coords&gt; ci = coord.iterator();</b>
<b class="nc">&nbsp;                    while (ci.hasNext()) {</b>
<b class="nc">&nbsp;                        Coords test = ci.next();</b>
<b class="nc">&nbsp;                        List&lt;MoveOption&gt; c = enemy.findMoves(test, this);</b>
<b class="nc">&nbsp;                        if (c.size() != 0) {</b>
<b class="nc">&nbsp;                            to_check.addAll(c);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    int range = option.getFinalCoords().distance(</b>
<b class="nc">&nbsp;                            enemy.current.getFinalCoords());</b>
<b class="nc">&nbsp;                    int compare = 0;</b>
<b class="nc">&nbsp;                    if ((enemy.long_range) &gt; (range - Math.max(enemy.jumpMP,</b>
&nbsp;                                                               enemy.runMP))) {
<b class="nc">&nbsp;                        compare = 30;</b>
<b class="nc">&nbsp;                    } else if (enemy.long_range &gt; range) {</b>
<b class="nc">&nbsp;                        compare = 10;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    double mod = enemies_moved / getEnemyEntities().size();</b>
<b class="nc">&nbsp;                    compare *= (1 + mod);</b>
<b class="nc">&nbsp;                    for (int k = 0; (k &lt;= compare)</b>
<b class="nc">&nbsp;                                    &amp;&amp; (k &lt; enemy_move_array.size()); k++) {</b>
<b class="nc">&nbsp;                        if (enemy_move_array.size() &lt; compare) {</b>
<b class="nc">&nbsp;                            to_check.add(enemy_move_array.get(k));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            int value = Compute.randomInt(enemy_move_array</b>
<b class="nc">&nbsp;                                                                  .size());</b>
<b class="nc">&nbsp;                            if ((value % 2) == 1) {</b>
<b class="nc">&nbsp;                                to_check.add(enemy_move_array.get(value));</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                to_check.add(enemy_move_array.get(k));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    Iterator&lt;MoveOption&gt; eo = to_check.iterator();</b>
<b class="nc">&nbsp;                    while (eo.hasNext()) {</b>
<b class="nc">&nbsp;                        MoveOption enemy_option = eo.next();</b>
<b class="nc">&nbsp;                        double max_threat = 0;</b>
<b class="nc">&nbsp;                        double max_damage = 0;</b>
<b class="nc">&nbsp;                        enemy_option.setState();</b>
<b class="nc">&nbsp;                        int enemy_hit_arc = CEntity.getThreatHitArc(</b>
<b class="nc">&nbsp;                                enemy_option.getFinalCoords(),</b>
<b class="nc">&nbsp;                                enemy_option.getFinalFacing(),</b>
<b class="nc">&nbsp;                                option.getFinalCoords());</b>
<b class="nc">&nbsp;                        int self_hit_arc = CEntity.getThreatHitArc(</b>
<b class="nc">&nbsp;                                enemy_option.getFinalCoords(),</b>
<b class="nc">&nbsp;                                enemy_option.getFinalFacing(),</b>
<b class="nc">&nbsp;                                option.getFinalCoords());</b>
<b class="nc">&nbsp;                        if (enemy_option.isJumping()) {</b>
<b class="nc">&nbsp;                            enemy_hit_arc = Compute.ARC_FORWARD;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        int[] modifiers = option.getModifiers(enemy_option</b>
<b class="nc">&nbsp;                                                                      .getEntity());</b>
<b class="nc">&nbsp;                        if (modifiers[1] != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                            self.engaged = true;</b>
<b class="nc">&nbsp;                            if (!enemy_option.isJumping()) {</b>
<b class="nc">&nbsp;                                max_threat = option.getMaxModifiedDamage(</b>
&nbsp;                                        enemy_option, modifiers[1],
&nbsp;                                        modifiers[MoveOption.DEFENCE_PC]);
&nbsp;                            } else {
<b class="nc">&nbsp;                                boolean enemyAptGunnery = enemy.getEntity().hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</b>
<b class="nc">&nbsp;                                max_threat = .8 * enemy</b>
<b class="nc">&nbsp;                                        .getModifiedDamage(</b>
<b class="nc">&nbsp;                                                (modifiers[MoveOption.DEFENCE_PC] == 1) ? CEntity.TT</b>
<b class="nc">&nbsp;                                                                                        : ToHitData.SIDE_FRONT,</b>
&nbsp;                                                enemy_option
<b class="nc">&nbsp;                                                        .getFinalCoords()</b>
<b class="nc">&nbsp;                                                        .distance(</b>
<b class="nc">&nbsp;                                                                option.getFinalCoords()),</b>
&nbsp;                                                modifiers[1], enemyAptGunnery);
&nbsp;                            }
<b class="nc">&nbsp;                            max_threat = self.getThreatUtility(max_threat,</b>
&nbsp;                                                               self_hit_arc);
&nbsp;                        }
<b class="nc">&nbsp;                        if (modifiers[0] != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                            self.engaged = true;</b>
<b class="nc">&nbsp;                            max_damage = enemy_option.getMaxModifiedDamage(</b>
&nbsp;                                    option, modifiers[0],
&nbsp;                                    modifiers[MoveOption.ATTACK_PC]);
<b class="nc">&nbsp;                            max_damage = enemy.getThreatUtility(max_damage,</b>
&nbsp;                                                                enemy_hit_arc);
<b class="nc">&nbsp;                            if (option.isPhysical) {</b>
<b class="nc">&nbsp;                                if (centities.get(option.getPhysicalTargetId())</b>
<b class="nc">&nbsp;                                             .getEntity().getId() == enemy</b>
<b class="nc">&nbsp;                                            .getEntity().getId()) {</b>
<b class="nc">&nbsp;                                    max_damage = option.getDamage(enemy);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    max_damage = 0;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        MoveOption.DamageInfo di = option.getDamageInfo(enemy,</b>
&nbsp;                                                                        true);
<b class="nc">&nbsp;                        di.max_threat = Math.max(max_threat, di.max_threat);</b>
<b class="nc">&nbsp;                        di.min_damage = Math.min(di.min_damage, max_damage);</b>
<b class="nc">&nbsp;                        if ((max_threat - max_damage) &gt; (di.threat - di.damage)) {</b>
<b class="nc">&nbsp;                            di.threat = max_threat;</b>
<b class="nc">&nbsp;                            di.damage = max_damage;</b>
<b class="nc">&nbsp;                            if (debug) {</b>
<b class="nc">&nbsp;                                option.tv.add(max_threat + &quot; Spec Threat &quot; + e</b>
&nbsp;                                              + &quot;\n&quot;);
<b class="nc">&nbsp;                                option.tv.add(max_damage + &quot; Spec Damage &quot; + e</b>
&nbsp;                                              + &quot;\n&quot;);
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // update estimates
<b class="nc">&nbsp;                    option.damage = 0;</b>
<b class="nc">&nbsp;                    option.threat = 0;</b>
<b class="nc">&nbsp;                    for (CEntity cen : option.damageInfos.keySet()) {</b>
&nbsp;                        // rescale
<b class="nc">&nbsp;                        MoveOption.DamageInfo di = option.getDamageInfo(cen,</b>
&nbsp;                                                                        true);
<b class="nc">&nbsp;                        di.min_damage /= cen.strategy.target;</b>
<b class="nc">&nbsp;                        di.damage /= cen.strategy.target;</b>
<b class="nc">&nbsp;                        option.damage += (di.min_damage + di.damage) / 2;</b>
&nbsp;
&nbsp;                        // my threat is average of absolute worst, and expected
<b class="nc">&nbsp;                        option.threat = Math.max(option.threat, di.max_threat</b>
&nbsp;                                                                + di.threat) / 2;
<b class="nc">&nbsp;                        di.threat = (di.max_threat + (2 * di.threat)) / 3;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // restore enemy
<b class="nc">&nbsp;                enemy.current.setState();</b>
&nbsp;            }
<b class="nc">&nbsp;            self.current.setState();</b>
&nbsp;        } // --end move speculation
<b class="nc">&nbsp;        return move_array;</b>
&nbsp;    }
&nbsp;
&nbsp;    // pass should now be 20 ~ 40
&nbsp;
&nbsp;    /**
&nbsp;     * ********************************************************************
&nbsp;     * fifth pass, final damage and threat approximation --prevents moves that
&nbsp;     * from the previous pass would cause the mech to die
&nbsp;     * ********************************************************************
&nbsp;     */
&nbsp;    private MoveOption[] fifthPass(CEntity self, List&lt;Entity&gt; enemy_array) {
<b class="nc">&nbsp;        MoveOption[] move_array = self.pass.values().toArray(new MoveOption[0]);</b>
<b class="nc">&nbsp;        self.pass.clear();</b>
&nbsp;
<b class="nc">&nbsp;        if (self.engaged) {</b>
<b class="nc">&nbsp;            for (MoveOption option : move_array) {</b>
<b class="nc">&nbsp;                option.setState();</b>
<b class="nc">&nbsp;                GAAttack temp = this.bestAttack(option);</b>
<b class="nc">&nbsp;                if (temp != null) {</b>
<b class="nc">&nbsp;                    option.damage = (option.damage + temp</b>
<b class="nc">&nbsp;                            .getFittestChromosomesFitness()) / 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    option.damage /= 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int e = 0; e &lt; enemy_array.size(); e++) { // for each</b>
&nbsp;                    // enemy
<b class="nc">&nbsp;                    Entity en = enemy_array.get(e);</b>
<b class="nc">&nbsp;                    CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;                    if (!enemy.canMove()) {</b>
<b class="nc">&nbsp;                        option.setThreat(</b>
&nbsp;                                enemy,
<b class="nc">&nbsp;                                (option.getThreat(enemy) + attackUtility(</b>
&nbsp;                                        enemy.current, self)) / 2
&nbsp;                                        );
<b class="nc">&nbsp;                        if (debug) {</b>
<b class="nc">&nbsp;                            option.tv.add(option.getThreat(enemy)</b>
&nbsp;                                          + &quot; Revised Threat &quot; + e + &quot; \n&quot;);
&nbsp;                        }
<b class="nc">&nbsp;                        if (!option.isPhysical) {</b>
<b class="nc">&nbsp;                            if (temp != null) {</b>
<b class="nc">&nbsp;                                option.setDamage(enemy, (option</b>
<b class="nc">&nbsp;                                                                 .getDamage(enemy) + temp</b>
<b class="nc">&nbsp;                                                                 .getDamageUtility(enemy)) / 2);</b>
&nbsp;                            } else {
&nbsp;                                // probably zero, but just in case
<b class="nc">&nbsp;                                option.setDamage(enemy,</b>
<b class="nc">&nbsp;                                                 option.getMinDamage(enemy));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (debug) {</b>
<b class="nc">&nbsp;                                option.tv.add(option.getDamage(enemy)</b>
&nbsp;                                              + &quot; Revised Damage &quot; + e + &quot; \n&quot;);
&nbsp;                            }
&nbsp;                            // this needs to be reworked
<b class="nc">&nbsp;                            if (option.getFinalCoords().distance(</b>
<b class="nc">&nbsp;                                    enemy.current.getFinalCoords()) == 1) {</b>
<b class="nc">&nbsp;                                PhysicalOption p = PhysicalCalculator</b>
<b class="nc">&nbsp;                                        .getBestPhysicalAttack(</b>
<b class="nc">&nbsp;                                                option.getEntity(),</b>
<b class="nc">&nbsp;                                                enemy.getEntity(), game);</b>
<b class="nc">&nbsp;                                if (p != null) {</b>
<b class="nc">&nbsp;                                    option.setDamage(enemy,</b>
<b class="nc">&nbsp;                                                     option.getDamage(enemy)</b>
&nbsp;                                                     + p.expectedDmg
&nbsp;                                                    );
<b class="nc">&nbsp;                                    if (debug) {</b>
<b class="nc">&nbsp;                                        option.tv.add(p.expectedDmg</b>
&nbsp;                                                      + &quot; Physical Damage &quot; + e
&nbsp;                                                      + &quot; \n&quot;);
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                                p = PhysicalCalculator.getBestPhysicalAttack(</b>
<b class="nc">&nbsp;                                        enemy.getEntity(), option.getEntity(),</b>
&nbsp;                                        game);
<b class="nc">&nbsp;                                if (p != null) {</b>
<b class="nc">&nbsp;                                    option.setThreat(enemy,</b>
<b class="nc">&nbsp;                                                     option.getThreat(enemy)</b>
&nbsp;                                                     + (.5 * p.expectedDmg)
&nbsp;                                                    );
<b class="nc">&nbsp;                                    if (debug) {</b>
<b class="nc">&nbsp;                                        option.tv.add((.5 * p.expectedDmg)</b>
&nbsp;                                                      + &quot; Physical Threat &quot; + e
&nbsp;                                                      + &quot; \n&quot;);
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (!option.isPhysical) { // enemy can move (not</b>
<b class="nc">&nbsp;                        if (temp != null) {</b>
<b class="nc">&nbsp;                            option.setDamage(enemy, ((2 * option</b>
<b class="nc">&nbsp;                                    .getDamage(enemy)) + temp</b>
<b class="nc">&nbsp;                                                             .getDamageUtility(enemy)) / 3);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            option.setDamage(enemy, option.getMinDamage(enemy));</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // get a more accurate estimate
<b class="nc">&nbsp;                        option.setDamage(</b>
&nbsp;                                enemy,
<b class="nc">&nbsp;                                option.getDamage(enemy)</b>
<b class="nc">&nbsp;                                / Math.sqrt((double) enemy.bv</b>
&nbsp;                                            / (double) self.bv)
&nbsp;                                        );
<b class="nc">&nbsp;                        option.damage = option.getDamage(enemy);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                option.threat = 0;</b>
<b class="nc">&nbsp;                for (DamageInfo damageInfo : option.damageInfos.values()) {</b>
<b class="nc">&nbsp;                    option.threat += damageInfo.threat;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (debug) {</b>
<b class="nc">&nbsp;                    option.tv.add(option.threat + &quot; Revised Threat Utility\n&quot;);</b>
<b class="nc">&nbsp;                    option.tv.add(option.damage + &quot; Revised Damage Utility\n&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Arrays.&lt;MoveOption&gt;sort(move_array, new MoveOption.WeightedComparator(</b>
&nbsp;                1, 1));
<b class="nc">&nbsp;        self.current.setState();</b>
&nbsp;
<b class="nc">&nbsp;        return move_array;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void filterMoves(MoveOption[] move_array, MoveOption.Table pass,
&nbsp;                             MoveOption.WeightedComparator comp, int filter) {
<b class="nc">&nbsp;        Arrays.sort(move_array, comp);</b>
&nbsp;
&nbsp;        // top 100 utility, mostly conservative
<b class="nc">&nbsp;        for (int i = 0; (i &lt; filter) &amp;&amp; (i &lt; move_array.length); i++) {</b>
<b class="nc">&nbsp;            pass.put(move_array[i]);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected void initFiring() {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;(</b>
<b class="nc">&nbsp;                game.getEntitiesVector());</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entities.size(); i++) {</b>
<b class="nc">&nbsp;            Entity entity = entities.get(i);</b>
<b class="nc">&nbsp;            CEntity centity = centities.get(entity);</b>
<b class="nc">&nbsp;            centity.reset();</b>
<b class="nc">&nbsp;            centity.enemy_num = i;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity entity : getEnemyEntities()) {</b>
<b class="nc">&nbsp;            CEntity centity = centities.get(entity);</b>
<b class="nc">&nbsp;            if (entity.isMakingDfa() || entity.isCharging()) {</b>
&nbsp;                // try to prevent a physical attack from happening
&nbsp;                // but should take into account the toHit of the attack
<b class="nc">&nbsp;                centity.strategy.target = 2.5;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected ArrayList&lt;AttackOption&gt; calculateWeaponAttacks(Entity en,
&nbsp;                                                             Mounted mw, boolean best_only) {
<b class="nc">&nbsp;        int from = en.getId();</b>
<b class="nc">&nbsp;        int weaponID = en.getEquipmentNum(mw);</b>
<b class="nc">&nbsp;        int spin_mode = 0;</b>
&nbsp;        int starg_mod;
<b class="nc">&nbsp;        ArrayList&lt;AttackOption&gt; result = new ArrayList&lt;AttackOption&gt;();</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; ents = myEnemies(en);</b>
&nbsp;        WeaponAttackAction wep_test;
&nbsp;        WeaponType spinner;
<b class="nc">&nbsp;        AttackOption a = null;</b>
<b class="nc">&nbsp;        AttackOption max = new AttackOption(null, null, 0, null, 1, </b>
<b class="nc">&nbsp;                en.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY));</b>
<b class="nc">&nbsp;        for (Entity e : ents) {</b>
<b class="nc">&nbsp;            CEntity enemy = centities.get(e);</b>
&nbsp;            // long entry = System.currentTimeMillis();
<b class="nc">&nbsp;            ToHitData th = WeaponAttackAction.toHit(game, from, e, weaponID, false);</b>
&nbsp;            // long exit = System.currentTimeMillis();
&nbsp;            // if (exit != entry)
&nbsp;            // System.out.println(&quot;Weapon attack toHit took &quot;+(exit-entry));
<b class="nc">&nbsp;            if ((th.getValue() != TargetRoll.IMPOSSIBLE)</b>
<b class="nc">&nbsp;                &amp;&amp; !(th.getValue() &gt;= 13)) {</b>
&nbsp;                double expectedDmg;
&nbsp;
<b class="nc">&nbsp;                wep_test = new WeaponAttackAction(from, e.getId(), weaponID);</b>
&nbsp;
&nbsp;                // If this is an Ultra or Rotary cannon, check for spin up
<b class="nc">&nbsp;                spinner = (WeaponType) mw.getType();</b>
<b class="nc">&nbsp;                if ((spinner.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                    || (spinner.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;                    || (spinner.getAmmoType() == AmmoType.T_AC_ROTARY)) {</b>
<b class="nc">&nbsp;                    spin_mode = Compute.spinUpCannon(game, wep_test);</b>
<b class="nc">&nbsp;                    super.sendModeChange(from, weaponID, spin_mode);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Ammo cycler runs each valid ammo type through the weapon
&nbsp;                // while calling for expected damage on each type; best type
&nbsp;                // by damage is loaded
&nbsp;
<b class="nc">&nbsp;                expectedDmg = Compute.getAmmoAdjDamage(game, wep_test);</b>
&nbsp;
&nbsp;                // Get the secondary target modifier for this weapon/target
&nbsp;                // combo
&nbsp;
<b class="nc">&nbsp;                starg_mod = 1;</b>
&nbsp;
<b class="nc">&nbsp;                if (en.getFacing() != -1) {</b>
<b class="nc">&nbsp;                    if (en.canChangeSecondaryFacing()) {</b>
&nbsp;
<b class="nc">&nbsp;                        if (!Compute.isInArc(en.getPosition(),</b>
<b class="nc">&nbsp;                                             en.getSecondaryFacing(), e, en.getForwardArc())) {</b>
<b class="nc">&nbsp;                            starg_mod = 2;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (!Compute.isInArc(en.getPosition(), en.getFacing(),</b>
<b class="nc">&nbsp;                                             e, en.getForwardArc())) {</b>
<b class="nc">&nbsp;                            starg_mod = 2;</b>
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // For good measure, infantry cannot attack multiple targets
<b class="nc">&nbsp;                if ((en instanceof Infantry) &amp;&amp; !(en instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    starg_mod = 13;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                a = new AttackOption(enemy, mw, expectedDmg, th, starg_mod,</b>
<b class="nc">&nbsp;                                     en.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY));</b>
<b class="nc">&nbsp;                if (a.value &gt; max.value) {</b>
<b class="nc">&nbsp;                    if (best_only) {</b>
<b class="nc">&nbsp;                        max = a;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        result.add(0, a);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    result.add(a);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (best_only &amp;&amp; (max.target != null)) {</b>
<b class="nc">&nbsp;            result.add(max);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (result.size() &gt; 0) {</b>
<b class="nc">&nbsp;            result.add(new AttackOption(null, mw, 0, null, 1, en.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY)));</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public GAAttack bestAttack(MoveOption es) {
<b class="nc">&nbsp;        return bestAttack(es, null, 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public GAAttack bestAttack(MoveOption es, CEntity target, int search_level) {
<b class="nc">&nbsp;        Entity en = es.getEntity();</b>
<b class="nc">&nbsp;        int attacks[] = new int[4];</b>
<b class="nc">&nbsp;        ArrayList&lt;AttackOption&gt; c = new ArrayList&lt;AttackOption&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; front = new ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; left = new ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; right = new ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; rear = new ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt;();</b>
<b class="nc">&nbsp;        GAAttack result = null;</b>
<b class="nc">&nbsp;        int o_facing = en.getFacing();</b>
<b class="nc">&nbsp;        double front_la_dmg = 0;</b>
<b class="nc">&nbsp;        double front_ra_dmg = 0;</b>
<b class="nc">&nbsp;        double left_la_dmg = 0;</b>
<b class="nc">&nbsp;        double left_ra_dmg = 0;</b>
<b class="nc">&nbsp;        double right_la_dmg = 0;</b>
<b class="nc">&nbsp;        double right_ra_dmg = 0;</b>
<b class="nc">&nbsp;        PhysicalOption best_front_po = new PhysicalOption(en);</b>
<b class="nc">&nbsp;        PhysicalOption best_left_po = new PhysicalOption(en);</b>
<b class="nc">&nbsp;        PhysicalOption best_right_po = new PhysicalOption(en);</b>
&nbsp;
&nbsp;        // Get best physical attack
<b class="nc">&nbsp;        for (Mounted mw : en.getWeaponList()) {</b>
&nbsp;
&nbsp;            // If this weapon is in the same arm as a
&nbsp;            // brush off attack skip to next weapon.
<b class="nc">&nbsp;            c = calculateWeaponAttacks(en, mw, true);</b>
&nbsp;
&nbsp;            // Get best physical attack
<b class="nc">&nbsp;            best_front_po = PhysicalCalculator.getBestPhysical(en, game);</b>
&nbsp;
<b class="nc">&nbsp;            if ((best_front_po != null) &amp;&amp; (en instanceof Mech)) {</b>
&nbsp;
&nbsp;                // If this weapon is in the same arm as a brush off attack
&nbsp;                // skip to next weapon
&nbsp;
<b class="nc">&nbsp;                if (((best_front_po.type == PhysicalOption.BRUSH_LEFT) || (best_front_po.type == PhysicalOption</b>
&nbsp;                        .BRUSH_BOTH))
<b class="nc">&nbsp;                    &amp;&amp; (mw.getLocation() == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (((best_front_po.type == PhysicalOption.BRUSH_RIGHT) || (best_front_po.type == PhysicalOption</b>
&nbsp;                        .BRUSH_BOTH))
<b class="nc">&nbsp;                    &amp;&amp; (mw.getLocation() == Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Total the damage of all weapons fired from each arm
<b class="nc">&nbsp;                if (((best_front_po.type == PhysicalOption.PUNCH_LEFT) || (best_front_po.type == PhysicalOption</b>
&nbsp;                        .PUNCH_BOTH))
<b class="nc">&nbsp;                    &amp;&amp; (mw.getLocation() == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                    if (c.size() &gt; 0) {</b>
<b class="nc">&nbsp;                        front_la_dmg += c.get(c.size() - 2).value;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (((best_front_po.type == PhysicalOption.PUNCH_RIGHT) || (best_front_po.type == PhysicalOption</b>
&nbsp;                        .PUNCH_BOTH))
<b class="nc">&nbsp;                    &amp;&amp; (mw.getLocation() == Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                    if (c.size() &gt; 0) {</b>
<b class="nc">&nbsp;                        front_ra_dmg += c.get(c.size() - 2).value;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // If this weapon is a push attack and an arm mounted
&nbsp;                // weapon skip to next weapon
&nbsp;
<b class="nc">&nbsp;                if ((best_front_po.type == PhysicalOption.PUSH_ATTACK)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((mw.getLocation() == Mech.LOC_LARM) || (mw</b>
<b class="nc">&nbsp;                                                                        .getLocation() == Mech.LOC_RARM))) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If this weapon is in the same arm as a punch
&nbsp;            // attack, add the damage to the running total.
<b class="nc">&nbsp;            if (c.size() &gt; 0) {</b>
<b class="nc">&nbsp;                front.add(c);</b>
<b class="nc">&nbsp;                attacks[0] = Math.max(attacks[0], c.size());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!es.getFinalProne() &amp;&amp; en.canChangeSecondaryFacing()) {</b>
<b class="nc">&nbsp;                en.setSecondaryFacing((o_facing + 5) % 6);</b>
<b class="nc">&nbsp;                c = calculateWeaponAttacks(en, mw, true);</b>
<b class="nc">&nbsp;                if (c.size() &gt; 0) {</b>
&nbsp;                    // Get best physical attack
<b class="nc">&nbsp;                    best_left_po = PhysicalCalculator.getBestPhysical(en, game);</b>
<b class="nc">&nbsp;                    if ((best_left_po != null) &amp;&amp; (en instanceof Mech)) {</b>
<b class="nc">&nbsp;                        if (((best_left_po.type == PhysicalOption.PUNCH_LEFT) || (best_left_po.type == PhysicalOption</b>
&nbsp;                                .PUNCH_BOTH))
<b class="nc">&nbsp;                            &amp;&amp; (mw.getLocation() == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                            left_la_dmg += c.get(c.size() - 2).value;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (((best_left_po.type == PhysicalOption.PUNCH_RIGHT) || (best_left_po.type ==</b>
&nbsp;                                                                                   PhysicalOption.PUNCH_BOTH))
<b class="nc">&nbsp;                            &amp;&amp; (mw.getLocation() == Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                            left_ra_dmg += c.get(c.size() - 2).value;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    left.add(c);</b>
<b class="nc">&nbsp;                    attacks[1] = Math.max(attacks[1], c.size());</b>
&nbsp;                }
<b class="nc">&nbsp;                en.setSecondaryFacing((o_facing + 1) % 6);</b>
<b class="nc">&nbsp;                c = calculateWeaponAttacks(en, mw, true);</b>
<b class="nc">&nbsp;                if (c.size() &gt; 0) {</b>
&nbsp;                    // Get best physical attack
<b class="nc">&nbsp;                    best_right_po = PhysicalCalculator</b>
<b class="nc">&nbsp;                            .getBestPhysical(en, game);</b>
<b class="nc">&nbsp;                    if ((best_right_po != null) &amp;&amp; (en instanceof Mech)) {</b>
<b class="nc">&nbsp;                        if (((best_right_po.type == PhysicalOption.PUNCH_LEFT) || (best_right_po.type ==</b>
&nbsp;                                                                                   PhysicalOption.PUNCH_BOTH))
<b class="nc">&nbsp;                            &amp;&amp; (mw.getLocation() == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                            right_la_dmg += c.get(c.size() - 2).value;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (((best_right_po.type == PhysicalOption.PUNCH_RIGHT) || (best_right_po.type ==</b>
&nbsp;                                                                                    PhysicalOption.PUNCH_BOTH))
<b class="nc">&nbsp;                            &amp;&amp; (mw.getLocation() == Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                            right_ra_dmg += c.get(c.size() - 2).value;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    right.add(c);</b>
<b class="nc">&nbsp;                    attacks[2] = Math.max(attacks[2], c.size());</b>
&nbsp;                }
<b class="nc">&nbsp;                en.setSecondaryFacing((o_facing + 3) % 6);</b>
<b class="nc">&nbsp;                c = calculateWeaponAttacks(en, mw, true);</b>
<b class="nc">&nbsp;                if (c.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    rear.add(c);</b>
<b class="nc">&nbsp;                    attacks[3] = Math.max(attacks[3], c.size());</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                attacks[1] = 0;</b>
<b class="nc">&nbsp;                attacks[2] = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            en.setSecondaryFacing(o_facing);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        fireOrPhysicalCheck(best_front_po, en, front, front_la_dmg,</b>
&nbsp;                            front_ra_dmg);
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt;&gt; arcs = new ArrayList&lt;ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt;&gt;();</b>
<b class="nc">&nbsp;        arcs.add(front);</b>
<b class="nc">&nbsp;        if (!es.getFinalProne() &amp;&amp; en.canChangeSecondaryFacing()) {</b>
<b class="nc">&nbsp;            fireOrPhysicalCheck(best_left_po, en, left, left_la_dmg,</b>
&nbsp;                                left_ra_dmg);
<b class="nc">&nbsp;            arcs.add(left);</b>
<b class="nc">&nbsp;            fireOrPhysicalCheck(best_right_po, en, right, right_la_dmg,</b>
&nbsp;                                right_ra_dmg);
<b class="nc">&nbsp;            arcs.add(right);</b>
&nbsp;            // Meks and protos can&#39;t twist all the way around.
<b class="nc">&nbsp;            if (!(en instanceof Mech) &amp;&amp; !(en instanceof Protomech)) {</b>
<b class="nc">&nbsp;                arcs.add(rear);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; arcs.size(); i++) {</b>
<b class="nc">&nbsp;            ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; v = arcs.get(i);</b>
<b class="nc">&nbsp;            if (v.size() &gt; 0) {</b>
<b class="nc">&nbsp;                GAAttack test = new GAAttack(this, centities.get(en), v,</b>
<b class="nc">&nbsp;                                             Math.max((v.size() + attacks[i]) * search_level,</b>
&nbsp;                                                      20 * search_level), 30 * search_level,
<b class="nc">&nbsp;                                             en.isEnemyOf(getEntitiesOwned().get(0))</b>
&nbsp;                );
<b class="nc">&nbsp;                test.setFiringArc(i);</b>
<b class="nc">&nbsp;                test.evolve();</b>
<b class="nc">&nbsp;                if (target != null) {</b>
<b class="nc">&nbsp;                    if ((result == null)</b>
<b class="nc">&nbsp;                        || (test.getDamageUtility(target) &gt; result</b>
<b class="nc">&nbsp;                            .getDamageUtility(target))) {</b>
<b class="nc">&nbsp;                        result = test;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((result == null)</b>
<b class="nc">&nbsp;                           || (test.getFittestChromosomesFitness() &gt; result</b>
<b class="nc">&nbsp;                        .getFittestChromosomesFitness())) {</b>
<b class="nc">&nbsp;                    result = test;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If the best attack is a punch, then check each punch damage against the
&nbsp;     * weapons damage from the appropriate arm; if the punch does more damage,
&nbsp;     * drop the weapons in that arm to 0 expected damage Repeat this for left
&nbsp;     * and right twists
&nbsp;     *
&nbsp;     * @param best_po
&nbsp;     * @param entity
&nbsp;     * @param attackOptions
&nbsp;     * @param la_dmg
&nbsp;     * @param ra_dmg
&nbsp;     */
&nbsp;    private void fireOrPhysicalCheck(PhysicalOption best_po, Entity entity,
&nbsp;                                     ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; attackOptions, double la_dmg,
&nbsp;                                     double ra_dmg) {
&nbsp;        ArrayList&lt;AttackOption&gt; c;
<b class="nc">&nbsp;        if ((best_po != null) &amp;&amp; (entity instanceof Mech)) {</b>
<b class="nc">&nbsp;            if (best_po.type == PhysicalOption.PUNCH_LEFT) {</b>
<b class="nc">&nbsp;                if ((la_dmg &lt; best_po.expectedDmg)</b>
<b class="nc">&nbsp;                    &amp;&amp; (attackOptions.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; attackOptions.size(); i++) {</b>
<b class="nc">&nbsp;                        c = attackOptions.get(i);</b>
<b class="nc">&nbsp;                        for (int j = 0; j &lt; c.size(); j++) {</b>
<b class="nc">&nbsp;                            if (c.get(j).weapon.getLocation() == Mech.LOC_LARM) {</b>
<b class="nc">&nbsp;                                c.get(j).expected = 0;</b>
<b class="nc">&nbsp;                                c.get(j).primary_expected = 0;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (best_po.type == PhysicalOption.PUNCH_RIGHT) {</b>
<b class="nc">&nbsp;                if ((ra_dmg &lt; best_po.expectedDmg)</b>
<b class="nc">&nbsp;                    &amp;&amp; (attackOptions.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; attackOptions.size(); i++) {</b>
<b class="nc">&nbsp;                        c = attackOptions.get(i);</b>
<b class="nc">&nbsp;                        for (int j = 0; j &lt; c.size(); j++) {</b>
<b class="nc">&nbsp;                            if (c.get(j).weapon.getLocation() == Mech.LOC_RARM) {</b>
<b class="nc">&nbsp;                                c.get(j).expected = 0;</b>
<b class="nc">&nbsp;                                c.get(j).primary_expected = 0;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (best_po.type == PhysicalOption.PUNCH_BOTH) {</b>
<b class="nc">&nbsp;                if (((la_dmg + ra_dmg) &lt; best_po.expectedDmg)</b>
<b class="nc">&nbsp;                    &amp;&amp; (attackOptions.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; attackOptions.size(); i++) {</b>
<b class="nc">&nbsp;                        c = attackOptions.get(i);</b>
<b class="nc">&nbsp;                        for (int j = 0; j &lt; c.size(); j++) {</b>
<b class="nc">&nbsp;                            if (c.get(j).weapon.getLocation() == Mech.LOC_LARM) {</b>
<b class="nc">&nbsp;                                c.get(j).expected = 0;</b>
<b class="nc">&nbsp;                                c.get(j).primary_expected = 0;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (c.get(j).weapon.getLocation() == Mech.LOC_RARM) {</b>
<b class="nc">&nbsp;                                c.get(j).expected = 0;</b>
<b class="nc">&nbsp;                                c.get(j).primary_expected = 0;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /* could use best of best strategy instead of expensive ga */
&nbsp;    public double attackUtility(MoveOption es, CEntity target) {
<b class="nc">&nbsp;        GAAttack result = bestAttack(es, target, 1);</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return result.getFittestChromosomesFitness();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void calculateFiringTurn() {
<b class="nc">&nbsp;        int first_entity = game.getFirstEntityNum(getMyTurn());</b>
<b class="nc">&nbsp;        int entity_num = first_entity;</b>
<b class="nc">&nbsp;        int best_entity = first_entity;</b>
<b class="nc">&nbsp;        int spin_mode = 0;</b>
<b class="nc">&nbsp;        double max = java.lang.Double.NEGATIVE_INFINITY;</b>
<b class="nc">&nbsp;        int[] results = null;</b>
<b class="nc">&nbsp;        ArrayList&lt;ArrayList&lt;AttackOption&gt;&gt; winner = null;</b>
<b class="nc">&nbsp;        int arc = 0;</b>
&nbsp;        WeaponType spinner;
&nbsp;
<b class="nc">&nbsp;        if (entity_num == -1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        do {
<b class="nc">&nbsp;            Entity en = game.getEntity(entity_num);</b>
<b class="nc">&nbsp;            CEntity cen = centities.get(en);</b>
&nbsp;
<b class="nc">&nbsp;            GAAttack test = bestAttack(cen.current, null, 3);</b>
&nbsp;
<b class="nc">&nbsp;            if ((test != null) &amp;&amp; (test.getFittestChromosomesFitness() &gt; max)) {</b>
<b class="nc">&nbsp;                max = test.getFittestChromosomesFitness();</b>
<b class="nc">&nbsp;                results = test.getResultChromosome();</b>
<b class="nc">&nbsp;                arc = test.getFiringArc();</b>
<b class="nc">&nbsp;                best_entity = entity_num;</b>
<b class="nc">&nbsp;                winner = test.getAttack();</b>
&nbsp;            }
<b class="nc">&nbsp;            entity_num = game.getNextEntityNum(getMyTurn(), entity_num);</b>
<b class="nc">&nbsp;        } while ((entity_num != first_entity) &amp;&amp; (entity_num != -1));</b>
&nbsp;
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; av = new Vector&lt;EntityAction&gt;();</b>
&nbsp;        // maximum already selected (or default)
<b class="nc">&nbsp;        Entity en = game.getEntity(best_entity);</b>
<b class="nc">&nbsp;        if (results != null) {</b>
<b class="nc">&nbsp;            Entity primary_target = game.getEntitiesVector().get(</b>
&nbsp;                    results[results.length - 1]);
<b class="nc">&nbsp;            TreeSet&lt;AttackOption&gt; tm = new TreeSet&lt;AttackOption&gt;(</b>
<b class="nc">&nbsp;                    new AttackOption.Sorter(centities.get(primary_target)));</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; (results.length - 1); i++) {</b>
<b class="nc">&nbsp;                if (winner != null) {</b>
<b class="nc">&nbsp;                    AttackOption a = winner.get(i).get(results[i]);</b>
<b class="nc">&nbsp;                    if (a.target != null) {</b>
<b class="nc">&nbsp;                        a.target.expected_damage[a.toHit.getSideTable()] += a.value;</b>
<b class="nc">&nbsp;                        a.target.hasTakenDamage = true;</b>
<b class="nc">&nbsp;                        tm.add(a);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            Iterator&lt;AttackOption&gt; i = tm.iterator();</b>
<b class="nc">&nbsp;            while (i.hasNext()) {</b>
<b class="nc">&nbsp;                AttackOption a = i.next();</b>
&nbsp;
<b class="nc">&nbsp;                WeaponAttackAction new_attack = new WeaponAttackAction(</b>
<b class="nc">&nbsp;                        en.getId(), a.target.getEntity().getId(),</b>
<b class="nc">&nbsp;                        en.getEquipmentNum(a.weapon));</b>
&nbsp;
<b class="nc">&nbsp;                if (en.getEquipment(new_attack.getWeaponId()).getLinked() != null) {</b>
<b class="nc">&nbsp;                    spinner = (WeaponType) a.weapon.getType();</b>
&nbsp;
&nbsp;                    // If this is an ultra-cannon or rotary cannon, try to spin
&nbsp;                    // it up
&nbsp;
<b class="nc">&nbsp;                    if ((spinner.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                        || (spinner.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;                        || (spinner.getAmmoType() == AmmoType.T_AC_ROTARY)) {</b>
<b class="nc">&nbsp;                        spin_mode = Compute.spinUpCannon(game, new_attack);</b>
<b class="nc">&nbsp;                        super.sendModeChange(en.getId(),</b>
<b class="nc">&nbsp;                                             en.getEquipmentNum(a.weapon), spin_mode);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Mounted cur_ammo = en</b>
<b class="nc">&nbsp;                            .getEquipment(new_attack.getWeaponId()).getLinked();</b>
<b class="nc">&nbsp;                    new_attack.setAmmoId(en.getEquipmentNum(cur_ammo));</b>
<b class="nc">&nbsp;                    Compute.getAmmoAdjDamage(game, new_attack);</b>
&nbsp;
&nbsp;                }
<b class="nc">&nbsp;                av.add(new_attack);</b>
&nbsp;
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Use the attack options and weapon attack actions to determine the
&nbsp;            // best aiming point
&nbsp;
<b class="nc">&nbsp;            if (av.size() &gt; 0) {</b>
<b class="nc">&nbsp;                getAimPoint(tm, av);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        switch (arc) {</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                av.add(0, new TorsoTwistAction(en.getId(),</b>
<b class="nc">&nbsp;                                               (en.getFacing() + 5) % 6));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                av.add(0, new TorsoTwistAction(en.getId(),</b>
<b class="nc">&nbsp;                                               (en.getFacing() + 1) % 6));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                av.add(0, new TorsoTwistAction(en.getId(),</b>
<b class="nc">&nbsp;                                               (en.getFacing() + 3) % 6));</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        sendAttackData(best_entity, av);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * consider how to put more pre-turn logic here
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected void initMovement() {
<b class="nc">&nbsp;        old_moves = null;</b>
<b class="nc">&nbsp;        enemies_moved = 0;</b>
<b class="nc">&nbsp;        double max_modifier = 1.4;</b>
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;(</b>
<b class="nc">&nbsp;                game.getEntitiesVector());</b>
<b class="nc">&nbsp;        double num_entities = Math.sqrt(entities.size()) / 100;</b>
<b class="nc">&nbsp;        ArrayList&lt;CEntity&gt; friends = new ArrayList&lt;CEntity&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;CEntity&gt; foes = new ArrayList&lt;CEntity&gt;();</b>
<b class="nc">&nbsp;        double friend_sum = 0;</b>
<b class="nc">&nbsp;        double foe_sum = 0;</b>
<b class="nc">&nbsp;        double max_foe_bv = 0;</b>
<b class="nc">&nbsp;        CEntity max_foe = null;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entities.size(); i++) {</b>
<b class="nc">&nbsp;            Entity entity = entities.get(i);</b>
<b class="nc">&nbsp;            CEntity centity = centities.get(entity);</b>
<b class="nc">&nbsp;            centity.enemy_num = i;</b>
<b class="nc">&nbsp;            double old_value = centity.bv * (centity.overall_armor_percent + 1);</b>
<b class="nc">&nbsp;            centity.reset(); // should get fresh values</b>
<b class="nc">&nbsp;            double new_value = centity.bv * (centity.overall_armor_percent + 1);</b>
<b class="nc">&nbsp;            double percent = 1 + ((new_value - old_value) / old_value);</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(getLocalPlayer())) {</b>
<b class="nc">&nbsp;                friends.add(centity);</b>
<b class="nc">&nbsp;                friend_sum += new_value;</b>
<b class="nc">&nbsp;                if (percent &lt; .85) {</b>
&nbsp;                    // small retreat
<b class="nc">&nbsp;                    centity.strategy.attack = .85;</b>
<b class="nc">&nbsp;                } else if (percent &lt; .95) {</b>
<b class="nc">&nbsp;                    centity.strategy.attack = 1;</b>
<b class="nc">&nbsp;                } else if ((percent &lt;= 1)</b>
&nbsp;                           &amp;&amp; (centity.strategy.attack &lt; max_modifier)) {
<b class="nc">&nbsp;                    if (percent == 1) {</b>
<b class="nc">&nbsp;                        if (centity.strategy.attack &lt; 1) {</b>
<b class="nc">&nbsp;                            centity.strategy.attack = Math.min(</b>
&nbsp;                                    1.4 * centity.strategy.attack, 1);
&nbsp;                        } else {
<b class="nc">&nbsp;                            centity.strategy.attack *= (1.0 + num_entities);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        centity.strategy.attack *= (1.0 + (2 * num_entities));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (!entity.getOwner().isEnemyOf(getLocalPlayer())) {</b>
<b class="nc">&nbsp;                friend_sum += new_value;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                foes.add(centity);</b>
<b class="nc">&nbsp;                foe_sum += new_value;</b>
<b class="nc">&nbsp;                if (entity.isCommander()) {</b>
<b class="nc">&nbsp;                    new_value *= 3; // make bots like to attack commanders</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((new_value &gt; max_foe_bv) || (max_foe == null)) {</b>
<b class="nc">&nbsp;                    max_foe_bv = new_value;</b>
<b class="nc">&nbsp;                    max_foe = centity;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (getEntitiesOwned().size() &gt; 2) {</b>
<b class="nc">&nbsp;                    if (centity.strategy.target &gt; 2) {</b>
<b class="nc">&nbsp;                        centity.strategy.target = 1 + (.5 * (centity.strategy.target - 2));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((percent &lt; .85)</b>
&nbsp;                        &amp;&amp; (centity.strategy.target &lt; max_modifier)) {
<b class="nc">&nbsp;                        centity.strategy.target *= (1.0 + (6 * num_entities));</b>
<b class="nc">&nbsp;                    } else if ((percent &lt; .95)</b>
&nbsp;                               &amp;&amp; (centity.strategy.target &lt; max_modifier)) {
<b class="nc">&nbsp;                        centity.strategy.target *= (1.0 + (4 * num_entities));</b>
<b class="nc">&nbsp;                    } else if (percent &lt;= 1) {</b>
<b class="nc">&nbsp;                        if (percent == 1) {</b>
<b class="nc">&nbsp;                            centity.strategy.target /= (1.0 + (2 * num_entities));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            centity.strategy.target /= (1.0 + num_entities);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    // don&#39;t go below one
<b class="nc">&nbsp;                    if (centity.strategy.target &lt; 1) {</b>
<b class="nc">&nbsp;                        centity.strategy.target = 1;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(&quot;Us &quot; + friend_sum + &quot; Them &quot; + foe_sum);</b>
&nbsp;        // do some more reasoning...
<b class="nc">&nbsp;        double unit_values = friend_sum;</b>
<b class="nc">&nbsp;        double enemy_values = foe_sum;</b>
<b class="nc">&nbsp;        Iterator&lt;CEntity&gt; i = foes.iterator();</b>
&nbsp;
<b class="nc">&nbsp;        if (friends.size() &gt; 1) {</b>
<b class="nc">&nbsp;            if ((Strategy.MainTarget == null)</b>
<b class="nc">&nbsp;                || (null == game.getEntity(Strategy.MainTarget.getEntity()</b>
<b class="nc">&nbsp;                                                              .getId()))) {</b>
<b class="nc">&nbsp;                Strategy.MainTarget = max_foe;</b>
&nbsp;            }
&nbsp;            // TODO : Handle this better.
<b class="nc">&nbsp;            if (null == Strategy.MainTarget) {</b>
<b class="nc">&nbsp;                System.err</b>
<b class="nc">&nbsp;                        .println(&quot;TestBot#initMovement() - no main target for bot&quot;);</b>
<b class="nc">&nbsp;            } else if (null == Strategy.MainTarget.strategy) {</b>
<b class="nc">&nbsp;                System.err</b>
<b class="nc">&nbsp;                        .println(&quot;TestBot#initMovement() - no strategy for main target&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Strategy.MainTarget.strategy.target += .2;</b>
<b class="nc">&nbsp;                while (i.hasNext()) {</b>
<b class="nc">&nbsp;                    CEntity centity = i.next();</b>
&nbsp;                    // good turn, keep up the work, but randomize to reduce
&nbsp;                    // predictability
<b class="nc">&nbsp;                    if ((friend_sum - foe_sum) &gt;= ((.9 * unit_values) - enemy_values)) {</b>
<b class="nc">&nbsp;                        if (Compute.randomInt(2) == 1) {</b>
<b class="nc">&nbsp;                            centity.strategy.target += .3;</b>
&nbsp;                        }
&nbsp;                        // lost that turn, but still in the fight, just get a
&nbsp;                        // little more aggressive
<b class="nc">&nbsp;                    } else if (friend_sum &gt; (.9 * foe_sum)) {</b>
<b class="nc">&nbsp;                        centity.strategy.target += .15;</b>
&nbsp;                        // lost that turn and loosing
<b class="nc">&nbsp;                    } else if (centity.strategy.target &lt; 2) { // go for the</b>
&nbsp;                        // gusto
<b class="nc">&nbsp;                        centity.strategy.target += .3;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    System.out.println(centity.getEntity().getShortName() + &quot; &quot;</b>
&nbsp;                                       + centity.strategy.target);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double ratio = friend_sum / foe_sum;</b>
<b class="nc">&nbsp;        double mod = 1;</b>
<b class="nc">&nbsp;        if (ratio &lt; .9) {</b>
<b class="nc">&nbsp;            mod = .95;</b>
<b class="nc">&nbsp;        } else if (ratio &lt; 1) {</b>
&nbsp;            // no change
&nbsp;        } else { // attack
<b class="nc">&nbsp;            mod = (1.0 + num_entities);</b>
&nbsp;        }
<b class="nc">&nbsp;        i = friends.iterator();</b>
<b class="nc">&nbsp;        while (i.hasNext()) {</b>
<b class="nc">&nbsp;            CEntity centity = i.next();</b>
<b class="nc">&nbsp;            if (!((mod &lt; 1) &amp;&amp; (centity.strategy.attack &lt; .6))</b>
&nbsp;                &amp;&amp; !((mod &gt; 1) &amp;&amp; (centity.strategy.attack &gt;= max_modifier))) {
<b class="nc">&nbsp;                centity.strategy.attack *= mod;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.gc(); // just to make sure</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected void processChat(GamePlayerChatEvent ge) {
<b class="nc">&nbsp;        chatp.processChat(ge, this);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Where do I put my units? This prioritizes hexes and facings
&nbsp;    @Override
&nbsp;    protected void calculateDeployment() {
&nbsp;
&nbsp;        int weapon_count;
&nbsp;        int hex_count, x_ave, y_ave, nDir;
&nbsp;        double av_range;
&nbsp;
&nbsp;        Coords pointing_to;
&nbsp;
<b class="nc">&nbsp;        int entNum = game.getFirstDeployableEntityNum(game.getTurnForPlayer(localPlayerNumber));</b>
<b class="nc">&nbsp;        assert (entNum != Entity.NONE) : &quot;The bot is trying to deploy without units being left.&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Coords&gt; cStart = getStartingCoordsArray(game.getEntity(entNum));</b>
<b class="nc">&nbsp;        Coords cDeploy = getFirstValidCoords(getEntity(entNum), cStart);</b>
&nbsp;
<b class="nc">&nbsp;        if (cDeploy == null) {</b>
&nbsp;            // bad event handeling, this unit is not deployable, remove it
&nbsp;            // instead.
&nbsp;            // This should not happen but does (eg ships on a deployment zone
&nbsp;            // without water.
<b class="nc">&nbsp;            System.out</b>
<b class="nc">&nbsp;                    .println(&quot;The bot does not know how or is unable to deploy &quot;</b>
<b class="nc">&nbsp;                             + getEntity(entNum) + &quot;. Removing it instead.&quot;);</b>
<b class="nc">&nbsp;            sendChat(&quot;Oh dear I don&#39;t know how to deploy this &quot;</b>
<b class="nc">&nbsp;                     + getEntity(entNum) + &quot;. Skipping to the next one.&quot;);</b>
<b class="nc">&nbsp;            sendDeleteEntity(entNum);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now that we have a location to deploy to, get a direction
&nbsp;        // Using average long range of deploying unit, point towards the largest
&nbsp;        // cluster of enemies in range
&nbsp;
<b class="nc">&nbsp;        av_range = 0.0;</b>
<b class="nc">&nbsp;        weapon_count = 0;</b>
<b class="nc">&nbsp;        for (Mounted mounted : getEntity(entNum).getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="nc">&nbsp;            if ((wtype.getName() != &quot;ATM 3&quot;) &amp;&amp; (wtype.getName() != &quot;ATM 6&quot;)</b>
<b class="nc">&nbsp;                &amp;&amp; (wtype.getName() != &quot;ATM 9&quot;)</b>
<b class="nc">&nbsp;                &amp;&amp; (wtype.getName() != &quot;ATM 12&quot;)) {</b>
<b class="nc">&nbsp;                if (getEntity(entNum).getC3Master() != null) {</b>
<b class="nc">&nbsp;                    av_range += ((wtype.getLongRange()) * 1.25);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    av_range += wtype.getLongRange();</b>
&nbsp;                }
<b class="nc">&nbsp;                weapon_count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Mounted mounted : getEntity(entNum).getAmmo()) {</b>
<b class="nc">&nbsp;            AmmoType atype = (AmmoType) mounted.getType();</b>
<b class="nc">&nbsp;            if (atype.getAmmoType() == AmmoType.T_ATM) {</b>
<b class="nc">&nbsp;                weapon_count++;</b>
<b class="nc">&nbsp;                av_range += 15.0;</b>
<b class="nc">&nbsp;                if (atype.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE) {</b>
<b class="nc">&nbsp;                    av_range -= 6;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (atype.getMunitionType() == AmmoType.M_EXTENDED_RANGE) {</b>
<b class="nc">&nbsp;                    av_range += 12.0;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (atype.getAmmoType() == AmmoType.T_MML) {</b>
<b class="nc">&nbsp;                weapon_count++;</b>
<b class="nc">&nbsp;                if (atype.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    av_range = 9;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    av_range = 21.0;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        av_range = av_range / weapon_count;</b>
&nbsp;
<b class="nc">&nbsp;        hex_count = 0;</b>
<b class="nc">&nbsp;        x_ave = 0;</b>
<b class="nc">&nbsp;        y_ave = 0;</b>
<b class="nc">&nbsp;        for (Entity test_ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (test_ent.isDeployed()) {</b>
<b class="nc">&nbsp;                if (test_ent.isVisibleToEnemy()) {</b>
<b class="nc">&nbsp;                    if (cDeploy.distance(test_ent.getPosition()) &lt;= (int) av_range) {</b>
<b class="nc">&nbsp;                        hex_count++;</b>
<b class="nc">&nbsp;                        x_ave += test_ent.getPosition().getX();</b>
<b class="nc">&nbsp;                        y_ave += test_ent.getPosition().getY();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (hex_count != 0) {</b>
<b class="nc">&nbsp;            pointing_to = new Coords((x_ave / hex_count), (y_ave / hex_count));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            pointing_to = new Coords(game.getBoard().getWidth() / 2, game</b>
<b class="nc">&nbsp;                                                                             .getBoard().getHeight() / 2);</b>
&nbsp;        }
<b class="nc">&nbsp;        nDir = cDeploy.direction(pointing_to);</b>
&nbsp;
&nbsp;        // If unit has stealth armor, turn it on
<b class="nc">&nbsp;        if ((getEntity(entNum) instanceof Mech)</b>
<b class="nc">&nbsp;            &amp;&amp; (getEntity(entNum).getArmorType(0) == EquipmentType.T_ARMOR_STEALTH)</b>
<b class="nc">&nbsp;            &amp;&amp; !getEntity(entNum).hasPatchworkArmor()) {</b>
<b class="nc">&nbsp;            for (Mounted test_equip : getEntity(entNum).getMisc()) {</b>
<b class="nc">&nbsp;                MiscType test_type = (MiscType) test_equip.getType();</b>
<b class="nc">&nbsp;                if (test_type.hasFlag(MiscType.F_STEALTH)) {</b>
<b class="nc">&nbsp;                    if (!test_equip.curMode().getName().equals(&quot;On&quot;)) {</b>
<b class="nc">&nbsp;                        test_equip.setMode(&quot;On&quot;);</b>
<b class="nc">&nbsp;                        super.sendModeChange(entNum, getEntity(entNum)</b>
<b class="nc">&nbsp;                                .getEquipmentNum(test_equip), 1);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entity ce = game.getEntity(entNum);</b>
<b class="nc">&nbsp;        assert (!ce.isLocationProhibited(cDeploy)) : &quot;Bot tried to deploy to an invalid hex&quot;;</b>
<b class="nc">&nbsp;        deploy(entNum, cDeploy, nDir, 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected MovePath continueMovementFor(Entity entity) {
&nbsp;
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            throw new NullPointerException(&quot;Entity is null.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        System.out.println(&quot;Contemplating movement of &quot; + entity.getShortName()</b>
<b class="nc">&nbsp;                           + &quot; &quot; + entity.getId());</b>
<b class="nc">&nbsp;        CEntity cen = centities.get(entity);</b>
<b class="nc">&nbsp;        cen.refresh();</b>
<b class="nc">&nbsp;        firstPass(cen);</b>
&nbsp;
<b class="nc">&nbsp;        Object[] enemy_array = getEnemyEntities().toArray();</b>
<b class="nc">&nbsp;        MoveOption result[] = calculateMove(entity);</b>
<b class="nc">&nbsp;        MoveOption min = null;</b>
<b class="nc">&nbsp;        ArrayList&lt;MoveOption[]&gt; possible = new ArrayList&lt;MoveOption[]&gt;();</b>
<b class="nc">&nbsp;        boolean short_circuit = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (result.length &lt; 6) {</b>
<b class="nc">&nbsp;            min = result.length &gt; 0 ? (MoveOption) result[0] : null;</b>
<b class="nc">&nbsp;            short_circuit = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        possible.add(result);</b>
&nbsp;
&nbsp;        // should ignore mechs that are not engaged
&nbsp;        // and only do the below when there are 2 or mechs left to move
<b class="nc">&nbsp;        if (!short_circuit) {</b>
<b class="nc">&nbsp;            if ((getEntitiesOwned().size() &gt; 1) &amp;&amp; (possible.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                GALance lance = new GALance(this, possible, 50, 80);</b>
<b class="nc">&nbsp;                lance.evolve();</b>
<b class="nc">&nbsp;                min = lance.getResult();</b>
<b class="nc">&nbsp;                old_moves = lance;</b>
<b class="nc">&nbsp;            } else if ((possible.get(0) != null)</b>
<b class="nc">&nbsp;                       &amp;&amp; (possible.get(0).length &gt; 0)) {</b>
<b class="nc">&nbsp;                min = possible.get(0)[0];</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (min == null) {</b>
<b class="nc">&nbsp;            min = new MoveOption(game, centities.get(getFirstEntityNum()));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Object element : enemy_array) {</b>
<b class="nc">&nbsp;            Entity en = (Entity) element;</b>
&nbsp;
&nbsp;            // ignore loaded units
<b class="nc">&nbsp;            if (en.getPosition() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            CEntity enemy = centities.get(en);</b>
<b class="nc">&nbsp;            int enemy_hit_arc = CEntity.getThreatHitArc(</b>
<b class="nc">&nbsp;                    enemy.current.getFinalCoords(),</b>
<b class="nc">&nbsp;                    enemy.current.getFinalFacing(), min.getFinalCoords());</b>
<b class="nc">&nbsp;            MoveOption.DamageInfo di = min.damageInfos.get(enemy);</b>
<b class="nc">&nbsp;            if (di != null) {</b>
<b class="nc">&nbsp;                enemy.expected_damage[enemy_hit_arc] += di.min_damage;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (enemy.expected_damage[enemy_hit_arc] &gt; 0) {</b>
<b class="nc">&nbsp;                enemy.hasTakenDamage = true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (min.isPhysical) {</b>
<b class="nc">&nbsp;            centities.get(min.getPhysicalTargetId()).isPhysicalTarget = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(min);</b>
<b class="nc">&nbsp;        min.getCEntity().current = min;</b>
<b class="nc">&nbsp;        min.getCEntity().last = min;</b>
<b class="nc">&nbsp;        min.getCEntity().moved = true;</b>
&nbsp;
&nbsp;        // If this unit has a jammed RAC, and it has only walked,
&nbsp;        // add an unjam action
<b class="nc">&nbsp;        if (min.getLastStep() != null) {</b>
<b class="nc">&nbsp;            if (min.getCEntity().entity.canUnjamRAC()) {</b>
<b class="nc">&nbsp;                if ((min.getLastStep().getMovementType(true) == EntityMovementType.MOVE_WALK)</b>
<b class="nc">&nbsp;                    || (min.getLastStep().getMovementType(true) == EntityMovementType.MOVE_VTOL_WALK)</b>
<b class="nc">&nbsp;                    || (min.getLastStep().getMovementType(true) == EntityMovementType.MOVE_NONE)) {</b>
&nbsp;                    // Cycle through all available weapons, only unjam if the
&nbsp;                    // jam(med)
&nbsp;                    // RACs count for a significant portion of possible damage
<b class="nc">&nbsp;                    int rac_damage = 0;</b>
<b class="nc">&nbsp;                    int other_damage = 0;</b>
<b class="nc">&nbsp;                    int clearance_range = 0;</b>
<b class="nc">&nbsp;                    for (Mounted equip : min.getCEntity().entity</b>
<b class="nc">&nbsp;                            .getWeaponList()) {</b>
<b class="nc">&nbsp;                        WeaponType test_weapon = new WeaponType();</b>
&nbsp;
<b class="nc">&nbsp;                        test_weapon = (WeaponType) equip.getType();</b>
<b class="nc">&nbsp;                        if ((test_weapon.getAmmoType() == AmmoType.T_AC_ROTARY)</b>
<b class="nc">&nbsp;                            &amp;&amp; (equip.isJammed() == true)) {</b>
<b class="nc">&nbsp;                            rac_damage = rac_damage</b>
<b class="nc">&nbsp;                                         + (4 * (test_weapon.getDamage()));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (equip.canFire()) {</b>
<b class="nc">&nbsp;                                other_damage += test_weapon.getDamage();</b>
<b class="nc">&nbsp;                                if (test_weapon.getMediumRange() &gt; clearance_range) {</b>
<b class="nc">&nbsp;                                    clearance_range = test_weapon</b>
<b class="nc">&nbsp;                                            .getMediumRange();</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // Even if the jammed RAC doesn&#39;t make up a significant
&nbsp;                    // portion
&nbsp;                    // of the units damage, its still better to have it
&nbsp;                    // functional
&nbsp;                    // If nothing is &quot;close&quot; then unjam anyways
<b class="nc">&nbsp;                    int check_range = 100;</b>
<b class="nc">&nbsp;                    for (Entity enemy : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                        if ((min.getCEntity().entity.getPosition() != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; (enemy.getPosition() != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; (enemy.isEnemyOf(min.getCEntity().entity))) {</b>
<b class="nc">&nbsp;                            if (enemy.isVisibleToEnemy()) {</b>
<b class="nc">&nbsp;                                if (min.getCEntity().entity.getPosition()</b>
<b class="nc">&nbsp;                                                           .distance(enemy.getPosition()) &lt; check_range) {</b>
<b class="nc">&nbsp;                                    check_range = min.getCEntity().entity</b>
<b class="nc">&nbsp;                                            .getPosition().distance(</b>
<b class="nc">&nbsp;                                                    enemy.getPosition());</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if ((rac_damage &gt;= other_damage)</b>
&nbsp;                        || (check_range &lt; clearance_range)) {
<b class="nc">&nbsp;                        min.addStep(MoveStepType.UNJAM_RAC);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return min;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected Vector&lt;Minefield&gt; calculateMinefieldDeployment() {
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; deployedMinefields = new Vector&lt;Minefield&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        deployMinefields(deployedMinefields, getLocalPlayer()</b>
<b class="nc">&nbsp;                .getNbrMFConventional(), 0);</b>
<b class="nc">&nbsp;        deployMinefields(deployedMinefields,</b>
<b class="nc">&nbsp;                         getLocalPlayer().getNbrMFCommand(), 1);</b>
<b class="nc">&nbsp;        deployMinefields(deployedMinefields, getLocalPlayer().getNbrMFVibra(),</b>
&nbsp;                         2);
&nbsp;
<b class="nc">&nbsp;        return deployedMinefields;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected PlayerIDandList&lt;Coords&gt; calculateArtyAutoHitHexes() {
<b class="nc">&nbsp;        PlayerIDandList&lt;Coords&gt; artyAutoHitHexes = new PlayerIDandList&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        artyAutoHitHexes.setPlayerID(getLocalPlayer().getId());</b>
<b class="nc">&nbsp;        return artyAutoHitHexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void deployMinefields(Vector&lt;Minefield&gt; deployedMinefields,
&nbsp;                                    int number, int type) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; number; i++) {</b>
<b class="nc">&nbsp;            Coords coords = new Coords(Compute.randomInt(game.getBoard()</b>
<b class="nc">&nbsp;                                                             .getWidth()),</b>
<b class="nc">&nbsp;                                       Compute.randomInt(game.getBoard().getHeight())</b>
&nbsp;            );
&nbsp;
<b class="nc">&nbsp;            if (game.containsMinefield(coords)) {</b>
<b class="nc">&nbsp;                Minefield mf = game.getMinefields(coords).get(0);</b>
<b class="nc">&nbsp;                if (mf.getPlayerId() == getLocalPlayer().getId()) {</b>
<b class="nc">&nbsp;                    i--;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                Minefield mf = null;</b>
&nbsp;
<b class="nc">&nbsp;                if (type == 0) {</b>
<b class="nc">&nbsp;                    mf = Minefield.createMinefield(coords, getLocalPlayer()</b>
<b class="nc">&nbsp;                            .getId(), Minefield.TYPE_CONVENTIONAL, 10);</b>
<b class="nc">&nbsp;                } else if (type == 1) {</b>
<b class="nc">&nbsp;                    mf = Minefield.createMinefield(coords, getLocalPlayer()</b>
<b class="nc">&nbsp;                            .getId(), Minefield.TYPE_COMMAND_DETONATED, 10);</b>
<b class="nc">&nbsp;                } else if (type == 2) {</b>
<b class="nc">&nbsp;                    mf = Minefield.createMinefield(coords, getLocalPlayer()</b>
<b class="nc">&nbsp;                            .getId(), Minefield.TYPE_VIBRABOMB, 20);</b>
&nbsp;                }
<b class="nc">&nbsp;                deployedMinefields.add(mf);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Calculate the best location to aim at on a target Mech. Attack options
&nbsp;     * must match 1:1 with WeaponAttackActions in Vector.
&nbsp;     */
&nbsp;    private void getAimPoint(TreeSet&lt;AttackOption&gt; attack_tree,
&nbsp;                             Vector&lt;EntityAction&gt; atk_action_list) {
&nbsp;
<b class="nc">&nbsp;        if ((attack_tree == null) || (atk_action_list == null)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        WeaponAttackAction aimed_attack;
&nbsp;        AttackOption current_option;
&nbsp;
&nbsp;        Vector&lt;Integer&gt; target_id_list; // List of viable aimed-shot targets
&nbsp;
&nbsp;        // Adjusted damages
&nbsp;        double base_damage, base_odds;
&nbsp;        double refactored_damage, refactored_head;
&nbsp;
&nbsp;        // Armor values
&nbsp;        // Order is: head, ct, lt, rt, la, ra, ll, rl
<b class="nc">&nbsp;        double[] values = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};</b>
&nbsp;
&nbsp;        // Internal structure values
&nbsp;        // Order is: head, ct, lt, rt, la, ra, ll, rl
<b class="nc">&nbsp;        double[] is_values = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};</b>
&nbsp;
&nbsp;        // Fitness values
&nbsp;        // Order is: head, ct, lt, rt, la, ra, ll, rl
<b class="nc">&nbsp;        double[] fitness = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};</b>
&nbsp;
&nbsp;        // Counters for armor penetration
&nbsp;        // Order is: head, ct, lt, rt, la, ra, ll, rl
<b class="nc">&nbsp;        int[] pen_counters = {0, 0, 0, 0, 0, 0, 0, 0};</b>
&nbsp;
&nbsp;        int attacker_id, test_target;
<b class="nc">&nbsp;        int action_index = 0;</b>
&nbsp;
&nbsp;        // Base to-hit
&nbsp;        int base_to_hit;
&nbsp;
&nbsp;        // Best locations to aim for
&nbsp;        int best_loc, best_loc_head;
&nbsp;
<b class="nc">&nbsp;        boolean has_tcomp = false;</b>
&nbsp;        boolean imob_target, rear_shot;
&nbsp;        boolean is_primary_target;
&nbsp;
&nbsp;        // For each attack action
&nbsp;
<b class="nc">&nbsp;        target_id_list = new Vector&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        for (EntityAction aea : atk_action_list) {</b>
&nbsp;
<b class="nc">&nbsp;            if (aea instanceof WeaponAttackAction) {</b>
&nbsp;                // Get the attacker
&nbsp;
<b class="nc">&nbsp;                attacker_id = ((WeaponAttackAction) atk_action_list.get(0))</b>
<b class="nc">&nbsp;                        .getEntityId();</b>
&nbsp;
&nbsp;                // Check to see if the attacker has a tcomp
&nbsp;
<b class="nc">&nbsp;                has_tcomp = game.getEntity(attacker_id).hasTargComp();</b>
&nbsp;
&nbsp;                // Get the target entity id
&nbsp;
<b class="nc">&nbsp;                test_target = ((WeaponAttackAction) aea).getTargetId();</b>
&nbsp;
&nbsp;                // If the target is a Mech
&nbsp;
<b class="nc">&nbsp;                if (game.getEntity(test_target) instanceof Mech) {</b>
&nbsp;
&nbsp;                    // If the target is officially immobile or if the attacker
&nbsp;                    // has a tcomp
&nbsp;
<b class="nc">&nbsp;                    if ((has_tcomp == true)</b>
<b class="nc">&nbsp;                        | (game.getEntity(test_target).isImmobile())) {</b>
<b class="nc">&nbsp;                        if (!target_id_list.contains(test_target)) {</b>
<b class="nc">&nbsp;                            target_id_list.add(test_target);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // For each valid target
&nbsp;
<b class="nc">&nbsp;        is_primary_target = true;</b>
<b class="nc">&nbsp;        for (Iterator&lt;Integer&gt; i = target_id_list.iterator(); i.hasNext(); ) {</b>
&nbsp;
&nbsp;            // Set the current target
&nbsp;
<b class="nc">&nbsp;            test_target = i.next();</b>
<b class="nc">&nbsp;            imob_target = game.getEntity(test_target).isImmobile();</b>
&nbsp;
&nbsp;            // Get the targets aspect ratio
&nbsp;
<b class="nc">&nbsp;            rear_shot = false;</b>
<b class="nc">&nbsp;            for (Iterator&lt;AttackOption&gt; j = attack_tree.iterator(); j.hasNext(); ) {</b>
<b class="nc">&nbsp;                current_option = j.next();</b>
<b class="nc">&nbsp;                if (current_option.target.getEntity().getId() == test_target) {</b>
<b class="nc">&nbsp;                    int attack_direction = current_option.toHit.getSideTable();</b>
<b class="nc">&nbsp;                    if (attack_direction == ToHitData.SIDE_REAR) {</b>
<b class="nc">&nbsp;                        rear_shot = true;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        rear_shot = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Get the armor values for the target and make them negative (count
&nbsp;            // up)
&nbsp;
<b class="nc">&nbsp;            values[0] = game.getEntity(test_target).getArmor(Mech.LOC_HEAD);</b>
<b class="nc">&nbsp;            values[1] = game.getEntity(test_target).getArmor(Mech.LOC_CT,</b>
&nbsp;                                                             rear_shot);
<b class="nc">&nbsp;            values[2] = game.getEntity(test_target).getArmor(Mech.LOC_LT,</b>
&nbsp;                                                             rear_shot);
<b class="nc">&nbsp;            values[3] = game.getEntity(test_target).getArmor(Mech.LOC_RT,</b>
&nbsp;                                                             rear_shot);
<b class="nc">&nbsp;            values[4] = game.getEntity(test_target).getArmor(Mech.LOC_LARM);</b>
<b class="nc">&nbsp;            values[5] = game.getEntity(test_target).getArmor(Mech.LOC_RARM);</b>
<b class="nc">&nbsp;            values[6] = game.getEntity(test_target).getArmor(Mech.LOC_LLEG);</b>
<b class="nc">&nbsp;            values[7] = game.getEntity(test_target).getArmor(Mech.LOC_RLEG);</b>
&nbsp;
&nbsp;            // Get the internals for the target
&nbsp;
<b class="nc">&nbsp;            is_values[0] = game.getEntity(test_target).getInternal(</b>
&nbsp;                    Mech.LOC_HEAD);
<b class="nc">&nbsp;            is_values[1] = game.getEntity(test_target).getInternal(Mech.LOC_CT);</b>
<b class="nc">&nbsp;            is_values[2] = game.getEntity(test_target).getInternal(Mech.LOC_LT);</b>
<b class="nc">&nbsp;            is_values[3] = game.getEntity(test_target).getInternal(Mech.LOC_RT);</b>
<b class="nc">&nbsp;            is_values[4] = game.getEntity(test_target).getInternal(</b>
&nbsp;                    Mech.LOC_LARM);
<b class="nc">&nbsp;            is_values[5] = game.getEntity(test_target).getInternal(</b>
&nbsp;                    Mech.LOC_RARM);
<b class="nc">&nbsp;            is_values[6] = game.getEntity(test_target).getInternal(</b>
&nbsp;                    Mech.LOC_LLEG);
<b class="nc">&nbsp;            is_values[7] = game.getEntity(test_target).getInternal(</b>
&nbsp;                    Mech.LOC_RLEG);
&nbsp;
&nbsp;            // Reset the fitness array
<b class="nc">&nbsp;            for (int arr_index = 0; arr_index &lt; 8; arr_index++) {</b>
<b class="nc">&nbsp;                fitness[arr_index] = 0.0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Reset the penetration counter
&nbsp;
<b class="nc">&nbsp;            for (int arr_index = 0; arr_index &lt; 8; arr_index++) {</b>
<b class="nc">&nbsp;                pen_counters[arr_index] = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // For each attack option
&nbsp;
<b class="nc">&nbsp;            action_index = 0;</b>
<b class="nc">&nbsp;            refactored_damage = 0.0;</b>
<b class="nc">&nbsp;            refactored_head = 0.0;</b>
&nbsp;
<b class="nc">&nbsp;            best_loc = Mech.LOC_CT;</b>
<b class="nc">&nbsp;            best_loc_head = Mech.LOC_CT;</b>
<b class="nc">&nbsp;            for (Iterator&lt;AttackOption&gt; j = attack_tree.iterator(); j.hasNext(); ) {</b>
&nbsp;
&nbsp;                // If the target of the attack option is the current target
&nbsp;
<b class="nc">&nbsp;                current_option = j.next();</b>
<b class="nc">&nbsp;                if (test_target == current_option.target.getEntity().getId()) {</b>
&nbsp;
&nbsp;                    // Get the weapon
&nbsp;
<b class="nc">&nbsp;                    Mounted test_weapon = current_option.weapon;</b>
<b class="nc">&nbsp;                    boolean aptGunnery = current_option.target.getEntity().hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</b>
&nbsp;
&nbsp;                    // If the weapon is not LBX cannon or LBX cannon loaded with
&nbsp;                    // slug
&nbsp;
<b class="nc">&nbsp;                    boolean direct_fire = true;</b>
<b class="nc">&nbsp;                    if (((WeaponType) test_weapon.getType())</b>
<b class="nc">&nbsp;                                .hasFlag(WeaponType.F_DIRECT_FIRE) == false) {</b>
<b class="nc">&nbsp;                        direct_fire = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (test_weapon.getType().hasFlag(WeaponType.F_PULSE)) {</b>
<b class="nc">&nbsp;                        direct_fire = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((((WeaponType) test_weapon.getType()).getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                        || (((WeaponType) test_weapon.getType())</b>
<b class="nc">&nbsp;                                    .getAmmoType() == AmmoType.T_AC_LBX)) {</b>
<b class="nc">&nbsp;                        if (((AmmoType) test_weapon.getLinked().getType())</b>
<b class="nc">&nbsp;                                    .getAmmoType() == AmmoType.M_CLUSTER) {</b>
<b class="nc">&nbsp;                            direct_fire = false;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (test_weapon.getCurrentShots() &gt; 1) {</b>
<b class="nc">&nbsp;                        direct_fire = false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // If the weapon is direct fire
&nbsp;
<b class="nc">&nbsp;                    if (direct_fire == true) {</b>
&nbsp;
&nbsp;                        // Get the expected damage, to-hit number, and odds
&nbsp;                        // (0-1) of hitting
&nbsp;
<b class="nc">&nbsp;                        base_damage = is_primary_target ? current_option.primary_expected</b>
<b class="nc">&nbsp;                                                        : current_option.expected;</b>
<b class="nc">&nbsp;                        base_to_hit = is_primary_target ? current_option.toHit</b>
<b class="nc">&nbsp;                                .getValue()</b>
<b class="nc">&nbsp;                                                        : current_option.toHit.getValue() + 1;</b>
<b class="nc">&nbsp;                        base_odds = is_primary_target ? current_option.primary_odds</b>
<b class="nc">&nbsp;                                                      : current_option.odds;</b>
<b class="nc">&nbsp;                        base_damage = base_odds == 0.0 ? 0.0 : base_damage</b>
<b class="nc">&nbsp;                                                               / base_odds;</b>
&nbsp;
&nbsp;                        // If the target is mobile, only a tcomp can make an
&nbsp;                        // aimed shot
&nbsp;
<b class="nc">&nbsp;                        if (!imob_target &amp; has_tcomp) {</b>
&nbsp;
&nbsp;                            // Refactor the expected damage to account for
&nbsp;                            // increased to-hit number
&nbsp;
<b class="nc">&nbsp;                            refactored_head = 0.0;</b>
<b class="nc">&nbsp;                            if (((base_to_hit + 4) &lt;= 12) &amp;&amp; Compute.allowAimedShotWith(test_weapon,</b>
&nbsp;                                                                                        IAimingModes
&nbsp;                                                                                                .AIM_MODE_TARG_COMP)) {
<b class="nc">&nbsp;                                refactored_damage = base_damage</b>
<b class="nc">&nbsp;                                                    * (Compute.oddsAbove(base_to_hit + 4, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                ((WeaponAttackAction) atk_action_list</b>
<b class="nc">&nbsp;                                        .get(action_index))</b>
<b class="nc">&nbsp;                                        .setAimingMode(IAimingModes.AIM_MODE_TARG_COMP);</b>
&nbsp;                                // Consider that a regular shot has a roughly
&nbsp;                                // 20% chance of hitting the same location
&nbsp;                                // Use the better of the regular shot or aimed
&nbsp;                                // shot
<b class="nc">&nbsp;                                if ((0.2 * base_damage * (Compute.oddsAbove(base_to_hit, aptGunnery) / 100.0)) &gt;</b>
&nbsp;                                    refactored_damage) {
<b class="nc">&nbsp;                                    refactored_damage = 0.2</b>
&nbsp;                                                        * base_damage
<b class="nc">&nbsp;                                                        * (Compute.oddsAbove(base_to_hit, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                    ((WeaponAttackAction) atk_action_list</b>
<b class="nc">&nbsp;                                            .get(action_index))</b>
<b class="nc">&nbsp;                                            .setAimingMode(IAimingModes.AIM_MODE_NONE);</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                refactored_damage = 0.0;</b>
<b class="nc">&nbsp;                                ((WeaponAttackAction) atk_action_list</b>
<b class="nc">&nbsp;                                        .get(action_index))</b>
<b class="nc">&nbsp;                                        .setAimingMode(IAimingModes.AIM_MODE_NONE);</b>
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
&nbsp;                        // If the target is immobile, the shot will always be
&nbsp;                        // aimed
&nbsp;
<b class="nc">&nbsp;                        if (imob_target) {</b>
&nbsp;
&nbsp;                            // If the attacker has a tcomp, consider both
&nbsp;                            // options: immobile aim, tcomp aim
&nbsp;
<b class="nc">&nbsp;                            if (has_tcomp) {</b>
&nbsp;
<b class="nc">&nbsp;                                if (Compute.allowAimedShotWith(test_weapon, IAimingModes.AIM_MODE_TARG_COMP)) {</b>
&nbsp;                                    // Refactor the expected damage to account for
&nbsp;                                    // increased to-hit number of the tcomp
&nbsp;
<b class="nc">&nbsp;                                    refactored_damage = base_damage</b>
<b class="nc">&nbsp;                                                        * (Compute.oddsAbove(base_to_hit + 4, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                    refactored_head = 0.0;</b>
<b class="nc">&nbsp;                                    ((WeaponAttackAction) atk_action_list</b>
<b class="nc">&nbsp;                                            .get(action_index))</b>
<b class="nc">&nbsp;                                            .setAimingMode(IAimingModes.AIM_MODE_TARG_COMP);</b>
&nbsp;
&nbsp;                                    // Check against immobile aim mode w/tcomp
&nbsp;                                    // assist
&nbsp;
&nbsp;                                }
<b class="nc">&nbsp;                                if (((0.50 * base_damage * (Compute</b>
<b class="nc">&nbsp;                                                                    .oddsAbove(base_to_hit, aptGunnery) / 100.0)) &gt;</b>
<b class="nc">&nbsp;                                     refactored_damage) &amp;&amp; Compute.allowAimedShotWith(test_weapon,</b>
&nbsp;                                                                                      IAimingModes.AIM_MODE_IMMOBILE)) {
<b class="nc">&nbsp;                                    refactored_damage = 0.50</b>
&nbsp;                                                        * base_damage
<b class="nc">&nbsp;                                                        * (Compute.oddsAbove(base_to_hit, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                    refactored_head = 0.50</b>
&nbsp;                                                      * base_damage
&nbsp;                                                      * (Compute
<b class="nc">&nbsp;                                                                 .oddsAbove(base_to_hit + 7, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                    ((WeaponAttackAction) atk_action_list</b>
<b class="nc">&nbsp;                                            .get(action_index))</b>
<b class="nc">&nbsp;                                            .setAimingMode(IAimingModes.AIM_MODE_IMMOBILE);</b>
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                            } else if (Compute.allowAimedShotWith(test_weapon, IAimingModes.AIM_MODE_IMMOBILE)) {</b>
&nbsp;
&nbsp;                                // If the attacker doesn&#39;t have a tcomp, settle
&nbsp;                                // for immobile aim
&nbsp;
<b class="nc">&nbsp;                                refactored_damage = 0.50</b>
&nbsp;                                                    * base_damage
<b class="nc">&nbsp;                                                    * (Compute.oddsAbove(base_to_hit, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                refactored_head = 0.50</b>
&nbsp;                                                  * base_damage
<b class="nc">&nbsp;                                                  * (Compute.oddsAbove(base_to_hit + 7, aptGunnery) / 100.0);</b>
<b class="nc">&nbsp;                                ((WeaponAttackAction) atk_action_list</b>
<b class="nc">&nbsp;                                        .get(action_index))</b>
<b class="nc">&nbsp;                                        .setAimingMode(IAimingModes.AIM_MODE_IMMOBILE);</b>
&nbsp;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // Count the refactored damage off each location. Count
&nbsp;                        // hits to IS.
&nbsp;                        // Ignore locations that have been previously destroyed
&nbsp;
<b class="nc">&nbsp;                        for (int arr_index = 0; arr_index &lt; 8; arr_index++) {</b>
<b class="nc">&nbsp;                            if (arr_index == 0) {</b>
<b class="nc">&nbsp;                                values[arr_index] -= refactored_head;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                values[arr_index] -= refactored_damage;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if ((values[arr_index] &lt; 0)</b>
&nbsp;                                &amp; (is_values[arr_index] &gt; 0)) {
<b class="nc">&nbsp;                                is_values[arr_index] += values[arr_index];</b>
<b class="nc">&nbsp;                                values[arr_index] = 0;</b>
<b class="nc">&nbsp;                                pen_counters[arr_index]++;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // End if (AttackAction against current target)
&nbsp;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                action_index++;</b>
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            double loc_mod;
<b class="nc">&nbsp;            for (int arr_index = 0; arr_index &lt; 8; arr_index++) {</b>
<b class="nc">&nbsp;                loc_mod = 0.0;</b>
&nbsp;
&nbsp;                // If any location has had its armor stripped but is not
&nbsp;                // destroyed,
&nbsp;                // criticals may result
&nbsp;
<b class="nc">&nbsp;                if ((values[arr_index] &lt;= 0) &amp; (is_values[arr_index] &gt; 0)) {</b>
<b class="nc">&nbsp;                    switch (arr_index) {</b>
&nbsp;                        case 0: // Head hits are very good, pilot damage and
&nbsp;                            // critical systems
<b class="nc">&nbsp;                            fitness[arr_index] = 4.0 * pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += getAimModifier(test_target,</b>
&nbsp;                                                                 Mech.LOC_HEAD);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1: // CT hits are good, chances at hitting gyro,
&nbsp;                            // engine
<b class="nc">&nbsp;                            fitness[arr_index] = 3.0 * pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += getAimModifier(test_target,</b>
&nbsp;                                                                 Mech.LOC_CT);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2: // Side torso hits are good, equipment hits and
&nbsp;                            // ammo slots
<b class="nc">&nbsp;                            loc_mod = getAimModifier(test_target, Mech.LOC_LT);</b>
<b class="nc">&nbsp;                            fitness[arr_index] = 2.0 * pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += loc_mod;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            loc_mod = getAimModifier(test_target, Mech.LOC_RT);</b>
<b class="nc">&nbsp;                            fitness[arr_index] = 2.0 * pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += loc_mod;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6: // Leg hits are good, reduces target mobility
<b class="nc">&nbsp;                            loc_mod = getAimModifier(test_target, Mech.LOC_LLEG);</b>
<b class="nc">&nbsp;                            fitness[arr_index] = 2.0 * pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += loc_mod;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            loc_mod = getAimModifier(test_target, Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                            fitness[arr_index] = 2.0 * pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += loc_mod;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4: // Arm hits might damage some weapons, but not
&nbsp;                            // the best option
<b class="nc">&nbsp;                            loc_mod = getAimModifier(test_target, Mech.LOC_LARM);</b>
<b class="nc">&nbsp;                            fitness[arr_index] = pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += loc_mod;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            loc_mod = getAimModifier(test_target, Mech.LOC_RARM);</b>
<b class="nc">&nbsp;                            fitness[arr_index] = pen_counters[arr_index];</b>
<b class="nc">&nbsp;                            fitness[arr_index] += loc_mod;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // If any location has been destroyed, adjust the location value
&nbsp;                // relative to its value
&nbsp;
<b class="nc">&nbsp;                if ((is_values[arr_index] &lt;= 0) &amp; (pen_counters[arr_index] &gt; 0)) {</b>
&nbsp;
<b class="nc">&nbsp;                    switch (arr_index) {</b>
&nbsp;                        case 0: // Destroying the head is a hard kill and gets
&nbsp;                            // rid of the pilot, too
<b class="nc">&nbsp;                            fitness[arr_index] += 3 * getAimModifier(</b>
&nbsp;                                    test_target, Mech.LOC_HEAD);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1: // Destroying the CT is a hard kill
<b class="nc">&nbsp;                            fitness[arr_index] += 2 * getAimModifier(</b>
&nbsp;                                    test_target, Mech.LOC_CT);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2: // Destroying a side torso could be a soft kill
&nbsp;                            // or cripple
<b class="nc">&nbsp;                            fitness[arr_index] += 1.5 * getAimModifier(</b>
&nbsp;                                    test_target, Mech.LOC_LT);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            fitness[arr_index] += 1.5 * getAimModifier(</b>
&nbsp;                                    test_target, Mech.LOC_RT);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6: // Destroying a leg is a mobility kill
<b class="nc">&nbsp;                            fitness[arr_index] += 1.5 * getAimModifier(</b>
&nbsp;                                    test_target, Mech.LOC_LLEG);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            fitness[arr_index] += 1.5 * getAimModifier(</b>
&nbsp;                                    test_target, Mech.LOC_RLEG);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4: // Destroying an arm can cripple a Mech, but not
&nbsp;                            // the best option
<b class="nc">&nbsp;                            fitness[arr_index] += getAimModifier(test_target,</b>
&nbsp;                                                                 Mech.LOC_LARM);
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            fitness[arr_index] += getAimModifier(test_target,</b>
&nbsp;                                                                 Mech.LOC_RARM);
&nbsp;                            break;
&nbsp;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // Get the best target location, including the head
&nbsp;
<b class="nc">&nbsp;            refactored_damage = fitness[1];</b>
<b class="nc">&nbsp;            for (int arr_index = 0; arr_index &lt; 8; arr_index++) {</b>
<b class="nc">&nbsp;                if (fitness[arr_index] &gt; refactored_damage) {</b>
<b class="nc">&nbsp;                    refactored_damage = fitness[arr_index];</b>
<b class="nc">&nbsp;                    switch (arr_index) {</b>
&nbsp;                        case 0:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_HEAD;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2: // case 1 is CT, which was initialized as
&nbsp;                            // default
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_LT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_RT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_LARM;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_RARM;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_LLEG;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_RLEG;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            best_loc_head = Mech.LOC_CT;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Get the best target location, not including the head
<b class="nc">&nbsp;            int temp_index = 1;</b>
<b class="nc">&nbsp;            refactored_damage = fitness[1];</b>
<b class="nc">&nbsp;            for (int arr_index = 2; arr_index &lt; 8; arr_index++) {</b>
<b class="nc">&nbsp;                if (fitness[arr_index] &gt; refactored_damage) {</b>
<b class="nc">&nbsp;                    refactored_damage = fitness[arr_index];</b>
<b class="nc">&nbsp;                    temp_index = arr_index;</b>
<b class="nc">&nbsp;                    switch (arr_index) {</b>
&nbsp;                        case 2: // case 1 is CT, which was set as default
<b class="nc">&nbsp;                            best_loc = Mech.LOC_LT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            best_loc = Mech.LOC_RT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
<b class="nc">&nbsp;                            best_loc = Mech.LOC_LARM;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            best_loc = Mech.LOC_RARM;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 6:
<b class="nc">&nbsp;                            best_loc = Mech.LOC_LLEG;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            best_loc = Mech.LOC_RLEG;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            best_loc = Mech.LOC_CT;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // For all weapon attack actions
&nbsp;
<b class="nc">&nbsp;            for (EntityAction entityAction : atk_action_list) {</b>
<b class="nc">&nbsp;                aimed_attack = (WeaponAttackAction) entityAction;</b>
&nbsp;
&nbsp;                // If the target of the action is the current target
&nbsp;
<b class="nc">&nbsp;                if (aimed_attack.getTargetId() == test_target) {</b>
&nbsp;
&nbsp;                    // If the weapon aim mode is set to use a tcomp
&nbsp;
<b class="nc">&nbsp;                    if (aimed_attack.getAimingMode() == IAimingModes.AIM_MODE_TARG_COMP) {</b>
&nbsp;
&nbsp;                        // If the location is at least close to being breached
&nbsp;                        // or the target is immobile
&nbsp;
<b class="nc">&nbsp;                        if (values[temp_index] &lt;= Compute.randomInt(5)) {</b>
<b class="nc">&nbsp;                            aimed_attack.setAimedLocation(best_loc);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            aimed_attack</b>
<b class="nc">&nbsp;                                    .setAimingMode(IAimingModes.AIM_MODE_NONE);</b>
<b class="nc">&nbsp;                            aimed_attack.setAimedLocation(Entity.LOC_NONE);</b>
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    // If the weapon aim mode is set for immobile aim
&nbsp;
<b class="nc">&nbsp;                    if (aimed_attack.getAimingMode() == IAimingModes.AIM_MODE_IMMOBILE) {</b>
<b class="nc">&nbsp;                        aimed_attack.setAimedLocation(best_loc_head);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Any targets after this are secondary targets. Use secondary odds
&nbsp;            // and damage.
&nbsp;
<b class="nc">&nbsp;            is_primary_target = false;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private double getAimModifier(int target_id, int location) {
&nbsp;
&nbsp;        double loc_total;
&nbsp;
&nbsp;        // TODO: change the factor of 0.1 to float depending on critical item
&nbsp;        // type
&nbsp;
<b class="nc">&nbsp;        loc_total = 0.1 * game.getEntity(target_id).getHittableCriticals(</b>
&nbsp;                location);
&nbsp;
<b class="nc">&nbsp;        return loc_total;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void checkMoral() {
&nbsp;        // unused.
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
