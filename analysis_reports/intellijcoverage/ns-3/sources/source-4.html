


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CEntity</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot</a>
</div>

<h1>Coverage Summary for Class: CEntity (megamek.client.bot)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CEntity</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/791)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CEntity$Table</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/800)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; * This program is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU General Public License as published by the Free
&nbsp; * Software Foundation; either version 2 of the License, or (at your option)
&nbsp; * any later version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
&nbsp; * more details.
&nbsp; */
&nbsp;package megamek.client.bot;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;
&nbsp;import megamek.client.Client;
&nbsp;import megamek.client.ui.SharedUtility;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MiscType;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.weapons.gaussrifles.ISImpHGaussRifle;
&nbsp;import megamek.common.weapons.infantry.InfantryWeapon;
&nbsp;import megamek.common.weapons.lasers.VariableSpeedPulseLaserWeapon;
&nbsp;import megamek.common.weapons.ppc.ISSnubNosePPC;
&nbsp;
&nbsp;public class CEntity {
&nbsp;
&nbsp;    static class Table extends HashMap&lt;Integer, CEntity&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         *
&nbsp;         */
&nbsp;        private static final long serialVersionUID = 6437109733397107056L;
&nbsp;        private TestBot tb;
&nbsp;
<b class="nc">&nbsp;        public Table(TestBot tb) {</b>
<b class="nc">&nbsp;            this.tb = tb;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void put(CEntity es) {
<b class="nc">&nbsp;            this.put(es.getKey(), es);</b>
&nbsp;        }
&nbsp;
&nbsp;        public CEntity get(Entity es) {
<b class="nc">&nbsp;            CEntity result = null;</b>
<b class="nc">&nbsp;            if ((result = super.get(Integer.valueOf(es.getId()))) == null) {</b>
<b class="nc">&nbsp;                result = new CEntity(es, tb);</b>
<b class="nc">&nbsp;                this.put(result);</b>
&nbsp;            }
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        public CEntity get(int id) {
<b class="nc">&nbsp;            return get(Integer.valueOf(id));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Armor values based on [ToHitData.SIDE_XXX][location static int]
&nbsp;    // Locations are as defined in static variables in various unit type classes
&nbsp;    // Values are the odds (out of 1.00) of rolling that location on the to-hit
&nbsp;    // table
&nbsp;
&nbsp;    // Tank armor is either the side hit or the turret
<b class="nc">&nbsp;    static final double TANK_ARMOR[][] = { { 0, 1.0, 0, 0, 0 },</b>
&nbsp;            { 0, 0, 0, 0, 1.0 }, { 0, 0, 0, 1.0, 0 }, { 0, 0, 1.0, 0, 0 } };
<b class="nc">&nbsp;    static final double TANK_WT_ARMOR[][] = {</b>
&nbsp;            { 0, 31.0 / 36, 0, 0, 0, 5.0 / 36 },
&nbsp;            { 0, 0, 0, 0, 31.0 / 36, 5.0 / 36 },
&nbsp;            { 0, 0, 0, 31.0 / 36, 0, 5.0 / 36 },
&nbsp;            { 0, 0, 31.0 / 36, 0, 0, 5.0 / 36 } };
&nbsp;
&nbsp;    // Infantry don&#39;t have a facing. In fact, they don&#39;t have armor...
<b class="nc">&nbsp;    static final double INFANTRY_ARMOR[][] = { { 1.0 }, { 1.0 }, { 1.0 },</b>
&nbsp;            { 1.0 } };
&nbsp;
&nbsp;    // Battle armor units have multiple suits
<b class="nc">&nbsp;    static final double ISBA_ARMOR[][] = { { 0.25, 0.25, 0.25, 0.25 },</b>
&nbsp;            { 0.25, 0.25, 0.25, 0.25 }, { 0.25, 0.25, 0.25, 0.25 },
&nbsp;            { 0.25, 0.25, 0.25, 0.25 } };
<b class="nc">&nbsp;    static final double CLBA_ARMOR[][] = { { 0.2, 0.2, 0.2, 0.2, 0.2 },</b>
&nbsp;            { 0.2, 0.2, 0.2, 0.2, 0.2 }, { 0.2, 0.2, 0.2, 0.2, 0.2 },
&nbsp;            { 0.2, 0.2, 0.2, 0.2, 0.2 } };
<b class="nc">&nbsp;    static final double PROTOMECH_ARMOR[][] = {</b>
&nbsp;            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 },
&nbsp;            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 },
&nbsp;            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 },
&nbsp;            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 } };
<b class="nc">&nbsp;    static final double PROTOMECH_MG_ARMOR[][] = {</b>
&nbsp;            { 1.0 / 32, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 },
&nbsp;            { 1.0 / 31, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 },
&nbsp;            { 1.0 / 31, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 },
&nbsp;            { 1.0 / 31, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 } };
<b class="nc">&nbsp;    static final double MECH_ARMOR[][] = {</b>
&nbsp;            { 1.0 / 36, 7.0 / 36, 6.0 / 36, 6.0 / 36, 4.0 / 36, 4.0 / 36,
&nbsp;                    4.0 / 36, 4.0 / 36 },
&nbsp;            { 1.0 / 36, 7.0 / 36, 6.0 / 36, 6.0 / 36, 4.0 / 36, 4.0 / 36,
&nbsp;                    4.0 / 36, 4.0 / 36 },
&nbsp;            { 1.0 / 36, 6.0 / 36, 4.0 / 36, 7.0 / 36, 2.0 / 36, 6.0 / 36,
&nbsp;                    2.0 / 36, 8.0 / 36 },
&nbsp;            { 1.0 / 36, 6.0 / 36, 7.0 / 36, 4.0 / 36, 6.0 / 36, 2.0 / 36,
&nbsp;                    8.0 / 36, 2.0 / 36 } };
<b class="nc">&nbsp;    static final double GUN_EMPLACEMENT_ARMOR[][] = { { 1.0 / 4, 0, 0, 0 },</b>
&nbsp;            { 1.0 / 4, 0, 0, 0 }, { 1.0 / 4, 0, 0, 0 }, { 1.0 / 4, 0, 0, 0 } };
<b class="nc">&nbsp;    static final double GUN_EMPLACEMENT_TURRET_ARMOR[][] = {</b>
&nbsp;            { 1.0 / 3, 0, 0, 0, 5.0 / 36 }, { 1.0 / 3, 0, 0, 0, 5.0 / 36 },
&nbsp;            { 1.0 / 3, 0, 0, 0, 5.0 / 36 }, { 1.0 / 3, 0, 0, 0, 5.0 / 36 } };
&nbsp;
&nbsp;    public static final int MAX_RANGE = 36; // Updated to reflect longer ranges
&nbsp;    // of level 2 equipment
&nbsp;    public static final int MIN_BRACKET = 6;
&nbsp;
&nbsp;    public static final int OVERHEAT_NONE = 0;
&nbsp;    public static final int OVERHEAT_LOW = 1;
&nbsp;    public static final int OVERHEAT_HIGH = 2;
&nbsp;
&nbsp;    public static final int RANGE_SHORT = 0;
&nbsp;    public static final int RANGE_MEDIUM = 1;
&nbsp;    public static final int RANGE_LONG = 2;
&nbsp;    public static final int RANGE_ALL = 3;
&nbsp;
&nbsp;    public static final int FIRST_ARC = 0;
&nbsp;    public static final int LAST_PRIMARY_ARC = 3;
&nbsp;    public static final int LAST_ARC = 5;
&nbsp;
&nbsp;    public static final int TT = 4;
&nbsp;
&nbsp;    public static final int LEFT_LEG = 0;
&nbsp;    public static final int RIGHT_LEG = 1;
&nbsp;
&nbsp;    // Weighted averages of the cluster hits table. Note the actual
&nbsp;    // table does skip entries from 31 through 39.
<b class="nc">&nbsp;    private static final double[] hits_by_racksize = { 0.0, 1.0, 1.58, 2.0,</b>
&nbsp;            2.63, 3.17, 4.0, 4.49, 4.98, 5.47, 6.31, 7.23, 8.14, 8.59, 9.04,
&nbsp;            9.5, 10.1, 10.8, 11.42, 12.1, 12.7, 13.6, 14.4, 15.7, 16.3, 16.6,
&nbsp;            17.4, 17.6, 17.9, 18.7, 19.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25.4 };
&nbsp;
&nbsp;    Entity entity;
&nbsp;    MoveOption current;
&nbsp;    MoveOption last; // set only after movement
&nbsp;
&nbsp;    private MoveOption.Table moves;
<b class="nc">&nbsp;    MoveOption.Table pass = new MoveOption.Table();</b>
&nbsp;    public int runMP;
&nbsp;    public int jumpMP;
&nbsp;    // For MASC/supercharger useage. Set to true if failure is bad.
<b class="nc">&nbsp;    public boolean masc_threat = false;</b>
&nbsp;
<b class="nc">&nbsp;    boolean isPhysicalTarget = false;</b>
&nbsp;
&nbsp;    // Current heat status of the unit
<b class="nc">&nbsp;    int overheat = OVERHEAT_NONE;</b>
&nbsp;    // Weapons heat for ideal range bracket
<b class="nc">&nbsp;    int heat_at_range = 0;</b>
&nbsp;    // Heat for each range bracket
<b class="nc">&nbsp;    int heat_estimates[] = new int[4];</b>
&nbsp;
&nbsp;    // Index of the ideal engagement range from range_damages
<b class="nc">&nbsp;    int range = RANGE_ALL;</b>
<b class="nc">&nbsp;    int long_range = 0;</b>
&nbsp;    // Damage at short/medium/long/all(?) ranges
<b class="nc">&nbsp;    double range_damages[] = new double[4];</b>
<b class="nc">&nbsp;    int rd_bracket = 0;</b>
&nbsp;
<b class="nc">&nbsp;    double base_psr_odds = 1.0;</b>
&nbsp;
<b class="nc">&nbsp;    boolean hasTakenDamage = false;</b>
<b class="nc">&nbsp;    public Strategy strategy = new Strategy();</b>
&nbsp;
&nbsp;    // A subjective measure of the armor quality indexed by ToHitData
&nbsp;    // location static variables (front, rear, left, right)
<b class="nc">&nbsp;    double[] armor_health = { 0, 0, 0, 0, 0, 0, 0, 0 };</b>
<b class="nc">&nbsp;    double[] armor_percent = { 0, 0, 0, 0, 0, 0, 0, 0 };</b>
&nbsp;    // Armor averaged over all locations
&nbsp;    // TODO: replace with array, one element per arc
<b class="nc">&nbsp;    double avg_armor = 0;</b>
&nbsp;    // Average internal structure
&nbsp;    // TODO: replace with array, one element per arc
<b class="nc">&nbsp;    double avg_iarmor = 0;</b>
&nbsp;
&nbsp;    // used to determine the utility of combining attacks
<b class="nc">&nbsp;    double[] expected_damage = { 0, 0, 0, 0, 0, 0, 0, 0 };</b>
<b class="nc">&nbsp;    double[] possible_damage = { 0, 0, 0, 0, 0, 0, 0, 0 };</b>
&nbsp;
<b class="nc">&nbsp;    double[] leg_health = { 0, 0 };</b>
&nbsp;
<b class="nc">&nbsp;    double overall_armor_percent = 0.0;</b>
<b class="nc">&nbsp;    double[][] damages = new double[6][MAX_RANGE];</b>
&nbsp;
&nbsp;    // the battle value of the unit
&nbsp;    int bv;
&nbsp;
&nbsp;    // relative position in the enemy array
&nbsp;    int enemy_num;
&nbsp;
&nbsp;    private TestBot tb;
&nbsp;
<b class="nc">&nbsp;    boolean engaged = false; // am i fighting</b>
<b class="nc">&nbsp;    boolean moved = false;</b>
<b class="nc">&nbsp;    boolean justMoved = false;</b>
&nbsp;
&nbsp;    // TSM equipped Mechs work better at 9+ heat, so flag if mounted
<b class="nc">&nbsp;    boolean tsm_offset = false;</b>
&nbsp;
<b class="nc">&nbsp;    int[] minRangeMods = new int[MIN_BRACKET + 1];</b>
&nbsp;
<b class="nc">&nbsp;    public CEntity(Entity en, TestBot tb) {</b>
<b class="nc">&nbsp;        entity = en;</b>
<b class="nc">&nbsp;        this.tb = tb;</b>
<b class="nc">&nbsp;        reset();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Entity getEntity() {
<b class="nc">&nbsp;        return entity;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean canMove() {
<b class="nc">&nbsp;        return (entity.isSelectableThisTurn()</b>
<b class="nc">&nbsp;                &amp;&amp; !(entity.isProne() &amp;&amp; (base_psr_odds &lt; .2)) &amp;&amp; !entity</b>
<b class="nc">&nbsp;                    .isImmobile());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean justMoved() {
<b class="nc">&nbsp;        return (!moved &amp;&amp; !entity.isSelectableThisTurn()) || justMoved;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void reset() {
<b class="nc">&nbsp;        entity = tb.getGame().getEntity(entity.getId()); // fresh entity</b>
<b class="nc">&nbsp;        for (int a = FIRST_ARC; a &lt;= LAST_ARC; a++) {</b>
<b class="nc">&nbsp;            Arrays.fill(damages[a], 0);</b>
&nbsp;        }
<b class="nc">&nbsp;        characterize();</b>
<b class="nc">&nbsp;        resetPossibleDamage();</b>
<b class="nc">&nbsp;        moves = null;</b>
<b class="nc">&nbsp;        hasTakenDamage = false;</b>
<b class="nc">&nbsp;        Arrays.fill(expected_damage, 0);</b>
<b class="nc">&nbsp;        engaged = false;</b>
<b class="nc">&nbsp;        moved = false;</b>
<b class="nc">&nbsp;        isPhysicalTarget = false;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void refresh() {
<b class="nc">&nbsp;        entity = tb.getGame().getEntity(entity.getId());</b>
<b class="nc">&nbsp;        if (justMoved()) {</b>
<b class="nc">&nbsp;            for (int a = FIRST_ARC; a &lt;= LAST_ARC; a++) {</b>
<b class="nc">&nbsp;                Arrays.fill(damages[a], 0);</b>
&nbsp;            }
<b class="nc">&nbsp;            characterize();</b>
<b class="nc">&nbsp;            resetPossibleDamage();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void resetPossibleDamage() {
<b class="nc">&nbsp;        Arrays.fill(possible_damage, 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Simplifies the many game stats into something that can be quickly
&nbsp;     * calculated into a units combat effectiveness. The concept is similar to
&nbsp;     * creating BattleForce stats.
&nbsp;     */
&nbsp;
&nbsp;    public void characterize() {
<b class="nc">&nbsp;        entity = tb.getGame().getEntity(entity.getId());</b>
<b class="nc">&nbsp;        current = new MoveOption(tb.getGame(), this);</b>
<b class="nc">&nbsp;        bv = entity.calculateBattleValue();</b>
&nbsp;
&nbsp;        // Make a guess as to whether MASC should be turned on or off
&nbsp;        // TODO: Link this to a Bot configuration file
<b class="nc">&nbsp;        runMP = entity.getRunMP();</b>
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            if (((Mech) entity).hasMASC()) {</b>
<b class="nc">&nbsp;                if (((Mech) entity).getMASCTarget() &lt;= (5 + Compute.randomInt(6))) {</b>
<b class="nc">&nbsp;                    masc_threat = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    masc_threat = true;</b>
<b class="nc">&nbsp;                    runMP = entity.getRunMPwithoutMASC();</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;
&nbsp;                // If this is a Mech equipped with TSM, push for the sweet
&nbsp;                // spot at 9 heat
<b class="nc">&nbsp;                if (((Mech) entity).hasTSM()) {</b>
<b class="nc">&nbsp;                    tsm_offset = true;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        jumpMP = entity.getJumpMP();</b>
&nbsp;
<b class="nc">&nbsp;        overall_armor_percent = entity.getArmorRemainingPercent();</b>
<b class="nc">&nbsp;        base_psr_odds = Compute.oddsAbove(entity.getBasePilotingRoll()</b>
<b class="nc">&nbsp;                .getValue(), entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING)) / 100;</b>
&nbsp;
&nbsp;        // Heat characterisation - how badly will a Mech overheat this round
<b class="nc">&nbsp;        int heat_capacity = entity.getHeatCapacity();</b>
<b class="nc">&nbsp;        int heat = entity.heat;</b>
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
&nbsp;
&nbsp;            // Include heat from active stealth armor systems
<b class="nc">&nbsp;            if (entity.isStealthActive() || entity.isNullSigActive()</b>
<b class="nc">&nbsp;                    || entity.isVoidSigActive()) {</b>
<b class="nc">&nbsp;                heat += 10;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.isChameleonShieldActive()) {</b>
<b class="nc">&nbsp;                heat += 6;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Infernos no longer track heat over multiple rounds
&nbsp;
&nbsp;            // Include heat from engine hits
<b class="nc">&nbsp;            heat += entity.getEngineCritHeat();</b>
&nbsp;
&nbsp;            // Include heat for standing in a fire
<b class="nc">&nbsp;            if (entity.getPosition() != null) {</b>
<b class="nc">&nbsp;                if (tb.getGame().getBoard().getHex(entity.getPosition()) != null) {</b>
<b class="nc">&nbsp;                    if (tb.getGame().getBoard().getHex(entity.getPosition())</b>
<b class="nc">&nbsp;                            .containsTerrain(Terrains.FIRE)</b>
<b class="nc">&nbsp;                            &amp;&amp; (tb.getGame().getBoard().getHex(entity.getPosition())</b>
<b class="nc">&nbsp;                                    .getFireTurn() &gt; 0)) {</b>
<b class="nc">&nbsp;                        heat += 5;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Include heat from ambient temperature
<b class="nc">&nbsp;            heat += tb.getGame().getPlanetaryConditions().getTemperatureDifference(</b>
&nbsp;                    50, -30);
&nbsp;        }
&nbsp;
&nbsp;        // Offensive characterisation - damage potentials
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Mounted&gt; ammo_list = entity.getAmmo();</b>
&nbsp;
<b class="nc">&nbsp;        double overall_damage[][] = new double[6][MAX_RANGE];</b>
<b class="nc">&nbsp;        double cur_weapon_damage[] = new double[MAX_RANGE];</b>
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Integer&gt; cur_weapon_arcs = new ArrayList&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        int overall_heat[][] = new int[6][MAX_RANGE];</b>
<b class="nc">&nbsp;        int cur_weapon_heat, weapons_count = 0;</b>
&nbsp;        int cur_weapon_arc;
&nbsp;
&nbsp;        // Mainly for BA and conventional infantry support
<b class="nc">&nbsp;        int number_of_shooters = 1;</b>
&nbsp;
<b class="nc">&nbsp;        boolean ammo_ranges[] = { false, false, false };</b>
&nbsp;
<b class="nc">&nbsp;        int gunnery = entity.getCrew().getGunnery();</b>
<b class="nc">&nbsp;        if (entity.getTaserFeedBackRounds() &gt; 0) {</b>
<b class="nc">&nbsp;            gunnery += 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Most units, including BA, are equipped with conventional weapons
<b class="nc">&nbsp;        if (!(entity instanceof Infantry) || (entity instanceof BattleArmor)) {</b>
&nbsp;
<b class="nc">&nbsp;            if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                number_of_shooters = ((BattleArmor) entity)</b>
<b class="nc">&nbsp;                        .getShootingStrength();</b>
&nbsp;            }
&nbsp;
&nbsp;            // Physical attacks - punch and/or kicking for Mechs
<b class="nc">&nbsp;            if (entity instanceof Mech) {</b>
&nbsp;
&nbsp;                // Base damage, adjusted for odds of hitting
<b class="nc">&nbsp;                cur_weapon_damage[1] = (tsm_offset ? 1.0 : 0.5)</b>
<b class="nc">&nbsp;                        * (entity.getWeight() / 10)</b>
<b class="nc">&nbsp;                        * (Compute.oddsAbove(entity.getCrew().getPiloting(),</b>
<b class="nc">&nbsp;                                             entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING)) / 100);</b>
&nbsp;
&nbsp;                // Either a kick or double-punch to the front
<b class="nc">&nbsp;                overall_damage[Compute.ARC_FORWARD][1] = 2.0 * cur_weapon_damage[1];</b>
&nbsp;
&nbsp;                // If the Mech can flip arms, don&#39;t consider arm arcs
<b class="nc">&nbsp;                if (!((Mech) entity).canFlipArms()) {</b>
<b class="nc">&nbsp;                    overall_damage[Compute.ARC_LEFTARM][1] = cur_weapon_damage[1];</b>
<b class="nc">&nbsp;                    overall_damage[Compute.ARC_RIGHTARM][1] = cur_weapon_damage[1];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Physical attacks - vibroclaws for BA
<b class="nc">&nbsp;            if (entity instanceof BattleArmor) {</b>
&nbsp;
<b class="nc">&nbsp;                overall_damage[Compute.ARC_360][0] = (hits_by_racksize[number_of_shooters]</b>
<b class="nc">&nbsp;                        * ((BattleArmor) entity).getVibroClaws()</b>
<b class="nc">&nbsp;                        * Compute.oddsAbove(gunnery,</b>
<b class="nc">&nbsp;                                            entity.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))) / 100.0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Iterate over each weapon, calculating average damage
&nbsp;            // for each weapon, over each hex of range
<b class="nc">&nbsp;            for (Mounted cur_weapon : entity.getWeaponList()) {</b>
&nbsp;
<b class="nc">&nbsp;                WeaponType weapon = (WeaponType) cur_weapon.getType();</b>
<b class="nc">&nbsp;                int cur_weapon_id = entity.getEquipmentNum(cur_weapon);</b>
&nbsp;
&nbsp;                // Don&#39;t count weapons that are destroyed/jammed or are out
&nbsp;                // of ammo
<b class="nc">&nbsp;                if (!cur_weapon.canFire()</b>
<b class="nc">&nbsp;                        || cur_weapon.isJammed()</b>
<b class="nc">&nbsp;                        || ((cur_weapon.getLinked() == null) &amp;&amp; (weapon</b>
<b class="nc">&nbsp;                                .getAmmoType() != AmmoType.T_NA))) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Anti-Mech attacks are difficult to set up and have bad
&nbsp;                // odds most of the time. This means they have little
&nbsp;                // strategic impact.
<b class="nc">&nbsp;                if (weapon.getInternalName().equals(Infantry.SWARM_MEK)</b>
<b class="nc">&nbsp;                        || weapon.getInternalName().equals(Infantry.LEG_ATTACK)</b>
<b class="nc">&nbsp;                        || weapon.getInternalName().equals(Infantry.SWARM_MEK)</b>
<b class="nc">&nbsp;                        || weapon.getInternalName().equals(Infantry.STOP_SWARM)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Get basic stats for the current weapon
<b class="nc">&nbsp;                cur_weapon_arc = entity.getWeaponArc(cur_weapon_id);</b>
<b class="nc">&nbsp;                cur_weapon_arcs = getWeaponArcs(cur_weapon_arc,</b>
<b class="nc">&nbsp;                        entity.isSecondaryArcWeapon(cur_weapon_id));</b>
<b class="nc">&nbsp;                cur_weapon_heat = cur_weapon.getCurrentHeat();</b>
&nbsp;
&nbsp;                // Get the damage the weapon will do at each range bracket.
&nbsp;                // This includes average cluster hits but not to-hit averages.
<b class="nc">&nbsp;                ammo_ranges = getAmmoRanges(weapon, ammo_list);</b>
<b class="nc">&nbsp;                cur_weapon_damage = getRawDamage(cur_weapon, ammo_ranges);</b>
&nbsp;
<b class="nc">&nbsp;                boolean aptGunnery = entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING);</b>
&nbsp;
&nbsp;                // Apply to-hit modifiers to the damage values
<b class="nc">&nbsp;                cur_weapon_damage = getExpectedDamage(weapon, gunnery,</b>
&nbsp;                                                      cur_weapon_damage, ammo_ranges, aptGunnery);
&nbsp;
&nbsp;                // If the heat generated by the weapon is a significant
&nbsp;                // portion of the Mechs remaining heatsink capacity, it needs
&nbsp;                // to do some significant damage before being counted. Under
&nbsp;                // most circumstances this will only happen if the Mech is
&nbsp;                // seriously overheating.
&nbsp;
<b class="nc">&nbsp;                if (entity instanceof Mech) {</b>
&nbsp;
<b class="nc">&nbsp;                    int overheat = (cur_weapon_heat + heat)</b>
<b class="nc">&nbsp;                            - (heat_capacity + (tsm_offset ? 9 : 4));</b>
<b class="nc">&nbsp;                    if (overheat &gt; 0) {</b>
&nbsp;
<b class="nc">&nbsp;                        for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</b>
<b class="nc">&nbsp;                            if (cur_weapon_damage[i] &lt; overheat) {</b>
<b class="nc">&nbsp;                                cur_weapon_damage[i] = 0.0;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                // Only BA can fire into their own hex
<b class="nc">&nbsp;                if (!(entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    cur_weapon_damage[0] = 0.0;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Increment the total weapons count if the weapon was
&nbsp;                // allocated to the forward arc. No point counting weapons
&nbsp;                // that don&#39;t get used much.
<b class="nc">&nbsp;                if (cur_weapon_arcs.contains(Compute.ARC_FORWARD)) {</b>
<b class="nc">&nbsp;                    weapons_count++;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int weapon_min_range = weapon.getMinimumRange();</b>
&nbsp;
&nbsp;                // Add the final damage and heat values into the overall damage
&nbsp;                // array for the appropriate arcs
<b class="nc">&nbsp;                for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</b>
&nbsp;
&nbsp;                    // Skip any range where no damage is done
<b class="nc">&nbsp;                    if (cur_weapon_damage[i] == 0.0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Adjust weapon damage by the number of shooters. This
&nbsp;                    // normally applies only to Battle Armor.
<b class="nc">&nbsp;                    if (number_of_shooters &gt; 1) {</b>
<b class="nc">&nbsp;                        cur_weapon_damage[i] *= hits_by_racksize[number_of_shooters];</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    for (int firing_arc : cur_weapon_arcs) {</b>
&nbsp;
&nbsp;                        // Some error control to catch non-standard arcs
<b class="nc">&nbsp;                        if (firing_arc &gt; LAST_ARC) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        overall_damage[firing_arc][i] += cur_weapon_damage[i];</b>
&nbsp;
&nbsp;                        // Only Mechs need track heat. The heat values will
&nbsp;                        // be used to derate damage at each hex of range.
<b class="nc">&nbsp;                        if ((entity instanceof Mech)</b>
&nbsp;                                &amp;&amp; (overall_damage[firing_arc][i] &gt; 0)) {
<b class="nc">&nbsp;                            overall_heat[firing_arc][i] += cur_weapon_heat;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        // Track minimum range modifiers for weapons that
&nbsp;                        // fire into the forward arc
<b class="nc">&nbsp;                        if ((firing_arc == Compute.ARC_FORWARD)</b>
&nbsp;                                &amp;&amp; (i &lt;= weapon_min_range)
&nbsp;                                &amp;&amp; (i &lt; minRangeMods.length)) {
<b class="nc">&nbsp;                            minRangeMods[i] += (1 + weapon_min_range) - i;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                // Next weapon
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        } else {
&nbsp;
&nbsp;            // Conventional infantry use infantry weapons, which require
&nbsp;            // special handling
&nbsp;
<b class="nc">&nbsp;            number_of_shooters = ((Infantry) entity).getShootingStrength();</b>
&nbsp;
<b class="nc">&nbsp;            cur_weapon_damage = getExpectedDamage((Infantry) entity, gunnery);</b>
&nbsp;
&nbsp;            // Add the current damage values into the overall damage array for
&nbsp;            // the 360 degree arc. Adjust for number of troopers hitting.
<b class="nc">&nbsp;            for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</b>
<b class="nc">&nbsp;                overall_damage[Compute.ARC_360][i] += cur_weapon_damage[i];</b>
<b class="nc">&nbsp;                overall_damage[Compute.ARC_360][i] *= hits_by_racksize[number_of_shooters];</b>
&nbsp;            }
&nbsp;
&nbsp;            // Check for field guns
<b class="nc">&nbsp;            for (Mounted cur_weapon : entity.getWeaponList()) {</b>
&nbsp;
<b class="nc">&nbsp;                WeaponType weapon = (WeaponType) cur_weapon.getType();</b>
&nbsp;
<b class="nc">&nbsp;                if (cur_weapon.getLocation() != Infantry.LOC_FIELD_GUNS) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Don&#39;t count weapons that are destroyed/jammed or are out
&nbsp;                // of ammo
<b class="nc">&nbsp;                if (!cur_weapon.canFire()</b>
<b class="nc">&nbsp;                        || cur_weapon.isJammed()</b>
<b class="nc">&nbsp;                        || ((cur_weapon.getLinked() == null) &amp;&amp; (weapon</b>
<b class="nc">&nbsp;                                .getAmmoType() != AmmoType.T_NA))) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                boolean aptGunnery = entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING);</b>
&nbsp;
<b class="nc">&nbsp;                cur_weapon_damage = CEntity.getRawDamage(cur_weapon, null);</b>
<b class="nc">&nbsp;                cur_weapon_damage = CEntity.getExpectedDamage(weapon, gunnery,</b>
&nbsp;                                                              cur_weapon_damage, ammo_ranges, aptGunnery);
&nbsp;
&nbsp;                // Push the field gun damages into the overall damage array
<b class="nc">&nbsp;                for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</b>
&nbsp;
&nbsp;                    // Skip 0-damage entries
<b class="nc">&nbsp;                    if (cur_weapon_damage[i] == 0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    overall_damage[Compute.ARC_360][i] += cur_weapon_damage[i];</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Copy the total damage into each arc
<b class="nc">&nbsp;            for (int cur_arc = FIRST_ARC + 1; cur_arc &lt;= LAST_ARC; cur_arc++) {</b>
<b class="nc">&nbsp;                overall_damage[cur_arc] = overall_damage[Compute.ARC_360];</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // Push the accumulated damages into the CEntity array
<b class="nc">&nbsp;        for (int cur_arc = FIRST_ARC; cur_arc &lt;= LAST_ARC; cur_arc++) {</b>
&nbsp;
&nbsp;            // For each hex
<b class="nc">&nbsp;            for (int cur_range = 0; cur_range &lt; MAX_RANGE; cur_range++) {</b>
&nbsp;
&nbsp;                // If no damage, then skip the calculations
<b class="nc">&nbsp;                if (overall_damage[cur_arc][cur_range] == 0.0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If the weapons heat and the miscellaneous heat is more than
&nbsp;                // the Mech can sink, lower the damage proportionally e.g.
&nbsp;                // (sink capacity + buffer) / (weapon heat + base heat)
<b class="nc">&nbsp;                if ((entity instanceof Mech)</b>
&nbsp;                        &amp;&amp; ((overall_heat[cur_arc][cur_range] + heat) &gt; (heat_capacity
<b class="nc">&nbsp;                                + (tsm_offset ? 9 : 4)))) {</b>
<b class="nc">&nbsp;                    overall_damage[cur_arc][cur_range] *= (heat_capacity + (tsm_offset ? 9</b>
<b class="nc">&nbsp;                            : 4));</b>
<b class="nc">&nbsp;                    overall_damage[cur_arc][cur_range] /= (overall_heat[cur_arc][cur_range] + heat);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                damages[cur_arc][cur_range] = overall_damage[cur_arc][cur_range];</b>
&nbsp;
&nbsp;                // Next hex
&nbsp;            }
&nbsp;
&nbsp;            // Next arc
&nbsp;        }
&nbsp;
&nbsp;        // Average out the minimum range modifiers
<b class="nc">&nbsp;        for (int cur_range = 1; cur_range &lt; minRangeMods.length; cur_range++) {</b>
<b class="nc">&nbsp;            if (weapons_count &gt; 0) {</b>
<b class="nc">&nbsp;                minRangeMods[cur_range] = (int) Math</b>
<b class="nc">&nbsp;                        .round(((double) minRangeMods[cur_range])</b>
&nbsp;                                / (double) weapons_count);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Change the damage from a per-hex array to a single &quot;weapon&quot;
&nbsp;        // with short/medium/long ranges. For now, just do the forward
&nbsp;        // arc.
<b class="nc">&nbsp;        computeRange(Compute.ARC_FORWARD, overall_heat);</b>
&nbsp;
&nbsp;        // Overheating will be based on the optimum firing range
<b class="nc">&nbsp;        heat = (heat + heat_at_range) - heat_capacity;</b>
&nbsp;
<b class="nc">&nbsp;        if (heat &lt;= 4) {</b>
<b class="nc">&nbsp;            overheat = OVERHEAT_NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (heat &gt; 4) {</b>
<b class="nc">&nbsp;            overheat = OVERHEAT_LOW;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((heat &gt; 9) &amp; !tsm_offset) {</b>
<b class="nc">&nbsp;            overheat = OVERHEAT_HIGH;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((heat &gt; 12) &amp; tsm_offset) {</b>
<b class="nc">&nbsp;            overheat = OVERHEAT_HIGH;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Defensive characterization - protection values
&nbsp;
<b class="nc">&nbsp;        double max = 1.0;</b>
&nbsp;
&nbsp;        // Initialize armor values
<b class="nc">&nbsp;        double armor[][] = MECH_ARMOR;</b>
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            if (((Tank) entity).hasNoTurret()) {</b>
<b class="nc">&nbsp;                armor = TANK_ARMOR;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                armor = TANK_WT_ARMOR;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            if (!(entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                armor = INFANTRY_ARMOR;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (entity.isClan()) {</b>
<b class="nc">&nbsp;                    armor = CLBA_ARMOR;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    armor = ISBA_ARMOR;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;            if (((Protomech) entity).hasMainGun()) {</b>
<b class="nc">&nbsp;                armor = PROTOMECH_MG_ARMOR;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                armor = PROTOMECH_ARMOR;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof GunEmplacement) {</b>
<b class="nc">&nbsp;            armor = ((GunEmplacement) entity).isTurret() ? GUN_EMPLACEMENT_TURRET_ARMOR</b>
<b class="nc">&nbsp;                    : GUN_EMPLACEMENT_ARMOR;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Arcs for the outside loop are those used for incoming damage:
&nbsp;        // front, rear, left, right as per static variables in ToHitData
<b class="nc">&nbsp;        for (int arc = FIRST_ARC; arc &lt;= LAST_PRIMARY_ARC; arc++) {</b>
<b class="nc">&nbsp;            armor_health[arc] = 0.0;</b>
&nbsp;            // &quot;i&quot; is a location index. It matches the location static variables
&nbsp;            // for each sub-entity type (Mech, Tank, etc)
<b class="nc">&nbsp;            for (int i = 0; i &lt; armor[arc].length; i++) {</b>
<b class="nc">&nbsp;                armor_health[arc] += armor[arc][i]</b>
<b class="nc">&nbsp;                        * getArmorValue(i, arc == ToHitData.SIDE_REAR);</b>
&nbsp;            }
&nbsp;
&nbsp;            // ProtoMechs have a &quot;near miss&quot; location that isn&#39;t accounted for
&nbsp;            // in
&nbsp;            // the hit-table-probability array. Rolling 3 or 11 on 2d6 is 4/36.
&nbsp;
<b class="nc">&nbsp;            if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                armor_health[arc] *= 1.22;</b>
&nbsp;            }
<b class="nc">&nbsp;            max = Math.max(armor_health[arc], max);</b>
<b class="nc">&nbsp;            armor_percent[arc] = armor_health[arc] / max;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Calculate an average armor value for the entire entity
&nbsp;        // TODO: Change to array, with an entry for each arc
<b class="nc">&nbsp;        avg_armor = (armor_health[0] + armor_health[1] + armor_health[2] + armor_health[3]) / 4;</b>
&nbsp;
&nbsp;        // Calculate average internal structure across the unit
&nbsp;        // Default to Mech unit, which has 7 locations plus the head (ignored
&nbsp;        // due to low
&nbsp;        // hit probability and low standard IS)
<b class="nc">&nbsp;        avg_iarmor = entity.getTotalInternal() / 7.0;</b>
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            avg_iarmor = entity instanceof BattleArmor ? ((BattleArmor) entity)</b>
<b class="nc">&nbsp;                    .getShootingStrength() : 1.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            avg_iarmor = entity.getTotalInternal()</b>
<b class="nc">&nbsp;                    / (((Tank) entity).hasNoTurret() ? 4.0 : 5.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;            avg_iarmor = entity.getTotalInternal()</b>
<b class="nc">&nbsp;                    / (((Protomech) entity).hasMainGun() ? 5.0 : 6.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof GunEmplacement) {</b>
<b class="nc">&nbsp;            avg_iarmor = 1.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Weapons mounted in one arc can be applied over several depending on the
&nbsp;     * type of unit due to torso or turret twisting
&nbsp;     *
&nbsp;     * @param mounted_arc
&nbsp;     *            arc for weapon
&nbsp;     * @param is_secondary
&nbsp;     *            true if weapon can fire into another arc
&nbsp;     * @return ArrayList of Compute.ARC_XXX integers
&nbsp;     */
&nbsp;    private ArrayList&lt;Integer&gt; getWeaponArcs(int mounted_arc,
&nbsp;            boolean is_secondary) {
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Integer&gt; arc_list = new ArrayList&lt;Integer&gt;(1);</b>
&nbsp;
&nbsp;        // Weapons which can fire in any direction
<b class="nc">&nbsp;        if ((mounted_arc == Compute.ARC_360)</b>
&nbsp;                || (mounted_arc == Compute.ARC_MAINGUN)
&nbsp;                || (mounted_arc == Compute.ARC_TURRET)) {
<b class="nc">&nbsp;            for (int i = FIRST_ARC; i &lt;= LAST_ARC; i++) {</b>
<b class="nc">&nbsp;                arc_list.add(i);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;
<b class="nc">&nbsp;            arc_list.add(mounted_arc);</b>
&nbsp;
&nbsp;            // If the weapon can be applied to a secondary arc, add it there
&nbsp;            // as well
<b class="nc">&nbsp;            if (is_secondary) {</b>
&nbsp;
<b class="nc">&nbsp;                if (mounted_arc == Compute.ARC_FORWARD) {</b>
&nbsp;
&nbsp;                    // Mech torso twist
<b class="nc">&nbsp;                    arc_list.add(Compute.ARC_LEFTARM);</b>
<b class="nc">&nbsp;                    arc_list.add(Compute.ARC_RIGHTARM);</b>
&nbsp;
&nbsp;                    // Vehicle turrets
<b class="nc">&nbsp;                    if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                        arc_list.add(Compute.ARC_360);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                // Left arm fires into the front and left side,
&nbsp;                // right arm to the front and right. If the arms
&nbsp;                // can flip, they both go to the rear as well.
<b class="nc">&nbsp;                if ((mounted_arc == Compute.ARC_LEFTARM)</b>
&nbsp;                        || (mounted_arc == Compute.ARC_RIGHTARM)) {
&nbsp;
<b class="nc">&nbsp;                    arc_list.add(Compute.ARC_FORWARD);</b>
<b class="nc">&nbsp;                    if ((entity instanceof Mech) &amp;&amp; entity.canFlipArms()) {</b>
<b class="nc">&nbsp;                        arc_list.add(Compute.ARC_REAR);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return arc_list;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fills the CEntity damage and range brackets, plus the preferred range and
&nbsp;     * the heat for that range.
&nbsp;     *
&nbsp;     * @param arc
&nbsp;     *            Compute.ARC index for main damage array
&nbsp;     * @param est_heat
&nbsp;     *            Estimated heat of unit for each hex of range
&nbsp;     */
&nbsp;    private void computeRange(int arc, int[][] est_heat) {
&nbsp;
<b class="nc">&nbsp;        double damage_by_bracket[] = { 0.0, 0.0, 0.0, 0.0 };</b>
<b class="nc">&nbsp;        double heat_by_bracket[] = { 0, 0, 0, 0 };</b>
&nbsp;
<b class="nc">&nbsp;        long_range = MAX_RANGE - 1;</b>
&nbsp;        int bracket_start, bracket_end;
&nbsp;
&nbsp;        // Get the longest range and use it to calculate an average range
&nbsp;        // bracket. Extreme range is used when estimating damage but only
&nbsp;        // the official &quot;long&quot; range is kept.
&nbsp;        // TODO: add some math to account for non-linear brackets
<b class="nc">&nbsp;        while ((damages[arc][long_range] == 0.0) &amp;&amp; (long_range &gt;= 4)) {</b>
<b class="nc">&nbsp;            long_range--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        rd_bracket = long_range / 4;</b>
<b class="nc">&nbsp;        long_range = 3 * rd_bracket;</b>
<b class="nc">&nbsp;        bracket_start = 0;</b>
<b class="nc">&nbsp;        bracket_end = rd_bracket;</b>
&nbsp;
&nbsp;        // For each range bracket
<b class="nc">&nbsp;        for (int cur_bracket = RANGE_SHORT; cur_bracket &lt;= RANGE_LONG; cur_bracket++) {</b>
&nbsp;
&nbsp;            // Get the start and end ranges. Allocate any leftover hexes to
&nbsp;            // to the end of the long range bracket.
<b class="nc">&nbsp;            switch (cur_bracket) {</b>
&nbsp;                case RANGE_SHORT:
<b class="nc">&nbsp;                    bracket_start = (entity instanceof Infantry ? 0 : 1);</b>
<b class="nc">&nbsp;                    bracket_end = rd_bracket;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case RANGE_MEDIUM:
<b class="nc">&nbsp;                    bracket_start = rd_bracket + 1;</b>
<b class="nc">&nbsp;                    bracket_end = 2 * rd_bracket;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case RANGE_LONG:
<b class="nc">&nbsp;                    bracket_start = (2 * rd_bracket) + 1;</b>
<b class="nc">&nbsp;                    bracket_end = Math.min(long_range, MAX_RANGE - 1);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;
&nbsp;            // For each hex in the current bracket
<b class="nc">&nbsp;            for (int cur_range = bracket_start; cur_range &lt;= bracket_end; cur_range++) {</b>
&nbsp;
&nbsp;                // Add up the damage and heat estimates
<b class="nc">&nbsp;                damage_by_bracket[cur_bracket] += damages[arc][cur_range];</b>
<b class="nc">&nbsp;                damage_by_bracket[RANGE_ALL] += damages[arc][cur_range];</b>
&nbsp;
<b class="nc">&nbsp;                heat_by_bracket[cur_bracket] += est_heat[arc][cur_range];</b>
<b class="nc">&nbsp;                heat_by_bracket[RANGE_ALL] += est_heat[arc][cur_range];</b>
&nbsp;
&nbsp;                // Next hex
&nbsp;            }
&nbsp;
&nbsp;            // Next range bracket
&nbsp;        }
&nbsp;
&nbsp;        // Average out the damage and heat value totals over the number of
&nbsp;        // hexes for the range bracket
<b class="nc">&nbsp;        for (int cur_range = RANGE_SHORT; cur_range &lt;= RANGE_LONG; cur_range++) {</b>
<b class="nc">&nbsp;            if ((damages[arc][0] != 0.0) &amp;&amp; (cur_range == RANGE_SHORT)) {</b>
<b class="nc">&nbsp;                damage_by_bracket[cur_range] /= (rd_bracket + 1);</b>
<b class="nc">&nbsp;                heat_by_bracket[cur_range] /= (rd_bracket + 1);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                damage_by_bracket[cur_range] /= rd_bracket;</b>
<b class="nc">&nbsp;                heat_by_bracket[cur_range] /= rd_bracket;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        damage_by_bracket[RANGE_ALL] /= long_range;</b>
<b class="nc">&nbsp;        heat_by_bracket[RANGE_ALL] /= long_range;</b>
&nbsp;
&nbsp;        // Push the average damage and heat values to the CEntity arrays
<b class="nc">&nbsp;        range_damages = damage_by_bracket;</b>
<b class="nc">&nbsp;        for (int cur_bracket = RANGE_SHORT; cur_bracket &lt;= RANGE_ALL; cur_bracket++) {</b>
<b class="nc">&nbsp;            heat_estimates[cur_bracket] = (int) heat_by_bracket[cur_bracket];</b>
&nbsp;        }
&nbsp;
&nbsp;        // Pick the best range, which will likely be &quot;short&quot; due to short
&nbsp;        // range secondary weapons and better to-hit modifiers
<b class="nc">&nbsp;        range = RANGE_SHORT;</b>
<b class="nc">&nbsp;        for (int cur_bracket = RANGE_SHORT; cur_bracket &lt;= RANGE_ALL; cur_bracket++) {</b>
<b class="nc">&nbsp;            if (range_damages[cur_bracket] &gt; range_damages[range]) {</b>
<b class="nc">&nbsp;                range = cur_bracket;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Get the weapons heat for the optimum range
<b class="nc">&nbsp;        heat_at_range = heat_estimates[range];</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Fills range damage values for short, medium, long, and all, plus sets the
&nbsp;     * range bracket for the entity, which is 1/3 of long range or 1/4 extreme
&nbsp;     * range. The arc argument follows Compute.ARC_XXX format.
&nbsp;     */
&nbsp;    public void computeRange(int arc, boolean aptGunnery) {
&nbsp;
<b class="nc">&nbsp;        double optimizer[] = { 0, 0, 0, 0 };</b>
&nbsp;
<b class="nc">&nbsp;        Arrays.fill(range_damages, 0);</b>
&nbsp;
&nbsp;        // Create short, medium, and long range values for each arc
&nbsp;
<b class="nc">&nbsp;        rd_bracket = long_range / 4;</b>
&nbsp;
<b class="nc">&nbsp;        for (int range_walk = (entity instanceof Infantry ? 0 : 1); range_walk &lt; long_range; range_walk++) {</b>
<b class="nc">&nbsp;            if (range_walk &lt;= rd_bracket) {</b>
<b class="nc">&nbsp;                optimizer[RANGE_SHORT] += damages[arc][range_walk];</b>
<b class="nc">&nbsp;                range_damages[RANGE_SHORT] += damages[arc][range_walk];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((range_walk &gt; rd_bracket) &amp; (range_walk &lt;= (2 * rd_bracket))) {</b>
<b class="nc">&nbsp;                optimizer[RANGE_MEDIUM] += getModifiedDamage(arc, range_walk, -2, aptGunnery);</b>
<b class="nc">&nbsp;                range_damages[RANGE_MEDIUM] += damages[arc][range_walk];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((range_walk &gt; (2 * rd_bracket)) &amp; (range_walk &lt;= (3 * rd_bracket))) {</b>
<b class="nc">&nbsp;                optimizer[RANGE_LONG] += getModifiedDamage(arc, range_walk, -4, aptGunnery);</b>
<b class="nc">&nbsp;                range_damages[RANGE_LONG] += damages[arc][range_walk];</b>
&nbsp;            }
<b class="nc">&nbsp;            range_damages[RANGE_ALL] += damages[arc][range_walk];</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (rd_bracket &gt; 0) {</b>
<b class="nc">&nbsp;            range_damages[RANGE_SHORT] /= rd_bracket;</b>
<b class="nc">&nbsp;            optimizer[RANGE_SHORT] /= rd_bracket;</b>
<b class="nc">&nbsp;            range_damages[RANGE_MEDIUM] /= rd_bracket;</b>
<b class="nc">&nbsp;            optimizer[RANGE_MEDIUM] /= rd_bracket;</b>
<b class="nc">&nbsp;            range_damages[RANGE_LONG] /= rd_bracket;</b>
<b class="nc">&nbsp;            optimizer[RANGE_LONG] /= rd_bracket;</b>
<b class="nc">&nbsp;            range_damages[RANGE_ALL] /= (rd_bracket * 3);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            range_damages[RANGE_SHORT] = damages[arc][0];</b>
<b class="nc">&nbsp;            optimizer[RANGE_SHORT] = damages[arc][0];</b>
<b class="nc">&nbsp;            range_damages[RANGE_MEDIUM] = damages[arc][0];</b>
<b class="nc">&nbsp;            optimizer[RANGE_MEDIUM] = damages[arc][0];</b>
<b class="nc">&nbsp;            range_damages[RANGE_LONG] = damages[arc][0];</b>
<b class="nc">&nbsp;            optimizer[RANGE_LONG] = damages[arc][0];</b>
<b class="nc">&nbsp;            range_damages[RANGE_ALL] = damages[arc][0];</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now determine the preferred range. Use damage values based on no
&nbsp;        // range modifiers, but retain the range-based damage values for
&nbsp;        // further use.
&nbsp;
<b class="nc">&nbsp;        int best_range = RANGE_ALL;</b>
&nbsp;
<b class="nc">&nbsp;        for (range = RANGE_SHORT; range &lt;= RANGE_LONG; range++) {</b>
<b class="nc">&nbsp;            if (optimizer[range] &gt; optimizer[best_range]) {</b>
<b class="nc">&nbsp;                best_range = range;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        range = best_range;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of the armor in the indicated location. Conventional
&nbsp;     * infantry and battle armor behave differently than other units. Armor is
&nbsp;     * in integer units.
&nbsp;     */
&nbsp;    protected int getArmorValue(int loc, boolean rear) {
<b class="nc">&nbsp;        int result = entity.getArmor(loc, rear);</b>
&nbsp;
&nbsp;        // Conventional infantry don&#39;t have armor (yet), so use the number of
&nbsp;        // troopers
&nbsp;        // TODO: This will probably need some revamping when Total Warfare is
&nbsp;        // released.
<b class="nc">&nbsp;        if ((entity instanceof Infantry) &amp; !(entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            result = ((Infantry) entity).getShootingStrength();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Battle armor has armor per trooper; treat each trooper as a
&nbsp;        // &quot;location&quot;
<b class="nc">&nbsp;        if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;            result = ((BattleArmor) entity).getArmor(loc, false);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (result &lt;= 0) {</b>
<b class="nc">&nbsp;            result = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The utility of something done against me. -- uses the arcs defined by
&nbsp;     * ToHitData (FRONT, REAR, LEFT, RIGHT). Takes a damage value and adjusts it
&nbsp;     * based on the characterized entities armor/internal values in that arc.
&nbsp;     * Also adjusts based on the strategy module being used by this entity.
&nbsp;     */
&nbsp;    public double getThreatUtility(double threat, int arc) {
<b class="nc">&nbsp;        double t1 = threat;</b>
<b class="nc">&nbsp;        double t2 = threat;</b>
&nbsp;        // relative bonus for weak side
<b class="nc">&nbsp;        if (armor_percent[arc] &lt; .75) {</b>
<b class="nc">&nbsp;            t1 *= 1.1;</b>
<b class="nc">&nbsp;        } else if (armor_percent[arc] &lt; .5) {</b>
<b class="nc">&nbsp;            t1 *= 1.3;</b>
<b class="nc">&nbsp;        } else if (armor_percent[arc] &lt; .25) {</b>
<b class="nc">&nbsp;            t1 *= 1.5;</b>
&nbsp;        }
<b class="nc">&nbsp;        t1 *= strategy.target;</b>
&nbsp;
&nbsp;        // absolute bonus for damage that is likely to do critical
<b class="nc">&nbsp;        if ((t2 + expected_damage[arc]) &gt; armor_health[arc]) {</b>
&nbsp;
&nbsp;            // expected_damage[] is set on the fly; it tracks damage
&nbsp;            // the entity expects to take
<b class="nc">&nbsp;            if ((((t2 + expected_damage[0] + expected_damage[1]</b>
&nbsp;                    + expected_damage[2] + expected_damage[3]) &gt; (3 * (avg_armor + avg_iarmor))) || (entity
<b class="nc">&nbsp;                    .isProne() &amp;&amp; (base_psr_odds &lt; .1) &amp;&amp; !entity.isImmobile()))) { // If</b>
&nbsp;                                                                                    // I
&nbsp;                // have
&nbsp;                // more
&nbsp;                // friends,
&nbsp;                // this
&nbsp;                // isn&#39;t
&nbsp;                // so
&nbsp;                // bad
<b class="nc">&nbsp;                if (entity.isEnemyOf(tb.getEntitiesOwned().get(0))) {</b>
<b class="nc">&nbsp;                    return Math.sqrt(t2) * strategy.target;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            t2 *= 1.5; // Damage that penetrates armor is bad for me</b>
&nbsp;            // Even if damage doesn&#39;t penetrate, some damage to this arc isn&#39;t
&nbsp;            // that great
<b class="nc">&nbsp;        } else if (expected_damage[arc] &gt; 0) {</b>
<b class="nc">&nbsp;            t2 *= 1.3;</b>
&nbsp;
&nbsp;            // Even if this arc is still good, taking additional damage isn&#39;t a
&nbsp;            // good thing
<b class="nc">&nbsp;        } else if (hasTakenDamage) {</b>
<b class="nc">&nbsp;            t2 *= 1.1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Return the worst case, either massive damage or penetration to
&nbsp;        // internals
&nbsp;
<b class="nc">&nbsp;        return Math.max(t1, t2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Integer getKey() {
<b class="nc">&nbsp;        return Integer.valueOf(entity.getId());</b>
&nbsp;    }
&nbsp;
&nbsp;    public MoveOption.Table getAllMoves(Client client) {
<b class="nc">&nbsp;        if (moves == null) {</b>
<b class="nc">&nbsp;            moves = calculateMoveOptions(current, client);</b>
&nbsp;        }
<b class="nc">&nbsp;        return moves;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * From the current state, explore based upon an implementation of
&nbsp;     * Dijkstra&#39;s algorithm.
&nbsp;     */
&nbsp;    protected MoveOption.Table calculateMoveOptions(MoveOption base,
&nbsp;            Client client) {
&nbsp;        // New array of movement options
<b class="nc">&nbsp;        ArrayList&lt;MoveOption&gt; possible = new ArrayList&lt;MoveOption&gt;();</b>
<b class="nc">&nbsp;        MoveOption.Table discovered = new MoveOption.Table();</b>
&nbsp;
&nbsp;        // Add the seed for jumping if allowed
<b class="nc">&nbsp;        if (entity.getJumpMPWithTerrain() &gt; 0) {</b>
<b class="nc">&nbsp;            possible.add((base.clone()).addStep(MoveStepType.START_JUMP));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        possible.add(base); // Add the base movement option to the arraylist of</b>
&nbsp;        // possibles
<b class="nc">&nbsp;        discovered.put(base); // Add the base movement option to the movement</b>
&nbsp;        // option table
&nbsp;
<b class="nc">&nbsp;        while (possible.size() &gt; 0) { // Keep going until the arraylist is</b>
&nbsp;            // empty (why?)
&nbsp;
&nbsp;            // Get the first movement option, while stripping it from the
&nbsp;            // arraylist
<b class="nc">&nbsp;            MoveOption min = possible.remove(0);</b>
<b class="nc">&nbsp;            Iterator&lt;MovePath&gt; adjacent = min.getNextMoves(true, true)</b>
<b class="nc">&nbsp;                    .iterator();</b>
<b class="nc">&nbsp;            while (adjacent.hasNext()) {</b>
<b class="nc">&nbsp;                MoveOption next = (MoveOption) adjacent.next();</b>
<b class="nc">&nbsp;                if ((entity instanceof Mech) &amp;&amp; (((Mech) entity).countBadLegs() &gt;= 1)</b>
<b class="nc">&nbsp;                        &amp;&amp; (((Mech) entity).isLocationBad(Mech.LOC_LARM) &amp;&amp; ((Mech) entity)</b>
<b class="nc">&nbsp;                                .isLocationBad(Mech.LOC_RARM))) {</b>
<b class="nc">&nbsp;                    MoveOption eject = next.clone();</b>
<b class="nc">&nbsp;                    eject.addStep(MoveStepType.EJECT);</b>
<b class="nc">&nbsp;                    discovered.put(eject.clone());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (next.changeToPhysical() &amp;&amp; next.isMoveLegal()) {</b>
<b class="nc">&nbsp;                    discovered.put(next);</b>
<b class="nc">&nbsp;                } else if (next.isMoveLegal()) {</b>
&nbsp;                    // relax edges;
<b class="nc">&nbsp;                    if ((discovered.get(next) == null)</b>
<b class="nc">&nbsp;                            || (next.getDistUtility() &lt; discovered.get(next)</b>
<b class="nc">&nbsp;                                    .getDistUtility())) {</b>
<b class="nc">&nbsp;                        discovered.put(next);</b>
<b class="nc">&nbsp;                        if (next.isJumping()) {</b>
<b class="nc">&nbsp;                            MoveOption left = next.clone();</b>
<b class="nc">&nbsp;                            MoveOption right = next.clone();</b>
&nbsp;                            // Think about skipping this for infantry, which
&nbsp;                            // have no facing
<b class="nc">&nbsp;                            for (int turn = 0; turn &lt; 2; turn++) {</b>
<b class="nc">&nbsp;                                left.addStep(MoveStepType.TURN_LEFT);</b>
<b class="nc">&nbsp;                                right.addStep(MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;                                discovered.put((left.clone()));</b>
<b class="nc">&nbsp;                                discovered.put((right.clone()));</b>
&nbsp;                            }
&nbsp;                            // Accounts for a 180 degree turn
<b class="nc">&nbsp;                            right.addStep(MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;                            discovered.put(right);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        int index = Collections.&lt;MoveOption&gt; binarySearch(</b>
&nbsp;                                possible, next, MoveOption.DISTANCE_COMPARATOR);
<b class="nc">&nbsp;                        if (index &lt; 0) {</b>
<b class="nc">&nbsp;                            index = -index - 1;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        possible.add(index, next);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Final check for illegal and extra weighting for heat
<b class="nc">&nbsp;        for (Iterator&lt;MoveOption&gt; i = discovered.values().iterator(); i</b>
<b class="nc">&nbsp;                .hasNext();) {</b>
<b class="nc">&nbsp;            MoveOption next = i.next();</b>
<b class="nc">&nbsp;            next.clipToPossible();</b>
<b class="nc">&nbsp;            if (!next.isMoveLegal()) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.heat &gt; 4) {</b>
<b class="nc">&nbsp;                next.movement_threat += (bv / 1000)</b>
<b class="nc">&nbsp;                        * next.getMovementheatBuildup();</b>
<b class="nc">&nbsp;                if (entity.heat &gt; 7) {</b>
<b class="nc">&nbsp;                    next.movement_threat += (bv / 500)</b>
<b class="nc">&nbsp;                            * next.getMovementheatBuildup();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (tsm_offset) {</b>
<b class="nc">&nbsp;                    if (entity.heat == 9) {</b>
<b class="nc">&nbsp;                        next.movement_threat -= (bv / 100)</b>
<b class="nc">&nbsp;                                * next.getMovementheatBuildup();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((entity.heat &lt; 12) &amp;&amp; (entity.heat &gt; 9)) {</b>
<b class="nc">&nbsp;                        next.movement_threat -= (bv / 500)</b>
<b class="nc">&nbsp;                                * next.getMovementheatBuildup();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (entity.heat &gt; 12) {</b>
<b class="nc">&nbsp;                    next.movement_threat += (bv / 100)</b>
<b class="nc">&nbsp;                            * next.getMovementheatBuildup();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            String pilotChecks = SharedUtility.doPSRCheck(next);</b>
<b class="nc">&nbsp;            if (pilotChecks.length() &gt; 0) {</b>
<b class="nc">&nbsp;                next.inDanger = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return discovered;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * find all moves that get into dest
&nbsp;     */
&nbsp;    public ArrayList&lt;MoveOption&gt; findMoves(Coords dest, Client client) {
<b class="nc">&nbsp;        ArrayList&lt;MoveOption&gt; result = new ArrayList&lt;MoveOption&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            for (int j = 1; j &lt; 2; j++) {</b>
<b class="nc">&nbsp;                MoveOption.Key key = new MoveOption.Key(dest, i, j);</b>
<b class="nc">&nbsp;                MoveOption es = null;</b>
<b class="nc">&nbsp;                if ((es = getAllMoves(client).get(key)) != null) {</b>
<b class="nc">&nbsp;                    result.add(es);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an estimate of damage given the range to the target and a
&nbsp;     * modifier to the to-hit number. An approximation of the original to-hit
&nbsp;     * odds is extracted from the damage at that range leaving the damage that
&nbsp;     * is (hopefully) close to the original value. New odds are generated based
&nbsp;     * on the units gunnery skill and the modifier and factored back into the
&nbsp;     * returned damage value.
&nbsp;     */
&nbsp;    public double getModifiedDamage(int arc, int a_range, int modifier, boolean aptGunnery) {
<b class="nc">&nbsp;        if (a_range &gt;= MAX_RANGE) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        double damage = damages[arc][a_range];</b>
&nbsp;
&nbsp;        // Use pilots gunnery skill, not the piloting skill...
<b class="nc">&nbsp;        int base = entity.getCrew().getGunnery();</b>
<b class="nc">&nbsp;        if (entity.getTaserFeedBackRounds() &gt; 0) {</b>
<b class="nc">&nbsp;            base += 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        int dist_mod = 0;</b>
&nbsp;
&nbsp;        // Check range brackets based on defined maximum possible
&nbsp;        // range of weapon
<b class="nc">&nbsp;        double range_bracket = long_range / 4.0;</b>
&nbsp;
&nbsp;        // Inside minimum range, penalties must be observed
<b class="nc">&nbsp;        if (a_range &lt;= MIN_BRACKET) {</b>
<b class="nc">&nbsp;            dist_mod += minRangeMods[a_range];</b>
&nbsp;        }
&nbsp;
&nbsp;        // Medium range is +2
<b class="nc">&nbsp;        if (a_range &gt; range_bracket) {</b>
<b class="nc">&nbsp;            dist_mod += 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Long range is another +2 (i.e. +4)
<b class="nc">&nbsp;        if (a_range &gt; (2 * range_bracket)) {</b>
<b class="nc">&nbsp;            dist_mod += 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Anything past 3 &quot;range brackets&quot; is extreme range +8,
&nbsp;        // or +4 on top of previous modifiers
<b class="nc">&nbsp;        if (a_range &gt; (3 * range_bracket)) {</b>
<b class="nc">&nbsp;            dist_mod += 4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (((base + dist_mod + modifier) &gt; tb.ignore)</b>
&nbsp;                | ((base + dist_mod + modifier) &gt; 12)) {
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((base + dist_mod + modifier) == tb.ignore) {</b>
<b class="nc">&nbsp;            damage *= 0.5;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Factor out the to-hit odds and re-factor in new odds with the passed
&nbsp;        // modifier
<b class="nc">&nbsp;        double old_odds = Compute.oddsAbove(base + dist_mod, aptGunnery) / 100;</b>
<b class="nc">&nbsp;        double new_odds = Compute.oddsAbove(dist_mod + modifier + base, aptGunnery) / 100;</b>
&nbsp;
<b class="nc">&nbsp;        return (new_odds * damage) / old_odds;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates an approximation of damage done at each of the major range
&nbsp;     * brackets, including minimum range. Also handles weapons with damage and
&nbsp;     * range that varies by ammo type. Adds line to debug log for any variable
&nbsp;     * damage weapons that aren&#39;t handled.
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     * @param applicable_ranges
&nbsp;     *            only counts for MMLs and ATMs
&nbsp;     * @return 4-element array with min/short/medium/long range damage
&nbsp;     */
&nbsp;
&nbsp;    private static double[] getRawDamage(Mounted weapon,
&nbsp;            boolean[] applicable_ranges) {
<b class="nc">&nbsp;        WeaponType wt = (WeaponType) weapon.getType();</b>
&nbsp;        Mounted linked_guidance;
&nbsp;
<b class="nc">&nbsp;        double damage_value = wt.getDamage();</b>
<b class="nc">&nbsp;        double[] raw_damage_array = { damage_value, damage_value, damage_value,</b>
&nbsp;                damage_value };
&nbsp;
<b class="nc">&nbsp;        int rack_size = 1;</b>
&nbsp;
<b class="nc">&nbsp;        boolean use_table = false;</b>
&nbsp;
&nbsp;        // Some weapons use the cluster hits table:
&nbsp;        // - non-Thunderbolt missiles
&nbsp;        // - LBX cannons are assumed to have cluster ammo
&nbsp;        // - Ultra cannons as two-shot, rotary cannons as 4-shot
&nbsp;        // - HAGs
&nbsp;
<b class="nc">&nbsp;        if (wt.hasFlag(WeaponType.F_MISSILE)</b>
<b class="nc">&nbsp;                &amp;&amp; ((wt.getAmmoType() != AmmoType.T_TBOLT_5)</b>
<b class="nc">&nbsp;                        || (wt.getAmmoType() != AmmoType.T_TBOLT_10)</b>
<b class="nc">&nbsp;                        || (wt.getAmmoType() != AmmoType.T_TBOLT_15) || (wt</b>
<b class="nc">&nbsp;                        .getAmmoType() != AmmoType.T_TBOLT_20))) {</b>
<b class="nc">&nbsp;            use_table = true;</b>
<b class="nc">&nbsp;            rack_size = wt.getRackSize();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((wt.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_HAG)) {</b>
<b class="nc">&nbsp;            use_table = true;</b>
<b class="nc">&nbsp;            rack_size = wt.getRackSize();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {</b>
<b class="nc">&nbsp;            use_table = true;</b>
<b class="nc">&nbsp;            rack_size = 2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</b>
<b class="nc">&nbsp;            use_table = true;</b>
<b class="nc">&nbsp;            rack_size = 4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (use_table == true) {</b>
&nbsp;
<b class="nc">&nbsp;            int linked_ammo = wt.getAmmoType();</b>
&nbsp;
&nbsp;            // MMLs and ATMS change damage and range by ammo type,
&nbsp;            // which is going to require some serious gymnastics
&nbsp;
&nbsp;            // ATMs, which include built-in Artemis
<b class="nc">&nbsp;            if (linked_ammo == AmmoType.T_ATM) {</b>
&nbsp;
<b class="nc">&nbsp;                damage_value = hits_by_racksize[rack_size] * 1.2;</b>
&nbsp;
&nbsp;                // Use ER ammo damage as a default
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;                // All three types: use ER ranges, with HE for &quot;short&quot; range,
&nbsp;                // std for &quot;medium&quot; range, and ER for &quot;long&quot; range damages
<b class="nc">&nbsp;                if (applicable_ranges[0] &amp;&amp; applicable_ranges[1]</b>
&nbsp;                        &amp;&amp; applicable_ranges[2]) {
<b class="nc">&nbsp;                    raw_damage_array[0] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[1] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[2] *= 2.0;</b>
&nbsp;                }
&nbsp;
&nbsp;                // HE only
<b class="nc">&nbsp;                if (applicable_ranges[0] &amp;&amp; !applicable_ranges[1]</b>
&nbsp;                        &amp;&amp; !applicable_ranges[2]) {
<b class="nc">&nbsp;                    for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                        raw_damage_array[i] *= 3.0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Standard only
<b class="nc">&nbsp;                if (!applicable_ranges[0] &amp;&amp; applicable_ranges[1]</b>
&nbsp;                        &amp;&amp; !applicable_ranges[2]) {
<b class="nc">&nbsp;                    for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                        raw_damage_array[i] *= 2.0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // HE and standard only: use std ranges, with HE for the
&nbsp;                // &quot;short&quot; range damage
<b class="nc">&nbsp;                if (applicable_ranges[0] &amp;&amp; applicable_ranges[1]</b>
&nbsp;                        &amp;&amp; !applicable_ranges[2]) {
&nbsp;
<b class="nc">&nbsp;                    raw_damage_array[0] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[1] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[2] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[3] *= 2.0;</b>
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                // HE and ER only: use ER ranges, with HE for the
&nbsp;                // &quot;short&quot; range damage
<b class="nc">&nbsp;                if (applicable_ranges[0] &amp;&amp; !applicable_ranges[1]</b>
&nbsp;                        &amp;&amp; applicable_ranges[2]) {
&nbsp;
<b class="nc">&nbsp;                    raw_damage_array[0] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[1] *= 3.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[2] *= 1.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[3] *= 1.0;</b>
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                // Standard and ER only: use ER ranges, with std for &quot;short&quot;
&nbsp;                // and &quot;medium&quot; range damage
<b class="nc">&nbsp;                if (!applicable_ranges[0] &amp;&amp; applicable_ranges[1]</b>
&nbsp;                        &amp;&amp; applicable_ranges[2]) {
&nbsp;
<b class="nc">&nbsp;                    raw_damage_array[0] *= 2.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[1] *= 2.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[2] *= 2.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[3] *= 1.0;</b>
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // MMLs, which may have Artemis
<b class="nc">&nbsp;            if (linked_ammo == AmmoType.T_MML) {</b>
&nbsp;
<b class="nc">&nbsp;                damage_value = hits_by_racksize[rack_size];</b>
<b class="nc">&nbsp;                linked_guidance = weapon.getLinkedBy();</b>
<b class="nc">&nbsp;                if ((linked_guidance != null) &amp;&amp; !linked_guidance.isDestroyed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !linked_guidance.isMissing()</b>
<b class="nc">&nbsp;                        &amp;&amp; !linked_guidance.isBreached()</b>
<b class="nc">&nbsp;                        &amp;&amp; (linked_guidance.getType() instanceof MiscType)) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (linked_guidance.getType().hasFlag(MiscType.F_ARTEMIS)) {</b>
<b class="nc">&nbsp;                        damage_value *= 1.2;</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                // Use LRM damage as a default
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If SRM ammo is available, use it for short and medium range
<b class="nc">&nbsp;                if (applicable_ranges[0]) {</b>
&nbsp;
<b class="nc">&nbsp;                    raw_damage_array[0] *= 2.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[1] *= 2.0;</b>
<b class="nc">&nbsp;                    raw_damage_array[2] *= 2.0;</b>
&nbsp;
&nbsp;                    // If LRM ammo is not available, use SRM for long range too
<b class="nc">&nbsp;                    if (!applicable_ranges[2]) {</b>
<b class="nc">&nbsp;                        raw_damage_array[3] *= 2.0;</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // LRMs, SRMs, which may have Artemis
<b class="nc">&nbsp;            if ((linked_ammo == AmmoType.T_SRM)</b>
&nbsp;                    || (linked_ammo == AmmoType.T_SRM_IMP) 
&nbsp;                    || (linked_ammo == AmmoType.T_LRM_IMP)
&nbsp;                    || (linked_ammo == AmmoType.T_LRM)) {
&nbsp;
<b class="nc">&nbsp;                damage_value = hits_by_racksize[rack_size];</b>
<b class="nc">&nbsp;                linked_guidance = weapon.getLinkedBy();</b>
<b class="nc">&nbsp;                if ((linked_guidance != null) &amp;&amp; !linked_guidance.isDestroyed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !linked_guidance.isMissing()</b>
<b class="nc">&nbsp;                        &amp;&amp; !linked_guidance.isBreached()</b>
<b class="nc">&nbsp;                        &amp;&amp; (linked_guidance.getType() instanceof MiscType)) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (linked_guidance.getType().hasFlag(MiscType.F_ARTEMIS)) {</b>
<b class="nc">&nbsp;                        damage_value *= 1.2;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (linked_guidance.getType().hasFlag(</b>
&nbsp;                                MiscType.F_ARTEMIS_V)) {
<b class="nc">&nbsp;                            damage_value *= 1.4;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if ((linked_ammo == AmmoType.T_SRM) || (linked_ammo == AmmoType.T_SRM_IMP)) {</b>
<b class="nc">&nbsp;                    damage_value *= 2.0;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // MRMs, which may have Apollo
<b class="nc">&nbsp;            if (linked_ammo == AmmoType.T_MRM) {</b>
&nbsp;
<b class="nc">&nbsp;                damage_value = hits_by_racksize[rack_size];</b>
<b class="nc">&nbsp;                linked_guidance = weapon.getLinkedBy();</b>
<b class="nc">&nbsp;                if ((linked_guidance != null) &amp;&amp; !linked_guidance.isDestroyed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !linked_guidance.isMissing()</b>
<b class="nc">&nbsp;                        &amp;&amp; !linked_guidance.isBreached()</b>
<b class="nc">&nbsp;                        &amp;&amp; (linked_guidance.getType() instanceof MiscType)) {</b>
<b class="nc">&nbsp;                    damage_value *= 0.9;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // Streak SRMs and LRMs use full rack size
<b class="nc">&nbsp;            if (linked_ammo == AmmoType.T_SRM_STREAK) {</b>
&nbsp;
<b class="nc">&nbsp;                damage_value = rack_size * 2.0;</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            if (linked_ammo == AmmoType.T_LRM_STREAK) {</b>
<b class="nc">&nbsp;                damage_value = rack_size;</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // HAGs get a bonus at short range and a penalty at long range
<b class="nc">&nbsp;            if (linked_ammo == AmmoType.T_HAG) {</b>
<b class="nc">&nbsp;                damage_value = hits_by_racksize[rack_size];</b>
<b class="nc">&nbsp;                raw_damage_array[0] = damage_value * 1.2;</b>
<b class="nc">&nbsp;                raw_damage_array[1] = damage_value * 1.2;</b>
<b class="nc">&nbsp;                raw_damage_array[2] = damage_value;</b>
<b class="nc">&nbsp;                raw_damage_array[3] = damage_value * 0.8;</b>
&nbsp;            }
&nbsp;
&nbsp;            // LBX cannons are assumed to be firing cluster rounds.
&nbsp;            // TODO: extend ammo bin check from MMLs &amp; ATMs
<b class="nc">&nbsp;            if ((linked_ammo == AmmoType.T_AC_LBX)</b>
&nbsp;                    || (linked_ammo == AmmoType.T_AC_LBX_THB)) {
<b class="nc">&nbsp;                damage_value = hits_by_racksize[rack_size];</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Ultra and rotary cannons return damage values properly
&nbsp;
<b class="nc">&nbsp;            if ((linked_ammo == AmmoType.T_AC_ULTRA)</b>
&nbsp;                    || (linked_ammo == AmmoType.T_AC_ULTRA_THB)
&nbsp;                    || (linked_ammo == AmmoType.T_AC_ROTARY)) {
&nbsp;
<b class="nc">&nbsp;                damage_value *= hits_by_racksize[rack_size];</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } else {</b>
&nbsp;
&nbsp;            // Heavy Gauss, Snubnose PPC, variable speed lasers change
&nbsp;            // damage with range
<b class="nc">&nbsp;            if ((wt instanceof ISImpHGaussRifle) || (wt instanceof ISSnubNosePPC)</b>
&nbsp;                    || (wt instanceof VariableSpeedPulseLaserWeapon)) {
<b class="nc">&nbsp;                raw_damage_array[0] = wt.getDamage(wt.getShortRange());</b>
<b class="nc">&nbsp;                raw_damage_array[1] = wt.getDamage(wt.getShortRange());</b>
<b class="nc">&nbsp;                raw_damage_array[2] = wt.getDamage(wt.getMediumRange());</b>
<b class="nc">&nbsp;                raw_damage_array[3] = wt.getDamage(wt.getLongRange());</b>
&nbsp;            }
&nbsp;
&nbsp;            // IS plasma rifle
<b class="nc">&nbsp;            if (wt.getInternalName().equals(&quot;ISPlasmaRifle&quot;)) {</b>
&nbsp;
<b class="nc">&nbsp;                damage_value = 12.0;</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // Clan plasma cannon
<b class="nc">&nbsp;            if (wt.getInternalName().equals(&quot;CLPlasmaCannon&quot;)) {</b>
&nbsp;
<b class="nc">&nbsp;                damage_value = 10.5;</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // Thunderbolt missiles are half damage inside minimum range
<b class="nc">&nbsp;            if ((wt.getAmmoType() == AmmoType.T_TBOLT_5)</b>
<b class="nc">&nbsp;                    || (wt.getAmmoType() == AmmoType.T_TBOLT_10)</b>
<b class="nc">&nbsp;                    || (wt.getAmmoType() == AmmoType.T_TBOLT_15)</b>
<b class="nc">&nbsp;                    || (wt.getAmmoType() == AmmoType.T_TBOLT_20)) {</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; raw_damage_array.length; i++) {</b>
<b class="nc">&nbsp;                    raw_damage_array[i] = damage_value;</b>
&nbsp;                }
<b class="nc">&nbsp;                raw_damage_array[0] = damage_value / 2.0;</b>
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // Zero damage is acceptable, but negative damage means
&nbsp;        // something is wrong (typically a variable damage weapon
&nbsp;        // hasn&#39;t been handled). Push a line to the log file
&nbsp;        // to help developers and reset the damage value.
&nbsp;
<b class="nc">&nbsp;        if ((raw_damage_array[0] &lt; 0) || (raw_damage_array[1] &lt; 0)</b>
&nbsp;                || (raw_damage_array[2] &lt; 0) || (raw_damage_array[3] &lt; 0)) {
&nbsp;
<b class="nc">&nbsp;            System.out</b>
<b class="nc">&nbsp;                    .println(&quot;Weapons characterization: negative damage for weapon &quot;</b>
<b class="nc">&nbsp;                            + weapon.getName() + &quot;.&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            raw_damage_array[0] = 1.0;</b>
<b class="nc">&nbsp;            raw_damage_array[1] = 1.0;</b>
<b class="nc">&nbsp;            raw_damage_array[2] = 1.0;</b>
<b class="nc">&nbsp;            raw_damage_array[3] = 1.0;</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return raw_damage_array;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Certain weapons, mostly ATMs and MMLs, can change both range and damage
&nbsp;     * based on what ammo is selected. This will go through the ammo bins that
&nbsp;     * are applicable to the specified weapon and set flags based on whether the
&nbsp;     * ammo is short, medium, or long range. ATMs can set all three; MMLs can
&nbsp;     * only set short and long range flags.
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     *            weapon being checked
&nbsp;     * @param ammo_list
&nbsp;     *            ArrayList of Mounted returned by Entity.getAmmo()
&nbsp;     * @return 3-element array indicating short/medium/long ranges available
&nbsp;     */
&nbsp;
&nbsp;    private static boolean[] getAmmoRanges(WeaponType weapon,
&nbsp;            ArrayList&lt;Mounted&gt; ammo_list) {
&nbsp;
<b class="nc">&nbsp;        AmmoType bin_type = new AmmoType();</b>
<b class="nc">&nbsp;        int ammo_filter = weapon.getAmmoType();</b>
&nbsp;
&nbsp;        // Short, medium, and long range, respectively
<b class="nc">&nbsp;        boolean[] range_flags = { false, false, false };</b>
&nbsp;
&nbsp;        // Filter for ATM and MML only. Add more weapons as needed.
<b class="nc">&nbsp;        if ((ammo_filter != AmmoType.T_ATM) &amp;&amp; (ammo_filter != AmmoType.T_MML)) {</b>
<b class="nc">&nbsp;            return range_flags;</b>
&nbsp;        }
&nbsp;
&nbsp;        // For each ammo bin
<b class="nc">&nbsp;        for (Mounted ammo_bin : ammo_list) {</b>
&nbsp;
&nbsp;            // If all types are accounted for, no point in checking anything
&nbsp;            // else
<b class="nc">&nbsp;            if (((ammo_filter == AmmoType.T_MML) &amp;&amp; range_flags[0] &amp;&amp; range_flags[2])</b>
&nbsp;                    || ((ammo_filter == AmmoType.T_ATM) &amp;&amp; range_flags[0]
&nbsp;                            &amp;&amp; range_flags[1] &amp;&amp; range_flags[2])) {
<b class="nc">&nbsp;                return range_flags;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If the bin isn&#39;t empty, isn&#39;t destroyed, and isn&#39;t breached
<b class="nc">&nbsp;            if (ammo_bin.isAmmoUsable()) {</b>
&nbsp;
&nbsp;                // If the bin is the correct type for the weapon, and has the
&nbsp;                // proper rack size
<b class="nc">&nbsp;                bin_type = (AmmoType) ammo_bin.getType();</b>
<b class="nc">&nbsp;                if ((bin_type.getAmmoType() == ammo_filter)</b>
<b class="nc">&nbsp;                        &amp;&amp; (bin_type.getRackSize() == weapon.getRackSize())) {</b>
&nbsp;
&nbsp;                    // If the weapon is an ATM
<b class="nc">&nbsp;                    if (ammo_filter == AmmoType.T_ATM) {</b>
&nbsp;
<b class="nc">&nbsp;                        if (bin_type.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE) {</b>
<b class="nc">&nbsp;                            range_flags[0] = true;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (bin_type.getMunitionType() == AmmoType.M_EXTENDED_RANGE) {</b>
<b class="nc">&nbsp;                                range_flags[2] = true;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                range_flags[1] = true;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    // If the weapon is an MML
<b class="nc">&nbsp;                    if (ammo_filter == AmmoType.T_MML) {</b>
&nbsp;
&nbsp;                        // Really hate to depend on string comparisons but
&nbsp;                        // nothing else is available
<b class="nc">&nbsp;                        if (bin_type.getShortName().contains(&quot;SRM&quot;)) {</b>
<b class="nc">&nbsp;                            range_flags[0] = true;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (bin_type.getShortName().contains(&quot;LRM&quot;)</b>
<b class="nc">&nbsp;                                    &amp;&amp; !AmmoType.canDeliverMinefield(bin_type)) {</b>
<b class="nc">&nbsp;                                range_flags[2] = true;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // Next bin
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return range_flags;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies to-hit odds for a weapon at each range to raw damage numbers.
&nbsp;     * This provides an estimate of damage under average circumstances.
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     *            weapon being checked
&nbsp;     * @param gunskill
&nbsp;     *            Gunnery skill of attacker
&nbsp;     * @param raw_damage
&nbsp;     *            damage for min/short/medium/long range
&nbsp;     * @param ammo_ranges
&nbsp;     *            flags for short/medium/long range ammo available
&nbsp;     * @return array with the estimated damage values at each range
&nbsp;     */
&nbsp;
&nbsp;    private static double[] getExpectedDamage(WeaponType weapon, int gunskill,
&nbsp;                                              double[] raw_damage, boolean[] ammo_ranges, boolean aptGunnery) {
&nbsp;
&nbsp;        // Preset the modified damages
<b class="nc">&nbsp;        double[] modified_damages = new double[MAX_RANGE];</b>
&nbsp;
&nbsp;        // Grab the weapon ranges here, outside the range loop
<b class="nc">&nbsp;        int[] range_brackets = new int[5];</b>
<b class="nc">&nbsp;        range_brackets[RANGE_SHORT] = weapon.getShortRange();</b>
<b class="nc">&nbsp;        range_brackets[RANGE_MEDIUM] = weapon.getMediumRange();</b>
<b class="nc">&nbsp;        range_brackets[RANGE_LONG] = weapon.getLongRange();</b>
<b class="nc">&nbsp;        range_brackets[3] = weapon.getExtremeRange();</b>
<b class="nc">&nbsp;        range_brackets[4] = weapon.getMinimumRange();</b>
&nbsp;
&nbsp;        // ATM ranges depend on ammo types available. Use the longest range
&nbsp;        // ammo available.
&nbsp;        // TODO: figure out how to get ranges directly from ATM ammo
<b class="nc">&nbsp;        if (weapon.getAmmoType() == AmmoType.T_ATM) {</b>
<b class="nc">&nbsp;            if (ammo_ranges[2]) {</b>
&nbsp;
<b class="nc">&nbsp;                range_brackets[RANGE_SHORT] = 9;</b>
<b class="nc">&nbsp;                range_brackets[RANGE_MEDIUM] = 18;</b>
<b class="nc">&nbsp;                range_brackets[RANGE_LONG] = 27;</b>
<b class="nc">&nbsp;                range_brackets[3] = Math.min(36, MAX_RANGE);</b>
<b class="nc">&nbsp;                range_brackets[4] = ammo_ranges[0] ? -1 : 4;</b>
&nbsp;
&nbsp;            } else {
<b class="nc">&nbsp;                if (ammo_ranges[1]) {</b>
&nbsp;
<b class="nc">&nbsp;                    range_brackets[RANGE_SHORT] = 5;</b>
<b class="nc">&nbsp;                    range_brackets[RANGE_MEDIUM] = 10;</b>
<b class="nc">&nbsp;                    range_brackets[RANGE_LONG] = 15;</b>
<b class="nc">&nbsp;                    range_brackets[3] = 20;</b>
<b class="nc">&nbsp;                    range_brackets[4] = ammo_ranges[0] ? -1 : 4;</b>
&nbsp;
&nbsp;                } else {
&nbsp;
<b class="nc">&nbsp;                    range_brackets[RANGE_SHORT] = 3;</b>
<b class="nc">&nbsp;                    range_brackets[RANGE_MEDIUM] = 6;</b>
<b class="nc">&nbsp;                    range_brackets[RANGE_LONG] = 9;</b>
<b class="nc">&nbsp;                    range_brackets[3] = 12;</b>
<b class="nc">&nbsp;                    range_brackets[4] = -1;</b>
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // MML ranges depend on ammo types available
&nbsp;        // TODO: figure out how to get ranges directly from MML ammo
<b class="nc">&nbsp;        if (weapon.getAmmoType() == AmmoType.T_MML) {</b>
<b class="nc">&nbsp;            if (ammo_ranges[2]) {</b>
&nbsp;
&nbsp;                // If LRM ammo is available, use LRM ranges. If SRM ammo
&nbsp;                // is also available it will be used at short range.
<b class="nc">&nbsp;                range_brackets[RANGE_SHORT] = 7;</b>
<b class="nc">&nbsp;                range_brackets[RANGE_MEDIUM] = 14;</b>
<b class="nc">&nbsp;                range_brackets[RANGE_LONG] = 21;</b>
<b class="nc">&nbsp;                range_brackets[3] = 28;</b>
<b class="nc">&nbsp;                range_brackets[4] = ammo_ranges[0] ? -1 : 6;</b>
&nbsp;
&nbsp;            } else {
<b class="nc">&nbsp;                if (ammo_ranges[0]) {</b>
&nbsp;
&nbsp;                    // If only SRM ammo is available, use SRM ranges
<b class="nc">&nbsp;                    range_brackets[RANGE_SHORT] = 3;</b>
<b class="nc">&nbsp;                    range_brackets[RANGE_MEDIUM] = 6;</b>
<b class="nc">&nbsp;                    range_brackets[RANGE_LONG] = 9;</b>
<b class="nc">&nbsp;                    range_brackets[3] = 12;</b>
<b class="nc">&nbsp;                    range_brackets[4] = -1;</b>
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int total_mod;
<b class="nc">&nbsp;        int weapon_mod = weapon.getToHitModifier();</b>
&nbsp;
&nbsp;        // Consider LBX cannons to always be firing cluster rounds
<b class="nc">&nbsp;        if ((weapon.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                || (weapon.getAmmoType() == AmmoType.T_AC_LBX_THB)) {</b>
<b class="nc">&nbsp;            weapon_mod = -1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // For each hex of range out to extreme range or the extent of the
&nbsp;        // range array
<b class="nc">&nbsp;        for (int cur_range = 0; (cur_range &lt; MAX_RANGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (cur_range &lt;= range_brackets[3]); cur_range++) {</b>
&nbsp;
&nbsp;            // Calculate the total to-hit modifier using the units
&nbsp;            // gunnery skill, the current range, and any weapon-specific
&nbsp;            // modifiers
<b class="nc">&nbsp;            total_mod = gunskill + weapon_mod;</b>
<b class="nc">&nbsp;            if (cur_range &gt; range_brackets[4]) {</b>
&nbsp;
<b class="nc">&nbsp;                if (cur_range &gt; range_brackets[RANGE_SHORT]) {</b>
<b class="nc">&nbsp;                    total_mod += 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (cur_range &gt; range_brackets[RANGE_MEDIUM]) {</b>
<b class="nc">&nbsp;                    total_mod += 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (cur_range &gt; range_brackets[RANGE_LONG]) {</b>
<b class="nc">&nbsp;                    total_mod += 4;</b>
&nbsp;                }
&nbsp;
&nbsp;            } else {
&nbsp;
&nbsp;                // Inside minimum range
<b class="nc">&nbsp;                total_mod += (1 + range_brackets[4]) - cur_range;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Find the odds of hitting a target and apply them to the raw
&nbsp;            // damage
<b class="nc">&nbsp;            if (cur_range &lt;= range_brackets[RANGE_SHORT]) {</b>
<b class="nc">&nbsp;                if (cur_range &gt; range_brackets[4]) {</b>
<b class="nc">&nbsp;                    modified_damages[cur_range] = (raw_damage[1]</b>
<b class="nc">&nbsp;                                                   * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    modified_damages[cur_range] = (raw_damage[0]</b>
<b class="nc">&nbsp;                                                   * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (cur_range &gt; range_brackets[RANGE_SHORT]) {</b>
<b class="nc">&nbsp;                modified_damages[cur_range] = (raw_damage[2]</b>
<b class="nc">&nbsp;                                               * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cur_range &gt; range_brackets[RANGE_MEDIUM]) {</b>
<b class="nc">&nbsp;                modified_damages[cur_range] = (raw_damage[3]</b>
<b class="nc">&nbsp;                                               * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return modified_damages;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies to-hit odds for a conventional infantry unit at each range to raw
&nbsp;     * damage numbers. This provides an estimate of damage under average
&nbsp;     * circumstances.
&nbsp;     *
&nbsp;     * @param attacker
&nbsp;     *            Infantry unit
&nbsp;     * @param gunskill
&nbsp;     * @return
&nbsp;     */
&nbsp;    private static double[] getExpectedDamage(Infantry attacker, int gunskill) {
&nbsp;
<b class="nc">&nbsp;        InfantryWeapon primary_weapon = attacker.getPrimaryWeapon();</b>
<b class="nc">&nbsp;        InfantryWeapon secondary_weapon = attacker.getSecondaryWeapon();</b>
&nbsp;
&nbsp;        // Preset the modified damages
<b class="nc">&nbsp;        double raw_damage = 0.0;</b>
<b class="nc">&nbsp;        double[] modified_damages = new double[MAX_RANGE];</b>
&nbsp;
&nbsp;        // Base range for conventional infantry weapons
<b class="nc">&nbsp;        int base_range = 0;</b>
&nbsp;        int total_mod;
&nbsp;
&nbsp;        // Unarmed infantry unit doesn&#39;t do any damage
<b class="nc">&nbsp;        if (null == primary_weapon) {</b>
<b class="nc">&nbsp;            return modified_damages;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Base damage for a single trooper. Number of troopers will be
&nbsp;        // accounted for later.
<b class="nc">&nbsp;        raw_damage = attacker.getDamagePerTrooper();</b>
&nbsp;
&nbsp;        // If there are two secondary weapons per squad then use that weapons
&nbsp;        // range. Otherwise use the primary weapons range.
<b class="nc">&nbsp;        if ((null != secondary_weapon) &amp;&amp; (attacker.getSecondaryN() &gt;= 2)) {</b>
<b class="nc">&nbsp;            base_range = secondary_weapon.getInfantryRange();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            base_range = primary_weapon.getInfantryRange();</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int cur_range = 0; (cur_range &lt; MAX_RANGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (cur_range &lt;= (base_range * 4)); cur_range++) {</b>
&nbsp;
&nbsp;            // Range modifiers are a little screwey. This is just a rough
&nbsp;            // estimate.
<b class="nc">&nbsp;            total_mod = gunskill;</b>
<b class="nc">&nbsp;            if (cur_range == 0) {</b>
<b class="nc">&nbsp;                if ((base_range &gt; 0) &amp;&amp; (base_range &lt;= 4)) {</b>
<b class="nc">&nbsp;                    total_mod -= 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((base_range &gt; 0) &amp;&amp; (base_range &gt; 4)) {</b>
<b class="nc">&nbsp;                    total_mod -= 1;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (cur_range &gt; base_range) {</b>
<b class="nc">&nbsp;                total_mod += 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cur_range &gt; (base_range * 2)) {</b>
<b class="nc">&nbsp;                total_mod += 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cur_range &gt; (base_range * 3)) {</b>
<b class="nc">&nbsp;                total_mod += 4;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            boolean aptGunnery = attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</b>
<b class="nc">&nbsp;            modified_damages[cur_range] = (raw_damage</b>
<b class="nc">&nbsp;                                           * Compute.oddsAbove(total_mod, aptGunnery)) / 100.0;</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return modified_damages;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int getFiringAngle(final Coords dest, int dest_facing,
&nbsp;            final Coords src) {
<b class="nc">&nbsp;        int fa = dest.degree(src) - ((dest_facing % 6) * 60);</b>
<b class="nc">&nbsp;        if (fa &lt; 0) {</b>
<b class="nc">&nbsp;            fa += 360;</b>
<b class="nc">&nbsp;        } else if (fa &gt;= 360) {</b>
<b class="nc">&nbsp;            fa -= 360;</b>
&nbsp;        }
<b class="nc">&nbsp;        return fa;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int getThreatHitArc(Coords dest, int dest_facing, Coords src) {
<b class="nc">&nbsp;        int fa = getFiringAngle(dest, dest_facing, src);</b>
<b class="nc">&nbsp;        if ((fa &gt;= 300) || (fa &lt;= 60)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_FRONT;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((fa &gt;= 60) &amp;&amp; (fa &lt;= 120)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_RIGHT;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((fa &gt;= 240) &amp;&amp; (fa &lt;= 300)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_LEFT;</b>
&nbsp;        }
<b class="nc">&nbsp;        return ToHitData.SIDE_REAR;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int firingArcToHitArc(int arc) {
<b class="nc">&nbsp;        switch (arc) {</b>
&nbsp;            case Compute.ARC_FORWARD:
<b class="nc">&nbsp;                return ToHitData.SIDE_FRONT;</b>
&nbsp;            case Compute.ARC_LEFTARM:
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
&nbsp;            case Compute.ARC_RIGHTARM:
<b class="nc">&nbsp;                return ToHitData.SIDE_RIGHT;</b>
&nbsp;            case Compute.ARC_REAR:
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
&nbsp;            case Compute.ARC_LEFTSIDE:
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
&nbsp;            case Compute.ARC_RIGHTSIDE:
<b class="nc">&nbsp;                return ToHitData.SIDE_RIGHT;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="nc">&nbsp;        if (obj instanceof Entity) {</b>
<b class="nc">&nbsp;            return ((Entity)obj).getId() == entity.getId();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (obj instanceof CEntity) {</b>
<b class="nc">&nbsp;            return ((CEntity)obj).entity.getId() == entity.getId();</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="nc">&nbsp;        return entity.getId();</b>
&nbsp;    }
&nbsp;
&nbsp;    public TestBot getTb() {
<b class="nc">&nbsp;        return tb;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
