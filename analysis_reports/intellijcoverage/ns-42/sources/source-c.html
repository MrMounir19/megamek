


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Server</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.server</a>
</div>

<h1>Coverage Summary for Class: Server (megamek.server)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Server</td>
<td class="coverageStat">
  <span class="percent">
    0.6%
  </span>
  <span class="absValue">
    (3/528)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (4/20210)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Server$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$DamageType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$EntityTargetPair</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$PacketPump</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Server$ReceivedPacket</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0.5%
  </span>
  <span class="absValue">
    (3/556)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (4/20316)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)
&nbsp;* Copyright (C) 2018, 2020 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;package megamek.server;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.net.HttpURLConnection;
&nbsp;import java.net.InetAddress;
&nbsp;import java.net.ServerSocket;
&nbsp;import java.net.Socket;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLEncoder;
&nbsp;import java.net.UnknownHostException;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.text.SimpleDateFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Date;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.Timer;
&nbsp;import java.util.TimerTask;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.ConcurrentLinkedQueue;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.zip.GZIPInputStream;
&nbsp;import java.util.zip.GZIPOutputStream;
&nbsp;
&nbsp;import com.thoughtworks.xstream.XStream;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.client.ui.swing.util.PlayerColour;
&nbsp;import megamek.common.*;
&nbsp;import megamek.common.Building.BasementType;
&nbsp;import megamek.common.Building.DemolitionCharge;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.actions.AbstractAttackAction;
&nbsp;import megamek.common.actions.AirmechRamAttackAction;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.BAVibroClawAttackAction;
&nbsp;import megamek.common.actions.BreakGrappleAttackAction;
&nbsp;import megamek.common.actions.BrushOffAttackAction;
&nbsp;import megamek.common.actions.ChargeAttackAction;
&nbsp;import megamek.common.actions.ClearMinefieldAction;
&nbsp;import megamek.common.actions.ClubAttackAction;
&nbsp;import megamek.common.actions.DfaAttackAction;
&nbsp;import megamek.common.actions.DodgeAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.FindClubAction;
&nbsp;import megamek.common.actions.FlipArmsAction;
&nbsp;import megamek.common.actions.GrappleAttackAction;
&nbsp;import megamek.common.actions.JumpJetAttackAction;
&nbsp;import megamek.common.actions.KickAttackAction;
&nbsp;import megamek.common.actions.LayExplosivesAttackAction;
&nbsp;import megamek.common.actions.ProtomechPhysicalAttackAction;
&nbsp;import megamek.common.actions.PunchAttackAction;
&nbsp;import megamek.common.actions.PushAttackAction;
&nbsp;import megamek.common.actions.RamAttackAction;
&nbsp;import megamek.common.actions.RepairWeaponMalfunctionAction;
&nbsp;import megamek.common.actions.SearchlightAttackAction;
&nbsp;import megamek.common.actions.SpotAction;
&nbsp;import megamek.common.actions.TeleMissileAttackAction;
&nbsp;import megamek.common.actions.ThrashAttackAction;
&nbsp;import megamek.common.actions.TorsoTwistAction;
&nbsp;import megamek.common.actions.TriggerAPPodAction;
&nbsp;import megamek.common.actions.TriggerBPodAction;
&nbsp;import megamek.common.actions.TripAttackAction;
&nbsp;import megamek.common.actions.UnjamAction;
&nbsp;import megamek.common.actions.UnjamTurretAction;
&nbsp;import megamek.common.actions.UnloadStrandedAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.containers.PlayerIDandList;
&nbsp;import megamek.common.event.GameListener;
&nbsp;import megamek.common.event.GameVictoryEvent;
&nbsp;import megamek.common.icons.Camouflage;
&nbsp;import megamek.common.net.ConnectionFactory;
&nbsp;import megamek.common.net.ConnectionListenerAdapter;
&nbsp;import megamek.common.net.DisconnectedEvent;
&nbsp;import megamek.common.net.IConnection;
&nbsp;import megamek.common.net.Packet;
&nbsp;import megamek.common.net.PacketReceivedEvent;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.options.IBasicOption;
&nbsp;import megamek.common.options.IOption;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;import megamek.common.util.BoardUtilities;
&nbsp;import megamek.common.util.fileUtils.MegaMekFile;
&nbsp;import megamek.common.util.SerializationHelper;
&nbsp;import megamek.common.util.StringUtil;
&nbsp;import megamek.common.verifier.EntityVerifier;
&nbsp;import megamek.common.verifier.TestAero;
&nbsp;import megamek.common.verifier.TestBattleArmor;
&nbsp;import megamek.common.verifier.TestEntity;
&nbsp;import megamek.common.verifier.TestMech;
&nbsp;import megamek.common.verifier.TestSupportVehicle;
&nbsp;import megamek.common.verifier.TestTank;
&nbsp;import megamek.common.weapons.AreaEffectHelper;
&nbsp;import megamek.common.weapons.AreaEffectHelper.DamageFalloff;
&nbsp;import megamek.common.weapons.AreaEffectHelper.NukeStats;
&nbsp;import megamek.common.weapons.ArtilleryBayWeaponIndirectHomingHandler;
&nbsp;import megamek.common.weapons.ArtilleryWeaponIndirectHomingHandler;
&nbsp;import megamek.common.weapons.AttackHandler;
&nbsp;import megamek.common.weapons.CapitalMissileBearingsOnlyHandler;
&nbsp;import megamek.common.weapons.TAGHandler;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.WeaponHandler;
&nbsp;import megamek.common.weapons.infantry.InfantryWeapon;
&nbsp;import megamek.common.weapons.other.TSEMPWeapon;
&nbsp;import megamek.server.commands.AddBotCommand;
&nbsp;import megamek.server.commands.AllowTeamChangeCommand;
&nbsp;import megamek.server.commands.AssignNovaNetServerCommand;
&nbsp;import megamek.server.commands.CheckBVCommand;
&nbsp;import megamek.server.commands.CheckBVTeamCommand;
&nbsp;import megamek.server.commands.DefeatCommand;
&nbsp;import megamek.server.commands.ExportListCommand;
&nbsp;import megamek.server.commands.FixElevationCommand;
&nbsp;import megamek.server.commands.HelpCommand;
&nbsp;import megamek.server.commands.JoinTeamCommand;
&nbsp;import megamek.server.commands.KickCommand;
&nbsp;import megamek.server.commands.ListEntitiesCommand;
&nbsp;import megamek.server.commands.ListSavesCommand;
&nbsp;import megamek.server.commands.LoadGameCommand;
&nbsp;import megamek.server.commands.LocalLoadGameCommand;
&nbsp;import megamek.server.commands.LocalSaveGameCommand;
&nbsp;import megamek.server.commands.NukeCommand;
&nbsp;import megamek.server.commands.ResetCommand;
&nbsp;import megamek.server.commands.RollCommand;
&nbsp;import megamek.server.commands.RulerCommand;
&nbsp;import megamek.server.commands.SaveGameCommand;
&nbsp;import megamek.server.commands.SeeAllCommand;
&nbsp;import megamek.server.commands.ServerCommand;
&nbsp;import megamek.server.commands.ShowEntityCommand;
&nbsp;import megamek.server.commands.ShowTileCommand;
&nbsp;import megamek.server.commands.ShowValidTargetsCommand;
&nbsp;import megamek.server.commands.SkipCommand;
&nbsp;import megamek.server.commands.TeamCommand;
&nbsp;import megamek.server.commands.TraitorCommand;
&nbsp;import megamek.server.commands.VictoryCommand;
&nbsp;import megamek.server.commands.WhoCommand;
&nbsp;import megamek.server.victory.VictoryResult;
&nbsp;
&nbsp;/**
&nbsp; * @author Ben Mazur
&nbsp; */
<b class="nc">&nbsp;public class Server implements Runnable {</b>
&nbsp;    private static class EntityTargetPair {
&nbsp;        Entity ent;
&nbsp;
&nbsp;        Targetable target;
&nbsp;
<b class="nc">&nbsp;        EntityTargetPair (Entity e, Targetable t) {</b>
<b class="nc">&nbsp;            ent = e;</b>
<b class="nc">&nbsp;            target = t;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="nc">&nbsp;            if (this == o) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((null == o) || (getClass() != o.getClass())) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            final EntityTargetPair other = (EntityTargetPair) o;</b>
<b class="nc">&nbsp;            return Objects.equals(ent, other.ent) &amp;&amp; Objects.equals(target, other.target);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return Objects.hash(ent, target);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;    /**
&nbsp;     * The DamageType enumeration is used for the damageEntity function.
&nbsp;     */
<b class="nc">&nbsp;    public enum DamageType {</b>
<b class="nc">&nbsp;        NONE, FRAGMENTATION, FLECHETTE, ACID, INCENDIARY, IGNORE_PASSENGER, ANTI_TSM, ANTI_INFANTRY, NAIL_RIVET,</b>
<b class="nc">&nbsp;        NONPENETRATING</b>
&nbsp;    }
&nbsp;
&nbsp;    // public static final String LEGAL_CHARS =
&nbsp;    // &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-&quot;;
&nbsp;    private static final String DEFAULT_BOARD = MapSettings.BOARD_SURPRISE;
&nbsp;
&nbsp;    // server setup
&nbsp;    private String password;
&nbsp;
&nbsp;    private final String metaServerUrl;
&nbsp;
&nbsp;    private ServerSocket serverSocket;
&nbsp;
&nbsp;    private String motd;
&nbsp;
&nbsp;    private static class ReceivedPacket {
&nbsp;        public int connId;
&nbsp;        public Packet packet;
&nbsp;
<b class="nc">&nbsp;        ReceivedPacket(int cid, Packet p) {</b>
<b class="nc">&nbsp;            packet = p;</b>
<b class="nc">&nbsp;            connId = cid;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private class PacketPump implements Runnable {
&nbsp;
&nbsp;        boolean shouldStop;
&nbsp;
<b class="nc">&nbsp;        PacketPump() {</b>
<b class="nc">&nbsp;            shouldStop = false;</b>
&nbsp;        }
&nbsp;
&nbsp;        void signalEnd() {
<b class="nc">&nbsp;            shouldStop = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
<b class="nc">&nbsp;            while (!shouldStop) {</b>
<b class="nc">&nbsp;                while (!packetQueue.isEmpty()) {</b>
<b class="nc">&nbsp;                    ReceivedPacket rp = packetQueue.poll();</b>
<b class="nc">&nbsp;                    synchronized (serverLock) {</b>
<b class="nc">&nbsp;                        handle(rp.connId, rp.packet);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                try {
<b class="nc">&nbsp;                    synchronized (packetQueue) {</b>
<b class="nc">&nbsp;                        packetQueue.wait();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
&nbsp;                    // If we are interrupted, just keep going, generally
&nbsp;                    // this happens after we are signalled to stop.
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    // game info
<b class="nc">&nbsp;    private Vector&lt;IConnection&gt; connections = new Vector&lt;&gt;(4);</b>
&nbsp;
<b class="nc">&nbsp;    private Hashtable&lt;Integer, ConnectionHandler&gt; connectionHandlers = new Hashtable&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private final ConcurrentLinkedQueue&lt;ReceivedPacket&gt; packetQueue = new ConcurrentLinkedQueue&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Special packet queue for client feedback requests.
&nbsp;     */
<b class="nc">&nbsp;    private final ConcurrentLinkedQueue&lt;ReceivedPacket&gt; cfrPacketQueue = new ConcurrentLinkedQueue&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private Vector&lt;IConnection&gt; connectionsPending = new Vector&lt;&gt;(4);</b>
&nbsp;
<b class="nc">&nbsp;    private Hashtable&lt;Integer, IConnection&gt; connectionIds = new Hashtable&lt;&gt;();</b>
&nbsp;
&nbsp;    private int connectionCounter;
&nbsp;
<b class="nc">&nbsp;    private IGame game = new Game();</b>
&nbsp;
<b class="nc">&nbsp;    private Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;    public Vector&lt;Report&gt; getvPhaseReport() {
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private MapSettings mapSettings = MapSettings.getInstance();</b>
&nbsp;
&nbsp;    // commands
<b class="nc">&nbsp;    private Hashtable&lt;String, ServerCommand&gt; commandsHash = new Hashtable&lt;&gt;();</b>
&nbsp;
&nbsp;    // listens for and connects players
&nbsp;    private Thread connector;
&nbsp;
&nbsp;    private PacketPump packetPump;
&nbsp;    private Thread packetPumpThread;
&nbsp;
&nbsp;    // Track buildings that are affected by an entity&#39;s movement.
<b class="nc">&nbsp;    private Hashtable&lt;Building, Boolean&gt; affectedBldgs = new Hashtable&lt;&gt;();</b>
&nbsp;
&nbsp;    // Track Physical Action results, HACK to deal with opposing pushes
&nbsp;    // canceling each other
<b class="nc">&nbsp;    private Vector&lt;PhysicalResult&gt; physicalResults = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private Vector&lt;DynamicTerrainProcessor&gt; terrainProcessors = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private Timer watchdogTimer = new Timer(&quot;Watchdog Timer&quot;);</b>
&nbsp;
&nbsp;    private static EntityVerifier entityVerifier;
&nbsp;
<b class="nc">&nbsp;    private ArrayList&lt;int[]&gt; scheduledNukes = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private static Server serverInstance = null;</b>
&nbsp;
<b class="nc">&nbsp;    private String serverAccessKey = null;</b>
&nbsp;
<b class="nc">&nbsp;    private Timer serverBrowserUpdateTimer = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of what team a player requested to join.
&nbsp;     */
<b class="nc">&nbsp;    private int requestedTeam = IPlayer.TEAM_NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of what player made a request to change teams.
&nbsp;     */
<b class="nc">&nbsp;    private IPlayer playerChangingTeam = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that is set to true when all players have voted to allow another
&nbsp;     * player to change teams.
&nbsp;     */
<b class="nc">&nbsp;    private boolean changePlayersTeam = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Stores a set of &lt;code&gt;Coords&lt;/code&gt; that have changed during this phase.
&nbsp;     */
<b class="nc">&nbsp;    private Set&lt;Coords&gt; hexUpdateSet = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private List&lt;DemolitionCharge&gt; explodingCharges = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private ConnectionListenerAdapter connectionListener = new ConnectionListenerAdapter() {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Called when it is sensed that a connection has terminated.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void disconnected(DisconnectedEvent e) {
<b class="nc">&nbsp;            synchronized (serverLock) {</b>
<b class="nc">&nbsp;                IConnection conn = e.getConnection();</b>
&nbsp;
&nbsp;                // write something in the log
<b class="nc">&nbsp;                MegaMek.getLogger().info(&quot;s: connection &quot; + conn.getId() + &quot; disconnected&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                connections.removeElement(conn);</b>
<b class="nc">&nbsp;                connectionsPending.removeElement(conn);</b>
<b class="nc">&nbsp;                connectionIds.remove(conn.getId());</b>
<b class="nc">&nbsp;                ConnectionHandler ch = connectionHandlers.get(conn.getId());</b>
<b class="nc">&nbsp;                if (ch != null) {</b>
<b class="nc">&nbsp;                    ch.signalStop();</b>
<b class="nc">&nbsp;                    connectionHandlers.remove(conn.getId());</b>
&nbsp;                }
&nbsp;
&nbsp;                // if there&#39;s a player for this connection, remove it too
<b class="nc">&nbsp;                IPlayer player = getPlayer(conn.getId());</b>
<b class="nc">&nbsp;                if (null != player) {</b>
<b class="nc">&nbsp;                    Server.this.disconnected(player);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void packetReceived(PacketReceivedEvent e) {
<b class="nc">&nbsp;            ReceivedPacket rp = new ReceivedPacket(e.getConnection().getId(),</b>
<b class="nc">&nbsp;                    e.getPacket());</b>
<b class="nc">&nbsp;            int cmd = e.getPacket().getCommand();</b>
&nbsp;            // Handled CFR packets specially
<b class="nc">&nbsp;            if (cmd == Packet.COMMAND_CLIENT_FEEDBACK_REQUEST) {</b>
<b class="nc">&nbsp;                synchronized (cfrPacketQueue) {</b>
<b class="nc">&nbsp;                    cfrPacketQueue.add(rp);</b>
<b class="nc">&nbsp;                    cfrPacketQueue.notifyAll();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            // Some packets should be handled immediately
<b class="nc">&nbsp;            } else if ((cmd == Packet.COMMAND_CLOSE_CONNECTION)</b>
&nbsp;                    || (cmd == Packet.COMMAND_CLIENT_NAME)
&nbsp;                    || (cmd == Packet.COMMAND_CLIENT_VERSIONS)
&nbsp;                    || (cmd == Packet.COMMAND_CHAT)) {
<b class="nc">&nbsp;                handle(rp.connId, rp.packet);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                synchronized (packetQueue) {</b>
<b class="nc">&nbsp;                    packetQueue.add(rp);</b>
<b class="nc">&nbsp;                    packetQueue.notifyAll();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * Used to ensure only one thread at a time is accessing this particular
&nbsp;     * instance of the server.
&nbsp;     */
<b class="nc">&nbsp;    private final Object serverLock = new Object();</b>
&nbsp;
&nbsp;    public Server(String password, int port) throws IOException {
<b class="nc">&nbsp;        this(password, port, false, &quot;&quot;);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new GameHost and begin listening for incoming clients.
&nbsp;     *
&nbsp;     * @param password                  the &lt;code&gt;String&lt;/code&gt; that is set as a password
&nbsp;     * @param port                      the &lt;code&gt;int&lt;/code&gt; value that specifies the port that is
&nbsp;     *                                  used
&nbsp;     * @param registerWithServerBrowser a &lt;code&gt;boolean&lt;/code&gt; indicating whether we should register
&nbsp;     *                                  with the master server browser on megamek.info
&nbsp;     */
&nbsp;    public Server(String password, int port, boolean registerWithServerBrowser,
<b class="nc">&nbsp;                  String metaServerUrl) throws IOException {</b>
<b class="nc">&nbsp;        this.metaServerUrl = metaServerUrl;</b>
<b class="nc">&nbsp;        this.password = password.length() &gt; 0 ? password : null;</b>
&nbsp;        // initialize server socket
<b class="nc">&nbsp;        serverSocket = new ServerSocket(port);</b>
&nbsp;
<b class="nc">&nbsp;        motd = createMotd();</b>
&nbsp;
<b class="nc">&nbsp;        game.getOptions().initialize();</b>
<b class="nc">&nbsp;        game.getOptions().loadOptions();</b>
&nbsp;
<b class="nc">&nbsp;        changePhase(IGame.Phase.PHASE_LOUNGE);</b>
&nbsp;
&nbsp;        // display server start text
<b class="nc">&nbsp;        MegaMek.getLogger().info(&quot;s: starting a new server...&quot;);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc">&nbsp;            String host = InetAddress.getLocalHost().getHostName();</b>
<b class="nc">&nbsp;            sb.append(&quot;s: hostname = &#39;&quot;);</b>
<b class="nc">&nbsp;            sb.append(host);</b>
<b class="nc">&nbsp;            sb.append(&quot;&#39; port = &quot;);</b>
<b class="nc">&nbsp;            sb.append(serverSocket.getLocalPort());</b>
<b class="nc">&nbsp;            sb.append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;            InetAddress[] addresses = InetAddress.getAllByName(host);</b>
<b class="nc">&nbsp;            for (InetAddress address : addresses) {</b>
<b class="nc">&nbsp;                sb.append(&quot;s: hosting on address = &quot;);</b>
<b class="nc">&nbsp;                sb.append(address.getHostAddress());</b>
<b class="nc">&nbsp;                sb.append(&quot;\n&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            MegaMek.getLogger().info(sb.toString());</b>
<b class="nc">&nbsp;        } catch (UnknownHostException ignored) {</b>
&nbsp;            // oh well.
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        MegaMek.getLogger().info(&quot;s: password = &quot; + this.password);</b>
&nbsp;
&nbsp;        // register commands
<b class="nc">&nbsp;        registerCommand(new DefeatCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ExportListCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new FixElevationCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new HelpCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new KickCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ListSavesCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new LocalSaveGameCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new LocalLoadGameCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ResetCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new RollCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new SaveGameCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new LoadGameCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new SeeAllCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new SkipCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new VictoryCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new WhoCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new TeamCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ShowTileCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ShowEntityCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new RulerCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ShowValidTargetsCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new AddBotCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new CheckBVCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new CheckBVTeamCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new NukeCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new TraitorCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new ListEntitiesCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new AssignNovaNetServerCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new AllowTeamChangeCommand(this));</b>
<b class="nc">&nbsp;        registerCommand(new JoinTeamCommand(this));</b>
&nbsp;
&nbsp;        // register terrain processors
<b class="nc">&nbsp;        terrainProcessors.add(new FireProcessor(this));</b>
<b class="nc">&nbsp;        terrainProcessors.add(new SmokeProcessor(this));</b>
<b class="nc">&nbsp;        terrainProcessors.add(new GeyserProcessor(this));</b>
<b class="nc">&nbsp;        terrainProcessors.add(new ElevatorProcessor(this));</b>
<b class="nc">&nbsp;        terrainProcessors.add(new ScreenProcessor(this));</b>
<b class="nc">&nbsp;        terrainProcessors.add(new WeatherProcessor(this));</b>
<b class="nc">&nbsp;        terrainProcessors.add(new QuicksandProcessor(this));</b>
&nbsp;
<b class="nc">&nbsp;        packetPump = new PacketPump();</b>
<b class="nc">&nbsp;        packetPumpThread = new Thread(packetPump, &quot;Packet Pump&quot;);</b>
<b class="nc">&nbsp;        packetPumpThread.start();</b>
&nbsp;
<b class="nc">&nbsp;        if (registerWithServerBrowser) {</b>
&nbsp;
<b class="nc">&nbsp;            final TimerTask register = new TimerTask() {</b>
&nbsp;                @Override
&nbsp;                public void run() {
<b class="nc">&nbsp;                    registerWithServerBrowser(true,</b>
<b class="nc">&nbsp;                                              Server.getServerInstance().metaServerUrl);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            };
<b class="nc">&nbsp;            serverBrowserUpdateTimer = new Timer(</b>
&nbsp;                    &quot;Server Browser Register Timer&quot;, true);
<b class="nc">&nbsp;            serverBrowserUpdateTimer.schedule(register, 1, 40000);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Fully initialised, now accept connections
<b class="nc">&nbsp;        connector = new Thread(this, &quot;Connection Listener&quot;);</b>
<b class="nc">&nbsp;        connector.start();</b>
&nbsp;
<b class="nc">&nbsp;        serverInstance = this;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the game for this server. Restores any transient fields, and sets
&nbsp;     * all players as ghosts. This should only be called during server
&nbsp;     * initialization before any players have connected.
&nbsp;     */
&nbsp;    public void setGame(IGame g) {
&nbsp;        // game listeners are transient so we need to save and restore them
<b class="nc">&nbsp;        Vector&lt;GameListener&gt; gameListenersClone = new Vector&lt;&gt;(getGame().getGameListeners());</b>
&nbsp;
<b class="nc">&nbsp;        game = g;</b>
&nbsp;
<b class="nc">&nbsp;        for (GameListener listener : gameListenersClone) {</b>
<b class="nc">&nbsp;            getGame().addGameListener(listener);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Integer&gt; orphanEntities = new ArrayList&lt;&gt;();</b>
&nbsp;                
&nbsp;        // reattach the transient fields and ghost the players
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity ent = e.next();</b>
<b class="nc">&nbsp;            ent.setGame(game);</b>
&nbsp;            
<b class="nc">&nbsp;            if(ent.getOwner() == null) {</b>
<b class="nc">&nbsp;                orphanEntities.add(ent.getId());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (ent instanceof Mech) {</b>
<b class="nc">&nbsp;                ((Mech) ent).setBAGrabBars();</b>
<b class="nc">&nbsp;                ((Mech) ent).setProtomechClampMounts();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ent instanceof Tank) {</b>
<b class="nc">&nbsp;                ((Tank) ent).setBAGrabBars();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        game.removeEntities(orphanEntities, IEntityRemovalConditions.REMOVE_UNKNOWN);</b>
&nbsp;        
<b class="nc">&nbsp;        game.setOutOfGameEntitiesVector(game.getOutOfGameEntitiesVector());</b>
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; e = game.getPlayers(); e.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IPlayer p = e.nextElement();</b>
<b class="nc">&nbsp;            p.setGame(game);</b>
<b class="nc">&nbsp;            p.setGhost(true);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // might need to restore weapon type for some attacks that take multiple
&nbsp;        // turns (like artillery)
<b class="nc">&nbsp;        for (Enumeration&lt;AttackHandler&gt; a = game.getAttacks(); a</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            AttackHandler handler = a.nextElement();</b>
<b class="nc">&nbsp;            if (handler instanceof WeaponHandler) {</b>
<b class="nc">&nbsp;                ((WeaponHandler) handler).restore();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current game object
&nbsp;     */
&nbsp;    public IGame getGame() {
<b class="nc">&nbsp;        return game;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Make a default message o&#39; the day containing the version string, and if
&nbsp;     * it was found, the build timestamp
&nbsp;     */
&nbsp;    private String createMotd() {
<b class="nc">&nbsp;        StringBuilder motd = new StringBuilder();</b>
<b class="nc">&nbsp;        motd.append(&quot;Welcome to MegaMek.  Server is running version &quot;).append(MegaMek.VERSION)</b>
<b class="nc">&nbsp;                .append(&quot;, build date &quot;);</b>
<b class="nc">&nbsp;        if (MegaMek.TIMESTAMP &gt; 0L) {</b>
<b class="nc">&nbsp;            motd.append(new Date(MegaMek.TIMESTAMP).toString());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            motd.append(&quot;unknown&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        motd.append(&#39;.&#39;);</b>
&nbsp;
<b class="nc">&nbsp;        return motd.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if the server has a password
&nbsp;     */
&nbsp;    public boolean isPassworded() {
<b class="nc">&nbsp;        return password != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if the password matches
&nbsp;     */
&nbsp;    public boolean isPassword(Object guess) {
<b class="nc">&nbsp;        return password.equals(guess);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Registers a new command in the server command table
&nbsp;     */
&nbsp;    private void registerCommand(ServerCommand command) {
<b class="nc">&nbsp;        commandsHash.put(command.getName(), command);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the command associated with the specified name
&nbsp;     */
&nbsp;    public ServerCommand getCommand(String name) {
<b class="nc">&nbsp;        return commandsHash.get(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shuts down the server.
&nbsp;     */
&nbsp;    public void die() {
<b class="nc">&nbsp;        watchdogTimer.cancel();</b>
&nbsp;
&nbsp;        // kill thread accepting new connections
<b class="nc">&nbsp;        connector = null;</b>
<b class="nc">&nbsp;        packetPump.signalEnd();</b>
<b class="nc">&nbsp;        packetPumpThread.interrupt();</b>
<b class="nc">&nbsp;        packetPumpThread = null;</b>
&nbsp;
&nbsp;        // close socket
&nbsp;        try {
<b class="nc">&nbsp;            serverSocket.close();</b>
<b class="nc">&nbsp;        } catch (IOException ignored) {</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // kill pending connections
<b class="nc">&nbsp;        for (Enumeration&lt;IConnection&gt; connEnum = connectionsPending.elements(); connEnum</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IConnection conn = connEnum.nextElement();</b>
<b class="nc">&nbsp;            conn.close();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        connectionsPending.removeAllElements();</b>
&nbsp;
&nbsp;        // Send &quot;kill&quot; commands to all connections
&nbsp;        // N.B. I may be starting a race here.
<b class="nc">&nbsp;        for (Enumeration&lt;IConnection&gt; connEnum = connections.elements(); connEnum.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IConnection conn = connEnum.nextElement();</b>
<b class="nc">&nbsp;            send(conn.getId(), new Packet(Packet.COMMAND_CLOSE_CONNECTION));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // kill active connections
<b class="nc">&nbsp;        for (Enumeration&lt;IConnection&gt; connEnum = connections.elements(); connEnum.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IConnection conn = connEnum.nextElement();</b>
<b class="nc">&nbsp;            conn.close();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        connections.removeAllElements();</b>
<b class="nc">&nbsp;        connectionIds.clear();</b>
<b class="nc">&nbsp;        if (serverBrowserUpdateTimer != null) {</b>
<b class="nc">&nbsp;            serverBrowserUpdateTimer.cancel();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!metaServerUrl.equals(&quot;&quot;)) {</b>
<b class="nc">&nbsp;            registerWithServerBrowser(false, metaServerUrl);</b>
&nbsp;        }
&nbsp;
&nbsp;        // TODO : Not sure that this still needs to be here after updating to the new logging methods.
<b class="nc">&nbsp;        System.out.flush();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of all the command names
&nbsp;     */
&nbsp;    public Enumeration&lt;String&gt; getAllCommandNames() {
<b class="nc">&nbsp;        return commandsHash.keys();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sent when a client attempts to connect.
&nbsp;     */
&nbsp;    void greeting(int cn) {
&nbsp;        // send server greeting -- client should reply with client info.
<b class="nc">&nbsp;        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_GREETING));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a free connection id.
&nbsp;     */
&nbsp;    public int getFreeConnectionId() {
<b class="nc">&nbsp;        while ((getPendingConnection(connectionCounter) != null)</b>
<b class="nc">&nbsp;               || (getConnection(connectionCounter) != null)</b>
<b class="nc">&nbsp;               || (getPlayer(connectionCounter) != null)) {</b>
<b class="nc">&nbsp;            connectionCounter++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return connectionCounter;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a free entity id. Perhaps this should be in Game instead.
&nbsp;     */
&nbsp;    public int getFreeEntityId() {
<b class="nc">&nbsp;        return game.getNextEntityId();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allow the player to set whatever parameters he is able to
&nbsp;     */
&nbsp;    private void receivePlayerInfo(Packet packet, int connId) {
<b class="nc">&nbsp;        IPlayer player = (IPlayer) packet.getObject(0);</b>
<b class="nc">&nbsp;        IPlayer gamePlayer = game.getPlayer(connId);</b>
<b class="nc">&nbsp;        if (null != gamePlayer) {</b>
<b class="nc">&nbsp;            gamePlayer.setColour(player.getColour());</b>
<b class="nc">&nbsp;            gamePlayer.setStartingPos(player.getStartingPos());</b>
<b class="nc">&nbsp;            gamePlayer.setTeam(player.getTeam());</b>
<b class="nc">&nbsp;            gamePlayer.setCamoCategory(player.getCamoCategory());</b>
<b class="nc">&nbsp;            gamePlayer.setCamoFileName(player.getCamoFileName());</b>
<b class="nc">&nbsp;            gamePlayer.setNbrMFConventional(player.getNbrMFConventional());</b>
<b class="nc">&nbsp;            gamePlayer.setNbrMFCommand(player.getNbrMFCommand());</b>
<b class="nc">&nbsp;            gamePlayer.setNbrMFVibra(player.getNbrMFVibra());</b>
<b class="nc">&nbsp;            gamePlayer.setNbrMFActive(player.getNbrMFActive());</b>
<b class="nc">&nbsp;            gamePlayer.setNbrMFInferno(player.getNbrMFInferno());</b>
<b class="nc">&nbsp;            if (gamePlayer.getConstantInitBonus()</b>
<b class="nc">&nbsp;                != player.getConstantInitBonus()) {</b>
<b class="nc">&nbsp;                sendServerChat(&quot;Player &quot; + gamePlayer.getName()</b>
&nbsp;                               + &quot; changed their initiative bonus from &quot;
<b class="nc">&nbsp;                               + gamePlayer.getConstantInitBonus()</b>
<b class="nc">&nbsp;                               + &quot; to &quot; + player.getConstantInitBonus() + &quot;.&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            gamePlayer.setConstantInitBonus(player.getConstantInitBonus());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Correct a duplicate player name
&nbsp;     *
&nbsp;     * @param oldName the &lt;code&gt;String&lt;/code&gt; old player name, that is a duplicate
&nbsp;     * @return the &lt;code&gt;String&lt;/code&gt; new player name
&nbsp;     */
&nbsp;    private String correctDupeName(String oldName) {
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;            if (player.getName().equals(oldName)) {</b>
&nbsp;                // We need to correct it.
<b class="nc">&nbsp;                String newName = oldName;</b>
&nbsp;                int dupNum;
&nbsp;                try {
<b class="nc">&nbsp;                    dupNum = Integer.parseInt(oldName.substring(oldName.lastIndexOf(&quot;.&quot;) + 1));</b>
<b class="nc">&nbsp;                    dupNum++;</b>
<b class="nc">&nbsp;                    newName = oldName.substring(0, oldName.lastIndexOf(&quot;.&quot;));</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
&nbsp;                    // If this fails, we don&#39;t care much.
&nbsp;                    // Just assume it&#39;s the first time for this name.
<b class="nc">&nbsp;                    dupNum = 2;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                newName = newName.concat(&quot;.&quot;).concat(Integer.toString(dupNum));</b>
<b class="nc">&nbsp;                return correctDupeName(newName);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return oldName;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void receivePlayerVersion(Packet packet, int connId) {
<b class="nc">&nbsp;        String version = (String) packet.getObject(0);</b>
<b class="nc">&nbsp;        String clientChecksum = (String) packet.getObject(1);</b>
<b class="nc">&nbsp;        String serverChecksum = MegaMek.getMegaMekSHA256();</b>
<b class="nc">&nbsp;        StringBuilder buf = new StringBuilder();</b>
<b class="nc">&nbsp;        boolean needs = false;</b>
<b class="nc">&nbsp;        if (!version.equals(MegaMek.VERSION)) {</b>
<b class="nc">&nbsp;            buf.append(&quot;Client/Server version mismatch. Server reports: &quot;).append(MegaMek.VERSION)</b>
<b class="nc">&nbsp;                    .append(&quot;, Client reports: &quot;).append(version);</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Client/Server Version Mismatch -- Client: &quot; </b>
&nbsp;                    + version + &quot; Server: &quot; + MegaMek.VERSION);
<b class="nc">&nbsp;            needs = true;</b>
&nbsp;        }
&nbsp;        // print a message indicating client doesn&#39;t have jar file
<b class="nc">&nbsp;        if (clientChecksum == null) {</b>
<b class="nc">&nbsp;            if (!version.equals(MegaMek.VERSION)) {</b>
<b class="nc">&nbsp;                buf.append(System.lineSeparator()).append(System.lineSeparator());</b>
&nbsp;            }
<b class="nc">&nbsp;            buf.append(&quot;Client Checksum is null. Client may not have a jar file&quot;);</b>
<b class="nc">&nbsp;            MegaMek.getLogger().info(&quot;Client does not have a jar file&quot;);</b>
<b class="nc">&nbsp;            needs = true;</b>
&nbsp;        // print message indicating server doesn&#39;t have jar file
<b class="nc">&nbsp;        } else if (serverChecksum == null) {</b>
<b class="nc">&nbsp;            if (!version.equals(MegaMek.VERSION)) {</b>
<b class="nc">&nbsp;                buf.append(System.lineSeparator()).append(System.lineSeparator());</b>
&nbsp;            }
<b class="nc">&nbsp;            buf.append(&quot;Server Checksum is null. Server may not have a jar file&quot;);</b>
<b class="nc">&nbsp;            MegaMek.getLogger().info(&quot;Server does not have a jar file&quot;);</b>
<b class="nc">&nbsp;            needs = true;</b>
&nbsp;        // print message indicating a client/server checksum mismatch
<b class="nc">&nbsp;        } else if (!clientChecksum.equals(serverChecksum)) {</b>
<b class="nc">&nbsp;            if (!version.equals(MegaMek.VERSION)) {</b>
<b class="nc">&nbsp;                buf.append(System.lineSeparator());</b>
<b class="nc">&nbsp;                buf.append(System.lineSeparator());</b>
&nbsp;            }
<b class="nc">&nbsp;            buf.append(&quot;Client/Server checksum mismatch. Server reports: &quot;).append(serverChecksum)</b>
<b class="nc">&nbsp;                    .append(&quot;, Client reports: &quot;).append(clientChecksum);</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Client/Server Checksum Mismatch -- Client: &quot; + clientChecksum </b>
&nbsp;                    + &quot; Server: &quot; + serverChecksum);
&nbsp;
<b class="nc">&nbsp;            needs = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now, if we need to, send message!
<b class="nc">&nbsp;        if (needs) {</b>
<b class="nc">&nbsp;            IPlayer player = getPlayer(connId);</b>
<b class="nc">&nbsp;            if (null != player) {</b>
<b class="nc">&nbsp;                sendServerChat(&quot;For &quot; + player.getName() + &quot; Server reports:&quot;</b>
<b class="nc">&nbsp;                        + System.lineSeparator()</b>
<b class="nc">&nbsp;                        + buf.toString());</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().info(&quot;SUCCESS: Client/Server Version (&quot; + version + &quot;) and Checksum (&quot; </b>
&nbsp;                    + clientChecksum + &quot;) matched&quot;);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receives a player name, sent from a pending connection, and connects that
&nbsp;     * connection.
&nbsp;     */
&nbsp;    private void receivePlayerName(Packet packet, int connId) {
<b class="nc">&nbsp;        final IConnection conn = getPendingConnection(connId);</b>
<b class="nc">&nbsp;        String name = (String) packet.getObject(0);</b>
<b class="nc">&nbsp;        boolean returning = false;</b>
&nbsp;
&nbsp;        // this had better be from a pending connection
<b class="nc">&nbsp;        if (conn == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().warning(&quot;Got a client name from a non-pending connection&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check if they&#39;re connecting with the same name as a ghost player
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;            if (player.getName().equals(name)) {</b>
<b class="nc">&nbsp;                if (player.isGhost()) {</b>
<b class="nc">&nbsp;                    returning = true;</b>
<b class="nc">&nbsp;                    player.setGhost(false);</b>
&nbsp;                    // switch id
<b class="nc">&nbsp;                    connId = player.getId();</b>
<b class="nc">&nbsp;                    conn.setId(connId);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (!returning) {</b>
&nbsp;            // Check to avoid duplicate names...
<b class="nc">&nbsp;            name = correctDupeName(name);</b>
<b class="nc">&nbsp;            sendToPending(connId, new Packet(Packet.COMMAND_SERVER_CORRECT_NAME, name));</b>
&nbsp;        }
&nbsp;
&nbsp;        // right, switch the connection into the &quot;active&quot; bin
<b class="nc">&nbsp;        connectionsPending.removeElement(conn);</b>
<b class="nc">&nbsp;        connections.addElement(conn);</b>
<b class="nc">&nbsp;        connectionIds.put(conn.getId(), conn);</b>
&nbsp;
&nbsp;        // add and validate the player info
<b class="nc">&nbsp;        if (!returning) {</b>
<b class="nc">&nbsp;            addNewPlayer(connId, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if it is not the lounge phase, this player becomes an observer
<b class="nc">&nbsp;        IPlayer player = getPlayer(connId);</b>
<b class="nc">&nbsp;        if ((game.getPhase() != IGame.Phase.PHASE_LOUNGE) &amp;&amp; (null != player)</b>
<b class="nc">&nbsp;            &amp;&amp; (game.getEntitiesOwnedBy(player) &lt; 1)) {</b>
<b class="nc">&nbsp;            player.setObserver(true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // send the player the motd
<b class="nc">&nbsp;        sendServerChat(connId, motd);</b>
&nbsp;
&nbsp;        // send info that the player has connected
<b class="nc">&nbsp;        send(createPlayerConnectPacket(connId));</b>
&nbsp;
&nbsp;        // tell them their local playerId
<b class="nc">&nbsp;        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, connId));</b>
&nbsp;
&nbsp;        // send current game info
<b class="nc">&nbsp;        sendCurrentInfo(connId);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            InetAddress[] addresses = InetAddress.getAllByName(InetAddress</b>
<b class="nc">&nbsp;                    .getLocalHost().getHostName());</b>
<b class="nc">&nbsp;            for (InetAddress addresse : addresses) {</b>
<b class="nc">&nbsp;                sendServerChat(connId,</b>
<b class="nc">&nbsp;                               &quot;Machine IP is &quot; + addresse.getHostAddress());</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (UnknownHostException e) {</b>
&nbsp;            // oh well.
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Send the port we&#39;re listening on. Only useful for the player
&nbsp;        // on the server machine to check.
<b class="nc">&nbsp;        sendServerChat(connId,</b>
<b class="nc">&nbsp;                       &quot;Listening on port &quot; + serverSocket.getLocalPort());</b>
&nbsp;
&nbsp;        // Get the player *again*, because they may have disconnected.
<b class="nc">&nbsp;        player = getPlayer(connId);</b>
<b class="nc">&nbsp;        if (null != player) {</b>
<b class="nc">&nbsp;            String who = player.getName() + &quot; connected from &quot; + getClient(connId).getInetAddress();</b>
<b class="nc">&nbsp;            MegaMek.getLogger().info(&quot;s: player #&quot; + connId + &quot;, &quot; + who);</b>
<b class="nc">&nbsp;            sendServerChat(who);</b>
&nbsp;
&nbsp;        } // Found the player
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends a player the info they need to look at the current phase. This is
&nbsp;     * triggered when a player first connects to the server.
&nbsp;     */
&nbsp;    public void sendCurrentInfo(int connId) {
&nbsp;        // why are these two outside the player != null check below?
<b class="nc">&nbsp;        transmitAllPlayerConnects(connId);</b>
<b class="nc">&nbsp;        send(connId, createGameSettingsPacket());</b>
<b class="nc">&nbsp;        send(connId, createPlanetaryConditionsPacket());</b>
&nbsp;
<b class="nc">&nbsp;        IPlayer player = game.getPlayer(connId);</b>
<b class="nc">&nbsp;        if (null != player) {</b>
<b class="nc">&nbsp;            send(connId,</b>
&nbsp;                 new Packet(Packet.COMMAND_SENDING_MINEFIELDS, player
<b class="nc">&nbsp;                         .getMinefields()));</b>
&nbsp;
<b class="nc">&nbsp;            if (game.getPhase() == Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;                send(connId, createMapSettingsPacket());</b>
<b class="nc">&nbsp;                send(createMapSizesPacket());</b>
&nbsp;                // Send Entities *after* the Lounge Phase Change
<b class="nc">&nbsp;                send(connId,</b>
<b class="nc">&nbsp;                        new Packet(Packet.COMMAND_PHASE_CHANGE, game.getPhase()));</b>
<b class="nc">&nbsp;                if (doBlind()) {</b>
<b class="nc">&nbsp;                    send(connId, createFilteredFullEntitiesPacket(player));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    send(connId, createFullEntitiesPacket());</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                send(connId, new Packet(Packet.COMMAND_ROUND_UPDATE, game.getRoundCount()));</b>
<b class="nc">&nbsp;                send(connId, createBoardPacket());</b>
<b class="nc">&nbsp;                send(connId, createAllReportsPacket(player));</b>
&nbsp;
&nbsp;                // Send entities *before* other phase changes.
<b class="nc">&nbsp;                if (doBlind()) {</b>
<b class="nc">&nbsp;                    send(connId, createFilteredFullEntitiesPacket(player));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    send(connId, createFullEntitiesPacket());</b>
&nbsp;                }
<b class="nc">&nbsp;                player.setDone(game.getEntitiesOwnedBy(player) &lt;= 0);</b>
<b class="nc">&nbsp;                send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE, game.getPhase()));</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((game.getPhase() == IGame.Phase.PHASE_FIRING)</b>
<b class="nc">&nbsp;                    || (game.getPhase() == IGame.Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                    || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)</b>
<b class="nc">&nbsp;                    || (game.getPhase() == IGame.Phase.PHASE_PHYSICAL)) {</b>
&nbsp;                // can&#39;t go above, need board to have been sent
<b class="nc">&nbsp;                send(connId, createAttackPacket(game.getActionsVector(), 0));</b>
<b class="nc">&nbsp;                send(connId, createAttackPacket(game.getChargesVector(), 1));</b>
<b class="nc">&nbsp;                send(connId, createAttackPacket(game.getRamsVector(), 1));</b>
<b class="nc">&nbsp;                send(connId, createAttackPacket(game.getTeleMissileAttacksVector(), 1));</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (game.phaseHasTurns(game.getPhase()) &amp;&amp; game.hasMoreTurns()) {</b>
<b class="nc">&nbsp;                send(connId, createTurnVectorPacket());</b>
<b class="nc">&nbsp;                send(connId, createTurnIndexPacket(connId));</b>
<b class="nc">&nbsp;            } else if (game.getPhase() != IGame.Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;                endCurrentPhase();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            send(connId, createArtilleryPacket(player));</b>
<b class="nc">&nbsp;            send(connId, createFlarePacket());</b>
<b class="nc">&nbsp;            send(connId, createSpecialHexDisplayPacket(connId));</b>
&nbsp;
&nbsp;        } // Found the player.
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resend entities to the player called by SeeAll command
&nbsp;     */
&nbsp;    public void sendEntities(int connId) {
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            send(connId, createFilteredEntitiesPacket(getPlayer(connId), null));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            send(connId, createEntitiesPacket());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a new player to the game
&nbsp;     */
&nbsp;    private IPlayer addNewPlayer(int connId, String name) {
<b class="nc">&nbsp;        int team = IPlayer.TEAM_UNASSIGNED;</b>
<b class="nc">&nbsp;        if (game.getPhase() == Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;            team = IPlayer.TEAM_NONE;</b>
<b class="nc">&nbsp;            for (IPlayer p : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;                if (p.getTeam() &gt; team) {</b>
<b class="nc">&nbsp;                    team = p.getTeam();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            team++;</b>
&nbsp;        }
<b class="nc">&nbsp;        IPlayer newPlayer = new Player(connId, name);</b>
<b class="nc">&nbsp;        PlayerColour colour = newPlayer.getColour();</b>
<b class="nc">&nbsp;        Enumeration&lt;IPlayer&gt; players = game.getPlayers();</b>
<b class="nc">&nbsp;        final PlayerColour[] colours = PlayerColour.values();</b>
<b class="nc">&nbsp;        while (players.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final IPlayer p = players.nextElement();</b>
<b class="nc">&nbsp;            if (p.getId() == newPlayer.getId()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((p.getColour() == colour) &amp;&amp; (colours.length &gt; (colour.ordinal() + 1))) {</b>
<b class="nc">&nbsp;                colour = colours[colour.ordinal() + 1];</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        newPlayer.setColour(colour);</b>
<b class="nc">&nbsp;        newPlayer.setCamoCategory(Camouflage.COLOUR_CAMOUFLAGE);</b>
<b class="nc">&nbsp;        newPlayer.setCamoFileName(colour.name());</b>
<b class="nc">&nbsp;        newPlayer.setTeam(Math.min(team, 5));</b>
<b class="nc">&nbsp;        game.addPlayer(connId, newPlayer);</b>
<b class="nc">&nbsp;        validatePlayerInfo(connId);</b>
<b class="nc">&nbsp;        return newPlayer;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Validates the player info.
&nbsp;     */
&nbsp;    public void validatePlayerInfo(int playerId) {
<b class="nc">&nbsp;        final IPlayer player = getPlayer(playerId);</b>
&nbsp;
<b class="nc">&nbsp;        if (player != null) {</b>
&nbsp;            // TODO : check for duplicate or reserved names
&nbsp;
&nbsp;            // Colour Assignment
<b class="nc">&nbsp;            final PlayerColour[] playerColours = PlayerColour.values();</b>
<b class="nc">&nbsp;            boolean allUsed = true;</b>
<b class="nc">&nbsp;            Set&lt;PlayerColour&gt; colourUtilization = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                final IPlayer otherPlayer = i.nextElement();</b>
<b class="nc">&nbsp;                if (otherPlayer.getId() != playerId) {</b>
<b class="nc">&nbsp;                    colourUtilization.add(otherPlayer.getColour());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    allUsed = false;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (!allUsed &amp;&amp; colourUtilization.contains(player.getColour())) {</b>
<b class="nc">&nbsp;                for (PlayerColour colour : playerColours) {</b>
<b class="nc">&nbsp;                    if (!colourUtilization.contains(colour)) {</b>
<b class="nc">&nbsp;                        player.setColour(colour);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called when it&#39;s been determined that an actual player disconnected.
&nbsp;     * Notifies the other players and does the appropriate housekeeping.
&nbsp;     */
&nbsp;    void disconnected(IPlayer player) {
<b class="nc">&nbsp;        IGame.Phase phase = game.getPhase();</b>
&nbsp;
&nbsp;        // in the lounge, just remove all entities for that player
<b class="nc">&nbsp;        if (phase == IGame.Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;            removeAllEntitiesOwnedBy(player);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if a player has active entities, he becomes a ghost
&nbsp;        // except the VICTORY_PHASE when the disconnected
&nbsp;        // player is most likely the Bot disconnected after receiving
&nbsp;        // the COMMAND_END_OF_GAME command
&nbsp;        // see the Bug 1225949.
&nbsp;        // Ghost players (Bots mostly) are now removed during the
&nbsp;        // resetGame(), so we don&#39;t need to do it here.
&nbsp;        // This fixes Bug 3399000 without reintroducing 1225949
<b class="nc">&nbsp;        if ((phase == IGame.Phase.PHASE_VICTORY)</b>
<b class="nc">&nbsp;            || (phase == IGame.Phase.PHASE_LOUNGE) || player.isObserver()) {</b>
<b class="nc">&nbsp;            game.removePlayer(player.getId());</b>
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, player.getId()));</b>
&nbsp;            // Prevent situation where all players but the disconnected one
&nbsp;            // are done, and the disconnecting player causes the game to start
<b class="nc">&nbsp;            if (phase == IGame.Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;                resetActivePlayersDone();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            player.setGhost(true);</b>
<b class="nc">&nbsp;            player.setDone(true);</b>
<b class="nc">&nbsp;            send(createPlayerUpdatePacket(player.getId()));</b>
&nbsp;        }
&nbsp;
&nbsp;        // make sure the game advances
<b class="nc">&nbsp;        if (game.phaseHasTurns(game.getPhase()) &amp;&amp; (null != game.getTurn())) {</b>
<b class="nc">&nbsp;            if (game.getTurn().isValid(player.getId(), game)) {</b>
<b class="nc">&nbsp;                sendGhostSkipMessage(player);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            checkReady();</b>
&nbsp;        }
&nbsp;
&nbsp;        // notify other players
<b class="nc">&nbsp;        sendServerChat(player.getName() + &quot; disconnected.&quot;);</b>
&nbsp;
&nbsp;        // log it
<b class="nc">&nbsp;        MegaMek.getLogger().info(&quot;s: removed player &quot; + player.getName());</b>
&nbsp;
&nbsp;        // Reset the game after Elvis has left the building.
<b class="nc">&nbsp;        if (0 == game.getNoOfPlayers()) {</b>
<b class="nc">&nbsp;            resetGame();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks each player to see if he has no entities, and if true, sets the
&nbsp;     * observer flag for that player. An exception is that there are no
&nbsp;     * observers during the lounge phase.
&nbsp;     */
&nbsp;    public void checkForObservers() {
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; e = game.getPlayers(); e.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IPlayer p = e.nextElement();</b>
<b class="nc">&nbsp;            p.setObserver((game.getEntitiesOwnedBy(p) &lt; 1)</b>
<b class="nc">&nbsp;                          &amp;&amp; (game.getPhase() != IGame.Phase.PHASE_LOUNGE));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Reset the game back to the lounge.
&nbsp;     * TODO : couldn&#39;t this be a hazard if there are other things executing at the same time?
&nbsp;     */
&nbsp;    public void resetGame() {
&nbsp;        // remove all entities
<b class="nc">&nbsp;        game.reset();</b>
<b class="nc">&nbsp;        send(createEntitiesPacket());</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SENDING_MINEFIELDS, new Vector&lt;&gt;()));</b>
&nbsp;
&nbsp;        // remove ghosts
<b class="nc">&nbsp;        List&lt;IPlayer&gt; ghosts = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; players = game.getPlayers(); players.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IPlayer p = players.nextElement();</b>
<b class="nc">&nbsp;            if (p.isGhost()) {</b>
<b class="nc">&nbsp;                ghosts.add(p);</b>
&nbsp;            } else {
&nbsp;                // non-ghosts set their starting positions to any
<b class="nc">&nbsp;                p.setStartingPos(Board.START_ANY);</b>
<b class="nc">&nbsp;                send(createPlayerUpdatePacket(p.getId()));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (IPlayer p : ghosts) {</b>
<b class="nc">&nbsp;            game.removePlayer(p.getId());</b>
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, p.getId()));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // reset all players
<b class="nc">&nbsp;        resetPlayersDone();</b>
<b class="nc">&nbsp;        transmitAllPlayerDones();</b>
&nbsp;
&nbsp;        // Write end of game to stdout so controlling scripts can rotate logs.
<b class="nc">&nbsp;        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss z&quot;);</b>
<b class="nc">&nbsp;        MegaMek.getLogger().info(format.format(new Date()) + &quot; END OF GAME&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        changePhase(IGame.Phase.PHASE_LOUNGE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * automatically save the game
&nbsp;     */
&nbsp;    public void autoSave() {
<b class="nc">&nbsp;        String fileName = &quot;autosave&quot;;</b>
<b class="nc">&nbsp;        if (PreferenceManager.getClientPreferences().stampFilenames()) {</b>
<b class="nc">&nbsp;            fileName = StringUtil.addDateTimeStamp(fileName);</b>
&nbsp;        }
<b class="nc">&nbsp;        saveGame(fileName, game.getOptions().booleanOption(OptionsConstants.BASE_AUTOSAVE_MSG));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * save the game and send it to the specified connection
&nbsp;     *
&nbsp;     * @param connId     The &lt;code&gt;int&lt;/code&gt; connection id to send to
&nbsp;     * @param sFile      The &lt;code&gt;String&lt;/code&gt; filename to use
&nbsp;     * @param sLocalPath The &lt;code&gt;String&lt;/code&gt; path to the file to be used on the
&nbsp;     *                   client
&nbsp;     */
&nbsp;    public void sendSaveGame(int connId, String sFile, String sLocalPath) {
<b class="nc">&nbsp;        saveGame(sFile, false);</b>
<b class="nc">&nbsp;        String sFinalFile = sFile;</b>
<b class="nc">&nbsp;        if (!sFinalFile.endsWith(&quot;.sav.gz&quot;)) {</b>
<b class="nc">&nbsp;            if (sFinalFile.endsWith(&quot;.sav&quot;)) {</b>
<b class="nc">&nbsp;                sFinalFile = sFile + &quot;.gz&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sFinalFile = sFile + &quot;.sav.gz&quot;;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        sLocalPath = sLocalPath.replaceAll(&quot;\\|&quot;, &quot; &quot;);</b>
<b class="nc">&nbsp;        String localFile = &quot;savegames&quot; + File.separator + sFinalFile;</b>
<b class="nc">&nbsp;        try (InputStream in = new FileInputStream(localFile); InputStream bin = new BufferedInputStream(in)) {</b>
<b class="nc">&nbsp;            List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</b>
&nbsp;            int input;
<b class="nc">&nbsp;            while ((input = bin.read()) != -1) {</b>
<b class="nc">&nbsp;                data.add(input);</b>
&nbsp;            }
<b class="nc">&nbsp;            send(connId, new Packet(Packet.COMMAND_SEND_SAVEGAME, new Object[]{</b>
&nbsp;                    sFinalFile, data, sLocalPath}));
<b class="nc">&nbsp;            sendChat(connId, &quot;***Server&quot;, &quot;Save game has been sent to you.&quot;);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Unable to load file: &quot; + localFile, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * save the game
&nbsp;     *
&nbsp;     * @param sFile    The &lt;code&gt;String&lt;/code&gt; filename to use
&nbsp;     * @param sendChat A &lt;code&gt;boolean&lt;/code&gt; value whether or not to announce the
&nbsp;     *                 saving to the server chat.
&nbsp;     */
&nbsp;    public void saveGame(String sFile, boolean sendChat) {
&nbsp;        // We need to strip the .gz if it exists,
&nbsp;        // otherwise we&#39;ll double up on it.
<b class="nc">&nbsp;        if (sFile.endsWith(&quot;.gz&quot;)) {</b>
<b class="nc">&nbsp;            sFile = sFile.replace(&quot;.gz&quot;, &quot;&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        XStream xstream = new XStream();</b>
&nbsp;
&nbsp;        // This will make save games much smaller
&nbsp;        // by using a more efficient means of referencing
&nbsp;        // objects in the XML graph
<b class="nc">&nbsp;        xstream.setMode(XStream.ID_REFERENCES);</b>
&nbsp;
<b class="nc">&nbsp;        String sFinalFile = sFile;</b>
<b class="nc">&nbsp;        if (!sFinalFile.endsWith(&quot;.sav&quot;)) {</b>
<b class="nc">&nbsp;            sFinalFile = sFile + &quot;.sav&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        File sDir = new File(&quot;savegames&quot;);</b>
<b class="nc">&nbsp;        if (!sDir.exists()) {</b>
<b class="nc">&nbsp;            sDir.mkdir();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        sFinalFile = sDir + File.separator + sFinalFile;</b>
&nbsp;
<b class="nc">&nbsp;        try (OutputStream os = new FileOutputStream(sFinalFile + &quot;.gz&quot;);</b>
<b class="nc">&nbsp;             OutputStream gzo = new GZIPOutputStream(os);</b>
<b class="nc">&nbsp;             Writer writer = new OutputStreamWriter(gzo, StandardCharsets.UTF_8)) {</b>
&nbsp;
<b class="nc">&nbsp;            xstream.toXML(game, writer);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Unable to save file: &quot; + sFinalFile, e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (sendChat) {</b>
<b class="nc">&nbsp;            sendChat(&quot;MegaMek&quot;, &quot;Game saved to &quot; + sFinalFile);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * save the game
&nbsp;     *
&nbsp;     * @param sFile The &lt;code&gt;String&lt;/code&gt; filename to use
&nbsp;     */
&nbsp;    public void saveGame(String sFile) {
<b class="nc">&nbsp;        saveGame(sFile, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * send a packet to the connection tells it load a locally saved game
&nbsp;     *
&nbsp;     * @param connId The &lt;code&gt;int&lt;/code&gt; connection id to send to
&nbsp;     * @param sFile  The &lt;code&gt;String&lt;/code&gt; filename to use
&nbsp;     */
&nbsp;    public void sendLoadGame(int connId, String sFile) {
<b class="nc">&nbsp;        String sFinalFile = sFile;</b>
<b class="nc">&nbsp;        if (!sFinalFile.endsWith(&quot;.sav&quot;) &amp;&amp; !sFinalFile.endsWith(&quot;.sav.gz&quot;)) {</b>
<b class="nc">&nbsp;            sFinalFile = sFile + &quot;.sav&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!sFinalFile.endsWith(&quot;.gz&quot;)) {</b>
<b class="nc">&nbsp;            sFinalFile = sFinalFile + &quot;.gz&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        send(connId, new Packet(Packet.COMMAND_LOAD_SAVEGAME, new Object[]{sFinalFile}));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * load the game
&nbsp;     *
&nbsp;     * @param f The &lt;code&gt;File&lt;/code&gt; to load
&nbsp;     * @return A &lt;code&gt;boolean&lt;/code&gt; value whether or not the loading was successful
&nbsp;     */
&nbsp;    public boolean loadGame(File f) {
<b class="nc">&nbsp;        return loadGame(f, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * load the game
&nbsp;     *
&nbsp;     * @param f
&nbsp;     *            The &lt;code&gt;File&lt;/code&gt; to load
&nbsp;     * @param sendInfo
&nbsp;     *            Determines whether the connections should be updated with
&nbsp;     *            current info. This may be false if some reconnection remapping
&nbsp;     *            needs to be done first.
&nbsp;     * @return A &lt;code&gt;boolean&lt;/code&gt; value whether or not the loading was successful
&nbsp;     */
&nbsp;    public boolean loadGame(File f, boolean sendInfo) {
<b class="nc">&nbsp;        MegaMek.getLogger().info(&quot;s: loading saved game file &#39;&quot; + f + &quot;&#39;&quot;);</b>
&nbsp;
&nbsp;        IGame newGame;
<b class="nc">&nbsp;        try (InputStream is = new FileInputStream(f); InputStream gzi = new GZIPInputStream(is)) {</b>
<b class="nc">&nbsp;            XStream xstream = SerializationHelper.getXStream();</b>
<b class="nc">&nbsp;            newGame = (IGame) xstream.fromXML(gzi);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Unable to load file: &quot; + f, e);</b>
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        setGame(newGame);</b>
&nbsp;
<b class="nc">&nbsp;        if (!sendInfo) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // update all the clients with the new game info
<b class="nc">&nbsp;        for (IConnection conn : connections) {</b>
<b class="nc">&nbsp;            sendCurrentInfo(conn.getId());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When the load command is used, there is a list of already connected
&nbsp;     * players which have assigned names and player id numbers with the id
&nbsp;     * numbers matching the connection numbers. When a new game is loaded, this
&nbsp;     * mapping may need to be updated. This method takes a map of player names
&nbsp;     * to their current ids, and uses the list of players to figure out what the
&nbsp;     * current ids should change to.
&nbsp;     *
&nbsp;     * @param nameToIdMap
&nbsp;     *            This maps a player name to the current connection ID
&nbsp;     * @param idToNameMap
&nbsp;     *            This maps a current conn ID to a player name, and is just the
&nbsp;     *            inverse mapping from nameToIdMap
&nbsp;     */
&nbsp;    public void remapConnIds(Map&lt;String, Integer&gt; nameToIdMap, Map&lt;Integer, String&gt; idToNameMap) {
&nbsp;        // Keeps track of connections without Ids
<b class="nc">&nbsp;        List&lt;IConnection&gt; unassignedConns = new ArrayList&lt;&gt;();</b>
&nbsp;       // Keep track of which ids are used
<b class="nc">&nbsp;        Set&lt;Integer&gt; usedPlayerIds = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;String&gt; currentPlayerNames = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (IPlayer p : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;            currentPlayerNames.add(p.getName());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Map the old connection Id to new value
<b class="nc">&nbsp;        Map&lt;Integer,Integer&gt; connIdRemapping = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (IPlayer p : game.getPlayersVector()) {</b>
&nbsp;            // Check to see if this player was already connected
<b class="nc">&nbsp;            Integer oldId = nameToIdMap.get(p.getName());</b>
<b class="nc">&nbsp;            if ((oldId != null) &amp;&amp; (oldId != p.getId())) {</b>
<b class="nc">&nbsp;                connIdRemapping.put(oldId, p.getId());</b>
&nbsp;            }
&nbsp;            // If the old and new Ids match, make sure we remove ghost status
<b class="nc">&nbsp;            if ((oldId != null) &amp;&amp; (oldId == p.getId())) {</b>
<b class="nc">&nbsp;                p.setGhost(false);</b>
&nbsp;            }
&nbsp;            // Check to see if this player&#39;s Id is taken
<b class="nc">&nbsp;            String oldName = idToNameMap.get(p.getId());</b>
<b class="nc">&nbsp;            if ((oldName != null) &amp;&amp; !oldName.equals(p.getName())) {</b>
&nbsp;                // If this name doesn&#39;t belong to a current player, unassign it
<b class="nc">&nbsp;                if (!currentPlayerNames.contains(oldName)) {</b>
<b class="nc">&nbsp;                    unassignedConns.add(connectionIds.get(p.getId()));</b>
&nbsp;                    // Make sure we don&#39;t add this to unassigned connections twice
<b class="nc">&nbsp;                    connectionIds.remove(p.getId());</b>
&nbsp;                }
&nbsp;                // If it does belong to a current player, it&#39;ll get handled
&nbsp;                // when that player comes up
&nbsp;            }
&nbsp;            // Keep track of what Ids are used
<b class="nc">&nbsp;            usedPlayerIds.add(p.getId());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Remap old connection Ids to new ones
<b class="nc">&nbsp;        for (Integer currConnId : connIdRemapping.keySet()) {</b>
<b class="nc">&nbsp;            Integer newId = connIdRemapping.get(currConnId);</b>
<b class="nc">&nbsp;            IConnection conn = connectionIds.get(currConnId);</b>
<b class="nc">&nbsp;            conn.setId(newId);</b>
&nbsp;            // If this Id is used, make sure we reassign that connection
<b class="nc">&nbsp;            if (connectionIds.containsKey(newId)) {</b>
<b class="nc">&nbsp;                unassignedConns.add(connectionIds.get(newId));</b>
&nbsp;            }
&nbsp;            // Map the new Id
<b class="nc">&nbsp;            connectionIds.put(newId, conn);</b>
&nbsp;
<b class="nc">&nbsp;            game.getPlayer(newId).setGhost(false);</b>
<b class="nc">&nbsp;            send(newId, new Packet(Packet.COMMAND_LOCAL_PN, newId));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // It&#39;s possible we have players not in the saved game, add &#39;em
<b class="nc">&nbsp;        for (IConnection conn : unassignedConns) {</b>
<b class="nc">&nbsp;            int newId = 0;</b>
<b class="nc">&nbsp;            while (usedPlayerIds.contains(newId)) {</b>
<b class="nc">&nbsp;                newId++;</b>
&nbsp;            }
<b class="nc">&nbsp;            String name = idToNameMap.get(conn.getId());</b>
<b class="nc">&nbsp;            conn.setId(newId);</b>
<b class="nc">&nbsp;            IPlayer newPlayer = addNewPlayer(newId, name);</b>
<b class="nc">&nbsp;            newPlayer.setObserver(true);</b>
<b class="nc">&nbsp;            connectionIds.put(newId,  conn);</b>
<b class="nc">&nbsp;            send(newId, new Packet(Packet.COMMAND_LOCAL_PN, newId));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Ensure all clients are up-to-date on player info
<b class="nc">&nbsp;        transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Shortcut to game.getPlayer(id)
&nbsp;     */
&nbsp;    public IPlayer getPlayer(int id) {
<b class="nc">&nbsp;        return game.getPlayer(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all entities owned by a player. Should only be called when it
&nbsp;     * won&#39;t cause trouble (the lounge, for instance, or between phases.)
&nbsp;     *
&nbsp;     * @param player whose entities are to be removed
&nbsp;     */
&nbsp;    private void removeAllEntitiesOwnedBy(IPlayer player) {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; toRemove = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = e.next();</b>
&nbsp;
<b class="nc">&nbsp;            if (entity.getOwner().equals(player)) {</b>
<b class="nc">&nbsp;                toRemove.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : toRemove) {</b>
<b class="nc">&nbsp;            int id = entity.getId();</b>
<b class="nc">&nbsp;            game.removeEntity(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED);</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * a shorter name for getConnection()
&nbsp;     */
&nbsp;    private IConnection getClient(int connId) {
<b class="nc">&nbsp;        return getConnection(connId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a connection, indexed by id
&nbsp;     */
&nbsp;    public Enumeration&lt;IConnection&gt; getConnections() {
<b class="nc">&nbsp;        return connections.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a connection, indexed by id
&nbsp;     */
&nbsp;    public IConnection getConnection(int connId) {
<b class="nc">&nbsp;        return connectionIds.get(connId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a pending connection
&nbsp;     */
&nbsp;    IConnection getPendingConnection(int connId) {
<b class="nc">&nbsp;        for (IConnection conn : connectionsPending) {</b>
<b class="nc">&nbsp;            if (conn.getId() == connId) {</b>
<b class="nc">&nbsp;                return conn;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called at the beginning of each game round to reset values on this entity
&nbsp;     * that are reset every round
&nbsp;     */
&nbsp;    private void resetEntityRound() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = e.next();</b>
&nbsp;
<b class="nc">&nbsp;            entity.newRound(game.getRoundCount());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check a list of entity Ids for doomed entities and destroy those.
&nbsp;     */
&nbsp;    private void destroyDoomedEntities(Vector&lt;Integer&gt; entityIds) {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; toRemove = new Vector&lt;&gt;(0, 10);</b>
<b class="nc">&nbsp;        for (Integer entityId : entityIds) {</b>
<b class="nc">&nbsp;            Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;            if (entity.isDoomed()) {</b>
<b class="nc">&nbsp;                entity.setDestroyed(true);</b>
&nbsp;
&nbsp;                // Is this unit swarming somebody? Better let go before
&nbsp;                // it&#39;s too late.
<b class="nc">&nbsp;                final int swarmedId = entity.getSwarmTargetId();</b>
<b class="nc">&nbsp;                if (Entity.NONE != swarmedId) {</b>
<b class="nc">&nbsp;                    final Entity swarmed = game.getEntity(swarmedId);</b>
<b class="nc">&nbsp;                    swarmed.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                    entity.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;                    Report r = new Report(5165);</b>
<b class="nc">&nbsp;                    r.subject = swarmedId;</b>
<b class="nc">&nbsp;                    r.addDesc(swarmed);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entityUpdate(swarmedId);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.isDestroyed()) {</b>
<b class="nc">&nbsp;                toRemove.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // actually remove all flagged entities
<b class="nc">&nbsp;        for (Entity entity : toRemove) {</b>
<b class="nc">&nbsp;            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;</b>
<b class="nc">&nbsp;            if (!entity.isSalvage()) {</b>
<b class="nc">&nbsp;                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;</b>
&nbsp;            }
&nbsp;            // If we removed a unit during the movement phase that hasn&#39;t moved,
&nbsp;            // remove its turn.
<b class="nc">&nbsp;            if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; entity.isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                game.removeTurnFor(entity);</b>
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
&nbsp;            }
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            game.removeEntity(entity.getId(), condition);</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(entity.getId(), condition));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Deploys elligible offboard entities.
&nbsp;     */
&nbsp;    private void deployOffBoardEntities() {
&nbsp;        // place off board entities actually off-board
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; entities = game.getEntities();</b>
<b class="nc">&nbsp;        while (entities.hasNext()) {</b>
<b class="nc">&nbsp;            Entity en = entities.next();</b>
<b class="nc">&nbsp;            if (en.isOffBoard() &amp;&amp; !en.isDeployed()) {</b>
<b class="nc">&nbsp;                en.deployOffBoard(game.getRoundCount());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called at the beginning of each phase. Sets and resets any entity
&nbsp;     * parameters that need to be reset.
&nbsp;     */
&nbsp;    private void resetEntityPhase(IGame.Phase phase) {
&nbsp;        // first, mark doomed entities as destroyed and flag them
<b class="nc">&nbsp;        Vector&lt;Entity&gt; toRemove = new Vector&lt;&gt;(0, 10);</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = e.next();</b>
<b class="nc">&nbsp;            entity.newPhase(phase);</b>
<b class="nc">&nbsp;            if (entity.isDoomed()) {</b>
<b class="nc">&nbsp;                entity.setDestroyed(true);</b>
&nbsp;
&nbsp;                // Is this unit swarming somebody? Better let go before
&nbsp;                // it&#39;s too late.
<b class="nc">&nbsp;                final int swarmedId = entity.getSwarmTargetId();</b>
<b class="nc">&nbsp;                if (Entity.NONE != swarmedId) {</b>
<b class="nc">&nbsp;                    final Entity swarmed = game.getEntity(swarmedId);</b>
<b class="nc">&nbsp;                    swarmed.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                    entity.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;                    Report r = new Report(5165);</b>
<b class="nc">&nbsp;                    r.subject = swarmedId;</b>
<b class="nc">&nbsp;                    r.addDesc(swarmed);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entityUpdate(swarmedId);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.isDestroyed()) {</b>
<b class="nc">&nbsp;                if (game.getEntity(entity.getTransportId()) != null</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getEntity(entity.getTransportId()).isLargeCraft()) {</b>
&nbsp;                    //Leaving destroyed entities in dropship bays alone here
&nbsp;                } else {
<b class="nc">&nbsp;                    toRemove.addElement(entity);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // actually remove all flagged entities
<b class="nc">&nbsp;        for (Entity entity : toRemove) {</b>
<b class="nc">&nbsp;            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;</b>
<b class="nc">&nbsp;            if (!entity.isSalvage()) {</b>
<b class="nc">&nbsp;                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            game.removeEntity(entity.getId(), condition);</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(entity.getId(), condition));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // do some housekeeping on all the remaining
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = e.next();</b>
&nbsp;
<b class="nc">&nbsp;            entity.applyDamage();</b>
&nbsp;
<b class="nc">&nbsp;            entity.reloadEmptyWeapons();</b>
&nbsp;
&nbsp;            // reset damage this phase
&nbsp;            // telemissiles need a record of damage last phase
<b class="nc">&nbsp;            entity.damageThisRound += entity.damageThisPhase;</b>
<b class="nc">&nbsp;            entity.damageThisPhase = 0;</b>
<b class="nc">&nbsp;            entity.engineHitsThisPhase = 0;</b>
<b class="nc">&nbsp;            entity.rolledForEngineExplosion = false;</b>
<b class="nc">&nbsp;            entity.dodging = false;</b>
<b class="nc">&nbsp;            entity.setShutDownThisPhase(false);</b>
<b class="nc">&nbsp;            entity.setStartupThisPhase(false);</b>
&nbsp;
&nbsp;            // reset done to false
&nbsp;
<b class="nc">&nbsp;            if (phase == IGame.Phase.PHASE_DEPLOYMENT) {</b>
<b class="nc">&nbsp;                entity.setDone(!entity.shouldDeploy(game.getRoundCount()));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                entity.setDone(false);</b>
&nbsp;            }
&nbsp;
&nbsp;            // reset spotlights
<b class="nc">&nbsp;            entity.setIlluminated(false);</b>
<b class="nc">&nbsp;            entity.setUsedSearchlight(false);</b>
<b class="nc">&nbsp;            entity.setCarefulStand(false);</b>
<b class="nc">&nbsp;            entity.setNetworkBAP(false);</b>
&nbsp;
<b class="nc">&nbsp;            if (entity instanceof MechWarrior) {</b>
<b class="nc">&nbsp;                ((MechWarrior) entity).setLanded(true);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        game.clearIlluminatedPositions();</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_CLEAR_ILLUM_HEXES));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     *  Called during the end phase. Checks each entity for ASEW effects counters and decrements them by 1 if &gt; 0
&nbsp;     */
&nbsp;
&nbsp;    public void decrementASEWTurns() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = e.next();</b>
&nbsp;            // Decrement ASEW effects
<b class="nc">&nbsp;            if ((entity.getEntityType() &amp; Entity.ETYPE_DROPSHIP) == Entity.ETYPE_DROPSHIP) {</b>
<b class="nc">&nbsp;                Dropship d = (Dropship) entity;</b>
<b class="nc">&nbsp;                for (int loc = 0; loc &lt; d.locations(); loc++) {</b>
<b class="nc">&nbsp;                    if (d.getASEWAffected(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        d.setASEWAffected(loc, d.getASEWAffected(loc) - 1);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if ((entity.getEntityType() &amp; Entity.ETYPE_JUMPSHIP) != 0) {</b>
<b class="nc">&nbsp;                Jumpship j = (Jumpship) entity;</b>
<b class="nc">&nbsp;                for (int loc = 0; loc &lt; j.locations(); loc++) {</b>
<b class="nc">&nbsp;                    if (j.getASEWAffected(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        j.setASEWAffected(loc, j.getASEWAffected(loc) - 1);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                if (entity.getASEWAffected() &gt; 0) {</b>
<b class="nc">&nbsp;                    entity.setASEWAffected(entity.getASEWAffected() - 1);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * are we currently in a reporting phase
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if we are or &lt;code&gt;false&lt;/code&gt; if not.
&nbsp;     */
&nbsp;    private boolean isReportingPhase() {
<b class="nc">&nbsp;        return (game.getPhase() == IGame.Phase.PHASE_FIRING_REPORT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_INITIATIVE_REPORT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_MOVEMENT_REPORT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD_REPORT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_PHYSICAL_REPORT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called at the beginning of certain phases to make every player not ready.
&nbsp;     */
&nbsp;    private void resetPlayersDone() {
<b class="nc">&nbsp;        if (isReportingPhase()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;            player.setDone(false);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        transmitAllPlayerDones();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called at the beginning of certain phases to make every active player not
&nbsp;     * ready.
&nbsp;     */
&nbsp;    private void resetActivePlayersDone() {
&nbsp;        /*
&nbsp;         * if (isReportingPhase()) { return; }
&nbsp;         */
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
&nbsp;
<b class="nc">&nbsp;            player.setDone(game.getEntitiesOwnedBy(player) &lt;= 0);</b>
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        transmitAllPlayerDones();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Writes the victory report
&nbsp;     */
&nbsp;    private void prepareVictoryReport() {
&nbsp;        Report r;
&nbsp;
&nbsp;        // remove carcasses to the graveyard
<b class="nc">&nbsp;        Vector&lt;Entity&gt; toRemove = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.isCarcass() &amp;&amp; !e.isDestroyed()) {</b>
<b class="nc">&nbsp;                toRemove.add(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Entity e : toRemove) {</b>
<b class="nc">&nbsp;            destroyEntity(e, &quot;crew death&quot;, false, true);</b>
<b class="nc">&nbsp;            game.removeEntity(e.getId(), IEntityRemovalConditions.REMOVE_SALVAGEABLE);</b>
<b class="nc">&nbsp;            e.setDestroyed(true);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        addReport(new Report(7000, Report.PUBLIC));</b>
&nbsp;
&nbsp;        // Declare the victor
<b class="nc">&nbsp;        r = new Report(1210);</b>
<b class="nc">&nbsp;        r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;        if (game.getVictoryTeam() == IPlayer.TEAM_NONE) {</b>
<b class="nc">&nbsp;            IPlayer player = getPlayer(game.getVictoryPlayerId());</b>
<b class="nc">&nbsp;            if (null == player) {</b>
<b class="nc">&nbsp;                r.messageId = 7005;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.messageId = 7010;</b>
<b class="nc">&nbsp;                r.add(Server.getColorForPlayer(player));</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Team victory
<b class="nc">&nbsp;            r.messageId = 7015;</b>
<b class="nc">&nbsp;            r.add(game.getVictoryTeam());</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Show player BVs
<b class="nc">&nbsp;        Enumeration&lt;IPlayer&gt; players = game.getPlayers();</b>
<b class="nc">&nbsp;        while (players.hasMoreElements()) {</b>
<b class="nc">&nbsp;            IPlayer player = players.nextElement();</b>
&nbsp;            // Players who started the game as observers get ignored
<b class="nc">&nbsp;            if (player.getInitialBV() == 0) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report();</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            r.messageId = 7016;</b>
<b class="nc">&nbsp;            r.add(Server.getColorForPlayer(player));</b>
<b class="nc">&nbsp;            r.add(player.getBV());</b>
<b class="nc">&nbsp;            r.add(Double.toString(Math.round((double) player.getBV() / player.getInitialBV() * 10000.0) / 100.0));</b>
<b class="nc">&nbsp;            r.add(player.getInitialBV());</b>
<b class="nc">&nbsp;            r.add(player.getFledBV());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // List the survivors
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; survivors = game.getEntities();</b>
<b class="nc">&nbsp;        if (survivors.hasNext()) {</b>
<b class="nc">&nbsp;            addReport(new Report(7020, Report.PUBLIC));</b>
<b class="nc">&nbsp;            while (survivors.hasNext()) {</b>
<b class="nc">&nbsp;                Entity entity = survivors.next();</b>
&nbsp;
<b class="nc">&nbsp;                if (!entity.isDeployed()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                addReport(entity.victoryReport());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // List units that never deployed
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; undeployed = game.getEntities();</b>
<b class="nc">&nbsp;        if (undeployed.hasNext()) {</b>
<b class="nc">&nbsp;            boolean wroteHeader = false;</b>
&nbsp;
<b class="nc">&nbsp;            while (undeployed.hasNext()) {</b>
<b class="nc">&nbsp;                Entity entity = undeployed.next();</b>
&nbsp;
<b class="nc">&nbsp;                if (entity.isDeployed()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (!wroteHeader) {</b>
<b class="nc">&nbsp;                    addReport(new Report(7075, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    wroteHeader = true;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                addReport(entity.victoryReport());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // List units that retreated
<b class="nc">&nbsp;        Enumeration&lt;Entity&gt; retreat = game.getRetreatedEntities();</b>
<b class="nc">&nbsp;        if (retreat.hasMoreElements()) {</b>
<b class="nc">&nbsp;            addReport(new Report(7080, Report.PUBLIC));</b>
<b class="nc">&nbsp;            while (retreat.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Entity entity = retreat.nextElement();</b>
<b class="nc">&nbsp;                addReport(entity.victoryReport());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // List destroyed units
<b class="nc">&nbsp;        Enumeration&lt;Entity&gt; graveyard = game.getGraveyardEntities();</b>
<b class="nc">&nbsp;        if (graveyard.hasMoreElements()) {</b>
<b class="nc">&nbsp;            addReport(new Report(7085, Report.PUBLIC));</b>
<b class="nc">&nbsp;            while (graveyard.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Entity entity = graveyard.nextElement();</b>
<b class="nc">&nbsp;                addReport(entity.victoryReport());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // List devastated units (not salvageable)
<b class="nc">&nbsp;        Enumeration&lt;Entity&gt; devastated = game.getDevastatedEntities();</b>
<b class="nc">&nbsp;        if (devastated.hasMoreElements()) {</b>
<b class="nc">&nbsp;            addReport(new Report(7090, Report.PUBLIC));</b>
&nbsp;
<b class="nc">&nbsp;            while (devastated.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Entity entity = devastated.nextElement();</b>
<b class="nc">&nbsp;                addReport(entity.victoryReport());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // Let player know about entitystatus.txt file
<b class="nc">&nbsp;        addReport(new Report(7095, Report.PUBLIC));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a detailed report for campaign use
&nbsp;     */
&nbsp;    private String getDetailedVictoryReport() {
<b class="nc">&nbsp;        StringBuilder sb = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Entity&gt; vAllUnits = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            vAllUnits.addElement(i.next());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;Entity&gt; i = game.getRetreatedEntities(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            vAllUnits.addElement(i.nextElement());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;Entity&gt; i = game.getGraveyardEntities(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            vAllUnits.addElement(i.nextElement());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
&nbsp;            // Record the player.
<b class="nc">&nbsp;            IPlayer p = i.nextElement();</b>
<b class="nc">&nbsp;            sb.append(&quot;++++++++++ &quot;).append(p.getName()).append(&quot; ++++++++++&quot;);</b>
<b class="nc">&nbsp;            sb.append(CommonConstants.NL);</b>
&nbsp;
&nbsp;            // Record the player&#39;s alive, retreated, or salvageable units.
<b class="nc">&nbsp;            for (int x = 0; x &lt; vAllUnits.size(); x++) {</b>
<b class="nc">&nbsp;                Entity e = vAllUnits.elementAt(x);</b>
<b class="nc">&nbsp;                if (e.getOwner() == p) {</b>
<b class="nc">&nbsp;                    sb.append(UnitStatusFormatter.format(e));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Record the player&#39;s devastated units.
<b class="nc">&nbsp;            Enumeration&lt;Entity&gt; devastated = game.getDevastatedEntities();</b>
<b class="nc">&nbsp;            if (devastated.hasMoreElements()) {</b>
<b class="nc">&nbsp;                sb.append(&quot;=============================================================&quot;);</b>
<b class="nc">&nbsp;                sb.append(CommonConstants.NL);</b>
<b class="nc">&nbsp;                sb.append(&quot;The following utterly destroyed units are not available for salvage:&quot;);</b>
<b class="nc">&nbsp;                sb.append(CommonConstants.NL);</b>
<b class="nc">&nbsp;                while (devastated.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    Entity e = devastated.nextElement();</b>
<b class="nc">&nbsp;                    if (e.getOwner() == p) {</b>
<b class="nc">&nbsp;                        sb.append(e.getShortName());</b>
<b class="nc">&nbsp;                        for (int pos = 0; pos &lt; e.getCrew().getSlotCount(); pos++) {</b>
<b class="nc">&nbsp;                            sb.append(&quot;, &quot;).append(e.getCrew().getNameAndRole(pos)).append(&quot; (&quot;)</b>
<b class="nc">&nbsp;                                .append(e.getCrew().getGunnery()).append(&#39;/&#39;)</b>
<b class="nc">&nbsp;                                .append(e.getCrew().getPiloting()).append(&#39;)&#39;);</b>
<b class="nc">&nbsp;                            sb.append(CommonConstants.NL);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } // Handle the next non-salvageable unit for the player</b>
<b class="nc">&nbsp;                sb.append(&quot;=============================================================&quot;);</b>
<b class="nc">&nbsp;                sb.append(CommonConstants.NL);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } // Handle the next player</b>
&nbsp;
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Forces victory for the specified player, or his/her team at the end of
&nbsp;     * the round.
&nbsp;     */
&nbsp;    public void forceVictory(IPlayer victor) {
<b class="nc">&nbsp;        game.setForceVictory(true);</b>
<b class="nc">&nbsp;        if (victor.getTeam() == IPlayer.TEAM_NONE) {</b>
<b class="nc">&nbsp;            game.setVictoryPlayerId(victor.getId());</b>
<b class="nc">&nbsp;            game.setVictoryTeam(IPlayer.TEAM_NONE);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            game.setVictoryPlayerId(IPlayer.PLAYER_NONE);</b>
<b class="nc">&nbsp;            game.setVictoryTeam(victor.getTeam());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Vector&lt;IPlayer&gt; playersVector = game.getPlayersVector();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; playersVector.size(); i++) {</b>
<b class="nc">&nbsp;            IPlayer player = playersVector.elementAt(i);</b>
<b class="nc">&nbsp;            player.setAdmitsDefeat(false);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Cancels the force victory
&nbsp;     */
&nbsp;    public void cancelVictory() {
<b class="nc">&nbsp;        game.setForceVictory(false);</b>
<b class="nc">&nbsp;        game.setVictoryPlayerId(IPlayer.PLAYER_NONE);</b>
<b class="nc">&nbsp;        game.setVictoryTeam(IPlayer.TEAM_NONE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void requestTeamChange(int team, IPlayer player) {
<b class="nc">&nbsp;        requestedTeam = team;</b>
<b class="nc">&nbsp;        playerChangingTeam = player;</b>
<b class="nc">&nbsp;        changePlayersTeam = false;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void allowTeamChange() {
<b class="nc">&nbsp;        changePlayersTeam = true;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isTeamChangeRequestInProgress() {
<b class="nc">&nbsp;        return playerChangingTeam != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public IPlayer getPlayerRequestingTeamChange() {
<b class="nc">&nbsp;        return playerChangingTeam;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getRequestedTeam() {
<b class="nc">&nbsp;        return requestedTeam;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processTeamChange() {
<b class="nc">&nbsp;        if (playerChangingTeam != null) {</b>
<b class="nc">&nbsp;            playerChangingTeam.setTeam(requestedTeam);</b>
<b class="nc">&nbsp;            game.setupTeams();</b>
<b class="nc">&nbsp;            send(createPlayerUpdatePacket(playerChangingTeam.getId()));</b>
<b class="nc">&nbsp;            String teamString = &quot;Team &quot; + requestedTeam + &quot;!&quot;;</b>
<b class="nc">&nbsp;            if (requestedTeam == IPlayer.TEAM_UNASSIGNED) {</b>
<b class="nc">&nbsp;                teamString = &quot; unassigned!&quot;;</b>
<b class="nc">&nbsp;            } else if (requestedTeam == IPlayer.TEAM_NONE) {</b>
<b class="nc">&nbsp;                teamString = &quot; lone wolf!&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            sendServerChat(playerChangingTeam.getName() + &quot; has changed teams to &quot; + teamString);</b>
<b class="nc">&nbsp;            playerChangingTeam = null;</b>
&nbsp;        }
<b class="nc">&nbsp;        changePlayersTeam = false;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called when a player declares that he is &quot;done.&quot; Checks to see if all
&nbsp;     * players are done, and if so, moves on to the next phase.
&nbsp;     */
&nbsp;    private void checkReady() {
&nbsp;        // check if all active players are done
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;            if (!player.isGhost() &amp;&amp; !player.isObserver() &amp;&amp; !player.isDone()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Tactical Genius pilot special ability (lvl 3)
<b class="nc">&nbsp;        if (game.getNoOfInitiativeRerollRequests() &gt; 0) {</b>
<b class="nc">&nbsp;            resetActivePlayersDone();</b>
<b class="nc">&nbsp;            game.rollInitAndResolveTies();</b>
&nbsp;
<b class="nc">&nbsp;            determineTurnOrder(IGame.Phase.PHASE_INITIATIVE);</b>
<b class="nc">&nbsp;            clearReports();</b>
<b class="nc">&nbsp;            writeInitiativeReport(true);</b>
<b class="nc">&nbsp;            sendReport(true);</b>
<b class="nc">&nbsp;            return; // don&#39;t end the phase yet, players need to see new report</b>
&nbsp;        }
&nbsp;
&nbsp;        // need at least one entity in the game for the lounge phase to end
<b class="nc">&nbsp;        if (!game.phaseHasTurns(game.getPhase()) &amp;&amp; ((game.getPhase() != IGame.Phase.PHASE_LOUNGE)</b>
<b class="nc">&nbsp;                || (game.getNoOfEntities() &gt; 0))) {</b>
<b class="nc">&nbsp;            endCurrentPhase();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called when the current player has done his current turn and the turn
&nbsp;     * counter needs to be advanced. Also enforces the &quot;protos_move_multi&quot; and
&nbsp;     * the &quot;protos_move_multi&quot; option. If the player has just moved
&nbsp;     * infantry/protos with a &quot;normal&quot; turn, adds up to
&nbsp;     * Game.INF_AND_PROTOS_MOVE_MULTI - 1 more infantry/proto-specific turns
&nbsp;     * after the current turn.
&nbsp;     */
&nbsp;    private void endCurrentTurn(Entity entityUsed) {
&nbsp;        // Enforce &quot;inf_move_multi&quot; and &quot;protos_move_multi&quot; options.
&nbsp;        // The &quot;isNormalTurn&quot; flag is checking to see if any non-Infantry
&nbsp;        // or non-ProtoMech units can move during the current turn.
<b class="nc">&nbsp;        boolean turnsChanged = false;</b>
<b class="nc">&nbsp;        boolean outOfOrder = false;</b>
<b class="nc">&nbsp;        GameTurn turn = game.getTurn();</b>
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()</b>
&nbsp;            &amp;&amp; (entityUsed != null)
<b class="nc">&nbsp;            &amp;&amp; !turn.isValid(entityUsed.getOwnerId(), game)) {</b>
&nbsp;            // turn played out of order
<b class="nc">&nbsp;            outOfOrder = true;</b>
<b class="nc">&nbsp;            entityUsed.setDone(false);</b>
<b class="nc">&nbsp;            GameTurn removed = game.removeFirstTurnFor(entityUsed);</b>
<b class="nc">&nbsp;            entityUsed.setDone(true);</b>
<b class="nc">&nbsp;            turnsChanged = true;</b>
<b class="nc">&nbsp;            if (removed != null) {</b>
<b class="nc">&nbsp;                turn = removed;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        final Phase currPhase = game.getPhase();</b>
<b class="nc">&nbsp;        final GameOptions gameOpts = game.getOptions();</b>
<b class="nc">&nbsp;        final int playerId = null == entityUsed ? IPlayer.PLAYER_NONE : entityUsed.getOwnerId();</b>
<b class="nc">&nbsp;        boolean infMoved = entityUsed instanceof Infantry;</b>
<b class="nc">&nbsp;        boolean infMoveMulti = gameOpts.booleanOption(OptionsConstants.INIT_INF_MOVE_MULTI)</b>
&nbsp;               &amp;&amp; ((currPhase == IGame.Phase.PHASE_MOVEMENT)
&nbsp;                   || (currPhase == IGame.Phase.PHASE_DEPLOYMENT)
&nbsp;                   || (currPhase == IGame.Phase.PHASE_INITIATIVE));
<b class="nc">&nbsp;        boolean protosMoved = entityUsed instanceof Protomech;</b>
<b class="nc">&nbsp;        boolean protosMoveMulti = gameOpts.booleanOption(OptionsConstants.INIT_PROTOS_MOVE_MULTI);</b>
<b class="nc">&nbsp;        boolean tanksMoved = entityUsed instanceof Tank;</b>
<b class="nc">&nbsp;        boolean tanksMoveMulti = gameOpts.booleanOption(</b>
&nbsp;                OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT)
&nbsp;                &amp;&amp; ((currPhase == IGame.Phase.PHASE_MOVEMENT)
&nbsp;                    || (currPhase == IGame.Phase.PHASE_DEPLOYMENT)
&nbsp;                    || (currPhase == IGame.Phase.PHASE_INITIATIVE));
<b class="nc">&nbsp;        boolean meksMoved = entityUsed instanceof Mech;</b>
<b class="nc">&nbsp;        boolean meksMoveMulti = gameOpts.booleanOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT)</b>
&nbsp;                &amp;&amp; ((currPhase == IGame.Phase.PHASE_MOVEMENT)
&nbsp;                    || (currPhase == IGame.Phase.PHASE_DEPLOYMENT)
&nbsp;                    || (currPhase == IGame.Phase.PHASE_INITIATIVE));
&nbsp;
&nbsp;        // If infantry or protos move multi see if any
&nbsp;        // other unit types can move in the current turn.
<b class="nc">&nbsp;        int multiMask = 0;</b>
<b class="nc">&nbsp;        if (infMoveMulti &amp;&amp; infMoved) {</b>
<b class="nc">&nbsp;            multiMask = GameTurn.CLASS_INFANTRY;</b>
<b class="nc">&nbsp;        } else if (protosMoveMulti &amp;&amp; protosMoved) {</b>
<b class="nc">&nbsp;            multiMask = GameTurn.CLASS_PROTOMECH;</b>
<b class="nc">&nbsp;        } else if (tanksMoveMulti &amp;&amp; tanksMoved) {</b>
<b class="nc">&nbsp;            multiMask = GameTurn.CLASS_TANK;</b>
<b class="nc">&nbsp;        } else if (meksMoveMulti &amp;&amp; meksMoved) {</b>
<b class="nc">&nbsp;            multiMask = GameTurn.CLASS_MECH;</b>
&nbsp;        }
&nbsp;
&nbsp;        // In certain cases, a new SpecificEntityTurn could have been added for
&nbsp;        // the Entity whose turn we are ending as the next turn. If this has
&nbsp;        // happened, the remaining entity count will be off and we must ensure
&nbsp;        // that the SpecificEntityTurn for this unit remains the next turn
<b class="nc">&nbsp;        List&lt;GameTurn&gt; turnVector = game.getTurnVector();</b>
<b class="nc">&nbsp;        int turnIndex = game.getTurnIndex();</b>
<b class="nc">&nbsp;        boolean usedEntityNotDone = false;</b>
<b class="nc">&nbsp;        if ((turnIndex + 1) &lt; turnVector.size()) {</b>
<b class="nc">&nbsp;            GameTurn nextTurn = turnVector.get(turnIndex + 1);</b>
<b class="nc">&nbsp;            if (nextTurn instanceof GameTurn.SpecificEntityTurn) {</b>
<b class="nc">&nbsp;                GameTurn.SpecificEntityTurn seTurn = (GameTurn.SpecificEntityTurn) nextTurn;</b>
<b class="nc">&nbsp;                if ((entityUsed != null) &amp;&amp; (seTurn.getEntityNum() == entityUsed.getId())) {</b>
<b class="nc">&nbsp;                    turnIndex++;</b>
<b class="nc">&nbsp;                    usedEntityNotDone = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Was the turn we just took added as part of a multi-turn?
&nbsp;        //  This determines if we should add more multi-turns
<b class="nc">&nbsp;        boolean isMultiTurn = turn.isMultiTurn();</b>
&nbsp;
&nbsp;        // Unless overridden by the &quot;protos_move_multi&quot; option, all ProtoMechs
&nbsp;        // in a unit declare fire, and they don&#39;t mix with infantry.
<b class="nc">&nbsp;        if (protosMoved &amp;&amp; !protosMoveMulti &amp;&amp; !isMultiTurn &amp;&amp; (entityUsed != null)) {</b>
&nbsp;
&nbsp;            // What&#39;s the unit number and ID of the entity used?
<b class="nc">&nbsp;            final short movingUnit = entityUsed.getUnitNumber();</b>
<b class="nc">&nbsp;            final int movingId = entityUsed.getId();</b>
&nbsp;
&nbsp;            // How many other ProtoMechs are in the unit that can fire?
<b class="nc">&nbsp;            int protoTurns = game.getSelectedEntityCount(new EntitySelector() {</b>
<b class="nc">&nbsp;                private final int ownerId = playerId;</b>
&nbsp;
<b class="nc">&nbsp;                private final int entityId = movingId;</b>
&nbsp;
<b class="nc">&nbsp;                private final short unitNum = movingUnit;</b>
&nbsp;
&nbsp;                public boolean accept(Entity entity) {
<b class="nc">&nbsp;                    return (entity instanceof Protomech)</b>
<b class="nc">&nbsp;                            &amp;&amp; entity.isSelectableThisTurn()</b>
<b class="nc">&nbsp;                            &amp;&amp; (ownerId == entity.getOwnerId())</b>
<b class="nc">&nbsp;                            &amp;&amp; (entityId != entity.getId())</b>
<b class="nc">&nbsp;                            &amp;&amp; (unitNum == entity.getUnitNumber());</b>
&nbsp;                }
&nbsp;            });
&nbsp;
&nbsp;            // Add the correct number of turns for the ProtoMech unit number.
<b class="nc">&nbsp;            for (int i = 0; i &lt; protoTurns; i++) {</b>
<b class="nc">&nbsp;                GameTurn newTurn = new GameTurn.UnitNumberTurn(playerId, movingUnit);</b>
<b class="nc">&nbsp;                newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                game.insertTurnAfter(newTurn, turnIndex);</b>
<b class="nc">&nbsp;                turnsChanged = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Otherwise, we may need to add turns for the &quot;*_move_multi&quot; options.
<b class="nc">&nbsp;        else if (((infMoved &amp;&amp; infMoveMulti) || (protosMoved &amp;&amp; protosMoveMulti)) &amp;&amp; !isMultiTurn) {</b>
<b class="nc">&nbsp;            int remaining = 0;</b>
&nbsp;
&nbsp;            // Calculate the number of EntityClassTurns need to be added.
<b class="nc">&nbsp;            if (infMoveMulti &amp;&amp; infMoved) {</b>
<b class="nc">&nbsp;                remaining += game.getInfantryLeft(playerId);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (protosMoveMulti &amp;&amp; protosMoved) {</b>
<b class="nc">&nbsp;                remaining += game.getProtomechsLeft(playerId);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (usedEntityNotDone) {</b>
<b class="nc">&nbsp;                remaining--;</b>
&nbsp;            }
<b class="nc">&nbsp;            int moreInfAndProtoTurns = Math.min(</b>
<b class="nc">&nbsp;                    gameOpts.intOption(OptionsConstants.INIT_INF_PROTO_MOVE_MULTI) - 1, remaining);</b>
&nbsp;
&nbsp;            // Add the correct number of turns for the right unit classes.
<b class="nc">&nbsp;            for (int i = 0; i &lt; moreInfAndProtoTurns; i++) {</b>
<b class="nc">&nbsp;                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId, multiMask);</b>
<b class="nc">&nbsp;                newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                game.insertTurnAfter(newTurn, turnIndex);</b>
<b class="nc">&nbsp;                turnsChanged = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (tanksMoved &amp;&amp; tanksMoveMulti &amp;&amp; !isMultiTurn) {</b>
<b class="nc">&nbsp;            int remaining = game.getVehiclesLeft(playerId);</b>
<b class="nc">&nbsp;            if (usedEntityNotDone) {</b>
<b class="nc">&nbsp;                remaining--;</b>
&nbsp;            }
<b class="nc">&nbsp;            int moreVeeTurns = Math.min(</b>
<b class="nc">&nbsp;                    gameOpts.intOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT_NUMBER) - 1,</b>
&nbsp;                    remaining);
&nbsp;
&nbsp;            // Add the correct number of turns for the right unit classes.
<b class="nc">&nbsp;            for (int i = 0; i &lt; moreVeeTurns; i++) {</b>
<b class="nc">&nbsp;                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId, multiMask);</b>
<b class="nc">&nbsp;                newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                game.insertTurnAfter(newTurn, turnIndex);</b>
<b class="nc">&nbsp;                turnsChanged = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (meksMoved &amp;&amp; meksMoveMulti &amp;&amp; !isMultiTurn) {</b>
<b class="nc">&nbsp;            int remaining = game.getMechsLeft(playerId);</b>
<b class="nc">&nbsp;            if (usedEntityNotDone) {</b>
<b class="nc">&nbsp;                remaining--;</b>
&nbsp;            }
<b class="nc">&nbsp;            int moreMekTurns = Math.min(</b>
<b class="nc">&nbsp;                    gameOpts.intOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT_NUMBER) - 1,</b>
&nbsp;                    remaining);
&nbsp;
&nbsp;            // Add the correct number of turns for the right unit classes.
<b class="nc">&nbsp;            for (int i = 0; i &lt; moreMekTurns; i++) {</b>
<b class="nc">&nbsp;                GameTurn newTurn = new GameTurn.EntityClassTurn(playerId, multiMask);</b>
<b class="nc">&nbsp;                newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                game.insertTurnAfter(newTurn, turnIndex);</b>
<b class="nc">&nbsp;                turnsChanged = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // brief everybody on the turn update, if they changed
<b class="nc">&nbsp;        if (turnsChanged) {</b>
<b class="nc">&nbsp;            send(createTurnVectorPacket());</b>
&nbsp;        }
&nbsp;
&nbsp;        // move along
<b class="nc">&nbsp;        if (outOfOrder) {</b>
<b class="nc">&nbsp;            send(createTurnIndexPacket(playerId));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            changeToNextTurn(playerId);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Changes the current phase, does some bookkeeping and then tells the
&nbsp;     * players.
&nbsp;     *
&nbsp;     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase to change to
&nbsp;     */
&nbsp;    private void changePhase(IGame.Phase phase) {
<b class="nc">&nbsp;        game.setLastPhase(game.getPhase());</b>
<b class="nc">&nbsp;        game.setPhase(phase);</b>
&nbsp;
&nbsp;        // prepare for the phase
<b class="nc">&nbsp;        prepareForPhase(phase);</b>
&nbsp;
<b class="nc">&nbsp;        if (isPhasePlayable(phase)) {</b>
&nbsp;            // tell the players about the new phase
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_PHASE_CHANGE, phase));</b>
&nbsp;
&nbsp;            // post phase change stuff
<b class="nc">&nbsp;            executePhase(phase);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            endCurrentPhase();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Prepares for, presumably, the next phase. This typically involves
&nbsp;     * resetting the states of entities in the game and making sure the client
&nbsp;     * has the information it needs for the new phase.
&nbsp;     *
&nbsp;     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase to prepare for
&nbsp;     */
&nbsp;    private void prepareForPhase(IGame.Phase phase) {
<b class="nc">&nbsp;        switch (phase) {</b>
&nbsp;            case PHASE_LOUNGE:
<b class="nc">&nbsp;                clearReports();</b>
<b class="nc">&nbsp;                mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(</b>
<b class="nc">&nbsp;                        mapSettings.getBoardWidth(), mapSettings.getBoardHeight())));</b>
<b class="nc">&nbsp;                mapSettings.setNullBoards(DEFAULT_BOARD);</b>
<b class="nc">&nbsp;                send(createMapSettingsPacket());</b>
<b class="nc">&nbsp;                send(createMapSizesPacket());</b>
<b class="nc">&nbsp;                checkForObservers();</b>
<b class="nc">&nbsp;                transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_INITIATIVE:
&nbsp;                // remove the last traces of last round
<b class="nc">&nbsp;                game.handleInitiativeCompensation();</b>
<b class="nc">&nbsp;                game.resetActions();</b>
<b class="nc">&nbsp;                game.resetTagInfo();</b>
<b class="nc">&nbsp;                sendTagInfoReset();</b>
<b class="nc">&nbsp;                clearReports();</b>
<b class="nc">&nbsp;                resetEntityRound();</b>
<b class="nc">&nbsp;                resetEntityPhase(phase);</b>
<b class="nc">&nbsp;                checkForObservers();</b>
<b class="nc">&nbsp;                transmitAllPlayerUpdates();</b>
&nbsp;
&nbsp;                // roll &#39;em
<b class="nc">&nbsp;                resetActivePlayersDone();</b>
<b class="nc">&nbsp;                rollInitiative();</b>
&nbsp;                //Cockpit command consoles that switched crew on the previous round are ineligible for force
&nbsp;                //commander initiative bonus. Now that initiative is rolled, clear the flag.
<b class="nc">&nbsp;                game.getEntities().forEachRemaining(e -&gt; e.getCrew().resetActedFlag());</b>
&nbsp;
<b class="nc">&nbsp;                if (!game.shouldDeployThisRound()) {</b>
<b class="nc">&nbsp;                    incrementAndSendGameRound();</b>
&nbsp;                }
&nbsp;
&nbsp;                // setIneligible(phase);
<b class="nc">&nbsp;                determineTurnOrder(phase);</b>
<b class="nc">&nbsp;                writeInitiativeReport(false);</b>
&nbsp;
&nbsp;                // checks for environmental survival
<b class="nc">&nbsp;                checkForConditionDeath();</b>
&nbsp;
<b class="nc">&nbsp;                checkForBlueShieldDamage();</b>
<b class="nc">&nbsp;                if (game.getBoard().inAtmosphere()) {</b>
<b class="nc">&nbsp;                    checkForAtmosphereDeath();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                    checkForSpaceDeath();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                MegaMek.getLogger().info(&quot;Round &quot; + game.getRoundCount() + &quot; memory usage: &quot; + MegaMek.getMemoryUsed());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_DEPLOY_MINEFIELDS:
<b class="nc">&nbsp;                checkForObservers();</b>
<b class="nc">&nbsp;                transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;                resetActivePlayersDone();</b>
<b class="nc">&nbsp;                setIneligible(phase);</b>
&nbsp;
<b class="nc">&nbsp;                Enumeration&lt;IPlayer&gt; e = game.getPlayers();</b>
<b class="nc">&nbsp;                Vector&lt;GameTurn&gt; turns = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                while (e.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    IPlayer p = e.nextElement();</b>
<b class="nc">&nbsp;                    if (p.hasMinefields() &amp;&amp; game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                        GameTurn gt = new GameTurn(p.getId());</b>
<b class="nc">&nbsp;                        turns.addElement(gt);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                game.setTurnVector(turns);</b>
<b class="nc">&nbsp;                game.resetTurnIndex();</b>
&nbsp;
&nbsp;                // send turns to all players
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_SET_ARTYAUTOHITHEXES:
<b class="nc">&nbsp;                deployOffBoardEntities();</b>
<b class="nc">&nbsp;                checkForObservers();</b>
<b class="nc">&nbsp;                transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;                resetActivePlayersDone();</b>
<b class="nc">&nbsp;                setIneligible(phase);</b>
&nbsp;
<b class="nc">&nbsp;                Enumeration&lt;IPlayer&gt; players = game.getPlayers();</b>
<b class="nc">&nbsp;                Vector&lt;GameTurn&gt; turn = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;                // Walk through the players of the game, and add
&nbsp;                // a turn for all players with artillery weapons.
<b class="nc">&nbsp;                while (players.hasMoreElements()) {</b>
&nbsp;
&nbsp;                    // Get the next player.
<b class="nc">&nbsp;                    final IPlayer p = players.nextElement();</b>
&nbsp;
&nbsp;                    // Does the player have any artillery-equipped units?
<b class="nc">&nbsp;                    EntitySelector playerArtySelector = new EntitySelector() {</b>
<b class="nc">&nbsp;                        private IPlayer owner = p;</b>
&nbsp;
&nbsp;                        public boolean accept(Entity entity) {
<b class="nc">&nbsp;                            return owner.equals(entity.getOwner()) &amp;&amp; entity.isEligibleForArtyAutoHitHexes();</b>
&nbsp;                        }
&nbsp;                    };
<b class="nc">&nbsp;                    if (game.getSelectedEntities(playerArtySelector).hasNext()) {</b>
&nbsp;                        // Yes, the player has arty-equipped units.
<b class="nc">&nbsp;                        GameTurn gt = new GameTurn(p.getId());</b>
<b class="nc">&nbsp;                        turn.addElement(gt);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                game.setTurnVector(turn);</b>
<b class="nc">&nbsp;                game.resetTurnIndex();</b>
&nbsp;
&nbsp;                // send turns to all players
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_MOVEMENT:
&nbsp;            case PHASE_DEPLOYMENT:
&nbsp;            case PHASE_FIRING:
&nbsp;            case PHASE_PHYSICAL:
&nbsp;            case PHASE_TARGETING:
&nbsp;            case PHASE_OFFBOARD:
<b class="nc">&nbsp;                deployOffBoardEntities();</b>
&nbsp;
&nbsp;                // Check for activating hidden units
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {</b>
<b class="nc">&nbsp;                    for (Entity ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                        if (ent.getHiddenActivationPhase() == phase) {</b>
<b class="nc">&nbsp;                            ent.setHidden(false);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // Update visibility indications if using double blind.
<b class="nc">&nbsp;                if (doBlind()) {</b>
<b class="nc">&nbsp;                    updateVisibilityIndicator(null);</b>
&nbsp;                }
<b class="nc">&nbsp;                resetEntityPhase(phase);</b>
<b class="nc">&nbsp;                checkForObservers();</b>
<b class="nc">&nbsp;                transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;                resetActivePlayersDone();</b>
<b class="nc">&nbsp;                setIneligible(phase);</b>
<b class="nc">&nbsp;                determineTurnOrder(phase);</b>
&nbsp;                // send(createEntitiesPacket());
<b class="nc">&nbsp;                entityAllUpdate();</b>
<b class="nc">&nbsp;                clearReports();</b>
<b class="nc">&nbsp;                doTryUnstuck();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_END:
<b class="nc">&nbsp;                resetEntityPhase(phase);</b>
<b class="nc">&nbsp;                clearReports();</b>
<b class="nc">&nbsp;                resolveHeat();</b>
<b class="nc">&nbsp;                if (game.getPlanetaryConditions().isSandBlowing()</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getPlanetaryConditions().getWindStrength() &gt; PlanetaryConditions.WI_LIGHT_GALE)) {</b>
<b class="nc">&nbsp;                    addReport(resolveBlowingSandDamage());</b>
&nbsp;                }
<b class="nc">&nbsp;                addReport(resolveControlRolls());</b>
<b class="nc">&nbsp;                addReport(checkForTraitors());</b>
&nbsp;                // write End Phase header
<b class="nc">&nbsp;                addReport(new Report(5005, Report.PUBLIC));</b>
<b class="nc">&nbsp;                checkLayExplosives();</b>
<b class="nc">&nbsp;                resolveHarJelRepairs();</b>
<b class="nc">&nbsp;                resolveEmergencyCoolantSystem();</b>
<b class="nc">&nbsp;                checkForSuffocation();</b>
<b class="nc">&nbsp;                game.getPlanetaryConditions().determineWind();</b>
<b class="nc">&nbsp;                send(createPlanetaryConditionsPacket());</b>
&nbsp;
<b class="nc">&nbsp;                applyBuildingDamage();</b>
<b class="nc">&nbsp;                addReport(game.ageFlares());</b>
<b class="nc">&nbsp;                send(createFlarePacket());</b>
<b class="nc">&nbsp;                resolveAmmoDumps();</b>
<b class="nc">&nbsp;                resolveCrewWakeUp();</b>
<b class="nc">&nbsp;                resolveConsoleCrewSwaps();</b>
<b class="nc">&nbsp;                resolveSelfDestruct();</b>
<b class="nc">&nbsp;                resolveShutdownCrashes();</b>
<b class="nc">&nbsp;                checkForIndustrialEndOfTurn();</b>
<b class="nc">&nbsp;                resolveMechWarriorPickUp();</b>
<b class="nc">&nbsp;                resolveVeeINarcPodRemoval();</b>
<b class="nc">&nbsp;                resolveFortify();</b>
&nbsp;
&nbsp;                // Moved this to the very end because it makes it difficult to see
&nbsp;                // more important updates when you have 300+ messages of smoke filling
&nbsp;                // whatever hex. Please don&#39;t move it above the other things again.
&nbsp;                // Thanks! Ralgith - 2018/03/15
<b class="nc">&nbsp;                hexUpdateSet.clear();</b>
<b class="nc">&nbsp;                for (DynamicTerrainProcessor tp : terrainProcessors) {</b>
<b class="nc">&nbsp;                    tp.doEndPhaseChanges(vPhaseReport);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                sendChangedHexes(hexUpdateSet);</b>
&nbsp;
<b class="nc">&nbsp;                checkForObservers();</b>
<b class="nc">&nbsp;                transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;                entityAllUpdate();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_INITIATIVE_REPORT:
<b class="nc">&nbsp;                autoSave();</b>
&nbsp;                // Show player BVs
<b class="nc">&nbsp;                Enumeration&lt;IPlayer&gt; players2 = game.getPlayers();</b>
<b class="nc">&nbsp;                while (players2.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    IPlayer player = players2.nextElement();</b>
&nbsp;                    // Players who started the game as observers get ignored
<b class="nc">&nbsp;                    if (player.getInitialBV() == 0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Report r = new Report();</b>
<b class="nc">&nbsp;                    r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                    if (doBlind() &amp;&amp; suppressBlindBV()) {</b>
<b class="nc">&nbsp;                        r.type = Report.PLAYER;</b>
<b class="nc">&nbsp;                        r.player = player.getId();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.messageId = 7016;</b>
<b class="nc">&nbsp;                    r.add(Server.getColorForPlayer(player));</b>
<b class="nc">&nbsp;                    r.add(player.getBV());</b>
<b class="nc">&nbsp;                    r.add(Double.toString(Math.round((double) player.getBV() / player.getInitialBV() * 10000.0) / 100.0));</b>
<b class="nc">&nbsp;                    r.add(player.getInitialBV());</b>
<b class="nc">&nbsp;                    r.add(player.getFledBV());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            case PHASE_TARGETING_REPORT:
&nbsp;            case PHASE_MOVEMENT_REPORT:
&nbsp;            case PHASE_OFFBOARD_REPORT:
&nbsp;            case PHASE_FIRING_REPORT:
&nbsp;            case PHASE_PHYSICAL_REPORT:
&nbsp;            case PHASE_END_REPORT:
<b class="nc">&nbsp;                resetActivePlayersDone();</b>
<b class="nc">&nbsp;                sendReport();</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.BASE_PARANOID_AUTOSAVE)) {</b>
<b class="nc">&nbsp;                    autoSave();</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case PHASE_VICTORY:
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                clearReports();</b>
<b class="nc">&nbsp;                prepareVictoryReport();</b>
<b class="nc">&nbsp;                game.addReports(vPhaseReport);</b>
&nbsp;                // Before we send the full entities packet we need to loop
&nbsp;                // through the fighters in squadrons and damage them.
<b class="nc">&nbsp;                for (Iterator&lt;Entity&gt; ents = game.getEntities(); ents.hasNext(); ) {</b>
<b class="nc">&nbsp;                    Entity entity = ents.next();</b>
<b class="nc">&nbsp;                    if ((entity.isFighter()) &amp;&amp; !(entity instanceof FighterSquadron)) {</b>
<b class="nc">&nbsp;                        if (entity.isPartOfFighterSquadron() || entity.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                            ((IAero) entity).doDisbandDamage();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                // fix the armor and SI of aeros if using aero sanity rules for
&nbsp;                // the MUL
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)</b>
&nbsp;                        &amp;&amp; (entity instanceof Aero)) {
&nbsp;                    // need to rescale SI and armor
<b class="nc">&nbsp;                    int scale = 1;</b>
<b class="nc">&nbsp;                    if (entity.isCapitalScale()) {</b>
<b class="nc">&nbsp;                        scale = 10;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Aero a = (Aero) entity;</b>
<b class="nc">&nbsp;                    int currentSI = a.getSI() / (2 * scale);</b>
<b class="nc">&nbsp;                    a.set0SI(a.get0SI() / (2 * scale));</b>
<b class="nc">&nbsp;                    if (currentSI &gt; 0) {</b>
<b class="nc">&nbsp;                        a.setSI(currentSI);</b>
&nbsp;                    }
&nbsp;                    //Fix for #587. MHQ tracks fighters at standard scale and doesn&#39;t (currently)
&nbsp;                    //track squadrons. Squadrons don&#39;t save to MUL either, so... only convert armor for JS/WS/SS?
&nbsp;                    //Do we ever need to save capital fighter armor to the final MUL or entityStatus?
<b class="nc">&nbsp;                    if (!entity.hasETypeFlag(Entity.ETYPE_JUMPSHIP)) {</b>
<b class="nc">&nbsp;                        scale = 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (scale &gt; 1) {</b>
<b class="nc">&nbsp;                        for (int loc = 0; loc &lt; entity.locations(); loc++) {</b>
<b class="nc">&nbsp;                            int currentArmor = entity.getArmor(loc) / scale;</b>
<b class="nc">&nbsp;                            if (entity.getOArmor(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                                entity.initializeArmor(entity.getOArmor(loc) / scale, loc);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (entity.getArmor(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                                entity.setArmor(currentArmor, loc);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;                send(createFullEntitiesPacket());</b>
<b class="nc">&nbsp;                send(createReportPacket(null));</b>
<b class="nc">&nbsp;                send(createEndOfGamePacket());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Should we play this phase or skip it?
&nbsp;     */
&nbsp;    private boolean isPhasePlayable(IGame.Phase phase) {
<b class="nc">&nbsp;        switch (phase) {</b>
&nbsp;            case PHASE_INITIATIVE:
&nbsp;            case PHASE_END:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case PHASE_SET_ARTYAUTOHITHEXES:
&nbsp;            case PHASE_DEPLOY_MINEFIELDS:
&nbsp;            case PHASE_DEPLOYMENT:
&nbsp;            case PHASE_MOVEMENT:
&nbsp;            case PHASE_FIRING:
&nbsp;            case PHASE_PHYSICAL:
&nbsp;            case PHASE_TARGETING:
<b class="nc">&nbsp;                return game.hasMoreTurns();</b>
&nbsp;            case PHASE_OFFBOARD:
<b class="nc">&nbsp;                return isOffboardPlayable();</b>
&nbsp;            default:
<b class="nc">&nbsp;                return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Skip offboard phase, if there is no homing / semiguided ammo in play
&nbsp;     */
&nbsp;    private boolean isOffboardPlayable() {
<b class="nc">&nbsp;        if (!game.hasMoreTurns()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext();) {</b>
<b class="nc">&nbsp;            Entity entity = e.next();</b>
<b class="nc">&nbsp;            for (Mounted mounted : entity.getAmmo()) {</b>
<b class="nc">&nbsp;                AmmoType ammoType = (AmmoType) mounted.getType();</b>
&nbsp;                
&nbsp;                // per errata, TAG will spot for LRMs and such
<b class="nc">&nbsp;                if ((ammoType.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_NLRM)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_MEK_MORTAR)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                if (((ammoType.getAmmoType() == AmmoType.T_ARROW_IV)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_LONG_TOM)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_SNIPER)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_THUMPER))</b>
<b class="nc">&nbsp;                        &amp;&amp; (ammoType.getMunitionType() == AmmoType.M_HOMING)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            
<b class="nc">&nbsp;            for (Mounted b : entity.getBombs()) {</b>
<b class="nc">&nbsp;                if (!b.isDestroyed() &amp;&amp; (b.getUsableShotsLeft() &gt; 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (((BombType) b.getType()).getBombType() == BombType.B_LG)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // loop through all current attacks
&nbsp;        // if there are any that use homing ammo, we are playable
&nbsp;        // we need to do this because we might have a homing arty shot in flight
&nbsp;        // when the unit that mounted that ammo is no longer on the field
<b class="nc">&nbsp;        for (Enumeration&lt;AttackHandler&gt; attacks = game.getAttacks(); attacks.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            AttackHandler attackHandler = attacks.nextElement();</b>
<b class="nc">&nbsp;            Mounted ammo = attackHandler.getWaa().getEntity(game)</b>
<b class="nc">&nbsp;                    .getEquipment(attackHandler.getWaa().getAmmoId());</b>
<b class="nc">&nbsp;            if (ammo != null) {</b>
<b class="nc">&nbsp;                AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="nc">&nbsp;                if (ammoType.getMunitionType() == AmmoType.M_HOMING) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do anything we seed to start the new phase, such as give a turn to the
&nbsp;     * first player to play.
&nbsp;     */
&nbsp;    private void executePhase(IGame.Phase phase) {
<b class="nc">&nbsp;        switch (phase) {</b>
&nbsp;            case PHASE_EXCHANGE:
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                calculatePlayerBVs();</b>
&nbsp;                // Update initial BVs, as things may have been modified in lounge
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    e.setInitialBV(e.calculateBattleValue(false, false));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // Build teams vector
<b class="nc">&nbsp;                game.setupTeams();</b>
<b class="nc">&nbsp;                applyBoardSettings();</b>
<b class="nc">&nbsp;                game.getPlanetaryConditions().determineWind();</b>
<b class="nc">&nbsp;                send(createPlanetaryConditionsPacket());</b>
&nbsp;                // transmit the board to everybody
<b class="nc">&nbsp;                send(createBoardPacket());</b>
<b class="nc">&nbsp;                game.setupRoundDeployment();</b>
<b class="nc">&nbsp;                game.setVictoryContext(new HashMap&lt;&gt;());</b>
<b class="nc">&nbsp;                game.createVictoryConditions();</b>
&nbsp;                // some entities may need to be checked and updated
<b class="nc">&nbsp;                checkEntityExchange();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_MOVEMENT:
&nbsp;                // write Movement Phase header to report
<b class="nc">&nbsp;                addReport(new Report(2000, Report.PUBLIC));</b>
&nbsp;            case PHASE_SET_ARTYAUTOHITHEXES:
&nbsp;            case PHASE_DEPLOY_MINEFIELDS:
&nbsp;            case PHASE_DEPLOYMENT:
&nbsp;            case PHASE_FIRING:
&nbsp;            case PHASE_PHYSICAL:
&nbsp;            case PHASE_TARGETING:
&nbsp;            case PHASE_OFFBOARD:
<b class="nc">&nbsp;                changeToNextTurn(-1);</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.BASE_PARANOID_AUTOSAVE)) {</b>
<b class="nc">&nbsp;                    autoSave();</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates all players initial BV, should only be called at start of game
&nbsp;     */
&nbsp;    public void calculatePlayerBVs() {
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; players = game.getPlayers(); players.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            players.nextElement().setInitialBV();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * loop through entities in the exchange phase (i.e. after leaving
&nbsp;     * chat lounge) and do any actions that need to be done
&nbsp;     */
&nbsp;    public void checkEntityExchange() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; entities = game.getEntities(); entities.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = entities.next();</b>
&nbsp;            // apply bombs
<b class="nc">&nbsp;            if (entity.isBomber()) {</b>
<b class="nc">&nbsp;                ((IBomber)entity).applyBombs();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.isAero()) {</b>
<b class="nc">&nbsp;                IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                if (a.isSpaceborne()) {</b>
&nbsp;                    // altitude and elevation don&#39;t matter in space
<b class="nc">&nbsp;                    a.liftOff(0);</b>
&nbsp;                } else {
&nbsp;                    // check for grounding
<b class="nc">&nbsp;                    if (game.getBoard().inAtmosphere() &amp;&amp; !entity.isAirborne()) {</b>
&nbsp;                        // you have to be airborne on the atmospheric map
<b class="nc">&nbsp;                        a.liftOff(entity.getAltitude());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (entity.isFighter()) {</b>
<b class="nc">&nbsp;                    a.updateWeaponGroups();</b>
<b class="nc">&nbsp;                    entity.loadAllWeapons();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // if units were loaded in the chat lounge, I need to keep track of
&nbsp;            // it here because they can get dumped in the deployment phase
<b class="nc">&nbsp;            if (entity.getLoadedUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;                Vector&lt;Integer&gt; v = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Entity en : entity.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    v.add(en.getId());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                entity.setLoadedKeepers(v);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.isAero())) {</b>
<b class="nc">&nbsp;                Aero a = null;</b>
<b class="nc">&nbsp;                if (entity instanceof Aero) {</b>
<b class="nc">&nbsp;                    a = (Aero) entity;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity.isCapitalScale()) {</b>
<b class="nc">&nbsp;                    if (a != null) {</b>
<b class="nc">&nbsp;                        int currentSI = a.getSI() * 20;</b>
<b class="nc">&nbsp;                        a.initializeSI(a.get0SI() * 20);</b>
<b class="nc">&nbsp;                        a.setSI(currentSI);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (entity.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                        ((IAero)entity).autoSetCapArmor();</b>
<b class="nc">&nbsp;                        ((IAero)entity).autoSetFatalThresh();</b>
&nbsp;                    } else {
&nbsp;                        // all armor and SI is going to be at standard scale, so
&nbsp;                        // we need to adjust
<b class="nc">&nbsp;                        for (int loc = 0; loc &lt; entity.locations(); loc++) {</b>
<b class="nc">&nbsp;                            if (entity.getArmor(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                                int currentArmor = entity.getArmor(loc) * 10;</b>
<b class="nc">&nbsp;                                entity.initializeArmor(entity.getOArmor(loc) * 10, loc);</b>
<b class="nc">&nbsp;                                entity.setArmor(currentArmor, loc);</b>
&nbsp;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else if (a != null) {</b>
<b class="nc">&nbsp;                    int currentSI = a.getSI() * 2;</b>
<b class="nc">&nbsp;                    a.initializeSI(a.get0SI() * 2);</b>
<b class="nc">&nbsp;                    a.setSI(currentSI);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Give the unit a spotlight, if it has the spotlight quirk
<b class="nc">&nbsp;            entity.setExternalSpotlight(entity.hasExternaSpotlight()</b>
<b class="nc">&nbsp;                    || entity.hasQuirk(OptionsConstants.QUIRK_POS_SEARCHLIGHT));</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
&nbsp;
&nbsp;            // Remove hot-loading some from LRMs for meks
<b class="nc">&nbsp;            if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_HOTLOAD_IN_GAME)) {</b>
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
&nbsp;                    // Vehicles are allowed to hot load, just meks cannot
<b class="nc">&nbsp;                    if (!(e instanceof Mech)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (Mounted weapon : e.getWeaponList()) {</b>
<b class="nc">&nbsp;                        weapon.getType().removeMode(&quot;HotLoad&quot;);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    for (Mounted ammo : e.getAmmo()) {</b>
<b class="nc">&nbsp;                        ammo.getType().removeMode(&quot;HotLoad&quot;);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Ends this phase and moves on to the next.
&nbsp;     */
&nbsp;    private void endCurrentPhase() {
<b class="nc">&nbsp;        switch (game.getPhase()) {</b>
&nbsp;            case PHASE_LOUNGE:
<b class="nc">&nbsp;                game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_EXCHANGE);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_EXCHANGE:
&nbsp;            case PHASE_STARTING_SCENARIO:
<b class="nc">&nbsp;                game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_SET_ARTYAUTOHITHEXES:
<b class="nc">&nbsp;                sendSpecialHexDisplayPackets();</b>
<b class="nc">&nbsp;                Enumeration&lt;IPlayer&gt; e = game.getPlayers();</b>
<b class="nc">&nbsp;                boolean mines = false;</b>
<b class="nc">&nbsp;                while (e.hasMoreElements() &amp;&amp; !mines) {</b>
<b class="nc">&nbsp;                    IPlayer p = e.nextElement();</b>
<b class="nc">&nbsp;                    if (p.hasMinefields()) {</b>
<b class="nc">&nbsp;                        mines = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                if (mines) {</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_DEPLOY_MINEFIELDS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_INITIATIVE);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_DEPLOY_MINEFIELDS:
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_INITIATIVE);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_DEPLOYMENT:
<b class="nc">&nbsp;                game.clearDeploymentThisRound();</b>
<b class="nc">&nbsp;                game.checkForCompleteDeployment();</b>
<b class="nc">&nbsp;                Enumeration&lt;IPlayer&gt; pls = game.getPlayers();</b>
<b class="nc">&nbsp;                while (pls.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    IPlayer p = pls.nextElement();</b>
<b class="nc">&nbsp;                    p.adjustStartingPosForReinforcements();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (game.getRoundCount() &lt; 1) {</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_INITIATIVE);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_TARGETING);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_INITIATIVE:
<b class="nc">&nbsp;                resolveWhatPlayersCanSeeWhatUnits();</b>
<b class="nc">&nbsp;                detectSpacecraft();</b>
<b class="nc">&nbsp;                game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_INITIATIVE_REPORT);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_INITIATIVE_REPORT:
&nbsp;                // NOTE: now that aeros can come and go from the battlefield, I
&nbsp;                // need
&nbsp;                // to update the
&nbsp;                // deployment table every round. I think this it is OK to go
&nbsp;                // here.
&nbsp;                // (Taharqa)
<b class="nc">&nbsp;                game.setupRoundDeployment();</b>
&nbsp;                // boolean doDeploy = game.shouldDeployThisRound() &amp;&amp;
&nbsp;                // (game.getLastPhase() != IGame.Phase.PHASE_DEPLOYMENT);
<b class="nc">&nbsp;                if (game.shouldDeployThisRound()) {</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_DEPLOYMENT);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_TARGETING);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_MOVEMENT:
<b class="nc">&nbsp;                detectHiddenUnits();</b>
<b class="nc">&nbsp;                updateSpacecraftDetection();</b>
<b class="nc">&nbsp;                detectSpacecraft();</b>
<b class="nc">&nbsp;                resolveWhatPlayersCanSeeWhatUnits();</b>
<b class="nc">&nbsp;                doAllAssaultDrops();</b>
<b class="nc">&nbsp;                addMovementHeat();</b>
<b class="nc">&nbsp;                applyBuildingDamage();</b>
<b class="nc">&nbsp;                checkForPSRFromDamage();</b>
<b class="nc">&nbsp;                addReport(resolvePilotingRolls()); // Skids cause damage in</b>
&nbsp;                // movement phase
<b class="nc">&nbsp;                checkForFlamingDamage();</b>
<b class="nc">&nbsp;                checkForTeleMissileAttacks();</b>
<b class="nc">&nbsp;                cleanupDestroyedNarcPods();</b>
<b class="nc">&nbsp;                checkForFlawedCooling();</b>
<b class="nc">&nbsp;                resolveCallSupport();</b>
&nbsp;                // check phase report
<b class="nc">&nbsp;                if (vPhaseReport.size() &gt; 1) {</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_MOVEMENT_REPORT);</b>
&nbsp;                } else {
&nbsp;                    // just the header, so we&#39;ll add the &lt;nothing&gt; label
<b class="nc">&nbsp;                    addReport(new Report(1205, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    sendReport();</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_OFFBOARD);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_MOVEMENT_REPORT:
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_OFFBOARD);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_FIRING:
&nbsp;                // write Weapon Attack Phase header
<b class="nc">&nbsp;                addReport(new Report(3000, Report.PUBLIC));</b>
<b class="nc">&nbsp;                resolveWhatPlayersCanSeeWhatUnits();</b>
<b class="nc">&nbsp;                resolveAllButWeaponAttacks();</b>
<b class="nc">&nbsp;                resolveSelfDestructions();</b>
<b class="nc">&nbsp;                reportGhostTargetRolls();</b>
<b class="nc">&nbsp;                reportLargeCraftECCMRolls();</b>
<b class="nc">&nbsp;                resolveOnlyWeaponAttacks();</b>
<b class="nc">&nbsp;                assignAMS();</b>
<b class="nc">&nbsp;                handleAttacks();</b>
<b class="nc">&nbsp;                resolveScheduledNukes();</b>
<b class="nc">&nbsp;                applyBuildingDamage();</b>
<b class="nc">&nbsp;                checkForPSRFromDamage();</b>
<b class="nc">&nbsp;                cleanupDestroyedNarcPods();</b>
<b class="nc">&nbsp;                addReport(resolvePilotingRolls());</b>
<b class="nc">&nbsp;                checkForFlawedCooling();</b>
&nbsp;                // check phase report
<b class="nc">&nbsp;                if (vPhaseReport.size() &gt; 1) {</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_FIRING_REPORT);</b>
&nbsp;                } else {
&nbsp;                    // just the header, so we&#39;ll add the &lt;nothing&gt; label
<b class="nc">&nbsp;                    addReport(new Report(1205, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    sendReport();</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_PHYSICAL);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_FIRING_REPORT:
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_PHYSICAL);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_PHYSICAL:
<b class="nc">&nbsp;                resolveWhatPlayersCanSeeWhatUnits();</b>
<b class="nc">&nbsp;                resolvePhysicalAttacks();</b>
<b class="nc">&nbsp;                applyBuildingDamage();</b>
<b class="nc">&nbsp;                checkForPSRFromDamage();</b>
<b class="nc">&nbsp;                addReport(resolvePilotingRolls());</b>
<b class="nc">&nbsp;                resolveSinkVees();</b>
<b class="nc">&nbsp;                cleanupDestroyedNarcPods();</b>
<b class="nc">&nbsp;                checkForFlawedCooling();</b>
<b class="nc">&nbsp;                checkForChainWhipGrappleChecks();</b>
&nbsp;                // check phase report
<b class="nc">&nbsp;                if (vPhaseReport.size() &gt; 1) {</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_PHYSICAL_REPORT);</b>
&nbsp;                } else {
&nbsp;                    // just the header, so we&#39;ll add the &lt;nothing&gt; label
<b class="nc">&nbsp;                    addReport(new Report(1205, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    sendReport();</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_END);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_PHYSICAL_REPORT:
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_END);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_TARGETING:
<b class="nc">&nbsp;                vPhaseReport.addElement(new Report(1035, Report.PUBLIC));</b>
<b class="nc">&nbsp;                resolveAllButWeaponAttacks();</b>
<b class="nc">&nbsp;                resolveOnlyWeaponAttacks();</b>
<b class="nc">&nbsp;                handleAttacks();</b>
&nbsp;                // check reports
<b class="nc">&nbsp;                if (vPhaseReport.size() &gt; 1) {</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_TARGETING_REPORT);</b>
&nbsp;                } else {
&nbsp;                    // just the header, so we&#39;ll add the &lt;nothing&gt; label
<b class="nc">&nbsp;                    vPhaseReport.addElement(new Report(1205, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    sendReport();</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_MOVEMENT);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                sendSpecialHexDisplayPackets();</b>
<b class="nc">&nbsp;                for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                    IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;                    int connId = player.getId();</b>
<b class="nc">&nbsp;                    send(connId, createArtilleryPacket(player));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_OFFBOARD:
&nbsp;                // write Offboard Attack Phase header
<b class="nc">&nbsp;                addReport(new Report(1100, Report.PUBLIC));</b>
<b class="nc">&nbsp;                resolveAllButWeaponAttacks(); // torso twist or flip arms</b>
&nbsp;                // possible
<b class="nc">&nbsp;                resolveOnlyWeaponAttacks(); // should only be TAG at this point</b>
<b class="nc">&nbsp;                handleAttacks();</b>
<b class="nc">&nbsp;                for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                    IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;                    int connId = player.getId();</b>
<b class="nc">&nbsp;                    send(connId, createArtilleryPacket(player));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                applyBuildingDamage();</b>
<b class="nc">&nbsp;                checkForPSRFromDamage();</b>
<b class="nc">&nbsp;                addReport(resolvePilotingRolls());</b>
&nbsp;
<b class="nc">&nbsp;                cleanupDestroyedNarcPods();</b>
<b class="nc">&nbsp;                checkForFlawedCooling();</b>
&nbsp;
<b class="nc">&nbsp;                sendSpecialHexDisplayPackets();</b>
<b class="nc">&nbsp;                sendTagInfoUpdates();</b>
&nbsp;
&nbsp;                // check reports
<b class="nc">&nbsp;                if (vPhaseReport.size() &gt; 1) {</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_OFFBOARD_REPORT);</b>
&nbsp;                } else {
&nbsp;                    // just the header, so we&#39;ll add the &lt;nothing&gt; label
<b class="nc">&nbsp;                    addReport(new Report(1205, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    sendReport();</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_FIRING);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_OFFBOARD_REPORT:
<b class="nc">&nbsp;                sendSpecialHexDisplayPackets();</b>
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_FIRING);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_TARGETING_REPORT:
<b class="nc">&nbsp;                changePhase(IGame.Phase.PHASE_MOVEMENT);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_END:
&nbsp;                // remove any entities that died in the heat/end phase before
&nbsp;                // checking for victory
<b class="nc">&nbsp;                resetEntityPhase(IGame.Phase.PHASE_END);</b>
<b class="nc">&nbsp;                boolean victory = victory(); // note this may add reports</b>
&nbsp;                // check phase report
&nbsp;                // HACK: hardcoded message ID check
<b class="nc">&nbsp;                if ((vPhaseReport.size() &gt; 3) || ((vPhaseReport.size() &gt; 1)</b>
<b class="nc">&nbsp;                        &amp;&amp; (vPhaseReport.elementAt(1).messageId != 1205))) {</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_END_REPORT);</b>
&nbsp;                } else {
&nbsp;                    // just the heat and end headers, so we&#39;ll add
&nbsp;                    // the &lt;nothing&gt; label
<b class="nc">&nbsp;                    addReport(new Report(1205, Report.PUBLIC));</b>
<b class="nc">&nbsp;                    game.addReports(vPhaseReport);</b>
<b class="nc">&nbsp;                    sendReport();</b>
<b class="nc">&nbsp;                    if (victory) {</b>
<b class="nc">&nbsp;                        changePhase(IGame.Phase.PHASE_VICTORY);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        changePhase(IGame.Phase.PHASE_INITIATIVE);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Decrement the ASEWAffected counter
<b class="nc">&nbsp;                decrementASEWTurns();</b>
&nbsp;
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_END_REPORT:
<b class="nc">&nbsp;                if (changePlayersTeam) {</b>
<b class="nc">&nbsp;                    processTeamChange();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (victory()) {</b>
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_VICTORY);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    changePhase(IGame.Phase.PHASE_INITIATIVE);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_VICTORY:
<b class="nc">&nbsp;                GameVictoryEvent gve = new GameVictoryEvent(this, game);</b>
<b class="nc">&nbsp;                game.processGameEvent(gve);</b>
<b class="nc">&nbsp;                transmitGameVictoryEventToAll();</b>
<b class="nc">&nbsp;                resetGame();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;        }
&nbsp;
&nbsp;        // Any hidden units that activated this phase, should clear their
&nbsp;        // activating phase
<b class="nc">&nbsp;        for (Entity ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (ent.getHiddenActivationPhase() == game.getPhase()) {</b>
<b class="nc">&nbsp;                ent.setHiddeActivationPhase(null);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendSpecialHexDisplayPackets() {
<b class="nc">&nbsp;        if (connections == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; connections.size(); i++) {</b>
<b class="nc">&nbsp;            if (connections.get(i) != null) {</b>
<b class="nc">&nbsp;                connections.get(i).send(createSpecialHexDisplayPacket(i));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendTagInfoUpdates() {
<b class="nc">&nbsp;        if (connections == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (IConnection connection : connections) {</b>
<b class="nc">&nbsp;            if (connection != null) {</b>
<b class="nc">&nbsp;                connection.send(createTagInfoUpdatesPacket());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendTagInfoReset() {
<b class="nc">&nbsp;        if (connections == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (IConnection connection : connections) {</b>
<b class="nc">&nbsp;            if (connection != null) {</b>
<b class="nc">&nbsp;                connection.send(new Packet(Packet.COMMAND_RESET_TAGINFO));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Increment&#39;s the server&#39;s game round and send it to all the clients
&nbsp;     */
&nbsp;    private void incrementAndSendGameRound() {
<b class="nc">&nbsp;        game.incrementRoundCount();</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ROUND_UPDATE, game.getRoundCount()));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Hand over a turn to the next player. This is only possible if you haven&#39;t
&nbsp;     * yet started your turn (i.e. not yet moved anything like infantry where
&nbsp;     * you have to move multiple units)
&nbsp;     *
&nbsp;     * @param connectionId - connection id of the player sending the packet
&nbsp;     */
&nbsp;    private void receiveForwardIni(int connectionId) {
&nbsp;        // this is the player sending the packet
<b class="nc">&nbsp;        IPlayer current = getPlayer(connectionId);</b>
&nbsp;
<b class="nc">&nbsp;        if (game.getTurn().getPlayerNum() != current.getId()) {</b>
&nbsp;            // this player is not the current player, so just ignore this
&nbsp;            // command!
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // if individual initiative is active we cannot forward our initiative
&nbsp;        // ever!
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if the player isn&#39;t on a team, there is no next team by definition. Skip the rest.
<b class="nc">&nbsp;        Team currentPlayerTeam = game.getTeamForPlayer(current);</b>
<b class="nc">&nbsp;        if (currentPlayerTeam == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // get the next player from the team this player is on.
<b class="nc">&nbsp;        IPlayer next = currentPlayerTeam.getNextValidPlayer(current, game);</b>
&nbsp;        
<b class="nc">&nbsp;        while (!next.equals(current)) {</b>
&nbsp;            // if the chosen player is a valid player, we change the turn order and
&nbsp;            // inform the clients.
<b class="nc">&nbsp;            if ((next != null) &amp;&amp; (game.getEntitiesOwnedBy(next) != 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getTurnForPlayer(next.getId()) != null)) {</b>
&nbsp;    
<b class="nc">&nbsp;                int currentTurnIndex = game.getTurnIndex();</b>
&nbsp;                // now look for the next occurrence of player next in the turn order
<b class="nc">&nbsp;                List&lt;GameTurn&gt; turns = game.getTurnVector();</b>
<b class="nc">&nbsp;                GameTurn turn = game.getTurn();</b>
&nbsp;                // not entirely necessary. As we will also check this for the
&nbsp;                // activity of the button but to be sure do it on the server too.
<b class="nc">&nbsp;                boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)</b>
&nbsp;                        &amp;&amp; !(turn instanceof GameTurn.UnitNumberTurn)
&nbsp;                        &amp;&amp; !(turn instanceof GameTurn.UnloadStrandedTurn);
<b class="nc">&nbsp;                if (!isGeneralMoveTurn) {</b>
&nbsp;                    // if this is not a general turn the player cannot forward his turn.
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;    
&nbsp;                // if it is an EntityClassTurn we have to check make sure, that the
&nbsp;                // turn it is exchanged with is the same kind of turn!
&nbsp;                // in fact this requires an access function to the mask of an
&nbsp;                // EntityClassTurn.
<b class="nc">&nbsp;                boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);</b>
<b class="nc">&nbsp;                int classMask = 0;</b>
<b class="nc">&nbsp;                if (isEntityClassTurn) {</b>
<b class="nc">&nbsp;                    classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();</b>
&nbsp;                }
&nbsp;    
<b class="nc">&nbsp;                boolean switched = false;</b>
<b class="nc">&nbsp;                int nextTurnId = 0;</b>
<b class="nc">&nbsp;                for (int i = currentTurnIndex; i &lt; turns.size(); i++) {</b>
&nbsp;                    // if we find a turn for the specific player, swap the current
&nbsp;                    // player with the player noted there
&nbsp;                    // and stop
<b class="nc">&nbsp;                    if (turns.get(i).isValid(next.getId(), game)) {</b>
<b class="nc">&nbsp;                        nextTurnId = i;</b>
<b class="nc">&nbsp;                        if (isEntityClassTurn) {</b>
&nbsp;                            // if we had an EntityClassTurn
<b class="nc">&nbsp;                            if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {</b>
&nbsp;                                // and found another EntityClassTurn
<b class="nc">&nbsp;                                if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {</b>
&nbsp;                                    // both have to refer to the SAME class(es) or
&nbsp;                                    // they need to be rejected.
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
&nbsp;                            } else {
&nbsp;                                continue;
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        switched = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;    
&nbsp;                // update turn order
<b class="nc">&nbsp;                if (switched) {</b>
<b class="nc">&nbsp;                    game.swapTurnOrder(currentTurnIndex, nextTurnId);</b>
&nbsp;                    // update the turn packages for all players.
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;                    send(createTurnIndexPacket(connectionId));</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;                // if nothing changed return without doing anything
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            next = currentPlayerTeam.getNextValidPlayer(next, game);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to change to the next turn. If there are no more turns, ends the
&nbsp;     * current phase. If the player whose turn it is next is not connected, we
&nbsp;     * allow the other players to skip that player.
&nbsp;     */
&nbsp;    private void changeToNextTurn(int prevPlayerId) {
<b class="nc">&nbsp;        boolean minefieldPhase = game.getPhase() == IGame.Phase.PHASE_DEPLOY_MINEFIELDS;</b>
<b class="nc">&nbsp;        boolean artyPhase = game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES;</b>
&nbsp;        
<b class="nc">&nbsp;        GameTurn nextTurn = null;</b>
<b class="nc">&nbsp;        Entity nextEntity = null;</b>
<b class="nc">&nbsp;        while (game.hasMoreTurns() &amp;&amp; (null == nextEntity)) {</b>
<b class="nc">&nbsp;            nextTurn = game.changeToNextTurn();</b>
<b class="nc">&nbsp;            nextEntity = game.getEntity(game.getFirstEntityNum(nextTurn));</b>
<b class="nc">&nbsp;            if (minefieldPhase || artyPhase) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;   
&nbsp;        // if there aren&#39;t any more valid turns, end the phase
&nbsp;        // note that some phases don&#39;t use entities
<b class="nc">&nbsp;        if (((null == nextEntity) &amp;&amp; !minefieldPhase) || ((null == nextTurn) &amp;&amp; minefieldPhase)) {</b>
<b class="nc">&nbsp;            endCurrentPhase();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IPlayer player = getPlayer(nextTurn.getPlayerNum());</b>
&nbsp;
<b class="nc">&nbsp;        if ((player != null) &amp;&amp; (game.getEntitiesOwnedBy(player) == 0)) {</b>
<b class="nc">&nbsp;            endCurrentTurn(null);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (prevPlayerId != -1) {</b>
<b class="nc">&nbsp;            send(createTurnIndexPacket(prevPlayerId));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            send(createTurnIndexPacket(player != null ? player.getId() : IPlayer.PLAYER_NONE));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((null != player) &amp;&amp; player.isGhost()) {</b>
<b class="nc">&nbsp;            sendGhostSkipMessage(player);</b>
<b class="nc">&nbsp;        } else if ((null == game.getFirstEntity()) &amp;&amp; (null != player) &amp;&amp; !minefieldPhase &amp;&amp; !artyPhase) {</b>
<b class="nc">&nbsp;            sendTurnErrorSkipMessage(player);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out a notification message indicating that a ghost player may be
&nbsp;     * skipped.
&nbsp;     *
&nbsp;     * @param ghost - the &lt;code&gt;Player&lt;/code&gt; who is ghosted. This value must not
&nbsp;     *              be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    private void sendGhostSkipMessage(IPlayer ghost) {
<b class="nc">&nbsp;        String message = &quot;Player &#39;&quot; + ghost.getName() +</b>
&nbsp;                &quot;&#39; is disconnected.  You may skip his/her current turn with the /skip command.&quot;;
<b class="nc">&nbsp;        sendServerChat(message);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out a notification message indicating that the current turn is an
&nbsp;     * error and should be skipped.
&nbsp;     *
&nbsp;     * @param skip - the &lt;code&gt;Player&lt;/code&gt; who is to be skipped. This value
&nbsp;     *             must not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    private void sendTurnErrorSkipMessage(IPlayer skip) {
<b class="nc">&nbsp;        String message = &quot;Player &#39;&quot; + skip.getName() +</b>
&nbsp;                &quot;&#39; has no units to move.  You should skip his/her/your current turn with the /skip command. &quot; +
&nbsp;                &quot;You may want to report this error at https://github.com/MegaMek/megamek/issues&quot;;
<b class="nc">&nbsp;        sendServerChat(message);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Skips the current turn. This only makes sense in phases that have turns.
&nbsp;     * Operates by finding an entity to move and then doing nothing with it.
&nbsp;     */
&nbsp;    public void skipCurrentTurn() {
&nbsp;        // find an entity to skip...
<b class="nc">&nbsp;        Entity toSkip = game.getFirstEntity();</b>
&nbsp;
<b class="nc">&nbsp;        switch (game.getPhase()) {</b>
&nbsp;            case PHASE_DEPLOYMENT:
&nbsp;                // allow skipping during deployment,
&nbsp;                // we need that when someone removes a unit.
<b class="nc">&nbsp;                endCurrentTurn(null);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_MOVEMENT:
<b class="nc">&nbsp;                if (toSkip != null) {</b>
<b class="nc">&nbsp;                    processMovement(toSkip, new MovePath(game, toSkip), null);</b>
&nbsp;                }
<b class="nc">&nbsp;                endCurrentTurn(toSkip);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_FIRING:
&nbsp;            case PHASE_PHYSICAL:
&nbsp;            case PHASE_TARGETING:
&nbsp;            case PHASE_OFFBOARD:
<b class="nc">&nbsp;                if (toSkip != null) {</b>
<b class="nc">&nbsp;                    processAttack(toSkip, new Vector&lt;&gt;(0));</b>
&nbsp;                }
<b class="nc">&nbsp;                endCurrentTurn(toSkip);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the current turn may be skipped. Ghost players&#39; turns are
&nbsp;     * skippable, and a turn should be skipped if there&#39;s nothing to move.
&nbsp;     */
&nbsp;    public boolean isTurnSkippable() {
<b class="nc">&nbsp;        GameTurn turn = game.getTurn();</b>
<b class="nc">&nbsp;        if (null == turn) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        IPlayer player = getPlayer(turn.getPlayerNum());</b>
<b class="nc">&nbsp;        return (null == player) || player.isGhost() || (game.getFirstEntity() == null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if victory conditions have been met. Victory conditions are
&nbsp;     * when there is only one player left with mechs or only one team. will also
&nbsp;     * add some reports to reporting
&nbsp;     */
&nbsp;    public boolean victory() {
<b class="nc">&nbsp;        VictoryResult vr = game.getVictory().checkForVictory(game, game.getVictoryContext());</b>
<b class="nc">&nbsp;        for (Report r : vr.getReports()) {</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (vr.victory()) {</b>
<b class="nc">&nbsp;            boolean draw = vr.isDraw();</b>
<b class="nc">&nbsp;            int wonPlayer = vr.getWinningPlayer();</b>
<b class="nc">&nbsp;            int wonTeam = vr.getWinningTeam();</b>
&nbsp;
<b class="nc">&nbsp;            if (wonPlayer != IPlayer.PLAYER_NONE) {</b>
<b class="nc">&nbsp;                Report r = new Report(7200, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.add(Server.getColorForPlayer(game.getPlayer(wonPlayer)));</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wonTeam != IPlayer.TEAM_NONE) {</b>
<b class="nc">&nbsp;                Report r = new Report(7200, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.add(&quot;Team &quot; + wonTeam);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (draw) {</b>
&nbsp;                // multiple-won draw
<b class="nc">&nbsp;                game.setVictoryPlayerId(IPlayer.PLAYER_NONE);</b>
<b class="nc">&nbsp;                game.setVictoryTeam(IPlayer.TEAM_NONE);</b>
&nbsp;            } else {
&nbsp;                // nobody-won draw or
&nbsp;                // single player won or
&nbsp;                // single team won
<b class="nc">&nbsp;                game.setVictoryPlayerId(wonPlayer);</b>
<b class="nc">&nbsp;                game.setVictoryTeam(wonTeam);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            game.setVictoryPlayerId(IPlayer.PLAYER_NONE);</b>
<b class="nc">&nbsp;            game.setVictoryTeam(IPlayer.TEAM_NONE);</b>
<b class="nc">&nbsp;            if (game.isForceVictory()) {</b>
<b class="nc">&nbsp;                cancelVictory();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vr.victory();</b>
&nbsp;    }// end victory
&nbsp;
&nbsp;    private boolean isPlayerForcedVictory() {
&nbsp;        // check game options
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.VICTORY_SKIP_FORCED_VICTORY)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.isForceVictory()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (IPlayer player : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;            if ((player.getId() == game.getVictoryPlayerId()) || ((player.getTeam() == game.getVictoryTeam())</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getVictoryTeam() != IPlayer.TEAM_NONE))) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!player.admitsDefeat()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies board settings. This loads and combines all the boards that were
&nbsp;     * specified into one mega-board and sets that board as current.
&nbsp;     */
&nbsp;    public void applyBoardSettings() {
<b class="nc">&nbsp;        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);</b>
<b class="nc">&nbsp;        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);</b>
<b class="nc">&nbsp;        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth()</b>
<b class="nc">&nbsp;                * mapSettings.getMapHeight()];</b>
<b class="nc">&nbsp;        List&lt;Boolean&gt; rotateBoard = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; (mapSettings.getMapWidth() * mapSettings</b>
<b class="nc">&nbsp;                .getMapHeight()); i++) {</b>
<b class="nc">&nbsp;            sheetBoards[i] = new Board();</b>
<b class="nc">&nbsp;            String name = mapSettings.getBoardsSelectedVector().get(i);</b>
<b class="nc">&nbsp;            boolean isRotated = false;</b>
<b class="nc">&nbsp;            if (name.startsWith(Board.BOARD_REQUEST_ROTATION)) {</b>
&nbsp;                // only rotate boards with an even width
<b class="nc">&nbsp;                if ((mapSettings.getBoardWidth() % 2) == 0) {</b>
<b class="nc">&nbsp;                    isRotated = true;</b>
&nbsp;                }
<b class="nc">&nbsp;                name = name.substring(Board.BOARD_REQUEST_ROTATION.length());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (name.startsWith(MapSettings.BOARD_GENERATED)</b>
<b class="nc">&nbsp;                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {</b>
<b class="nc">&nbsp;                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name</b>
<b class="nc">&nbsp;                        + &quot;.board&quot;).getFile());</b>
<b class="nc">&nbsp;                BoardUtilities.flip(sheetBoards[i], isRotated, isRotated);</b>
&nbsp;            }
<b class="nc">&nbsp;            rotateBoard.add(isRotated);</b>
&nbsp;        }
<b class="nc">&nbsp;        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(),</b>
<b class="nc">&nbsp;                mapSettings.getBoardHeight(), mapSettings.getMapWidth(),</b>
<b class="nc">&nbsp;                mapSettings.getMapHeight(), sheetBoards, rotateBoard,</b>
<b class="nc">&nbsp;                mapSettings.getMedium());</b>
<b class="nc">&nbsp;        if (game.getOptions().getOption(OptionsConstants.BASE_BRIDGECF).intValue() &gt; 0) {</b>
<b class="nc">&nbsp;            newBoard.setBridgeCF(game.getOptions().getOption(OptionsConstants.BASE_BRIDGECF).intValue());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.BASE_RANDOM_BASEMENTS)) {</b>
<b class="nc">&nbsp;            newBoard.setRandomBasementsOff();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().isTerrainAffected()) {</b>
<b class="nc">&nbsp;            BoardUtilities.addWeatherConditions(newBoard, game.getPlanetaryConditions().getWeather(),</b>
<b class="nc">&nbsp;                    game.getPlanetaryConditions().getWindStrength());</b>
&nbsp;        }
<b class="nc">&nbsp;        game.setBoard(newBoard);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls initiative for all the players.
&nbsp;     */
&nbsp;    private void rollInitiative() {
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {</b>
<b class="nc">&nbsp;            TurnOrdered.rollInitiative(game.getEntitiesVector(), false);</b>
&nbsp;        } else {
&nbsp;            // Roll for initiative on the teams.
<b class="nc">&nbsp;            TurnOrdered.rollInitiative(game.getTeamsVector(),</b>
<b class="nc">&nbsp;                    game.getOptions().booleanOption(OptionsConstants.INIT_INITIATIVE_STREAK_COMPENSATION)</b>
<b class="nc">&nbsp;                    &amp;&amp; !game.shouldDeployThisRound());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        transmitAllPlayerUpdates();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Vector&lt;GameTurn&gt; checkTurnOrderStranded(TurnVectors team_order) {
<b class="nc">&nbsp;        Vector&lt;GameTurn&gt; turns = new Vector&lt;&gt;(team_order.getTotalTurns()</b>
<b class="nc">&nbsp;                + team_order.getEvenTurns());</b>
&nbsp;        // Stranded units only during movement phases, rebuild the turns vector
<b class="nc">&nbsp;        if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</b>
&nbsp;            // See if there are any loaded units stranded on immobile transports.
<b class="nc">&nbsp;            Iterator&lt;Entity&gt; strandedUnits = game.getSelectedEntities(</b>
<b class="nc">&nbsp;                    entity -&gt; game.isEntityStranded(entity));</b>
<b class="nc">&nbsp;            if (strandedUnits.hasNext()) {</b>
&nbsp;                // Add a game turn to unload stranded units, if this
&nbsp;                // is the movement phase.
<b class="nc">&nbsp;                turns = new Vector&lt;&gt;(team_order.getTotalTurns()</b>
<b class="nc">&nbsp;                        + team_order.getEvenTurns() + 1);</b>
<b class="nc">&nbsp;                turns.addElement(new GameTurn.UnloadStrandedTurn(strandedUnits));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return turns;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the turn oder for a given phase (with individual init)
&nbsp;     *
&nbsp;     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase
&nbsp;     */
&nbsp;    private void determineTurnOrderIUI(IGame.Phase phase) {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; loop = game.getEntities(); loop.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = loop.next();</b>
<b class="nc">&nbsp;            entity.resetOtherTurns();</b>
<b class="nc">&nbsp;            if (entity.isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                entity.incrementOtherTurns();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        List&lt;Entity&gt; entities;
&nbsp;        // If the protos move multi option isn&#39;t on, protos move as a unit
&nbsp;        // Need to adjust entities vector otherwise we&#39;ll have too many turns
&nbsp;        // when first proto in a unit moves, new turns get added so rest of the
&nbsp;        // unit will move
<b class="nc">&nbsp;        boolean protosMoveMulti = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.INIT_PROTOS_MOVE_MULTI);
<b class="nc">&nbsp;        if (!protosMoveMulti) {</b>
<b class="nc">&nbsp;            entities = new ArrayList&lt;&gt;(game.getEntitiesVector().size());</b>
<b class="nc">&nbsp;            Set&lt;Short&gt; movedUnits = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Entity e : game.getEntitiesVector()) {</b>
&nbsp;                // This only effects Protos for the time being
<b class="nc">&nbsp;                if (!(e instanceof Protomech)) {</b>
<b class="nc">&nbsp;                    entities.add(e);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                short unitNumber = e.getUnitNumber();</b>
<b class="nc">&nbsp;                if ((unitNumber == Entity.NONE)</b>
<b class="nc">&nbsp;                        || !movedUnits.contains(unitNumber)) {</b>
<b class="nc">&nbsp;                    entities.add(e);</b>
<b class="nc">&nbsp;                    if (unitNumber != Entity.NONE) {</b>
<b class="nc">&nbsp;                        movedUnits.add(unitNumber);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            entities = game.getEntitiesVector();</b>
&nbsp;        }
&nbsp;        // Now, generate the global order of all teams&#39; turns.
<b class="nc">&nbsp;        TurnVectors team_order = TurnOrdered.generateTurnOrder(entities, game);</b>
&nbsp;
&nbsp;        // Now, we collect everything into a single vector.
<b class="nc">&nbsp;        Vector&lt;GameTurn&gt; turns = checkTurnOrderStranded(team_order);</b>
&nbsp;
&nbsp;        // add the turns (this is easy)
<b class="nc">&nbsp;        while (team_order.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Entity e = (Entity) team_order.nextElement();</b>
<b class="nc">&nbsp;            if (e.isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                if (!protosMoveMulti &amp;&amp; (e instanceof Protomech) &amp;&amp; (e.getUnitNumber() != Entity.NONE)) {</b>
<b class="nc">&nbsp;                    turns.addElement(new GameTurn.UnitNumberTurn(e.getOwnerId(), e.getUnitNumber()));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    turns.addElement(new GameTurn.SpecificEntityTurn(e.getOwnerId(), e.getId()));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // set fields in game
<b class="nc">&nbsp;        game.setTurnVector(turns);</b>
<b class="nc">&nbsp;        game.resetTurnIndex();</b>
&nbsp;
&nbsp;        // send turns to all players
<b class="nc">&nbsp;        send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the turn order for a given phase
&nbsp;     *
&nbsp;     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase
&nbsp;     */
&nbsp;    private void determineTurnOrder(IGame.Phase phase) {
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {</b>
<b class="nc">&nbsp;            determineTurnOrderIUI(phase);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // and/or deploy even according to game options.
<b class="nc">&nbsp;        boolean infMoveEven = (game.getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_EVEN)</b>
<b class="nc">&nbsp;                &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)))</b>
<b class="nc">&nbsp;                || (game.getOptions().booleanOption(OptionsConstants.INIT_INF_DEPLOY_EVEN)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT));</b>
<b class="nc">&nbsp;        boolean infMoveMulti = game.getOptions()</b>
<b class="nc">&nbsp;                .booleanOption(OptionsConstants.INIT_INF_MOVE_MULTI)</b>
<b class="nc">&nbsp;                &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE)</b>
<b class="nc">&nbsp;                || ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)));</b>
<b class="nc">&nbsp;        boolean protosMoveEven = (game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.INIT_PROTOS_MOVE_EVEN)
<b class="nc">&nbsp;                &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE)</b>
<b class="nc">&nbsp;                || ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))))</b>
<b class="nc">&nbsp;                || (game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_EVEN)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT));</b>
<b class="nc">&nbsp;        boolean protosMoveMulti = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.INIT_PROTOS_MOVE_MULTI);
<b class="nc">&nbsp;        boolean protosMoveByPoint = !protosMoveMulti;</b>
<b class="nc">&nbsp;        boolean tankMoveByLance = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT)
<b class="nc">&nbsp;                &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE)</b>
<b class="nc">&nbsp;                || ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)));</b>
<b class="nc">&nbsp;        boolean mekMoveByLance = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT)
<b class="nc">&nbsp;                &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_INITIATIVE)</b>
<b class="nc">&nbsp;                || ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)));</b>
&nbsp;
<b class="nc">&nbsp;        int evenMask = 0;</b>
<b class="nc">&nbsp;        if (infMoveEven) {</b>
<b class="nc">&nbsp;            evenMask += GameTurn.CLASS_INFANTRY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (protosMoveEven) {</b>
<b class="nc">&nbsp;            evenMask += GameTurn.CLASS_PROTOMECH;</b>
&nbsp;        }
&nbsp;        // Reset all of the Players&#39; turn category counts
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; loop = game.getPlayers(); loop.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = loop.nextElement();</b>
<b class="nc">&nbsp;            player.resetEvenTurns();</b>
<b class="nc">&nbsp;            player.resetMultiTurns();</b>
<b class="nc">&nbsp;            player.resetOtherTurns();</b>
<b class="nc">&nbsp;            player.resetSpaceStationTurns();</b>
<b class="nc">&nbsp;            player.resetJumpshipTurns();</b>
<b class="nc">&nbsp;            player.resetWarshipTurns();</b>
<b class="nc">&nbsp;            player.resetDropshipTurns();</b>
<b class="nc">&nbsp;            player.resetSmallCraftTurns();</b>
<b class="nc">&nbsp;            player.resetAeroTurns();</b>
&nbsp;
&nbsp;            // Add turns for ProtoMechs weapons declaration.
<b class="nc">&nbsp;            if (protosMoveByPoint) {</b>
&nbsp;
&nbsp;                // How many ProtoMechs does the player have?
<b class="nc">&nbsp;                Iterator&lt;Entity&gt; playerProtos = game.getSelectedEntities(new EntitySelector() {</b>
<b class="nc">&nbsp;                            private final int ownerId = player.getId();</b>
&nbsp;
&nbsp;                            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                                return (entity instanceof Protomech)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (ownerId == entity.getOwnerId())</b>
<b class="nc">&nbsp;                                        &amp;&amp; entity.isSelectableThisTurn();</b>
&nbsp;                            }
&nbsp;                        });
<b class="nc">&nbsp;                HashSet&lt;Integer&gt; points = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                int numPlayerProtos = 0;</b>
<b class="nc">&nbsp;                for (; playerProtos.hasNext(); ) {</b>
<b class="nc">&nbsp;                    Entity proto = playerProtos.next();</b>
<b class="nc">&nbsp;                    numPlayerProtos++;</b>
<b class="nc">&nbsp;                    points.add((int) proto.getUnitNumber());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                int numProtoUnits = (int) Math.ceil(numPlayerProtos / 5.0);</b>
<b class="nc">&nbsp;                if (!protosMoveEven) {</b>
<b class="nc">&nbsp;                    numProtoUnits = points.size();</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int unit = 0; unit &lt; numProtoUnits; unit++) {</b>
<b class="nc">&nbsp;                    if (protosMoveEven) {</b>
<b class="nc">&nbsp;                        player.incrementEvenTurns();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        player.incrementOtherTurns();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            } // End handle-proto-firing-turns
&nbsp;
<b class="nc">&nbsp;        } // Handle the next player</b>
&nbsp;
&nbsp;        // Go through all entities, and update the turn categories of the
&nbsp;        // entity&#39;s player. The teams get their totals from their players.
&nbsp;        // N.B. ProtoMechs declare weapons fire based on their point.
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; loop = game.getEntities(); loop.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = loop.next();</b>
<b class="nc">&nbsp;            if (entity.isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                final IPlayer player = entity.getOwner();</b>
<b class="nc">&nbsp;                if ((entity instanceof SpaceStation)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {</b>
<b class="nc">&nbsp;                    player.incrementSpaceStationTurns();</b>
<b class="nc">&nbsp;                } else if ((entity instanceof Warship)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {</b>
<b class="nc">&nbsp;                    player.incrementWarshipTurns();</b>
<b class="nc">&nbsp;                } else if ((entity instanceof Jumpship)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {</b>
<b class="nc">&nbsp;                    player.incrementJumpshipTurns();</b>
<b class="nc">&nbsp;                } else if ((entity instanceof Dropship) &amp;&amp; entity.isAirborne()</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {</b>
<b class="nc">&nbsp;                    player.incrementDropshipTurns();</b>
<b class="nc">&nbsp;                } else if ((entity instanceof SmallCraft) &amp;&amp; entity.isAirborne()</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {</b>
<b class="nc">&nbsp;                    player.incrementSmallCraftTurns();</b>
<b class="nc">&nbsp;                } else if (entity.isAirborne()</b>
<b class="nc">&nbsp;                        &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                                || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT))) {</b>
<b class="nc">&nbsp;                    player.incrementAeroTurns();</b>
<b class="nc">&nbsp;                } else if ((entity instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    if (infMoveEven) {</b>
<b class="nc">&nbsp;                        player.incrementEvenTurns();</b>
<b class="nc">&nbsp;                    } else if (infMoveMulti) {</b>
<b class="nc">&nbsp;                        player.incrementMultiTurns(GameTurn.CLASS_INFANTRY);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        player.incrementOtherTurns();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                    if (!protosMoveByPoint) {</b>
<b class="nc">&nbsp;                        if (protosMoveEven) {</b>
<b class="nc">&nbsp;                            player.incrementEvenTurns();</b>
<b class="nc">&nbsp;                        } else if (protosMoveMulti) {</b>
<b class="nc">&nbsp;                            player.incrementMultiTurns(GameTurn.CLASS_PROTOMECH);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            player.incrementOtherTurns();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((entity instanceof Tank) &amp;&amp; tankMoveByLance) {</b>
<b class="nc">&nbsp;                    player.incrementMultiTurns(GameTurn.CLASS_TANK);</b>
<b class="nc">&nbsp;                } else if ((entity instanceof Mech) &amp;&amp; mekMoveByLance) {</b>
<b class="nc">&nbsp;                    player.incrementMultiTurns(GameTurn.CLASS_MECH);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    player.incrementOtherTurns();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Generate the turn order for the Players *within*
&nbsp;        // each Team. Map the teams to their turn orders.
&nbsp;        // Count the number of teams moving this turn.
<b class="nc">&nbsp;        int nTeams = game.getNoOfTeams();</b>
<b class="nc">&nbsp;        Hashtable&lt;Team, TurnVectors&gt; allTeamTurns = new Hashtable&lt;&gt;(nTeams);</b>
<b class="nc">&nbsp;        Hashtable&lt;Team, int[]&gt; evenTrackers = new Hashtable&lt;&gt;(nTeams);</b>
<b class="nc">&nbsp;        int numTeamsMoving = 0;</b>
<b class="nc">&nbsp;        for (Enumeration&lt;Team&gt; loop = game.getTeams(); loop.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final Team team = loop.nextElement();</b>
<b class="nc">&nbsp;            allTeamTurns.put(team, team.determineTeamOrder(game));</b>
&nbsp;
&nbsp;            // Track both the number of times we&#39;ve checked the team for
&nbsp;            // &quot;leftover&quot; turns, and the number of &quot;leftover&quot; turns placed.
<b class="nc">&nbsp;            int[] evenTracker = new int[2];</b>
<b class="nc">&nbsp;            evenTrackers.put(team, evenTracker);</b>
&nbsp;
&nbsp;            // Count this team if it has any &quot;normal&quot; moves.
<b class="nc">&nbsp;            if (team.getNormalTurns(game) &gt; 0) {</b>
<b class="nc">&nbsp;                numTeamsMoving++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Now, generate the global order of all teams&#39; turns.
<b class="nc">&nbsp;        TurnVectors team_order = TurnOrdered.generateTurnOrder(game.getTeamsVector(), game);</b>
&nbsp;
&nbsp;        // Now, we collect everything into a single vector.
<b class="nc">&nbsp;        Vector&lt;GameTurn&gt; turns = checkTurnOrderStranded(team_order);</b>
&nbsp;
&nbsp;        // Walk through the global order, assigning turns
&nbsp;        // for individual players to the single vector.
&nbsp;        // Keep track of how many turns we&#39;ve added to the vector.
<b class="nc">&nbsp;        Team prevTeam = null;</b>
<b class="nc">&nbsp;        int min = team_order.getMin();</b>
<b class="nc">&nbsp;        for (int numTurn = 0; team_order.hasMoreElements(); numTurn++) {</b>
<b class="nc">&nbsp;            Team team = (Team) team_order.nextElement();</b>
<b class="nc">&nbsp;            TurnVectors withinTeamTurns = allTeamTurns.get(team);</b>
&nbsp;
<b class="nc">&nbsp;            int[] evenTracker = evenTrackers.get(team);</b>
<b class="nc">&nbsp;            float teamEvenTurns = team.getEvenTurns();</b>
&nbsp;
&nbsp;            // Calculate the number of &quot;even&quot; turns to add for this team.
<b class="nc">&nbsp;            int numEven = 0;</b>
<b class="nc">&nbsp;            if (1 == numTeamsMoving) {</b>
&nbsp;                // If there&#39;s only one team moving, we don&#39;t need to bother
&nbsp;                // with the evenTracker, just make sure the even turns are
&nbsp;                // evenly distributed
<b class="nc">&nbsp;                numEven += (int) Math.round(teamEvenTurns / min);</b>
<b class="nc">&nbsp;            } else if (prevTeam == null) {</b>
&nbsp;                // Increment the number of times we&#39;ve checked for &quot;leftovers&quot;.
<b class="nc">&nbsp;                evenTracker[0]++;</b>
&nbsp;
&nbsp;                // The first team to move just adds the &quot;baseline&quot; turns.
<b class="nc">&nbsp;                numEven += Math.round(teamEvenTurns / min);</b>
<b class="nc">&nbsp;            } else if (!team.equals(prevTeam)) {</b>
&nbsp;                // Increment the number of times we&#39;ve checked for &quot;leftovers&quot;.
<b class="nc">&nbsp;                evenTracker[0]++;</b>
&nbsp;
&nbsp;                // This weird equation attempts to spread the &quot;leftover&quot;
&nbsp;                // turns across the turn&#39;s moves in a &quot;fair&quot; manner.
&nbsp;                // It&#39;s based on the number of times we&#39;ve checked for
&nbsp;                // &quot;leftovers&quot; the number of &quot;leftovers&quot; we started with,
&nbsp;                // the number of times we&#39;ve added a turn for a &quot;leftover&quot;,
&nbsp;                // and the total number of times we&#39;re going to check.
<b class="nc">&nbsp;                numEven += (int) Math.ceil(((evenTracker[0] * (teamEvenTurns % min)) / min) - 0.5)</b>
&nbsp;                           - evenTracker[1];
&nbsp;
&nbsp;                // Update the number of turns actually added for &quot;leftovers&quot;.
<b class="nc">&nbsp;                evenTracker[1] += numEven;</b>
&nbsp;
&nbsp;                // Add the &quot;baseline&quot; number of turns.
<b class="nc">&nbsp;                numEven += Math.round(teamEvenTurns / min);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Record this team for the next move.
<b class="nc">&nbsp;            prevTeam = team;</b>
&nbsp;
<b class="nc">&nbsp;            int aeroMask = GameTurn.CLASS_AERO + GameTurn.CLASS_SMALL_CRAFT</b>
&nbsp;                           + GameTurn.CLASS_DROPSHIP + GameTurn.CLASS_JUMPSHIP
&nbsp;                           + GameTurn.CLASS_WARSHIP + GameTurn.CLASS_SPACE_STATION;
&nbsp;            GameTurn turn;
&nbsp;            IPlayer player;
<b class="nc">&nbsp;            if (withinTeamTurns.hasMoreNormalElements()) {</b>
&nbsp;                // Not a placeholder... get the player who moves next.
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextNormalElement();</b>
&nbsp;
&nbsp;                // If we&#39;ve added all &quot;normal&quot; turns, allocate turns
&nbsp;                // for the infantry and/or ProtoMechs moving even.
<b class="nc">&nbsp;                if (numTurn &gt;= team_order.getTotalTurns()) {</b>
<b class="nc">&nbsp;                    turn = new GameTurn.EntityClassTurn(player.getId(), evenMask);</b>
&nbsp;                }
&nbsp;                // If either Infantry or ProtoMechs move even, only allow
&nbsp;                // the other classes to move during the &quot;normal&quot; turn.
<b class="nc">&nbsp;                else if (infMoveEven || protosMoveEven) {</b>
<b class="nc">&nbsp;                    int newMask = evenMask;</b>
&nbsp;                    // if this is the movement phase, then don&#39;t allow Aeros on
&nbsp;                    // normal turns
<b class="nc">&nbsp;                    if ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                            || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)) {</b>
<b class="nc">&nbsp;                        newMask += aeroMask;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    turn = new GameTurn.EntityClassTurn(player.getId(), ~newMask);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // Otherwise, let *anybody* move.
&nbsp;                else {
&nbsp;                    // well, almost anybody; Aero don&#39;t get normal turns during
&nbsp;                    // the movement phase
<b class="nc">&nbsp;                    if ((game.getPhase() == IGame.Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                            || (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT)) {</b>
<b class="nc">&nbsp;                        turn = new GameTurn.EntityClassTurn(player.getId(), ~aeroMask);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        turn = new GameTurn(player.getId());</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                turns.addElement(turn);</b>
&nbsp;            } // End team-has-&quot;normal&quot;-turns
<b class="nc">&nbsp;            else if (withinTeamTurns.hasMoreSpaceStationElements()) {</b>
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextSpaceStationElement();</b>
<b class="nc">&nbsp;                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_SPACE_STATION);</b>
<b class="nc">&nbsp;                turns.addElement(turn);</b>
<b class="nc">&nbsp;            } else if (withinTeamTurns.hasMoreJumpshipElements()) {</b>
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextJumpshipElement();</b>
<b class="nc">&nbsp;                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_JUMPSHIP);</b>
<b class="nc">&nbsp;                turns.addElement(turn);</b>
<b class="nc">&nbsp;            } else if (withinTeamTurns.hasMoreWarshipElements()) {</b>
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextWarshipElement();</b>
<b class="nc">&nbsp;                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_WARSHIP);</b>
<b class="nc">&nbsp;                turns.addElement(turn);</b>
<b class="nc">&nbsp;            } else if (withinTeamTurns.hasMoreDropshipElements()) {</b>
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextDropshipElement();</b>
<b class="nc">&nbsp;                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_DROPSHIP);</b>
<b class="nc">&nbsp;                turns.addElement(turn);</b>
<b class="nc">&nbsp;            } else if (withinTeamTurns.hasMoreSmallCraftElements()) {</b>
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextSmallCraftElement();</b>
<b class="nc">&nbsp;                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_SMALL_CRAFT);</b>
<b class="nc">&nbsp;                turns.addElement(turn);</b>
<b class="nc">&nbsp;            } else if (withinTeamTurns.hasMoreAeroElements()) {</b>
<b class="nc">&nbsp;                player = (IPlayer) withinTeamTurns.nextAeroElement();</b>
<b class="nc">&nbsp;                turn = new GameTurn.EntityClassTurn(player.getId(), GameTurn.CLASS_AERO);</b>
<b class="nc">&nbsp;                turns.addElement(turn);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Add the calculated number of &quot;even&quot; turns.
&nbsp;            // Allow the player at least one &quot;normal&quot; turn before the
&nbsp;            // &quot;even&quot; turns to help with loading infantry in deployment.
<b class="nc">&nbsp;            while ((numEven &gt; 0) &amp;&amp; withinTeamTurns.hasMoreEvenElements()) {</b>
<b class="nc">&nbsp;                IPlayer evenPlayer = (IPlayer) withinTeamTurns.nextEvenElement();</b>
<b class="nc">&nbsp;                turns.addElement(new GameTurn.EntityClassTurn(evenPlayer.getId(), evenMask));</b>
<b class="nc">&nbsp;                numEven--;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // set fields in game
<b class="nc">&nbsp;        game.setTurnVector(turns);</b>
<b class="nc">&nbsp;        game.resetTurnIndex();</b>
&nbsp;
&nbsp;        // send turns to all players
<b class="nc">&nbsp;        send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static String getColorForPlayer(IPlayer p) {
<b class="nc">&nbsp;        return &quot;&lt;B&gt;&lt;font color=&#39;&quot; + p.getColour().getHexString(0x00F0F0F0) + &quot;&#39;&gt;&quot; + p.getName() + &quot;&lt;/font&gt;&lt;/B&gt;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Write the initiative results to the report
&nbsp;     */
&nbsp;    private void writeInitiativeReport(boolean abbreviatedReport) {
&nbsp;        // write to report
&nbsp;        Report r;
<b class="nc">&nbsp;        boolean deployment = false;</b>
<b class="nc">&nbsp;        if (!abbreviatedReport) {</b>
<b class="nc">&nbsp;            r = new Report(1210);</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            if ((game.getLastPhase() == IGame.Phase.PHASE_DEPLOYMENT) || game.isDeploymentComplete()</b>
<b class="nc">&nbsp;                    || !game.shouldDeployThisRound()) {</b>
<b class="nc">&nbsp;                r.messageId = 1000;</b>
<b class="nc">&nbsp;                r.add(game.getRoundCount());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                deployment = true;</b>
<b class="nc">&nbsp;                if (game.getRoundCount() == 0) {</b>
<b class="nc">&nbsp;                    r.messageId = 1005;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.messageId = 1010;</b>
<b class="nc">&nbsp;                    r.add(game.getRoundCount());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // write separator
<b class="nc">&nbsp;            addReport(new Report(1200, Report.PUBLIC));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            addReport(new Report(1210, Report.PUBLIC));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {</b>
<b class="nc">&nbsp;            r = new Report(1040, Report.PUBLIC);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            for (Enumeration&lt;GameTurn&gt; e = game.getTurns(); e.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                GameTurn t = e.nextElement();</b>
<b class="nc">&nbsp;                if (t instanceof GameTurn.SpecificEntityTurn) {</b>
<b class="nc">&nbsp;                    Entity entity = game.getEntity(((GameTurn.SpecificEntityTurn) t).getEntityNum());</b>
<b class="nc">&nbsp;                    r = new Report(1045);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(entity.getInitiative().toString());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    IPlayer player = getPlayer(t.getPlayerNum());</b>
<b class="nc">&nbsp;                    if (null != player) {</b>
<b class="nc">&nbsp;                        r = new Report(1050, Report.PUBLIC);</b>
<b class="nc">&nbsp;                        r.add(Server.getColorForPlayer(player));</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
<b class="nc">&nbsp;            for (Enumeration&lt;Team&gt; i = game.getTeams(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                final Team team = i.nextElement();</b>
&nbsp;
&nbsp;                // Teams with no active players can be ignored
<b class="nc">&nbsp;                if (team.isObserverTeam()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If there is only one non-observer player, list
&nbsp;                // them as the &#39;team&#39;, and use the team initiative
<b class="nc">&nbsp;                if (team.getNonObserverSize() == 1) {</b>
<b class="nc">&nbsp;                    final IPlayer player = team.getNonObserverPlayers().nextElement();</b>
<b class="nc">&nbsp;                    r = new Report(1015, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(Server.getColorForPlayer(player));</b>
<b class="nc">&nbsp;                    r.add(team.getInitiative().toString());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // Multiple players. List the team, then break it down.
<b class="nc">&nbsp;                    r = new Report(1015, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(IPlayer.teamNames[team.getId()]);</b>
<b class="nc">&nbsp;                    r.add(team.getInitiative().toString());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    for (Enumeration&lt;IPlayer&gt; j = team.getNonObserverPlayers(); j.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                        final IPlayer player = j.nextElement();</b>
<b class="nc">&nbsp;                        r = new Report(1015, Report.PUBLIC);</b>
<b class="nc">&nbsp;                        r.indent();</b>
<b class="nc">&nbsp;                        r.add(player.getName());</b>
<b class="nc">&nbsp;                        r.add(player.getInitiative().toString());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (!doBlind()) {</b>
&nbsp;
&nbsp;                // The turn order is different in movement phase
&nbsp;                // if a player has any &quot;even&quot; moving units.
<b class="nc">&nbsp;                r = new Report(1020, Report.PUBLIC);</b>
&nbsp;
<b class="nc">&nbsp;                boolean hasEven = false;</b>
<b class="nc">&nbsp;                for (Enumeration&lt;GameTurn&gt; i = game.getTurns(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                    GameTurn turn = i.nextElement();</b>
<b class="nc">&nbsp;                    IPlayer player = getPlayer(turn.getPlayerNum());</b>
<b class="nc">&nbsp;                    if (null != player) {</b>
<b class="nc">&nbsp;                        r.add(player.getName());</b>
<b class="nc">&nbsp;                        if (player.getEvenTurns() &gt; 0) {</b>
<b class="nc">&nbsp;                            hasEven = true;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                r.newlines = 2;</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                if (hasEven) {</b>
<b class="nc">&nbsp;                    r = new Report(1021, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    if ((game.getOptions().booleanOption(OptionsConstants.INIT_INF_DEPLOY_EVEN)</b>
<b class="nc">&nbsp;                            || game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_EVEN))</b>
<b class="nc">&nbsp;                            &amp;&amp; !(game.getLastPhase() == IGame.Phase.PHASE_END_REPORT)) {</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.choose(false);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.newlines = 2;</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        if (!abbreviatedReport) {</b>
&nbsp;            // we don&#39;t much care about wind direction and such in a hard vacuum
<b class="nc">&nbsp;            if(!game.getBoard().inSpace()) {</b>
&nbsp;                // Wind direction and strength
<b class="nc">&nbsp;                Report rWindDir = new Report(1025, Report.PUBLIC);</b>
<b class="nc">&nbsp;                rWindDir.add(game.getPlanetaryConditions().getWindDirDisplayableName());</b>
<b class="nc">&nbsp;                rWindDir.newlines = 0;</b>
<b class="nc">&nbsp;                Report rWindStr = new Report(1030, Report.PUBLIC);</b>
<b class="nc">&nbsp;                rWindStr.add(game.getPlanetaryConditions().getWindDisplayableName());</b>
<b class="nc">&nbsp;                rWindStr.newlines = 0;</b>
<b class="nc">&nbsp;                Report rWeather = new Report(1031, Report.PUBLIC);</b>
<b class="nc">&nbsp;                rWeather.add(game.getPlanetaryConditions().getWeatherDisplayableName());</b>
<b class="nc">&nbsp;                rWeather.newlines = 0;</b>
<b class="nc">&nbsp;                Report rLight = new Report(1032, Report.PUBLIC);</b>
<b class="nc">&nbsp;                rLight.add(game.getPlanetaryConditions().getLightDisplayableName());</b>
<b class="nc">&nbsp;                Report rVis = new Report(1033, Report.PUBLIC);</b>
<b class="nc">&nbsp;                rVis.add(game.getPlanetaryConditions().getFogDisplayableName());</b>
<b class="nc">&nbsp;                addReport(rWindDir);</b>
<b class="nc">&nbsp;                addReport(rWindStr);</b>
<b class="nc">&nbsp;                addReport(rWeather);</b>
<b class="nc">&nbsp;                addReport(rLight);</b>
<b class="nc">&nbsp;                addReport(rVis);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (deployment) {</b>
<b class="nc">&nbsp;                addNewLines();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void applyDropShipLandingDamage(Coords centralPos, Entity killer) {
&nbsp;        // first cycle through hexes to figure out final elevation
<b class="nc">&nbsp;        IHex centralHex = game.getBoard().getHex(centralPos);</b>
<b class="nc">&nbsp;        if (null == centralHex) {</b>
&nbsp;            // shouldn&#39;t happen
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        int finalElev = centralHex.getLevel();</b>
<b class="nc">&nbsp;        if (!centralHex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;            &amp;&amp; !centralHex.containsTerrain(Terrains.ROAD)) {</b>
<b class="nc">&nbsp;            finalElev--;</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Coords&gt; positions = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        positions.add(centralPos);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            Coords pos = centralPos.translated(i);</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;            if (null == hex) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hex.getLevel() &lt; finalElev) {</b>
<b class="nc">&nbsp;                finalElev = hex.getLevel();</b>
&nbsp;            }
<b class="nc">&nbsp;            positions.add(pos);</b>
&nbsp;        }
&nbsp;        // ok now cycle through hexes and make all changes
<b class="nc">&nbsp;        for (Coords pos : positions) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;            hex.setLevel(finalElev);</b>
&nbsp;            // get rid of woods and replace with rough
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                hex.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                hex.removeTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                hex.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ROUGH, 1));</b>
&nbsp;            }
<b class="nc">&nbsp;            sendChangedHex(pos);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        applyDropShipProximityDamage(centralPos, killer);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void applyDropShipProximityDamage(Coords centralPos, Entity killer) {
<b class="nc">&nbsp;        applyDropShipProximityDamage(centralPos, false, 0, killer);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * apply damage to units and buildings within a certain radius of a landing
&nbsp;     * or lifting off DropShip
&nbsp;     *
&nbsp;     * @param centralPos - the Coords for the central position of the DropShip
&nbsp;     */
&nbsp;    private void applyDropShipProximityDamage(Coords centralPos, boolean rearArc, int facing,
&nbsp;                                              Entity killer) {
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Integer&gt; alreadyHit = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;        // anything in the central hex or adjacent hexes is destroyed
<b class="nc">&nbsp;        Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap = game.getPositionMap();</b>
<b class="nc">&nbsp;        for (Entity en : game.getEntitiesVector(centralPos)) {</b>
<b class="nc">&nbsp;            if (!en.isAirborne()) {</b>
<b class="nc">&nbsp;                addReport(destroyEntity(en, &quot;DropShip proximity damage&quot;, false,</b>
&nbsp;                                        false));
<b class="nc">&nbsp;                alreadyHit.add(en.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(centralPos);</b>
<b class="nc">&nbsp;        if (null != bldg) {</b>
<b class="nc">&nbsp;            collapseBuilding(bldg, positionMap, centralPos, vPhaseReport);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            Coords pos = centralPos.translated(i);</b>
<b class="nc">&nbsp;            for (Entity en : game.getEntitiesVector(pos)) {</b>
<b class="nc">&nbsp;                if (!en.isAirborne()) {</b>
<b class="nc">&nbsp;                    addReport(destroyEntity(en, &quot;DropShip proximity damage&quot;,</b>
&nbsp;                                            false, false));
&nbsp;                }
<b class="nc">&nbsp;                alreadyHit.add(en.getId());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            bldg = game.getBoard().getBuildingAt(pos);</b>
<b class="nc">&nbsp;            if (null != bldg) {</b>
<b class="nc">&nbsp;                collapseBuilding(bldg, positionMap, pos, vPhaseReport);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Report r;
&nbsp;        // ok now I need to look at the damage rings - start at 2 and go to 7
<b class="nc">&nbsp;        for (int i = 2; i &lt; 8; i++) {</b>
<b class="nc">&nbsp;            int damageDice = (8 - i) * 2;</b>
<b class="nc">&nbsp;            List&lt;Coords&gt; ring = centralPos.allAtDistance(i);</b>
<b class="nc">&nbsp;            for (Coords pos : ring) {</b>
<b class="nc">&nbsp;                if (rearArc &amp;&amp; !Compute.isInArc(centralPos, facing, pos, Compute.ARC_AFT)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                alreadyHit = artilleryDamageHex(pos, centralPos, damageDice, null, killer.getId(),</b>
&nbsp;                        killer, null, false, 0, vPhaseReport, false,
&nbsp;                        alreadyHit, true);
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        destroyDoomedEntities(alreadyHit);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Marks ineligible entities as not ready for this phase
&nbsp;     */
&nbsp;    private void setIneligible(IGame.Phase phase) {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; assistants = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        boolean assistable = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (isPlayerForcedVictory()) {</b>
<b class="nc">&nbsp;            assistants.addAll(game.getEntitiesVector());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (entity.isEligibleFor(phase)) {</b>
<b class="nc">&nbsp;                    assistable = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    assistants.addElement(entity);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity assistant : assistants) {</b>
<b class="nc">&nbsp;            if (!assistable || !assistant.canAssist(phase)) {</b>
<b class="nc">&nbsp;                assistant.setDone(true);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Have the loader load the indicated unit. The unit being loaded loses its
&nbsp;     * turn.
&nbsp;     *
&nbsp;     * @param loader - the &lt;code&gt;Entity&lt;/code&gt; that is loading the unit.
&nbsp;     * @param unit   - the &lt;code&gt;Entity&lt;/code&gt; being loaded.
&nbsp;     */
&nbsp;    private void loadUnit(Entity loader, Entity unit, int bayNumber) {
&nbsp;        // ProtoMechs share a single turn for a Point. When loading one we don&#39;t remove its turn
&nbsp;        // unless it&#39;s the last unit in the Point to act.
<b class="nc">&nbsp;        int remainingProtos = 0;</b>
<b class="nc">&nbsp;        if (unit.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {</b>
<b class="nc">&nbsp;            remainingProtos = game.getSelectedEntityCount(en -&gt; en.hasETypeFlag(Entity.ETYPE_PROTOMECH)</b>
<b class="nc">&nbsp;                    &amp;&amp; en.getId() != unit.getId()</b>
<b class="nc">&nbsp;                    &amp;&amp; en.isSelectableThisTurn()</b>
<b class="nc">&nbsp;                    &amp;&amp; en.getOwnerId() == unit.getOwnerId()</b>
<b class="nc">&nbsp;                    &amp;&amp; en.getUnitNumber() == unit.getUnitNumber());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getPhase() != IGame.Phase.PHASE_LOUNGE) &amp;&amp; !unit.isDone()</b>
&nbsp;                &amp;&amp; (remainingProtos == 0)) {
&nbsp;            // Remove the *last* friendly turn (removing the *first* penalizes
&nbsp;            // the opponent too much, and re-calculating moves is too hard).
<b class="nc">&nbsp;            game.removeTurnFor(unit);</b>
<b class="nc">&nbsp;            send(createTurnVectorPacket());</b>
&nbsp;        }
&nbsp;
&nbsp;        // When loading an Aero into a squadron in the lounge, make sure the
&nbsp;        // loaded aero has the same bomb loadout as the squadron
&nbsp;        // We want to do this before the fighter is loaded: when the fighter
&nbsp;        // is loaded into the squadron, the squadrons bombing attacks are
&nbsp;        // adjusted based on the bomb-loadout on the fighter.
<b class="nc">&nbsp;        if ((game.getPhase() == Phase.PHASE_LOUNGE)</b>
&nbsp;            &amp;&amp; (loader instanceof FighterSquadron)) {
<b class="nc">&nbsp;            ((IBomber) unit).setBombChoices(((FighterSquadron) loader)</b>
<b class="nc">&nbsp;                                                 .getBombChoices());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Load the unit. Do not check for elevation during deployment
<b class="nc">&nbsp;        boolean checkElevation = (game.getPhase() != Phase.PHASE_DEPLOYMENT)</b>
<b class="nc">&nbsp;                                 &amp;&amp; (game.getPhase() != Phase.PHASE_LOUNGE);</b>
<b class="nc">&nbsp;        if (bayNumber == -1) {</b>
<b class="nc">&nbsp;            loader.load(unit, checkElevation);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            loader.load(unit, checkElevation, bayNumber);</b>
&nbsp;        }
&nbsp;
&nbsp;        // The loaded unit is being carried by the loader.
<b class="nc">&nbsp;        unit.setTransportId(loader.getId());</b>
&nbsp;
&nbsp;        // Remove the loaded unit from the screen.
<b class="nc">&nbsp;        unit.setPosition(null);</b>
&nbsp;
&nbsp;        // set deployment round of the loadee to equal that of the loader
<b class="nc">&nbsp;        unit.setDeployRound(loader.getDeployRound());</b>
&nbsp;        
&nbsp;        //Update the loading unit&#39;s passenger count, if it&#39;s a large craft
<b class="nc">&nbsp;        if (loader instanceof SmallCraft || loader instanceof Jumpship) {</b>
&nbsp;            //Don&#39;t add dropship crew to a jumpship or station&#39;s passenger list
<b class="nc">&nbsp;            if (!unit.isLargeCraft()) {</b>
<b class="nc">&nbsp;                loader.setNPassenger(loader.getNPassenger() + unit.getCrew().getSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Update the loaded unit.
<b class="nc">&nbsp;        entityUpdate(unit.getId());</b>
&nbsp;
&nbsp;        // Taharqa (2/28/13): I am not sure why the loader is not getting
&nbsp;        // updated too - not updating it
&nbsp;        // is causing problem in the chat lounge loading, so I am going to do it
&nbsp;        // here, but if we get
&nbsp;        // weird results for other loading, then the reason is probably this
<b class="nc">&nbsp;        entityUpdate(loader.getId());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Have the loader tow the indicated unit. The unit being towed loses its
&nbsp;     * turn.
&nbsp;     *
&nbsp;     * @param loader - the &lt;code&gt;Entity&lt;/code&gt; that is towing the unit.
&nbsp;     * @param unit   - the &lt;code&gt;Entity&lt;/code&gt; being towed.
&nbsp;     */
&nbsp;    private void towUnit(Entity loader, Entity unit) {
<b class="nc">&nbsp;        if ((game.getPhase() != IGame.Phase.PHASE_LOUNGE) &amp;&amp; !unit.isDone()) {</b>
&nbsp;            // Remove the *last* friendly turn (removing the *first* penalizes
&nbsp;            // the opponent too much, and re-calculating moves is too hard).
<b class="nc">&nbsp;            game.removeTurnFor(unit);</b>
<b class="nc">&nbsp;            send(createTurnVectorPacket());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        loader.towUnit(unit.getId());</b>
&nbsp;
&nbsp;        // set deployment round of the loadee to equal that of the loader
<b class="nc">&nbsp;        unit.setDeployRound(loader.getDeployRound());</b>
&nbsp;
&nbsp;        // Update the loader and towed units.
<b class="nc">&nbsp;        entityUpdate(unit.getId());</b>
<b class="nc">&nbsp;        entityUpdate(loader.getId());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Have the tractor drop the indicated trailer. This will also disconnect all
&nbsp;     * trailers that follow the one dropped.
&nbsp;     *
&nbsp;     * @param tractor
&nbsp;     *            - the &lt;code&gt;Entity&lt;/code&gt; that is disconnecting the trailer.
&nbsp;     * @param unloaded
&nbsp;     *            - the &lt;code&gt;Targetable&lt;/code&gt; unit being unloaded.
&nbsp;     * @param pos
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; for the unloaded unit.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit was successfully unloaded,
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; if the trailer isn&#39;t carried by tractor.
&nbsp;     */
&nbsp;    private boolean disconnectUnit(Entity tractor, Targetable unloaded, Coords pos) {
&nbsp;
&nbsp;        // We can only unload Entities.
&nbsp;        Entity trailer;
<b class="nc">&nbsp;        if (unloaded instanceof Entity) {</b>
<b class="nc">&nbsp;            trailer = (Entity) unloaded;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // disconnectUnit() updates anything behind &#39;trailer&#39; too, so copy
&nbsp;        // the list of trailers before we alter it so entityUpdate() can be
&nbsp;        // run on all of them. Also, add the entity towing Trailer to the list
<b class="nc">&nbsp;        List&lt;Integer&gt; trailerList = new ArrayList&lt;&gt;(trailer.getConnectedUnits());</b>
<b class="nc">&nbsp;        trailerList.add(trailer.getTowedBy());</b>
&nbsp;
&nbsp;        // Unload the unit.
<b class="nc">&nbsp;        tractor.disconnectUnit(trailer.getId());</b>
&nbsp;
&nbsp;        // Update the tractor and all affected trailers.
<b class="nc">&nbsp;        for (int id : trailerList) {</b>
<b class="nc">&nbsp;            entityUpdate(id);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        entityUpdate(trailer.getId());</b>
<b class="nc">&nbsp;        entityUpdate(tractor.getId());</b>
&nbsp;
&nbsp;        // Unloaded successfully.
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean unloadUnit(Entity unloader, Targetable unloaded,
&nbsp;                               Coords pos, int facing, int elevation) {
<b class="nc">&nbsp;        return unloadUnit(unloader, unloaded, pos, facing, elevation, false,</b>
&nbsp;                false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Have the unloader unload the indicated unit. The unit being unloaded may
&nbsp;     * or may not gain a turn
&nbsp;     *
&nbsp;     * @param unloader
&nbsp;     *            - the &lt;code&gt;Entity&lt;/code&gt; that is unloading the unit.
&nbsp;     * @param unloaded
&nbsp;     *            - the &lt;code&gt;Targetable&lt;/code&gt; unit being unloaded.
&nbsp;     * @param pos
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; for the unloaded unit.
&nbsp;     * @param facing
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; facing for the unloaded unit.
&nbsp;     * @param elevation
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; elevation at which to unload, if both
&nbsp;     *            loader and loaded units use VTOL movement.
&nbsp;     * @param evacuation
&nbsp;     *            - a &lt;code&gt;boolean&lt;/code&gt; indicating whether this unit is being
&nbsp;     *            unloaded as a result of its carrying units destruction
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit was successfully unloaded,
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; if the unit isn&#39;t carried in unloader.
&nbsp;     */
&nbsp;    private boolean unloadUnit(Entity unloader, Targetable unloaded,
&nbsp;            Coords pos, int facing, int elevation, boolean evacuation,
&nbsp;            boolean duringDeployment) {
&nbsp;
&nbsp;        // We can only unload Entities.
&nbsp;        Entity unit;
<b class="nc">&nbsp;        if (unloaded instanceof Entity) {</b>
<b class="nc">&nbsp;            unit = (Entity) unloaded;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Unload the unit.
<b class="nc">&nbsp;        if (!unloader.unload(unit)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The unloaded unit is no longer being carried.
<b class="nc">&nbsp;        unit.setTransportId(Entity.NONE);</b>
&nbsp;
&nbsp;        // Place the unloaded unit onto the screen.
<b class="nc">&nbsp;        unit.setPosition(pos);</b>
&nbsp;
&nbsp;        // Units unloaded onto the screen are deployed.
<b class="nc">&nbsp;        if (pos != null) {</b>
<b class="nc">&nbsp;            unit.setDeployed(true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Point the unloaded unit in the given direction.
<b class="nc">&nbsp;        unit.setFacing(facing);</b>
<b class="nc">&nbsp;        unit.setSecondaryFacing(facing);</b>
&nbsp;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;        boolean isBridge = (hex != null)</b>
<b class="nc">&nbsp;                &amp;&amp; hex.containsTerrain(Terrains.PAVEMENT);</b>
&nbsp;
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            unit.setElevation(elevation);</b>
<b class="nc">&nbsp;        } else if (unloader.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;            if (unit.getMovementMode() == EntityMovementMode.VTOL) {</b>
&nbsp;                // Flying units unload to the same elevation as the flying
&nbsp;                // transport
<b class="nc">&nbsp;                unit.setElevation(elevation);</b>
<b class="nc">&nbsp;            } else if (game.getBoard().getBuildingAt(pos) != null) {</b>
&nbsp;                // non-flying unit unloaded from a flying onto a building
&nbsp;                // -&gt; sit on the roof
<b class="nc">&nbsp;                unit.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                while (elevation &gt;= -hex.depth()) {</b>
<b class="nc">&nbsp;                    if (unit.isElevationValid(elevation, hex)) {</b>
<b class="nc">&nbsp;                        unit.setElevation(elevation);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    elevation--;</b>
&nbsp;                    // If unit is landed, the while loop breaks before here
&nbsp;                    // And unit.moved will be MOVE_NONE
&nbsp;                    // If we can jump, use jump
<b class="nc">&nbsp;                    if (unit.getJumpMP() &gt; 0) {</b>
<b class="nc">&nbsp;                        unit.moved = EntityMovementType.MOVE_JUMP;</b>
&nbsp;                    } else { // Otherwise, use walk trigger check for ziplines
<b class="nc">&nbsp;                        unit.moved = EntityMovementType.MOVE_WALK;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (!unit.isElevationValid(elevation, hex)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (game.getBoard().getBuildingAt(pos) != null) {</b>
&nbsp;            // non flying unit unloading units into a building
&nbsp;            // -&gt; sit in the building at the same elevation
<b class="nc">&nbsp;            unit.setElevation(elevation);</b>
<b class="nc">&nbsp;        } else if (hex.terrainLevel(Terrains.WATER) &gt; 0) {</b>
<b class="nc">&nbsp;            if ((unit.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                || (unit.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                || (unit.getMovementMode() == EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                || (unit.getMovementMode() == EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                || (unit.getMovementMode() == EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;                || (unit.getMovementMode() == EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                || hex.containsTerrain(Terrains.ICE) || isBridge) {</b>
&nbsp;                // units that can float stay on the surface, or we go on the
&nbsp;                // bridge
&nbsp;                // this means elevation 0, because elevation is relative to the
&nbsp;                // surface
<b class="nc">&nbsp;                unit.setElevation(0);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // default to the floor of the hex.
&nbsp;            // unit elevation is relative to the surface
<b class="nc">&nbsp;            unit.setElevation(hex.floor() - hex.surface());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check for zip lines PSR -- MOVE_WALK implies ziplines
<b class="nc">&nbsp;        if (unit.moved == EntityMovementType.MOVE_WALK) {</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_ZIPLINES)</b>
&nbsp;                    &amp;&amp; (unit instanceof Infantry)
<b class="nc">&nbsp;                    &amp;&amp; !((Infantry) unit).isMechanized()) {</b>
&nbsp;
&nbsp;               // Handle zip lines
<b class="nc">&nbsp;                PilotingRollData psr = getEjectModifiers(game, unit, 0, false,</b>
<b class="nc">&nbsp;                        unit.getPosition(), &quot;Anti-mek skill&quot;);</b>
&nbsp;                // Factor in Elevation
<b class="nc">&nbsp;                if (unloader.getElevation() &gt; 0) {</b>
<b class="nc">&nbsp;                    psr.addModifier(unloader.getElevation(), &quot;elevation&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                int roll = Compute.d6(2);</b>
&nbsp;
&nbsp;                // Report ziplining
<b class="nc">&nbsp;                Report r = new Report(9920);</b>
<b class="nc">&nbsp;                r.subject = unit.getId();</b>
<b class="nc">&nbsp;                r.addDesc(unit);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // Report TN
<b class="nc">&nbsp;                r = new Report(9921);</b>
<b class="nc">&nbsp;                r.subject = unit.getId();</b>
<b class="nc">&nbsp;                r.add(psr.getValue());</b>
<b class="nc">&nbsp;                r.add(psr.getDesc());</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (roll &lt; psr.getValue()) { // Failure!</b>
<b class="nc">&nbsp;                    r = new Report(9923);</b>
<b class="nc">&nbsp;                    r.subject = unit.getId();</b>
<b class="nc">&nbsp;                    r.add(psr.getValue());</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                    HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    hit.setIgnoreInfantryDoubleDamage(true);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(unit, hit, 5));</b>
<b class="nc">&nbsp;                } else { //  Report success</b>
<b class="nc">&nbsp;                    r = new Report(9922);</b>
<b class="nc">&nbsp;                    r.subject = unit.getId();</b>
<b class="nc">&nbsp;                    r.add(psr.getValue());</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addReport(doSetLocationsExposure(unit, hex, false, unit.getElevation()));</b>
&nbsp;
&nbsp;        // unlike other unloaders, entities unloaded from droppers can still
&nbsp;        // move (unless infantry)
<b class="nc">&nbsp;        if (!evacuation &amp;&amp; (unloader instanceof SmallCraft)</b>
&nbsp;            &amp;&amp; !(unit instanceof Infantry)) {
<b class="nc">&nbsp;            unit.setUnloaded(false);</b>
<b class="nc">&nbsp;            unit.setDone(false);</b>
&nbsp;
&nbsp;            // unit uses half of walk mp and is treated as moving one hex
<b class="nc">&nbsp;            unit.mpUsed = unit.getOriginalWalkMP() / 2;</b>
<b class="nc">&nbsp;            unit.delta_distance = 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we unloaded during deployment, allow a turn
<b class="nc">&nbsp;        if (duringDeployment) {</b>
<b class="nc">&nbsp;            unit.setUnloaded(false);</b>
<b class="nc">&nbsp;            unit.setDone(false);</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Update the transport unit&#39;s passenger count, if it&#39;s a large craft
<b class="nc">&nbsp;        if (unloader instanceof SmallCraft || unloader instanceof Jumpship) {</b>
&nbsp;            //Don&#39;t add dropship crew to a jumpship or station&#39;s passenger list
<b class="nc">&nbsp;            if (!unit.isLargeCraft()) {</b>
<b class="nc">&nbsp;                unloader.setNPassenger(Math.max(0, unloader.getNPassenger() - unit.getCrew().getSize()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Update the unloaded unit.
<b class="nc">&nbsp;        entityUpdate(unit.getId());</b>
&nbsp;
&nbsp;        // Unloaded successfully.
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a piloting skill check to attempt landing
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is landing
&nbsp;     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this landing.
&nbsp;     */
&nbsp;    private void attemptLanding(Entity entity, PilotingRollData roll) {
<b class="nc">&nbsp;        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(9605);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9606);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
&nbsp;        // boolean suc;
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            int mof = roll.getValue() - diceRoll;</b>
<b class="nc">&nbsp;            int damage = 10 * (mof);</b>
&nbsp;            // Report damage taken
<b class="nc">&nbsp;            r = new Report(9609);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            r.add(mof);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            int side = ToHitData.SIDE_FRONT;</b>
<b class="nc">&nbsp;            if ((entity instanceof Aero) &amp;&amp; ((Aero) entity).isSpheroid()) {</b>
<b class="nc">&nbsp;                side = ToHitData.SIDE_REAR;</b>
&nbsp;            }
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, side);</b>
<b class="nc">&nbsp;                addReport(damageEntity(entity, hit, 10));</b>
<b class="nc">&nbsp;                damage -= 10;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // suc = false;
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // suc = true;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean launchUnit(Entity unloader, Targetable unloaded,
&nbsp;                               Coords pos, int facing, int velocity, int altitude, int[] moveVec,
&nbsp;                               int bonus) {
&nbsp;
&nbsp;        Entity unit;
<b class="nc">&nbsp;        if (unloaded instanceof Entity &amp;&amp; unloader instanceof Aero) {</b>
<b class="nc">&nbsp;            unit = (Entity) unloaded;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // must be an ASF, Small Craft, or DropShip
<b class="nc">&nbsp;        if (!unit.isAero() || unit instanceof Jumpship) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        IAero a = (IAero) unit;</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Unload the unit.
<b class="nc">&nbsp;        if (!unloader.unload(unit)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The unloaded unit is no longer being carried.
<b class="nc">&nbsp;        unit.setTransportId(Entity.NONE);</b>
&nbsp;
&nbsp;        // pg. 86 of TW: launched fighters can move in fire in the turn they are
&nbsp;        // unloaded
<b class="nc">&nbsp;        unit.setUnloaded(false);</b>
&nbsp;
&nbsp;        // Place the unloaded unit onto the screen.
<b class="nc">&nbsp;        unit.setPosition(pos);</b>
&nbsp;
&nbsp;        // Units unloaded onto the screen are deployed.
<b class="nc">&nbsp;        if (pos != null) {</b>
<b class="nc">&nbsp;            unit.setDeployed(true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Point the unloaded unit in the given direction.
<b class="nc">&nbsp;        unit.setFacing(facing);</b>
<b class="nc">&nbsp;        unit.setSecondaryFacing(facing);</b>
&nbsp;
&nbsp;        // the velocity of the unloaded unit is the same as the loader
<b class="nc">&nbsp;        a.setCurrentVelocity(velocity);</b>
<b class="nc">&nbsp;        a.setNextVelocity(velocity);</b>
&nbsp;
&nbsp;        // if using advanced movement then set vectors
<b class="nc">&nbsp;        unit.setVectors(moveVec);</b>
&nbsp;
<b class="nc">&nbsp;        unit.setAltitude(altitude);</b>
&nbsp;
&nbsp;        // it seems that the done button is still being set and I can&#39;t figure
&nbsp;        // out where
<b class="nc">&nbsp;        unit.setDone(false);</b>
&nbsp;
&nbsp;        // if the bonus was greater than zero then too many fighters were
&nbsp;        // launched and they
&nbsp;        // must all make control rolls
<b class="nc">&nbsp;        if (bonus &gt; 0) {</b>
<b class="nc">&nbsp;            PilotingRollData psr = unit.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            psr.addModifier(bonus, &quot;safe launch rate exceeded&quot;);</b>
<b class="nc">&nbsp;            int ctrlroll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(9375);</b>
<b class="nc">&nbsp;            r.subject = unit.getId();</b>
<b class="nc">&nbsp;            r.add(unit.getDisplayName());</b>
<b class="nc">&nbsp;            r.add(psr.getValue());</b>
<b class="nc">&nbsp;            r.add(ctrlroll);</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            if (ctrlroll &lt; psr.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // damage the unit
<b class="nc">&nbsp;                int damage = 10 * (psr.getValue() - ctrlroll);</b>
<b class="nc">&nbsp;                HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                Vector&lt;Report&gt; rep = damageEntity(unit, hit, damage);</b>
<b class="nc">&nbsp;                Report.indentAll(rep, 1);</b>
<b class="nc">&nbsp;                rep.lastElement().newlines++;</b>
<b class="nc">&nbsp;                addReport(rep);</b>
&nbsp;                // did we destroy the unit?
<b class="nc">&nbsp;                if (unit.isDoomed()) {</b>
&nbsp;                    // Clean out the entity.
<b class="nc">&nbsp;                    unit.setDestroyed(true);</b>
<b class="nc">&nbsp;                    game.moveToGraveyard(unit.getId());</b>
<b class="nc">&nbsp;                    send(createRemoveEntityPacket(unit.getId()));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
&nbsp;                // avoided damage
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                r.newlines++;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            r = new Report(9374);</b>
<b class="nc">&nbsp;            r.subject = unit.getId();</b>
<b class="nc">&nbsp;            r.add(unit.getDisplayName());</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            r.newlines++;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // launching from an OOC vessel causes damage
&nbsp;        // same thing if faster than 2 velocity in atmosphere
<b class="nc">&nbsp;        if ((((Aero) unloader).isOutControlTotal() &amp;&amp; !unit.isDoomed())</b>
<b class="nc">&nbsp;            || ((((Aero)unloader).getCurrentVelocity() &gt; 2) &amp;&amp; !game</b>
<b class="nc">&nbsp;                .getBoard().inSpace())) {</b>
<b class="nc">&nbsp;            int damageRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            int damage = damageRoll * 10;</b>
<b class="nc">&nbsp;            r = new Report(9385);</b>
<b class="nc">&nbsp;            r.subject = unit.getId();</b>
<b class="nc">&nbsp;            r.add(unit.getDisplayName());</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            HitData hit = unit.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;            addReport(damageEntity(unit, hit, damage));</b>
&nbsp;            // did we destroy the unit?
<b class="nc">&nbsp;            if (unit.isDoomed()) {</b>
&nbsp;                // Clean out the entity.
<b class="nc">&nbsp;                unit.setDestroyed(true);</b>
<b class="nc">&nbsp;                game.moveToGraveyard(unit.getId());</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(unit.getId()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Update the unloaded unit.
<b class="nc">&nbsp;        entityUpdate(unit.getId());</b>
&nbsp;
&nbsp;        // Set the turn mask. We need to be specific otherwise we run the risk
&nbsp;        // of having a unit of another class consume the turn and leave the
&nbsp;        // unloaded unit without a turn
&nbsp;        int turnMask;
<b class="nc">&nbsp;        List&lt;GameTurn&gt; turnVector = game.getTurnVector();</b>
<b class="nc">&nbsp;        if (unit instanceof Dropship) {</b>
<b class="nc">&nbsp;            turnMask = GameTurn.CLASS_DROPSHIP;</b>
<b class="nc">&nbsp;        } else if (unit instanceof SmallCraft) {</b>
<b class="nc">&nbsp;            turnMask = GameTurn.CLASS_SMALL_CRAFT;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            turnMask = GameTurn.CLASS_AERO;</b>
&nbsp;        }
&nbsp;        // Add one, otherwise we consider the turn we&#39;re currently processing
<b class="nc">&nbsp;        int turnInsertIdx = game.getTurnIndex() + 1;</b>
&nbsp;        // We have to figure out where to insert this turn, to maintain proper
&nbsp;        // space turn order (JumpShips, Small Craft, DropShips, Aeros)
<b class="nc">&nbsp;        for (; turnInsertIdx &lt; turnVector.size(); turnInsertIdx++) {</b>
<b class="nc">&nbsp;            GameTurn turn = turnVector.get(turnInsertIdx);</b>
<b class="nc">&nbsp;            if (turn.isValidEntity(unit, game)) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // ok add another turn for the unloaded entity so that it can move
<b class="nc">&nbsp;        GameTurn newTurn = new GameTurn.EntityClassTurn(unit.getOwner().getId(), turnMask);</b>
<b class="nc">&nbsp;        game.insertTurnAfter(newTurn, turnInsertIdx);</b>
&nbsp;        // brief everybody on the turn update
<b class="nc">&nbsp;        send(createTurnVectorPacket());</b>
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void dropUnit(Entity drop, Entity entity, Coords curPos, int altitude) {
&nbsp;        // Unload the unit.
<b class="nc">&nbsp;        entity.unload(drop);</b>
&nbsp;        // The unloaded unit is no longer being carried.
<b class="nc">&nbsp;        drop.setTransportId(Entity.NONE);</b>
&nbsp;
&nbsp;        // OK according to Welshman&#39;s pending ruling, when on the ground map
&nbsp;        // units should be deployed in the ring two hexes away from the DropShip
&nbsp;        // optimally, we should let people choose here, but that would be
&nbsp;        // complicated
&nbsp;        // so for now I am just going to distribute them. I will give each unit
&nbsp;        // the first
&nbsp;        // emptiest hex that has no water or magma in it.
&nbsp;        // I will start the circle based on the facing of the dropper
&nbsp;        // Spheroid - facing
&nbsp;        // Aerodyne - opposite of facing
&nbsp;        // http://www.classicbattletech.com/forums/index.php?topic=65600.msg1568089#new
<b class="nc">&nbsp;        if (game.getBoard().onGround() &amp;&amp; (null != curPos)) {</b>
<b class="nc">&nbsp;            boolean selected = false;</b>
&nbsp;            int count;
<b class="nc">&nbsp;            int max = 0;</b>
<b class="nc">&nbsp;            int facing = entity.getFacing();</b>
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {</b>
&nbsp;                // no real rule for this but it seems to make sense that units
&nbsp;                // would drop behind an
&nbsp;                // aerodyne rather than in front of it
<b class="nc">&nbsp;                facing = (facing + 3) % 6;</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean checkDanger = true;</b>
<b class="nc">&nbsp;            while (!selected) {</b>
&nbsp;                // we can get caught in an infinite loop if all available hexes
&nbsp;                // are dangerous, so check for this
<b class="nc">&nbsp;                boolean allDanger = true;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;                    int dir = (facing + i) % 6;</b>
<b class="nc">&nbsp;                    Coords newPos = curPos.translated(dir, 2);</b>
<b class="nc">&nbsp;                    count = 0;</b>
<b class="nc">&nbsp;                    if (game.getBoard().contains(newPos)) {</b>
<b class="nc">&nbsp;                        IHex newHex = game.getBoard().getHex(newPos);</b>
<b class="nc">&nbsp;                        Building bldg = game.getBoard().getBuildingAt(newPos);</b>
<b class="nc">&nbsp;                        boolean danger = newHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                                         || newHex.containsTerrain(Terrains.MAGMA)</b>
&nbsp;                                         || (null != bldg);
<b class="nc">&nbsp;                        for (Entity unit : game.getEntitiesVector(newPos)) {</b>
<b class="nc">&nbsp;                            if ((unit.getAltitude() == altitude)</b>
<b class="nc">&nbsp;                                &amp;&amp; !unit.isAero()) {</b>
<b class="nc">&nbsp;                                count++;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if ((count &lt;= max) &amp;&amp; (!danger || !checkDanger)) {</b>
<b class="nc">&nbsp;                            selected = true;</b>
<b class="nc">&nbsp;                            curPos = newPos;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (!danger) {</b>
<b class="nc">&nbsp;                            allDanger = false;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    newPos = newPos.translated((dir + 2) % 6);</b>
<b class="nc">&nbsp;                    count = 0;</b>
<b class="nc">&nbsp;                    if (game.getBoard().contains(newPos)) {</b>
<b class="nc">&nbsp;                        IHex newHex = game.getBoard().getHex(newPos);</b>
<b class="nc">&nbsp;                        Building bldg = game.getBoard().getBuildingAt(newPos);</b>
<b class="nc">&nbsp;                        boolean danger = newHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                                         || newHex.containsTerrain(Terrains.MAGMA)</b>
&nbsp;                                         || (null != bldg);
<b class="nc">&nbsp;                        for (Entity unit : game.getEntitiesVector(newPos)) {</b>
<b class="nc">&nbsp;                            if ((unit.getAltitude() == altitude) &amp;&amp; !unit.isAero()) {</b>
<b class="nc">&nbsp;                                count++;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if ((count &lt;= max) &amp;&amp; (!danger || !checkDanger)) {</b>
<b class="nc">&nbsp;                            selected = true;</b>
<b class="nc">&nbsp;                            curPos = newPos;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (!danger) {</b>
<b class="nc">&nbsp;                            allDanger = false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (allDanger &amp;&amp; checkDanger) {</b>
<b class="nc">&nbsp;                    checkDanger = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    max++;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Place the unloaded unit onto the screen.
<b class="nc">&nbsp;        drop.setPosition(curPos);</b>
&nbsp;
&nbsp;        // Units unloaded onto the screen are deployed.
<b class="nc">&nbsp;        if (curPos != null) {</b>
<b class="nc">&nbsp;            drop.setDeployed(true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Point the unloaded unit in the given direction.
<b class="nc">&nbsp;        drop.setFacing(entity.getFacing());</b>
<b class="nc">&nbsp;        drop.setSecondaryFacing(entity.getFacing());</b>
&nbsp;
<b class="nc">&nbsp;        drop.setAltitude(altitude);</b>
<b class="nc">&nbsp;        entityUpdate(drop.getId());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Record that the given building has been affected by the current entity&#39;s
&nbsp;     * movement. At the end of the entity&#39;s movement, notify the clients about
&nbsp;     * the updates.
&nbsp;     *
&nbsp;     * @param bldg     - the &lt;code&gt;Building&lt;/code&gt; that has been affected.
&nbsp;     * @param collapse - a &lt;code&gt;boolean&lt;/code&gt; value that specifies that the
&nbsp;     *                 building collapsed (when &lt;code&gt;true&lt;/code&gt;).
&nbsp;     */
&nbsp;    private void addAffectedBldg(Building bldg, boolean collapse) {
&nbsp;        // If the building collapsed, then the clients have already
&nbsp;        // been notified, so remove it from the notification list.
<b class="nc">&nbsp;        if (collapse) {</b>
<b class="nc">&nbsp;            affectedBldgs.remove(bldg);</b>
&nbsp;        } else { // Otherwise, make sure that this building is tracked.
<b class="nc">&nbsp;            affectedBldgs.put(bldg, Boolean.FALSE);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Walk through the building hexes that were affected by the recent entity&#39;s
&nbsp;     * movement. Notify the clients about the updates to all affected entities
&nbsp;     * and non-collapsed buildings. The affected hexes is then cleared for the
&nbsp;     * next entity&#39;s movement.
&nbsp;     */
&nbsp;    private void applyAffectedBldgs() {
&nbsp;        // Build a list of Building updates.
<b class="nc">&nbsp;        Vector&lt;Building&gt; bldgUpdates = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;        // Only send a single turn update.
<b class="nc">&nbsp;        boolean bTurnsChanged = false;</b>
&nbsp;
&nbsp;        // Walk the set of buildings.
<b class="nc">&nbsp;        Enumeration&lt;Building&gt; bldgs = affectedBldgs.keys();</b>
<b class="nc">&nbsp;        while (bldgs.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Building bldg = bldgs.nextElement();</b>
&nbsp;
&nbsp;            // Walk through the building&#39;s coordinates.
<b class="nc">&nbsp;            Enumeration&lt;Coords&gt; bldgCoords = bldg.getCoords();</b>
<b class="nc">&nbsp;            while (bldgCoords.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Coords coords = bldgCoords.nextElement();</b>
&nbsp;                // Walk through the entities at these coordinates.
<b class="nc">&nbsp;                for (Entity entity : game.getEntitiesVector(coords)) {</b>
&nbsp;                    // Is the entity infantry?
<b class="nc">&nbsp;                    if (entity instanceof Infantry) {</b>
&nbsp;                        // Is the infantry dead?
<b class="nc">&nbsp;                        if (entity.isDoomed() || entity.isDestroyed()) {</b>
&nbsp;                            // Has the entity taken a turn?
<b class="nc">&nbsp;                            if (!entity.isDone()) {</b>
&nbsp;                                // Dead entities don&#39;t take turns.
<b class="nc">&nbsp;                                game.removeTurnFor(entity);</b>
<b class="nc">&nbsp;                                bTurnsChanged = true;</b>
&nbsp;                            } // End entity-still-to-move
&nbsp;
&nbsp;                            // Clean out the dead entity.
<b class="nc">&nbsp;                            entity.setDestroyed(true);</b>
<b class="nc">&nbsp;                            game.moveToGraveyard(entity.getId());</b>
<b class="nc">&nbsp;                            send(createRemoveEntityPacket(entity.getId()));</b>
&nbsp;                        } else { // Infantry that aren&#39;t dead are damaged.
<b class="nc">&nbsp;                            entityUpdate(entity.getId());</b>
&nbsp;                        }
&nbsp;                    } // End entity-is-infantry
<b class="nc">&nbsp;                } // Check the next entity.</b>
<b class="nc">&nbsp;            } // Handle the next hex in this building.</b>
&nbsp;            // Add this building to the report.
<b class="nc">&nbsp;            bldgUpdates.addElement(bldg);</b>
<b class="nc">&nbsp;        } // Handle the next affected building.</b>
&nbsp;
&nbsp;        // Did we update the turns?
<b class="nc">&nbsp;        if (bTurnsChanged) {</b>
<b class="nc">&nbsp;            send(createTurnVectorPacket());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Are there any building updates?
<b class="nc">&nbsp;        if (!bldgUpdates.isEmpty()) {</b>
&nbsp;            // Send the building updates to the clients.
<b class="nc">&nbsp;            sendChangedBuildings(bldgUpdates);</b>
&nbsp;
&nbsp;            // Clear the list of affected buildings.
<b class="nc">&nbsp;            affectedBldgs.clear();</b>
&nbsp;        }
&nbsp;
&nbsp;        // And we&#39;re done.
<b class="nc">&nbsp;    } // End private void applyAffectedBldgs()</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receives an entity movement packet, and if valid, executes it and ends
&nbsp;     * the current turn.
&nbsp;     */
&nbsp;    private void receiveMovement(Packet packet, int connId) {
<b class="nc">&nbsp;        Map&lt;EntityTargetPair, LosEffects&gt; losCache = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Entity entity = game.getEntity(packet.getIntValue(0));</b>
<b class="nc">&nbsp;        MovePath md = (MovePath) packet.getObject(1);</b>
<b class="nc">&nbsp;        md.setGame(getGame());</b>
<b class="nc">&nbsp;        md.setEntity(entity);</b>
&nbsp;
&nbsp;        // is this the right phase?
<b class="nc">&nbsp;        if (game.getPhase() != IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got movement packet in wrong phase&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can this player/entity act right now?
<b class="nc">&nbsp;        GameTurn turn = game.getTurn();</b>
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
<b class="nc">&nbsp;            turn = game.getTurnForPlayer(connId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((turn == null) || !turn.isValid(connId, entity, game)) {</b>
<b class="nc">&nbsp;            String msg = &quot;error: server got invalid movement packet from &quot; + &quot;connection &quot; + connId;</b>
<b class="nc">&nbsp;            if (entity != null) {</b>
<b class="nc">&nbsp;                msg += &quot;, Entity: &quot; + entity.getShortName();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg += &quot;, Entity was null!&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            MegaMek.getLogger().error(msg);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // looks like mostly everything&#39;s okay
<b class="nc">&nbsp;        processMovement(entity, md, losCache);</b>
&nbsp;
&nbsp;        // The attacker may choose to break a chain whip grapple by expending MP
<b class="nc">&nbsp;        if ((entity.getGrappled() != Entity.NONE)</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isChainWhipGrappled() &amp;&amp; entity.isGrappleAttacker()</b>
<b class="nc">&nbsp;                &amp;&amp; (md.getMpUsed() &gt; 0)) {</b>
&nbsp;
<b class="nc">&nbsp;            Entity te = game.getEntity(entity.getGrappled());</b>
<b class="nc">&nbsp;            Report r = new Report(4316);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            entity.setGrappled(Entity.NONE, false);</b>
<b class="nc">&nbsp;            te.setGrappled(Entity.NONE, false);</b>
&nbsp;
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            entityUpdate(te.getId());</b>
&nbsp;        }
&nbsp;
&nbsp;        // check the LOS of any telemissiles owned by this entity
<b class="nc">&nbsp;        for (int missileId : entity.getTMTracker().getMissiles()) {</b>
<b class="nc">&nbsp;            Entity tm = game.getEntity(missileId);</b>
<b class="nc">&nbsp;            if ((null != tm) &amp;&amp; !tm.isDestroyed()</b>
&nbsp;                &amp;&amp; (tm instanceof TeleMissile)) {
<b class="nc">&nbsp;                if (LosEffects.calculateLos(game, entity.getId(), tm).canSee()) {</b>
<b class="nc">&nbsp;                    ((TeleMissile) tm).setOutContact(false);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ((TeleMissile) tm).setOutContact(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                entityUpdate(tm.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Notify the clients about any building updates.
<b class="nc">&nbsp;        applyAffectedBldgs();</b>
&nbsp;
&nbsp;        // Unit movement may detect hidden units
<b class="nc">&nbsp;        detectHiddenUnits();</b>
&nbsp;
&nbsp;        // Update visibility indications if using double blind.
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            updateVisibilityIndicator(losCache);</b>
&nbsp;        }
&nbsp;
&nbsp;        // This entity&#39;s turn is over.
&nbsp;        // N.B. if the entity fell, a *new* turn has already been added.
<b class="nc">&nbsp;        endCurrentTurn(entity);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * makes a unit skid or sideslip on the board
&nbsp;     *
&nbsp;     * @param entity    the unit which should skid
&nbsp;     * @param start     the coordinates of the hex the unit was in prior to skidding
&nbsp;     * @param elevation the elevation of the unit
&nbsp;     * @param direction the direction of the skid
&nbsp;     * @param distance  the number of hexes skidded
&nbsp;     * @param step      the MoveStep which caused the skid
&nbsp;     * @return true if the entity was removed from play
&nbsp;     */
&nbsp;    private boolean processSkid(Entity entity, Coords start, int elevation,
&nbsp;            int direction, int distance, MoveStep step,
&nbsp;            EntityMovementType moveType) {
<b class="nc">&nbsp;        return processSkid(entity, start, elevation, direction, distance, step, moveType, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * makes a unit skid or sideslip on the board
&nbsp;     *
&nbsp;     * @param entity    the unit which should skid
&nbsp;     * @param start     the coordinates of the hex the unit was in prior to skidding
&nbsp;     * @param elevation the elevation of the unit
&nbsp;     * @param direction the direction of the skid
&nbsp;     * @param distance  the number of hexes skidded
&nbsp;     * @param step      the MoveStep which caused the skid
&nbsp;     * @param flip      whether the skid resulted from a failure maneuver result of major skid
&nbsp;     * @return true if the entity was removed from play
&nbsp;     */
&nbsp;    private boolean processSkid(Entity entity, Coords start, int elevation,
&nbsp;            int direction, int distance, MoveStep step,
&nbsp;            EntityMovementType moveType, boolean flip) {
<b class="nc">&nbsp;        Coords nextPos = start;</b>
<b class="nc">&nbsp;        Coords curPos = nextPos;</b>
<b class="nc">&nbsp;        IHex curHex = game.getBoard().getHex(start);</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        int skidDistance = 0; // actual distance moved</b>
&nbsp;        // Flipping vehicles take tonnage/10 points of damage for every hex they enter.
<b class="nc">&nbsp;        int flipDamage = (int) Math.ceil(entity.getWeight() / 10.0);</b>
<b class="nc">&nbsp;        while (!entity.isDoomed() &amp;&amp; (distance &gt; 0)) {</b>
<b class="nc">&nbsp;            nextPos = curPos.translated(direction);</b>
&nbsp;            // Is the next hex off the board?
<b class="nc">&nbsp;            if (!game.getBoard().contains(nextPos)) {</b>
&nbsp;
&nbsp;                // Can the entity skid off the map?
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.BASE_PUSH_OFF_BOARD)) {</b>
&nbsp;                    // Yup. One dead entity.
<b class="nc">&nbsp;                    game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED);</b>
<b class="nc">&nbsp;                    send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED));</b>
<b class="nc">&nbsp;                    r = new Report(2030, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                    for (Entity e : entity.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                        game.removeEntity(e.getId(), IEntityRemovalConditions.REMOVE_PUSHED);</b>
<b class="nc">&nbsp;                        send(createRemoveEntityPacket(e.getId(), IEntityRemovalConditions.REMOVE_PUSHED));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    Entity swarmer = game.getEntity(entity.getSwarmAttackerId());</b>
<b class="nc">&nbsp;                    if (swarmer != null) {</b>
<b class="nc">&nbsp;                        if (!swarmer.isDone()) {</b>
<b class="nc">&nbsp;                            game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;                            swarmer.setDone(true);</b>
<b class="nc">&nbsp;                            send(createTurnVectorPacket());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        game.removeEntity(swarmer.getId(), IEntityRemovalConditions.REMOVE_PUSHED);</b>
<b class="nc">&nbsp;                        send(createRemoveEntityPacket(swarmer.getId(), IEntityRemovalConditions.REMOVE_PUSHED));</b>
&nbsp;                    }
&nbsp;                    // The entity&#39;s movement is completed.
<b class="nc">&nbsp;                    return true;</b>
&nbsp;
&nbsp;                }
&nbsp;                // Nope. Update the report.
<b class="nc">&nbsp;                r = new Report(2035);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // Stay in the current hex and stop skidding.
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            IHex nextHex = game.getBoard().getHex(nextPos);</b>
<b class="nc">&nbsp;            distance -= nextHex.movementCost(entity) + 1;</b>
&nbsp;            // By default, the unit is going to fall to the floor of the next
&nbsp;            // hex
<b class="nc">&nbsp;            int curAltitude = elevation + curHex.getLevel();</b>
<b class="nc">&nbsp;            int nextAltitude = nextHex.floor();</b>
&nbsp;
&nbsp;            // but VTOL keep altitude
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;                nextAltitude = Math.max(nextAltitude, curAltitude);</b>
&nbsp;            } else {
&nbsp;                // Is there a building to &quot;catch&quot; the unit?
<b class="nc">&nbsp;                if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
&nbsp;                    // unit will land on the roof, if at a higher level,
&nbsp;                    // otherwise it will skid through the wall onto the same
&nbsp;                    // floor.
&nbsp;                    // don&#39;t change this if the building starts at an elevation
&nbsp;                    // higher than the unit
&nbsp;                    // (e.g. the building is on a hill). Otherwise, we skid into
&nbsp;                    // solid earth.
<b class="nc">&nbsp;                    if (curAltitude &gt;= nextHex.floor()) {</b>
<b class="nc">&nbsp;                        nextAltitude = Math.min(curAltitude,</b>
<b class="nc">&nbsp;                                nextHex.getLevel() + nextHex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Is there a bridge to &quot;catch&quot; the unit?
<b class="nc">&nbsp;                if (nextHex.containsTerrain(Terrains.BRIDGE)) {</b>
&nbsp;                    // unit will land on the bridge, if at a higher level,
&nbsp;                    // and the bridge exits towards the current hex,
&nbsp;                    // otherwise the bridge has no effect
<b class="nc">&nbsp;                    int exitDir = (direction + 3) % 6;</b>
<b class="nc">&nbsp;                    exitDir = 1 &lt;&lt; exitDir;</b>
<b class="nc">&nbsp;                    if ((nextHex.getTerrain(Terrains.BRIDGE).getExits() &amp; exitDir) == exitDir) {</b>
<b class="nc">&nbsp;                        nextAltitude = Math.min(curAltitude,</b>
<b class="nc">&nbsp;                                     Math.max(nextAltitude,</b>
<b class="nc">&nbsp;                                             nextHex.getLevel() + nextHex.terrainLevel(Terrains.BRIDGE_ELEV)));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if ((nextAltitude &lt;= nextHex.surface())</b>
<b class="nc">&nbsp;                    &amp;&amp; (curAltitude &gt;= curHex.surface())) {</b>
&nbsp;                    // Hovercraft and WiGEs can &quot;skid&quot; over water.
&nbsp;                    // all units can skid over ice.
<b class="nc">&nbsp;                    if ((entity.getMovementMode().equals(EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                                || entity.getMovementMode().equals(EntityMovementMode.WIGE))</b>
<b class="nc">&nbsp;                            &amp;&amp; nextHex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                        nextAltitude = nextHex.surface();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (nextHex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;                            nextAltitude = nextHex.surface();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.WIGE</b>
&nbsp;                        &amp;&amp; elevation &gt; 0 &amp;&amp; nextAltitude &lt; curAltitude) {
&nbsp;                    // Airborne WiGEs drop to one level above the surface
<b class="nc">&nbsp;                    if (entity.climbMode()) {</b>
<b class="nc">&nbsp;                        nextAltitude = curAltitude;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        nextAltitude++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // The elevation the skidding unit will occupy in next hex
<b class="nc">&nbsp;            int nextElevation = nextAltitude - nextHex.surface();</b>
&nbsp;
<b class="nc">&nbsp;            boolean crashedIntoTerrain = curAltitude &lt; nextAltitude;</b>
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                &amp;&amp; (nextHex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                        || nextHex.containsTerrain(Terrains.JUNGLE)) </b>
<b class="nc">&nbsp;                &amp;&amp; nextElevation &lt;= nextHex.terrainLevel(Terrains.FOLIAGE_ELEV)) {</b>
<b class="nc">&nbsp;                    crashedIntoTerrain = true;</b>
&nbsp;                
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                Building bldg = game.getBoard().getBuildingAt(nextPos);</b>
&nbsp;
<b class="nc">&nbsp;                if (bldg.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                    crashedIntoTerrain = true;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {</b>
<b class="nc">&nbsp;                    crashedIntoTerrain = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // however WiGE can gain 1 level to avoid crashing into the terrain.
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.WIGE &amp;&amp; (elevation &gt; 0)) {</b>
<b class="nc">&nbsp;                if (curAltitude == nextHex.floor()) {</b>
<b class="nc">&nbsp;                    nextElevation = 1;</b>
<b class="nc">&nbsp;                    crashedIntoTerrain = false;</b>
<b class="nc">&nbsp;                } else if ((entity instanceof LandAirMech) &amp;&amp; (curAltitude + 1 == nextHex.floor())) {</b>
&nbsp;                    // LAMs in AirMech mode skid across terrain that is two levels higher rather than crashing,
&nbsp;                    // Reset the skid distance for skid damage calculations.
<b class="nc">&nbsp;                    nextElevation = 0;</b>
<b class="nc">&nbsp;                    skidDistance = 0;</b>
<b class="nc">&nbsp;                    crashedIntoTerrain = false;</b>
<b class="nc">&nbsp;                    r = new Report(2102);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Entity crashDropShip = null;</b>
<b class="nc">&nbsp;            for (Entity en : game.getEntitiesVector(nextPos)) {</b>
<b class="nc">&nbsp;                if ((en instanceof Dropship) &amp;&amp; !en.isAirborne()</b>
<b class="nc">&nbsp;                    &amp;&amp; (nextAltitude &lt;= (en.relHeight()))) {</b>
<b class="nc">&nbsp;                    crashDropShip = en;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (crashedIntoTerrain) {</b>
<b class="nc">&nbsp;                if (nextHex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                    Building bldg = game.getBoard().getBuildingAt(nextPos);</b>
&nbsp;
&nbsp;                    // If you crash into a wall you want to stop in the hex
&nbsp;                    // before the wall not in the wall
&nbsp;                    // Like a building.
<b class="nc">&nbsp;                    if (bldg.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                        r = new Report(2047);</b>
<b class="nc">&nbsp;                    } else if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {</b>
<b class="nc">&nbsp;                        r = new Report(2049);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(2045);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    r = new Report(2045);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(nextPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                if ((entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.VTOL)) {</b>
<b class="nc">&nbsp;                    int hitSide = (step.getFacing() - direction) + 6;</b>
<b class="nc">&nbsp;                    hitSide %= 6;</b>
<b class="nc">&nbsp;                    int table = 0;</b>
<b class="nc">&nbsp;                    switch (hitSide) {// quite hackish...I think it ought to</b>
&nbsp;                        // work, though.
&nbsp;                        case 0:// can this happen?
<b class="nc">&nbsp;                            table = ToHitData.SIDE_FRONT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
&nbsp;                        case 2:
<b class="nc">&nbsp;                            table = ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            table = ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
&nbsp;                        case 5:
<b class="nc">&nbsp;                            table = ToHitData.SIDE_RIGHT;</b>
&nbsp;                            break;
&nbsp;                    }
<b class="nc">&nbsp;                    elevation = nextElevation;</b>
<b class="nc">&nbsp;                    if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                        addReport(crashVTOLorWiGE((Tank) entity, false, true,</b>
&nbsp;                                distance, curPos, elevation, table));
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if ((nextHex.containsTerrain(Terrains.WATER) &amp;&amp; !nextHex</b>
<b class="nc">&nbsp;                            .containsTerrain(Terrains.ICE))</b>
<b class="nc">&nbsp;                            || nextHex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                            || nextHex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                        addReport(destroyEntity(entity, &quot;could not land in crash site&quot;));</b>
<b class="nc">&nbsp;                    } else if (elevation &lt; nextHex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                        Building bldg = game.getBoard().getBuildingAt(nextPos);</b>
&nbsp;
&nbsp;                        // If you crash into a wall you want to stop in the hex
&nbsp;                        // before the wall not in the wall
&nbsp;                        // Like a building.
<b class="nc">&nbsp;                        if (bldg.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                            addReport(destroyEntity(entity, &quot;crashed into a wall&quot;));</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (bldg.getBldgClass() == Building.GUN_EMPLACEMENT) {</b>
<b class="nc">&nbsp;                            addReport(destroyEntity(entity, &quot;crashed into a gun emplacement&quot;));</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        addReport(destroyEntity(entity, &quot;crashed into building&quot;));</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        entity.setPosition(nextPos);</b>
<b class="nc">&nbsp;                        entity.setElevation(0);</b>
<b class="nc">&nbsp;                        addReport(doEntityDisplacementMinefieldCheck(entity,</b>
&nbsp;                                curPos, nextPos, nextElevation));
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;
&nbsp;                }
&nbsp;                // skidding into higher terrain does weight/20
&nbsp;                // damage in 5pt clusters to front.
<b class="nc">&nbsp;                int damage = ((int) entity.getWeight() + 19) / 20;</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    int table = ToHitData.HIT_NORMAL;</b>
<b class="nc">&nbsp;                    int side = entity.sideTable(nextPos);</b>
<b class="nc">&nbsp;                    if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                        table = ToHitData.HIT_SPECIAL_PROTO;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    HitData hitData = entity.rollHitLocation(table, side);</b>
<b class="nc">&nbsp;                    hitData.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, hitData, Math.min(5, damage)));</b>
<b class="nc">&nbsp;                    damage -= 5;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // Stay in the current hex and stop skidding.
&nbsp;                break;
&nbsp;            }
&nbsp;
&nbsp;            // did we hit a DropShip. Oww!
&nbsp;            // Taharqa: The rules on how to handle this are completely missing, so I am assuming
&nbsp;            // we assign damage as per an accidental charge, but do not displace
&nbsp;            // the DropShip and end the skid
<b class="nc">&nbsp;            else if (null != crashDropShip) {</b>
<b class="nc">&nbsp;                r = new Report(2050);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(crashDropShip.getShortName(), true);</b>
<b class="nc">&nbsp;                r.add(nextPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                ChargeAttackAction caa = new ChargeAttackAction(entity.getId(),</b>
<b class="nc">&nbsp;                        crashDropShip.getTargetType(),</b>
<b class="nc">&nbsp;                        crashDropShip.getTargetId(),</b>
<b class="nc">&nbsp;                        crashDropShip.getPosition());</b>
<b class="nc">&nbsp;                ToHitData toHit = caa.toHit(game, true);</b>
<b class="nc">&nbsp;                resolveChargeDamage(entity, crashDropShip, toHit, direction);</b>
<b class="nc">&nbsp;                if ((entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.VTOL)) {</b>
<b class="nc">&nbsp;                    int hitSide = (step.getFacing() - direction) + 6;</b>
<b class="nc">&nbsp;                    hitSide %= 6;</b>
<b class="nc">&nbsp;                    int table = 0;</b>
<b class="nc">&nbsp;                    switch (hitSide) {// quite hackish...I think it ought to work, though.</b>
&nbsp;                        case 0:// can this happen?
<b class="nc">&nbsp;                            table = ToHitData.SIDE_FRONT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 1:
&nbsp;                        case 2:
<b class="nc">&nbsp;                            table = ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            table = ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 4:
&nbsp;                        case 5:
<b class="nc">&nbsp;                            table = ToHitData.SIDE_RIGHT;</b>
&nbsp;                            break;
&nbsp;                    }
<b class="nc">&nbsp;                    elevation = nextElevation;</b>
<b class="nc">&nbsp;                    addReport(crashVTOLorWiGE((VTOL) entity, false, true,</b>
&nbsp;                            distance, curPos, elevation, table));
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!crashDropShip.isDoomed() &amp;&amp; !crashDropShip.isDestroyed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !game.isOutOfGame(crashDropShip)) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Have skidding units suffer falls (off a cliff).
<b class="nc">&nbsp;            else if ( (curAltitude &gt; (nextAltitude + entity.getMaxElevationChange())</b>
<b class="nc">&nbsp;                    || (curHex.hasCliffTopTowards(nextHex) &amp;&amp; curAltitude &gt; nextAltitude) )</b>
<b class="nc">&nbsp;                    &amp;&amp; !(entity.getMovementMode() == EntityMovementMode.WIGE &amp;&amp; elevation &gt; curHex.ceiling())) {</b>
<b class="nc">&nbsp;                addReport(doEntityFallsInto(entity, entity.getElevation(), curPos, nextPos,</b>
<b class="nc">&nbsp;                        entity.getBasePilotingRoll(moveType), true));</b>
<b class="nc">&nbsp;                addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, nextElevation));</b>
&nbsp;                // Stay in the current hex and stop skidding.
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Get any building in the hex.
<b class="nc">&nbsp;            Building bldg = null;</b>
<b class="nc">&nbsp;            if (nextElevation &lt; nextHex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
&nbsp;                // We will only run into the building if its at a higher level,
&nbsp;                // otherwise we skid over the roof
<b class="nc">&nbsp;                bldg = game.getBoard().getBuildingAt(nextPos);</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean bldgSuffered = false;</b>
<b class="nc">&nbsp;            boolean stopTheSkid = false;</b>
&nbsp;            // Does the next hex contain an entities?
&nbsp;            // ASSUMPTION: hurt EVERYONE in the hex.
<b class="nc">&nbsp;            Iterator&lt;Entity&gt; targets = game.getEntities(nextPos);</b>
<b class="nc">&nbsp;            if (targets.hasNext()) {</b>
<b class="nc">&nbsp;                List&lt;Entity&gt; avoidedChargeUnits = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                boolean skidChargeHit = false;</b>
<b class="nc">&nbsp;                while (targets.hasNext()) {</b>
<b class="nc">&nbsp;                    Entity target = targets.next();</b>
&nbsp;
<b class="nc">&nbsp;                    if ((target.getElevation() &gt; (nextElevation + entity.getHeight()))</b>
<b class="nc">&nbsp;                            || (target.relHeight() &lt; nextElevation)) {</b>
&nbsp;                        // target is not in the way
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Can the target avoid the skid?
<b class="nc">&nbsp;                    if (!target.isDone()) {</b>
<b class="nc">&nbsp;                        if (target instanceof Infantry) {</b>
<b class="nc">&nbsp;                            r = new Report(2420);</b>
<b class="nc">&nbsp;                            r.subject = target.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(target);</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            continue;</b>
<b class="nc">&nbsp;                        } else if (target instanceof Protomech) {</b>
<b class="nc">&nbsp;                            if (target != Compute.stackingViolation(game, entity, nextPos, null)) {</b>
<b class="nc">&nbsp;                                r = new Report(2420);</b>
<b class="nc">&nbsp;                                r.subject = target.getId();</b>
<b class="nc">&nbsp;                                r.addDesc(target);</b>
<b class="nc">&nbsp;                                addReport(r);</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            PilotingRollData psr = target.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                            psr.addModifier(0, &quot;avoiding collision&quot;);</b>
<b class="nc">&nbsp;                            if (psr.getValue() == TargetRoll.AUTOMATIC_FAIL</b>
<b class="nc">&nbsp;                                    || psr.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                                r = new Report(2426);</b>
<b class="nc">&nbsp;                                r.subject = target.getId();</b>
<b class="nc">&nbsp;                                r.addDesc(target);</b>
<b class="nc">&nbsp;                                r.add(psr.getDesc());</b>
<b class="nc">&nbsp;                                addReport(r);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                                r = new Report(2425);</b>
<b class="nc">&nbsp;                                r.subject = target.getId();</b>
<b class="nc">&nbsp;                                r.addDesc(target);</b>
<b class="nc">&nbsp;                                r.add(psr.getValue());</b>
<b class="nc">&nbsp;                                r.add(psr.getDesc());</b>
<b class="nc">&nbsp;                                r.add(roll);</b>
<b class="nc">&nbsp;                                addReport(r);</b>
<b class="nc">&nbsp;                                if (roll &gt;= psr.getValue()) {</b>
<b class="nc">&nbsp;                                    game.removeTurnFor(target);</b>
<b class="nc">&nbsp;                                    avoidedChargeUnits.add(target);</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                    // TODO : the charge should really be suspended
&nbsp;                                    // and resumed after the target moved.
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // Mechs and vehicles get charged,
&nbsp;                    // but need to make a to-hit roll
<b class="nc">&nbsp;                    if ((target instanceof Mech) || (target instanceof Tank)</b>
&nbsp;                            || (target instanceof Aero)) {
<b class="nc">&nbsp;                        ChargeAttackAction caa = new ChargeAttackAction(</b>
<b class="nc">&nbsp;                                entity.getId(), target.getTargetType(),</b>
<b class="nc">&nbsp;                                target.getTargetId(), target.getPosition());</b>
<b class="nc">&nbsp;                        ToHitData toHit = caa.toHit(game, true);</b>
&nbsp;
&nbsp;                        // roll
<b class="nc">&nbsp;                        int roll = Compute.d6(2);</b>
&nbsp;                        // Update report.
<b class="nc">&nbsp;                        r = new Report(2050);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.indent();</b>
<b class="nc">&nbsp;                        r.add(target.getShortName(), true);</b>
<b class="nc">&nbsp;                        r.add(nextPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                            roll = -12;</b>
<b class="nc">&nbsp;                            r = new Report(2055);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;                            r = new Report(2060);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            roll = Integer.MAX_VALUE;</b>
&nbsp;                        } else {
&nbsp;                            // report the roll
<b class="nc">&nbsp;                            r = new Report(2065);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;                            r.add(roll);</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        // Resolve a charge against the target.
&nbsp;                        // ASSUMPTION: buildings block damage for
&nbsp;                        // *EACH* entity charged.
<b class="nc">&nbsp;                        if (roll &lt; toHit.getValue()) {</b>
<b class="nc">&nbsp;                            r = new Report(2070);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                        } else {
&nbsp;                            // Resolve the charge.
<b class="nc">&nbsp;                            resolveChargeDamage(entity, target, toHit, direction);</b>
&nbsp;                            // HACK: set the entity&#39;s location
&nbsp;                            // to the original hex again, for the other targets
<b class="nc">&nbsp;                            if (targets.hasNext()) {</b>
<b class="nc">&nbsp;                                entity.setPosition(curPos);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            bldgSuffered = true;</b>
<b class="nc">&nbsp;                            skidChargeHit = true;</b>
&nbsp;                            // The skid ends here if the target lives.
<b class="nc">&nbsp;                            if (!target.isDoomed() &amp;&amp; !target.isDestroyed()</b>
<b class="nc">&nbsp;                                    &amp;&amp; !game.isOutOfGame(target)) {</b>
<b class="nc">&nbsp;                                stopTheSkid = true;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // if we don&#39;t do this here,
&nbsp;                        // we can have a mech without a leg
&nbsp;                        // standing on the field and moving
&nbsp;                        // as if it still had his leg after
&nbsp;                        // getting skid-charged.
<b class="nc">&nbsp;                        if (!target.isDone()) {</b>
<b class="nc">&nbsp;                            addReport(resolvePilotingRolls(target));</b>
<b class="nc">&nbsp;                            game.resetPSRs(target);</b>
<b class="nc">&nbsp;                            target.applyDamage();</b>
<b class="nc">&nbsp;                            addNewLines();</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    // Resolve &quot;move-through&quot; damage on infantry.
&nbsp;                    // Infantry inside of a building don&#39;t get a
&nbsp;                    // move-through, but suffer &quot;bleed through&quot;
&nbsp;                    // from the building.
<b class="nc">&nbsp;                    else if ((target instanceof Infantry) &amp;&amp; (bldg != null)) {</b>
&nbsp;                        // Update report.
<b class="nc">&nbsp;                        r = new Report(2075);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.indent();</b>
<b class="nc">&nbsp;                        r.add(target.getShortName(), true);</b>
<b class="nc">&nbsp;                        r.add(nextPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;
&nbsp;                        // Infantry don&#39;t have different
&nbsp;                        // tables for punches and kicks
<b class="nc">&nbsp;                        HitData hit = target.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                                Compute.targetSideTable(entity, target));</b>
<b class="nc">&nbsp;                        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
&nbsp;                        // Damage equals tonnage, divided by 5.
&nbsp;                        // ASSUMPTION: damage is applied in one hit.
<b class="nc">&nbsp;                        addReport(damageEntity(target, hit, (int) Math.round(entity.getWeight() / 5)));</b>
<b class="nc">&nbsp;                        addNewLines();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Has the target been destroyed?
<b class="nc">&nbsp;                    if (target.isDoomed()) {</b>
&nbsp;                        // Has the target taken a turn?
<b class="nc">&nbsp;                        if (!target.isDone()) {</b>
&nbsp;                            // Dead entities don&#39;t take turns.
<b class="nc">&nbsp;                            game.removeTurnFor(target);</b>
<b class="nc">&nbsp;                            send(createTurnVectorPacket());</b>
&nbsp;                        } // End target-still-to-move
&nbsp;
&nbsp;                        // Clean out the entity.
<b class="nc">&nbsp;                        target.setDestroyed(true);</b>
<b class="nc">&nbsp;                        game.moveToGraveyard(target.getId());</b>
<b class="nc">&nbsp;                        send(createRemoveEntityPacket(target.getId()));</b>
&nbsp;                    }
&nbsp;                    // Update the target&#39;s position,
&nbsp;                    // unless it is off the game map.
<b class="nc">&nbsp;                    if (!game.isOutOfGame(target)) {</b>
<b class="nc">&nbsp;                        entityUpdate(target.getId());</b>
&nbsp;                    }
<b class="nc">&nbsp;                } // Check the next entity in the hex.</b>
&nbsp;
<b class="nc">&nbsp;                if (skidChargeHit) {</b>
&nbsp;                    // HACK: set the entities position to that
&nbsp;                    // hex&#39;s coords, because we had to move the entity
&nbsp;                    // back earlier for the other targets
<b class="nc">&nbsp;                    entity.setPosition(nextPos);</b>
&nbsp;                }
<b class="nc">&nbsp;                for (Entity e : avoidedChargeUnits) {</b>
<b class="nc">&nbsp;                    GameTurn newTurn = new GameTurn.SpecificEntityTurn(e.getOwner().getId(), e.getId());</b>
&nbsp;                    // Prevents adding extra turns for multi-turns
<b class="nc">&nbsp;                    newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                    game.insertNextTurn(newTurn);</b>
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // Handle the building in the hex.
<b class="nc">&nbsp;            if (bldg != null) {</b>
&nbsp;                // Report that the entity has entered the bldg.
<b class="nc">&nbsp;                r = new Report(2080);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(bldg.getName());</b>
<b class="nc">&nbsp;                r.add(nextPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // If the building hasn&#39;t already suffered
&nbsp;                // damage, then apply charge damage to the
&nbsp;                // building and displace the entity inside.
&nbsp;                // ASSUMPTION: you don&#39;t charge the building
&nbsp;                // if Tanks or Mechs were charged.
<b class="nc">&nbsp;                int chargeDamage = ChargeAttackAction.getDamageFor(entity, game</b>
<b class="nc">&nbsp;                        .getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE),</b>
&nbsp;                        entity.delta_distance);
<b class="nc">&nbsp;                if (!bldgSuffered) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; reports = damageBuilding(bldg, chargeDamage, nextPos);</b>
<b class="nc">&nbsp;                    for (Report report : reports) {</b>
<b class="nc">&nbsp;                        report.subject = entity.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(reports);</b>
&nbsp;
&nbsp;                    // Apply damage to the attacker.
<b class="nc">&nbsp;                    int toAttacker = ChargeAttackAction.getDamageTakenBy(entity, bldg, nextPos);</b>
<b class="nc">&nbsp;                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(nextPos));</b>
<b class="nc">&nbsp;                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, hit, toAttacker));</b>
<b class="nc">&nbsp;                    addNewLines();</b>
&nbsp;
<b class="nc">&nbsp;                    entity.setPosition(nextPos);</b>
<b class="nc">&nbsp;                    entity.setElevation(nextElevation);</b>
<b class="nc">&nbsp;                    addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, nextElevation));</b>
<b class="nc">&nbsp;                    curPos = nextPos;</b>
&nbsp;                } // End buildings-suffer-too
&nbsp;
&nbsp;                // Any infantry in the building take damage
&nbsp;                // equal to the building being charged.
&nbsp;                // ASSUMPTION: infantry take no damage from the
&nbsp;                // building absorbing damage from
&nbsp;                // Tanks and Mechs being charged.
<b class="nc">&nbsp;                addReport(damageInfantryIn(bldg, chargeDamage, nextPos));</b>
&nbsp;
&nbsp;                // If a building still stands, then end the skid,
&nbsp;                // and add it to the list of affected buildings.
<b class="nc">&nbsp;                if (bldg.getCurrentCF(nextPos) &gt; 0) {</b>
<b class="nc">&nbsp;                    stopTheSkid = true;</b>
<b class="nc">&nbsp;                    if (bldg.rollBasement(nextPos, game.getBoard(), vPhaseReport)) {</b>
<b class="nc">&nbsp;                        sendChangedHex(nextPos);</b>
<b class="nc">&nbsp;                        Vector&lt;Building&gt; buildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                        buildings.add(bldg);</b>
<b class="nc">&nbsp;                        sendChangedBuildings(buildings);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    addAffectedBldg(bldg, checkBuildingCollapseWhileMoving(bldg, entity, nextPos));</b>
&nbsp;                } else {
&nbsp;                    // otherwise it collapses immediately on our head
<b class="nc">&nbsp;                    checkForCollapse(bldg, game.getPositionMap(), nextPos, true, vPhaseReport);</b>
&nbsp;                }
&nbsp;            } // End handle-building.
&nbsp;
&nbsp;            // Do we stay in the current hex and stop skidding?
<b class="nc">&nbsp;            if (stopTheSkid) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Update entity position and elevation
<b class="nc">&nbsp;            entity.setPosition(nextPos);</b>
<b class="nc">&nbsp;            entity.setElevation(nextElevation);</b>
<b class="nc">&nbsp;            addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, nextElevation));</b>
<b class="nc">&nbsp;            skidDistance++;</b>
&nbsp;
&nbsp;            // Check for collapse of any building the entity might be on
<b class="nc">&nbsp;            Building roof = game.getBoard().getBuildingAt(nextPos);</b>
<b class="nc">&nbsp;            if (roof != null) {</b>
<b class="nc">&nbsp;                if (checkForCollapse(roof, game.getPositionMap(), nextPos, true, vPhaseReport)) {</b>
<b class="nc">&nbsp;                    break; // stop skidding if the building collapsed</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Can the skidding entity enter the next hex from this?
&nbsp;            // N.B. can skid along roads.
<b class="nc">&nbsp;            if ((entity.isLocationProhibited(start) || entity.isLocationProhibited(nextPos))</b>
<b class="nc">&nbsp;                    &amp;&amp; !Compute.canMoveOnPavement(game, curPos, nextPos, step)) {</b>
&nbsp;                // Update report.
<b class="nc">&nbsp;                r = new Report(2040);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(nextPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // If the prohibited terrain is water, entity is destroyed
<b class="nc">&nbsp;                if ((nextHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
&nbsp;                        &amp;&amp; (entity instanceof Tank)
<b class="nc">&nbsp;                        &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                        &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)) {</b>
<b class="nc">&nbsp;                    addReport(destroyEntity(entity,</b>
&nbsp;                            &quot;skidded into a watery grave&quot;, false, true));
&nbsp;                }
&nbsp;
&nbsp;                // otherwise, damage is weight/5 in 5pt clusters
<b class="nc">&nbsp;                int damage = ((int) entity.getWeight() + 4) / 5;</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, entity.rollHitLocation(</b>
&nbsp;                            ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),
<b class="nc">&nbsp;                            Math.min(5, damage)));</b>
<b class="nc">&nbsp;                    damage -= 5;</b>
&nbsp;                }
&nbsp;                // and unit is immobile
<b class="nc">&nbsp;                if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                    ((Tank) entity).immobilize();</b>
&nbsp;                }
&nbsp;
&nbsp;                // Stay in the current hex and stop skidding.
&nbsp;                break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((nextHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)) {</b>
&nbsp;                // water ends the skid
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for breaking magma crust
&nbsp;            // note that this must sequentially occur before the next &#39;entering liquid magma&#39; check
&nbsp;            // otherwise, magma crust won&#39;t have a chance to break
<b class="nc">&nbsp;            ServerHelper.checkAndApplyMagmaCrust(nextHex, nextElevation, entity, curPos, false, vPhaseReport, this);</b>
&nbsp;
&nbsp;            // is the next hex a swamp?
<b class="nc">&nbsp;            PilotingRollData rollTarget = entity.checkBogDown(step, moveType, nextHex, curPos, nextPos,</b>
<b class="nc">&nbsp;                    step.getElevation(), Compute.canMoveOnPavement(game, curPos, nextPos, step));</b>
&nbsp;
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
&nbsp;                // Taharqa: According to TacOps, you automatically stick if you
&nbsp;                // are skidding, (pg. 63)
&nbsp;                // if (0 &lt; doSkillCheckWhileMoving(entity, curPos, nextPos,
&nbsp;                // rollTarget, false)) {
<b class="nc">&nbsp;                entity.setStuck(true);</b>
<b class="nc">&nbsp;                r = new Report(2081);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // check for quicksand
<b class="nc">&nbsp;                addReport(checkQuickSand(nextPos));</b>
&nbsp;                // check for accidental stacking violation
<b class="nc">&nbsp;                Entity violation = Compute.stackingViolation(game, entity.getId(), curPos);</b>
<b class="nc">&nbsp;                if (violation != null) {</b>
&nbsp;                    // target gets displaced, because of low elevation
<b class="nc">&nbsp;                    Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), curPos,</b>
&nbsp;                            direction);
<b class="nc">&nbsp;                    addReport(doEntityDisplacement(violation, curPos, targetDest,</b>
<b class="nc">&nbsp;                            new PilotingRollData(violation.getId(), 0, &quot;domino effect&quot;)));</b>
&nbsp;                    // Update the violating entity&#39;s position on the client.
<b class="nc">&nbsp;                    entityUpdate(violation.getId());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // stay here and stop skidding, see bug 1115608
&nbsp;                break;
&nbsp;            }
&nbsp;
&nbsp;            // Update the position and keep skidding.
<b class="nc">&nbsp;            curPos = nextPos;</b>
<b class="nc">&nbsp;            curHex = nextHex;</b>
<b class="nc">&nbsp;            elevation = nextElevation;</b>
<b class="nc">&nbsp;            r = new Report(2085);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.add(curPos.getBoardNum(), true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            if (flip &amp;&amp; entity instanceof Tank) {</b>
<b class="nc">&nbsp;                doVehicleFlipDamage((Tank)entity, flipDamage, direction &lt; 3, skidDistance - 1);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } // Handle the next skid hex.</b>
&nbsp;
&nbsp;        // If the skidding entity violates stacking,
&nbsp;        // displace targets until it doesn&#39;t.
<b class="nc">&nbsp;        curPos = entity.getPosition();</b>
<b class="nc">&nbsp;        Entity target = Compute.stackingViolation(game, entity.getId(), curPos);</b>
<b class="nc">&nbsp;        while (target != null) {</b>
<b class="nc">&nbsp;            nextPos = Compute.getValidDisplacement(game, target.getId(), target.getPosition(), direction);</b>
&nbsp;            // ASSUMPTION
&nbsp;            // There should always be *somewhere* that
&nbsp;            // the target can go... last skid hex if
&nbsp;            // nothing else is available.
<b class="nc">&nbsp;            if (null == nextPos) {</b>
&nbsp;                // But I don&#39;t trust the assumption fully.
&nbsp;                // Report the error and try to continue.
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;The skid of &quot; + entity.getShortName()</b>
<b class="nc">&nbsp;                                + &quot; should displace &quot; + target.getShortName()</b>
<b class="nc">&nbsp;                                + &quot; in hex &quot; + curPos.getBoardNum()</b>
&nbsp;                                + &quot; but there is nowhere to go.&quot;);
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            // indent displacement
<b class="nc">&nbsp;            r = new Report(1210, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(doEntityDisplacement(target, curPos, nextPos, null));</b>
<b class="nc">&nbsp;            addReport(doEntityDisplacementMinefieldCheck(entity, curPos, nextPos, entity.getElevation()));</b>
<b class="nc">&nbsp;            target = Compute.stackingViolation(game, entity.getId(), curPos);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mechs suffer damage for every hex skidded.
&nbsp;        // For QuadVees in vehicle mode, apply
&nbsp;        // damage only if flipping.
<b class="nc">&nbsp;        boolean mechDamage = ((entity instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; !((entity.getMovementMode() == EntityMovementMode.WIGE) &amp;&amp; (entity.getElevation() &gt; 0)));</b>
<b class="nc">&nbsp;        if (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE) {</b>
<b class="nc">&nbsp;            mechDamage = flip;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mechDamage) {</b>
&nbsp;            // Calculate one half falling damage times skid length.
<b class="nc">&nbsp;            int damage = skidDistance * (int) Math.ceil(Math.round(entity.getWeight() / 10.0) / 2.0);</b>
&nbsp;
&nbsp;            // report skid damage
<b class="nc">&nbsp;            r = new Report(2090);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // standard damage loop
&nbsp;            // All skid damage is to the front.
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                addReport(damageEntity(entity, hit, cluster));</b>
<b class="nc">&nbsp;                damage -= cluster;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addNewLines();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (flip &amp;&amp; entity instanceof Tank) {</b>
<b class="nc">&nbsp;            addReport(applyCriticalHit(entity, Entity.NONE, new CriticalSlot(0, Tank.CRIT_CREW_STUNNED),</b>
&nbsp;                    true, 0, false));
<b class="nc">&nbsp;        } else if (flip &amp;&amp; entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE) {</b>
&nbsp;            // QuadVees don&#39;t suffer stunned crew criticals; require PSR to avoid damage instead.
<b class="nc">&nbsp;            PilotingRollData prd = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            addReport(checkPilotAvoidFallDamage(entity, 1, prd));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Clean up the entity if it has been destroyed.
<b class="nc">&nbsp;        if (entity.isDoomed()) {</b>
<b class="nc">&nbsp;            entity.setDestroyed(true);</b>
<b class="nc">&nbsp;            game.moveToGraveyard(entity.getId());</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(entity.getId()));</b>
&nbsp;
&nbsp;            // The entity&#39;s movement is completed.
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Let the player know the ordeal is over.
<b class="nc">&nbsp;        r = new Report(2095);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Roll on the failed vehicle maneuver table.
&nbsp;     *
&nbsp;     * @param entity    The vehicle that failed the maneuver.
&nbsp;     * @param curPos    The coordinates of the hex in which the maneuver was attempted.
&nbsp;     * @param turnDirection The difference between the intended final facing and the starting facing
&nbsp;     *                      (-1 for left turn, 1 for right turn, 0 for not turning).
&nbsp;     * @param prevStep  The &lt;code&gt;MoveStep&lt;/code&gt; immediately preceding the one being processed.
&nbsp;     *                  Cannot be null; if the check is made for the first step of the path,
&nbsp;     *                  use the current step.
&nbsp;     * @param lastStepMoveType  The &lt;code&gt;EntityMovementType&lt;/code&gt; of the last step in the path.
&nbsp;     * @param distance  The distance moved so far during the phase; used to calculate any potential skid.
&nbsp;     * @param modifier  The modifier to the maneuver failure roll.
&nbsp;     * @return          true if the maneuver failure result ends the unit&#39;s turn.
&nbsp;     */
&nbsp;    private boolean processFailedVehicleManeuver(Entity entity, Coords curPos, int turnDirection,
&nbsp;            MoveStep prevStep, boolean isBackwards, EntityMovementType lastStepMoveType, int distance,
&nbsp;            int modifier, int marginOfFailure) {
<b class="nc">&nbsp;        IHex curHex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.WHEELED</b>
<b class="nc">&nbsp;                &amp;&amp; !curHex.containsTerrain(Terrains.PAVEMENT)) {</b>
<b class="nc">&nbsp;            modifier += 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;            modifier += 2;</b>
<b class="nc">&nbsp;        } else if (entity.getMovementMode() == EntityMovementMode.HOVER</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.WIGE &amp;&amp; entity instanceof Tank)</b>
<b class="nc">&nbsp;                || entity.getMovementMode() == EntityMovementMode.HYDROFOIL) {</b>
<b class="nc">&nbsp;            modifier += 4;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity.getWeightClass() &lt; EntityWeightClass.WEIGHT_MEDIUM</b>
<b class="nc">&nbsp;                || entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</b>
<b class="nc">&nbsp;            modifier++;</b>
<b class="nc">&nbsp;        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_HEAVY</b>
<b class="nc">&nbsp;                || entity.getWeightClass() == EntityWeightClass.WEIGHT_LARGE_SUPPORT) {</b>
<b class="nc">&nbsp;            modifier--;</b>
<b class="nc">&nbsp;        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_ASSAULT</b>
<b class="nc">&nbsp;                || entity.getWeightClass() == EntityWeightClass.WEIGHT_SUPER_HEAVY) {</b>
<b class="nc">&nbsp;            modifier -= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean turnEnds = false;</b>
<b class="nc">&nbsp;        boolean motiveDamage = false;</b>
<b class="nc">&nbsp;        int motiveDamageMod = 0;</b>
<b class="nc">&nbsp;        boolean skid = false;</b>
<b class="nc">&nbsp;        boolean flip = false;</b>
<b class="nc">&nbsp;        boolean isGroundVehicle = ((entity instanceof Tank)</b>
<b class="nc">&nbsp;                &amp;&amp; ((entity.getMovementMode() == EntityMovementMode.TRACKED)</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.WHEELED)));</b>
&nbsp;
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;        Report r = new Report(2505);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        r = new Report(6310);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        r = new Report(3340);</b>
<b class="nc">&nbsp;        r.add(modifier);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        r = new Report(1210);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        roll += modifier;</b>
<b class="nc">&nbsp;        if (roll &lt; 8) {</b>
<b class="nc">&nbsp;            r.messageId = 2506;</b>
&nbsp;            // minor fishtail, fail to turn
<b class="nc">&nbsp;            turnDirection = 0;</b>
<b class="nc">&nbsp;        } else if (roll &lt; 10) {</b>
<b class="nc">&nbsp;            r.messageId = 2507;</b>
&nbsp;            // moderate fishtail, turn an extra hexside and roll for motive damage at -1.
<b class="nc">&nbsp;            if (turnDirection == 0) {</b>
<b class="nc">&nbsp;                turnDirection = Compute.d6() &lt; 4? -1 : 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                turnDirection *= 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            motiveDamage = true;</b>
<b class="nc">&nbsp;            motiveDamageMod = -1;</b>
<b class="nc">&nbsp;        } else if (roll &lt; 12) {</b>
<b class="nc">&nbsp;            r.messageId = 2508;</b>
&nbsp;            // serious fishtail, turn an extra hexside and roll for motive damage. Turn ends.
<b class="nc">&nbsp;            if (turnDirection == 0) {</b>
<b class="nc">&nbsp;                turnDirection = Compute.d6() &lt; 4? -1 : 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                turnDirection *= 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            motiveDamage = true;</b>
<b class="nc">&nbsp;            turnEnds = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.messageId = 2509;</b>
&nbsp;            // Turn fails and vehicle skids
&nbsp;            // Wheeled and naval vehicles start to flip if the roll is high enough.
<b class="nc">&nbsp;            if (roll &gt; 13) {</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;                    r.messageId = 2510;</b>
<b class="nc">&nbsp;                    flip = true;</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.NAVAL</b>
<b class="nc">&nbsp;                        || entity.getMovementMode() == EntityMovementMode.HYDROFOIL) {</b>
<b class="nc">&nbsp;                    entity.setDoomed(true);</b>
<b class="nc">&nbsp;                    r.messageId = 2511;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            skid = true;</b>
<b class="nc">&nbsp;            turnEnds = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        entity.setFacing((entity.getFacing() + turnDirection + 6) % 6);</b>
<b class="nc">&nbsp;        entity.setSecondaryFacing(entity.getFacing());</b>
<b class="nc">&nbsp;        if (motiveDamage &amp;&amp; isGroundVehicle) {</b>
<b class="nc">&nbsp;            addReport(vehicleMotiveDamage((Tank)entity, motiveDamageMod));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (skid &amp;&amp; !entity.isDoomed()) {</b>
<b class="nc">&nbsp;            if (!flip &amp;&amp; isGroundVehicle) {</b>
<b class="nc">&nbsp;                addReport(vehicleMotiveDamage((Tank)entity, 0));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int skidDistance = (int)Math.round((double) (distance - 1) / 2);</b>
<b class="nc">&nbsp;            if (flip &amp;&amp; entity.getMovementMode() == EntityMovementMode.WHEELED) {</b>
&nbsp;                // Wheeled vehicles that start to flip reduce the skid distance by one hex.
<b class="nc">&nbsp;                skidDistance--;</b>
<b class="nc">&nbsp;            } else if (entity.getMovementMode() == EntityMovementMode.HOVER</b>
<b class="nc">&nbsp;                    || entity.getMovementMode() == EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                    || entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                skidDistance = Math.min(marginOfFailure, distance);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (skidDistance &gt; 0) {</b>
<b class="nc">&nbsp;                int skidDirection = prevStep.getFacing();</b>
<b class="nc">&nbsp;                if (isBackwards) {</b>
<b class="nc">&nbsp;                    skidDirection = (skidDirection + 3) % 6;</b>
&nbsp;                }
<b class="nc">&nbsp;                processSkid(entity, curPos, prevStep.getElevation(), skidDirection, skidDistance,</b>
&nbsp;                        prevStep, lastStepMoveType, flip);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return turnEnds;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void doVehicleFlipDamage(Tank entity, int damage, boolean startRight, int flipCount) {
&nbsp;        HitData hit;
&nbsp;
<b class="nc">&nbsp;        int index = flipCount % 4;</b>
&nbsp;        // If there is no turret, we do side-side-bottom
<b class="nc">&nbsp;        if (entity.hasNoTurret()) {</b>
<b class="nc">&nbsp;            index = flipCount % 3;</b>
<b class="nc">&nbsp;            if (index &gt; 0) {</b>
<b class="nc">&nbsp;                index++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        switch (index) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                hit = new HitData(startRight ? Tank.LOC_RIGHT : Tank.LOC_LEFT);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                hit = new HitData(Tank.LOC_TURRET);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                hit = new HitData(startRight ? Tank.LOC_LEFT : Tank.LOC_RIGHT);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                hit = null; //Motive damage instead</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hit != null) {</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            addReport(damageEntity(entity, hit, damage));</b>
&nbsp;            // If the vehicle has two turrets, they both take full damage.
<b class="nc">&nbsp;            if ((hit.getLocation() == Tank.LOC_TURRET) &amp;&amp; !(entity.hasNoDualTurret())) {</b>
<b class="nc">&nbsp;                hit = new HitData(Tank.LOC_TURRET_2);</b>
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                addReport(damageEntity(entity, hit, damage));</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            addReport(vehicleMotiveDamage(entity, 1));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * processes a potential collision
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     * @param target
&nbsp;     * @param src
&nbsp;     * @return
&nbsp;     */
&nbsp;    private boolean processCollision(Entity entity, Entity target, Coords src) {
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        r = new Report(9035);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        boolean partial = (Compute.d6() == 6);</b>
&nbsp;        // if aero chance to avoid
<b class="nc">&nbsp;        if ((target.isAero())</b>
<b class="nc">&nbsp;            &amp;&amp; (target.mpUsed &lt; target.getRunMPwithoutMASC())</b>
<b class="nc">&nbsp;            &amp;&amp; !((IAero) target).isOutControlTotal() &amp;&amp; !target.isImmobile()) {</b>
&nbsp;            // give them a control roll to avoid the collision
&nbsp;            // TODO : I should make this voluntary really
<b class="nc">&nbsp;            IAero ta = (IAero) target;</b>
<b class="nc">&nbsp;            PilotingRollData psr = target.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            psr.addModifier(0, &quot;avoiding collision&quot;);</b>
<b class="nc">&nbsp;            int ctrlroll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(9045);</b>
<b class="nc">&nbsp;            r.subject = target.getId();</b>
<b class="nc">&nbsp;            r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;            r.add(psr.getValue());</b>
<b class="nc">&nbsp;            r.add(ctrlroll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            if (ctrlroll &lt; psr.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
&nbsp;                // avoided collision
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // two possibilities:
&nbsp;                // 1) the target already moved, but had MP left - check for
&nbsp;                // control roll conditions
&nbsp;                // 2) the target had not yet moved, move them in straight line
<b class="nc">&nbsp;                if (!target.isDone()) {</b>
<b class="nc">&nbsp;                    int vel = ta.getCurrentVelocity();</b>
<b class="nc">&nbsp;                    MovePath md = new MovePath(game, target);</b>
<b class="nc">&nbsp;                    while (vel &gt; 0) {</b>
<b class="nc">&nbsp;                        md.addStep(MoveStepType.FORWARDS);</b>
<b class="nc">&nbsp;                        vel--;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    game.removeTurnFor(target);</b>
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;                    processMovement(target, md, null);</b>
&nbsp;                    // for some reason it is not clearing out turn
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // what needs to get checked?
&nbsp;                    // this move puts them at over-thrust
<b class="nc">&nbsp;                    target.moved = EntityMovementType.MOVE_OVER_THRUST;</b>
&nbsp;                    // they may have exceeded SI, only add if they hadn&#39;t
&nbsp;                    // exceeded it before
<b class="nc">&nbsp;                    if (target.mpUsed &lt;= ta.getSI()) {</b>
<b class="nc">&nbsp;                        PilotingRollData rollTarget = ta.checkThrustSITotal(</b>
<b class="nc">&nbsp;                                target.getRunMPwithoutMASC(), target.moved);</b>
<b class="nc">&nbsp;                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                            game.addControlRoll(new PilotingRollData(</b>
<b class="nc">&nbsp;                                    target.getId(), 0,</b>
&nbsp;                                    &quot;Thrust spent during turn exceeds SI&quot;));
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    target.mpUsed = target.getRunMPwithoutMASC();</b>
&nbsp;                }
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // can&#39;t avoid collision - write report
<b class="nc">&nbsp;            r = new Report(9040);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we are still here, then collide
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, &quot;Its a collision&quot;);</b>
<b class="nc">&nbsp;        toHit.setSideTable(target.sideTable(src));</b>
<b class="nc">&nbsp;        resolveRamDamage((IAero)entity, target, toHit, partial, false);</b>
&nbsp;
&nbsp;        // Has the target been destroyed?
<b class="nc">&nbsp;        if (target.isDoomed()) {</b>
&nbsp;            // Has the target taken a turn?
<b class="nc">&nbsp;            if (!target.isDone()) {</b>
&nbsp;                // Dead entities don&#39;t take turns.
<b class="nc">&nbsp;                game.removeTurnFor(target);</b>
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
&nbsp;            } // End target-still-to-move
&nbsp;            // Clean out the entity.
<b class="nc">&nbsp;            target.setDestroyed(true);</b>
<b class="nc">&nbsp;            game.moveToGraveyard(target.getId());</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(target.getId()));</b>
&nbsp;        }
&nbsp;        // Update the target&#39;s position,
&nbsp;        // unless it is off the game map.
<b class="nc">&nbsp;        if (!game.isOutOfGame(target)) {</b>
<b class="nc">&nbsp;            entityUpdate(target.getId());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean checkCrash(Entity entity, Coords pos, int altitude) {
&nbsp;        // only Aeros can crash
<b class="nc">&nbsp;        if (!entity.isAero()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // no crashing in space
<b class="nc">&nbsp;        if (game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // if aero on the ground map, then only crash if elevation is zero
<b class="nc">&nbsp;        else if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            return altitude &lt;= 0;</b>
&nbsp;        }
&nbsp;        // we must be in atmosphere
&nbsp;        // if we&#39;re off the map, assume hex ceiling 0
&nbsp;        // Hexes with elevations &lt; 0 are treated as 0 altitude
<b class="nc">&nbsp;        int ceiling = 0;</b>
<b class="nc">&nbsp;        if (game.getBoard().getHex(pos) != null) {</b>
<b class="nc">&nbsp;            ceiling = Math.max(0, game.getBoard().getHex(pos).ceiling(true));</b>
&nbsp;        }
<b class="nc">&nbsp;        return ceiling &gt;= altitude;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; processCrash(Entity entity, int vel, Coords c) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vReport = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            r = new Report(9701);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            vReport.add(r);</b>
<b class="nc">&nbsp;            vReport.addAll(destroyEntity(entity, &quot;crashed off the map&quot;, true, true));</b>
<b class="nc">&nbsp;            return vReport;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getBoard().inAtmosphere()) {</b>
<b class="nc">&nbsp;            r = new Report(9393, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            vReport.add(r);</b>
<b class="nc">&nbsp;            entity.setDoomed(true);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ((IAero) entity).land();</b>
&nbsp;        }
&nbsp;
&nbsp;        // we might hit multiple hexes, if we&#39;re a DropShip, so we do some
&nbsp;        // checks for all of them
<b class="nc">&nbsp;        List&lt;Coords&gt; coords = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        coords.add(c);</b>
<b class="nc">&nbsp;        IHex h = game.getBoard().getHex(c);</b>
&nbsp;        int crateredElevation;
<b class="nc">&nbsp;        boolean containsWater = false;</b>
<b class="nc">&nbsp;        if (h.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            crateredElevation = Math.min(2, h.depth() + 1);</b>
<b class="nc">&nbsp;            containsWater = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            crateredElevation = h.getLevel() - 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;                Coords adjCoords = c.translated(i);</b>
<b class="nc">&nbsp;                if (!game.getBoard().contains(adjCoords)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                IHex adjHex = game.getBoard().getHex(adjCoords);</b>
<b class="nc">&nbsp;                coords.add(adjCoords);</b>
<b class="nc">&nbsp;                if (adjHex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                    if (containsWater) {</b>
<b class="nc">&nbsp;                        int newDepth = Math.min(2, adjHex.depth() + 1);</b>
<b class="nc">&nbsp;                        if (newDepth &gt; crateredElevation) {</b>
<b class="nc">&nbsp;                            crateredElevation = newDepth;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        crateredElevation = Math.min(2, adjHex.depth() + 1);</b>
<b class="nc">&nbsp;                        containsWater = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (!containsWater &amp;&amp; (adjHex.getLevel() &lt; crateredElevation)) {</b>
<b class="nc">&nbsp;                    crateredElevation = adjHex.getLevel();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // Units with velocity zero are treated like that had velocity two
<b class="nc">&nbsp;        if (vel &lt; 1) {</b>
<b class="nc">&nbsp;            vel = 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // deal crash damage only once
<b class="nc">&nbsp;        boolean damageDealt = false;</b>
<b class="nc">&nbsp;        for (Coords hitCoords : coords) {</b>
<b class="nc">&nbsp;            int orig_crash_damage = Compute.d6(2) * 10 * vel;</b>
<b class="nc">&nbsp;            int crash_damage = orig_crash_damage;</b>
<b class="nc">&nbsp;            int direction = entity.getFacing();</b>
&nbsp;            // first check for buildings
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(hitCoords);</b>
<b class="nc">&nbsp;            if ((null != bldg) &amp;&amp; (bldg.getType() == Building.HARDENED)) {</b>
<b class="nc">&nbsp;                crash_damage *= 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (null != bldg) {</b>
<b class="nc">&nbsp;                collapseBuilding(bldg, game.getPositionMap(), hitCoords, true, vReport);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!damageDealt) {</b>
<b class="nc">&nbsp;                r = new Report(9700, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(crash_damage);</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
<b class="nc">&nbsp;                while (crash_damage &gt; 0) {</b>
&nbsp;                    HitData hit;
<b class="nc">&nbsp;                    if ((entity instanceof SmallCraft) &amp;&amp; ((SmallCraft) entity).isSpheroid()) {</b>
<b class="nc">&nbsp;                        hit = entity.rollHitLocation(ToHitData.HIT_SPHEROID_CRASH, ToHitData.SIDE_REAR);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (crash_damage &gt; 10) {</b>
<b class="nc">&nbsp;                        vReport.addAll(damageEntity(entity, hit, 10));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        vReport.addAll(damageEntity(entity, hit, crash_damage));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    crash_damage -= 10;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                damageDealt = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            // ok, now lets cycle through the entities in this spot and
&nbsp;            // potentially
&nbsp;            // damage them
<b class="nc">&nbsp;            for (Entity victim : game.getEntitiesVector(hitCoords)) {</b>
<b class="nc">&nbsp;                if (victim.getId() == entity.getId()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (((victim.getElevation() &gt; 0) &amp;&amp; victim</b>
<b class="nc">&nbsp;                        .isAirborneVTOLorWIGE()) || (victim.getAltitude() &gt; 0)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // if the crasher is a DropShip and the victim is not a mech,
&nbsp;                // then it is automatically destroyed
<b class="nc">&nbsp;                if ((entity instanceof Dropship) &amp;&amp; !(victim instanceof Mech)) {</b>
<b class="nc">&nbsp;                    vReport.addAll(destroyEntity(victim, &quot;hit by crashing DropShip&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    crash_damage = orig_crash_damage / 2;</b>
&nbsp;                    // roll dice to see if they got hit
<b class="nc">&nbsp;                    int target = 2;</b>
<b class="nc">&nbsp;                    if (victim instanceof Infantry) {</b>
<b class="nc">&nbsp;                        target = 3;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    int roll = Compute.d6();</b>
<b class="nc">&nbsp;                    r = new Report(9705, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.addDesc(victim);</b>
<b class="nc">&nbsp;                    r.add(target);</b>
<b class="nc">&nbsp;                    r.add(crash_damage);</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    if (roll &gt; target) {</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
<b class="nc">&nbsp;                        vReport.add(r);</b>
&nbsp;                        // apply half the crash damage in 5 point clusters
&nbsp;                        // (check
&nbsp;                        // hit tables)
<b class="nc">&nbsp;                        while (crash_damage &gt; 0) {</b>
<b class="nc">&nbsp;                            HitData hit = victim.rollHitLocation(</b>
&nbsp;                                    ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
<b class="nc">&nbsp;                            if (victim instanceof Mech) {</b>
<b class="nc">&nbsp;                                hit = victim.rollHitLocation(</b>
&nbsp;                                        ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);
&nbsp;                            }
<b class="nc">&nbsp;                            if (victim instanceof Protomech) {</b>
<b class="nc">&nbsp;                                hit = victim.rollHitLocation(</b>
&nbsp;                                        ToHitData.HIT_SPECIAL_PROTO, ToHitData.SIDE_FRONT);
&nbsp;                            }
<b class="nc">&nbsp;                            if (crash_damage &gt; 5) {</b>
<b class="nc">&nbsp;                                vReport.addAll(damageEntity(victim, hit, 5));</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                vReport.addAll(damageEntity(victim, hit, crash_damage));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            crash_damage -= 5;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.choose(false);</b>
<b class="nc">&nbsp;                        vReport.add(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (!victim.isDoomed() &amp;&amp; !victim.isDestroyed()) {</b>
&nbsp;                    // entity displacement
<b class="nc">&nbsp;                    Coords dest = Compute.getValidDisplacement(game,</b>
<b class="nc">&nbsp;                                                               victim.getId(), hitCoords, direction);</b>
<b class="nc">&nbsp;                    if (null != dest) {</b>
<b class="nc">&nbsp;                        doEntityDisplacement(</b>
&nbsp;                                victim,
&nbsp;                                hitCoords,
&nbsp;                                dest,
<b class="nc">&nbsp;                                new PilotingRollData(victim.getId(), 0, &quot;crash&quot;));</b>
<b class="nc">&nbsp;                    } else if (!(victim instanceof Dropship)) {</b>
&nbsp;                        // destroy entity - but not dropships which are
&nbsp;                        // immovable
<b class="nc">&nbsp;                        addReport(destroyEntity(victim,</b>
&nbsp;                                                &quot;impossible displacement&quot;,
&nbsp;                                                victim instanceof Mech, victim instanceof Mech));
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // reduce woods
<b class="nc">&nbsp;            h = game.getBoard().getHex(hitCoords);</b>
<b class="nc">&nbsp;            if (h.containsTerrain(Terrains.WOODS)) {</b>
<b class="nc">&nbsp;                if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                    h.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                    h.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.ROUGH, 1));
&nbsp;                } else {
<b class="nc">&nbsp;                    int level = h.terrainLevel(Terrains.WOODS) - 1;</b>
<b class="nc">&nbsp;                    int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                    h.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                    if (level &gt; 0) {</b>
<b class="nc">&nbsp;                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                .createTerrain(Terrains.WOODS, level));</b>
<b class="nc">&nbsp;                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                .createTerrain(Terrains.FOLIAGE_ELEV, folEl == 1 ? 1 : 2));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                             .createTerrain(Terrains.ROUGH, 1));</b>
<b class="nc">&nbsp;                        h.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // do the same for jungles
<b class="nc">&nbsp;            if (h.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                    h.removeTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                    h.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.ROUGH, 1));
&nbsp;                } else {
<b class="nc">&nbsp;                    int level = h.terrainLevel(Terrains.JUNGLE) - 1;</b>
<b class="nc">&nbsp;                    int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                    h.removeTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                    if (level &gt; 0) {</b>
<b class="nc">&nbsp;                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                .createTerrain(Terrains.JUNGLE, level));</b>
<b class="nc">&nbsp;                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                .createTerrain(Terrains.FOLIAGE_ELEV, folEl == 1 ? 1 : 2));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                             .createTerrain(Terrains.ROUGH, 1));</b>
<b class="nc">&nbsp;                        h.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                if (!containsWater) {</b>
<b class="nc">&nbsp;                    h.setLevel(crateredElevation);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (!h.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                        h.removeAllTerrains();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    h.addTerrain(new Terrain(Terrains.WATER, crateredElevation,</b>
&nbsp;                                             false, 0));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            sendChangedHex(hitCoords);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check for a stacking violation - which should only happen in the
&nbsp;        // case of grounded dropships, because they are not movable
<b class="nc">&nbsp;        if (null != Compute.stackingViolation(game, entity.getId(), c)) {</b>
<b class="nc">&nbsp;            Coords dest = Compute.getValidDisplacement(game, entity.getId(), c,</b>
<b class="nc">&nbsp;                                                       Compute.d6() - 1);</b>
<b class="nc">&nbsp;            if (null != dest) {</b>
<b class="nc">&nbsp;                doEntityDisplacement(entity, c, dest, null);</b>
&nbsp;            } else {
&nbsp;                // ack! automatic death! Tanks
&nbsp;                // suffer an ammo/power plant hit.
&nbsp;                // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                vPhaseReport.addAll(destroyEntity(entity,</b>
&nbsp;                                                  &quot;impossible displacement&quot;, entity instanceof Mech,
&nbsp;                                                  entity instanceof Mech));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Check for watery death
<b class="nc">&nbsp;        h = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        if (h.containsTerrain(Terrains.WATER) &amp;&amp; !entity.isDestroyed()</b>
<b class="nc">&nbsp;            &amp;&amp; !entity.isDoomed()) {</b>
&nbsp;            int lethalDepth;
<b class="nc">&nbsp;            if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                lethalDepth = 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                lethalDepth = 1;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (h.depth() &gt;= lethalDepth) {</b>
&nbsp;                // Oh snap... we is dead
<b class="nc">&nbsp;                vReport.addAll(destroyEntity(entity,</b>
&nbsp;                                             &quot;crashing into deep water&quot;, true, true));
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Process any flee movement actions, including flying off the map
&nbsp;     *
&nbsp;     * @param movePath   The move path which resulted in an entity leaving the map.
&nbsp;     * @param flewOff    whether this fleeing is a result of accidentally flying off the
&nbsp;     *                   map
&nbsp;     * @param returnable the number of rounds until the unit can return to the map (-1
&nbsp;     *                   if it can&#39;t return)
&nbsp;     * @return Vector of turn reports.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; processLeaveMap(MovePath movePath, boolean flewOff, int returnable) {
<b class="nc">&nbsp;        Entity entity = movePath.getEntity();</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; vReport = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;        // Unit has fled the battlefield.
<b class="nc">&nbsp;        r = new Report(2005, Report.PUBLIC);</b>
<b class="nc">&nbsp;        if (flewOff) {</b>
<b class="nc">&nbsp;            r = new Report(9370, Report.PUBLIC);</b>
&nbsp;        }
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;        OffBoardDirection fleeDirection;
<b class="nc">&nbsp;        if (movePath.getFinalCoords().getY() &lt;= 0) {</b>
<b class="nc">&nbsp;            fleeDirection = OffBoardDirection.NORTH;</b>
<b class="nc">&nbsp;        } else if (movePath.getFinalCoords().getY() &gt;= (getGame().getBoard().getHeight() - 1)) {</b>
<b class="nc">&nbsp;            fleeDirection = OffBoardDirection.SOUTH;</b>
<b class="nc">&nbsp;        } else if (movePath.getFinalCoords().getX() &lt;= 0) {</b>
<b class="nc">&nbsp;            fleeDirection = OffBoardDirection.WEST;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            fleeDirection = OffBoardDirection.EAST;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (returnable &gt; -1) {</b>
&nbsp;
<b class="nc">&nbsp;            entity.setDeployed(false);</b>
<b class="nc">&nbsp;            entity.setDeployRound(1 + game.getRoundCount() + returnable);</b>
<b class="nc">&nbsp;            entity.setPosition(null);</b>
<b class="nc">&nbsp;            entity.setDone(true);</b>
<b class="nc">&nbsp;            if (entity.isAero()) {</b>
&nbsp;                // If we&#39;re flying off because we&#39;re OOC, when we come back we
&nbsp;                // should no longer be OOC
&nbsp;                // If we don&#39;t, this causes a major problem as aeros tend to
&nbsp;                // return, re-deploy then
&nbsp;                // fly off again instantly.
<b class="nc">&nbsp;                ((IAero) entity).setOutControl(false);</b>
&nbsp;            }
<b class="nc">&nbsp;            switch (fleeDirection) {</b>
&nbsp;                case WEST:
<b class="nc">&nbsp;                    entity.setStartingPos(Board.START_W);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case NORTH:
<b class="nc">&nbsp;                    entity.setStartingPos(Board.START_N);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case EAST:
<b class="nc">&nbsp;                    entity.setStartingPos(Board.START_E);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case SOUTH:
<b class="nc">&nbsp;                    entity.setStartingPos(Board.START_S);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    entity.setStartingPos(Board.START_EDGE);</b>
&nbsp;            }
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            return vReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the unit carrying passengers or trailers?
<b class="nc">&nbsp;        final List&lt;Entity&gt; passengers = new ArrayList&lt;&gt;(entity.getLoadedUnits());</b>
<b class="nc">&nbsp;        if (!entity.getAllTowedUnits().isEmpty()) {</b>
<b class="nc">&nbsp;            for (int id : entity.getAllTowedUnits()) {</b>
<b class="nc">&nbsp;                Entity towed = game.getEntity(id);</b>
<b class="nc">&nbsp;                passengers.add(towed);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!passengers.isEmpty()) {</b>
<b class="nc">&nbsp;            for (Entity passenger : passengers) {</b>
&nbsp;                // Unit has fled the battlefield.
<b class="nc">&nbsp;                r = new Report(2010, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.addDesc(passenger);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                passenger.setRetreatedDirection(fleeDirection);</b>
<b class="nc">&nbsp;                game.removeEntity(passenger.getId(),</b>
&nbsp;                                  IEntityRemovalConditions.REMOVE_IN_RETREAT);
<b class="nc">&nbsp;                send(createRemoveEntityPacket(passenger.getId(),</b>
&nbsp;                                              IEntityRemovalConditions.REMOVE_IN_RETREAT));
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Handle any picked up MechWarriors
<b class="nc">&nbsp;        for (Integer mechWarriorId : entity.getPickedUpMechWarriors()) {</b>
<b class="nc">&nbsp;            Entity mw = game.getEntity(mechWarriorId);</b>
&nbsp;            
<b class="nc">&nbsp;            if(mw == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Is the MechWarrior an enemy?
<b class="nc">&nbsp;            int condition = IEntityRemovalConditions.REMOVE_IN_RETREAT;</b>
<b class="nc">&nbsp;            r = new Report(2010);</b>
<b class="nc">&nbsp;            if (mw.isCaptured()) {</b>
<b class="nc">&nbsp;                r = new Report(2015);</b>
<b class="nc">&nbsp;                condition = IEntityRemovalConditions.REMOVE_CAPTURED;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                mw.setRetreatedDirection(fleeDirection);</b>
&nbsp;            }
<b class="nc">&nbsp;            game.removeEntity(mw.getId(), condition);</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(mw.getId(), condition));</b>
<b class="nc">&nbsp;            r.addDesc(mw);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Is the unit being swarmed?
<b class="nc">&nbsp;        final int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;        if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;            final Entity swarmer = game.getEntity(swarmerId);</b>
&nbsp;
&nbsp;            // Has the swarmer taken a turn?
<b class="nc">&nbsp;            if (!swarmer.isDone()) {</b>
&nbsp;                // Dead entities don&#39;t take turns.
<b class="nc">&nbsp;                game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
&nbsp;
&nbsp;            } // End swarmer-still-to-move
&nbsp;
&nbsp;            // Unit has fled the battlefield.
<b class="nc">&nbsp;            swarmer.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;            entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;            r = new Report(2015, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(swarmer);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            game.removeEntity(swarmerId, IEntityRemovalConditions.REMOVE_CAPTURED);</b>
<b class="nc">&nbsp;            send(createRemoveEntityPacket(swarmerId, IEntityRemovalConditions.REMOVE_CAPTURED));</b>
&nbsp;        }
<b class="nc">&nbsp;        entity.setRetreatedDirection(fleeDirection);</b>
<b class="nc">&nbsp;        game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;        send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));</b>
<b class="nc">&nbsp;        return vReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Steps through an entity movement packet, executing it.
&nbsp;     *
&nbsp;     * @param entity   The Entity that is moving
&nbsp;     * @param md       The MovePath that defines how the Entity moves
&nbsp;     * @param losCache A cache that stores Los between various Entities and
&nbsp;     *                 targets.  In double blind games, we may need to compute a
&nbsp;     *                 lot of LosEffects, so caching them can really speed
&nbsp;     *                 things up.
&nbsp;     */
&nbsp;    private void processMovement(Entity entity, MovePath md, Map&lt;EntityTargetPair,
&nbsp;            LosEffects&gt; losCache) {
&nbsp;        // Make sure the cache isn&#39;t null
<b class="nc">&nbsp;        if (losCache == null) {</b>
<b class="nc">&nbsp;            losCache = new HashMap&lt;&gt;();</b>
&nbsp;        }
&nbsp;        Report r;
<b class="nc">&nbsp;        boolean sideslipped = false; // for VTOL side slipping</b>
&nbsp;        PilotingRollData rollTarget;
&nbsp;
&nbsp;        // check for fleeing
<b class="nc">&nbsp;        if (md.contains(MoveStepType.FLEE)) {</b>
<b class="nc">&nbsp;            addReport(processLeaveMap(md, false, -1));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.EJECT)) {</b>
<b class="nc">&nbsp;            if (entity.isLargeCraft() &amp;&amp; !entity.isCarcass()) {</b>
<b class="nc">&nbsp;                r = new Report(2026);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                Aero ship = (Aero) entity;</b>
<b class="nc">&nbsp;                ship.setEjecting(true);</b>
<b class="nc">&nbsp;                entityUpdate(ship.getId());</b>
<b class="nc">&nbsp;                Coords legalPos = entity.getPosition();</b>
&nbsp;                //Get the step so we can pass it in and get the abandon coords from it
<b class="nc">&nbsp;                for (final Enumeration&lt;MoveStep&gt; i = md.getSteps(); i</b>
<b class="nc">&nbsp;                        .hasMoreElements();) {</b>
<b class="nc">&nbsp;                    final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;                    if (step.getType() == MoveStepType.EJECT) {</b>
<b class="nc">&nbsp;                        legalPos = step.getTargetPosition();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                addReport(ejectSpacecraft(ship, ship.isSpaceborne(), (ship.isAirborne() &amp;&amp; !ship.isSpaceborne()),legalPos));</b>
&nbsp;                //If we&#39;re grounded or destroyed by crew loss, end movement
<b class="nc">&nbsp;                if (entity.isDoomed() || (!entity.isSpaceborne() &amp;&amp; !entity.isAirborne())) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((entity instanceof Mech) || (entity instanceof Aero)) {</b>
<b class="nc">&nbsp;                r = new Report(2020);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getCrew().getName());</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(ejectEntity(entity, false));</b>
<b class="nc">&nbsp;                return;</b>
<b class="nc">&nbsp;            } else if ((entity instanceof Tank) &amp;&amp; !entity.isCarcass()) {</b>
<b class="nc">&nbsp;                r = new Report(2025);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(ejectEntity(entity, false));</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.CAREFUL_STAND)) {</b>
<b class="nc">&nbsp;            entity.setCarefulStand(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (md.contains(MoveStepType.BACKWARDS)) {</b>
<b class="nc">&nbsp;            entity.setMovedBackwards(true);</b>
<b class="nc">&nbsp;            if (md.getMpUsed() &gt; entity.getWalkMP()) {</b>
<b class="nc">&nbsp;                entity.setPowerReverse(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.TAKEOFF) &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            a.setCurrentVelocity(1);</b>
<b class="nc">&nbsp;            a.liftOff(1);</b>
<b class="nc">&nbsp;            if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                applyDropShipProximityDamage(md.getFinalCoords(), true, md.getFinalFacing(), entity);</b>
&nbsp;            }
<b class="nc">&nbsp;            checkForTakeoffDamage(a);</b>
<b class="nc">&nbsp;            entity.setPosition(entity.getPosition().translated(entity.getFacing(), a.getTakeOffLength()));</b>
<b class="nc">&nbsp;            entity.setDone(true);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.VTAKEOFF) &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            rollTarget = a.checkVerticalTakeOff();</b>
<b class="nc">&nbsp;            if (doVerticalTakeOffCheck(entity, rollTarget)) {</b>
<b class="nc">&nbsp;                a.setCurrentVelocity(0);</b>
<b class="nc">&nbsp;                a.liftOff(1);</b>
<b class="nc">&nbsp;                if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                    applyDropShipProximityDamage(md.getFinalCoords(), (Dropship)a);</b>
&nbsp;                }
<b class="nc">&nbsp;                checkForTakeoffDamage(a);</b>
&nbsp;            }
<b class="nc">&nbsp;            entity.setDone(true);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.LAND) &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            rollTarget = a.checkLanding(md.getLastStepMovementType(), md.getFinalVelocity(),</b>
<b class="nc">&nbsp;                    md.getFinalCoords(), md.getFinalFacing(), false);</b>
<b class="nc">&nbsp;            attemptLanding(entity, rollTarget);</b>
<b class="nc">&nbsp;            a.land();</b>
<b class="nc">&nbsp;            entity.setPosition(md.getFinalCoords().translated(md.getFinalFacing(),</b>
<b class="nc">&nbsp;                    a.getLandingLength()));</b>
<b class="nc">&nbsp;            entity.setDone(true);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.VLAND) &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            rollTarget = a.checkLanding(md.getLastStepMovementType(),</b>
<b class="nc">&nbsp;                    md.getFinalVelocity(), md.getFinalCoords(),</b>
<b class="nc">&nbsp;                    md.getFinalFacing(), true);</b>
<b class="nc">&nbsp;            attemptLanding(entity, rollTarget);</b>
<b class="nc">&nbsp;            if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;                applyDropShipLandingDamage(md.getFinalCoords(), (Dropship)a);</b>
&nbsp;            }
<b class="nc">&nbsp;            a.land();</b>
<b class="nc">&nbsp;            entity.setPosition(md.getFinalCoords());</b>
<b class="nc">&nbsp;            entity.setDone(true);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, proceed with movement calculations
<b class="nc">&nbsp;        Coords lastPos = entity.getPosition();</b>
<b class="nc">&nbsp;        Coords curPos = entity.getPosition();</b>
<b class="nc">&nbsp;        int curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;        int curVTOLElevation = entity.getElevation();</b>
&nbsp;        int curElevation;
<b class="nc">&nbsp;        int lastElevation = entity.getElevation();</b>
<b class="nc">&nbsp;        int curAltitude = entity.getAltitude();</b>
<b class="nc">&nbsp;        boolean curClimbMode = entity.climbMode();</b>
&nbsp;        // if the entity already used some MPs,
&nbsp;        // it previously tried to get up and fell,
&nbsp;        // and then got another turn. set moveType
&nbsp;        // and overallMoveType accordingly
&nbsp;        // (these are all cleared by Entity.newRound)
<b class="nc">&nbsp;        int distance = entity.delta_distance;</b>
<b class="nc">&nbsp;        int mpUsed = entity.mpUsed;</b>
<b class="nc">&nbsp;        EntityMovementType moveType = entity.moved;</b>
&nbsp;        EntityMovementType overallMoveType;
&nbsp;        boolean firstStep;
<b class="nc">&nbsp;        boolean wasProne = entity.isProne();</b>
<b class="nc">&nbsp;        boolean fellDuringMovement = false;</b>
<b class="nc">&nbsp;        boolean crashedDuringMovement = false;</b>
<b class="nc">&nbsp;        boolean dropshipStillUnloading = false;</b>
&nbsp;        boolean turnOver;
<b class="nc">&nbsp;        int prevFacing = curFacing;</b>
<b class="nc">&nbsp;        IHex prevHex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;        final boolean isInfantry = entity instanceof Infantry;</b>
<b class="nc">&nbsp;        AttackAction charge = null;</b>
<b class="nc">&nbsp;        RamAttackAction ram = null;</b>
&nbsp;        // cache this here, otherwise changing MP in the turn causes
&nbsp;        // erroneous gravity PSRs
<b class="nc">&nbsp;        int cachedGravityLimit = -1;</b>
<b class="nc">&nbsp;        int thrustUsed = 0;</b>
<b class="nc">&nbsp;        int j = 0;</b>
&nbsp;        boolean didMove;
<b class="nc">&nbsp;        boolean recovered = false;</b>
<b class="nc">&nbsp;        Entity loader = null;</b>
<b class="nc">&nbsp;        boolean continueTurnFromPBS = false;</b>
<b class="nc">&nbsp;        boolean continueTurnFromFishtail = false;</b>
<b class="nc">&nbsp;        boolean continueTurnFromLevelDrop = false;</b>
<b class="nc">&nbsp;        boolean continueTurnFromCliffAscent = false;</b>
&nbsp;
&nbsp;        // get a list of coordinates that the unit passed through this turn
&nbsp;        // so that I can later recover potential bombing targets
&nbsp;        // it may already have some values
<b class="nc">&nbsp;        Vector&lt;Coords&gt; passedThrough = entity.getPassedThrough();</b>
<b class="nc">&nbsp;        passedThrough.add(curPos);</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; passedThroughFacing = entity.getPassedThroughFacing();</b>
<b class="nc">&nbsp;        passedThroughFacing.add(curFacing);</b>
&nbsp;
&nbsp;        // Compile the move - don&#39;t clip
&nbsp;        // Clipping could affect hidden units; illegal steps aren&#39;t processed
<b class="nc">&nbsp;        md.compile(game, entity, false);</b>
&nbsp;
&nbsp;        // if advanced movement is being used then set the new vectors based on
&nbsp;        // move path
<b class="nc">&nbsp;        entity.setVectors(md.getFinalVectors());</b>
&nbsp;
<b class="nc">&nbsp;        overallMoveType = md.getLastStepMovementType();</b>
&nbsp;
&nbsp;        // check for starting in liquid magma
<b class="nc">&nbsp;        if ((game.getBoard().getHex(entity.getPosition())</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.MAGMA) == 2)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getElevation() == 0)) {</b>
<b class="nc">&nbsp;            doMagmaDamage(entity, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // set acceleration used to default
<b class="nc">&nbsp;        if (entity.isAero()) {</b>
<b class="nc">&nbsp;            ((IAero)entity).setAccLast(false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for dropping troops and drop them
<b class="nc">&nbsp;        if (entity.isDropping() &amp;&amp; !md.contains(MoveStepType.HOVER)) {</b>
<b class="nc">&nbsp;            entity.setAltitude(entity.getAltitude() - game.getPlanetaryConditions().getDropRate());</b>
&nbsp;            // they may have changed their facing
<b class="nc">&nbsp;            if (md.length() &gt; 0) {</b>
<b class="nc">&nbsp;                entity.setFacing(md.getFinalFacing());</b>
&nbsp;            }
<b class="nc">&nbsp;            passedThrough.add(entity.getPosition());</b>
<b class="nc">&nbsp;            entity.setPassedThrough(passedThrough);</b>
<b class="nc">&nbsp;            passedThroughFacing.add(entity.getFacing());</b>
<b class="nc">&nbsp;            entity.setPassedThroughFacing(passedThroughFacing);</b>
&nbsp;            // We may still need to process any conversions for dropping LAMs
<b class="nc">&nbsp;            if (entity instanceof LandAirMech &amp;&amp; md.contains(MoveStepType.CONVERT_MODE)) {</b>
<b class="nc">&nbsp;                entity.setMovementMode(md.getFinalConversionMode());</b>
<b class="nc">&nbsp;                entity.setConvertingNow(true);</b>
<b class="nc">&nbsp;                r = new Report(1210);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                    r.messageId = 2452;</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {</b>
<b class="nc">&nbsp;                    r.messageId = 2453;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.messageId = 2450;</b>
&nbsp;                }
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            entity.setDone(true);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // iterate through steps
<b class="nc">&nbsp;        firstStep = true;</b>
<b class="nc">&nbsp;        turnOver = false;</b>
&nbsp;        /* Bug 754610: Revert fix for bug 702735. */
<b class="nc">&nbsp;        MoveStep prevStep = null;</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Entity&gt; hiddenEnemies = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {</b>
<b class="nc">&nbsp;            for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (e.isHidden() &amp;&amp; e.isEnemyOf(entity) &amp;&amp; (e.getPosition() != null)) {</b>
<b class="nc">&nbsp;                    hiddenEnemies.add(e);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Vector&lt;UnitLocation&gt; movePath = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        EntityMovementType lastStepMoveType = md.getLastStepMovementType();</b>
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;            EntityMovementType stepMoveType = step.getMovementType(md.isEndStep(step));</b>
<b class="nc">&nbsp;            wasProne = entity.isProne();</b>
<b class="nc">&nbsp;            boolean isPavementStep = step.isPavementStep();</b>
<b class="nc">&nbsp;            entity.inReverse = step.isThisStepBackwards();</b>
<b class="nc">&nbsp;            boolean entityFellWhileAttemptingToStand = false;</b>
<b class="nc">&nbsp;            boolean isOnGround = !i.hasMoreElements();</b>
<b class="nc">&nbsp;            isOnGround |= stepMoveType != EntityMovementType.MOVE_JUMP;</b>
<b class="nc">&nbsp;            isOnGround &amp;= step.getElevation() &lt; 1;</b>
&nbsp;
&nbsp;            // Check for hidden units point blank shots
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {</b>
<b class="nc">&nbsp;                for (Entity e : hiddenEnemies) {</b>
<b class="nc">&nbsp;                    int dist = e.getPosition().distance(step.getPosition());</b>
&nbsp;                    // Checking for same hex and stacking violation
<b class="nc">&nbsp;                    if ((dist == 0) &amp;&amp; !continueTurnFromPBS</b>
<b class="nc">&nbsp;                            &amp;&amp; (Compute.stackingViolation(game, entity.getId(),</b>
<b class="nc">&nbsp;                                    step.getPosition()) != null)) {</b>
&nbsp;                        // Moving into hex of a hidden unit detects the unit
<b class="nc">&nbsp;                        e.setHidden(false);</b>
<b class="nc">&nbsp;                        entityUpdate(e.getId());</b>
<b class="nc">&nbsp;                        r = new Report(9960);</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(e.getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                        vPhaseReport.addElement(r);</b>
&nbsp;                        // Report the block
<b class="nc">&nbsp;                        if (doBlind()) {</b>
<b class="nc">&nbsp;                            r = new Report(9961);</b>
<b class="nc">&nbsp;                            r.subject = e.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(e);</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.add(step.getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                        }
&nbsp;                        // Report halted movement
<b class="nc">&nbsp;                        r = new Report(9962);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.add(step.getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        addNewLines();</b>
<b class="nc">&nbsp;                        Report.addNewline(vPhaseReport);</b>
&nbsp;                        // If we aren&#39;t at the end, send a special report
<b class="nc">&nbsp;                        if ((game.getTurnIndex() + 1) &lt; game.getTurnVector().size()) {</b>
<b class="nc">&nbsp;                            send(e.getOwner().getId(), createSpecialReportPacket());</b>
<b class="nc">&nbsp;                            send(entity.getOwner().getId(), createSpecialReportPacket());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        entity.setDone(true);</b>
<b class="nc">&nbsp;                        entityUpdate(entity.getId(), movePath, true, losCache);</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                        // Potential point-blank shot
<b class="nc">&nbsp;                    } else if ((dist == 1) &amp;&amp; !e.madePointblankShot()) {</b>
<b class="nc">&nbsp;                        entity.setPosition(step.getPosition());</b>
<b class="nc">&nbsp;                        entity.setFacing(step.getFacing());</b>
&nbsp;                        // If not set, BV icons could have wrong facing
<b class="nc">&nbsp;                        entity.setSecondaryFacing(step.getFacing());</b>
&nbsp;                        // Update entity position on client
<b class="nc">&nbsp;                        send(e.getOwnerId(), createEntityPacket(entity.getId(), null));</b>
<b class="nc">&nbsp;                        boolean tookPBS = processPointblankShotCFR(e, entity);</b>
&nbsp;                        // Movement should be interrupted
<b class="nc">&nbsp;                        if (tookPBS) {</b>
&nbsp;                            // Attacking reveals hidden unit
<b class="nc">&nbsp;                            e.setHidden(false);</b>
<b class="nc">&nbsp;                            entityUpdate(e.getId());</b>
<b class="nc">&nbsp;                            r = new Report(9960);</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(e.getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                            vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                            continueTurnFromPBS = true;</b>
&nbsp;
<b class="nc">&nbsp;                            curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                            curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                            mpUsed = step.getMpUsed();</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // stop for illegal movement
<b class="nc">&nbsp;            if (stepMoveType == EntityMovementType.MOVE_ILLEGAL) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // stop if the entity already killed itself
<b class="nc">&nbsp;            if (entity.isDestroyed() || entity.isDoomed()) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.UP &amp;&amp; !entity.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    entity.setWigeLiftoffHover(true);</b>
<b class="nc">&nbsp;                } else if (step.getType() == MoveStepType.HOVER) {</b>
<b class="nc">&nbsp;                    entity.setWigeLiftoffHover(true);</b>
<b class="nc">&nbsp;                    entity.setAssaultDropInProgress(false);</b>
<b class="nc">&nbsp;                } else if (step.getType() == MoveStepType.DOWN &amp;&amp; step.getClearance() == 0) {</b>
&nbsp;                    // If this is the first step, use the Entity&#39;s starting elevation
<b class="nc">&nbsp;                    int elevation = (prevStep == null) ? entity.getElevation() : prevStep.getElevation();</b>
<b class="nc">&nbsp;                    if (entity instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                        addReport(landAirMech((LandAirMech) entity, step.getPosition(), elevation,</b>
&nbsp;                                distance));
<b class="nc">&nbsp;                    } else if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                        addReport(landGliderPM((Protomech) entity, step.getPosition(), elevation,</b>
&nbsp;                                distance));
&nbsp;                    }
&nbsp;                    // landing always ends movement whether successful or not
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check for MASC failure on first step
&nbsp;            // also check Tanks because they can have superchargers that act
&nbsp;            // like MASc
<b class="nc">&nbsp;            if (firstStep &amp;&amp; ((entity instanceof Mech) || (entity instanceof Tank))) {</b>
&nbsp;                // Not necessarily a fall, but we need to give them a new turn to plot movement with
&nbsp;                // likely reduced MP.
<b class="nc">&nbsp;                fellDuringMovement = checkMASCFailure(entity, md);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (firstStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkGunningIt(overallMoveType);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    int mof = doSkillCheckWhileMoving(entity, lastElevation, lastPos,</b>
&nbsp;                            curPos, rollTarget, false);
<b class="nc">&nbsp;                    if (mof &gt; 0) {</b>
&nbsp;                        // Since this is the first step, we don&#39;t have a previous step so we&#39;ll pass
&nbsp;                        // this one in case it&#39;s needed to process a skid.
<b class="nc">&nbsp;                        if (processFailedVehicleManeuver(entity, curPos, 0, step,</b>
<b class="nc">&nbsp;                                step.isThisStepBackwards(), lastStepMoveType, distance, 2, mof)) {</b>
<b class="nc">&nbsp;                            if (md.hasActiveMASC()) {</b>
<b class="nc">&nbsp;                                mpUsed = entity.getRunMP();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                mpUsed = entity.getRunMPwithoutMASC();</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            turnOver = true;</b>
<b class="nc">&nbsp;                            distance = entity.delta_distance;</b>
<b class="nc">&nbsp;                            curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                            entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                            break;</b>
<b class="nc">&nbsp;                        } else if (entity.getFacing() != curFacing) {</b>
&nbsp;                            // If the facing doesn&#39;t change we had a minor fishtail that doesn&#39;t require
&nbsp;                            // stopping movement.
<b class="nc">&nbsp;                            continueTurnFromFishtail = true;</b>
<b class="nc">&nbsp;                            curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                            entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Check for failed maneuver for overdrive on first step. The rules for overdrive do not
&nbsp;            // state this explicitly, but since combining overdrive with gunning it requires two rolls
&nbsp;            // and gunning does state explicitly that the roll is made before movement, this
&nbsp;            // implies the same for overdrive.
<b class="nc">&nbsp;            if (firstStep &amp;&amp; (overallMoveType == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                    || overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT)) {
<b class="nc">&nbsp;                rollTarget = entity.checkUsingOverdrive(EntityMovementType.MOVE_SPRINT);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    int mof = doSkillCheckWhileMoving(entity, lastElevation, lastPos,</b>
&nbsp;                            curPos, rollTarget, false);
<b class="nc">&nbsp;                    if (mof &gt; 0) {</b>
<b class="nc">&nbsp;                        if (processFailedVehicleManeuver(entity, curPos, 0, step, step.isThisStepBackwards(),</b>
&nbsp;                                lastStepMoveType, distance, 2, mof)) {
<b class="nc">&nbsp;                            if (md.hasActiveMASC()) {</b>
<b class="nc">&nbsp;                                mpUsed = entity.getRunMP();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                mpUsed = entity.getRunMPwithoutMASC();</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            turnOver = true;</b>
<b class="nc">&nbsp;                            distance = entity.delta_distance;</b>
<b class="nc">&nbsp;                            curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                            entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                            break;</b>
<b class="nc">&nbsp;                        } else if (entity.getFacing() != curFacing) {</b>
&nbsp;                            // If the facing doesn&#39;t change we had a minor fishtail that doesn&#39;t require
&nbsp;                            // stopping movement.
<b class="nc">&nbsp;                            continueTurnFromFishtail = true;</b>
<b class="nc">&nbsp;                            curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                            entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.CONVERT_MODE) {</b>
<b class="nc">&nbsp;                entity.setConvertingNow(true);</b>
&nbsp;
&nbsp;                // Non-omni QuadVees converting to vehicle mode dump any riding BA in the
&nbsp;                // starting hex if they fail to make an anti-mech check.
&nbsp;                // http://bg.battletech.com/forums/index.php?topic=55263.msg1271423#msg1271423
<b class="nc">&nbsp;                if (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_MECH</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.isOmni()) {</b>
<b class="nc">&nbsp;                    for (Entity rider : entity.getExternalUnits()) {</b>
<b class="nc">&nbsp;                        addReport(checkDropBAFromConverting(entity, rider, curPos, curFacing,</b>
&nbsp;                                false, false, false));
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if ((entity.getEntityType() &amp; Entity.ETYPE_LAND_AIR_MECH) != 0) {</b>
&nbsp;                    //External units on LAMs, including swarmers, fall automatically and take damage,
&nbsp;                    //and the LAM itself may take one or more criticals.
<b class="nc">&nbsp;                    for (Entity rider : entity.getExternalUnits()) {</b>
<b class="nc">&nbsp;                        addReport(checkDropBAFromConverting(entity, rider, curPos, curFacing, true, true, true));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    final int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;                    if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;                        addReport(checkDropBAFromConverting(entity, game.getEntity(swarmerId),</b>
&nbsp;                                curPos, curFacing, true, true, true));
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            // did the entity move?
<b class="nc">&nbsp;            didMove = step.getDistance() &gt; distance;</b>
&nbsp;
&nbsp;            // check for aero stuff
<b class="nc">&nbsp;            if (entity.isAirborne() &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;                IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                j++;</b>
&nbsp;
&nbsp;                // increment straight moves (can&#39;t do it at end, because not all
&nbsp;                // steps may be processed)
<b class="nc">&nbsp;                a.setStraightMoves(step.getNStraight());</b>
&nbsp;
&nbsp;                // TODO : change the way this check is made
<b class="nc">&nbsp;                if (!didMove &amp;&amp; (md.length() != j)) {</b>
<b class="nc">&nbsp;                    thrustUsed += step.getMp();</b>
&nbsp;                } else {
&nbsp;                    // if this was the last move and distance was zero, then add
&nbsp;                    // thrust
<b class="nc">&nbsp;                    if (!didMove &amp;&amp; (md.length() == j)) {</b>
<b class="nc">&nbsp;                        thrustUsed += step.getMp();</b>
&nbsp;                    }
&nbsp;                    // then we moved to a new hex or the last step so check
&nbsp;                    // conditions
&nbsp;                    // structural damage
<b class="nc">&nbsp;                    rollTarget = a.checkThrustSI(thrustUsed, overallMoveType);</b>
<b class="nc">&nbsp;                    if ((rollTarget.getValue() != TargetRoll.CHECK_FALSE)</b>
<b class="nc">&nbsp;                            &amp;&amp; !(entity instanceof FighterSquadron) &amp;&amp; !game.useVectorMove()) {</b>
<b class="nc">&nbsp;                        if (!doSkillCheckInSpace(entity, rollTarget)) {</b>
<b class="nc">&nbsp;                            a.setSI(a.getSI() - 1);</b>
<b class="nc">&nbsp;                            if (entity instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                                addReport(criticalEntity(entity, Mech.LOC_CT, false, 0, 1));</b>
&nbsp;                            }
&nbsp;                            // check for destruction
<b class="nc">&nbsp;                            if (a.getSI() == 0) {</b>
&nbsp;                                // Lets auto-eject if we can!
<b class="nc">&nbsp;                                if (a instanceof LandAirMech) {</b>
&nbsp;                                    // LAMs eject if the CT destroyed switch is on
<b class="nc">&nbsp;                                    LandAirMech lam = (LandAirMech) a;</b>
<b class="nc">&nbsp;                                    if (lam.isAutoEject()</b>
<b class="nc">&nbsp;                                        &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                                        &amp;&amp; lam.isCondEjectCTDest()))) {</b>
<b class="nc">&nbsp;                                        addReport(ejectEntity(entity, true, false));</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                } else {</b>
&nbsp;                                    // Aeros eject if the SI Destroyed switch is on
<b class="nc">&nbsp;                                    Aero aero = (Aero) a;</b>
<b class="nc">&nbsp;                                    if (aero.isAutoEject()</b>
<b class="nc">&nbsp;                                        &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                                || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                                        &amp;&amp; aero.isCondEjectSIDest()))) {</b>
<b class="nc">&nbsp;                                        addReport(ejectEntity(entity, true, false));</b>
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                                addReport(destroyEntity(entity, &quot;Structural Integrity Collapse&quot;,</b>
&nbsp;                                        false));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // check for pilot damage
<b class="nc">&nbsp;                    int hits = entity.getCrew().getHits();</b>
<b class="nc">&nbsp;                    int health = 6 - hits;</b>
&nbsp;
<b class="nc">&nbsp;                    if ((thrustUsed &gt; (2 * health)) &amp;&amp; !game.useVectorMove()</b>
&nbsp;                            &amp;&amp; !(entity instanceof TeleMissile)) {
<b class="nc">&nbsp;                        int targetRoll = 2 + (thrustUsed - (2 * health))</b>
&nbsp;                                + (2 * hits);
<b class="nc">&nbsp;                        resistGForce(entity, targetRoll);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    thrustUsed = 0;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.RETURN) {</b>
<b class="nc">&nbsp;                    a.setCurrentVelocity(md.getFinalVelocity());</b>
<b class="nc">&nbsp;                    entity.setAltitude(curAltitude);</b>
<b class="nc">&nbsp;                    processLeaveMap(md, true, Compute.roundsUntilReturn(game, entity));</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.OFF) {</b>
<b class="nc">&nbsp;                    a.setCurrentVelocity(md.getFinalVelocity());</b>
<b class="nc">&nbsp;                    entity.setAltitude(curAltitude);</b>
<b class="nc">&nbsp;                    processLeaveMap(md, true, -1);</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                rollTarget = a.checkRolls(step, overallMoveType);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(entity.getId(), 0, &quot;excess roll&quot;));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                rollTarget = a.checkManeuver(step, overallMoveType);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    if (!doSkillCheckManeuver(entity, rollTarget)) {</b>
<b class="nc">&nbsp;                        a.setFailedManeuver(true);</b>
<b class="nc">&nbsp;                        int forward = Math.max(step.getVelocityLeft() / 2, 1);</b>
<b class="nc">&nbsp;                        if (forward &lt; step.getVelocityLeft()) {</b>
<b class="nc">&nbsp;                            fellDuringMovement = true;</b>
&nbsp;                        }
&nbsp;                        // multiply forward by 16 when on ground hexes
<b class="nc">&nbsp;                        if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                            forward *= 16;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        while (forward &gt; 0) {</b>
<b class="nc">&nbsp;                            curPos = curPos.translated(step.getFacing());</b>
<b class="nc">&nbsp;                            forward--;</b>
<b class="nc">&nbsp;                            distance++;</b>
<b class="nc">&nbsp;                            a.setStraightMoves(a.getStraightMoves() + 1);</b>
&nbsp;                            // make sure it didn&#39;t fly off the map
<b class="nc">&nbsp;                            if (!game.getBoard().contains(curPos)) {</b>
<b class="nc">&nbsp;                                a.setCurrentVelocity(md.getFinalVelocity());</b>
<b class="nc">&nbsp;                                processLeaveMap(md, true, Compute.roundsUntilReturn(game, entity));</b>
<b class="nc">&nbsp;                                return;</b>
&nbsp;                                // make sure it didn&#39;t crash
<b class="nc">&nbsp;                            } else if (checkCrash(entity, curPos, step.getAltitude())) {</b>
<b class="nc">&nbsp;                                addReport(processCrash(entity, step.getVelocity(), curPos));</b>
<b class="nc">&nbsp;                                forward = 0;</b>
<b class="nc">&nbsp;                                fellDuringMovement = false;</b>
<b class="nc">&nbsp;                                crashedDuringMovement = true;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                        break;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // if out of control, check for possible collision
<b class="nc">&nbsp;                if (didMove &amp;&amp; a.isOutControlTotal()) {</b>
<b class="nc">&nbsp;                    Iterator&lt;Entity&gt; targets = game.getEntities(step.getPosition());</b>
<b class="nc">&nbsp;                    if (targets.hasNext()) {</b>
&nbsp;                        // Somebody here so check to see if there is a collision
<b class="nc">&nbsp;                        int checkRoll = Compute.d6(2);</b>
&nbsp;                        // TODO : change this to 11 for Large Craft
<b class="nc">&nbsp;                        int targetRoll = 11;</b>
<b class="nc">&nbsp;                        if ((a instanceof Dropship) || (entity instanceof Jumpship)) {</b>
<b class="nc">&nbsp;                            targetRoll = 10;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (checkRoll &gt;= targetRoll) {</b>
&nbsp;                            // this gets complicated, I need to check for each
&nbsp;                            // unit type
&nbsp;                            // by order of movement sub-phase
<b class="nc">&nbsp;                            Vector&lt;Integer&gt; potentialSpaceStation = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                            Vector&lt;Integer&gt; potentialWarShip = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                            Vector&lt;Integer&gt; potentialJumpShip = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                            Vector&lt;Integer&gt; potentialDropShip = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                            Vector&lt;Integer&gt; potentialSmallCraft = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                            Vector&lt;Integer&gt; potentialASF = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;                            while (targets.hasNext()) {</b>
<b class="nc">&nbsp;                                int id = targets.next().getId();</b>
<b class="nc">&nbsp;                                Entity ce = game.getEntity(id);</b>
&nbsp;                                // if we are in atmosphere and not the same altitude
&nbsp;                                // then skip
<b class="nc">&nbsp;                                if (!game.getBoard().inSpace() &amp;&amp; (ce.getAltitude() != curAltitude)) {</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
&nbsp;                                // you can&#39;t collide with yourself
<b class="nc">&nbsp;                                if (ce.equals(a)) {</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                if (ce instanceof SpaceStation) {</b>
<b class="nc">&nbsp;                                    potentialSpaceStation.addElement(id);</b>
<b class="nc">&nbsp;                                } else if (ce instanceof Warship) {</b>
<b class="nc">&nbsp;                                    potentialWarShip.addElement(id);</b>
<b class="nc">&nbsp;                                } else if (ce instanceof Jumpship) {</b>
<b class="nc">&nbsp;                                    potentialJumpShip.addElement(id);</b>
<b class="nc">&nbsp;                                } else if (ce instanceof Dropship) {</b>
<b class="nc">&nbsp;                                    potentialDropShip.addElement(id);</b>
<b class="nc">&nbsp;                                } else if (ce instanceof SmallCraft) {</b>
<b class="nc">&nbsp;                                    potentialSmallCraft.addElement(id);</b>
&nbsp;                                } else {
&nbsp;                                    // ASF can actually include anything,
&nbsp;                                    // because we might
&nbsp;                                    // have combat dropping troops
<b class="nc">&nbsp;                                    potentialASF.addElement(id);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            // ok now go through and see if these have anybody in them
&nbsp;                            int chosen;
&nbsp;                            Entity target;
&nbsp;                            Coords destination;
&nbsp;
<b class="nc">&nbsp;                            if (potentialSpaceStation.size() &gt; 0) {</b>
<b class="nc">&nbsp;                                chosen = Compute.randomInt(potentialSpaceStation.size());</b>
<b class="nc">&nbsp;                                target = game.getEntity(potentialSpaceStation.elementAt(chosen));</b>
<b class="nc">&nbsp;                                destination = target.getPosition();</b>
<b class="nc">&nbsp;                                if (processCollision(entity, target, lastPos)) {</b>
<b class="nc">&nbsp;                                    curPos = destination;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } else if (potentialWarShip.size() &gt; 0) {</b>
<b class="nc">&nbsp;                                chosen = Compute.randomInt(potentialWarShip.size());</b>
<b class="nc">&nbsp;                                target = game.getEntity(potentialWarShip.elementAt(chosen));</b>
<b class="nc">&nbsp;                                destination = target.getPosition();</b>
<b class="nc">&nbsp;                                if (processCollision(entity, target, lastPos)) {</b>
<b class="nc">&nbsp;                                    curPos = destination;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } else if (potentialJumpShip.size() &gt; 0) {</b>
<b class="nc">&nbsp;                                chosen = Compute.randomInt(potentialJumpShip.size());</b>
<b class="nc">&nbsp;                                target = game.getEntity(potentialJumpShip.elementAt(chosen));</b>
<b class="nc">&nbsp;                                destination = target.getPosition();</b>
<b class="nc">&nbsp;                                if (processCollision(entity, target, lastPos)) {</b>
<b class="nc">&nbsp;                                    curPos = destination;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } else if (potentialDropShip.size() &gt; 0) {</b>
<b class="nc">&nbsp;                                chosen = Compute.randomInt(potentialDropShip.size());</b>
<b class="nc">&nbsp;                                target = game.getEntity(potentialDropShip.elementAt(chosen));</b>
<b class="nc">&nbsp;                                destination = target.getPosition();</b>
<b class="nc">&nbsp;                                if (processCollision(entity, target, lastPos)) {</b>
<b class="nc">&nbsp;                                    curPos = destination;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } else if (potentialSmallCraft.size() &gt; 0) {</b>
<b class="nc">&nbsp;                                chosen = Compute.randomInt(potentialSmallCraft.size());</b>
<b class="nc">&nbsp;                                target = game.getEntity(potentialSmallCraft.elementAt(chosen));</b>
<b class="nc">&nbsp;                                destination = target.getPosition();</b>
<b class="nc">&nbsp;                                if (processCollision(entity, target, lastPos)) {</b>
<b class="nc">&nbsp;                                    curPos = destination;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } else if (potentialASF.size() &gt; 0) {</b>
<b class="nc">&nbsp;                                chosen = Compute.randomInt(potentialASF.size());</b>
<b class="nc">&nbsp;                                target = game.getEntity(potentialASF.elementAt(chosen));</b>
<b class="nc">&nbsp;                                destination = target.getPosition();</b>
<b class="nc">&nbsp;                                if (processCollision(entity, target, lastPos)) {</b>
<b class="nc">&nbsp;                                    curPos = destination;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // if in the atmosphere, check for a potential crash
&nbsp;
<b class="nc">&nbsp;                if (checkCrash(entity, step.getPosition(), step.getAltitude())) {</b>
<b class="nc">&nbsp;                    addReport(processCrash(entity, md.getFinalVelocity(), curPos));</b>
<b class="nc">&nbsp;                    crashedDuringMovement = true;</b>
&nbsp;                    // don&#39;t do the rest
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
&nbsp;                // handle fighter launching
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.LAUNCH) {</b>
<b class="nc">&nbsp;                    TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; launched = step.getLaunched();</b>
<b class="nc">&nbsp;                    Set&lt;Integer&gt; bays = launched.keySet();</b>
<b class="nc">&nbsp;                    Iterator&lt;Integer&gt; bayIter = bays.iterator();</b>
&nbsp;                    Bay currentBay;
<b class="nc">&nbsp;                    while (bayIter.hasNext()) {</b>
<b class="nc">&nbsp;                        int bayId = bayIter.next();</b>
<b class="nc">&nbsp;                        currentBay = entity.getFighterBays().elementAt(bayId);</b>
<b class="nc">&nbsp;                        Vector&lt;Integer&gt; launches = launched.get(bayId);</b>
<b class="nc">&nbsp;                        int nLaunched = launches.size();</b>
&nbsp;                        // need to make some decisions about how to handle the
&nbsp;                        // distribution
&nbsp;                        // of fighters to doors beyond the launch rate. The most
&nbsp;                        // sensible thing
&nbsp;                        // is probably to distribute them evenly.
<b class="nc">&nbsp;                        int doors = currentBay.getCurrentDoors();</b>
<b class="nc">&nbsp;                        int[] distribution = new int[doors];</b>
<b class="nc">&nbsp;                        for (int l = 0; l &lt; nLaunched; l++) {</b>
<b class="nc">&nbsp;                            distribution[l % doors] = distribution[l % doors] + 1;</b>
&nbsp;                        }
&nbsp;                        // ok, now lets launch them
<b class="nc">&nbsp;                        r = new Report(9380);</b>
<b class="nc">&nbsp;                        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(nLaunched);</b>
<b class="nc">&nbsp;                        r.add(&quot;bay &quot; + currentBay.getBayNumber() + &quot; (&quot; + doors + &quot; doors)&quot;);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        int currentDoor = 0;</b>
<b class="nc">&nbsp;                        int fighterCount = 0;</b>
<b class="nc">&nbsp;                        boolean doorDamage = false;</b>
<b class="nc">&nbsp;                        for (int fighterId : launches) {</b>
&nbsp;                            // check to see if we are in the same door
<b class="nc">&nbsp;                            fighterCount++;</b>
&nbsp;
&nbsp;                            // check for door damage
<b class="nc">&nbsp;                            Report doorReport = null;</b>
<b class="nc">&nbsp;                            if (!doorDamage &amp;&amp; (distribution[currentDoor] &gt; 2) &amp;&amp; (fighterCount &gt; 2)) {</b>
<b class="nc">&nbsp;                                doorReport = new Report(9378);</b>
<b class="nc">&nbsp;                                doorReport.subject = entity.getId();</b>
<b class="nc">&nbsp;                                doorReport.indent(2);</b>
<b class="nc">&nbsp;                                int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                                doorReport.add(roll);</b>
<b class="nc">&nbsp;                                if (roll == 2) {</b>
<b class="nc">&nbsp;                                    doorDamage = true;</b>
<b class="nc">&nbsp;                                    doorReport.choose(true);</b>
<b class="nc">&nbsp;                                    currentBay.destroyDoorNext();</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    doorReport.choose(false);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                doorReport.newlines++;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            if (fighterCount &gt; distribution[currentDoor]) {</b>
&nbsp;                                // move to a new door
<b class="nc">&nbsp;                                currentDoor++;</b>
<b class="nc">&nbsp;                                fighterCount = 0;</b>
<b class="nc">&nbsp;                                doorDamage = false;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            int bonus = Math.max(0,</b>
&nbsp;                                    distribution[currentDoor] - 2);
&nbsp;
<b class="nc">&nbsp;                            Entity fighter = game.getEntity(fighterId);</b>
<b class="nc">&nbsp;                            if (!launchUnit(entity, fighter, curPos, curFacing, step.getVelocity(),</b>
<b class="nc">&nbsp;                                    step.getAltitude(), step.getVectors(), bonus)) {</b>
<b class="nc">&nbsp;                                MegaMek.getLogger().error(&quot;Server was told to unload &quot;</b>
<b class="nc">&nbsp;                                        + fighter.getDisplayName() + &quot; from &quot; + entity.getDisplayName()</b>
<b class="nc">&nbsp;                                        + &quot; into &quot; + curPos.getBoardNum());</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (doorReport != null) {</b>
<b class="nc">&nbsp;                                addReport(doorReport);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // now apply any damage to bay doors
<b class="nc">&nbsp;                    entity.resetBayDoors();</b>
&nbsp;                }
&nbsp;
&nbsp;                // handle DropShip undocking
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.UNDOCK) {</b>
<b class="nc">&nbsp;                    TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; launched = step.getLaunched();</b>
<b class="nc">&nbsp;                    Set&lt;Integer&gt; collars = launched.keySet();</b>
<b class="nc">&nbsp;                    Iterator&lt;Integer&gt; collarIter = collars.iterator();</b>
<b class="nc">&nbsp;                    while (collarIter.hasNext()) {</b>
<b class="nc">&nbsp;                        int collarId = collarIter.next();</b>
<b class="nc">&nbsp;                        Vector&lt;Integer&gt; launches = launched.get(collarId);</b>
<b class="nc">&nbsp;                        int nLaunched = launches.size();</b>
&nbsp;                        // ok, now lets launch them
<b class="nc">&nbsp;                        r = new Report(9380);</b>
<b class="nc">&nbsp;                        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(nLaunched);</b>
<b class="nc">&nbsp;                        r.add(&quot;collar &quot; + collarId);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        for (int dropShipId : launches) {</b>
&nbsp;                            // check to see if we are in the same door
<b class="nc">&nbsp;                            Entity ds = game.getEntity(dropShipId);</b>
<b class="nc">&nbsp;                            if (!launchUnit(entity, ds, curPos, curFacing,</b>
<b class="nc">&nbsp;                                    step.getVelocity(), step.getAltitude(),</b>
<b class="nc">&nbsp;                                    step.getVectors(), 0)) {</b>
<b class="nc">&nbsp;                                MegaMek.getLogger().error(&quot;Error! Server was told to unload &quot;</b>
<b class="nc">&nbsp;                                                + ds.getDisplayName() + &quot; from &quot;</b>
<b class="nc">&nbsp;                                                + entity.getDisplayName() + &quot; into &quot;</b>
<b class="nc">&nbsp;                                                + curPos.getBoardNum());</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                // handle combat drops
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.DROP) {</b>
<b class="nc">&nbsp;                    TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; dropped = step.getLaunched();</b>
<b class="nc">&nbsp;                    Set&lt;Integer&gt; bays = dropped.keySet();</b>
<b class="nc">&nbsp;                    Iterator&lt;Integer&gt; bayIter = bays.iterator();</b>
&nbsp;                    Bay currentBay;
<b class="nc">&nbsp;                    while (bayIter.hasNext()) {</b>
<b class="nc">&nbsp;                        int bayId = bayIter.next();</b>
<b class="nc">&nbsp;                        currentBay = entity.getTransportBays().elementAt(bayId);</b>
<b class="nc">&nbsp;                        Vector&lt;Integer&gt; drops = dropped.get(bayId);</b>
<b class="nc">&nbsp;                        int nDropped = drops.size();</b>
&nbsp;                        // ok, now lets drop them
<b class="nc">&nbsp;                        r = new Report(9386);</b>
<b class="nc">&nbsp;                        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(nDropped);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        for (int unitId : drops) {</b>
<b class="nc">&nbsp;                            if (Compute.d6(2) == 2) {</b>
<b class="nc">&nbsp;                                r = new Report(9390);</b>
<b class="nc">&nbsp;                                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                                r.indent(1);</b>
<b class="nc">&nbsp;                                r.add(currentBay.getType());</b>
<b class="nc">&nbsp;                                addReport(r);</b>
<b class="nc">&nbsp;                                currentBay.destroyDoorNext();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            Entity drop = game.getEntity(unitId);</b>
<b class="nc">&nbsp;                            dropUnit(drop, entity, curPos, step.getAltitude());</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // now apply any damage to bay doors
<b class="nc">&nbsp;                    entity.resetBayDoors();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check piloting skill for getting up
<b class="nc">&nbsp;            rollTarget = entity.checkGetUp(step, overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
&nbsp;                // Unless we&#39;re an ICE- or fuel cell-powered IndustrialMech,
&nbsp;                // standing up builds heat.
<b class="nc">&nbsp;                if ((entity instanceof Mech) &amp;&amp; entity.hasEngine() &amp;&amp; !(((Mech) entity).isIndustrial()</b>
<b class="nc">&nbsp;                        &amp;&amp; ((entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE)</b>
<b class="nc">&nbsp;                                || (entity.getEngine().getEngineType() == Engine.FUEL_CELL)))) {</b>
<b class="nc">&nbsp;                    entity.heatBuildup += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                entity.setProne(false);</b>
&nbsp;                // entity.setHullDown(false);
<b class="nc">&nbsp;                wasProne = false;</b>
<b class="nc">&nbsp;                game.resetPSRs(entity);</b>
<b class="nc">&nbsp;                entityFellWhileAttemptingToStand = !doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;            }
&nbsp;            // did the entity just fall?
<b class="nc">&nbsp;            if (entityFellWhileAttemptingToStand) {</b>
<b class="nc">&nbsp;                moveType = stepMoveType;</b>
<b class="nc">&nbsp;                curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                mpUsed = step.getMpUsed();</b>
<b class="nc">&nbsp;                fellDuringMovement = true;</b>
<b class="nc">&nbsp;                if (!entity.isCarefulStand()) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                entity.setHullDown(false);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.UNJAM_RAC) {</b>
<b class="nc">&nbsp;                entity.setUnjammingRAC(true);</b>
<b class="nc">&nbsp;                game.addAction(new UnjamAction(entity.getId()));</b>
&nbsp;
&nbsp;                // for Aeros this will end movement prematurely
&nbsp;                // if we break
<b class="nc">&nbsp;                if (!(entity.isAirborne())) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.LAY_MINE) {</b>
<b class="nc">&nbsp;                layMine(entity, step.getMineToLay(), step.getPosition());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.CLEAR_MINEFIELD) {</b>
<b class="nc">&nbsp;                ClearMinefieldAction cma = new ClearMinefieldAction(entity.getId(), step.getMinefield());</b>
<b class="nc">&nbsp;                entity.setClearingMinefield(true);</b>
<b class="nc">&nbsp;                game.addAction(cma);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.SEARCHLIGHT)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.hasSpotlight()) {</b>
<b class="nc">&nbsp;                final boolean SearchOn = !entity.isUsingSpotlight();</b>
<b class="nc">&nbsp;                entity.setSpotlightState(SearchOn);</b>
<b class="nc">&nbsp;                if (doBlind()) { // if double blind, we may need to filter the</b>
&nbsp;                    // players that receive this message
<b class="nc">&nbsp;                    Vector&lt;IPlayer&gt; playersVector = game.getPlayersVector();</b>
<b class="nc">&nbsp;                    Vector&lt;IPlayer&gt; vCanSee = whoCanSee(entity);</b>
<b class="nc">&nbsp;                    for (IPlayer p : playersVector) {</b>
<b class="nc">&nbsp;                        if (vCanSee.contains(p)) { // Player sees the unit</b>
<b class="nc">&nbsp;                            sendServerChat(p.getId(),</b>
<b class="nc">&nbsp;                                    entity.getDisplayName()</b>
&nbsp;                                            + &quot; switched searchlight &quot;
<b class="nc">&nbsp;                                            + (SearchOn ? &quot;on&quot; : &quot;off&quot;) + &#39;.&#39;);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            sendServerChat(p.getId(),</b>
&nbsp;                                    &quot;An unseen unit&quot; + &quot; switched searchlight &quot;
<b class="nc">&nbsp;                                            + (SearchOn ? &quot;on&quot; : &quot;off&quot;) + &#39;.&#39;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else { // No double blind, everyone can see this</b>
<b class="nc">&nbsp;                    sendServerChat(</b>
<b class="nc">&nbsp;                            entity.getDisplayName() + &quot; switched searchlight &quot;</b>
<b class="nc">&nbsp;                                    + (SearchOn ? &quot;on&quot; : &quot;off&quot;) + &#39;.&#39;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // set most step parameters
<b class="nc">&nbsp;            moveType = stepMoveType;</b>
<b class="nc">&nbsp;            distance = step.getDistance();</b>
<b class="nc">&nbsp;            mpUsed = step.getMpUsed();</b>
&nbsp;
<b class="nc">&nbsp;            if (cachedGravityLimit &lt; 0) {</b>
<b class="nc">&nbsp;                cachedGravityLimit = EntityMovementType.MOVE_JUMP == moveType</b>
<b class="nc">&nbsp;                        ? entity.getJumpMP(false)</b>
<b class="nc">&nbsp;                        : entity.getRunningGravityLimit();</b>
&nbsp;            }
&nbsp;            // check for charge
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.CHARGE) {</b>
<b class="nc">&nbsp;                if (entity.canCharge()) {</b>
<b class="nc">&nbsp;                    checkExtremeGravityMovement(entity, step, lastStepMoveType,</b>
&nbsp;                            curPos, cachedGravityLimit);
<b class="nc">&nbsp;                    Targetable target = step.getTarget(game);</b>
<b class="nc">&nbsp;                    if (target != null) {</b>
<b class="nc">&nbsp;                        ChargeAttackAction caa = new ChargeAttackAction(</b>
<b class="nc">&nbsp;                                entity.getId(), target.getTargetType(),</b>
<b class="nc">&nbsp;                                target.getTargetId(), target.getPosition());</b>
<b class="nc">&nbsp;                        entity.setDisplacementAttack(caa);</b>
<b class="nc">&nbsp;                        game.addCharge(caa);</b>
<b class="nc">&nbsp;                        charge = caa;</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        String message = &quot;Illegal charge!! &quot; + entity.getDisplayName() +</b>
&nbsp;                                &quot; is attempting to charge a null target!&quot;;
<b class="nc">&nbsp;                        MegaMek.getLogger().info(message);</b>
<b class="nc">&nbsp;                        sendServerChat(message);</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (entity.isAirborneVTOLorWIGE() &amp;&amp; entity.canRam()) {</b>
<b class="nc">&nbsp;                    checkExtremeGravityMovement(entity, step, lastStepMoveType,</b>
&nbsp;                            curPos, cachedGravityLimit);
<b class="nc">&nbsp;                    Targetable target = step.getTarget(game);</b>
<b class="nc">&nbsp;                    if (target != null) {</b>
<b class="nc">&nbsp;                        AirmechRamAttackAction raa = new AirmechRamAttackAction(</b>
<b class="nc">&nbsp;                                entity.getId(), target.getTargetType(),</b>
<b class="nc">&nbsp;                                target.getTargetId(), target.getPosition());</b>
<b class="nc">&nbsp;                        entity.setDisplacementAttack(raa);</b>
<b class="nc">&nbsp;                        entity.setRamming(true);</b>
<b class="nc">&nbsp;                        game.addCharge(raa);</b>
<b class="nc">&nbsp;                        charge = raa;</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        String message = &quot;Illegal charge!! &quot; + entity.getDisplayName() + &quot; is attempting to charge a null target!&quot;;</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().info(message);</b>
<b class="nc">&nbsp;                        sendServerChat(message);</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Illegal charge!! I don&#39;t think &quot;</b>
<b class="nc">&nbsp;                            + entity.getDisplayName()</b>
&nbsp;                            + &quot; should be allowed to charge,&quot;
&nbsp;                            + &quot; but the client of &quot;
<b class="nc">&nbsp;                            + entity.getOwner().getName() + &quot; disagrees.&quot;);</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Please make sure &quot;</b>
<b class="nc">&nbsp;                            + entity.getOwner().getName()</b>
&nbsp;                            + &quot; is running MegaMek &quot; + MegaMek.VERSION
&nbsp;                            + &quot;, or if that is already the case, submit a bug report at https://github.com/MegaMek/megamek/issues&quot;);
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            }
&nbsp;
&nbsp;            // check for dfa
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.DFA) {</b>
<b class="nc">&nbsp;                if (entity.canDFA()) {</b>
<b class="nc">&nbsp;                    checkExtremeGravityMovement(entity, step, lastStepMoveType, curPos, cachedGravityLimit);</b>
<b class="nc">&nbsp;                    Targetable target = step.getTarget(game);</b>
&nbsp;                    
&nbsp;                    int targetType;
&nbsp;                    int targetID;
&nbsp;                    
&nbsp;                    // if it&#39;s a valid target, then simply pass along the type and ID
<b class="nc">&nbsp;                    if (target != null) {    </b>
<b class="nc">&nbsp;                        targetID = target.getTargetId();</b>
<b class="nc">&nbsp;                        targetType = target.getTargetType();</b>
&nbsp;                    // if the target has become invalid somehow, or was incorrectly declared in the first place
&nbsp;                    // log the error, then put some defaults in for the DFA and proceed as if the target had been moved/destroyed
&nbsp;                    } else {
<b class="nc">&nbsp;                        String errorMessage = &quot;Illegal DFA by &quot; + entity.getDisplayName() + &quot; against non-existent entity at &quot; + step.getTargetPosition(); </b>
<b class="nc">&nbsp;                        sendServerChat(errorMessage);</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(errorMessage);</b>
<b class="nc">&nbsp;                        targetID = Entity.NONE; </b>
&nbsp;                        // doesn&#39;t really matter, DFA processing will cut out early if target resolves as null
<b class="nc">&nbsp;                        targetType = Targetable.TYPE_ENTITY; </b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    DfaAttackAction daa = new DfaAttackAction(entity.getId(),</b>
&nbsp;                            targetType, targetID,
<b class="nc">&nbsp;                            step.getPosition());</b>
<b class="nc">&nbsp;                    entity.setDisplacementAttack(daa);</b>
<b class="nc">&nbsp;                    entity.setElevation(step.getElevation());</b>
<b class="nc">&nbsp;                    game.addCharge(daa);</b>
<b class="nc">&nbsp;                    charge = daa;</b>
&nbsp;                    
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Illegal DFA!! I don&#39;t think &quot;</b>
<b class="nc">&nbsp;                            + entity.getDisplayName()</b>
&nbsp;                            + &quot; should be allowed to DFA,&quot;
&nbsp;                            + &quot; but the client of &quot;
<b class="nc">&nbsp;                            + entity.getOwner().getName() + &quot; disagrees.&quot;);</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Please make sure &quot;</b>
<b class="nc">&nbsp;                            + entity.getOwner().getName()</b>
&nbsp;                            + &quot; is running MegaMek &quot; + MegaMek.VERSION
&nbsp;                            + &quot;, or if that is already the case, submit a bug report at https://github.com/MegaMek/megamek/issues&quot;);
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;                
&nbsp;                break;
&nbsp;            }
&nbsp;
&nbsp;            // check for ram
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.RAM) {</b>
<b class="nc">&nbsp;                if (entity.canRam()) {</b>
<b class="nc">&nbsp;                    Targetable target = step.getTarget(game);</b>
<b class="nc">&nbsp;                    RamAttackAction raa = new RamAttackAction(entity.getId(),</b>
<b class="nc">&nbsp;                            target.getTargetType(), target.getTargetId(),</b>
<b class="nc">&nbsp;                            target.getPosition());</b>
<b class="nc">&nbsp;                    entity.setRamming(true);</b>
<b class="nc">&nbsp;                    game.addRam(raa);</b>
<b class="nc">&nbsp;                    ram = raa;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Illegal ram!! I don&#39;t think &quot;</b>
<b class="nc">&nbsp;                            + entity.getDisplayName()</b>
&nbsp;                            + &quot; should be allowed to charge,&quot;
&nbsp;                            + &quot; but the client of &quot;
<b class="nc">&nbsp;                            + entity.getOwner().getName() + &quot; disagrees.&quot;);</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Please make sure &quot;</b>
<b class="nc">&nbsp;                            + entity.getOwner().getName()</b>
&nbsp;                            + &quot; is running MegaMek &quot; + MegaMek.VERSION
&nbsp;                            + &quot;, or if that is already the case, submit a bug report at https://github.com/MegaMek/megamek/issues&quot;);
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;                ((IBomber) entity).setVTOLBombTarget(step.getTarget(game));</b>
<b class="nc">&nbsp;            } else if (step.isStrafingStep() &amp;&amp; (entity instanceof VTOL)) {</b>
<b class="nc">&nbsp;                ((VTOL) entity).getStrafingCoords().add(step.getPosition());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.ACC) || (step.getType() == MoveStepType.ACCN)) {</b>
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                    if (step.getType() == MoveStepType.ACCN) {</b>
<b class="nc">&nbsp;                        a.setAccLast(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        a.setAccDecNow(true);</b>
<b class="nc">&nbsp;                        a.setCurrentVelocity(a.getCurrentVelocity() + 1);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    a.setNextVelocity(a.getNextVelocity() + 1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.DEC) || (step.getType() == MoveStepType.DECN)) {</b>
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                    if (step.getType() == MoveStepType.DECN) {</b>
<b class="nc">&nbsp;                        a.setAccLast(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        a.setAccDecNow(true);</b>
<b class="nc">&nbsp;                        a.setCurrentVelocity(a.getCurrentVelocity() - 1);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    a.setNextVelocity(a.getNextVelocity() - 1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.EVADE) {</b>
<b class="nc">&nbsp;                entity.setEvading(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.SHUTDOWN) {</b>
<b class="nc">&nbsp;                entity.performManualShutdown();</b>
<b class="nc">&nbsp;                sendServerChat(entity.getDisplayName() + &quot; has shutdown.&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.STARTUP) {</b>
<b class="nc">&nbsp;                entity.performManualStartup();</b>
<b class="nc">&nbsp;                sendServerChat(entity.getDisplayName() + &quot; has started up.&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.SELF_DESTRUCT) {</b>
<b class="nc">&nbsp;                entity.setSelfDestructing(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.ROLL) {</b>
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                    a.setRolled(!a.isRolled());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check for dig in or fortify
<b class="nc">&nbsp;            if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;                Infantry inf = (Infantry) entity;</b>
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.DIG_IN) {</b>
<b class="nc">&nbsp;                    inf.setDugIn(Infantry.DUG_IN_WORKING);</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                } else if (step.getType() == MoveStepType.FORTIFY) {</b>
<b class="nc">&nbsp;                    if (!entity.hasWorkingMisc(MiscType.F_TOOLS,</b>
&nbsp;                            MiscType.S_VIBROSHOVEL)) {
<b class="nc">&nbsp;                        sendServerChat(entity.getDisplayName()</b>
&nbsp;                                + &quot; failed to fortify because it is missing suitable equipment&quot;);
&nbsp;                    }
<b class="nc">&nbsp;                    inf.setDugIn(Infantry.DUG_IN_FORTIFYING1);</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                } else if ((step.getType() != MoveStepType.TURN_LEFT)</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getType() != MoveStepType.TURN_RIGHT)) {</b>
&nbsp;                    // other movement clears dug in status
<b class="nc">&nbsp;                    inf.setDugIn(Infantry.DUG_IN_NONE);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (step.getType() == MoveStepType.TAKE_COVER) {</b>
<b class="nc">&nbsp;                    if (Infantry.hasValidCover(game, step.getPosition(),</b>
<b class="nc">&nbsp;                            step.getElevation())) {</b>
<b class="nc">&nbsp;                        inf.setTakingCover(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        sendServerChat(entity.getDisplayName()</b>
&nbsp;                                + &quot; failed to take cover: &quot;
&nbsp;                                + &quot;no valid unit found in &quot;
<b class="nc">&nbsp;                                + step.getPosition());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If we have turned, check whether we have fulfilled any turn mode requirements.
<b class="nc">&nbsp;            if ((step.getType() == MoveStepType.TURN_LEFT || step.getType() == MoveStepType.TURN_RIGHT)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.usesTurnMode()) {</b>
<b class="nc">&nbsp;                int straight = 0;</b>
<b class="nc">&nbsp;                if (prevStep != null) {</b>
<b class="nc">&nbsp;                    straight = prevStep.getNStraight();</b>
&nbsp;                }
<b class="nc">&nbsp;                rollTarget = entity.checkTurnModeFailure(overallMoveType, straight,</b>
<b class="nc">&nbsp;                        md.getMpUsed(), step.getPosition());</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    int mof = doSkillCheckWhileMoving(entity, lastElevation, lastPos,</b>
&nbsp;                            curPos, rollTarget, false);
<b class="nc">&nbsp;                    if (mof &gt; 0) {</b>
<b class="nc">&nbsp;                        if (processFailedVehicleManeuver(entity, curPos,</b>
<b class="nc">&nbsp;                                step.getFacing() - curFacing,</b>
<b class="nc">&nbsp;                                (null == prevStep)?step : prevStep,</b>
<b class="nc">&nbsp;                                        step.isThisStepBackwards(),</b>
&nbsp;                                        lastStepMoveType, distance, mof, mof)) {
<b class="nc">&nbsp;                            if (md.hasActiveMASC()) {</b>
<b class="nc">&nbsp;                                mpUsed = entity.getRunMP();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                mpUsed = entity.getRunMPwithoutMASC();</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            turnOver = true;</b>
<b class="nc">&nbsp;                            distance = entity.delta_distance;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            continueTurnFromFishtail = true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                        curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                        entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.BOOTLEGGER) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                entity.addPilotingModifierForTerrain(rollTarget);</b>
<b class="nc">&nbsp;                rollTarget.addModifier(0, &quot;bootlegger maneuver&quot;);</b>
<b class="nc">&nbsp;                int mof = doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                        curPos, curPos, rollTarget, false);
<b class="nc">&nbsp;                if (mof &gt; 0) {</b>
&nbsp;                    // If the bootlegger maneuver fails, we treat it as a turn in a random direction.
<b class="nc">&nbsp;                    processFailedVehicleManeuver(entity, curPos, Compute.d6() &lt; 4 ? -1 : 1,</b>
<b class="nc">&nbsp;                            (null == prevStep)? step : prevStep,</b>
<b class="nc">&nbsp;                            step.isThisStepBackwards(), lastStepMoveType, distance, 2, mof);</b>
<b class="nc">&nbsp;                    curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                    curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // set last step parameters
<b class="nc">&nbsp;            curPos = step.getPosition();</b>
<b class="nc">&nbsp;            if (!((entity.getJumpType() == Mech.JUMP_BOOSTER) &amp;&amp; step.isJumping())) {</b>
<b class="nc">&nbsp;                curFacing = step.getFacing();</b>
&nbsp;            }
&nbsp;            // check if a building PSR will be needed later, before setting the
&nbsp;            // new elevation
<b class="nc">&nbsp;            int buildingMove = entity.checkMovementInBuilding(step, prevStep, curPos, lastPos);</b>
<b class="nc">&nbsp;            curVTOLElevation = step.getElevation();</b>
<b class="nc">&nbsp;            curAltitude = step.getAltitude();</b>
<b class="nc">&nbsp;            curElevation = step.getElevation();</b>
<b class="nc">&nbsp;            curClimbMode = step.climbMode();</b>
&nbsp;            // set elevation in case of collapses
<b class="nc">&nbsp;            entity.setElevation(step.getElevation());</b>
&nbsp;            // set climb mode in case of skid
<b class="nc">&nbsp;            entity.setClimbMode(curClimbMode);</b>
&nbsp;
<b class="nc">&nbsp;            IHex curHex = game.getBoard().getHex(curPos);</b>
&nbsp;
&nbsp;            // when first entering a building, we need to roll what type
&nbsp;            // of basement it has
<b class="nc">&nbsp;            if (isOnGround &amp;&amp; curHex.containsTerrain(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;                Building bldg = game.getBoard().getBuildingAt(curPos);</b>
<b class="nc">&nbsp;                if (bldg.rollBasement(curPos, game.getBoard(), vPhaseReport)) {</b>
<b class="nc">&nbsp;                    sendChangedHex(curPos);</b>
<b class="nc">&nbsp;                    Vector&lt;Building&gt; buildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                    buildings.add(bldg);</b>
<b class="nc">&nbsp;                    sendChangedBuildings(buildings);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check for automatic unstick
<b class="nc">&nbsp;            if (entity.canUnstickByJumping() &amp;&amp; entity.isStuck()</b>
&nbsp;                    &amp;&amp; (moveType == EntityMovementType.MOVE_JUMP)) {
<b class="nc">&nbsp;                entity.setStuck(false);</b>
<b class="nc">&nbsp;                entity.setCanUnstickByJumping(false);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for leap
<b class="nc">&nbsp;            if (!lastPos.equals(curPos)</b>
&nbsp;                    &amp;&amp; (stepMoveType != EntityMovementType.MOVE_JUMP) &amp;&amp; (entity instanceof Mech)
<b class="nc">&nbsp;                    &amp;&amp; !entity.isAirborne() &amp;&amp; (step.getClearance() &lt;= 0)  // Don&#39;t check airborne LAMs</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEAPING)) {</b>
<b class="nc">&nbsp;                int leapDistance = (lastElevation</b>
<b class="nc">&nbsp;                        + game.getBoard().getHex(lastPos).getLevel())</b>
<b class="nc">&nbsp;                        - (curElevation + curHex.getLevel());</b>
<b class="nc">&nbsp;                if (leapDistance &gt; 2) {</b>
&nbsp;                    // skill check for leg damage
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(stepMoveType);</b>
<b class="nc">&nbsp;                    entity.addPilotingModifierForTerrain(rollTarget, curPos);</b>
<b class="nc">&nbsp;                    rollTarget.append(new PilotingRollData(entity.getId(),</b>
&nbsp;                            2 * leapDistance, &quot;leaping (leg damage)&quot;));
<b class="nc">&nbsp;                    if (0 &lt; doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                            lastPos, curPos, rollTarget, false)) {
&nbsp;                        // do leg damage
<b class="nc">&nbsp;                        addReport(damageEntity(entity, new HitData(Mech.LOC_LLEG), leapDistance));</b>
<b class="nc">&nbsp;                        addReport(damageEntity(entity, new HitData(Mech.LOC_RLEG), leapDistance));</b>
<b class="nc">&nbsp;                        addNewLines();</b>
<b class="nc">&nbsp;                        addReport(criticalEntity(entity, Mech.LOC_LLEG, false, 0, 0));</b>
<b class="nc">&nbsp;                        addNewLines();</b>
<b class="nc">&nbsp;                        addReport(criticalEntity(entity, Mech.LOC_RLEG, false, 0, 0));</b>
<b class="nc">&nbsp;                        if (entity instanceof QuadMech) {</b>
<b class="nc">&nbsp;                            addReport(damageEntity(entity, new HitData(Mech.LOC_LARM), leapDistance));</b>
<b class="nc">&nbsp;                            addReport(damageEntity(entity, new HitData(Mech.LOC_RARM), leapDistance));</b>
<b class="nc">&nbsp;                            addNewLines();</b>
<b class="nc">&nbsp;                            addReport(criticalEntity(entity, Mech.LOC_LARM, false, 0, 0));</b>
<b class="nc">&nbsp;                            addNewLines();</b>
<b class="nc">&nbsp;                            addReport(criticalEntity(entity, Mech.LOC_RARM, false, 0, 0));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    // skill check for fall
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(stepMoveType);</b>
<b class="nc">&nbsp;                    entity.addPilotingModifierForTerrain(rollTarget, curPos);</b>
<b class="nc">&nbsp;                    rollTarget.append(new PilotingRollData(entity.getId(),</b>
&nbsp;                            leapDistance, &quot;leaping (fall)&quot;));
<b class="nc">&nbsp;                    if (0 &lt; doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                            lastPos, curPos, rollTarget, false)) {
<b class="nc">&nbsp;                        entity.setElevation(lastElevation);</b>
<b class="nc">&nbsp;                        addReport(doEntityFallsInto(entity, lastElevation,</b>
&nbsp;                                lastPos, curPos,
<b class="nc">&nbsp;                                entity.getBasePilotingRoll(overallMoveType), false));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Check for skid.
<b class="nc">&nbsp;            rollTarget = entity.checkSkid(moveType, prevHex, overallMoveType,</b>
&nbsp;                    prevStep, step, prevFacing, curFacing, lastPos, curPos,
&nbsp;                    isInfantry, distance - 1);
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
&nbsp;                // Have an entity-meaningful PSR message.
&nbsp;                boolean psrFailed;
<b class="nc">&nbsp;                int startingFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                if (entity instanceof Mech) {</b>
&nbsp;                    // We need to ensure that falls will happen from the proper
&nbsp;                    // facing
<b class="nc">&nbsp;                    entity.setFacing(curFacing);</b>
<b class="nc">&nbsp;                    psrFailed = (0 &lt; doSkillCheckWhileMoving(entity,</b>
&nbsp;                            lastElevation, lastPos, lastPos, rollTarget, true));
&nbsp;                } else {
<b class="nc">&nbsp;                    psrFailed = (0 &lt; doSkillCheckWhileMoving(entity,</b>
&nbsp;                            lastElevation, lastPos, lastPos, rollTarget, false));
&nbsp;                }
&nbsp;
&nbsp;                // Does the entity skid?
<b class="nc">&nbsp;                if (psrFailed) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                        addReport(vehicleMotiveDamage((Tank)entity, 0));</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    curPos = lastPos;</b>
<b class="nc">&nbsp;                    int skidDistance = (int) Math.round((double) (distance - 1) / 2);</b>
<b class="nc">&nbsp;                    int skidDirection = prevFacing;</b>
&nbsp;
&nbsp;                    // All charge damage is based upon
&nbsp;                    // the pre-skid move distance.
<b class="nc">&nbsp;                    entity.delta_distance = distance - 1;</b>
&nbsp;
&nbsp;                    // Attacks against a skidding target have additional +2.
<b class="nc">&nbsp;                    moveType = EntityMovementType.MOVE_SKID;</b>
&nbsp;
&nbsp;                    // What is the first hex in the skid?
<b class="nc">&nbsp;                    if (step.isThisStepBackwards()) {</b>
<b class="nc">&nbsp;                        skidDirection = (skidDirection + 3) % 6;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (processSkid(entity, curPos, prevStep.getElevation(),</b>
&nbsp;                            skidDirection, skidDistance, prevStep,
&nbsp;                            lastStepMoveType)) {
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // set entity parameters
<b class="nc">&nbsp;                    curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                    curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                    entity.setSecondaryFacing(curFacing);</b>
&nbsp;
&nbsp;                    // skid consumes all movement
<b class="nc">&nbsp;                    if (md.hasActiveMASC()) {</b>
<b class="nc">&nbsp;                        mpUsed = entity.getRunMP();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        mpUsed = entity.getRunMPwithoutMASC();</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    entity.moved = moveType;</b>
<b class="nc">&nbsp;                    fellDuringMovement = true;</b>
<b class="nc">&nbsp;                    turnOver = true;</b>
<b class="nc">&nbsp;                    distance = entity.delta_distance;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;
&nbsp;                } else { // End failed-skid-psr
&nbsp;                    // If the check succeeded, restore the facing we had before
&nbsp;                    // if it failed, the fall will have changed facing
<b class="nc">&nbsp;                    entity.setFacing(startingFacing);</b>
&nbsp;                }
&nbsp;
&nbsp;            } // End need-skid-psr
&nbsp;
&nbsp;            // check sideslip
<b class="nc">&nbsp;            if ((entity instanceof VTOL)</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                            &amp;&amp; step.getClearance() &gt; 0)) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkSideSlip(moveType, prevHex,</b>
&nbsp;                        overallMoveType, prevStep, prevFacing, curFacing,
&nbsp;                        lastPos, curPos, distance);
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    int moF = doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                            lastPos, curPos, rollTarget, false);
<b class="nc">&nbsp;                    if (moF &gt; 0) {</b>
&nbsp;                        int elev;
&nbsp;                        int sideslipDistance;
&nbsp;                        int skidDirection;
&nbsp;                        Coords start;
<b class="nc">&nbsp;                        if (step.getType() == MoveStepType.LATERAL_LEFT</b>
<b class="nc">&nbsp;                                || step.getType() == MoveStepType.LATERAL_RIGHT</b>
<b class="nc">&nbsp;                                || step.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</b>
<b class="nc">&nbsp;                                || step.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS) {</b>
&nbsp;                            // A failed controlled sideslip always results in moving one additional hex
&nbsp;                            // in the direction of the intentional sideslip.
<b class="nc">&nbsp;                            elev = step.getElevation();</b>
<b class="nc">&nbsp;                            sideslipDistance = 1;</b>
<b class="nc">&nbsp;                            skidDirection = lastPos.direction(curPos);</b>
<b class="nc">&nbsp;                            start = curPos;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            elev = (null == prevStep)? curElevation : prevStep.getElevation();</b>
&nbsp;                            // maximum distance is hexes moved / 2
<b class="nc">&nbsp;                            sideslipDistance = Math.min(moF, distance / 2);</b>
<b class="nc">&nbsp;                            skidDirection = prevFacing;</b>
<b class="nc">&nbsp;                            start = lastPos;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (sideslipDistance &gt; 0) {</b>
<b class="nc">&nbsp;                            sideslipped = true;</b>
<b class="nc">&nbsp;                            r = new Report(2100);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.add(sideslipDistance);</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                            if (processSkid(entity, start, elev, skidDirection,</b>
<b class="nc">&nbsp;                                    sideslipDistance, (null == prevStep)? step : prevStep,</b>
&nbsp;                                    lastStepMoveType)) {
<b class="nc">&nbsp;                                return;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            if (!entity.isDestroyed() &amp;&amp; !entity.isDoomed()</b>
<b class="nc">&nbsp;                                    &amp;&amp; (mpUsed &lt; entity.getRunMP())) {</b>
<b class="nc">&nbsp;                                fellDuringMovement = true; // No, but it should</b>
&nbsp;                                // work...
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            if ((entity.getElevation() == 0)</b>
<b class="nc">&nbsp;                                    &amp;&amp; ((entity.getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                                        || (entity.getMovementMode() == EntityMovementMode.WIGE))) {</b>
<b class="nc">&nbsp;                                turnOver = true;</b>
&nbsp;                            }
&nbsp;                            // set entity parameters
<b class="nc">&nbsp;                            curFacing = step.getFacing();</b>
<b class="nc">&nbsp;                            curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                            entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check if we&#39;ve moved into rubble
<b class="nc">&nbsp;            boolean isLastStep = step.equals(md.getLastStep());</b>
<b class="nc">&nbsp;            rollTarget = entity.checkRubbleMove(step, overallMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, isLastStep, isPavementStep);
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                doSkillCheckWhileMoving(entity, lastElevation, lastPos, curPos,</b>
&nbsp;                        rollTarget, true);
&nbsp;            }
&nbsp;
&nbsp;            // check if we are using reckless movement
<b class="nc">&nbsp;            rollTarget = entity.checkRecklessMove(step, overallMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, prevHex);
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                    doSkillCheckWhileMoving(entity, lastElevation, lastPos,</b>
&nbsp;                            curPos, rollTarget, true);
<b class="nc">&nbsp;                } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                    if (0 &lt; doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                            lastPos, curPos, rollTarget, false)) {
&nbsp;                        // assume VTOLs in flight are always in clear terrain
<b class="nc">&nbsp;                        if ((0 == curHex.terrainsPresent())</b>
<b class="nc">&nbsp;                                || (step.getClearance() &gt; 0)) {</b>
<b class="nc">&nbsp;                            if (entity instanceof VTOL) {</b>
<b class="nc">&nbsp;                                r = new Report(2208);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                r = new Report(2206);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            mpUsed = step.getMpUsed() + 1;</b>
<b class="nc">&nbsp;                            fellDuringMovement = true;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        r = new Report(2207);</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                        // until we get a rules clarification assume that the
&nbsp;                        // entity is both giver and taker
&nbsp;                        // for charge damage
<b class="nc">&nbsp;                        HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                        addReport(damageEntity(entity, hit, ChargeAttackAction</b>
<b class="nc">&nbsp;                                .getDamageTakenBy(entity, entity)));</b>
<b class="nc">&nbsp;                        turnOver = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check for breaking magma crust unless we are jumping over the hex
<b class="nc">&nbsp;            if (stepMoveType != EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;                ServerHelper.checkAndApplyMagmaCrust(curHex, step.getElevation(), entity, curPos, false, vPhaseReport, this);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check if we&#39;ve moved into a swamp
<b class="nc">&nbsp;            rollTarget = entity.checkBogDown(step, lastStepMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, lastElevation, isPavementStep);
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                if (0 &lt; doSkillCheckWhileMoving(entity, lastElevation, lastPos,</b>
&nbsp;                        curPos, rollTarget, false)) {
<b class="nc">&nbsp;                    entity.setStuck(true);</b>
<b class="nc">&nbsp;                    entity.setCanUnstickByJumping(true);</b>
<b class="nc">&nbsp;                    r = new Report(2081);</b>
<b class="nc">&nbsp;                    r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // check for quicksand
<b class="nc">&nbsp;                    addReport(checkQuickSand(curPos));</b>
&nbsp;                    // check for accidental stacking violation
<b class="nc">&nbsp;                    Entity violation = Compute.stackingViolation(game,</b>
<b class="nc">&nbsp;                            entity.getId(), curPos);</b>
<b class="nc">&nbsp;                    if (violation != null) {</b>
&nbsp;                        // target gets displaced, because of low elevation
<b class="nc">&nbsp;                        int direction = lastPos.direction(curPos);</b>
<b class="nc">&nbsp;                        Coords targetDest = Compute.getValidDisplacement(game,</b>
<b class="nc">&nbsp;                                entity.getId(), curPos, direction);</b>
<b class="nc">&nbsp;                        addReport(doEntityDisplacement(violation, curPos,</b>
&nbsp;                                targetDest,
<b class="nc">&nbsp;                                new PilotingRollData(violation.getId(), 0,</b>
&nbsp;                                        &quot;domino effect&quot;)));
&nbsp;                        // Update the violating entity&#39;s position on the client.
<b class="nc">&nbsp;                        entityUpdate(violation.getId());</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    break;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check to see if we are a mech and we&#39;ve moved OUT of fire
<b class="nc">&nbsp;            IHex lastHex = game.getBoard().getHex(lastPos);</b>
<b class="nc">&nbsp;            if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                if (!lastPos.equals(curPos) &amp;&amp; (prevStep != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((lastHex.containsTerrain(Terrains.FIRE)</b>
<b class="nc">&nbsp;                                &amp;&amp; (prevStep.getElevation() &lt;= 1))</b>
<b class="nc">&nbsp;                                || (lastHex.containsTerrain(Terrains.MAGMA)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (prevStep.getElevation() == 0)))</b>
&nbsp;                        &amp;&amp; ((stepMoveType != EntityMovementType.MOVE_JUMP)
&nbsp;                                // Bug #828741 -- jumping bypasses fire, but not
&nbsp;                                // on the
&nbsp;                                // first step
&nbsp;                                // getMpUsed -- total MP used to this step
&nbsp;                                // getMp -- MP used in this step
&nbsp;                                // the difference will always be 0 on the &quot;first
&nbsp;                                // step&quot;
&nbsp;                                // of a jump,
&nbsp;                                // and &gt;0 on a step in the midst of a jump
<b class="nc">&nbsp;                                || (0 == (step.getMpUsed() - step.getMp())))) {</b>
<b class="nc">&nbsp;                    int heat = 0;</b>
<b class="nc">&nbsp;                    if (lastHex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;                        heat += 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (lastHex.terrainLevel(Terrains.MAGMA) == 1) {</b>
<b class="nc">&nbsp;                        heat += 2;</b>
<b class="nc">&nbsp;                    } else if (lastHex.terrainLevel(Terrains.MAGMA) == 2) {</b>
<b class="nc">&nbsp;                        heat += 5;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        heat /= 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    entity.heatFromExternal += heat;</b>
<b class="nc">&nbsp;                    r = new Report(2115);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(heat);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        r = new Report(5550);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check to see if we are not a mech and we&#39;ve moved INTO fire
<b class="nc">&nbsp;            if (!(entity instanceof Mech)) {</b>
<b class="nc">&nbsp;                boolean underwater = game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                        .containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                        &amp;&amp; (game.getBoard().getHex(curPos).depth() &gt; 0)</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getElevation() &lt; game.getBoard().getHex(curPos).surface());</b>
<b class="nc">&nbsp;                if (game.getBoard().getHex(curPos).containsTerrain(</b>
<b class="nc">&nbsp;                        Terrains.FIRE) &amp;&amp; !lastPos.equals(curPos)</b>
&nbsp;                        &amp;&amp; (stepMoveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                        &amp;&amp; (step.getElevation() &lt;= 1) &amp;&amp; !underwater) {</b>
<b class="nc">&nbsp;                    doFlamingDamage(entity);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // check for extreme gravity movement
<b class="nc">&nbsp;            if (!i.hasMoreElements() &amp;&amp; !firstStep) {</b>
<b class="nc">&nbsp;                checkExtremeGravityMovement(entity, step, lastStepMoveType, curPos, cachedGravityLimit);</b>
&nbsp;            }
&nbsp;            // check for minefields. have to check both new hex and new
&nbsp;            // elevation
&nbsp;            // VTOLs may land and submarines may rise or lower into a minefield
<b class="nc">&nbsp;            if (!lastPos.equals(curPos) || (lastElevation != curElevation)) {</b>
<b class="nc">&nbsp;                boolean boom = false;</b>
<b class="nc">&nbsp;                if (isOnGround) {</b>
<b class="nc">&nbsp;                    boom = checkVibrabombs(entity, curPos, false, lastPos, curPos, vPhaseReport);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (game.containsMinefield(curPos)) {</b>
&nbsp;                    // set the new position temporarily, because
&nbsp;                    // infantry otherwise would get double damage
&nbsp;                    // when moving from clear into mined woods
<b class="nc">&nbsp;                    entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                    if (enterMinefield(entity, curPos, step.getElevation(),</b>
&nbsp;                            isOnGround, vPhaseReport)) {
&nbsp;                        // resolve any piloting rolls from damage unless unit
&nbsp;                        // was jumping
<b class="nc">&nbsp;                        if (stepMoveType != EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;                            addReport(resolvePilotingRolls(entity));</b>
<b class="nc">&nbsp;                            game.resetPSRs(entity);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        boom = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (wasProne || !entity.isProne()) {</b>
<b class="nc">&nbsp;                        entity.setPosition(lastPos);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // did anything go boom?
<b class="nc">&nbsp;                if (boom) {</b>
&nbsp;                    // set fell during movement so that entity will get another
&nbsp;                    // chance to move with any motive damage
&nbsp;                    // taken account of (functions the same as MASC failure)
&nbsp;                    // only do this if they had more steps (and they were not
&nbsp;                    // jumping
<b class="nc">&nbsp;                    if (i.hasMoreElements() &amp;&amp; (stepMoveType != EntityMovementType.MOVE_JUMP)) {</b>
<b class="nc">&nbsp;                        md.clear();</b>
<b class="nc">&nbsp;                        fellDuringMovement = true;</b>
&nbsp;                    }
&nbsp;                    // reset mines if anything detonated
<b class="nc">&nbsp;                    resetMines();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // infantry discovers minefields if they end their move
&nbsp;            // in a minefield.
<b class="nc">&nbsp;            if (!lastPos.equals(curPos) &amp;&amp; !i.hasMoreElements() &amp;&amp; isInfantry) {</b>
<b class="nc">&nbsp;                if (game.containsMinefield(curPos)) {</b>
<b class="nc">&nbsp;                    IPlayer owner = entity.getOwner();</b>
<b class="nc">&nbsp;                    for (Minefield mf : game.getMinefields(curPos)) {</b>
<b class="nc">&nbsp;                        if (!owner.containsMinefield(mf)) {</b>
<b class="nc">&nbsp;                            r = new Report(2120);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            revealMinefield(game.getTeamForPlayer(owner), mf);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check if we&#39;ve moved into water
<b class="nc">&nbsp;            rollTarget = entity.checkWaterMove(step, lastStepMoveType, curHex,</b>
&nbsp;                    lastPos, curPos, isPavementStep);
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
&nbsp;                // Swarmers need special handling.
<b class="nc">&nbsp;                final int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;                boolean swarmerDone = true;</b>
<b class="nc">&nbsp;                Entity swarmer = null;</b>
<b class="nc">&nbsp;                if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;                    swarmer = game.getEntity(swarmerId);</b>
<b class="nc">&nbsp;                    swarmerDone = swarmer.isDone();</b>
&nbsp;                }
&nbsp;
&nbsp;                // Now do the skill check.
<b class="nc">&nbsp;                entity.setFacing(curFacing);</b>
<b class="nc">&nbsp;                doSkillCheckWhileMoving(entity, lastElevation, lastPos, curPos, rollTarget, true);</b>
&nbsp;
&nbsp;                // Swarming infantry platoons may drown.
<b class="nc">&nbsp;                if (curHex.terrainLevel(Terrains.WATER) &gt; 1) {</b>
<b class="nc">&nbsp;                    drownSwarmer(entity, curPos);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Do we need to remove a game turn for the swarmer
<b class="nc">&nbsp;                if (!swarmerDone &amp;&amp; (swarmer != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (swarmer.isDoomed() || swarmer.isDestroyed())) {</b>
&nbsp;                    // We have to diddle with the swarmer&#39;s
&nbsp;                    // status to get its turn removed.
<b class="nc">&nbsp;                    swarmer.setDone(false);</b>
<b class="nc">&nbsp;                    swarmer.setUnloaded(false);</b>
&nbsp;
&nbsp;                    // Dead entities don&#39;t take turns.
<b class="nc">&nbsp;                    game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
&nbsp;
&nbsp;                    // Return the original status.
<b class="nc">&nbsp;                    swarmer.setDone(true);</b>
<b class="nc">&nbsp;                    swarmer.setUnloaded(true);</b>
&nbsp;                }
&nbsp;
&nbsp;                // check for inferno wash-off
<b class="nc">&nbsp;                checkForWashedInfernos(entity, curPos);</b>
&nbsp;            }
&nbsp;
&nbsp;            // In water, may or may not be a new hex, necessary to
&nbsp;            // check during movement, for breach damage, and always
&nbsp;            // set dry if appropriate
&nbsp;            // TODO : possibly make the locations local and set later
<b class="nc">&nbsp;            addReport(doSetLocationsExposure(entity, curHex,</b>
&nbsp;                    stepMoveType == EntityMovementType.MOVE_JUMP,
<b class="nc">&nbsp;                    step.getElevation()));</b>
&nbsp;
&nbsp;            // check for breaking ice by breaking through from below
<b class="nc">&nbsp;            if ((lastElevation &lt; 0) &amp;&amp; (step.getElevation() == 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; lastHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;                    &amp;&amp; lastHex.containsTerrain(Terrains.WATER)</b>
&nbsp;                    &amp;&amp; (stepMoveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                    &amp;&amp; !lastPos.equals(curPos)) {</b>
&nbsp;                // need to temporarily reset entity&#39;s position so it doesn&#39;t
&nbsp;                // fall in the ice
<b class="nc">&nbsp;                entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                r = new Report(2410);</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(resolveIceBroken(lastPos));</b>
&nbsp;                // ok now set back
<b class="nc">&nbsp;                entity.setPosition(lastPos);</b>
&nbsp;            }
&nbsp;            // check for breaking ice by stepping on it
<b class="nc">&nbsp;            if (curHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;                    &amp;&amp; curHex.containsTerrain(Terrains.WATER)</b>
&nbsp;                    &amp;&amp; (stepMoveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                    &amp;&amp; !lastPos.equals(curPos) &amp;&amp; !(entity instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(isPavementStep &amp;&amp; curHex.containsTerrain(Terrains.BRIDGE))) {</b>
<b class="nc">&nbsp;                if (step.getElevation() == 0) {</b>
<b class="nc">&nbsp;                    int roll = Compute.d6(1);</b>
<b class="nc">&nbsp;                    r = new Report(2118);</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    if (roll == 6) {</b>
<b class="nc">&nbsp;                        entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                        addReport(resolveIceBroken(curPos));</b>
<b class="nc">&nbsp;                        curPos = entity.getPosition();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // or intersecting it
<b class="nc">&nbsp;                else if ((step.getElevation() + entity.height()) == 0) {</b>
<b class="nc">&nbsp;                    r = new Report(2410);</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addReport(resolveIceBroken(curPos));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Handle loading units.
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.LOAD) {</b>
&nbsp;
&nbsp;                // Find the unit being loaded.
<b class="nc">&nbsp;                Entity loaded = null;</b>
<b class="nc">&nbsp;                Iterator&lt;Entity&gt; entities = game.getEntities(curPos);</b>
<b class="nc">&nbsp;                while (entities.hasNext()) {</b>
&nbsp;
&nbsp;                    // Is the other unit friendly and not the current entity?
<b class="nc">&nbsp;                    loaded = entities.next();</b>
&nbsp;
&nbsp;                    // This should never ever happen, but just in case...
<b class="nc">&nbsp;                    if (loaded.equals(null)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (!entity.isEnemyOf(loaded) &amp;&amp; !entity.equals(loaded)) {</b>
&nbsp;                        // The moving unit should be able to load the other
&nbsp;                        // unit and the other should be able to have a turn.
<b class="nc">&nbsp;                        if (!entity.canLoad(loaded) || !loaded.isLoadableThisTurn()) {</b>
&nbsp;                            // Something is fishy in Denmark.
<b class="nc">&nbsp;                            MegaMek.getLogger().error(entity.getShortName() + &quot; can not load &quot; + loaded.getShortName());</b>
<b class="nc">&nbsp;                            loaded = null;</b>
&nbsp;                        } else {
&nbsp;                            // Have the deployed unit load the indicated unit.
<b class="nc">&nbsp;                            loadUnit(entity, loaded, loaded.getTargetBay());</b>
&nbsp;
&nbsp;                            // Stop looking.
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;
&nbsp;                    } else {
&nbsp;                        // Nope. Discard it.
<b class="nc">&nbsp;                        loaded = null;</b>
&nbsp;                    }
&nbsp;
&nbsp;                } // Handle the next entity in this hex.
&nbsp;
&nbsp;                // We were supposed to find someone to load.
<b class="nc">&nbsp;                if (loaded == null) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Could not find unit for &quot; + entity.getShortName() + &quot; to load in &quot; + curPos);</b>
&nbsp;                }
&nbsp;
&nbsp;            } // End STEP_LOAD
&nbsp;
&nbsp;         // Handle towing units.
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.TOW) {</b>
&nbsp;
&nbsp;                // Find the unit being loaded.
&nbsp;                Entity loaded;
<b class="nc">&nbsp;                loaded = game.getEntity(entity.getTowing());</b>
&nbsp;
&nbsp;                // This should never ever happen, but just in case...
<b class="nc">&nbsp;                if (loaded == null) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Could not find unit for &quot; + entity.getShortName() + &quot; to tow.&quot;);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // The moving unit should be able to tow the other
&nbsp;                // unit and the other should be able to have a turn.
&nbsp;                //FIXME: I know this check duplicates functions already performed when enabling the Tow button.
&nbsp;                //This code made more sense as borrowed from &quot;Load&quot; where we actually rechecked the hex for the target unit.
&nbsp;                //Do we need it here for safety, client/server sync or can this be further streamlined?
<b class="nc">&nbsp;                if (!entity.canTow(loaded.getId())) {</b>
&nbsp;                    // Something is fishy in Denmark.
<b class="nc">&nbsp;                    MegaMek.getLogger().error(entity.getShortName() + &quot; can not tow &quot; + loaded.getShortName());</b>
&nbsp;                } else {
&nbsp;                    // Have the deployed unit load the indicated unit.
<b class="nc">&nbsp;                    towUnit(entity, loaded);</b>
&nbsp;                }
&nbsp;            } // End STEP_TOW
&nbsp;
&nbsp;            // Handle mounting units to small craft/DropShip
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.MOUNT) {</b>
<b class="nc">&nbsp;                Targetable mountee = step.getTarget(game);</b>
<b class="nc">&nbsp;                if (mountee instanceof Entity) {</b>
<b class="nc">&nbsp;                    Entity dropShip = (Entity) mountee;</b>
<b class="nc">&nbsp;                    if (!dropShip.canLoad(entity)) {</b>
&nbsp;                        // Something is fishy in Denmark.
<b class="nc">&nbsp;                        MegaMek.getLogger().error(dropShip.getShortName() + &quot; can not load &quot; + entity.getShortName());</b>
&nbsp;                    } else {
&nbsp;                        // Have the indicated unit load this unit.
<b class="nc">&nbsp;                        entity.setDone(true);</b>
<b class="nc">&nbsp;                        loadUnit(dropShip, entity, entity.getTargetBay());</b>
<b class="nc">&nbsp;                        Bay currentBay = dropShip.getBay(entity);</b>
<b class="nc">&nbsp;                        if ((null != currentBay) &amp;&amp; (Compute.d6(2) == 2)) {</b>
<b class="nc">&nbsp;                            r = new Report(9390);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.indent(1);</b>
<b class="nc">&nbsp;                            r.add(currentBay.getType());</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            currentBay.destroyDoorNext();</b>
&nbsp;                        }
&nbsp;                        // Stop looking.
<b class="nc">&nbsp;                        entityUpdate(dropShip.getId());</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } // End STEP_MOUNT
&nbsp;
&nbsp;            // handle fighter recovery, and also DropShip docking with another large craft
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.RECOVER) {</b>
&nbsp;
<b class="nc">&nbsp;                loader = game.getEntity(step.getRecoveryUnit());</b>
<b class="nc">&nbsp;                boolean isDS = (entity instanceof Dropship);</b>
&nbsp;
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
<b class="nc">&nbsp;                if (loader.mpUsed &gt; 0) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(5, &quot;carrier used thrust&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity.getPartialRepairs().booleanOption(&quot;aero_collar_crit&quot;)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(2, &quot;misrepaired docking collar&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (isDS &amp;&amp; (((Dropship)entity).getCollarType() == Dropship.COLLAR_PROTOTYPE)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(2, &quot;prototype kf-boom&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                int ctrlroll = Compute.d6(2);</b>
<b class="nc">&nbsp;                if (isDS) {</b>
<b class="nc">&nbsp;                    r = new Report(9388);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(9381);</b>
&nbsp;                }
&nbsp;                //TODO : This doesn&#39;t currently break out the modifiers and should...
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                r.add(loader.getDisplayName());</b>
<b class="nc">&nbsp;                r.add(rollTarget.getValue());</b>
<b class="nc">&nbsp;                r.add(ctrlroll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                if (ctrlroll &lt; rollTarget.getValue()) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // damage unit
<b class="nc">&nbsp;                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, hit, 2 * (rollTarget.getValue() - ctrlroll)));</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    recovered = true;</b>
&nbsp;                }
&nbsp;                // check for door damage
<b class="nc">&nbsp;                if (ctrlroll == 2) {</b>
<b class="nc">&nbsp;                    loader.damageDoorRecovery(entity);</b>
<b class="nc">&nbsp;                    r = new Report(9384);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(0);</b>
<b class="nc">&nbsp;                    r.add(loader.getDisplayName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // handle fighter squadron joining
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.JOIN) {</b>
<b class="nc">&nbsp;                loader = game.getEntity(step.getRecoveryUnit());</b>
<b class="nc">&nbsp;                recovered = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Handle unloading units.
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.UNLOAD) {</b>
<b class="nc">&nbsp;                Targetable unloaded = step.getTarget(game);</b>
<b class="nc">&nbsp;                Coords unloadPos = curPos;</b>
<b class="nc">&nbsp;                int unloadFacing = curFacing;</b>
<b class="nc">&nbsp;                if (null != step.getTargetPosition()) {</b>
<b class="nc">&nbsp;                    unloadPos = step.getTargetPosition();</b>
<b class="nc">&nbsp;                    unloadFacing = curPos.direction(unloadPos);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!unloadUnit(entity, unloaded, unloadPos, unloadFacing,</b>
<b class="nc">&nbsp;                        step.getElevation())) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Server was told to unload &quot;</b>
<b class="nc">&nbsp;                                    + unloaded.getDisplayName() + &quot; from &quot;</b>
<b class="nc">&nbsp;                                    + entity.getDisplayName() + &quot; into &quot;</b>
<b class="nc">&nbsp;                                    + curPos.getBoardNum());</b>
&nbsp;                }
&nbsp;                // some additional stuff to take care of for small
&nbsp;                // craft/DropShip unloading
<b class="nc">&nbsp;                if ((entity instanceof SmallCraft) &amp;&amp; (unloaded instanceof Entity)) {</b>
<b class="nc">&nbsp;                    Bay currentBay = entity.getBay((Entity) unloaded);</b>
<b class="nc">&nbsp;                    if ((null != currentBay) &amp;&amp; (Compute.d6(2) == 2)) {</b>
<b class="nc">&nbsp;                        r = new Report(9390);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.indent(1);</b>
<b class="nc">&nbsp;                        r.add(currentBay.getType());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        currentBay.destroyDoorNext();</b>
&nbsp;                    }
&nbsp;                    // now apply any damage to bay doors
<b class="nc">&nbsp;                    entity.resetBayDoors();</b>
<b class="nc">&nbsp;                    entityUpdate(entity.getId());</b>
&nbsp;                    // ok now add another turn for the transport so it can
&nbsp;                    // continue to unload units
<b class="nc">&nbsp;                    if (entity.getUnitsUnloadableFromBays().size() &gt; 0) {</b>
<b class="nc">&nbsp;                        dropshipStillUnloading = true;</b>
<b class="nc">&nbsp;                        GameTurn newTurn = new GameTurn.SpecificEntityTurn(</b>
<b class="nc">&nbsp;                                entity.getOwner().getId(), entity.getId());</b>
&nbsp;                        // Need to set the new turn&#39;s multiTurn state
<b class="nc">&nbsp;                        newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                        game.insertNextTurn(newTurn);</b>
&nbsp;                    }
&nbsp;                    // ok add another turn for the unloaded entity so that it
&nbsp;                    // can move
<b class="nc">&nbsp;                    if (!(unloaded instanceof Infantry)) {</b>
<b class="nc">&nbsp;                        GameTurn newTurn = new GameTurn.SpecificEntityTurn(</b>
<b class="nc">&nbsp;                                ((Entity) unloaded).getOwner().getId(),</b>
<b class="nc">&nbsp;                                ((Entity) unloaded).getId());</b>
&nbsp;                        // Need to set the new turn&#39;s multiTurn state
<b class="nc">&nbsp;                        newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;                        game.insertNextTurn(newTurn);</b>
&nbsp;                    }
&nbsp;                    // brief everybody on the turn update
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Handle disconnecting trailers.
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.DISCONNECT) {</b>
<b class="nc">&nbsp;                Targetable unloaded = step.getTarget(game);</b>
<b class="nc">&nbsp;                Coords unloadPos = curPos;</b>
<b class="nc">&nbsp;                if (null != step.getTargetPosition()) {</b>
<b class="nc">&nbsp;                    unloadPos = step.getTargetPosition();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!disconnectUnit(entity, unloaded, unloadPos)) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Server was told to disconnect &quot;</b>
<b class="nc">&nbsp;                                    + unloaded.getDisplayName() + &quot; from &quot;</b>
<b class="nc">&nbsp;                                    + entity.getDisplayName() + &quot; into &quot;</b>
<b class="nc">&nbsp;                                    + curPos.getBoardNum());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // moving backwards over elevation change
<b class="nc">&nbsp;            if (((step.getType() == MoveStepType.BACKWARDS)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS)</b>
<b class="nc">&nbsp;                    || (step.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS))</b>
<b class="nc">&nbsp;                    &amp;&amp; !(md.isJumping()</b>
<b class="nc">&nbsp;                            &amp;&amp; (entity.getJumpType() == Mech.JUMP_BOOSTER))</b>
<b class="nc">&nbsp;                    &amp;&amp; (lastHex.getLevel() + lastElevation != curHex.getLevel() + step.getElevation())</b>
&nbsp;                    &amp;&amp; !(entity instanceof VTOL)
&nbsp;                    &amp;&amp; !(curClimbMode
<b class="nc">&nbsp;                            &amp;&amp; curHex.containsTerrain(Terrains.BRIDGE)</b>
<b class="nc">&nbsp;                            &amp;&amp; ((curHex.terrainLevel(Terrains.BRIDGE_ELEV)</b>
<b class="nc">&nbsp;                                    + curHex.getLevel()) == (prevHex.getLevel()</b>
<b class="nc">&nbsp;                                            + (prevHex.containsTerrain(</b>
&nbsp;                                                    Terrains.BRIDGE)
&nbsp;                                                            ? prevHex
<b class="nc">&nbsp;                                                                    .terrainLevel(</b>
&nbsp;                                                                            Terrains.BRIDGE_ELEV)
<b class="nc">&nbsp;                                                            : 0))))) {</b>
&nbsp;
&nbsp;                // per TacOps, if the mech is walking backwards over an elevation change and falls
&nbsp;                // it falls into the lower hex. The caveat is if it already fell from some other PSR in this 
&nbsp;                // invocation of processMovement, then it can&#39;t fall again. 
<b class="nc">&nbsp;                if ((entity instanceof Mech) &amp;&amp; (curHex.getLevel() &lt; game</b>
<b class="nc">&nbsp;                        .getBoard().getHex(lastPos).getLevel()) &amp;&amp; !entity.hasFallen()) {</b>
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(0,</b>
&nbsp;                            &quot;moving backwards over an elevation change&quot;);
<b class="nc">&nbsp;                    doSkillCheckWhileMoving(entity, entity.getElevation(),</b>
&nbsp;                            curPos, curPos, rollTarget, true);
<b class="nc">&nbsp;                } else if ((entity instanceof Mech) &amp;&amp; !entity.hasFallen()) {</b>
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(0,</b>
&nbsp;                            &quot;moving backwards over an elevation change&quot;);
<b class="nc">&nbsp;                    doSkillCheckWhileMoving(entity, lastElevation, lastPos,</b>
&nbsp;                            lastPos, rollTarget, true);
<b class="nc">&nbsp;                } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                    rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(0,</b>
&nbsp;                            &quot;moving backwards over an elevation change&quot;);
<b class="nc">&nbsp;                    if (doSkillCheckWhileMoving(entity, entity.getElevation(),</b>
&nbsp;                            curPos, lastPos, rollTarget, false) &lt; 0) {
<b class="nc">&nbsp;                        curPos = lastPos;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // Handle non-infantry moving into a building.
<b class="nc">&nbsp;            if (buildingMove &gt; 0) {</b>
&nbsp;
&nbsp;                // Get the building being exited.
<b class="nc">&nbsp;                Building bldgExited = null;</b>
<b class="nc">&nbsp;                if ((buildingMove &amp; 1) == 1) {</b>
<b class="nc">&nbsp;                    bldgExited = game.getBoard().getBuildingAt(lastPos);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Get the building being entered.
<b class="nc">&nbsp;                Building bldgEntered = null;</b>
<b class="nc">&nbsp;                if ((buildingMove &amp; 2) == 2) {</b>
<b class="nc">&nbsp;                    bldgEntered = game.getBoard().getBuildingAt(curPos);</b>
&nbsp;                }
&nbsp;
&nbsp;                // ProtoMechs changing levels within a building cause damage
<b class="nc">&nbsp;                if (((buildingMove &amp; 8) == 8) &amp;&amp; (entity instanceof Protomech)) {</b>
<b class="nc">&nbsp;                    Building bldg = game.getBoard().getBuildingAt(curPos);</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; vBuildingReport = damageBuilding(bldg, 1, curPos);</b>
<b class="nc">&nbsp;                    for (Report report : vBuildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = entity.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(vBuildingReport);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                boolean collapsed = false;</b>
<b class="nc">&nbsp;                if ((bldgEntered != null)) {</b>
&nbsp;                    // If we&#39;re not leaving a building, just handle the
&nbsp;                    // &quot;entered&quot;.
&nbsp;                    String reason;
<b class="nc">&nbsp;                    if (bldgExited == null) {</b>
<b class="nc">&nbsp;                        reason = &quot;entering&quot;;</b>
&nbsp;                    }
&nbsp;                    // If we&#39;re moving within the same building, just handle
&nbsp;                    // the &quot;within&quot;.
<b class="nc">&nbsp;                    else if (bldgExited.equals(bldgEntered)</b>
&nbsp;                            &amp;&amp; !(entity instanceof Protomech)
&nbsp;                            &amp;&amp; !(entity instanceof Infantry)) {
<b class="nc">&nbsp;                        reason = &quot;moving in&quot;;</b>
&nbsp;                    }
&nbsp;                    // If we have different buildings, roll for each.
&nbsp;                    else {
<b class="nc">&nbsp;                        reason = &quot;entering&quot;;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    passBuildingWall(entity, bldgEntered, lastPos, curPos,</b>
<b class="nc">&nbsp;                            distance, reason, step.isThisStepBackwards(),</b>
&nbsp;                            lastStepMoveType, true);
<b class="nc">&nbsp;                    addAffectedBldg(bldgEntered, collapsed);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Clean up the entity if it has been destroyed.
<b class="nc">&nbsp;                if (entity.isDoomed()) {</b>
<b class="nc">&nbsp;                    entity.setDestroyed(true);</b>
<b class="nc">&nbsp;                    game.moveToGraveyard(entity.getId());</b>
<b class="nc">&nbsp;                    send(createRemoveEntityPacket(entity.getId()));</b>
&nbsp;
&nbsp;                    // The entity&#39;s movement is completed.
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
&nbsp;                // TODO : what if a building collapses into rubble?
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (stepMoveType != EntityMovementType.MOVE_JUMP</b>
<b class="nc">&nbsp;                    &amp;&amp; (step.getClearance() == 0</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.WIGE &amp;&amp; step.getClearance() == 1)</b>
<b class="nc">&nbsp;                        || curElevation == curHex.terrainLevel(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                        || curElevation == curHex.terrainLevel(Terrains.BRIDGE_ELEV))) {</b>
<b class="nc">&nbsp;                Building bldg = game.getBoard().getBuildingAt(curPos);</b>
<b class="nc">&nbsp;                if ((bldg != null) &amp;&amp; (entity.getElevation() &gt;= 0)) {</b>
<b class="nc">&nbsp;                    boolean wigeFlyingOver = entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                            &amp;&amp; ((curHex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                                    &amp;&amp; curElevation &gt; curHex.terrainLevel(Terrains.BLDG_ELEV)) ||</b>
<b class="nc">&nbsp;                            (curHex.containsTerrain(Terrains.BRIDGE_ELEV)</b>
<b class="nc">&nbsp;                                    &amp;&amp; curElevation &gt; curHex.terrainLevel(Terrains.BRIDGE_ELEV)));</b>
<b class="nc">&nbsp;                    boolean collapse = checkBuildingCollapseWhileMoving(bldg, entity, curPos);</b>
<b class="nc">&nbsp;                    addAffectedBldg(bldg, collapse);</b>
&nbsp;                    // If the building is collapsed by a WiGE flying over it, the WiGE drops one level of elevation.
&nbsp;                    // This could invalidate the remainder of the movement path, so we will send it back to the client.
<b class="nc">&nbsp;                    if (collapse &amp;&amp; wigeFlyingOver) {</b>
<b class="nc">&nbsp;                        curElevation--;</b>
<b class="nc">&nbsp;                        r = new Report(2378);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        continueTurnFromLevelDrop = true;</b>
<b class="nc">&nbsp;                        entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                        entity.setFacing(curFacing);</b>
<b class="nc">&nbsp;                        entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;                        entity.setElevation(curElevation);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Sheer Cliffs, TO p.39
<b class="nc">&nbsp;            boolean vehicleAffectedByCliff = entity instanceof Tank </b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isAirborneVTOLorWIGE();</b>
<b class="nc">&nbsp;            boolean quadveeVehMode = entity instanceof QuadVee</b>
<b class="nc">&nbsp;                    &amp;&amp; ((QuadVee)entity).getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</b>
<b class="nc">&nbsp;            boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech)</b>
&nbsp;                    &amp;&amp; moveType != EntityMovementType.MOVE_JUMP
<b class="nc">&nbsp;                    &amp;&amp; !entity.isAero();</b>
&nbsp;            // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
&nbsp;            // Everything that does not have a 1 or 2 level drop shouldn&#39;t be handled as a cliff
<b class="nc">&nbsp;            int stepHeight = curElevation + curHex.getLevel() </b>
<b class="nc">&nbsp;                    - (lastElevation + prevHex.getLevel());</b>
<b class="nc">&nbsp;            boolean isUpCliff = !lastPos.equals(curPos) </b>
<b class="nc">&nbsp;                    &amp;&amp; curHex.hasCliffTopTowards(prevHex)</b>
&nbsp;                    &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<b class="nc">&nbsp;            boolean isDownCliff = !lastPos.equals(curPos) </b>
<b class="nc">&nbsp;                    &amp;&amp; prevHex.hasCliffTopTowards(curHex)</b>
&nbsp;                    &amp;&amp; (stepHeight == -1 || stepHeight == -2);
&nbsp;
&nbsp;            // Vehicles (exc. WIGE/VTOL) moving down a cliff
<b class="nc">&nbsp;            if (vehicleAffectedByCliff &amp;&amp; isDownCliff &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(stepMoveType);</b>
<b class="nc">&nbsp;                rollTarget.append(new PilotingRollData(entity.getId(), 0, &quot;moving down a sheer cliff&quot;));</b>
<b class="nc">&nbsp;                if (doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                        lastPos, curPos, rollTarget, false) &gt; 0) {
<b class="nc">&nbsp;                    addReport(vehicleMotiveDamage((Tank)entity, 0));</b>
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    turnOver = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Mechs and Protomechs moving down a cliff
&nbsp;            // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133
<b class="nc">&nbsp;            if (mechAffectedByCliff &amp;&amp; !quadveeVehMode &amp;&amp; isDownCliff &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                rollTarget.append(new PilotingRollData(entity.getId(), -stepHeight - 1, &quot;moving down a sheer cliff&quot;));</b>
<b class="nc">&nbsp;                if (doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                        lastPos, curPos, rollTarget, true) &gt; 0) {
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    turnOver = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Mechs moving up a cliff
<b class="nc">&nbsp;            if (mechAffectedByCliff &amp;&amp; !quadveeVehMode &amp;&amp; isUpCliff &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                rollTarget.append(new PilotingRollData(entity.getId(), stepHeight, &quot;moving up a sheer cliff&quot;));</b>
<b class="nc">&nbsp;                if (doSkillCheckWhileMoving(entity, lastElevation,</b>
&nbsp;                        lastPos, lastPos, rollTarget, false) &gt; 0) {
<b class="nc">&nbsp;                    r = new Report(2209);</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                    mpUsed = step.getMpUsed();</b>
<b class="nc">&nbsp;                    continueTurnFromCliffAscent = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // did the entity just fall?
<b class="nc">&nbsp;            if (!wasProne &amp;&amp; entity.isProne()) {</b>
<b class="nc">&nbsp;                curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                mpUsed = step.getMpUsed();</b>
<b class="nc">&nbsp;                fellDuringMovement = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // dropping prone intentionally?
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.GO_PRONE) {</b>
<b class="nc">&nbsp;                mpUsed = step.getMpUsed();</b>
<b class="nc">&nbsp;                rollTarget = entity.checkDislodgeSwarmers(step, overallMoveType);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() == TargetRoll.CHECK_FALSE) {</b>
&nbsp;                    // Not being swarmed
<b class="nc">&nbsp;                    entity.setProne(true);</b>
&nbsp;                    // check to see if we washed off infernos
<b class="nc">&nbsp;                    checkForWashedInfernos(entity, curPos);</b>
&nbsp;                } else {
&nbsp;                    // Being swarmed
<b class="nc">&nbsp;                    entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                    if (doDislodgeSwarmerSkillCheck(entity, rollTarget, curPos)) {</b>
&nbsp;                        // Entity falls
<b class="nc">&nbsp;                        curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                        curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                        fellDuringMovement = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                    // roll failed, go prone but don&#39;t dislodge swarmers
<b class="nc">&nbsp;                    entity.setProne(true);</b>
&nbsp;                    // check to see if we washed off infernos
<b class="nc">&nbsp;                    checkForWashedInfernos(entity, curPos);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // going hull down
<b class="nc">&nbsp;            if (step.getType() == MoveStepType.HULL_DOWN) {</b>
<b class="nc">&nbsp;                mpUsed = step.getMpUsed();</b>
<b class="nc">&nbsp;                entity.setHullDown(true);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Check for crushing buildings by Dropships/Mobile Structures
<b class="nc">&nbsp;            for (Coords pos : step.getCrushedBuildingLocs()) {</b>
<b class="nc">&nbsp;                Building bldg = game.getBoard().getBuildingAt(pos);</b>
<b class="nc">&nbsp;                IHex hex = game.getBoard().getHex(pos);</b>
&nbsp;
<b class="nc">&nbsp;                r = new Report(3443);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(bldg.getName());</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                final int cf = bldg.getCurrentCF(pos);</b>
<b class="nc">&nbsp;                final int numFloors = Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageBuilding(bldg, 150, &quot; is crushed for &quot;, pos));</b>
<b class="nc">&nbsp;                int damage = (int) Math.round((cf / 10.0) * numFloors);</b>
<b class="nc">&nbsp;                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageEntity(entity, hit, damage));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Track this step&#39;s location.
<b class="nc">&nbsp;            movePath.addElement(new UnitLocation(entity.getId(), curPos,</b>
<b class="nc">&nbsp;                    curFacing, step.getElevation()));</b>
&nbsp;
&nbsp;            // if the lastpos is not the same as the current position
&nbsp;            // then add the current position to the list of places passed
&nbsp;            // through
<b class="nc">&nbsp;            if (!curPos.equals(lastPos)) {</b>
<b class="nc">&nbsp;                passedThrough.add(curPos);</b>
<b class="nc">&nbsp;                passedThroughFacing.add(curFacing);</b>
&nbsp;            }
&nbsp;
&nbsp;            // update lastPos, prevStep, prevFacing &amp; prevHex
<b class="nc">&nbsp;            if (!curPos.equals(lastPos)) {</b>
<b class="nc">&nbsp;                prevFacing = curFacing;</b>
&nbsp;            }
<b class="nc">&nbsp;            lastPos = curPos;</b>
<b class="nc">&nbsp;            lastElevation = curElevation;</b>
<b class="nc">&nbsp;            prevStep = step;</b>
<b class="nc">&nbsp;            prevHex = curHex;</b>
&nbsp;
<b class="nc">&nbsp;            firstStep = false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // set entity parameters
<b class="nc">&nbsp;        entity.setPosition(curPos);</b>
<b class="nc">&nbsp;        entity.setFacing(curFacing);</b>
<b class="nc">&nbsp;        entity.setSecondaryFacing(curFacing);</b>
<b class="nc">&nbsp;        entity.delta_distance = distance;</b>
<b class="nc">&nbsp;        entity.moved = moveType;</b>
<b class="nc">&nbsp;        entity.mpUsed = mpUsed;</b>
<b class="nc">&nbsp;        entity.setClimbMode(curClimbMode);</b>
<b class="nc">&nbsp;        if (!sideslipped &amp;&amp; !fellDuringMovement &amp;&amp; !crashedDuringMovement</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() == EntityMovementMode.VTOL)) {</b>
<b class="nc">&nbsp;            entity.setElevation(curVTOLElevation);</b>
&nbsp;        }
<b class="nc">&nbsp;        entity.setAltitude(curAltitude);</b>
<b class="nc">&nbsp;        entity.setClimbMode(curClimbMode);</b>
&nbsp;
&nbsp;        // add a list of places passed through
<b class="nc">&nbsp;        entity.setPassedThrough(passedThrough);</b>
<b class="nc">&nbsp;        entity.setPassedThroughFacing(passedThroughFacing);</b>
&nbsp;
&nbsp;        // if we ran with destroyed hip or gyro, we need a psr
<b class="nc">&nbsp;        rollTarget = entity.checkRunningWithDamage(overallMoveType);</b>
<b class="nc">&nbsp;        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE &amp;&amp; entity.canFall()) {</b>
<b class="nc">&nbsp;            doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we sprinted with MASC or a supercharger, then we need a PSR
<b class="nc">&nbsp;        rollTarget = entity.checkSprintingWithMASC(overallMoveType,</b>
&nbsp;                entity.mpUsed);
<b class="nc">&nbsp;        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE &amp;&amp; entity.canFall()) {</b>
<b class="nc">&nbsp;            doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we used ProtoMech myomer booster, roll 2d6
&nbsp;        // pilot damage on a 2
<b class="nc">&nbsp;        if ((entity instanceof Protomech) &amp;&amp; ((Protomech) entity).hasMyomerBooster()</b>
<b class="nc">&nbsp;                &amp;&amp; (md.getMpUsed() &gt; ((Protomech) entity)</b>
<b class="nc">&nbsp;                        .getRunMPwithoutMyomerBooster(true, false, false))) {</b>
<b class="nc">&nbsp;            r = new Report(2373);</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            if (roll &gt; 2) {</b>
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(damageCrew(entity, 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        rollTarget = entity.checkSprintingWithSupercharger(overallMoveType, entity.mpUsed);</b>
<b class="nc">&nbsp;        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;            doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((md.getLastStepMovementType() == EntityMovementType.MOVE_SPRINT)</b>
<b class="nc">&nbsp;                &amp;&amp; md.hasActiveMASC() &amp;&amp; entity.canFall()) {</b>
<b class="nc">&nbsp;            doSkillCheckInPlace(entity, entity.getBasePilotingRoll(EntityMovementType.MOVE_SPRINT));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.isAirborne() &amp;&amp; entity.isAero()) {</b>
&nbsp;
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            int thrust = md.getMpUsed();</b>
&nbsp;
&nbsp;            // consume fuel
<b class="nc">&nbsp;            if (((entity.isAero())</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_FUEL_CONSUMPTION))</b>
&nbsp;                    || (entity instanceof TeleMissile)) {
<b class="nc">&nbsp;                int fuelUsed = ((IAero) entity).getFuelUsed(thrust);</b>
<b class="nc">&nbsp;                a.useFuel(fuelUsed);</b>
&nbsp;            }
&nbsp;
&nbsp;            // JumpShips and space stations need to reduce accumulated thrust if
&nbsp;            // they spend some
<b class="nc">&nbsp;            if (entity instanceof Jumpship) {</b>
<b class="nc">&nbsp;                Jumpship js = (Jumpship) entity;</b>
<b class="nc">&nbsp;                double penalty = 0.0;</b>
&nbsp;                // JumpShips do not accumulate thrust when they make a turn or
&nbsp;                // change velocity
<b class="nc">&nbsp;                if (md.contains(MoveStepType.TURN_LEFT) || md.contains(MoveStepType.TURN_RIGHT)) {</b>
&nbsp;                    // I need to subtract the station keeping thrust from their
&nbsp;                    // accumulated thrust
&nbsp;                    // because they did not actually use it
<b class="nc">&nbsp;                    penalty = js.getStationKeepingThrust();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (thrust &gt; 0) {</b>
<b class="nc">&nbsp;                    penalty = thrust;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (penalty &gt; 0.0) {</b>
<b class="nc">&nbsp;                    js.setAccumulatedThrust(Math.max(0, js.getAccumulatedThrust() - penalty));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check to see if thrust exceeded SI
&nbsp;
<b class="nc">&nbsp;            rollTarget = a.checkThrustSITotal(thrust, overallMoveType);</b>
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(entity.getId(), 0,</b>
&nbsp;                        &quot;Thrust spent during turn exceeds SI&quot;));
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                rollTarget = a.checkVelocityDouble(md.getFinalVelocity(),</b>
&nbsp;                        overallMoveType);
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(entity.getId(), 0,</b>
&nbsp;                            &quot;Velocity greater than 2x safe thrust&quot;));
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                rollTarget = a.checkDown(md.getFinalNDown(), overallMoveType);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(</b>
<b class="nc">&nbsp;                            new PilotingRollData(entity.getId(), md.getFinalNDown(),</b>
&nbsp;                                    &quot;descended more than two altitudes&quot;));
&nbsp;                }
&nbsp;
&nbsp;                // check for hovering
<b class="nc">&nbsp;                rollTarget = a.checkHover(md);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(</b>
<b class="nc">&nbsp;                            new PilotingRollData(entity.getId(), 0, &quot;hovering&quot;));</b>
&nbsp;                }
&nbsp;
&nbsp;                // check for aero stall
<b class="nc">&nbsp;                rollTarget = a.checkStall(md);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    r = new Report(9391);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(entity.getId(), 0,</b>
&nbsp;                            &quot;stalled out&quot;));
<b class="nc">&nbsp;                    entity.setAltitude(entity.getAltitude() - 1);</b>
&nbsp;                    // check for crash
<b class="nc">&nbsp;                    if (checkCrash(entity, entity.getPosition(), entity.getAltitude())) {</b>
<b class="nc">&nbsp;                        addReport(processCrash(entity, 0, entity.getPosition()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // check to see if spheroids should lose one altitude
<b class="nc">&nbsp;                if (a.isSpheroid() &amp;&amp; !a.isSpaceborne()</b>
<b class="nc">&nbsp;                        &amp;&amp; a.isAirborne() &amp;&amp; (md.getFinalNDown() == 0) &amp;&amp; (md.getMpUsed() == 0)) {</b>
<b class="nc">&nbsp;                    r = new Report(9392);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entity.setAltitude(entity.getAltitude() - 1);</b>
&nbsp;                    // check for crash
<b class="nc">&nbsp;                    if (checkCrash(entity, entity.getPosition(), entity.getAltitude())) {</b>
<b class="nc">&nbsp;                        addReport(processCrash(entity, 0, entity.getPosition()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (entity instanceof EscapePods &amp;&amp; entity.isAirborne() &amp;&amp; md.getFinalVelocity() &lt; 2) {</b>
&nbsp;                    //Atmospheric Escape Pods that drop below velocity 2 lose altitude as dropping units
<b class="nc">&nbsp;                    entity.setAltitude(entity.getAltitude()</b>
<b class="nc">&nbsp;                            - game.getPlanetaryConditions().getDropRate());</b>
<b class="nc">&nbsp;                    r = new Report(6676);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(game.getPlanetaryConditions().getDropRate());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // We need to check for the removal of hull-down for tanks.
&nbsp;        // Tanks can just drive out of hull-down: if the tank was hull-down
&nbsp;        // and doesn&#39;t end hull-down we can remove the hull-down status
<b class="nc">&nbsp;        if (entity.isHullDown() &amp;&amp; !md.getFinalHullDown()</b>
&nbsp;                &amp;&amp; (entity instanceof Tank
<b class="nc">&nbsp;                || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))) {</b>
<b class="nc">&nbsp;            entity.setHullDown(false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the entity is being swarmed, erratic movement may dislodge the
&nbsp;        // fleas.
<b class="nc">&nbsp;        final int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;        if ((Entity.NONE != swarmerId) &amp;&amp; md.contains(MoveStepType.SHAKE_OFF_SWARMERS)) {</b>
<b class="nc">&nbsp;            final Entity swarmer = game.getEntity(swarmerId);</b>
<b class="nc">&nbsp;            rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;            entity.addPilotingModifierForTerrain(rollTarget);</b>
&nbsp;
&nbsp;            // Add a +4 modifier.
<b class="nc">&nbsp;            if (md.getLastStepMovementType() == EntityMovementType.MOVE_VTOL_RUN) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(2,</b>
&nbsp;                        &quot;dislodge swarming infantry with VTOL movement&quot;);
&nbsp;            } else {
<b class="nc">&nbsp;                rollTarget.addModifier(4, &quot;dislodge swarming infantry&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // If the swarmer has Assault claws, give a 1 modifier.
&nbsp;            // We can stop looking when we find our first match.
<b class="nc">&nbsp;            for (Mounted mount : swarmer.getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType equip = mount.getType();</b>
<b class="nc">&nbsp;                if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(1, &quot;swarmer has magnetic claws&quot;);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // okay, print the info
<b class="nc">&nbsp;            r = new Report(2125);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // roll
<b class="nc">&nbsp;            final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(2130);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(rollTarget.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(rollTarget.getDesc());</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            if (diceRoll &lt; rollTarget.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
&nbsp;                // Dislodged swarmers don&#39;t get turns.
<b class="nc">&nbsp;                game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
&nbsp;
&nbsp;                // Update the report and the swarmer&#39;s status.
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                swarmer.setSwarmTargetId(Entity.NONE);</b>
&nbsp;
<b class="nc">&nbsp;                IHex curHex = game.getBoard().getHex(curPos);</b>
&nbsp;
&nbsp;                // Did the infantry fall into water?
<b class="nc">&nbsp;                if (curHex.terrainLevel(Terrains.WATER) &gt; 0) {</b>
&nbsp;                    // Swarming infantry die.
<b class="nc">&nbsp;                    swarmer.setPosition(curPos);</b>
<b class="nc">&nbsp;                    r = new Report(2135);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addReport(destroyEntity(swarmer, &quot;a watery grave&quot;, false));</b>
&nbsp;                } else {
&nbsp;                    // Swarming infantry take a 3d6 point hit.
&nbsp;                    // ASSUMPTION : damage should not be doubled.
<b class="nc">&nbsp;                    r = new Report(2140);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                    r.add(&quot;3d6&quot;);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(swarmer,</b>
<b class="nc">&nbsp;                            swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),</b>
<b class="nc">&nbsp;                            Compute.d6(3)));</b>
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    swarmer.setPosition(curPos);</b>
&nbsp;                }
<b class="nc">&nbsp;                entityUpdate(swarmerId);</b>
&nbsp;            } // End successful-PSR
&nbsp;
&nbsp;        } // End try-to-dislodge-swarmers
&nbsp;
&nbsp;        // but the danger isn&#39;t over yet! landing from a jump can be risky!
<b class="nc">&nbsp;        if ((overallMoveType == EntityMovementType.MOVE_JUMP) &amp;&amp; !entity.isMakingDfa()) {</b>
<b class="nc">&nbsp;            final IHex curHex = game.getBoard().getHex(curPos);</b>
&nbsp;            // check for damaged criticals
<b class="nc">&nbsp;            rollTarget = entity.checkLandingWithDamage(overallMoveType);</b>
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;            }
&nbsp;            // check for prototype JJs
<b class="nc">&nbsp;            rollTarget = entity.checkLandingWithPrototypeJJ(overallMoveType);</b>
<b class="nc">&nbsp;            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;            }
&nbsp;            // check for jumping into heavy woods
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_PSR_JUMP_HEAVY_WOODS)) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkLandingInHeavyWoods(overallMoveType, curHex);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    doSkillCheckInPlace(entity, rollTarget);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Mechanical jump boosters fall damage
<b class="nc">&nbsp;            if (md.shouldMechanicalJumpCauseFallDamage()) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFallsInto(entity,</b>
<b class="nc">&nbsp;                        entity.getElevation(), md.getJumpPathHighestPoint(),</b>
<b class="nc">&nbsp;                        curPos, entity.getBasePilotingRoll(overallMoveType),</b>
<b class="nc">&nbsp;                        false, entity.getJumpMP()));</b>
&nbsp;            }
&nbsp;            // jumped into water?
<b class="nc">&nbsp;            int waterLevel = curHex.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;            if (curHex.containsTerrain(Terrains.ICE) &amp;&amp; (waterLevel &gt; 0)) {</b>
<b class="nc">&nbsp;                if (!(entity instanceof Infantry)) {</b>
&nbsp;                    // check for breaking ice
<b class="nc">&nbsp;                    int roll = Compute.d6(1);</b>
<b class="nc">&nbsp;                    r = new Report(2122);</b>
<b class="nc">&nbsp;                    r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    if (roll &gt;= 4) {</b>
&nbsp;                        // oops!
<b class="nc">&nbsp;                        entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                        addReport(resolveIceBroken(curPos));</b>
<b class="nc">&nbsp;                        curPos = entity.getPosition();</b>
&nbsp;                    } else {
&nbsp;                        // TacOps: immediate PSR with +4 for terrain. If you
&nbsp;                        // fall then may break the ice after all
<b class="nc">&nbsp;                        rollTarget = entity.checkLandingOnIce(overallMoveType, curHex);</b>
<b class="nc">&nbsp;                        if (!doSkillCheckInPlace(entity, rollTarget)) {</b>
&nbsp;                            // apply damage now, or it will show up as a
&nbsp;                            // possible breach, if ice is broken
<b class="nc">&nbsp;                            entity.applyDamage();</b>
<b class="nc">&nbsp;                            roll = Compute.d6(1);</b>
<b class="nc">&nbsp;                            r = new Report(2118);</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.add(roll);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            if (roll == 6) {</b>
<b class="nc">&nbsp;                                entity.setPosition(curPos);</b>
<b class="nc">&nbsp;                                addReport(resolveIceBroken(curPos));</b>
<b class="nc">&nbsp;                                curPos = entity.getPosition();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } else if (!(prevStep.climbMode() &amp;&amp; curHex.containsTerrain(Terrains.BRIDGE))</b>
<b class="nc">&nbsp;                    &amp;&amp; !(entity.getMovementMode() == EntityMovementMode.HOVER)) {</b>
<b class="nc">&nbsp;                rollTarget = entity.checkWaterMove(waterLevel, overallMoveType);</b>
<b class="nc">&nbsp;                if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {</b>
&nbsp;                    // For falling elevation, Entity must not on hex surface
<b class="nc">&nbsp;                    int currElevation = entity.getElevation();</b>
<b class="nc">&nbsp;                    entity.setElevation(0);</b>
<b class="nc">&nbsp;                    boolean success = doSkillCheckInPlace(entity, rollTarget);</b>
<b class="nc">&nbsp;                    if (success) {</b>
<b class="nc">&nbsp;                        entity.setElevation(currElevation);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (waterLevel &gt; 1) {</b>
&nbsp;                    // Any swarming infantry will be destroyed.
<b class="nc">&nbsp;                    drownSwarmer(entity, curPos);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check for building collapse
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(curPos);</b>
<b class="nc">&nbsp;            if (bldg != null) {</b>
<b class="nc">&nbsp;                checkForCollapse(bldg, game.getPositionMap(), curPos, true,</b>
&nbsp;                        vPhaseReport);
&nbsp;            }
&nbsp;
&nbsp;            // Don&#39;t interact with terrain when jumping onto a building or a bridge
<b class="nc">&nbsp;            if (entity.getElevation() == 0) {</b>
<b class="nc">&nbsp;                ServerHelper.checkAndApplyMagmaCrust(curHex, entity.getElevation(), entity, curPos, true, vPhaseReport, this);</b>
&nbsp;
&nbsp;                // jumped into swamp? maybe stuck!
<b class="nc">&nbsp;                if (curHex.getBogDownModifier(entity.getMovementMode(),</b>
&nbsp;                        entity instanceof LargeSupportTank) != TargetRoll.AUTOMATIC_SUCCESS) {
<b class="nc">&nbsp;                    if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                        entity.setStuck(true);</b>
<b class="nc">&nbsp;                        r = new Report(2121);</b>
<b class="nc">&nbsp;                        r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                        // check for quicksand
<b class="nc">&nbsp;                        addReport(checkQuickSand(curPos));</b>
<b class="nc">&nbsp;                    } else if (!entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {</b>
<b class="nc">&nbsp;                        rollTarget = new PilotingRollData(entity.getId(),</b>
&nbsp;                                5, &quot;entering boggy terrain&quot;);
<b class="nc">&nbsp;                        rollTarget.append(new PilotingRollData(entity.getId(),</b>
<b class="nc">&nbsp;                                curHex.getBogDownModifier(entity.getMovementMode(),</b>
&nbsp;                                        entity instanceof LargeSupportTank),
&nbsp;                                &quot;avoid bogging down&quot;));
<b class="nc">&nbsp;                        if (0 &lt; doSkillCheckWhileMoving(entity, entity.getElevation(), curPos, curPos,</b>
&nbsp;                                rollTarget, false)) {
<b class="nc">&nbsp;                            entity.setStuck(true);</b>
<b class="nc">&nbsp;                            r = new Report(2081);</b>
<b class="nc">&nbsp;                            r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                            // check for quicksand
<b class="nc">&nbsp;                            addReport(checkQuickSand(curPos));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // If the entity is being swarmed, jumping may dislodge the fleas.
<b class="nc">&nbsp;            if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;                final Entity swarmer = game.getEntity(swarmerId);</b>
<b class="nc">&nbsp;                rollTarget = entity.getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;                entity.addPilotingModifierForTerrain(rollTarget);</b>
&nbsp;
&nbsp;                // Add a +4 modifier.
<b class="nc">&nbsp;                rollTarget.addModifier(4, &quot;dislodge swarming infantry&quot;);</b>
&nbsp;
&nbsp;                // If the swarmer has Assault claws, give a 1 modifier.
&nbsp;                // We can stop looking when we find our first match.
<b class="nc">&nbsp;                if (swarmer.hasWorkingMisc(MiscType.F_MAGNET_CLAW, -1)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(1, &quot;swarmer has magnetic claws&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // okay, print the info
<b class="nc">&nbsp;                r = new Report(2125);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // roll
<b class="nc">&nbsp;                final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                r = new Report(2130);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(rollTarget.getValueAsString());</b>
<b class="nc">&nbsp;                r.add(rollTarget.getDesc());</b>
<b class="nc">&nbsp;                r.add(diceRoll);</b>
<b class="nc">&nbsp;                if (diceRoll &lt; rollTarget.getValue()) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                } else {
&nbsp;                    // Dislodged swarmers don&#39;t get turns.
<b class="nc">&nbsp;                    game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
&nbsp;
&nbsp;                    // Update the report and the swarmer&#39;s status.
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                    swarmer.setSwarmTargetId(Entity.NONE);</b>
&nbsp;
&nbsp;                    // Did the infantry fall into water?
<b class="nc">&nbsp;                    if (curHex.terrainLevel(Terrains.WATER) &gt; 0) {</b>
&nbsp;                        // Swarming infantry die.
<b class="nc">&nbsp;                        swarmer.setPosition(curPos);</b>
<b class="nc">&nbsp;                        r = new Report(2135);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.indent();</b>
<b class="nc">&nbsp;                        r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        addReport(destroyEntity(swarmer, &quot;a watery grave&quot;, false));</b>
&nbsp;                    } else {
&nbsp;                        // Swarming infantry take a 3d6 point hit.
&nbsp;                        // ASSUMPTION : damage should not be doubled.
<b class="nc">&nbsp;                        r = new Report(2140);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.indent();</b>
<b class="nc">&nbsp;                        r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                        r.add(&quot;3d6&quot;);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        addReport(damageEntity(swarmer,</b>
<b class="nc">&nbsp;                                swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),</b>
<b class="nc">&nbsp;                                Compute.d6(3)));</b>
<b class="nc">&nbsp;                        addNewLines();</b>
<b class="nc">&nbsp;                        swarmer.setPosition(curPos);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    entityUpdate(swarmerId);</b>
&nbsp;                } // End successful-PSR
&nbsp;
&nbsp;            } // End try-to-dislodge-swarmers
&nbsp;
&nbsp;            // one more check for inferno wash-off
<b class="nc">&nbsp;            checkForWashedInfernos(entity, curPos);</b>
&nbsp;
&nbsp;            // a jumping tank needs to roll for movement damage
<b class="nc">&nbsp;            if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                int modifier = 0;</b>
<b class="nc">&nbsp;                if (curHex.containsTerrain(Terrains.ROUGH)</b>
<b class="nc">&nbsp;                        || curHex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                        || curHex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                    modifier = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = new Report(2126);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(vehicleMotiveDamage((Tank)entity, modifier,</b>
&nbsp;                        false, -1, true));
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
&nbsp;            }
&nbsp;
&nbsp;        } // End entity-is-jumping
&nbsp;
&nbsp;        //If converting to another mode, set the final movement mode and report it
<b class="nc">&nbsp;        if (entity.isConvertingNow()) {</b>
<b class="nc">&nbsp;            r = new Report(1210);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            if (entity instanceof QuadVee &amp;&amp; entity.isProne()</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_MECH) {</b>
&nbsp;                //Fall while converting to vehicle mode cancels conversion.
<b class="nc">&nbsp;                entity.setConvertingNow(false);</b>
<b class="nc">&nbsp;                r.messageId = 2454;</b>
&nbsp;            } else {
&nbsp;                // LAMs converting from fighter mode need to have the elevation set properly.
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    if (md.getFinalConversionMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                            &amp;&amp; entity.getAltitude() &gt; 0 &amp;&amp; entity.getAltitude() &lt;= 3) {</b>
<b class="nc">&nbsp;                        entity.setElevation(entity.getAltitude() * 10);</b>
<b class="nc">&nbsp;                        entity.setAltitude(0);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        IHex hex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;                        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                            entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            entity.setElevation(0);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                entity.setMovementMode(md.getFinalConversionMode());</b>
<b class="nc">&nbsp;                if (entity instanceof Mech &amp;&amp; ((Mech)entity).hasTracks()) {</b>
<b class="nc">&nbsp;                    r.messageId = 2455;</b>
<b class="nc">&nbsp;                    r.choose(entity.getMovementMode() == EntityMovementMode.TRACKED);</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.TRACKED</b>
<b class="nc">&nbsp;                        || entity.getMovementMode() == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;                    r.messageId = 2451;</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                    r.messageId = 2452;</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.AERODYNE) {</b>
<b class="nc">&nbsp;                    r.messageId = 2453;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.messageId = 2450;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    int altitude = entity.getAltitude();</b>
<b class="nc">&nbsp;                    if (altitude == 0 &amp;&amp; md.getFinalElevation() &gt;= 8) {</b>
<b class="nc">&nbsp;                        altitude = 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (altitude == 0) {</b>
<b class="nc">&nbsp;                        ((IAero)entity).land();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        ((IAero)entity).liftOff(altitude);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;          // update entity&#39;s locations&#39; exposure
<b class="nc">&nbsp;        vPhaseReport.addAll(doSetLocationsExposure(entity,</b>
<b class="nc">&nbsp;                game.getBoard().getHex(curPos), false, entity.getElevation()));</b>
&nbsp;
&nbsp;        // Check the falls_end_movement option to see if it should be able to
&nbsp;        // move on.
&nbsp;        // Need to check here if the &#39;Mech actually went from non-prone to prone
&nbsp;        // here because &#39;fellDuringMovement&#39; is sometimes abused just to force
&nbsp;        // another turn and so doesn&#39;t reliably tell us.
<b class="nc">&nbsp;        boolean continueTurnFromFall = !(game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_FALLS_END_MOVEMENT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity instanceof Mech) &amp;&amp; !wasProne &amp;&amp; entity.isProne())</b>
<b class="nc">&nbsp;                &amp;&amp; (fellDuringMovement &amp;&amp; !entity.isCarefulStand()) // Careful standing takes up the whole turn</b>
<b class="nc">&nbsp;                &amp;&amp; !turnOver &amp;&amp; (entity.mpUsed &lt; entity.getRunMP())</b>
&nbsp;                &amp;&amp; (overallMoveType != EntityMovementType.MOVE_JUMP);
<b class="nc">&nbsp;        if ((continueTurnFromFall || continueTurnFromPBS || continueTurnFromFishtail || continueTurnFromLevelDrop || continueTurnFromCliffAscent)</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isSelectableThisTurn() &amp;&amp; !entity.isDoomed()) {</b>
<b class="nc">&nbsp;            entity.applyDamage();</b>
<b class="nc">&nbsp;            entity.setDone(false);</b>
<b class="nc">&nbsp;            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity.getOwner().getId(), entity.getId());</b>
&nbsp;            // Need to set the new turn&#39;s multiTurn state
<b class="nc">&nbsp;            newTurn.setMultiTurn(true);</b>
<b class="nc">&nbsp;            game.insertNextTurn(newTurn);</b>
&nbsp;            // brief everybody on the turn update
<b class="nc">&nbsp;            send(createTurnVectorPacket());</b>
&nbsp;            // let everyone know about what just happened
<b class="nc">&nbsp;            if (vPhaseReport.size() &gt; 1) {</b>
<b class="nc">&nbsp;                send(entity.getOwner().getId(), createSpecialReportPacket());</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                IHex hex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;                if (md.automaticWiGELanding(false)) {</b>
&nbsp;                    // try to land safely; LAMs require a psr when landing with gyro or leg actuator
&nbsp;                    // damage and ProtoMechs always require a roll
<b class="nc">&nbsp;                    int elevation = (null == prevStep)? entity.getElevation() : prevStep.getElevation();</b>
<b class="nc">&nbsp;                    if (entity.hasETypeFlag(Entity.ETYPE_LAND_AIR_MECH)) {</b>
<b class="nc">&nbsp;                        addReport(landAirMech((LandAirMech) entity, entity.getPosition(), elevation,</b>
&nbsp;                                entity.delta_distance));
<b class="nc">&nbsp;                    } else if (entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(landGliderPM((Protomech) entity, entity.getPosition(),</b>
&nbsp;                                elevation, entity.delta_distance));
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(2123);</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                        Building bldg = game.getBoard().getBuildingAt(entity.getPosition());</b>
<b class="nc">&nbsp;                        entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;                        addAffectedBldg(bldg, checkBuildingCollapseWhileMoving(bldg,</b>
<b class="nc">&nbsp;                                entity, entity.getPosition()));</b>
<b class="nc">&nbsp;                    } else if (entity.isLocationProhibited(entity.getPosition(), 0)</b>
<b class="nc">&nbsp;                            &amp;&amp; !hex.hasPavement()){</b>
&nbsp;                        // crash
<b class="nc">&nbsp;                        r = new Report(2124);</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(crashVTOLorWiGE((Tank) entity));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        entity.setElevation(0);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Check for stacking violations in the target hex
<b class="nc">&nbsp;                    Entity violation = Compute.stackingViolation(game,</b>
<b class="nc">&nbsp;                            entity.getId(), entity.getPosition());</b>
<b class="nc">&nbsp;                    if (violation != null) {</b>
<b class="nc">&nbsp;                        PilotingRollData prd = new PilotingRollData(</b>
<b class="nc">&nbsp;                                violation.getId(), 2, &quot;fallen on&quot;);</b>
<b class="nc">&nbsp;                        if (violation instanceof Dropship) {</b>
<b class="nc">&nbsp;                            violation = entity;</b>
<b class="nc">&nbsp;                            prd = null;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Coords targetDest = Compute.getValidDisplacement(game,</b>
<b class="nc">&nbsp;                                violation.getId(), entity.getPosition(), 0);</b>
<b class="nc">&nbsp;                        if (targetDest != null) {</b>
<b class="nc">&nbsp;                            vPhaseReport.addAll(doEntityDisplacement(violation,</b>
<b class="nc">&nbsp;                                    entity.getPosition(), targetDest, prd));</b>
&nbsp;                            // Update the violating entity&#39;s position on the
&nbsp;                            // client.
<b class="nc">&nbsp;                            entityUpdate(violation.getId());</b>
&nbsp;                        } else {
&nbsp;                            // ack! automatic death! Tanks
&nbsp;                            // suffer an ammo/power plant hit.
&nbsp;                            // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                            vPhaseReport.addAll(destroyEntity(violation,</b>
&nbsp;                                    &quot;impossible displacement&quot;,
&nbsp;                                    violation instanceof Mech,
&nbsp;                                    violation instanceof Mech));
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else if (!entity.hasETypeFlag(Entity.ETYPE_LAND_AIR_MECH)</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {</b>
&nbsp;
&nbsp;                    // we didn&#39;t land, so we go to elevation 1 above the terrain
&nbsp;                    // features
&nbsp;                    // it might have been higher than one due to the extra MPs
&nbsp;                    // it can spend to stay higher during movement, but should
&nbsp;                    // end up at one
&nbsp;
<b class="nc">&nbsp;                    entity.setElevation(Math.min(entity.getElevation(),</b>
<b class="nc">&nbsp;                            1 + hex.maxTerrainFeatureElevation(</b>
<b class="nc">&nbsp;                            game.getBoard().inAtmosphere())));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If we&#39;ve somehow gotten here as an airborne LAM with a destroyed side torso
&nbsp;            // (such as conversion while dropping), crash now.
<b class="nc">&nbsp;            if (entity instanceof LandAirMech</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.isLocationBad(Mech.LOC_RT) || entity.isLocationBad(Mech.LOC_LT))) {</b>
<b class="nc">&nbsp;                r = new Report(9710);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                if (entity.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    crashAirMech(entity, new PilotingRollData(entity.getId(), TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                            &quot;side torso destroyed&quot;), vPhaseReport);
<b class="nc">&nbsp;                } else if (entity.isAirborne() &amp;&amp; entity.isAero()) {</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addReport(processCrash(entity, ((IAero)entity).getCurrentVelocity(), entity.getPosition()));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            entity.setDone(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (dropshipStillUnloading) {</b>
&nbsp;            // turns should have already been inserted but we need to set the
&nbsp;            // entity as not done
<b class="nc">&nbsp;            entity.setDone(false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the entity is being swarmed, update the attacker&#39;s position.
<b class="nc">&nbsp;        if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;            final Entity swarmer = game.getEntity(swarmerId);</b>
<b class="nc">&nbsp;            swarmer.setPosition(curPos);</b>
&nbsp;            // If the hex is on fire, and the swarming infantry is
&nbsp;            // *not* Battle Armor, it drops off.
<b class="nc">&nbsp;            if (!(swarmer instanceof BattleArmor) &amp;&amp; game.getBoard()</b>
<b class="nc">&nbsp;                    .getHex(curPos).containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;                swarmer.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;                entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                r = new Report(2145);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(swarmer.getShortName(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            entityUpdate(swarmerId);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update the entity&#39;s position,
&nbsp;        // unless it is off the game map.
<b class="nc">&nbsp;        if (!game.isOutOfGame(entity)) {</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId(), movePath, true, losCache);</b>
<b class="nc">&nbsp;            if (entity.isDoomed()) {</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(entity.getId(),</b>
<b class="nc">&nbsp;                        entity.getRemovalCondition()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //If the entity is towing trailers, update the position of those trailers
<b class="nc">&nbsp;        if (!entity.getAllTowedUnits().isEmpty()) {</b>
<b class="nc">&nbsp;            List&lt;Integer&gt; reversedTrailers = new ArrayList&lt;&gt;(entity.getAllTowedUnits()); // initialize with a copy (no need to initialize to an empty list first)</b>
<b class="nc">&nbsp;            Collections.reverse(reversedTrailers); // reverse in-place</b>
<b class="nc">&nbsp;            List&lt;Coords&gt; trailerPath = initializeTrailerCoordinates(entity, reversedTrailers); // no need to initialize to an empty list first</b>
<b class="nc">&nbsp;            processTrailerMovement(entity, trailerPath);</b>
&nbsp;         }
&nbsp;
&nbsp;        // recovered units should now be recovered and dealt with
<b class="nc">&nbsp;        if (entity.isAero() &amp;&amp; recovered &amp;&amp; (loader != null)) {</b>
&nbsp;
<b class="nc">&nbsp;            if (loader.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                if (!(loader instanceof FighterSquadron)) {</b>
&nbsp;                    // this is a solo capital fighter so we need to add a new
&nbsp;                    // squadron and load both the loader and loadee
<b class="nc">&nbsp;                    FighterSquadron fs = new FighterSquadron();</b>
<b class="nc">&nbsp;                    fs.setDeployed(true);</b>
<b class="nc">&nbsp;                    fs.setId(getFreeEntityId());</b>
<b class="nc">&nbsp;                    fs.setCurrentVelocity(((Aero) loader).getCurrentVelocity());</b>
<b class="nc">&nbsp;                    fs.setNextVelocity(((Aero) loader).getNextVelocity());</b>
<b class="nc">&nbsp;                    fs.setVectors(loader.getVectors());</b>
<b class="nc">&nbsp;                    fs.setFacing(loader.getFacing());</b>
<b class="nc">&nbsp;                    fs.setOwner(entity.getOwner());</b>
&nbsp;                    // set velocity and heading the same as parent entity
<b class="nc">&nbsp;                    game.addEntity(fs);</b>
<b class="nc">&nbsp;                    send(createAddEntityPacket(fs.getId()));</b>
&nbsp;                    // make him not get a move this turn
<b class="nc">&nbsp;                    fs.setDone(true);</b>
&nbsp;                    // place on board
<b class="nc">&nbsp;                    fs.setPosition(loader.getPosition());</b>
<b class="nc">&nbsp;                    loadUnit(fs, loader, -1);</b>
<b class="nc">&nbsp;                    loader = fs;</b>
<b class="nc">&nbsp;                    entityUpdate(fs.getId());</b>
&nbsp;                }
<b class="nc">&nbsp;                loader.load(entity);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                loader.recover(entity);</b>
<b class="nc">&nbsp;                entity.setRecoveryTurn(5);</b>
&nbsp;            }
&nbsp;
&nbsp;            // The loaded unit is being carried by the loader.
<b class="nc">&nbsp;            entity.setTransportId(loader.getId());</b>
&nbsp;
&nbsp;            // Remove the loaded unit from the screen.
<b class="nc">&nbsp;            entity.setPosition(null);</b>
&nbsp;
&nbsp;            // Update the loaded unit.
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
&nbsp;        }
&nbsp;
&nbsp;        // even if load was unsuccessful, I may need to update the loader
<b class="nc">&nbsp;        if (null != loader) {</b>
<b class="nc">&nbsp;            entityUpdate(loader.getId());</b>
&nbsp;        }
&nbsp;
&nbsp;        // if using double blind, update the player on new units he might see
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            send(entity.getOwner().getId(),</b>
<b class="nc">&nbsp;                    createFilteredEntitiesPacket(entity.getOwner(), losCache));</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we generated a charge attack, report it now
<b class="nc">&nbsp;        if (charge != null) {</b>
<b class="nc">&nbsp;            send(createAttackPacket(charge, 1));</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we generated a ram attack, report it now
<b class="nc">&nbsp;        if (ram != null) {</b>
<b class="nc">&nbsp;            send(createAttackPacket(ram, 1));</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((entity instanceof Mech) &amp;&amp; entity.hasEngine() &amp;&amp; ((Mech) entity).isIndustrial()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.hasEnvironmentalSealing()</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE)) {</b>
<b class="nc">&nbsp;            if ((!entity.isProne()</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getBoard().getHex(entity.getPosition())</b>
<b class="nc">&nbsp;                            .terrainLevel(Terrains.WATER) &gt;= 2))</b>
<b class="nc">&nbsp;                    || (entity.isProne()</b>
<b class="nc">&nbsp;                            &amp;&amp; (game.getBoard().getHex(entity.getPosition())</b>
<b class="nc">&nbsp;                                    .terrainLevel(Terrains.WATER) == 1))) {</b>
<b class="nc">&nbsp;                ((Mech) entity).setJustMovedIntoIndustrialKillingWater(true);</b>
&nbsp;
&nbsp;            } else {
<b class="nc">&nbsp;                ((Mech) entity).setJustMovedIntoIndustrialKillingWater(false);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the position of any towed trailers.
&nbsp;     *
&nbsp;     * @param tractor    The Entity that is moving
&nbsp;     * @param trainPath  The path all trailers are following?
&nbsp;     */
&nbsp;    private void processTrailerMovement(Entity tractor, List&lt;Coords&gt; trainPath) {
<b class="nc">&nbsp;        for (int eId : tractor.getAllTowedUnits()) {</b>
<b class="nc">&nbsp;            Entity trailer = game.getEntity(eId);</b>
&nbsp;            // if the Tractor didn&#39;t move anywhere, stay where we are
<b class="nc">&nbsp;            if (tractor.delta_distance == 0) {</b>
<b class="nc">&nbsp;                trailer.delta_distance = tractor.delta_distance;</b>
<b class="nc">&nbsp;                trailer.moved = tractor.moved;</b>
<b class="nc">&nbsp;                trailer.setSecondaryFacing(trailer.getFacing());</b>
<b class="nc">&nbsp;                trailer.setDone(true);</b>
<b class="nc">&nbsp;                entityUpdate(eId);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            int stepNumber; // The Coords in trainPath that this trailer should move to
&nbsp;            Coords trailerPos;
<b class="nc">&nbsp;            int trailerNumber = tractor.getAllTowedUnits().indexOf(eId);</b>
<b class="nc">&nbsp;            double trailerPositionOffset = (trailerNumber + 1); //Offset so we get the right position index</b>
&nbsp;            // Unless the tractor is superheavy, put the first trailer in its hex.
&nbsp;            // Technically this would be true for a superheavy trailer too, but only a superheavy tractor can tow one.
<b class="nc">&nbsp;            if (trailerNumber == 0 &amp;&amp; !tractor.isSuperHeavy()) {</b>
<b class="nc">&nbsp;                trailer.setPosition(tractor.getPosition());</b>
<b class="nc">&nbsp;                trailer.setFacing(tractor.getFacing());</b>
&nbsp;            } else {
&nbsp;                // If the trailer is superheavy, place it in a hex by itself
<b class="nc">&nbsp;                if (trailer.isSuperHeavy()) {</b>
<b class="nc">&nbsp;                    trailerPositionOffset ++;</b>
<b class="nc">&nbsp;                    stepNumber = (trainPath.size() - (int) trailerPositionOffset);</b>
<b class="nc">&nbsp;                    trailerPos = trainPath.get(stepNumber);</b>
<b class="nc">&nbsp;                    trailer.setPosition(trailerPos);</b>
<b class="nc">&nbsp;                    if ((tractor.getPassedThroughFacing().size() - trailerPositionOffset) &gt;= 0) {</b>
<b class="nc">&nbsp;                        trailer.setFacing(tractor.getPassedThroughFacing().get(tractor.getPassedThroughFacing().size() - (int) trailerPositionOffset));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (tractor.isSuperHeavy()) {</b>
&nbsp;                    // If the tractor is superheavy, we can put two trailers in each hex
&nbsp;                    // starting trailer 0 in the hex behind the tractor
<b class="nc">&nbsp;                    trailerPositionOffset = (Math.ceil((trailerPositionOffset / 2.0)) + 1);</b>
<b class="nc">&nbsp;                    stepNumber = (trainPath.size() - (int) trailerPositionOffset);</b>
<b class="nc">&nbsp;                    trailerPos = trainPath.get(stepNumber);</b>
<b class="nc">&nbsp;                    trailer.setPosition(trailerPos);</b>
<b class="nc">&nbsp;                    if ((tractor.getPassedThroughFacing().size() - trailerPositionOffset) &gt;= 0) {</b>
<b class="nc">&nbsp;                        trailer.setFacing(tractor.getPassedThroughFacing().get(tractor.getPassedThroughFacing().size() - (int) trailerPositionOffset));</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // Otherwise, we can put two trailers in each hex
&nbsp;                    // starting trailer 1 in the hex behind the tractor
<b class="nc">&nbsp;                    trailerPositionOffset ++;</b>
<b class="nc">&nbsp;                    trailerPositionOffset = Math.ceil((trailerPositionOffset / 2.0));</b>
<b class="nc">&nbsp;                    stepNumber = (trainPath.size() - (int) trailerPositionOffset);</b>
<b class="nc">&nbsp;                    trailerPos = trainPath.get(stepNumber);</b>
<b class="nc">&nbsp;                    trailer.setPosition(trailerPos);</b>
<b class="nc">&nbsp;                    if ((tractor.getPassedThroughFacing().size() - trailerPositionOffset) &gt;= 0) {</b>
<b class="nc">&nbsp;                        trailer.setFacing(tractor.getPassedThroughFacing().get(tractor.getPassedThroughFacing().size() - (int) trailerPositionOffset));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // trailers are immobile by default. Match the tractor&#39;s movement here
<b class="nc">&nbsp;            trailer.delta_distance = tractor.delta_distance;</b>
<b class="nc">&nbsp;            trailer.moved = tractor.moved;</b>
<b class="nc">&nbsp;            trailer.setSecondaryFacing(trailer.getFacing());</b>
<b class="nc">&nbsp;            trailer.setDone(true);</b>
<b class="nc">&nbsp;            entityUpdate(eId);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flips the order of a tractor&#39;s towed trailers list by index and
&nbsp;     * adds their starting coordinates to a list of hexes the tractor passed through
&nbsp;     *
&nbsp;     * @return  Returns the properly sorted list of all train coordinates
&nbsp;     */
&nbsp;    public List&lt;Coords&gt; initializeTrailerCoordinates(Entity tractor, List&lt;Integer&gt; allTowedTrailers) {
<b class="nc">&nbsp;        List&lt;Coords&gt; trainCoords = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int trId : allTowedTrailers) {</b>
<b class="nc">&nbsp;            Entity trailer = game.getEntity(trId);</b>
<b class="nc">&nbsp;            Coords position = trailer.getPosition();</b>
&nbsp;            //Duplicates foul up the works...
<b class="nc">&nbsp;            if (!trainCoords.contains(position)) {</b>
<b class="nc">&nbsp;                trainCoords.add(position);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Coords c : tractor.getPassedThrough() ) {</b>
<b class="nc">&nbsp;            if (!trainCoords.contains(c)) {</b>
<b class="nc">&nbsp;                trainCoords.add(c);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return trainCoords;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether the entity used MASC or a supercharger during movement, and if so checks for
&nbsp;     * and resolves any failures.
&nbsp;     *
&nbsp;     * @param entity  The unit using MASC/supercharger
&nbsp;     * @param md      The current &lt;code&gt;MovePath&lt;/code&gt;
&nbsp;     * @return        Whether the unit failed the check
&nbsp;     */
&nbsp;    private boolean checkMASCFailure(Entity entity, MovePath md) {
<b class="nc">&nbsp;        HashMap&lt;Integer, List&lt;CriticalSlot&gt;&gt; crits = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; vReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        if (entity.checkForMASCFailure(md, vReport, crits)) {</b>
<b class="nc">&nbsp;            boolean mascFailure = true;</b>
&nbsp;            // Check to see if the pilot can reroll due to Edge
<b class="nc">&nbsp;            if (entity.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.getCrew().getOptions()</b>
<b class="nc">&nbsp;                            .booleanOption(OptionsConstants.EDGE_WHEN_MASC_FAILS)) {</b>
<b class="nc">&nbsp;                entity.getCrew().decreaseEdge();</b>
&nbsp;                // Need to reset the MASCUsed flag
<b class="nc">&nbsp;                entity.setMASCUsed(false);</b>
&nbsp;                // Report to notify user that masc check was rerolled
<b class="nc">&nbsp;                Report masc_report = new Report(6501);</b>
<b class="nc">&nbsp;                masc_report.subject = entity.getId();</b>
<b class="nc">&nbsp;                masc_report.indent(2);</b>
<b class="nc">&nbsp;                masc_report.addDesc(entity);</b>
<b class="nc">&nbsp;                vReport.add(masc_report);</b>
&nbsp;                // Report to notify user how much edge pilot has left
<b class="nc">&nbsp;                masc_report = new Report(6510);</b>
<b class="nc">&nbsp;                masc_report.subject = entity.getId();</b>
<b class="nc">&nbsp;                masc_report.indent(2);</b>
<b class="nc">&nbsp;                masc_report.addDesc(entity);</b>
<b class="nc">&nbsp;                masc_report.add(entity.getCrew().getOptions()</b>
<b class="nc">&nbsp;                        .intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;                vReport.addElement(masc_report);</b>
&nbsp;                // Recheck MASC failure
<b class="nc">&nbsp;                if (!entity.checkForMASCFailure(md, vReport, crits)) {</b>
&nbsp;                    // The reroll passed, don&#39;t process the failure
<b class="nc">&nbsp;                    mascFailure = false;</b>
<b class="nc">&nbsp;                    addReport(vReport);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Check for failure and process it
<b class="nc">&nbsp;            if (mascFailure) {</b>
<b class="nc">&nbsp;                addReport(vReport);</b>
&nbsp;                // If this is supercharger failure we need to damage the supercharger as well as
&nbsp;                // the additional criticals. For mechs this requires the additional step of finding
&nbsp;                // the slot and marking it as hit so it can&#39;t absorb future damage.
<b class="nc">&nbsp;                Mounted supercharger = entity.getSuperCharger();</b>
<b class="nc">&nbsp;                if ((null != supercharger) &amp;&amp; supercharger.curMode().equals(&quot;Armed&quot;)) {</b>
<b class="nc">&nbsp;                    if (entity.hasETypeFlag(Entity.ETYPE_MECH)) {</b>
<b class="nc">&nbsp;                        final int loc = supercharger.getLocation();</b>
<b class="nc">&nbsp;                        for (int slot = 0; slot &lt; entity.getNumberOfCriticals(loc); slot++) {</b>
<b class="nc">&nbsp;                            final CriticalSlot crit = entity.getCritical(loc, slot);</b>
<b class="nc">&nbsp;                            if ((null != crit) &amp;&amp; (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                                    &amp;&amp; (crit.getMount().getType().equals(supercharger.getType()))) {</b>
<b class="nc">&nbsp;                                addReport(applyCriticalHit(entity, loc, crit,</b>
&nbsp;                                        true, 0, false));
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        supercharger.setHit(true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    supercharger.setMode(&quot;Off&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                for (Integer loc : crits.keySet()) {</b>
<b class="nc">&nbsp;                    List&lt;CriticalSlot&gt; lcs = crits.get(loc);</b>
<b class="nc">&nbsp;                    for (CriticalSlot cs : lcs) {</b>
&nbsp;                        // HACK: if loc is -1, we need to deal motive damage to
&nbsp;                        // the tank, the severity of which is stored in the critslot index
<b class="nc">&nbsp;                        if (loc == -1) {</b>
<b class="nc">&nbsp;                            addReport(vehicleMotiveDamage((Tank) entity,</b>
<b class="nc">&nbsp;                                    0, true, cs.getIndex()));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            addReport(applyCriticalHit(entity, loc, cs,</b>
&nbsp;                                    true, 0, false));
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // do any PSR immediately
<b class="nc">&nbsp;                addReport(resolvePilotingRolls(entity));</b>
<b class="nc">&nbsp;                game.resetPSRs(entity);</b>
&nbsp;                // let the player replot their move as MP might be changed
<b class="nc">&nbsp;                md.clear();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            addReport(vReport);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * LAMs or QuadVees converting from leg mode may force any carried infantry (including swarming)
&nbsp;     * to fall into the current hex. A LAM may suffer damage.
&nbsp;     *
&nbsp;     * @param carrier       The &lt;code&gt;Entity&lt;/code&gt; making the conversion.
&nbsp;     * @param rider         The &lt;code&gt;Entity&lt;/code&gt; possibly being forced off.
&nbsp;     * @param curPos        The coordinates of the hex where the conversion starts.
&nbsp;     * @param curFacing     The carrier&#39;s facing when conversion starts.
&nbsp;     * @param automatic     Whether the infantry falls automatically. If false, an anti-mech roll is made
&nbsp;     *                      to see whether it stays mounted.
&nbsp;     * @param infDamage     If true, the infantry takes falling damage, +1D6 for conventional.
&nbsp;     * @param carrierDamage If true, the carrier takes damage from converting while carrying infantry.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; checkDropBAFromConverting(Entity carrier, Entity rider, Coords curPos, int curFacing,
&nbsp;            boolean automatic, boolean infDamage, boolean carrierDamage) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        PilotingRollData prd = rider.getBasePilotingRoll(EntityMovementType.MOVE_NONE);</b>
<b class="nc">&nbsp;        boolean falls = automatic;</b>
<b class="nc">&nbsp;        if (automatic) {</b>
<b class="nc">&nbsp;            r = new Report(2465);</b>
<b class="nc">&nbsp;            r.subject = rider.getId();</b>
<b class="nc">&nbsp;            r.addDesc(rider);</b>
<b class="nc">&nbsp;            r.addDesc(carrier);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(2460);</b>
<b class="nc">&nbsp;            r.subject = rider.getId();</b>
<b class="nc">&nbsp;            r.addDesc(rider);</b>
<b class="nc">&nbsp;            r.add(prd.getValueAsString());</b>
<b class="nc">&nbsp;            r.addDesc(carrier);</b>
<b class="nc">&nbsp;            final int diceRoll = carrier.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            if (diceRoll &lt; prd.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                falls = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(true);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        reports.add(r);</b>
<b class="nc">&nbsp;        if (falls) {</b>
<b class="nc">&nbsp;            if (carrier.getSwarmAttackerId() == rider.getId()) {</b>
<b class="nc">&nbsp;                rider.setDone(true);</b>
<b class="nc">&nbsp;                carrier.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                rider.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;            } else if (!unloadUnit(carrier, rider, curPos, curFacing, 0)) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Server was told to unload &quot;</b>
<b class="nc">&nbsp;                                + rider.getDisplayName() + &quot; from &quot;</b>
<b class="nc">&nbsp;                                + carrier.getDisplayName() + &quot; into &quot;</b>
<b class="nc">&nbsp;                                + curPos.getBoardNum());</b>
<b class="nc">&nbsp;                return reports;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (infDamage) {</b>
<b class="nc">&nbsp;                reports.addAll(doEntityFall(rider, curPos, 2, prd));</b>
<b class="nc">&nbsp;                if (rider.getEntityType() == Entity.ETYPE_INFANTRY) {</b>
<b class="nc">&nbsp;                    int extra = Compute.d6();</b>
<b class="nc">&nbsp;                    reports.addAll(damageEntity(rider, new HitData(Infantry.LOC_INFANTRY), extra));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (carrierDamage) {</b>
&nbsp;                //Report the possibility of a critical hit.
<b class="nc">&nbsp;                r = new Report(2470);</b>
<b class="nc">&nbsp;                r.subject = carrier.getId();</b>
<b class="nc">&nbsp;                r.addDesc(carrier);</b>
<b class="nc">&nbsp;                reports.addElement(r);</b>
<b class="nc">&nbsp;                int mod = 0;</b>
<b class="nc">&nbsp;                if (rider.getEntityType() == Entity.ETYPE_INFANTRY) {</b>
<b class="nc">&nbsp;                    mod = -2;</b>
&nbsp;                }
<b class="nc">&nbsp;                HitData hit = carrier.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                reports.addAll(criticalEntity(carrier, hit.getLocation(), false, mod, 0));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handles a pointblank shot for hidden units, which must request feedback
&nbsp;     * from the client of the player who owns the hidden unit.
&nbsp;     * @return Returns true if a point-blank shot was taken, otherwise false
&nbsp;     */
&nbsp;    private boolean processPointblankShotCFR(Entity hidden, Entity target) {
<b class="nc">&nbsp;        sendPointBlankShotCFR(hidden, target);</b>
<b class="nc">&nbsp;        boolean firstPacket = true;</b>
&nbsp;        // Keep processing until we get a response
&nbsp;        while (true) {
<b class="nc">&nbsp;            synchronized (cfrPacketQueue) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    while (cfrPacketQueue.isEmpty()) {</b>
<b class="nc">&nbsp;                        cfrPacketQueue.wait();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // Get the packet, if there&#39;s something to get
&nbsp;                ReceivedPacket rp;
<b class="nc">&nbsp;                if (cfrPacketQueue.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    rp = cfrPacketQueue.poll();</b>
<b class="nc">&nbsp;                    int cfrType = rp.packet.getIntValue(0);</b>
&nbsp;                    // Make sure we got the right type of response
<b class="nc">&nbsp;                    if (cfrType != Packet.COMMAND_CFR_HIDDEN_PBS) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a &quot; + &quot;COMMAND_CFR_HIDDEN_PBS CFR packet, &quot; </b>
&nbsp;                                + &quot;received: &quot; + cfrType);
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Check packet came from right ID
<b class="nc">&nbsp;                    if (rp.connId != hidden.getOwnerId()) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a &quot; + &quot;COMMAND_CFR_HIDDEN_PBS CFR packet &quot; </b>
<b class="nc">&nbsp;                                + &quot;from player  &quot; + hidden.getOwnerId()</b>
&nbsp;                                + &quot; but instead it came from player &quot; + rp.connId);
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else { // If no packets, wait again</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // First packet indicates whether the PBS is taken or declined
<b class="nc">&nbsp;                if (firstPacket) {</b>
&nbsp;                    // Check to see if the client declined the PBS
<b class="nc">&nbsp;                    if (rp.packet.getObject(1) == null) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        firstPacket = false;</b>
&nbsp;                        // Notify other clients, so they can display a message
<b class="nc">&nbsp;                        for (IPlayer p : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;                            if (p.getId() == hidden.getOwnerId()) {</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            send(p.getId(), new Packet(</b>
&nbsp;                                    Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,
&nbsp;                                    new Object[] {
<b class="nc">&nbsp;                                            Packet.COMMAND_CFR_HIDDEN_PBS,</b>
<b class="nc">&nbsp;                                            Entity.NONE, Entity.NONE }));</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                        // Update all clients with the position of the PBS
<b class="nc">&nbsp;                        entityUpdate(target.getId());</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // The second packet contains the attacks to process
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;                Vector&lt;EntityAction&gt; attacks = (Vector&lt;EntityAction&gt;) rp.packet.getObject(1);</b>
&nbsp;                // Mark the hidden unit as having taken a PBS
<b class="nc">&nbsp;                hidden.setMadePointblankShot(true);</b>
&nbsp;                // Process the Actions
<b class="nc">&nbsp;                for (EntityAction ea : attacks) {</b>
<b class="nc">&nbsp;                    Entity entity = game.getEntity(ea.getEntityId());</b>
<b class="nc">&nbsp;                    if (ea instanceof TorsoTwistAction) {</b>
<b class="nc">&nbsp;                        TorsoTwistAction tta = (TorsoTwistAction) ea;</b>
<b class="nc">&nbsp;                        if (entity.canChangeSecondaryFacing()) {</b>
<b class="nc">&nbsp;                            entity.setSecondaryFacing(tta.getFacing());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (ea instanceof FlipArmsAction) {</b>
<b class="nc">&nbsp;                        FlipArmsAction faa = (FlipArmsAction) ea;</b>
<b class="nc">&nbsp;                        entity.setArmsFlipped(faa.getIsFlipped());</b>
<b class="nc">&nbsp;                    } else if (ea instanceof SearchlightAttackAction) {</b>
<b class="nc">&nbsp;                        boolean hexesAdded = ((SearchlightAttackAction) ea).setHexesIlluminated(game);</b>
&nbsp;                        // If we added new hexes, send them to all players.
&nbsp;                        // These are spotlights at night, you know they&#39;re
&nbsp;                        // there.
<b class="nc">&nbsp;                        if (hexesAdded) {</b>
<b class="nc">&nbsp;                            send(createIlluminatedHexesPacket());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        SearchlightAttackAction saa = (SearchlightAttackAction) ea;</b>
<b class="nc">&nbsp;                        addReport(saa.resolveAction(game));</b>
<b class="nc">&nbsp;                    } else if (ea instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                        WeaponAttackAction waa = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                        Entity ae = game.getEntity(waa.getEntityId());</b>
<b class="nc">&nbsp;                        Mounted m = ae.getEquipment(waa.getWeaponId());</b>
<b class="nc">&nbsp;                        Weapon w = (Weapon) m.getType();</b>
&nbsp;                        // Track attacks original target, for things like swarm LRMs
<b class="nc">&nbsp;                        waa.setOriginalTargetId(waa.getTargetId());</b>
<b class="nc">&nbsp;                        waa.setOriginalTargetType(waa.getTargetType());</b>
<b class="nc">&nbsp;                        AttackHandler ah = w.fire(waa, game, this);</b>
<b class="nc">&nbsp;                        if (ah != null) {</b>
<b class="nc">&nbsp;                            ah.setStrafing(waa.isStrafing());</b>
<b class="nc">&nbsp;                            ah.setStrafingFirstShot(waa.isStrafingFirstShot());</b>
<b class="nc">&nbsp;                            game.addAttack(ah);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // Now handle the attacks
&nbsp;                // Set to the firing phase, so the attacks handle
<b class="nc">&nbsp;                IGame.Phase currentPhase = game.getPhase();</b>
<b class="nc">&nbsp;                game.setPhase(IGame.Phase.PHASE_FIRING);</b>
&nbsp;                // Handle attacks
<b class="nc">&nbsp;                handleAttacks(true);</b>
&nbsp;                // Restore Phase
<b class="nc">&nbsp;                game.setPhase(currentPhase);</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public int processTeleguidedMissileCFR(int playerId, List&lt;Integer&gt; targetIds, List&lt;Integer&gt; toHitValues) {
<b class="nc">&nbsp;        sendTeleguidedMissileCFR(playerId, targetIds, toHitValues);</b>
&nbsp;        while (true) {
<b class="nc">&nbsp;            synchronized (cfrPacketQueue) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    while (cfrPacketQueue.isEmpty()) {</b>
<b class="nc">&nbsp;                        cfrPacketQueue.wait();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    return 0;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // Get the packet, if there&#39;s something to get
&nbsp;                ReceivedPacket rp;
<b class="nc">&nbsp;                if (cfrPacketQueue.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    rp = cfrPacketQueue.poll();</b>
<b class="nc">&nbsp;                    int cfrType = rp.packet.getIntValue(0);</b>
&nbsp;                    // Make sure we got the right type of response
<b class="nc">&nbsp;                    if (cfrType != Packet.COMMAND_CFR_TELEGUIDED_TARGET) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a &quot; </b>
&nbsp;                                + &quot;COMMAND_CFR_TELEGUIDED_TARGET CFR packet, &quot; + &quot;received: &quot; + cfrType);
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Check packet came from right ID
<b class="nc">&nbsp;                    if (rp.connId != playerId) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a &quot; </b>
&nbsp;                                + &quot;COMMAND_CFR_TELEGUIDED_TARGET CFR packet &quot; + &quot;from player  &quot; + playerId
&nbsp;                                + &quot; but instead it came from player &quot; + rp.connId);
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return (int)rp.packet.getData()[1];</b>
&nbsp;                } // If no packets, wait again
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public int processTAGTargetCFR(int playerId, List&lt;Integer&gt; targetIds, List&lt;Integer&gt; targetTypes) {
<b class="nc">&nbsp;        sendTAGTargetCFR(playerId, targetIds, targetTypes);</b>
&nbsp;        while (true) {
<b class="nc">&nbsp;            synchronized (cfrPacketQueue) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    while (cfrPacketQueue.isEmpty()) {</b>
<b class="nc">&nbsp;                        cfrPacketQueue.wait();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    return 0;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // Get the packet, if there&#39;s something to get
&nbsp;                ReceivedPacket rp;
<b class="nc">&nbsp;                if (cfrPacketQueue.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    rp = cfrPacketQueue.poll();</b>
<b class="nc">&nbsp;                    int cfrType = rp.packet.getIntValue(0);</b>
&nbsp;                    // Make sure we got the right type of response
<b class="nc">&nbsp;                    if (cfrType != Packet.COMMAND_CFR_TAG_TARGET) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a &quot; + &quot;COMMAND_CFR_TAG_TARGET CFR packet, &quot;</b>
&nbsp;                                        + &quot;received: &quot; + cfrType);
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Check packet came from right ID
<b class="nc">&nbsp;                    if (rp.connId != playerId) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a &quot; + &quot;COMMAND_CFR_TAG_TARGET CFR packet &quot;</b>
&nbsp;                                        + &quot;from player  &quot; + playerId
&nbsp;                                        + &quot; but instead it came from player &quot; + rp.connId);
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return (int) rp.packet.getData()[1];</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If an aero unit takes off in the same turn that other units loaded, then
&nbsp;     * it risks damage to itself and those units
&nbsp;     *
&nbsp;     * @param a - The &lt;code&gt;Aero&lt;/code&gt; taking off
&nbsp;     */
&nbsp;    private void checkForTakeoffDamage(IAero a) {
<b class="nc">&nbsp;        boolean unsecured = false;</b>
<b class="nc">&nbsp;        for (Entity loaded : ((Entity)a).getLoadedUnits()) {</b>
<b class="nc">&nbsp;            if (loaded.wasLoadedThisTurn() &amp;&amp; !(loaded instanceof Infantry)) {</b>
<b class="nc">&nbsp;                unsecured = true;</b>
&nbsp;                // uh-oh, you forgot your seat belt
<b class="nc">&nbsp;                Report r = new Report(6800);</b>
<b class="nc">&nbsp;                r.subject = loaded.getId();</b>
<b class="nc">&nbsp;                r.addDesc(loaded);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                int damage = 25;</b>
<b class="nc">&nbsp;                ToHitData toHit = new ToHitData();</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    HitData hit = loaded.rollHitLocation(toHit.getHitTable(), ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(loaded, hit, 5, false,</b>
&nbsp;                            DamageType.NONE, false, true, false));
<b class="nc">&nbsp;                    damage -= 5;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (unsecured) {</b>
&nbsp;            // roll hit location to get a new critical
<b class="nc">&nbsp;            HitData hit = ((Entity)a).rollHitLocation(ToHitData.HIT_ABOVE, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;            addReport(applyCriticalHit((Entity)a, hit.getLocation(), new CriticalSlot(</b>
<b class="nc">&nbsp;                    0, ((Aero)a).getPotCrit()), true, 1, false));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Delivers a thunder-aug shot to the targeted hex area. Thunder-Augs are 7
&nbsp;     * hexes, though, so...
&nbsp;     *
&nbsp;     * @param damage
&nbsp;     *            The per-hex density of the incoming minefield; that is, the
&nbsp;     *            final value with any modifiers (such as halving and rounding
&nbsp;     *            just for &lt;em&gt;being&lt;/em&gt; T-Aug) already applied.
&nbsp;     */
&nbsp;    public void deliverThunderAugMinefield(Coords coords, int playerId, int damage, int entityId) {
&nbsp;        Coords mfCoord;
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 7; dir++) {</b>
&nbsp;            // May need to reset here for each new hex.
<b class="nc">&nbsp;            int hexDamage = damage;</b>
<b class="nc">&nbsp;            if (dir == 6) {// The targeted hex.</b>
<b class="nc">&nbsp;                mfCoord = coords;</b>
&nbsp;            } else {// The hex in the dir direction from the targeted hex.
<b class="nc">&nbsp;                mfCoord = coords.translated(dir);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Only if this is on the board...
<b class="nc">&nbsp;            if (game.getBoard().contains(mfCoord)) {</b>
<b class="nc">&nbsp;                Minefield minefield = null;</b>
<b class="nc">&nbsp;                Enumeration&lt;Minefield&gt; minefields = game.getMinefields(mfCoord).elements();</b>
&nbsp;                // Check if there already are Thunder minefields in the hex.
<b class="nc">&nbsp;                while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    Minefield mf = minefields.nextElement();</b>
<b class="nc">&nbsp;                    if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {</b>
<b class="nc">&nbsp;                        minefield = mf;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                // Did we find a Thunder minefield in the hex?
&nbsp;                // N.B. damage Thunder minefields equals the number of
&nbsp;                // missiles, divided by two, rounded up.
<b class="nc">&nbsp;                if (minefield == null) {</b>
&nbsp;                    // Nope. Create a new Thunder minefield
<b class="nc">&nbsp;                    minefield = Minefield.createMinefield(mfCoord, playerId,</b>
&nbsp;                            Minefield.TYPE_CONVENTIONAL, hexDamage);
<b class="nc">&nbsp;                    game.addMinefield(minefield);</b>
<b class="nc">&nbsp;                    checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
<b class="nc">&nbsp;                } else if (minefield.getDensity() &lt; Minefield.MAX_DAMAGE) {</b>
&nbsp;                    // Yup. Replace the old one.
<b class="nc">&nbsp;                    removeMinefield(minefield);</b>
<b class="nc">&nbsp;                    hexDamage += minefield.getDensity();</b>
&nbsp;
&nbsp;                    // Damage from Thunder minefields are capped.
<b class="nc">&nbsp;                    if (hexDamage &gt; Minefield.MAX_DAMAGE) {</b>
<b class="nc">&nbsp;                        hexDamage = Minefield.MAX_DAMAGE;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    minefield.setDensity(hexDamage);</b>
<b class="nc">&nbsp;                    game.addMinefield(minefield);</b>
<b class="nc">&nbsp;                    checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
&nbsp;                }
&nbsp;            } // End coords-on-board
&nbsp;        } // Handle the next coords
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a Thunder minefield to the hex.
&nbsp;     *
&nbsp;     * @param coords   the minefield&#39;s coordinates
&nbsp;     * @param playerId the deploying player&#39;s id
&nbsp;     * @param damage   the amount of damage the minefield does
&nbsp;     * @param entityId an entity that might spot the minefield
&nbsp;     */
&nbsp;    public void deliverThunderMinefield(Coords coords, int playerId, int damage, int entityId) {
<b class="nc">&nbsp;        Minefield minefield = null;</b>
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; minefields = game.getMinefields(coords).elements();</b>
&nbsp;        // Check if there already are Thunder minefields in the hex.
<b class="nc">&nbsp;        while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield mf = minefields.nextElement();</b>
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {</b>
<b class="nc">&nbsp;                minefield = mf;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Create a new Thunder minefield
<b class="nc">&nbsp;        if (minefield == null) {</b>
<b class="nc">&nbsp;            minefield = Minefield.createMinefield(coords, playerId, Minefield.TYPE_CONVENTIONAL, damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
<b class="nc">&nbsp;        } else if (minefield.getDensity() &lt; Minefield.MAX_DAMAGE) {</b>
&nbsp;            // Add to the old one
<b class="nc">&nbsp;            removeMinefield(minefield);</b>
<b class="nc">&nbsp;            int oldDamage = minefield.getDensity();</b>
<b class="nc">&nbsp;            damage += oldDamage;</b>
<b class="nc">&nbsp;            damage = Math.min(damage, Minefield.MAX_DAMAGE);</b>
<b class="nc">&nbsp;            minefield.setDensity(damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a Thunder Inferno minefield to the hex.
&nbsp;     *
&nbsp;     * @param coords   the minefield&#39;s coordinates
&nbsp;     * @param playerId the deploying player&#39;s id
&nbsp;     * @param damage   the amount of damage the minefield does
&nbsp;     * @param entityId an entity that might spot the minefield
&nbsp;     */
&nbsp;    public void deliverThunderInfernoMinefield(Coords coords, int playerId, int damage, int entityId) {
<b class="nc">&nbsp;        Minefield minefield = null;</b>
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; minefields = game.getMinefields(coords).elements();</b>
&nbsp;        // Check if there already are Thunder minefields in the hex.
<b class="nc">&nbsp;        while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield mf = minefields.nextElement();</b>
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_INFERNO) {</b>
<b class="nc">&nbsp;                minefield = mf;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Create a new Thunder Inferno minefield
<b class="nc">&nbsp;        if (minefield == null) {</b>
<b class="nc">&nbsp;            minefield = Minefield.createMinefield(coords, playerId, Minefield.TYPE_INFERNO, damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
<b class="nc">&nbsp;        } else if (minefield.getDensity() &lt; Minefield.MAX_DAMAGE) {</b>
&nbsp;            // Add to the old one
<b class="nc">&nbsp;            removeMinefield(minefield);</b>
<b class="nc">&nbsp;            int oldDamage = minefield.getDensity();</b>
<b class="nc">&nbsp;            damage += oldDamage;</b>
<b class="nc">&nbsp;            damage = Math.min(damage, Minefield.MAX_DAMAGE);</b>
<b class="nc">&nbsp;            minefield.setDensity(damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Delivers an artillery FASCAM shot to the targeted hex area.
&nbsp;     */
&nbsp;    public void deliverFASCAMMinefield(Coords coords, int playerId, int damage, int entityId) {
&nbsp;        // Only if this is on the board...
<b class="nc">&nbsp;        if (game.getBoard().contains(coords)) {</b>
<b class="nc">&nbsp;            Minefield minefield = null;</b>
<b class="nc">&nbsp;            Enumeration&lt;Minefield&gt; minefields = game.getMinefields(coords).elements();</b>
&nbsp;            // Check if there already are Thunder minefields in the hex.
<b class="nc">&nbsp;            while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Minefield mf = minefields.nextElement();</b>
<b class="nc">&nbsp;                if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {</b>
<b class="nc">&nbsp;                    minefield = mf;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // Did we find a Thunder minefield in the hex?
<b class="nc">&nbsp;            if (minefield == null) {</b>
<b class="nc">&nbsp;                minefield = Minefield.createMinefield(coords, playerId,</b>
&nbsp;                        Minefield.TYPE_CONVENTIONAL, damage);
<b class="nc">&nbsp;                game.addMinefield(minefield);</b>
<b class="nc">&nbsp;                checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
<b class="nc">&nbsp;            } else if (minefield.getDensity() &lt; Minefield.MAX_DAMAGE) {</b>
&nbsp;                // Add to the old one.
<b class="nc">&nbsp;                removeMinefield(minefield);</b>
<b class="nc">&nbsp;                int oldDamage = minefield.getDensity();</b>
<b class="nc">&nbsp;                damage += oldDamage;</b>
<b class="nc">&nbsp;                damage = Math.min(damage, Minefield.MAX_DAMAGE);</b>
<b class="nc">&nbsp;                minefield.setDensity(damage);</b>
<b class="nc">&nbsp;                game.addMinefield(minefield);</b>
<b class="nc">&nbsp;                checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
&nbsp;            }
&nbsp;        } // End coords-on-board
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a Thunder-Active minefield to the hex.
&nbsp;     * @param coords   the minefield&#39;s coordinates
&nbsp;     * @param playerId the deploying player&#39;s id
&nbsp;     * @param damage   the amount of damage the minefield does
&nbsp;     * @param entityId an entity that might spot the minefield
&nbsp;     */
&nbsp;    public void deliverThunderActiveMinefield(Coords coords, int playerId, int damage, int entityId) {
<b class="nc">&nbsp;        Minefield minefield = null;</b>
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; minefields = game.getMinefields(coords).elements();</b>
&nbsp;        // Check if there already are Thunder minefields in the hex.
<b class="nc">&nbsp;        while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield mf = minefields.nextElement();</b>
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_ACTIVE) {</b>
<b class="nc">&nbsp;                minefield = mf;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Create a new Thunder-Active minefield
<b class="nc">&nbsp;        if (minefield == null) {</b>
<b class="nc">&nbsp;            minefield = Minefield.createMinefield(coords, playerId, Minefield.TYPE_ACTIVE, damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
<b class="nc">&nbsp;        } else if (minefield.getDensity() &lt; Minefield.MAX_DAMAGE) {</b>
&nbsp;            // Add to the old one
<b class="nc">&nbsp;            removeMinefield(minefield);</b>
<b class="nc">&nbsp;            int oldDamage = minefield.getDensity();</b>
<b class="nc">&nbsp;            damage += oldDamage;</b>
<b class="nc">&nbsp;            damage = Math.min(damage, Minefield.MAX_DAMAGE);</b>
<b class="nc">&nbsp;            minefield.setDensity(damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a Thunder-Vibrabomb minefield to the hex.
&nbsp;     */
&nbsp;    public void deliverThunderVibraMinefield(Coords coords, int playerId,
&nbsp;            int damage, int sensitivity, int entityId) {
<b class="nc">&nbsp;        Minefield minefield = null;</b>
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; minefields = game.getMinefields(coords).elements();</b>
&nbsp;        // Check if there already are Thunder minefields in the hex.
<b class="nc">&nbsp;        while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield mf = minefields.nextElement();</b>
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {</b>
<b class="nc">&nbsp;                minefield = mf;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Create a new Thunder-Vibra minefield
<b class="nc">&nbsp;        if (minefield == null) {</b>
<b class="nc">&nbsp;            minefield = Minefield.createMinefield(coords, playerId,</b>
&nbsp;                    Minefield.TYPE_VIBRABOMB, damage, sensitivity);
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            game.addVibrabomb(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
<b class="nc">&nbsp;        } else if (minefield.getDensity() &lt; Minefield.MAX_DAMAGE) {</b>
&nbsp;            // Add to the old one
<b class="nc">&nbsp;            removeMinefield(minefield);</b>
<b class="nc">&nbsp;            int oldDamage = minefield.getDensity();</b>
<b class="nc">&nbsp;            damage += oldDamage;</b>
<b class="nc">&nbsp;            damage = Math.min(damage, Minefield.MAX_DAMAGE);</b>
<b class="nc">&nbsp;            minefield.setDensity(damage);</b>
<b class="nc">&nbsp;            game.addMinefield(minefield);</b>
<b class="nc">&nbsp;            game.addVibrabomb(minefield);</b>
<b class="nc">&nbsp;            checkForRevealMinefield(minefield, game.getEntity(entityId));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an artillery flare of the given radius above the target
&nbsp;     */
&nbsp;    public void deliverArtilleryFlare(Coords coords, int radius) {
<b class="nc">&nbsp;        Flare flare = new Flare(coords, 5, radius, Flare.F_DRIFTING);</b>
<b class="nc">&nbsp;        game.addFlare(flare);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void deliverMortarFlare(Coords coords, int duration) {
<b class="nc">&nbsp;        Flare flare = new Flare(coords, duration, 1, Flare.F_IGNITED);</b>
<b class="nc">&nbsp;        game.addFlare(flare);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deliver missile smoke
&nbsp;     *
&nbsp;     * @param coords the &lt;code&gt;Coords&lt;/code&gt; where to deliver
&nbsp;     */
&nbsp;
&nbsp;    public void deliverMissileSmoke(Coords coords, int smokeType, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        Report r = new Report(5183, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
&nbsp;        //Report either light or heavy smoke, as appropriate
<b class="nc">&nbsp;        r.choose(smokeType == SmokeCloud.SMOKE_LIGHT);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        createSmoke(coords, smokeType, 3);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, smokeType));</b>
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void deliverSmokeGrenade(Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        Report r = new Report(5200, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        createSmoke(coords, SmokeCloud.SMOKE_LIGHT, 3);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                Terrains.SMOKE, SmokeCloud.SMOKE_LIGHT));
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void deliverSmokeMortar(Coords coords, Vector&lt;Report&gt; vPhaseReport, int duration) {
<b class="nc">&nbsp;        Report r = new Report(5185, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, duration);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                Terrains.SMOKE, SmokeCloud.SMOKE_HEAVY));
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void deliverChaffGrenade(Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        Report r = new Report(5187, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        createSmoke(coords, SmokeCloud.SMOKE_CHAFF_LIGHT, 1);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                Terrains.SMOKE, SmokeCloud.SMOKE_CHAFF_LIGHT));
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deliver artillery smoke
&nbsp;     *
&nbsp;     * @param coords the &lt;code&gt;Coords&lt;/code&gt; where to deliver
&nbsp;     */
&nbsp;    public void deliverArtillerySmoke(Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        Report r = new Report(5185, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        createSmoke(coords, SmokeCloud.SMOKE_HEAVY, 3);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                Terrains.SMOKE, SmokeCloud.SMOKE_HEAVY));
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt;= 5; dir++) {</b>
<b class="nc">&nbsp;            Coords tempcoords = coords.translated(dir);</b>
<b class="nc">&nbsp;            if (!game.getBoard().contains(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (coords.equals(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report(5185, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.add(tempcoords.getBoardNum());</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            createSmoke(tempcoords, SmokeCloud.SMOKE_HEAVY, 3);</b>
<b class="nc">&nbsp;            hex = game.getBoard().getHex(tempcoords);</b>
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                    Terrains.SMOKE, SmokeCloud.SMOKE_HEAVY));
<b class="nc">&nbsp;            sendChangedHex(tempcoords);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deliver LASER inhibiting smoke
&nbsp;     *
&nbsp;     * @param coords the &lt;code&gt;Coords&lt;/code&gt; where to deliver
&nbsp;     */
&nbsp;    public void deliverLIsmoke(Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        Report r = new Report(5186, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        createSmoke(coords, SmokeCloud.SMOKE_LI_HEAVY, 2);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                Terrains.SMOKE, SmokeCloud.SMOKE_LI_HEAVY));
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt;= 5; dir++) {</b>
<b class="nc">&nbsp;            Coords tempcoords = coords.translated(dir);</b>
<b class="nc">&nbsp;            if (!game.getBoard().contains(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (coords.equals(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report(5186, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.add(tempcoords.getBoardNum());</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            createSmoke(tempcoords, SmokeCloud.SMOKE_LI_HEAVY, 2);</b>
<b class="nc">&nbsp;            hex = game.getBoard().getHex(tempcoords);</b>
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                    Terrains.SMOKE, SmokeCloud.SMOKE_LI_HEAVY));
<b class="nc">&nbsp;            sendChangedHex(tempcoords);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deliver artillery inferno
&nbsp;     *
&nbsp;     * @param coords    the &lt;code&gt;Coords&lt;/code&gt; where to deliver
&nbsp;     * @param ae        the attacking &lt;code&gt;entity&lt;code&gt;
&nbsp;     * @param subjectId the &lt;code&gt;int&lt;/code&gt; id of the target
&nbsp;     */
&nbsp;    public void deliverArtilleryInferno(Coords coords, Entity ae,
&nbsp;            int subjectId, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        IHex h = game.getBoard().getHex(coords);</b>
&nbsp;        Report r;
&nbsp;        // Unless there is a fire in the hex already, start one.
<b class="nc">&nbsp;        if (h.terrainLevel(Terrains.FIRE) &lt; Terrains.FIRE_LVL_INFERNO_IV) {</b>
<b class="nc">&nbsp;            ignite(coords, Terrains.FIRE_LVL_INFERNO_IV, vPhaseReport);</b>
&nbsp;        }
&nbsp;        // possibly melt ice and snow
<b class="nc">&nbsp;        if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(meltIceAndSnow(coords, subjectId));</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector(coords)) {</b>
&nbsp;            // TacOps, p. 356 - treat as if hit by 5 inferno missiles
<b class="nc">&nbsp;            r = new Report(6695);</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
&nbsp;            }
<b class="nc">&nbsp;            Vector&lt;Report&gt; vDamageReport = deliverInfernoMissiles(ae, entity, 5, true);</b>
<b class="nc">&nbsp;            Report.indentAll(vDamageReport, 2);</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(vDamageReport);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt;= 5; dir++) {</b>
<b class="nc">&nbsp;            Coords tempcoords = coords.translated(dir);</b>
<b class="nc">&nbsp;            if (!game.getBoard().contains(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (coords.equals(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            h = game.getBoard().getHex(tempcoords);</b>
&nbsp;            // Unless there is a fire in the hex already, start one.
<b class="nc">&nbsp;            if (h.terrainLevel(Terrains.FIRE) &lt; Terrains.FIRE_LVL_INFERNO_IV) {</b>
<b class="nc">&nbsp;                ignite(tempcoords, Terrains.FIRE_LVL_INFERNO_IV, vPhaseReport);</b>
&nbsp;            }
&nbsp;            // possibly melt ice and snow
<b class="nc">&nbsp;            if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(meltIceAndSnow(tempcoords, subjectId));</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Entity entity : game.getEntitiesVector(tempcoords)) {</b>
<b class="nc">&nbsp;                r = new Report(6695);</b>
<b class="nc">&nbsp;                r.indent(3);</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                    Report.addNewline(vPhaseReport);</b>
&nbsp;                }
<b class="nc">&nbsp;                Vector&lt;Report&gt; vDamageReport = deliverInfernoMissiles(ae,</b>
&nbsp;                        entity, 5, true);
<b class="nc">&nbsp;                Report.indentAll(vDamageReport, 2);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(vDamageReport);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void deliverScreen(Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        IHex h = game.getBoard().getHex(coords);</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;        r = new Report(9070, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
&nbsp;        // use level to count the number of screens (since level does not matter
&nbsp;        // in space)
<b class="nc">&nbsp;        int nscreens = h.terrainLevel(Terrains.SCREEN);</b>
<b class="nc">&nbsp;        if (nscreens &gt; 0) {</b>
<b class="nc">&nbsp;            h.removeTerrain(Terrains.SCREEN);</b>
<b class="nc">&nbsp;            h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                    Terrains.SCREEN, nscreens + 1));
&nbsp;        } else {
<b class="nc">&nbsp;            h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                    Terrains.SCREEN, 1));
&nbsp;        }
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deploys a new telemissile entity onto the map
&nbsp;     */
&nbsp;    public void deployTeleMissile(Entity ae, WeaponType wtype, AmmoType atype, int wId,
&nbsp;            int capMisMod, int damage, int armor, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        Report r = new Report(9080);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.addDesc(ae);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        r.add(wtype.getName());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        TeleMissile tele = new TeleMissile(ae, damage, armor,</b>
<b class="nc">&nbsp;                atype.getTonnage(ae), atype.getAmmoType(), capMisMod);</b>
<b class="nc">&nbsp;        tele.setDeployed(true);</b>
<b class="nc">&nbsp;        tele.setId(getFreeEntityId());</b>
<b class="nc">&nbsp;        if (ae instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero a = (Aero) ae;</b>
<b class="nc">&nbsp;            tele.setCurrentVelocity(a.getCurrentVelocity());</b>
<b class="nc">&nbsp;            tele.setNextVelocity(a.getNextVelocity());</b>
<b class="nc">&nbsp;            tele.setVectors(a.getVectors());</b>
<b class="nc">&nbsp;            tele.setFacing(a.getFacing());</b>
&nbsp;        }
&nbsp;        // set velocity and heading the same as parent entity
<b class="nc">&nbsp;        game.addEntity(tele);</b>
<b class="nc">&nbsp;        send(createAddEntityPacket(tele.getId()));</b>
&nbsp;        // make him not get a move this turn
<b class="nc">&nbsp;        tele.setDone(true);</b>
&nbsp;        // place on board
<b class="nc">&nbsp;        tele.setPosition(ae.getPosition());</b>
&nbsp;        // Update the entity
<b class="nc">&nbsp;        entityUpdate(tele.getId());</b>
&nbsp;        // check to see if the launching of this missile removes control of any
&nbsp;        // prior missiles
<b class="nc">&nbsp;        if (ae.getTMTracker().containsLauncher(wId)) {</b>
<b class="nc">&nbsp;            Entity priorMissile = game.getEntity(ae.getTMTracker().getMissile(</b>
&nbsp;                    wId));
<b class="nc">&nbsp;            if (priorMissile instanceof TeleMissile) {</b>
<b class="nc">&nbsp;                ((TeleMissile) priorMissile).setOutContact(true);</b>
&nbsp;                // remove this from the tracker for good measure
<b class="nc">&nbsp;                ae.getTMTracker().removeMissile(wId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // track this missile on the entity
<b class="nc">&nbsp;        ae.getTMTracker().addMissile(wId, tele.getId());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deliver inferno missiles
&nbsp;     *
&nbsp;     * @param ae       the &lt;code&gt;Entity&lt;/code&gt; that fired the missiles
&nbsp;     * @param t        the &lt;code&gt;Targetable&lt;/code&gt; that is the target
&nbsp;     * @param missiles the &lt;code&gt;int&lt;/code&gt; amount of missiles
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; deliverInfernoMissiles(Entity ae, Targetable t, int missiles) {
<b class="nc">&nbsp;        return deliverInfernoMissiles(ae, t, missiles, CalledShot.CALLED_NONE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * deliver inferno missiles
&nbsp;     *
&nbsp;     * @param ae       the &lt;code&gt;Entity&lt;/code&gt; that fired the missiles
&nbsp;     * @param t        the &lt;code&gt;Targetable&lt;/code&gt; that is the target
&nbsp;     * @param missiles the &lt;code&gt;int&lt;/code&gt; amount of missiles
&nbsp;     * @param areaEffect a &lt;code&gt;boolean&lt;/code&gt; indicating whether the attack is from an
&nbsp;     *                   area effect weapon such as Arrow IV inferno, and partial cover should
&nbsp;     *                   be ignored.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; deliverInfernoMissiles(Entity ae, Targetable t, int missiles,
&nbsp;                                                 boolean areaEffect) {
<b class="nc">&nbsp;        return deliverInfernoMissiles(ae, t, missiles, CalledShot.CALLED_NONE, areaEffect);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * deliver inferno missiles
&nbsp;     *
&nbsp;     * @param ae       the &lt;code&gt;Entity&lt;/code&gt; that fired the missiles
&nbsp;     * @param t        the &lt;code&gt;Targetable&lt;/code&gt; that is the target
&nbsp;     * @param missiles the &lt;code&gt;int&lt;/code&gt; amount of missiles
&nbsp;     * @param called   an &lt;code&gt;int&lt;/code&gt; indicated the aiming mode used to fire the
&nbsp;     *                 inferno missiles (for called shots)
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; deliverInfernoMissiles(Entity ae, Targetable t,
&nbsp;            int missiles, int called) {
<b class="nc">&nbsp;        return deliverInfernoMissiles(ae, t, missiles, called, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * deliver inferno missiles
&nbsp;     *
&nbsp;     * @param ae         the &lt;code&gt;Entity&lt;/code&gt; that fired the missiles
&nbsp;     * @param t          the &lt;code&gt;Targetable&lt;/code&gt; that is the target
&nbsp;     * @param missiles   the &lt;code&gt;int&lt;/code&gt; amount of missiles
&nbsp;     * @param called     an &lt;code&gt;int&lt;/code&gt; indicated the aiming mode used to fire the
&nbsp;     *                   inferno missiles (for called shots)
&nbsp;     * @param areaEffect a &lt;code&gt;boolean&lt;/code&gt; indicating whether the attack is from an
&nbsp;     *                   area effect weapon such as Arrow IV inferno, and partial cover should
&nbsp;     *                   be ignored.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; deliverInfernoMissiles(Entity ae, Targetable t,
&nbsp;                int missiles, int called, boolean areaEffect) {
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(t.getPosition());</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        int attId = Entity.NONE;</b>
<b class="nc">&nbsp;        if (null != ae) {</b>
<b class="nc">&nbsp;            attId = ae.getId();</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (t.getTargetType()) {</b>
&nbsp;            case Targetable.TYPE_HEX_ARTILLERY:
&nbsp;                // used for BA inferno explosion
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector(t.getPosition())) {</b>
<b class="nc">&nbsp;                    if (e.getElevation() &gt; hex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                        r = new Report(6685);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(e);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(deliverInfernoMissiles(ae, e, missiles, called));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        int roll = Compute.d6();</b>
<b class="nc">&nbsp;                        r = new Report(3570);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(e);</b>
<b class="nc">&nbsp;                        r.add(roll);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        if (roll &gt;= 5) {</b>
<b class="nc">&nbsp;                            vPhaseReport.addAll(deliverInfernoMissiles(ae, e, missiles, called));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (game.getBoard().getBuildingAt(t.getPosition()) != null) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; vBuildingReport = damageBuilding(game.getBoard().getBuildingAt(t.getPosition()),</b>
<b class="nc">&nbsp;                            2 * missiles, t.getPosition());</b>
<b class="nc">&nbsp;                    for (Report report : vBuildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = attId;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(vBuildingReport);</b>
&nbsp;                }
&nbsp;                // fall through
&nbsp;            case Targetable.TYPE_HEX_CLEAR:
&nbsp;            case Targetable.TYPE_HEX_IGNITE:
&nbsp;                // Report that damage applied to terrain, if there&#39;s TF to damage
<b class="nc">&nbsp;                IHex h = game.getBoard().getHex(t.getPosition());</b>
<b class="nc">&nbsp;                if ((h != null) &amp;&amp; h.hasTerrainfactor()) {</b>
<b class="nc">&nbsp;                    r = new Report(3384);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = attId;</b>
<b class="nc">&nbsp;                    r.add(t.getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                    r.add(missiles * 4);</b>
<b class="nc">&nbsp;                    vPhaseReport.addElement(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                vPhaseReport.addAll(tryClearHex(t.getPosition(), missiles * 4, attId));</b>
<b class="nc">&nbsp;                tryIgniteHex(t.getPosition(), attId, false, true,</b>
&nbsp;                             new TargetRoll(0, &quot;inferno&quot;), -1, vPhaseReport);
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Targetable.TYPE_BLDG_IGNITE:
&nbsp;            case Targetable.TYPE_BUILDING:
<b class="nc">&nbsp;                Vector&lt;Report&gt; vBuildingReport = damageBuilding(game.getBoard().getBuildingAt(t.getPosition()),</b>
<b class="nc">&nbsp;                        2 * missiles, t.getPosition());</b>
<b class="nc">&nbsp;                for (Report report : vBuildingReport) {</b>
<b class="nc">&nbsp;                    report.subject = attId;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(vBuildingReport);</b>
&nbsp;
&nbsp;                // For each missile, check to see if it hits a unit in this hex
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector(t.getPosition())) {</b>
<b class="nc">&nbsp;                    if (e.getElevation() &gt; hex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int m = 0; m &lt; missiles; m++) {</b>
<b class="nc">&nbsp;                        int roll = Compute.d6();</b>
<b class="nc">&nbsp;                        r = new Report(3570);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        r.addDesc(e);</b>
<b class="nc">&nbsp;                        r.add(roll);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        if (roll &gt;= 5) {</b>
<b class="nc">&nbsp;                            Vector&lt;Report&gt; dmgReports = deliverInfernoMissiles(ae, e, 1, called);</b>
<b class="nc">&nbsp;                            for (Report rep : dmgReports) {</b>
<b class="nc">&nbsp;                                rep.indent(4);</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            vPhaseReport.addAll(dmgReports);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Targetable.TYPE_ENTITY:
<b class="nc">&nbsp;                Entity te = (Entity) t;</b>
<b class="nc">&nbsp;                if ((te instanceof Mech) &amp;&amp; (!areaEffect)) {</b>
&nbsp;                    // Bug #1585497: Check for partial cover
<b class="nc">&nbsp;                    int m = missiles;</b>
<b class="nc">&nbsp;                    LosEffects le = LosEffects.calculateLos(game, attId, t);</b>
<b class="nc">&nbsp;                    int cover = le.getTargetCover();</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; coverDamageReports = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                    int heatDamage = 0;</b>
<b class="nc">&nbsp;                    boolean heatReduced = false;</b>
<b class="nc">&nbsp;                    String reductionCause = &quot;&quot;;</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; m; i++) {</b>
<b class="nc">&nbsp;                        int side = Compute.targetSideTable(ae, t, called);</b>
<b class="nc">&nbsp;                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, side);</b>
<b class="nc">&nbsp;                        if (te.removePartialCoverHits(hit.getLocation(), cover, side)) {</b>
<b class="nc">&nbsp;                            missiles--;</b>
&nbsp;                            // Determine if damageable cover is hit
&nbsp;                            int damageableCoverType;
&nbsp;                            Entity coverDropship;
&nbsp;                            Coords coverLoc;
&nbsp;
&nbsp;                            // Determine if there is primary and secondary
&nbsp;                            // cover,
&nbsp;                            // and then determine which one gets hit
<b class="nc">&nbsp;                            if (((cover == LosEffects.COVER_75RIGHT) || (cover == LosEffects.COVER_75LEFT))</b>
&nbsp;                                    // 75% cover has a primary and secondary
&nbsp;                                    || ((cover == LosEffects.COVER_HORIZONTAL)
<b class="nc">&nbsp;                                    &amp;&amp; (le.getDamagableCoverTypeSecondary() != LosEffects.DAMAGABLE_COVER_NONE))) {</b>
&nbsp;                                // Horizontal cover provided by two 25%&#39;s,
&nbsp;                                // so primary and secondary
<b class="nc">&nbsp;                                int hitLoc = hit.getLocation();</b>
&nbsp;                                // Primary stores the left side, from the
&nbsp;                                // perspective of the attacker
<b class="nc">&nbsp;                                if ((hitLoc == Mech.LOC_RLEG) || (hitLoc == Mech.LOC_RT)</b>
&nbsp;                                        || (hitLoc == Mech.LOC_RARM)) {
&nbsp;                                    // Left side is primary
<b class="nc">&nbsp;                                    damageableCoverType = le.getDamagableCoverTypePrimary();</b>
<b class="nc">&nbsp;                                    coverDropship = le.getCoverDropshipPrimary();</b>
<b class="nc">&nbsp;                                    coverLoc = le.getCoverLocPrimary();</b>
&nbsp;                                } else {
&nbsp;                                    // If not left side, then right side,
&nbsp;                                    // which is secondary
<b class="nc">&nbsp;                                    damageableCoverType = le.getDamagableCoverTypeSecondary();</b>
<b class="nc">&nbsp;                                    coverDropship = le.getCoverDropshipSecondary();</b>
<b class="nc">&nbsp;                                    coverLoc = le.getCoverLocSecondary();</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } else { // Only primary cover exists</b>
<b class="nc">&nbsp;                                damageableCoverType = le.getDamagableCoverTypePrimary();</b>
<b class="nc">&nbsp;                                coverDropship = le.getCoverDropshipPrimary();</b>
<b class="nc">&nbsp;                                coverLoc = le.getCoverLocPrimary();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            // Check if we need to damage the cover that
&nbsp;                            // absorbed
&nbsp;                            // the hit.
<b class="nc">&nbsp;                            Vector&lt;Report&gt; coverDamageReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                            if (damageableCoverType == LosEffects.DAMAGABLE_COVER_DROPSHIP) {</b>
<b class="nc">&nbsp;                                r = new Report(3465);</b>
<b class="nc">&nbsp;                                r.addDesc(coverDropship);</b>
<b class="nc">&nbsp;                                r.indent(1);</b>
<b class="nc">&nbsp;                                coverDamageReport = deliverInfernoMissiles(ae,</b>
&nbsp;                                        coverDropship, 1, CalledShot.CALLED_NONE);
<b class="nc">&nbsp;                                coverDamageReport.insertElementAt(r, 0);</b>
<b class="nc">&nbsp;                                for (Report report : coverDamageReport) {</b>
<b class="nc">&nbsp;                                    report.indent(1);</b>
<b class="nc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            } else if (damageableCoverType == LosEffects.DAMAGABLE_COVER_BUILDING) {</b>
<b class="nc">&nbsp;                                BuildingTarget bldgTrgt = new BuildingTarget(coverLoc,</b>
<b class="nc">&nbsp;                                        game.getBoard(), false);</b>
<b class="nc">&nbsp;                                coverDamageReport = deliverInfernoMissiles(ae, bldgTrgt, 1,</b>
&nbsp;                                        CalledShot.CALLED_NONE);
&nbsp;                            }
<b class="nc">&nbsp;                            for (Report report : coverDamageReport) {</b>
<b class="nc">&nbsp;                                report.indent(1);</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            coverDamageReports.addAll(coverDamageReport);</b>
<b class="nc">&nbsp;                        } else { // No partial cover, missile hits</b>
<b class="nc">&nbsp;                            if ((te.getArmor(hit) &gt; 0)</b>
<b class="nc">&nbsp;                                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HEAT_DISSIPATING)) {</b>
<b class="nc">&nbsp;                                heatDamage += 1;</b>
<b class="nc">&nbsp;                                heatReduced = true;</b>
<b class="nc">&nbsp;                                reductionCause = EquipmentType.armorNames[te</b>
<b class="nc">&nbsp;                                        .getArmorType(hit.getLocation())];</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                heatDamage += 2;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (heatReduced) {</b>
<b class="nc">&nbsp;                        r = new Report(3406);</b>
<b class="nc">&nbsp;                        r.add(heatDamage);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
<b class="nc">&nbsp;                        r.add(missiles * 2);</b>
<b class="nc">&nbsp;                        r.add(reductionCause);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(3400);</b>
<b class="nc">&nbsp;                        r.add(heatDamage);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                    te.heatFromExternal += heatDamage;</b>
&nbsp;
<b class="nc">&nbsp;                    if (missiles != m) {</b>
<b class="nc">&nbsp;                        r = new Report(3403);</b>
<b class="nc">&nbsp;                        r.add(m - missiles);</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vPhaseReport.addAll(coverDamageReports);</b>
<b class="nc">&nbsp;                    Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                } else if (te.tracksHeat()) {</b>
&nbsp;                    // ASFs and small craft
<b class="nc">&nbsp;                    r = new Report(3400);</b>
<b class="nc">&nbsp;                    r.add(2 * missiles);</b>
<b class="nc">&nbsp;                    r.subject = te.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    te.heatFromExternal += 2 * missiles;</b>
<b class="nc">&nbsp;                    Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                } else if (te instanceof GunEmplacement){</b>
<b class="nc">&nbsp;                    int direction = Compute.targetSideTable(ae, te, called);</b>
<b class="nc">&nbsp;                    while (missiles-- &gt; 0) {</b>
<b class="nc">&nbsp;                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, direction);</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(damageEntity(te, hit, 2));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if ((te instanceof Tank) || te.isSupportVehicle()) {</b>
<b class="nc">&nbsp;                    int direction = Compute.targetSideTable(ae, te, called);</b>
<b class="nc">&nbsp;                    while (missiles-- &gt; 0) {</b>
<b class="nc">&nbsp;                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, direction);</b>
<b class="nc">&nbsp;                        int critRollMod = 0;</b>
<b class="nc">&nbsp;                        if (!te.isSupportVehicle() || (te.hasArmoredChassis()</b>
<b class="nc">&nbsp;                                &amp;&amp; (te.getBARRating(hit.getLocation()) &gt; 9))) {</b>
<b class="nc">&nbsp;                            critRollMod -= 2;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if ((te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED)</b>
<b class="nc">&nbsp;                                &amp;&amp; (te.getArmor(hit.getLocation()) &gt; 0)) {</b>
<b class="nc">&nbsp;                            critRollMod -= 2;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        vPhaseReport.addAll(criticalEntity(te, hit.getLocation(), hit.isRear(),</b>
&nbsp;                                critRollMod, 0, true));
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (te instanceof ConvFighter) {</b>
&nbsp;                    // CFs take a point SI damage for every three missiles that hit.
&nbsp;                    // Use the heatFromExternal field to carry the remainder in case of multiple inferno hits.
<b class="nc">&nbsp;                    te.heatFromExternal += missiles;</b>
<b class="nc">&nbsp;                    if (te.heatFromExternal &gt;= 3) {</b>
<b class="nc">&nbsp;                        int siDamage = te.heatFromExternal / 3;</b>
<b class="nc">&nbsp;                        te.heatFromExternal %= 3;</b>
<b class="nc">&nbsp;                        final ConvFighter ftr = (ConvFighter) te;</b>
<b class="nc">&nbsp;                        int remaining = Math.max(0,  ftr.getSI() - siDamage);</b>
<b class="nc">&nbsp;                        r = new Report(9146);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.add(siDamage);</b>
<b class="nc">&nbsp;                        r.add(remaining);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        ftr.setSI(remaining);</b>
<b class="nc">&nbsp;                        te.damageThisPhase += siDamage;</b>
<b class="nc">&nbsp;                        if (remaining &lt;= 0) {</b>
&nbsp;                            // Lets auto-eject if we can!
<b class="nc">&nbsp;                            if (ftr.isAutoEject()</b>
<b class="nc">&nbsp;                                    &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                                        || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                                &amp;&amp; ftr.isCondEjectSIDest()))) {</b>
<b class="nc">&nbsp;                                vPhaseReport.addAll(ejectEntity(te, true, false));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            vPhaseReport.addAll(destroyEntity(te,&quot;Structural Integrity Collapse&quot;));</b>
<b class="nc">&nbsp;                            ftr.setSI(0);</b>
<b class="nc">&nbsp;                            if (null != ae) {</b>
<b class="nc">&nbsp;                                creditKill(te, ae);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (te.isLargeCraft()) {</b>
&nbsp;                    // Large craft ignore infernos
<b class="nc">&nbsp;                    r = new Report(1242);</b>
<b class="nc">&nbsp;                    r.subject = te.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                } else if (te instanceof Protomech) {</b>
<b class="nc">&nbsp;                    te.heatFromExternal += missiles;</b>
<b class="nc">&nbsp;                    while (te.heatFromExternal &gt;= 3) {</b>
<b class="nc">&nbsp;                        te.heatFromExternal -= 3;</b>
<b class="nc">&nbsp;                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                        if (hit.getLocation() == Protomech.LOC_NMISS) {</b>
<b class="nc">&nbsp;                            Protomech proto = (Protomech) te;</b>
<b class="nc">&nbsp;                            r = new Report(6035);</b>
<b class="nc">&nbsp;                            r.subject = te.getId();</b>
<b class="nc">&nbsp;                            r.indent(2);</b>
<b class="nc">&nbsp;                            if (proto.isGlider()) {</b>
<b class="nc">&nbsp;                                r.messageId = 6036;</b>
<b class="nc">&nbsp;                                proto.setWingHits(proto.getWingHits() + 1);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            r = new Report(6690);</b>
<b class="nc">&nbsp;                            r.subject = te.getId();</b>
<b class="nc">&nbsp;                            r.indent(2);</b>
<b class="nc">&nbsp;                            r.add(te.getLocationName(hit));</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                            te.destroyLocation(hit.getLocation());</b>
&nbsp;                            // Handle ProtoMech pilot damage
&nbsp;                            // due to location destruction
<b class="nc">&nbsp;                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]</b>
<b class="nc">&nbsp;                                       - ((Protomech) te).getPilotDamageTaken(hit.getLocation());</b>
<b class="nc">&nbsp;                            if (hits &gt; 0) {</b>
<b class="nc">&nbsp;                                vPhaseReport.addAll(damageCrew(te, hits));</b>
<b class="nc">&nbsp;                                ((Protomech) te).setPilotDamageTaken(hit.getLocation(),</b>
<b class="nc">&nbsp;                                        Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (te.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {</b>
<b class="nc">&nbsp;                                vPhaseReport.addAll(destroyEntity(te,</b>
&nbsp;                                        &quot;flaming inferno death&quot;, false, true));
<b class="nc">&nbsp;                                Report.addNewline(vPhaseReport);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (te instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                    if (((BattleArmor) te).isFireResistant()) {</b>
<b class="nc">&nbsp;                        r = new Report(3395);</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(te);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        return vPhaseReport;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    te.heatFromExternal += missiles;</b>
<b class="nc">&nbsp;                    while (te.heatFromExternal &gt;= 3) {</b>
<b class="nc">&nbsp;                        te.heatFromExternal -= 3;</b>
<b class="nc">&nbsp;                        HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                        hit.setEffect(HitData.EFFECT_CRITICAL);</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(damageEntity(te, hit, 1));</b>
<b class="nc">&nbsp;                        Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (te instanceof Infantry) {</b>
<b class="nc">&nbsp;                    HitData hit = new HitData(Infantry.LOC_INFANTRY);</b>
<b class="nc">&nbsp;                    if (te.getInternal(hit) &gt; (3 * missiles)) {</b>
&nbsp;                        // internal structure absorbs all damage
<b class="nc">&nbsp;                        te.setInternal(te.getInternal(hit) - (3 * missiles), hit);</b>
<b class="nc">&nbsp;                        r = new Report(6065);</b>
<b class="nc">&nbsp;                        r.addDesc(te);</b>
<b class="nc">&nbsp;                        r.add(3 * missiles);</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                        r = new Report(6095);</b>
<b class="nc">&nbsp;                        r.add(te.getInternal(hit));</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        vPhaseReport.addAll(destroyEntity(te, &quot;damage&quot;, false));</b>
<b class="nc">&nbsp;                        creditKill(te, ae);</b>
<b class="nc">&nbsp;                        Report.addNewline(vPhaseReport);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for any detonations when an entity enters a minefield, except a
&nbsp;     * vibrabomb.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            - the &lt;code&gt;entity&lt;/code&gt; who entered the minefield
&nbsp;     * @param c
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the minefield
&nbsp;     * @param curElev
&nbsp;     *            - an &lt;code&gt;int&lt;/code&gt; for the elevation of the entity entering
&nbsp;     *            the minefield (used for underwater sea mines)
&nbsp;     * @param isOnGround
&nbsp;     *            - &lt;code&gt;true&lt;/code&gt; if the entity is not in the middle of a
&nbsp;     *            jump
&nbsp;     * @param vMineReport
&nbsp;     *            - the report vector that reports will be added to
&nbsp;     * @return - &lt;code&gt;true&lt;/code&gt; if the entity set off any mines
&nbsp;     */
&nbsp;    private boolean enterMinefield(Entity entity, Coords c, int curElev, boolean isOnGround,
&nbsp;                                   Vector&lt;Report&gt; vMineReport) {
<b class="nc">&nbsp;        return enterMinefield(entity, c, curElev, isOnGround, vMineReport, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for any detonations when an entity enters a minefield, except a
&nbsp;     * vibrabomb.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            - the &lt;code&gt;entity&lt;/code&gt; who entered the minefield
&nbsp;     * @param c
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the minefield
&nbsp;     * @param curElev
&nbsp;     *            - an &lt;code&gt;int&lt;/code&gt; for the elevation of the entity entering
&nbsp;     *            the minefield (used for underwater sea mines)
&nbsp;     * @param isOnGround
&nbsp;     *            - &lt;code&gt;true&lt;/code&gt; if the entity is not in the middle of a
&nbsp;     *            jump
&nbsp;     * @param vMineReport
&nbsp;     *            - the report vector that reports will be added to
&nbsp;     * @param target
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; target number for detonation. If this
&nbsp;     *            will be determined by density, it should be -1
&nbsp;     * @return - &lt;code&gt;true&lt;/code&gt; if the entity set off any mines
&nbsp;     */
&nbsp;    private boolean enterMinefield(Entity entity, Coords c, int curElev, boolean isOnGround,
&nbsp;                                   Vector&lt;Report&gt; vMineReport, int target) {
&nbsp;        Report r;
<b class="nc">&nbsp;        boolean trippedMine = false;</b>
&nbsp;        // flying units cannot trip a mine
<b class="nc">&nbsp;        if (curElev &gt; 0) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check for Mine sweepers
<b class="nc">&nbsp;        Mounted minesweeper = null;</b>
<b class="nc">&nbsp;        for (Mounted m : entity.getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_MINESWEEPER) &amp;&amp; m.isReady()</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.getArmorValue() &gt; 0)) {</b>
<b class="nc">&nbsp;                minesweeper = m;</b>
<b class="nc">&nbsp;                break; // Can only have one minesweeper</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; fieldsToRemove = new Vector&lt;&gt;();</b>
&nbsp;        // loop through mines in this hex
<b class="nc">&nbsp;        for (Minefield mf : game.getMinefields(c)) {</b>
&nbsp;
&nbsp;            // vibrabombs are handled differently
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // if we are in the water, then the sea mine will only blow up if at
&nbsp;            // the right depth
<b class="nc">&nbsp;            if (game.getBoard().getHex(mf.getCoords())</b>
<b class="nc">&nbsp;                    .containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                if ((Math.abs(curElev) != mf.getDepth())</b>
<b class="nc">&nbsp;                    &amp;&amp; (Math.abs(curElev + entity.getHeight()) != mf</b>
<b class="nc">&nbsp;                        .getDepth())) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Check for mine-sweeping.  Vibramines handled elsewhere
<b class="nc">&nbsp;            if ((minesweeper != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((mf.getType() == Minefield.TYPE_CONVENTIONAL)</b>
<b class="nc">&nbsp;                            || (mf.getType() == Minefield.TYPE_ACTIVE)</b>
<b class="nc">&nbsp;                            || (mf.getType() == Minefield.TYPE_INFERNO))) {</b>
&nbsp;                // Check to see if the minesweeper clears
<b class="nc">&nbsp;                int roll = Compute.d6(2);</b>
&nbsp;
&nbsp;                // Report minefield roll
<b class="nc">&nbsp;                if (doBlind()) { // only report if DB, otherwise all players see</b>
<b class="nc">&nbsp;                r = new Report(2152);</b>
<b class="nc">&nbsp;                r.player = mf.getPlayerId();</b>
<b class="nc">&nbsp;                r.add(Minefield.getDisplayableName(mf.getType()));</b>
<b class="nc">&nbsp;                r.add(mf.getCoords().getBoardNum());</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (roll &gt;= 6) {</b>
&nbsp;                    // Report hit
<b class="nc">&nbsp;                    if (doBlind()) {</b>
<b class="nc">&nbsp;                        r = new Report(5543);</b>
<b class="nc">&nbsp;                        r.player = mf.getPlayerId();</b>
<b class="nc">&nbsp;                        vMineReport.add(r);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Clear the minefield
<b class="nc">&nbsp;                    r = new Report(2158);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                    r.add(Minefield.getDisplayableName(mf.getType()), true);</b>
<b class="nc">&nbsp;                    r.add(mf.getCoords().getBoardNum(), true);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    vMineReport.add(r);</b>
<b class="nc">&nbsp;                    fieldsToRemove.add(mf);</b>
&nbsp;
&nbsp;                    // Handle armor value damage
<b class="nc">&nbsp;                    int remainingAV = minesweeper.getArmorValue() - 6;</b>
<b class="nc">&nbsp;                    minesweeper.setArmorValue(Math.max(remainingAV, 0));</b>
&nbsp;
<b class="nc">&nbsp;                    r = new Report(2161);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                    r.add(6);</b>
<b class="nc">&nbsp;                    r.add(Math.max(remainingAV, 0));</b>
<b class="nc">&nbsp;                    vMineReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                    if (remainingAV &lt;= 0) {</b>
<b class="nc">&nbsp;                        minesweeper.setDestroyed(true);</b>
&nbsp;                    }
&nbsp;                    // Check for damage transfer
<b class="nc">&nbsp;                    if (remainingAV &lt; 0) {</b>
<b class="nc">&nbsp;                        int damage = Math.abs(remainingAV);</b>
<b class="nc">&nbsp;                        r = new Report(2162);</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(damage, true);</b>
<b class="nc">&nbsp;                        vMineReport.add(r);</b>
&nbsp;
&nbsp;                        // Damage is dealt to the location of minesweeper
<b class="nc">&nbsp;                        HitData hit = new HitData(minesweeper.getLocation());</b>
<b class="nc">&nbsp;                        Vector&lt;Report&gt; damageReports = damageEntity(entity, hit, damage);</b>
<b class="nc">&nbsp;                        for (Report r1 : damageReports) {</b>
<b class="nc">&nbsp;                            r1.indent(1);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        vMineReport.addAll(damageReports);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Report.addNewline(vMineReport);</b>
&nbsp;                    // If the minefield is cleared, we&#39;re done processing it
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                } else {
&nbsp;                    // Report miss
<b class="nc">&nbsp;                    if (doBlind()) {</b>
<b class="nc">&nbsp;                        r = new Report(5542);</b>
<b class="nc">&nbsp;                        r.player = mf.getPlayerId();</b>
<b class="nc">&nbsp;                        vMineReport.add(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // check whether we have an active mine
<b class="nc">&nbsp;            if ((mf.getType() == Minefield.TYPE_ACTIVE) &amp;&amp; isOnGround) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((mf.getType() != Minefield.TYPE_ACTIVE) &amp;&amp; !isOnGround) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // set the target number
<b class="nc">&nbsp;            if (target == -1) {</b>
<b class="nc">&nbsp;                target = mf.getTrigger();</b>
<b class="nc">&nbsp;                if (mf.getType() == Minefield.TYPE_ACTIVE) {</b>
<b class="nc">&nbsp;                    target = 9;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;                    target += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity.hasAbility(OptionsConstants.MISC_EAGLE_EYES)) {</b>
<b class="nc">&nbsp;                    target += 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((entity.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.WIGE)) {</b>
<b class="nc">&nbsp;                    target = 12;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
&nbsp;
&nbsp;            // Report minefield roll
<b class="nc">&nbsp;            if (doBlind()) { // Only do if DB, otherwise all players will see</b>
<b class="nc">&nbsp;                r = new Report(2151);</b>
<b class="nc">&nbsp;                r.player = mf.getPlayerId();</b>
<b class="nc">&nbsp;                r.add(Minefield.getDisplayableName(mf.getType()));</b>
<b class="nc">&nbsp;                r.add(mf.getCoords().getBoardNum());</b>
<b class="nc">&nbsp;                r.add(target);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (roll &lt; target) {</b>
&nbsp;                // Report miss
<b class="nc">&nbsp;                if (doBlind()) {</b>
<b class="nc">&nbsp;                    r = new Report(2217);</b>
<b class="nc">&nbsp;                    r.player = mf.getPlayerId();</b>
<b class="nc">&nbsp;                    vMineReport.add(r);</b>
&nbsp;                }
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            // Report hit
<b class="nc">&nbsp;            if (doBlind()) {</b>
<b class="nc">&nbsp;                r = new Report(2270);</b>
<b class="nc">&nbsp;                r.player = mf.getPlayerId();</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // apply damage
<b class="nc">&nbsp;            trippedMine = true;</b>
&nbsp;            // explodedMines.add(mf);
<b class="nc">&nbsp;            mf.setDetonated(true);</b>
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_INFERNO) {</b>
&nbsp;                // report hitting an inferno mine
<b class="nc">&nbsp;                r = new Report(2155);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                r.add(mf.getCoords().getBoardNum(), true);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
<b class="nc">&nbsp;                vMineReport.addAll(deliverInfernoMissiles(entity, entity, mf.getDensity() / 2));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(2150);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                r.add(mf.getCoords().getBoardNum(), true);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
<b class="nc">&nbsp;                int damage = mf.getDensity();</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    int cur_damage = Math.min(5, damage);</b>
<b class="nc">&nbsp;                    damage = damage - cur_damage;</b>
&nbsp;                    HitData hit;
<b class="nc">&nbsp;                    if (minesweeper == null) {</b>
<b class="nc">&nbsp;                        hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE,</b>
&nbsp;                                Minefield.TO_HIT_SIDE);
&nbsp;                    } else { // Minesweepers cause mines to hit minesweeper loc
<b class="nc">&nbsp;                        hit = new HitData(minesweeper.getLocation());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vMineReport.addAll(damageEntity(entity, hit, cur_damage));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (entity instanceof Tank) {</b>
&nbsp;                    // Tanks check for motive system damage from minefields as
&nbsp;                    // from a side hit even though the damage proper hits the
&nbsp;                    // front above; exact side doesn&#39;t matter, though.
<b class="nc">&nbsp;                    vMineReport.addAll(vehicleMotiveDamage((Tank)entity,</b>
<b class="nc">&nbsp;                            entity.getMotiveSideMod(ToHitData.SIDE_LEFT)));</b>
&nbsp;                }
<b class="nc">&nbsp;                Report.addNewline(vMineReport);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check the direct reduction
<b class="nc">&nbsp;            mf.checkReduction(0, true);</b>
<b class="nc">&nbsp;            revealMinefield(mf);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (Minefield mf : fieldsToRemove) {</b>
<b class="nc">&nbsp;            removeMinefield(mf);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return trippedMine;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * cycle through all mines on the board, check to see whether they should do
&nbsp;     * collateral damage to other mines due to detonation, resets detonation to
&nbsp;     * false, and removes any mines whose density has been reduced to zero.
&nbsp;     */
&nbsp;    private void resetMines() {
<b class="nc">&nbsp;        Enumeration&lt;Coords&gt; mineLoc = game.getMinedCoords();</b>
<b class="nc">&nbsp;        while (mineLoc.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Coords c = mineLoc.nextElement();</b>
<b class="nc">&nbsp;            Enumeration&lt;Minefield&gt; minefields = game.getMinefields(c).elements();</b>
<b class="nc">&nbsp;            while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Minefield minefield = minefields.nextElement();</b>
<b class="nc">&nbsp;                if (minefield.hasDetonated()) {</b>
<b class="nc">&nbsp;                    minefield.setDetonated(false);</b>
<b class="nc">&nbsp;                    Enumeration&lt;Minefield&gt; otherMines = game.getMinefields(c).elements();</b>
<b class="nc">&nbsp;                    while (otherMines.hasMoreElements()) {</b>
<b class="nc">&nbsp;                        Minefield otherMine = otherMines.nextElement();</b>
<b class="nc">&nbsp;                        if (otherMine.equals(minefield)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        int bonus = 0;</b>
<b class="nc">&nbsp;                        if (otherMine.getDensity() &gt; minefield.getDensity()) {</b>
<b class="nc">&nbsp;                            bonus = 1;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (otherMine.getDensity() &lt; minefield.getDensity()) {</b>
<b class="nc">&nbsp;                            bonus = -1;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        otherMine.checkReduction(bonus, false);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // cycle through a second time to see if any mines at these coords
&nbsp;            // need to be removed
<b class="nc">&nbsp;            List&lt;Minefield&gt; mfRemoved = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            Enumeration&lt;Minefield&gt; mines = game.getMinefields(c).elements();</b>
<b class="nc">&nbsp;            while (mines.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Minefield mine = mines.nextElement();</b>
<b class="nc">&nbsp;                if (mine.getDensity() &lt; 5) {</b>
<b class="nc">&nbsp;                    mfRemoved.add(mine);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // we have to do it this way to avoid a concurrent error problem
<b class="nc">&nbsp;            for (Minefield mf : mfRemoved) {</b>
<b class="nc">&nbsp;                removeMinefield(mf);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // update the mines at these coords
<b class="nc">&nbsp;            sendChangedMines(c);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * attempt to clear a minefield
&nbsp;     *
&nbsp;     * @param mf     - a &lt;code&gt;Minefield&lt;/code&gt; to clear
&nbsp;     * @param en     - &lt;code&gt;entity&lt;/code&gt; doing the clearing
&nbsp;     * @param target - &lt;code&gt;int&lt;/code&gt; needed to roll for a successful clearance
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if clearance successful
&nbsp;     */
&nbsp;    public boolean clearMinefield(Minefield mf, Entity en, int target,
&nbsp;                                  Vector&lt;Report&gt; vClearReport) {
<b class="nc">&nbsp;        return clearMinefield(mf, en, target, -1, vClearReport, 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean clearMinefield(Minefield mf, Entity en, int target,
&nbsp;                                  int botch, Vector&lt;Report&gt; vClearReport) {
<b class="nc">&nbsp;        return clearMinefield(mf, en, target, botch, vClearReport, 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * attempt to clear a minefield We don&#39;t actually remove the minefield here,
&nbsp;     * because if this is called up from within a loop, that will cause problems
&nbsp;     *
&nbsp;     * @param mf
&nbsp;     *            - a &lt;code&gt;Minefield&lt;/code&gt; to clear
&nbsp;     * @param en
&nbsp;     *            - &lt;code&gt;entity&lt;/code&gt; doing the clearing
&nbsp;     * @param target
&nbsp;     *            - &lt;code&gt;int&lt;/code&gt; needed to roll for a successful clearance
&nbsp;     * @param botch
&nbsp;     *            - &lt;code&gt;int&lt;/code&gt; that indicates an accidental detonation
&nbsp;     * @param vClearReport
&nbsp;     *            - The report collection to report to
&nbsp;     * @param indent
&nbsp;     *            - The number of indents for the report
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if clearance successful
&nbsp;     */
&nbsp;    public boolean clearMinefield(Minefield mf, Entity en, int target,
&nbsp;            int botch, Vector&lt;Report&gt; vClearReport, int indent) {
&nbsp;        Report r;
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        if (roll &gt;= target) {</b>
<b class="nc">&nbsp;            r = new Report(2250);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.add(Minefield.getDisplayableName(mf.getType()));</b>
<b class="nc">&nbsp;            r.add(target);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.indent(indent);</b>
<b class="nc">&nbsp;            vClearReport.add(r);</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } else if (roll &lt;= botch) {</b>
&nbsp;            // TODO : detonate the minefield
<b class="nc">&nbsp;            r = new Report(2255);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(indent);</b>
<b class="nc">&nbsp;            r.add(Minefield.getDisplayableName(mf.getType()));</b>
<b class="nc">&nbsp;            r.add(target);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            vClearReport.add(r);</b>
&nbsp;            // The detonation damages any units that were also attempting to
&nbsp;            // clear mines in the same hex
<b class="nc">&nbsp;            for (Entity victim : game.getEntitiesVector(mf.getCoords())) {</b>
&nbsp;                Report rVictim;
<b class="nc">&nbsp;                if (victim.isClearingMinefield()) {</b>
<b class="nc">&nbsp;                    rVictim = new Report(2265);</b>
<b class="nc">&nbsp;                    rVictim.subject = victim.getId();</b>
<b class="nc">&nbsp;                    rVictim.add(victim.getShortName(), true);</b>
<b class="nc">&nbsp;                    rVictim.indent(indent + 1);</b>
<b class="nc">&nbsp;                    vClearReport.add(rVictim);</b>
<b class="nc">&nbsp;                    int damage = mf.getDensity();</b>
<b class="nc">&nbsp;                    while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                        int cur_damage = Math.min(5, damage);</b>
<b class="nc">&nbsp;                        damage = damage - cur_damage;</b>
<b class="nc">&nbsp;                        HitData hit = victim.rollHitLocation(</b>
&nbsp;                                Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);
<b class="nc">&nbsp;                        vClearReport.addAll(damageEntity(victim, hit, cur_damage));</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // reduction works differently here
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_CONVENTIONAL) {</b>
<b class="nc">&nbsp;                mf.setDensity(Math.max(5, mf.getDensity() - 5));</b>
&nbsp;            } else {
&nbsp;                // congratulations, you cleared the mine by blowing yourself up
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // failure
<b class="nc">&nbsp;            r = new Report(2260);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(indent);</b>
<b class="nc">&nbsp;            r.add(Minefield.getDisplayableName(mf.getType()));</b>
<b class="nc">&nbsp;            r.add(target);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            vClearReport.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clear any detonated mines at these coords
&nbsp;     */
&nbsp;    private void clearDetonatedMines(Coords c, int target) {
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; minefields = game.getMinefields(c).elements();</b>
<b class="nc">&nbsp;        List&lt;Minefield&gt; mfRemoved = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        while (minefields.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield minefield = minefields.nextElement();</b>
<b class="nc">&nbsp;            if (minefield.hasDetonated() &amp;&amp; (Compute.d6(2) &gt;= target)) {</b>
<b class="nc">&nbsp;                mfRemoved.add(minefield);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // we have to do it this way to avoid a concurrent error problem
<b class="nc">&nbsp;        for (Minefield mf : mfRemoved) {</b>
<b class="nc">&nbsp;            removeMinefield(mf);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if an entity sets off any vibrabombs.
&nbsp;     */
&nbsp;    private boolean checkVibrabombs(Entity entity, Coords coords, boolean displaced,
&nbsp;                                    Vector&lt;Report&gt; vMineReport) {
<b class="nc">&nbsp;        return checkVibrabombs(entity, coords, displaced, null, null, vMineReport);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if an entity sets off any vibrabombs.
&nbsp;     */
&nbsp;    private boolean checkVibrabombs(Entity entity, Coords coords, boolean displaced, Coords lastPos,
&nbsp;                                    Coords curPos, Vector&lt;Report&gt; vMineReport) {
<b class="nc">&nbsp;        int mass = (int) entity.getWeight();</b>
&nbsp;
&nbsp;        // Check for Mine sweepers
<b class="nc">&nbsp;        Mounted minesweeper = null;</b>
<b class="nc">&nbsp;        for (Mounted m : entity.getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_MINESWEEPER) &amp;&amp; m.isReady() &amp;&amp; (m.getArmorValue() &gt; 0)) {</b>
<b class="nc">&nbsp;                minesweeper = m;</b>
<b class="nc">&nbsp;                break; // Can only have one minesweeper</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Check for minesweepers sweeping VB minefields
<b class="nc">&nbsp;        if (minesweeper != null) {</b>
<b class="nc">&nbsp;            Vector&lt;Minefield&gt; fieldsToRemove = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Minefield mf : game.getVibrabombs()) {</b>
&nbsp;                // Ignore mines if they aren&#39;t in this position
<b class="nc">&nbsp;                if (!mf.getCoords().equals(coords)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Minesweepers on units within 9 tons of the vibrafield setting
&nbsp;                // automatically clear the minefield
<b class="nc">&nbsp;                if (Math.abs(mass - mf.getSetting()) &lt; 10) {</b>
&nbsp;                    // Clear the minefield
&nbsp;                    Report r;
<b class="nc">&nbsp;                    r = new Report(2158);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                    r.add(Minefield.getDisplayableName(mf.getType()), true);</b>
<b class="nc">&nbsp;                    r.add(mf.getCoords().getBoardNum(), true);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    vMineReport.add(r);</b>
<b class="nc">&nbsp;                    fieldsToRemove.add(mf);</b>
&nbsp;
&nbsp;                    // Handle armor value damage
<b class="nc">&nbsp;                    int remainingAV = minesweeper.getArmorValue() - 10;</b>
<b class="nc">&nbsp;                    minesweeper.setArmorValue(Math.max(remainingAV, 0));</b>
&nbsp;
<b class="nc">&nbsp;                    r = new Report(2161);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                    r.add(10);</b>
<b class="nc">&nbsp;                    r.add(Math.max(remainingAV, 0));</b>
<b class="nc">&nbsp;                    vMineReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                    if (remainingAV &lt;= 0) {</b>
<b class="nc">&nbsp;                        minesweeper.setDestroyed(true);</b>
&nbsp;                    }
&nbsp;                    // Check for damage transfer
<b class="nc">&nbsp;                    if (remainingAV &lt; 0) {</b>
<b class="nc">&nbsp;                        int damage = Math.abs(remainingAV);</b>
<b class="nc">&nbsp;                        r = new Report(2162);</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(damage, true);</b>
<b class="nc">&nbsp;                        vMineReport.add(r);</b>
&nbsp;
&nbsp;                        // Damage is dealt to the location of minesweeper
<b class="nc">&nbsp;                        HitData hit = new HitData(minesweeper.getLocation());</b>
<b class="nc">&nbsp;                        Vector&lt;Report&gt; damageReports = damageEntity(entity, hit, damage);</b>
<b class="nc">&nbsp;                        for (Report r1 : damageReports) {</b>
<b class="nc">&nbsp;                            r1.indent(1);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        vMineReport.addAll(damageReports);</b>
<b class="nc">&nbsp;                        entity.applyDamage();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Report.addNewline(vMineReport);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            for (Minefield mf : fieldsToRemove) {</b>
<b class="nc">&nbsp;                removeMinefield(mf);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        boolean boom = false;</b>
&nbsp;        // Only mechs can set off vibrabombs. QuadVees should only be able to set off a
&nbsp;        // vibrabomb in Mech mode. Those that are converting to or from Mech mode should
&nbsp;        // are using leg movement and should be able to set them off.
<b class="nc">&nbsp;        if (!(entity instanceof Mech) || (entity instanceof QuadVee</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isConvertingNow())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; e = game.getVibrabombs().elements();</b>
&nbsp;
<b class="nc">&nbsp;        while (e.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield mf = e.nextElement();</b>
&nbsp;
&nbsp;            // Bug 954272: Mines shouldn&#39;t work underwater, and BMRr says
&nbsp;            // Vibrabombs are mines
<b class="nc">&nbsp;            if (game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                    &amp;&amp; !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Mech weighing 10 tons or less can&#39;t set off the bomb
<b class="nc">&nbsp;            if (mass &lt;= (mf.getSetting() - 10)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int effectiveDistance = (mass - mf.getSetting()) / 10;</b>
<b class="nc">&nbsp;            int actualDistance = coords.distance(mf.getCoords());</b>
&nbsp;
<b class="nc">&nbsp;            if (actualDistance &lt;= effectiveDistance) {</b>
<b class="nc">&nbsp;                Report r = new Report(2156);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                r.add(mf.getCoords().getBoardNum(), true);</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
&nbsp;                
&nbsp;                // if the moving entity is not actually moving into the vibrabomb
&nbsp;                // hex, it won&#39;t get damaged
<b class="nc">&nbsp;                Integer excludeEntityID = null;</b>
<b class="nc">&nbsp;                if (!coords.equals(mf.getCoords())) {</b>
<b class="nc">&nbsp;                    excludeEntityID = entity.getId();</b>
&nbsp;                }
&nbsp;                    
<b class="nc">&nbsp;                explodeVibrabomb(mf, vMineReport, false, excludeEntityID);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Hack; when moving, the Mech isn&#39;t in the hex during
&nbsp;            // the movement.
<b class="nc">&nbsp;            if (!displaced &amp;&amp; (actualDistance == 0)) {</b>
&nbsp;                // report getting hit by vibrabomb
<b class="nc">&nbsp;                Report r = new Report(2160);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                vMineReport.add(r);</b>
<b class="nc">&nbsp;                int damage = mf.getDensity();</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    int cur_damage = Math.min(5, damage);</b>
<b class="nc">&nbsp;                    damage = damage - cur_damage;</b>
<b class="nc">&nbsp;                    HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);</b>
<b class="nc">&nbsp;                    vMineReport.addAll(damageEntity(entity, hit, cur_damage));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                vMineReport.addAll(resolvePilotingRolls(entity, true, lastPos, curPos));</b>
&nbsp;                // we need to apply Damage now, in case the entity lost a leg,
&nbsp;                // otherwise it won&#39;t get a leg missing mod if it hasn&#39;t yet
&nbsp;                // moved and lost a leg, see bug 1071434 for an example
<b class="nc">&nbsp;                entity.applyDamage();</b>
&nbsp;            }
&nbsp;
&nbsp;            // don&#39;t check for reduction until the end or units in the same hex
&nbsp;            // through
&nbsp;            // movement will get the reduced damage
<b class="nc">&nbsp;            if (mf.hasDetonated()) {</b>
<b class="nc">&nbsp;                boom = true;</b>
<b class="nc">&nbsp;                mf.checkReduction(0, true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return boom;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the minefield from the game.
&nbsp;     *
&nbsp;     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to remove
&nbsp;     */
&nbsp;    public void removeMinefield(Minefield mf) {
<b class="nc">&nbsp;        if (game.containsVibrabomb(mf)) {</b>
<b class="nc">&nbsp;            game.removeVibrabomb(mf);</b>
&nbsp;        }
<b class="nc">&nbsp;        game.removeMinefield(mf);</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;IPlayer&gt; players = game.getPlayers();</b>
<b class="nc">&nbsp;        while (players.hasMoreElements()) {</b>
<b class="nc">&nbsp;            IPlayer player = players.nextElement();</b>
<b class="nc">&nbsp;            removeMinefield(player, mf);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the minefield from a player.
&nbsp;     *
&nbsp;     * @param player The &lt;code&gt;Player&lt;/code&gt; whose minefield should be removed
&nbsp;     * @param mf     The &lt;code&gt;Minefield&lt;/code&gt; to be removed
&nbsp;     */
&nbsp;    private void removeMinefield(IPlayer player, Minefield mf) {
<b class="nc">&nbsp;        if (player.containsMinefield(mf)) {</b>
<b class="nc">&nbsp;            player.removeMinefield(mf);</b>
<b class="nc">&nbsp;            send(player.getId(), new Packet(Packet.COMMAND_REMOVE_MINEFIELD, mf));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Reveals a minefield for all players.
&nbsp;     *
&nbsp;     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be revealed
&nbsp;     */
&nbsp;    private void revealMinefield(Minefield mf) {
<b class="nc">&nbsp;        Enumeration&lt;Team&gt; teams = game.getTeams();</b>
<b class="nc">&nbsp;        while (teams.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Team team = teams.nextElement();</b>
<b class="nc">&nbsp;            revealMinefield(team, mf);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Reveals a minefield for all players on a team.
&nbsp;     *
&nbsp;     * @param team The &lt;code&gt;team&lt;/code&gt; whose minefield should be revealed
&nbsp;     * @param mf   The &lt;code&gt;Minefield&lt;/code&gt; to be revealed
&nbsp;     */
&nbsp;    private void revealMinefield(Team team, Minefield mf) {
<b class="nc">&nbsp;        Enumeration&lt;IPlayer&gt; players = team.getPlayers();</b>
<b class="nc">&nbsp;        while (players.hasMoreElements()) {</b>
<b class="nc">&nbsp;            IPlayer player = players.nextElement();</b>
<b class="nc">&nbsp;            if (!player.containsMinefield(mf)) {</b>
<b class="nc">&nbsp;                player.addMinefield(mf);</b>
<b class="nc">&nbsp;                send(player.getId(), new Packet(Packet.COMMAND_REVEAL_MINEFIELD, mf));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * checks whether a newly set mine should be revealed to players based on
&nbsp;     * LOS. If so, then it reveals the mine
&nbsp;     */
&nbsp;    private void checkForRevealMinefield(Minefield mf, Entity layer) {
<b class="nc">&nbsp;        Enumeration&lt;Team&gt; teams = game.getTeams();</b>
&nbsp;        // loop through each team and determine if they can see the mine, then
&nbsp;        // loop through players on team
&nbsp;        // and reveal the mine
<b class="nc">&nbsp;        while (teams.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Team team = teams.nextElement();</b>
<b class="nc">&nbsp;            boolean canSee = false;</b>
&nbsp;
&nbsp;            // the players own team can always see the mine
<b class="nc">&nbsp;            if (team.equals(game.getTeamForPlayer(game.getPlayer(mf.getPlayerId())))) {</b>
<b class="nc">&nbsp;                canSee = true;</b>
&nbsp;            } else {
&nbsp;                // need to loop through all entities on this team and find the
&nbsp;                // one with the best shot of seeing
&nbsp;                // the mine placement
<b class="nc">&nbsp;                int target = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;                Iterator&lt;Entity&gt; entities = game.getEntities();</b>
<b class="nc">&nbsp;                while (entities.hasNext()) {</b>
<b class="nc">&nbsp;                    Entity en = entities.next();</b>
&nbsp;                    // are we on the right team?
<b class="nc">&nbsp;                    if (!team.equals(game.getTeamForPlayer(en.getOwner()))) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (LosEffects.calculateLos(game, en.getId(),</b>
<b class="nc">&nbsp;                            new HexTarget(mf.getCoords(), game.getBoard(),</b>
<b class="nc">&nbsp;                                    Targetable.TYPE_HEX_CLEAR)).canSee()) {</b>
<b class="nc">&nbsp;                        target = 0;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    LosEffects los = LosEffects.calculateLos(game, en.getId(), layer);</b>
<b class="nc">&nbsp;                    if (los.canSee()) {</b>
&nbsp;                        // TODO : need to add mods
<b class="nc">&nbsp;                        ToHitData current = new ToHitData(4, &quot;base&quot;);</b>
<b class="nc">&nbsp;                        current.append(Compute.getAttackerMovementModifier(game, en.getId()));</b>
<b class="nc">&nbsp;                        current.append(Compute.getTargetMovementModifier(game, layer.getId()));</b>
<b class="nc">&nbsp;                        current.append(los.losModifiers(game));</b>
<b class="nc">&nbsp;                        if (current.getValue() &lt; target) {</b>
<b class="nc">&nbsp;                            target = current.getValue();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (Compute.d6(2) &gt;= target) {</b>
<b class="nc">&nbsp;                    canSee = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (canSee) {</b>
<b class="nc">&nbsp;                revealMinefield(team, mf);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Explodes a vibrabomb.
&nbsp;     *
&nbsp;     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to explode
&nbsp;     */
&nbsp;    private void explodeVibrabomb(Minefield mf, Vector&lt;Report&gt; vBoomReport, boolean reduce, Integer entityToExclude) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; targets = game.getEntities(mf.getCoords());</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        while (targets.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = targets.next();</b>
&nbsp;
&nbsp;            // Airborne entities wont get hit by the mines...
<b class="nc">&nbsp;            if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for the OptionsConstants.ADVGRNDMOV_NO_PREMOVE_VIBRA option
&nbsp;            // If it&#39;s set, and the target has not yet moved,
&nbsp;            // it doesn&#39;t get damaged.
<b class="nc">&nbsp;            if (!entity.isDone()</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_NO_PREMOVE_VIBRA)) {</b>
<b class="nc">&nbsp;                r = new Report(2157);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                vBoomReport.add(r);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // the &quot;currently moving entity&quot; may not be in the same hex, so it needs to be excluded
<b class="nc">&nbsp;            if ((entityToExclude != null) &amp;&amp; (entity.getId() == entityToExclude)) {</b>
&nbsp;                // report not hitting vibrabomb
<b class="nc">&nbsp;                r = new Report(2157);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                vBoomReport.add(r);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            } else {
&nbsp;                // report hitting vibrabomb
<b class="nc">&nbsp;                r = new Report(2160);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                vBoomReport.add(r);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            int damage = mf.getDensity();</b>
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                int cur_damage = Math.min(5, damage);</b>
<b class="nc">&nbsp;                damage = damage - cur_damage;</b>
<b class="nc">&nbsp;                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);</b>
<b class="nc">&nbsp;                vBoomReport.addAll(damageEntity(entity, hit, cur_damage));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Report.addNewline(vBoomReport);</b>
&nbsp;
<b class="nc">&nbsp;            if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                vBoomReport.addAll(vehicleMotiveDamage((Tank)entity,</b>
<b class="nc">&nbsp;                        entity.getMotiveSideMod(ToHitData.SIDE_LEFT)));</b>
&nbsp;            }
<b class="nc">&nbsp;            vBoomReport.addAll(resolvePilotingRolls(entity, true, entity.getPosition(),</b>
<b class="nc">&nbsp;                    entity.getPosition()));</b>
&nbsp;            // we need to apply Damage now, in case the entity lost a leg,
&nbsp;            // otherwise it won&#39;t get a leg missing mod if it hasn&#39;t yet
&nbsp;            // moved and lost a leg, see bug 1071434 for an example
<b class="nc">&nbsp;            game.resetPSRs(entity);</b>
<b class="nc">&nbsp;            entity.applyDamage();</b>
<b class="nc">&nbsp;            Report.addNewline(vBoomReport);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check the direct reduction of mine
<b class="nc">&nbsp;        if (reduce) {</b>
<b class="nc">&nbsp;            mf.checkReduction(0, true);</b>
&nbsp;        }
<b class="nc">&nbsp;        mf.setDetonated(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * drowns any units swarming the entity
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is being swarmed
&nbsp;     * @param pos    The &lt;code&gt;Coords&lt;/code&gt; the entity is at
&nbsp;     */
&nbsp;    private void drownSwarmer(Entity entity, Coords pos) {
&nbsp;        // Any swarming infantry will be destroyed.
<b class="nc">&nbsp;        final int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;        if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;            final Entity swarmer = game.getEntity(swarmerId);</b>
&nbsp;            // Only *platoons* drown while swarming.
<b class="nc">&nbsp;            if (!(swarmer instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                swarmer.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;                entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                swarmer.setPosition(pos);</b>
<b class="nc">&nbsp;                Report r = new Report(2165);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName(), true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(destroyEntity(swarmer, &quot;a watery grave&quot;, false));</b>
<b class="nc">&nbsp;                entityUpdate(swarmerId);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if we may have just washed off infernos. Call after a step
&nbsp;     * which may have done this.
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is being checked
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; the entity is at
&nbsp;     */
&nbsp;    void checkForWashedInfernos(Entity entity, Coords coords) {
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        int waterLevel = hex.terrainLevel(Terrains.WATER);</b>
&nbsp;        // Mech on fire with infernos can wash them off.
<b class="nc">&nbsp;        if (!(entity instanceof Mech) || !entity.infernos.isStillBurning()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // Check if entering depth 2 water or prone in depth 1.
<b class="nc">&nbsp;        if ((waterLevel &gt; 0) &amp;&amp; (entity.relHeight() &lt; 0)) {</b>
<b class="nc">&nbsp;            washInferno(entity, coords);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Washes off an inferno from a mech and adds it to the (water) hex.
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is taking a bath
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; the entity is at
&nbsp;     */
&nbsp;    void washInferno(Entity entity, Coords coords) {
<b class="nc">&nbsp;        game.getBoard().addInfernoTo(coords, InfernoTracker.STANDARD_ROUND, 1);</b>
<b class="nc">&nbsp;        entity.infernos.clear();</b>
&nbsp;
&nbsp;        // Start a fire in the hex?
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        Report r = new Report(2170);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        if (!hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            r.messageId = 2175;</b>
<b class="nc">&nbsp;            ignite(coords, Terrains.FIRE_LVL_INFERNO, null);</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add heat from the movement phase
&nbsp;     */
&nbsp;    public void addMovementHeat() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = i.next();</b>
&nbsp;
<b class="nc">&nbsp;            if (entity.hasDamagedRHS()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 1;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {</b>
&nbsp;                // UMU heat
<b class="nc">&nbsp;                entity.heatBuildup += 1;</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // build up heat from movement
<b class="nc">&nbsp;            if (entity.isEvading() &amp;&amp; !entity.isAero()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += entity.getRunHeat() + 2;</b>
<b class="nc">&nbsp;            } else if (entity.moved == EntityMovementType.MOVE_NONE) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += entity.getStandingHeat();</b>
<b class="nc">&nbsp;            } else if ((entity.moved == EntityMovementType.MOVE_WALK)</b>
&nbsp;                       || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                       || (entity.moved == EntityMovementType.MOVE_CAREFUL_STAND)) {
<b class="nc">&nbsp;                entity.heatBuildup += entity.getWalkHeat();</b>
<b class="nc">&nbsp;            } else if ((entity.moved == EntityMovementType.MOVE_RUN)</b>
&nbsp;                       || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                       || (entity.moved == EntityMovementType.MOVE_SKID)) {
<b class="nc">&nbsp;                entity.heatBuildup += entity.getRunHeat();</b>
<b class="nc">&nbsp;            } else if (entity.moved == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += entity.getJumpHeat(entity.delta_distance);</b>
<b class="nc">&nbsp;            } else if (entity.moved == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                    || entity.moved == EntityMovementType.MOVE_VTOL_SPRINT) {
<b class="nc">&nbsp;                entity.heatBuildup += entity.getSprintHeat();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set the LocationsExposure of an entity
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            The &lt;code&gt;Entity&lt;/code&gt; who&#39;s exposure is being set
&nbsp;     * @param hex
&nbsp;     *            The &lt;code&gt;IHex&lt;/code&gt; the entity is in
&nbsp;     * @param isJump
&nbsp;     *            a &lt;code&gt;boolean&lt;/code&gt; value whether the entity is jumping
&nbsp;     * @param elevation
&nbsp;     *            the elevation the entity should be at.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; doSetLocationsExposure(Entity entity, IHex hex,
&nbsp;            boolean isJump, int elevation) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((hex.terrainLevel(Terrains.WATER) &gt; 0) &amp;&amp; !isJump</b>
&nbsp;            &amp;&amp; (elevation &lt; 0)) {
<b class="nc">&nbsp;            int partialWaterLevel = 1;</b>
<b class="nc">&nbsp;            if ((entity instanceof Mech) &amp;&amp; entity.isSuperHeavy()) {</b>
<b class="nc">&nbsp;                partialWaterLevel = 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity instanceof Mech) &amp;&amp; !entity.isProne()</b>
<b class="nc">&nbsp;                &amp;&amp; (hex.terrainLevel(Terrains.WATER) &lt;= partialWaterLevel)) {</b>
<b class="nc">&nbsp;                for (int loop = 0; loop &lt; entity.locations(); loop++) {</b>
<b class="nc">&nbsp;                    if (game.getPlanetaryConditions().isVacuum()</b>
<b class="nc">&nbsp;                            || ((entity.getEntityType() &amp; Entity.ETYPE_AERO) == 0 &amp;&amp; entity.isSpaceborne())) {</b>
<b class="nc">&nbsp;                        entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                entity.setLocationStatus(Mech.LOC_RLEG, ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;                entity.setLocationStatus(Mech.LOC_LLEG, ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(breachCheck(entity, Mech.LOC_RLEG, hex));</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(breachCheck(entity, Mech.LOC_LLEG, hex));</b>
<b class="nc">&nbsp;                if (entity instanceof QuadMech) {</b>
<b class="nc">&nbsp;                    entity.setLocationStatus(Mech.LOC_RARM, ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;                    entity.setLocationStatus(Mech.LOC_LARM, ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_RARM, hex));</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_LARM, hex));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity instanceof TripodMech) {</b>
<b class="nc">&nbsp;                    entity.setLocationStatus(Mech.LOC_CLEG, ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(breachCheck(entity, Mech.LOC_CLEG, hex));</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                for (int loop = 0; loop &lt; entity.locations(); loop++) {</b>
<b class="nc">&nbsp;                    entity.setLocationStatus(loop, ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(breachCheck(entity, loop, hex));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            for (int loop = 0; loop &lt; entity.locations(); loop++) {</b>
<b class="nc">&nbsp;                if (game.getPlanetaryConditions().isVacuum()</b>
<b class="nc">&nbsp;                        || ((entity.getEntityType() &amp; Entity.ETYPE_AERO) == 0 &amp;&amp; entity.isSpaceborne())) {</b>
<b class="nc">&nbsp;                    entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a roll to avoid pilot damage from g-forces
&nbsp;     *
&nbsp;     * @param entity       The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR
&nbsp;     * @param targetNumber The &lt;code&gt;int&lt;/code&gt; to be used for this PSR.
&nbsp;     */
&nbsp;    private void resistGForce(Entity entity, int targetNumber) {
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(9330);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9335);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(Integer.toString(targetNumber));</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
<b class="nc">&nbsp;        if (diceRoll &lt; targetNumber) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(damageCrew(entity, 1));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Do a piloting skill check in space to avoid structural damage
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR
&nbsp;     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this PSR.
&nbsp;     * @return true if check succeeds, false otherwise.
&nbsp;     */
&nbsp;    private boolean doSkillCheckInSpace(Entity entity, PilotingRollData roll) {
<b class="nc">&nbsp;        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(9320);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9325);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
&nbsp;        boolean suc;
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            suc = false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            suc = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return suc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a piloting skill check to take off vertically
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR
&nbsp;     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this PSR.
&nbsp;     * @return true if check succeeds, false otherwise.
&nbsp;     */
&nbsp;    private boolean doVerticalTakeOffCheck(Entity entity, PilotingRollData roll) {
&nbsp;
<b class="nc">&nbsp;        if (!entity.isAero()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IAero a = (IAero) entity;</b>
&nbsp;
<b class="nc">&nbsp;        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(9320);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9321);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        boolean suc = false;</b>
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;            int mof = roll.getValue() - diceRoll;</b>
<b class="nc">&nbsp;            if (mof &lt; 3) {</b>
<b class="nc">&nbsp;                r = new Report(9322);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                suc = true;</b>
<b class="nc">&nbsp;            } else if (mof &lt; 5) {</b>
<b class="nc">&nbsp;                PilotingRollData newRoll = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                if (Compute.d6(2) &gt;= newRoll.getValue()) {</b>
<b class="nc">&nbsp;                    r = new Report(9322);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    suc = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(9323);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    int damage = 20;</b>
<b class="nc">&nbsp;                    while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                        addReport(damageEntity(entity, entity.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                                ToHitData.SIDE_REAR), Math.min(5, damage)));</b>
<b class="nc">&nbsp;                        damage -= 5;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (mof &lt; 6) {</b>
<b class="nc">&nbsp;                r = new Report(9323);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                int damage = 50;</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, entity.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                            ToHitData.SIDE_REAR), Math.min(5, damage)));</b>
<b class="nc">&nbsp;                    damage -= 5;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                r = new Report(9323);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                int damage = 100;</b>
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, entity.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                            ToHitData.SIDE_REAR), Math.min(5, damage)));</b>
<b class="nc">&nbsp;                    damage -= 5;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            a.setGearHit(true);</b>
<b class="nc">&nbsp;            r = new Report(9125);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            r = new Report(9322);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            suc = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return suc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a piloting skill check in space to do a successful maneuver Failure
&nbsp;     * means moving forward half velocity
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR
&nbsp;     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this PSR.
&nbsp;     * @return true if check succeeds, false otherwise.
&nbsp;     */
&nbsp;    private boolean doSkillCheckManeuver(Entity entity, PilotingRollData roll) {
<b class="nc">&nbsp;        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(9600);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9601);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
&nbsp;        boolean suc;
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            suc = false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            suc = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return suc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a piloting skill check while standing still (during the movement
&nbsp;     * phase).
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR
&nbsp;     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this PSR.
&nbsp;     * @return true if check succeeds, false otherwise.
&nbsp;     */
&nbsp;    private boolean doSkillCheckInPlace(Entity entity, PilotingRollData roll) {
<b class="nc">&nbsp;        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.isProne()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(2180);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = entity.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;        r = new Report(2185);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
&nbsp;        boolean suc;
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if ((entity instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                    OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
<b class="nc">&nbsp;                &amp;&amp; (entity.getCrew().getPiloting() &lt; 6)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                if ((entity.getCrew().getPiloting() &gt; 1) &amp;&amp; ((roll.getValue() - diceRoll) &lt; 2)) {</b>
<b class="nc">&nbsp;                    entity.setHullDown(true);</b>
<b class="nc">&nbsp;                } else if ((entity.getCrew().getPiloting() &lt;= 1)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((roll.getValue() - diceRoll) &lt; 3)) {</b>
<b class="nc">&nbsp;                    entity.setHullDown(true);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!entity.isHullDown()</b>
<b class="nc">&nbsp;                || (entity.isHullDown() &amp;&amp; !entity.canGoHullDown())) {</b>
<b class="nc">&nbsp;                addReport(doEntityFall(entity, roll));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ServerHelper.sinkToBottom(entity);</b>
&nbsp;                
<b class="nc">&nbsp;                r = new Report(2317);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            suc = false;</b>
&nbsp;            // failed a PSR, possibly check for engine stalling
<b class="nc">&nbsp;            entity.doCheckEngineStallRoll(vPhaseReport);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            suc = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return suc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a Piloting Skill check to dislodge swarming infantry.
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is doing the dislodging.
&nbsp;     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; for this PSR.
&nbsp;     * @param curPos The &lt;code&gt;Coords&lt;/code&gt; the entity is at.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the dislodging is successful.
&nbsp;     */
&nbsp;    private boolean doDislodgeSwarmerSkillCheck(Entity entity, PilotingRollData roll, Coords curPos) {
&nbsp;        // okay, print the info
<b class="nc">&nbsp;        Report r = new Report(2180);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(2190);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // failed a PSR, possibly check for engine stalling
<b class="nc">&nbsp;            entity.doCheckEngineStallRoll(vPhaseReport);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // Dislodged swarmers don&#39;t get turns.
<b class="nc">&nbsp;        int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;        final Entity swarmer = game.getEntity(swarmerId);</b>
<b class="nc">&nbsp;        if (!swarmer.isDone()) {</b>
<b class="nc">&nbsp;            game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;            swarmer.setDone(true);</b>
<b class="nc">&nbsp;            send(createTurnVectorPacket());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update the report and cause a fall.
<b class="nc">&nbsp;        r.choose(true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        entity.setPosition(curPos);</b>
<b class="nc">&nbsp;        addReport(doEntityFallsInto(entity, curPos, roll, false));</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a piloting skill check while moving.
&nbsp;     *
&nbsp;     * @param entity          - the &lt;code&gt;Entity&lt;/code&gt; that must roll.
&nbsp;     * @param entityElevation The elevation of the supplied Entity above the surface of the
&nbsp;     *                        src hex. This is necessary as the state of the Entity may
&nbsp;     *                        represent the elevation of the entity about the surface of the
&nbsp;     *                        destination hex.
&nbsp;     * @param src             - the &lt;code&gt;Coords&lt;/code&gt; the entity is moving from.
&nbsp;     * @param dest            - the &lt;code&gt;Coords&lt;/code&gt; the entity is moving to. This value
&nbsp;     *                        can be the same as src for in-place checks.
&nbsp;     * @param roll            - the &lt;code&gt;PilotingRollData&lt;/code&gt; that is causing this
&nbsp;     *                        check.
&nbsp;     * @param isFallRoll      - a &lt;code&gt;boolean&lt;/code&gt; flag that indicates that failure will
&nbsp;     *                        result in a fall or not. Falls will be processed.
&nbsp;     * @return Margin of Failure if the pilot fails the skill check, 0 if they
&nbsp;     * pass.
&nbsp;     */
&nbsp;    private int doSkillCheckWhileMoving(Entity entity, int entityElevation,
&nbsp;            Coords src, Coords dest, PilotingRollData roll, boolean isFallRoll) {
&nbsp;        boolean fallsInPlace;
&nbsp;
&nbsp;        // Start the info for this roll.
<b class="nc">&nbsp;        Report r = new Report(1210);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
&nbsp;
&nbsp;        // Will the entity fall in the source or destination hex?
<b class="nc">&nbsp;        if (src.equals(dest)) {</b>
<b class="nc">&nbsp;            fallsInPlace = true;</b>
<b class="nc">&nbsp;            r.messageId = 2195;</b>
<b class="nc">&nbsp;            r.add(src.getBoardNum(), true);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            fallsInPlace = false;</b>
<b class="nc">&nbsp;            r.messageId = 2200;</b>
<b class="nc">&nbsp;            r.add(src.getBoardNum(), true);</b>
<b class="nc">&nbsp;            r.add(dest.getBoardNum(), true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Finish the info.
<b class="nc">&nbsp;        r.add(roll.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // roll
<b class="nc">&nbsp;        final int diceRoll = entity.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;        r = new Report(2185);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
<b class="nc">&nbsp;        if (diceRoll &lt; roll.getValue()) {</b>
&nbsp;            // Does failing the PSR result in a fall.
<b class="nc">&nbsp;            if (isFallRoll &amp;&amp; entity.canFall()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(doEntityFallsInto(entity, entityElevation,</b>
<b class="nc">&nbsp;                                            fallsInPlace ? dest : src, fallsInPlace ? src : dest,</b>
&nbsp;                                            roll, true));
&nbsp;            } else {
<b class="nc">&nbsp;                r.messageId = 2190;</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                entity.setPosition(fallsInPlace ? src : dest);</b>
&nbsp;            }
&nbsp;            // failed a PSR, possibly check for engine stalling
<b class="nc">&nbsp;            entity.doCheckEngineStallRoll(vPhaseReport);</b>
<b class="nc">&nbsp;            return roll.getValue() - diceRoll;</b>
&nbsp;        }
<b class="nc">&nbsp;        r.choose(true);</b>
<b class="nc">&nbsp;        r.newlines = 2;</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Process a fall when the source and destination hexes are the same.
&nbsp;     * Depending on the elevations of the hexes, the Entity could land in the
&nbsp;     * source or destination hexes. Check for any conflicts and resolve them.
&nbsp;     * Deal damage to faller. Note: the elevation of the entity is used to
&nbsp;     * determine fall distance, so it is important to ensure the Entity&#39;s
&nbsp;     * elevation is correct.
&nbsp;     *
&nbsp;     * @param entity    The &lt;code&gt;Entity&lt;/code&gt; that is falling.
&nbsp;     * @param src       The &lt;code&gt;Coords&lt;/code&gt; of the source hex.
&nbsp;     * @param roll      The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced
&nbsp;     *                  by the falling.
&nbsp;     * @param causeAffa The &lt;code&gt;boolean&lt;/code&gt; value whether this fall should be able
&nbsp;     *                  to cause an accidental fall from above
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityFallsInto(Entity entity, Coords src,
&nbsp;                                             PilotingRollData roll, boolean causeAffa) {
<b class="nc">&nbsp;        return doEntityFallsInto(entity, entity.getElevation(), src, src, roll,</b>
&nbsp;                                 causeAffa);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Process a fall when moving from the source hex to the destination hex.
&nbsp;     * Depending on the elevations of the hexes, the Entity could land in the
&nbsp;     * source or destination hexes. Check for any conflicts and resolve them.
&nbsp;     * Deal damage to faller. Note: the elevation of the entity is used to
&nbsp;     * determine fall distance, so it is important to ensure the Entity&#39;s
&nbsp;     * elevation is correct.
&nbsp;     *
&nbsp;     * @param entity             The &lt;code&gt;Entity&lt;/code&gt; that is falling.
&nbsp;     * @param entitySrcElevation The elevation of the supplied Entity above the surface of the
&nbsp;     *                           src hex. This is necessary as the state of the Entity may
&nbsp;     *                           represent the elevation of the entity about the surface of the
&nbsp;     *                           destination hex.
&nbsp;     * @param src                The &lt;code&gt;Coords&lt;/code&gt; of the source hex.
&nbsp;     * @param dest               The &lt;code&gt;Coords&lt;/code&gt; of the destination hex.
&nbsp;     * @param roll               The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced
&nbsp;     *                           by the falling.
&nbsp;     * @param causeAffa          The &lt;code&gt;boolean&lt;/code&gt; value whether this fall should be able
&nbsp;     *                           to cause an accidental fall from above
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityFallsInto(Entity entity,
&nbsp;                                             int entitySrcElevation, Coords src, Coords dest,
&nbsp;                                             PilotingRollData roll, boolean causeAffa) {
<b class="nc">&nbsp;        return doEntityFallsInto(entity, entitySrcElevation, src, dest, roll,</b>
&nbsp;                                 causeAffa, 0);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Process a fall when moving from the source hex to the destination hex.
&nbsp;     * Depending on the elevations of the hexes, the Entity could land in the
&nbsp;     * source or destination hexes. Check for any conflicts and resolve them.
&nbsp;     * Deal damage to faller.
&nbsp;     *
&nbsp;     * @param entity             The &lt;code&gt;Entity&lt;/code&gt; that is falling.
&nbsp;     * @param entitySrcElevation The elevation of the supplied Entity above the surface of the
&nbsp;     *                           src hex. This is necessary as the state of the Entity may
&nbsp;     *                           represent the elevation of the entity about the surface of the
&nbsp;     *                           destination hex.
&nbsp;     * @param origSrc            The &lt;code&gt;Coords&lt;/code&gt; of the original source hex.
&nbsp;     * @param origDest           The &lt;code&gt;Coords&lt;/code&gt; of the original destination hex.
&nbsp;     * @param roll               The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced
&nbsp;     *                           by the falling.
&nbsp;     * @param causeAffa          The &lt;code&gt;boolean&lt;/code&gt; value whether this fall should be able
&nbsp;     *                           to cause an accidental fall from above
&nbsp;     * @param fallReduction      An integer value to reduce the fall distance by
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityFallsInto(Entity entity,
&nbsp;                                             int entitySrcElevation, Coords origSrc, Coords origDest,
&nbsp;                                             PilotingRollData roll, boolean causeAffa, int fallReduction) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        IHex srcHex = game.getBoard().getHex(origSrc);</b>
<b class="nc">&nbsp;        IHex destHex = game.getBoard().getHex(origDest);</b>
&nbsp;        Coords src, dest;
&nbsp;        // We need to fall into the lower of the two hexes, TW pg 68
<b class="nc">&nbsp;        if (srcHex.getLevel() &lt; destHex.getLevel()) {</b>
<b class="nc">&nbsp;            IHex swapHex = destHex;</b>
<b class="nc">&nbsp;            destHex = srcHex;</b>
<b class="nc">&nbsp;            srcHex = swapHex;</b>
<b class="nc">&nbsp;            src = origDest;</b>
<b class="nc">&nbsp;            dest = origSrc;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            src = origSrc;</b>
<b class="nc">&nbsp;            dest = origDest;</b>
&nbsp;        }
<b class="nc">&nbsp;        final int srcHeightAboveFloor = entitySrcElevation + srcHex.depth(false);</b>
<b class="nc">&nbsp;        int fallElevation = Math.abs((srcHex.floor() + srcHeightAboveFloor)</b>
<b class="nc">&nbsp;                - (destHex.containsTerrain(Terrains.ICE) ? destHex.surface() : destHex.floor()))</b>
&nbsp;                - fallReduction;
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            fallElevation -= destHex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {</b>
<b class="nc">&nbsp;            if (entity.getElevation() == 0) { // floor 0 falling into basement</b>
<b class="nc">&nbsp;                fallElevation = destHex.depth(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int direction;
<b class="nc">&nbsp;        if (src.equals(dest)) {</b>
<b class="nc">&nbsp;            direction = Compute.d6() - 1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            direction = src.direction(dest);</b>
&nbsp;        }
&nbsp;        Report r;
&nbsp;        // check entity in target hex
<b class="nc">&nbsp;        Entity affaTarget = game.getAffaTarget(dest, entity);</b>
&nbsp;        // falling mech falls
<b class="nc">&nbsp;        r = new Report(2205);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(fallElevation);</b>
<b class="nc">&nbsp;        r.add(dest.getBoardNum(), true);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
&nbsp;
&nbsp;        // if hex was empty, deal damage and we&#39;re done
<b class="nc">&nbsp;        if (affaTarget == null) {</b>
<b class="nc">&nbsp;            r.newlines = 1;</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;            // If we rolled for the direction, we want to use that for the fall
<b class="nc">&nbsp;            if (src.equals(dest)) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation,</b>
<b class="nc">&nbsp;                                                 direction, roll, false, srcHex.hasCliffTopTowards(destHex)));</b>
&nbsp;            } else {
&nbsp;                // Otherwise, we&#39;ll roll for the direction after the fall
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation, roll));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
&nbsp;
&nbsp;        // hmmm... somebody there... problems.
<b class="nc">&nbsp;        if ((fallElevation &gt;= 2) &amp;&amp; causeAffa) {</b>
&nbsp;            // accidental fall from above: havoc!
<b class="nc">&nbsp;            r = new Report(2210);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(affaTarget);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;
&nbsp;            // determine to-hit number
<b class="nc">&nbsp;            ToHitData toHit = new ToHitData(7, &quot;base&quot;);</b>
<b class="nc">&nbsp;            if ((affaTarget instanceof Tank) || (affaTarget instanceof Dropship)) {</b>
<b class="nc">&nbsp;                toHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, &quot;Target is a Tank&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.append(Compute.getTargetMovementModifier(game, affaTarget.getId()));</b>
<b class="nc">&nbsp;                toHit.append(Compute.getTargetTerrainModifier(game, affaTarget));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL) {</b>
&nbsp;                // collision roll
<b class="nc">&nbsp;                final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;                    r = new Report(2212);</b>
<b class="nc">&nbsp;                    r.add(toHit.getValue());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(2215);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(toHit.getValue());</b>
<b class="nc">&nbsp;                    r.add(diceRoll);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                if (diceRoll &gt;= toHit.getValue()) {</b>
&nbsp;                    // deal damage to target
<b class="nc">&nbsp;                    int damage = Compute.getAffaDamageFor(entity);</b>
<b class="nc">&nbsp;                    r = new Report(2220);</b>
<b class="nc">&nbsp;                    r.subject = affaTarget.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(affaTarget);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                        int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                        HitData hit = affaTarget.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(damageEntity(affaTarget, hit, cluster));</b>
<b class="nc">&nbsp;                        damage -= cluster;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    // attacker falls as normal, on his back
&nbsp;                    // only given a modifier, so flesh out into a full piloting
&nbsp;                    // roll
<b class="nc">&nbsp;                    PilotingRollData pilotRoll = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                    pilotRoll.append(roll);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFall(entity, dest,</b>
&nbsp;                            fallElevation, 3, pilotRoll, false, false));
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityDisplacementMinefieldCheck(</b>
<b class="nc">&nbsp;                            entity, src, dest, entity.getElevation()));</b>
&nbsp;
&nbsp;                    // defender pushed away, or destroyed, if there is a
&nbsp;                    // stacking violation
<b class="nc">&nbsp;                    Entity violation = Compute.stackingViolation(game, entity.getId(), dest);</b>
<b class="nc">&nbsp;                    if (violation != null) {</b>
<b class="nc">&nbsp;                        PilotingRollData prd = new PilotingRollData(violation.getId(), 2,</b>
&nbsp;                                &quot;fallen on&quot;);
<b class="nc">&nbsp;                        if (violation instanceof Dropship) {</b>
<b class="nc">&nbsp;                            violation = entity;</b>
<b class="nc">&nbsp;                            prd = null;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Coords targetDest = Compute.getValidDisplacement(game, violation.getId(),</b>
&nbsp;                                dest, direction);
<b class="nc">&nbsp;                        if (targetDest != null) {</b>
<b class="nc">&nbsp;                            vPhaseReport.addAll(doEntityDisplacement(violation, dest, targetDest, prd));</b>
&nbsp;                            // Update the violating entity&#39;s position on the
&nbsp;                            // client.
<b class="nc">&nbsp;                            entityUpdate(violation.getId());</b>
&nbsp;                        } else {
&nbsp;                            // ack! automatic death! Tanks
&nbsp;                            // suffer an ammo/power plant hit.
&nbsp;                            // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                            vPhaseReport.addAll(destroyEntity(violation, &quot;impossible displacement&quot;,</b>
&nbsp;                                    violation instanceof Mech, violation instanceof Mech));
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    return vPhaseReport;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
&nbsp;                // automatic miss
<b class="nc">&nbsp;                r = new Report(2213);</b>
<b class="nc">&nbsp;                r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
&nbsp;            // ok, we missed, let&#39;s fall into a valid other hex and not cause an
&nbsp;            // AFFA while doing so
<b class="nc">&nbsp;            Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);</b>
<b class="nc">&nbsp;            if (targetDest != null) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFallsInto(entity, entitySrcElevation, src, targetDest,</b>
<b class="nc">&nbsp;                        new PilotingRollData(entity.getId(),</b>
&nbsp;                                TargetRoll.IMPOSSIBLE,
&nbsp;                                &quot;pushed off a cliff&quot;),
&nbsp;                        false));
&nbsp;                // Update the entity&#39;s position on the client.
<b class="nc">&nbsp;                entityUpdate(entity.getId());</b>
&nbsp;            } else {
&nbsp;                // ack! automatic death! Tanks
&nbsp;                // suffer an ammo/power plant hit.
&nbsp;                // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                vPhaseReport.addAll(destroyEntity(entity,</b>
&nbsp;                        &quot;impossible displacement&quot;, entity instanceof Mech, entity instanceof Mech));
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // damage as normal
<b class="nc">&nbsp;            vPhaseReport.addAll(doEntityFall(entity, dest, fallElevation, roll));</b>
<b class="nc">&nbsp;            Entity violation = Compute.stackingViolation(game, entity.getId(), dest);</b>
<b class="nc">&nbsp;            if (violation != null) {</b>
<b class="nc">&nbsp;                PilotingRollData prd = new PilotingRollData(violation.getId(), 0, &quot;domino effect&quot;);</b>
<b class="nc">&nbsp;                if (violation instanceof Dropship) {</b>
<b class="nc">&nbsp;                    violation = entity;</b>
<b class="nc">&nbsp;                    prd = null;</b>
&nbsp;                }
&nbsp;                // target gets displaced, because of low elevation
<b class="nc">&nbsp;                Coords targetDest = Compute.getValidDisplacement(game, violation.getId(), dest, direction);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityDisplacement(violation, dest, targetDest, prd));</b>
&nbsp;                // Update the violating entity&#39;s position on the client.
<b class="nc">&nbsp;                if (!game.getOutOfGameEntitiesVector().contains(violation)) {</b>
<b class="nc">&nbsp;                    entityUpdate(violation.getId());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Displace a unit in the direction specified. The unit moves in that
&nbsp;     * direction, and the piloting skill roll is used to determine if it falls.
&nbsp;     * The roll may be unnecessary as certain situations indicate an automatic
&nbsp;     * fall. Rolls are added to the piloting roll list.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityDisplacement(Entity entity, Coords src,
&nbsp;            Coords dest, PilotingRollData roll) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (!game.getBoard().contains(dest)) {</b>
&nbsp;            // set position anyway, for pushes moving through, stuff like that
<b class="nc">&nbsp;            entity.setPosition(dest);</b>
<b class="nc">&nbsp;            if (!entity.isDoomed()) {</b>
&nbsp;                // Make sure there aren&#39;t any specific entity turns for entity
<b class="nc">&nbsp;                int turnsRemoved = game.removeSpecificEntityTurnsFor(entity);</b>
&nbsp;                // May need to remove a turn for this Entity
<b class="nc">&nbsp;                if ((game.getPhase() == Phase.PHASE_MOVEMENT)</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.isDone() &amp;&amp; (turnsRemoved == 0)) {</b>
<b class="nc">&nbsp;                    game.removeTurnFor(entity);</b>
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;                } else if (turnsRemoved &gt; 0) {</b>
<b class="nc">&nbsp;                    send(createTurnVectorPacket());</b>
&nbsp;                }
<b class="nc">&nbsp;                game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED);</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_PUSHED));</b>
&nbsp;                // entity forced from the field
<b class="nc">&nbsp;                r = new Report(2230);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;                // TODO : remove passengers and swarmers.
&nbsp;            }
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;        final int direction = src.direction(dest);</b>
&nbsp;
&nbsp;        // Handle null hexes.
<b class="nc">&nbsp;        if ((srcHex == null) || (destHex == null)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Can not displace &quot; + entity.getShortName()</b>
&nbsp;                    + &quot; from &quot; + src + &quot; to &quot; + dest + &quot;.&quot;);
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
<b class="nc">&nbsp;        int bldgElev = destHex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;            ? destHex.terrainLevel(Terrains.BLDG_ELEV) : 0;</b>
<b class="nc">&nbsp;        int fallElevation = srcHex.surface() + entity.getElevation()</b>
<b class="nc">&nbsp;                - (destHex.surface() + bldgElev);</b>
<b class="nc">&nbsp;        if (fallElevation &gt; 1) {</b>
<b class="nc">&nbsp;            if (roll == null) {</b>
<b class="nc">&nbsp;                roll = entity.getBasePilotingRoll();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!(entity.isAirborneVTOLorWIGE())) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest,</b>
&nbsp;                        roll, true));
&nbsp;            } else {
<b class="nc">&nbsp;                entity.setPosition(dest);</b>
&nbsp;            }
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;        // unstick the entity if it was stuck in swamp
<b class="nc">&nbsp;        boolean wasStuck = entity.isStuck();</b>
<b class="nc">&nbsp;        entity.setStuck(false);</b>
<b class="nc">&nbsp;        int oldElev = entity.getElevation();</b>
&nbsp;        // move the entity into the new location gently
<b class="nc">&nbsp;        entity.setPosition(dest);</b>
<b class="nc">&nbsp;        entity.setElevation(entity.calcElevation(srcHex, destHex));</b>
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(dest);</b>
<b class="nc">&nbsp;        if (bldg != null) {</b>
<b class="nc">&nbsp;            if (destHex.terrainLevel(Terrains.BLDG_ELEV) &gt; oldElev) {</b>
&nbsp;                // whoops, into the building we go
<b class="nc">&nbsp;                passBuildingWall(entity, game.getBoard().getBuildingAt(dest), src, dest, 1,</b>
&nbsp;                        &quot;displaced into&quot;,
<b class="nc">&nbsp;                        Math.abs(entity.getFacing() - src.direction(dest)) == 3,</b>
&nbsp;                        entity.moved, true);
&nbsp;            }
<b class="nc">&nbsp;            checkBuildingCollapseWhileMoving(bldg, entity, dest);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        ServerHelper.checkAndApplyMagmaCrust(destHex, entity.getElevation(), entity, dest, false, vPhaseReport, this);</b>
&nbsp;        
<b class="nc">&nbsp;        Entity violation = Compute.stackingViolation(game, entity.getId(), dest);</b>
<b class="nc">&nbsp;        if (violation == null) {</b>
&nbsp;            // move and roll normally
<b class="nc">&nbsp;            r = new Report(2235);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(dest.getBoardNum(), true);</b>
&nbsp;        } else {
&nbsp;            // domino effect: move &amp; displace target
<b class="nc">&nbsp;            r = new Report(2240);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(dest.getBoardNum(), true);</b>
<b class="nc">&nbsp;            r.addDesc(violation);</b>
&nbsp;        }
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
&nbsp;        // trigger any special things for moving to the new hex
<b class="nc">&nbsp;        vPhaseReport.addAll(doEntityDisplacementMinefieldCheck(entity, src, dest, entity.getElevation()));</b>
<b class="nc">&nbsp;        vPhaseReport.addAll(doSetLocationsExposure(entity, destHex, false, entity.getElevation()));</b>
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getElevation() == 0)) {</b>
<b class="nc">&nbsp;            bldg = game.getBoard().getBuildingAt(dest);</b>
<b class="nc">&nbsp;            if (bldg.rollBasement(dest, game.getBoard(), vPhaseReport)) {</b>
<b class="nc">&nbsp;                sendChangedHex(dest);</b>
<b class="nc">&nbsp;                Vector&lt;Building&gt; buildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                buildings.add(bldg);</b>
<b class="nc">&nbsp;                sendChangedBuildings(buildings);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // mechs that were stuck will automatically fall in their new hex
<b class="nc">&nbsp;        if (wasStuck &amp;&amp; entity.canFall()) {</b>
<b class="nc">&nbsp;            if (roll == null) {</b>
<b class="nc">&nbsp;                roll = entity.getBasePilotingRoll();</b>
&nbsp;            }
<b class="nc">&nbsp;            vPhaseReport.addAll(doEntityFall(entity, dest, 0, roll));</b>
&nbsp;        }
&nbsp;        // check bog-down conditions
<b class="nc">&nbsp;        vPhaseReport.addAll(doEntityDisplacementBogDownCheck(entity, dest, entity.getElevation()));</b>
&nbsp;
<b class="nc">&nbsp;        if (roll != null) {</b>
<b class="nc">&nbsp;            if (entity.canFall()) {</b>
<b class="nc">&nbsp;                game.addPSR(roll);</b>
<b class="nc">&nbsp;            } else if ((entity instanceof LandAirMech) &amp;&amp; entity.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(roll);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int waterDepth = destHex.terrainLevel(Terrains.WATER);</b>
&nbsp;
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.ICE) &amp;&amp; destHex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            if (!(entity instanceof Infantry)) {</b>
<b class="nc">&nbsp;                int d6 = Compute.d6(1);</b>
<b class="nc">&nbsp;                r = new Report(2118);</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(d6);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (d6 == 6) {</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(resolveIceBroken(dest));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // Falling into water instantly destroys most non-mechs
<b class="nc">&nbsp;        else if ((waterDepth &gt; 0)</b>
&nbsp;                &amp;&amp; !(entity instanceof Mech)
&nbsp;                &amp;&amp; !(entity instanceof Protomech)
<b class="nc">&nbsp;                &amp;&amp; !((entity.getRunMP() &gt; 0) &amp;&amp; (entity.getMovementMode() == EntityMovementMode.HOVER))</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.INF_UMU)) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(destroyEntity(entity, &quot;a watery grave&quot;, false));</b>
<b class="nc">&nbsp;        } else if ((waterDepth &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; !(entity.getMovementMode() == EntityMovementMode.HOVER)) {</b>
<b class="nc">&nbsp;            PilotingRollData waterRoll = entity.checkWaterMove(waterDepth, entity.moved);</b>
<b class="nc">&nbsp;            if (waterRoll.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                doSkillCheckInPlace(entity, waterRoll);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Update the entity&#39;s position on the client.
<b class="nc">&nbsp;        entityUpdate(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;        if (violation != null) {</b>
&nbsp;            // Can the violating unit move out of the way?
&nbsp;            // if the direction comes from a side, Entity didn&#39;t jump, and it
&nbsp;            // has MP left to use, it can try to move.
<b class="nc">&nbsp;            MovePath stepForward = new MovePath(game, violation);</b>
<b class="nc">&nbsp;            MovePath stepBackwards = new MovePath(game, violation);</b>
<b class="nc">&nbsp;            stepForward.addStep(MoveStepType.FORWARDS);</b>
<b class="nc">&nbsp;            stepBackwards.addStep(MoveStepType.BACKWARDS);</b>
<b class="nc">&nbsp;            stepForward.compile(getGame(), violation, false);</b>
<b class="nc">&nbsp;            stepBackwards.compile(getGame(), violation, false);</b>
<b class="nc">&nbsp;            if ((direction != violation.getFacing())</b>
<b class="nc">&nbsp;                    &amp;&amp; (direction != ((violation.getFacing() + 3) % 6))</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.getIsJumpingNow()</b>
<b class="nc">&nbsp;                    &amp;&amp; (stepForward.isMoveLegal() || stepBackwards.isMoveLegal())) {</b>
&nbsp;                // First, we need to make a PSR to see if we can step out
<b class="nc">&nbsp;                int result = Compute.d6(2);</b>
<b class="nc">&nbsp;                roll = entity.getBasePilotingRoll();</b>
&nbsp;
<b class="nc">&nbsp;                r = new Report(2351);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = violation.getId();</b>
<b class="nc">&nbsp;                r.addDesc(violation);</b>
<b class="nc">&nbsp;                r.add(roll.getValue());</b>
<b class="nc">&nbsp;                r.add(result);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                if (result &lt; roll.getValue()) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; newReports = doEntityDisplacement(violation,</b>
<b class="nc">&nbsp;                            dest, dest.translated(direction),</b>
<b class="nc">&nbsp;                            new PilotingRollData(violation.getId(),</b>
&nbsp;                                    TargetRoll.AUTOMATIC_FAIL,
&nbsp;                                    &quot;failed to step out of a domino effect&quot;));
<b class="nc">&nbsp;                    for (Report newReport : newReports) {</b>
<b class="nc">&nbsp;                        newReport.indent(3);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(newReports);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    sendDominoEffectCFR(violation);</b>
<b class="nc">&nbsp;                    synchronized (cfrPacketQueue) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            cfrPacketQueue.wait();</b>
<b class="nc">&nbsp;                        } catch (InterruptedException ignored) {</b>
&nbsp;                            // Do nothing
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if (cfrPacketQueue.size() &gt; 0) {</b>
<b class="nc">&nbsp;                            ReceivedPacket rp = cfrPacketQueue.poll();</b>
<b class="nc">&nbsp;                            int cfrType = (int) rp.packet.getData()[0];</b>
&nbsp;                            // Make sure we got the right type of response
<b class="nc">&nbsp;                            if (cfrType != Packet.COMMAND_CFR_DOMINO_EFFECT) {</b>
<b class="nc">&nbsp;                                MegaMek.getLogger().error(&quot;Excepted a COMMAND_CFR_DOMINO_EFFECT CFR packet, &quot;</b>
&nbsp;                                                + &quot;received: &quot; + cfrType);
<b class="nc">&nbsp;                                throw new IllegalStateException();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            MovePath mp = (MovePath) rp.packet.getData()[1];</b>
&nbsp;                            // Move based on the feedback
<b class="nc">&nbsp;                            if (mp != null) {</b>
<b class="nc">&nbsp;                                mp.setGame(getGame());</b>
<b class="nc">&nbsp;                                mp.setEntity(violation);</b>
&nbsp;                                // Report
<b class="nc">&nbsp;                                r = new Report(2352);</b>
<b class="nc">&nbsp;                                r.indent(3);</b>
<b class="nc">&nbsp;                                r.subject = violation.getId();</b>
<b class="nc">&nbsp;                                r.addDesc(violation);</b>
<b class="nc">&nbsp;                                if (mp.getLastStep().getType() == MoveStepType.FORWARDS) {</b>
<b class="nc">&nbsp;                                    r.choose(false);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    r.choose(true);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                r.add(mp.getLastStep().getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                                vPhaseReport.add(r);</b>
&nbsp;                                // Move unit
<b class="nc">&nbsp;                                violation.setPosition(mp.getFinalCoords());</b>
<b class="nc">&nbsp;                                violation.mpUsed += mp.getMpUsed();</b>
<b class="nc">&nbsp;                                violation.moved = mp.getLastStepMovementType();</b>
&nbsp;                            } else { // User decided to do nothing
<b class="nc">&nbsp;                                r = new Report(2358);</b>
<b class="nc">&nbsp;                                r.indent(3);</b>
<b class="nc">&nbsp;                                r.subject = violation.getId();</b>
<b class="nc">&nbsp;                                r.addDesc(violation);</b>
<b class="nc">&nbsp;                                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                                vPhaseReport.addAll(doEntityDisplacement(violation, dest,</b>
<b class="nc">&nbsp;                                        dest.translated(direction), null));</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } else { // If no responses, treat as no action</b>
<b class="nc">&nbsp;                            vPhaseReport.addAll(doEntityDisplacement(violation,</b>
<b class="nc">&nbsp;                                    dest, dest.translated(direction),</b>
<b class="nc">&nbsp;                                    new PilotingRollData(violation.getId(), 0,</b>
&nbsp;                                            &quot;domino effect&quot;)));
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            } else { // Nope</b>
<b class="nc">&nbsp;                r = new Report(2359);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = violation.getId();</b>
<b class="nc">&nbsp;                r.addDesc(violation);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityDisplacement(violation, dest, dest.translated(direction),</b>
<b class="nc">&nbsp;                        new PilotingRollData(violation.getId(), 0, &quot;domino effect&quot;)));</b>
&nbsp;
&nbsp;            }
&nbsp;            // Update the violating entity&#39;s position on the client,
&nbsp;            // if it didn&#39;t get displaced off the board.
<b class="nc">&nbsp;            if (!game.isOutOfGame(violation)) {</b>
<b class="nc">&nbsp;                entityUpdate(violation.getId());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendDominoEffectCFR(Entity e) {
<b class="nc">&nbsp;        send(e.getOwnerId(), new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,</b>
<b class="nc">&nbsp;                new Object[] { Packet.COMMAND_CFR_DOMINO_EFFECT, e.getId() }));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendAMSAssignCFR(Entity e, Mounted ams, List&lt;WeaponAttackAction&gt; waas) {
<b class="nc">&nbsp;        send(e.getOwnerId(),</b>
&nbsp;                new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,
<b class="nc">&nbsp;                        new Object[] { Packet.COMMAND_CFR_AMS_ASSIGN,</b>
<b class="nc">&nbsp;                                e.getId(), e.getEquipmentNum(ams), waas }));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendAPDSAssignCFR(Entity e, List&lt;Integer&gt; apdsDists,
&nbsp;            List&lt;WeaponAttackAction&gt; waas) {
<b class="nc">&nbsp;        send(e.getOwnerId(), new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,</b>
<b class="nc">&nbsp;                new Object[] { Packet.COMMAND_CFR_APDS_ASSIGN, e.getId(),</b>
&nbsp;                apdsDists, waas }));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendPointBlankShotCFR(Entity hidden, Entity target) {
&nbsp;        // Send attacker/target IDs to PBS Client
<b class="nc">&nbsp;        send(hidden.getOwnerId(),</b>
&nbsp;                new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,
<b class="nc">&nbsp;                        new Object[] { Packet.COMMAND_CFR_HIDDEN_PBS,</b>
<b class="nc">&nbsp;                                hidden.getId(), target.getId() }));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendTeleguidedMissileCFR(int playerId, List&lt;Integer&gt; targetIds, List&lt;Integer&gt; toHitValues) {
&nbsp;        // Send target id numbers and to-hit values to Client
<b class="nc">&nbsp;        send(playerId, new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,</b>
<b class="nc">&nbsp;                new Object[] { Packet.COMMAND_CFR_TELEGUIDED_TARGET, targetIds, toHitValues}));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    private void sendTAGTargetCFR(int playerId, List&lt;Integer&gt; targetIds, List&lt;Integer&gt; targetTypes) {
&nbsp;        // Send target id numbers and type identifiers to Client
<b class="nc">&nbsp;        send(playerId, new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST,</b>
<b class="nc">&nbsp;                new Object[] { Packet.COMMAND_CFR_TAG_TARGET, targetIds, targetTypes}));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Vector&lt;Report&gt; doEntityDisplacementMinefieldCheck(Entity entity, Coords src, Coords dest, int elev) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        boolean boom = checkVibrabombs(entity, dest, true, vPhaseReport);</b>
<b class="nc">&nbsp;        if (game.containsMinefield(dest)) {</b>
<b class="nc">&nbsp;            boom = enterMinefield(entity, dest, elev, true, vPhaseReport) || boom;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (boom) {</b>
<b class="nc">&nbsp;            resetMines();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; doEntityDisplacementBogDownCheck(Entity entity, Coords c, int elev) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vReport = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        IHex destHex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        int bgMod = destHex.getBogDownModifier(entity.getMovementMode(),</b>
&nbsp;                entity instanceof LargeSupportTank);
<b class="nc">&nbsp;        if ((bgMod != TargetRoll.AUTOMATIC_SUCCESS)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</b>
&nbsp;                &amp;&amp; (elev == 0)) {
<b class="nc">&nbsp;            PilotingRollData roll = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(entity.getId(), bgMod, &quot;avoid bogging down&quot;));</b>
<b class="nc">&nbsp;            int stuckroll = Compute.d6(2);</b>
&nbsp;            // A DFA-ing mech is &quot;displaced&quot; into the target hex. Since it
&nbsp;            // must be jumping, it will automatically be bogged down
<b class="nc">&nbsp;            if (stuckroll &lt; roll.getValue() || entity.isMakingDfa()) {</b>
<b class="nc">&nbsp;                entity.setStuck(true);</b>
<b class="nc">&nbsp;                r = new Report(2081);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
&nbsp;                // check for quicksand
<b class="nc">&nbsp;                vReport.addAll(checkQuickSand(c));</b>
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        return vReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Receive a deployment packet. If valid, execute it and end the current
&nbsp;     * turn.
&nbsp;     */
&nbsp;    private void receiveDeployment(Packet packet, int connId) {
<b class="nc">&nbsp;        Entity entity = game.getEntity(packet.getIntValue(0));</b>
<b class="nc">&nbsp;        Coords coords = (Coords) packet.getObject(1);</b>
<b class="nc">&nbsp;        int nFacing = packet.getIntValue(2);</b>
<b class="nc">&nbsp;        int elevation = packet.getIntValue(3);</b>
&nbsp;
&nbsp;        // Handle units that deploy loaded with other units.
<b class="nc">&nbsp;        int loadedCount = packet.getIntValue(4);</b>
<b class="nc">&nbsp;        Vector&lt;Entity&gt; loadVector = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; loadedCount; i++) {</b>
<b class="nc">&nbsp;            int loadedId = packet.getIntValue(6 + i);</b>
<b class="nc">&nbsp;            loadVector.addElement(game.getEntity(loadedId));</b>
&nbsp;        }
&nbsp;
&nbsp;        // is this the right phase?
<b class="nc">&nbsp;        if (game.getPhase() != IGame.Phase.PHASE_DEPLOYMENT) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got deployment packet in wrong phase&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can this player/entity act right now?
<b class="nc">&nbsp;        final boolean assaultDrop = packet.getBooleanValue(5);</b>
&nbsp;        // can this player/entity act right now?
<b class="nc">&nbsp;        GameTurn turn = game.getTurn();</b>
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
<b class="nc">&nbsp;            turn = game.getTurnForPlayer(connId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((turn == null) || !turn.isValid(connId, entity, game)</b>
<b class="nc">&nbsp;                || !(game.getBoard().isLegalDeployment(coords, entity.getStartingPos())</b>
<b class="nc">&nbsp;                || (assaultDrop &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_ASSAULT_DROP)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.canAssaultDrop()))) {</b>
<b class="nc">&nbsp;            String msg = &quot;server got invalid deployment packet from &quot;</b>
&nbsp;                         + &quot;connection &quot; + connId;
<b class="nc">&nbsp;            if (entity != null) {</b>
<b class="nc">&nbsp;                msg += &quot;, Entity: &quot; + entity.getShortName();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg += &quot;, Entity was null!&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            MegaMek.getLogger().error(msg);</b>
<b class="nc">&nbsp;            send(connId, createTurnVectorPacket());</b>
<b class="nc">&nbsp;            send(connId, createTurnIndexPacket(turn.getPlayerNum()));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // looks like mostly everything&#39;s okay
<b class="nc">&nbsp;        processDeployment(entity, coords, nFacing, elevation, loadVector, assaultDrop);</b>
&nbsp;
&nbsp;        //Update Aero sensors for a space or atmospheric game
<b class="nc">&nbsp;        if (entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            a.updateSensorOptions();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update visibility indications if using double blind.
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            updateVisibilityIndicator(null);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        endCurrentTurn(entity);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used when an Entity that was loaded in another Entity in the Lounge is
&nbsp;     * unloaded during deployment.
&nbsp;     * @param packet the packet to be processed
&nbsp;     * @param connId the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveDeploymentUnload(Packet packet, int connId) {
<b class="nc">&nbsp;        Entity loader = game.getEntity(packet.getIntValue(0));</b>
<b class="nc">&nbsp;        Entity loaded = game.getEntity(packet.getIntValue(1));</b>
&nbsp;
<b class="nc">&nbsp;        if (game.getPhase() != Phase.PHASE_DEPLOYMENT) {</b>
<b class="nc">&nbsp;            String msg = &quot;server received deployment unload packet &quot;</b>
&nbsp;                    + &quot;outside of deployment phase from connection &quot; + connId;
<b class="nc">&nbsp;            if (loader != null) {</b>
<b class="nc">&nbsp;                msg += &quot;, Entity: &quot; + loader.getShortName();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg += &quot;, Entity was null!&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            MegaMek.getLogger().error(msg);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can this player/entity act right now?
<b class="nc">&nbsp;        GameTurn turn = game.getTurn();</b>
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
<b class="nc">&nbsp;            turn = game.getTurnForPlayer(connId);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((turn == null) || !turn.isValid(connId, loader, game)) {</b>
<b class="nc">&nbsp;            String msg = &quot;server got invalid deployment unload packet from connection &quot; + connId;</b>
<b class="nc">&nbsp;            if (loader != null) {</b>
<b class="nc">&nbsp;                msg += &quot;, Entity: &quot; + loader.getShortName();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg += &quot;, Entity was null!&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            MegaMek.getLogger().error(msg);</b>
<b class="nc">&nbsp;            send(connId, createTurnVectorPacket());</b>
<b class="nc">&nbsp;            send(connId, createTurnIndexPacket(connId));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Unload and call entityUpdate
<b class="nc">&nbsp;        unloadUnit(loader, loaded, null, 0, 0, false, true);</b>
&nbsp;
&nbsp;        // Need to update the loader
<b class="nc">&nbsp;        entityUpdate(loader.getId());</b>
&nbsp;
&nbsp;        // Now need to add a turn for the unloaded unit, to be taken immediately
&nbsp;        // Turn forced to be immediate to avoid messy turn ordering issues
&nbsp;        // (aka, how do we add the turn with individual initiative?)
<b class="nc">&nbsp;        game.insertTurnAfter(new GameTurn.SpecificEntityTurn(</b>
<b class="nc">&nbsp;                loaded.getOwnerId(), loaded.getId()), game.getTurnIndex() - 1);</b>
&nbsp;        //game.insertNextTurn(new GameTurn.SpecificEntityTurn(
&nbsp;        //        loaded.getOwnerId(), loaded.getId()));
<b class="nc">&nbsp;        send(createTurnVectorPacket());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Process a deployment packet by... deploying the entity! We load any other
&nbsp;     * specified entities inside of it too. Also, check that the deployment is
&nbsp;     * valid.
&nbsp;     */
&nbsp;    private void processDeployment(Entity entity, Coords coords, int nFacing, int elevation, Vector&lt;Entity&gt; loadVector,
&nbsp;            boolean assaultDrop) {
<b class="nc">&nbsp;        for (Entity loaded : loadVector) {</b>
<b class="nc">&nbsp;            if (loaded.getTransportId() != Entity.NONE) {</b>
&nbsp;                // we probably already loaded this unit in the chat lounge
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (loaded.getPosition() != null) {</b>
&nbsp;                // Something is fishy in Denmark.
<b class="nc">&nbsp;                MegaMek.getLogger().error(entity + &quot; can not load entity #&quot; + loaded);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            // Have the deployed unit load the indicated unit.
<b class="nc">&nbsp;            loadUnit(entity, loaded, loaded.getTargetBay());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /*
&nbsp;         * deal with starting velocity for advanced movement. Probably not the
&nbsp;         * best place to do it, but what are you going to do
&nbsp;         */
<b class="nc">&nbsp;        if (entity.isAero() &amp;&amp; game.useVectorMove()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            int[] v = {0, 0, 0, 0, 0, 0};</b>
&nbsp;
&nbsp;            // if this is the entity&#39;s first time deploying, we want to respect the &quot;velocity&quot; setting from the lobby
<b class="nc">&nbsp;            if(entity.wasNeverDeployed()) {</b>
<b class="nc">&nbsp;                if (a.getCurrentVelocityActual() &gt; 0) {</b>
<b class="nc">&nbsp;                    v[nFacing] = a.getCurrentVelocityActual();</b>
<b class="nc">&nbsp;                    entity.setVectors(v);</b>
&nbsp;                }
&nbsp;            // this means the entity is coming back from off board, so we&#39;ll rotate the velocity vector by 180
&nbsp;            // and set it to 1/2 the magnitude
&nbsp;            } else {
<b class="nc">&nbsp;                for(int x = 0; x &lt; 6; x++) {</b>
<b class="nc">&nbsp;                    v[(x + 3) % 6] = entity.getVector(x) / 2;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                entity.setVectors(v);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        entity.setPosition(coords);</b>
<b class="nc">&nbsp;        entity.setFacing(nFacing);</b>
<b class="nc">&nbsp;        entity.setSecondaryFacing(nFacing);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        if (assaultDrop) {</b>
<b class="nc">&nbsp;            entity.setAltitude(1);</b>
&nbsp;            // from the sky!
<b class="nc">&nbsp;            entity.setAssaultDropInProgress(true);</b>
<b class="nc">&nbsp;        } else if ((entity instanceof VTOL) &amp;&amp; (entity.getExternalUnits().size() &lt;= 0)) {</b>
&nbsp;            // We should let players pick, but this simplifies a lot.
&nbsp;            // Only do it for VTOLs, though; assume everything else is on the
&nbsp;            // ground.
<b class="nc">&nbsp;            entity.setElevation((hex.ceiling() - hex.surface()) + 1);</b>
<b class="nc">&nbsp;            while ((Compute.stackingViolation(game, entity, coords, null) != null)</b>
<b class="nc">&nbsp;                   &amp;&amp; (entity.getElevation() &lt;= 50)) {</b>
<b class="nc">&nbsp;                entity.setElevation(entity.getElevation() + 1);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.getElevation() &gt; 50) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Entity #&quot; + entity.getId()</b>
&nbsp;                        + &quot; appears to be in an infinite loop trying to get a legal elevation.&quot;);
&nbsp;            }
<b class="nc">&nbsp;        } else if (entity.isAero()) {</b>
&nbsp;            // if the entity is airborne, then we don&#39;t want to set its
&nbsp;            // elevation below, because that will
&nbsp;            // default to 999
<b class="nc">&nbsp;            if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                entity.setElevation(0);</b>
<b class="nc">&nbsp;                elevation = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!game.getBoard().inSpace()) {</b>
&nbsp;                // all spheroid craft should have velocity of zero in atmosphere
&nbsp;                // regardless of what was entered
<b class="nc">&nbsp;                IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;                if (a.isSpheroid() || game.getPlanetaryConditions().isVacuum()) {</b>
<b class="nc">&nbsp;                    a.setCurrentVelocity(0);</b>
<b class="nc">&nbsp;                    a.setNextVelocity(0);</b>
&nbsp;                }
&nbsp;                // make sure that entity is above the level of the hex if in
&nbsp;                // atmosphere
<b class="nc">&nbsp;                if (game.getBoard().inAtmosphere()</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getAltitude() &lt;= hex.ceiling(true))) {</b>
&nbsp;                    // you can&#39;t be grounded on low atmosphere map
<b class="nc">&nbsp;                    entity.setAltitude(hex.ceiling(true) + 1);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (entity.getMovementMode() == EntityMovementMode.SUBMARINE) {</b>
&nbsp;            // TODO : Submarines should have a selectable height.
&nbsp;            // TODO : For now, pretend they&#39;re regular naval.
<b class="nc">&nbsp;            entity.setElevation(0);</b>
<b class="nc">&nbsp;        } else if ((entity.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)) {</b>
&nbsp;            // For now, assume they&#39;re on the surface.
&nbsp;            // entity elevation is relative to hex surface
<b class="nc">&nbsp;            entity.setElevation(0);</b>
<b class="nc">&nbsp;        } else if (hex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;            entity.setElevation(0);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Building bld = game.getBoard().getBuildingAt(entity.getPosition());</b>
<b class="nc">&nbsp;            if ((bld != null) &amp;&amp; (bld.getType() == Building.WALL)) {</b>
<b class="nc">&nbsp;                entity.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;        // add the elevation that was passed into this method
&nbsp;        // TODO : currently only used for building placement, we should do this
&nbsp;        // TODO : more systematically with up/down buttons in the deployment display
<b class="nc">&nbsp;        entity.setElevation(entity.getElevation() + elevation);</b>
<b class="nc">&nbsp;        boolean wigeFlyover = entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                &amp;&amp; hex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getElevation() &gt; hex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;
&nbsp;
&nbsp;        // when first entering a building, we need to roll what type
&nbsp;        // of basement it has
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(entity.getPosition());</b>
<b class="nc">&nbsp;        if ((bldg != null)) {</b>
<b class="nc">&nbsp;            if (bldg.rollBasement(entity.getPosition(), game.getBoard(), vPhaseReport)) {</b>
<b class="nc">&nbsp;                sendChangedHex(entity.getPosition());</b>
<b class="nc">&nbsp;                Vector&lt;Building&gt; buildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                buildings.add(bldg);</b>
<b class="nc">&nbsp;                sendChangedBuildings(buildings);</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean collapse = checkBuildingCollapseWhileMoving(bldg, entity, entity.getPosition());</b>
<b class="nc">&nbsp;            if (collapse) {</b>
<b class="nc">&nbsp;                addAffectedBldg(bldg, true);</b>
<b class="nc">&nbsp;                if (wigeFlyover) {</b>
&nbsp;                // If the building is collapsed by a WiGE flying over it, the WiGE drops one level of elevation.
<b class="nc">&nbsp;                    entity.setElevation(entity.getElevation() - 1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        entity.setDone(true);</b>
<b class="nc">&nbsp;        entity.setDeployed(true);</b>
<b class="nc">&nbsp;        entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;        addReport(doSetLocationsExposure(entity, hex, false, entity.getElevation()));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive a packet that contains hexes that are automatically hit by
&nbsp;     * artillery
&nbsp;     *
&nbsp;     * @param packet the packet to be processed
&nbsp;     * @param connId the id for connection that received the packet.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveArtyAutoHitHexes(Packet packet, int connId) {
<b class="nc">&nbsp;        PlayerIDandList&lt;Coords&gt; artyAutoHitHexes = (PlayerIDandList&lt;Coords&gt;) packet</b>
<b class="nc">&nbsp;                .getObject(0);</b>
&nbsp;
<b class="nc">&nbsp;        int playerId = artyAutoHitHexes.getPlayerID();</b>
&nbsp;
&nbsp;        // is this the right phase?
<b class="nc">&nbsp;        if (game.getPhase() != IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got set artyautohithexespacket in wrong phase&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        game.getPlayer(playerId).setArtyAutoHitHexes(artyAutoHitHexes);</b>
&nbsp;
<b class="nc">&nbsp;        for (Coords coord : artyAutoHitHexes) {</b>
<b class="nc">&nbsp;            game.getBoard().addSpecialHexDisplay(coord,</b>
&nbsp;                    new SpecialHexDisplay(
&nbsp;                            SpecialHexDisplay.Type.ARTILLERY_AUTOHIT,
<b class="nc">&nbsp;                            SpecialHexDisplay.NO_ROUND, getPlayer(playerId),</b>
&nbsp;                            &quot;Artillery auto hit hex, for &quot;
<b class="nc">&nbsp;                            + getPlayer(playerId).getName(),</b>
&nbsp;                            SpecialHexDisplay.SHD_OBSCURED_TEAM));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        endCurrentTurn(null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive a packet that contains minefields
&nbsp;     *
&nbsp;     * @param packet the packet to be processed
&nbsp;     * @param connId the id for connection that received the packet.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveDeployMinefields(Packet packet, int connId) {
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; minefields = (Vector&lt;Minefield&gt;) packet.getObject(0);</b>
&nbsp;
&nbsp;        // is this the right phase?
<b class="nc">&nbsp;        if (game.getPhase() != IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got deploy minefields packet in wrong phase&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // looks like mostly everything&#39;s okay
<b class="nc">&nbsp;        processDeployMinefields(minefields);</b>
<b class="nc">&nbsp;        endCurrentTurn(null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * process deployment of minefields
&nbsp;     *
&nbsp;     * @param minefields
&nbsp;     */
&nbsp;    private void processDeployMinefields(Vector&lt;Minefield&gt; minefields) {
<b class="nc">&nbsp;        int playerId = IPlayer.PLAYER_NONE;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; minefields.size(); i++) {</b>
<b class="nc">&nbsp;            Minefield mf = minefields.elementAt(i);</b>
<b class="nc">&nbsp;            playerId = mf.getPlayerId();</b>
&nbsp;
<b class="nc">&nbsp;            game.addMinefield(mf);</b>
<b class="nc">&nbsp;            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {</b>
<b class="nc">&nbsp;                game.addVibrabomb(mf);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IPlayer player = game.getPlayer(playerId);</b>
<b class="nc">&nbsp;        if (null != player) {</b>
<b class="nc">&nbsp;            int teamId = player.getTeam();</b>
&nbsp;
<b class="nc">&nbsp;            if (teamId != IPlayer.TEAM_NONE) {</b>
<b class="nc">&nbsp;                Enumeration&lt;Team&gt; teams = game.getTeams();</b>
<b class="nc">&nbsp;                while (teams.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    Team team = teams.nextElement();</b>
<b class="nc">&nbsp;                    if (team.getId() == teamId) {</b>
<b class="nc">&nbsp;                        Enumeration&lt;IPlayer&gt; players = team.getPlayers();</b>
<b class="nc">&nbsp;                        while (players.hasMoreElements()) {</b>
<b class="nc">&nbsp;                            IPlayer teamPlayer = players.nextElement();</b>
<b class="nc">&nbsp;                            if (teamPlayer.getId() != player.getId()) {</b>
<b class="nc">&nbsp;                                send(teamPlayer.getId(), new Packet(Packet.COMMAND_DEPLOY_MINEFIELDS,</b>
&nbsp;                                        minefields));
&nbsp;                            }
<b class="nc">&nbsp;                            teamPlayer.addMinefields(minefields);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                        break;
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                player.addMinefields(minefields);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Client has sent an update indicating that a ground unit is firing at
&nbsp;     * an airborne unit and is overriding the default select for the position
&nbsp;     * in the flight path.
&nbsp;     * @param packet the packet to be processed
&nbsp;     * @param connId the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveGroundToAirHexSelectPacket(Packet packet, int connId) {
<b class="nc">&nbsp;        Integer targetId = (Integer)packet.getObject(0);</b>
<b class="nc">&nbsp;        Integer attackerId = (Integer)packet.getObject(1);</b>
<b class="nc">&nbsp;        Coords pos = (Coords)packet.getObject(2);</b>
<b class="nc">&nbsp;        game.getEntity(targetId).setPlayerPickedPassThrough(attackerId, pos);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a bunch of entity attacks from the packet. If valid, processes them
&nbsp;     * and ends the current turn.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveAttack(Packet packet, int connId) {
<b class="nc">&nbsp;        Entity entity = game.getEntity(packet.getIntValue(0));</b>
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; vector = (Vector&lt;EntityAction&gt;) packet.getObject(1);</b>
&nbsp;
&nbsp;        // is this the right phase?
<b class="nc">&nbsp;        if ((game.getPhase() != IGame.Phase.PHASE_FIRING)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() != IGame.Phase.PHASE_PHYSICAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() != IGame.Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() != IGame.Phase.PHASE_OFFBOARD)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got attack packet in wrong phase&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can this player/entity act right now?
<b class="nc">&nbsp;        GameTurn turn = game.getTurn();</b>
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
<b class="nc">&nbsp;            turn = game.getTurnForPlayer(connId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((turn == null) || !turn.isValid(connId, entity, game)) {</b>
<b class="nc">&nbsp;            String msg = &quot;error: server got invalid attack packet from connection &quot; + connId;</b>
<b class="nc">&nbsp;            if (entity != null) {</b>
<b class="nc">&nbsp;                msg += &quot;, Entity: &quot; + entity.getShortName();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg += &quot;, Entity was null!&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            MegaMek.getLogger().error(msg);</b>
<b class="nc">&nbsp;            send(connId, createTurnVectorPacket());</b>
<b class="nc">&nbsp;            send(connId, createTurnIndexPacket(turn.getPlayerNum()));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // looks like mostly everything&#39;s okay
<b class="nc">&nbsp;        processAttack(entity, vector);</b>
&nbsp;
&nbsp;        // Update visibility indications if using double blind.
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            updateVisibilityIndicator(null);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        endCurrentTurn(entity);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Process a batch of entity attack (or twist) actions by adding them to the
&nbsp;     * proper list to be processed later.
&nbsp;     */
&nbsp;    private void processAttack(Entity entity, Vector&lt;EntityAction&gt; vector) {
&nbsp;        // Convert any null vectors to empty vectors to avoid NPEs.
<b class="nc">&nbsp;        if (vector == null) {</b>
<b class="nc">&nbsp;            vector = new Vector&lt;&gt;(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Not **all** actions take up the entity&#39;s turn.
<b class="nc">&nbsp;        boolean setDone = !((game.getTurn() instanceof GameTurn.TriggerAPPodTurn)</b>
<b class="nc">&nbsp;                || (game.getTurn() instanceof GameTurn.TriggerBPodTurn));</b>
<b class="nc">&nbsp;        for (EntityAction ea : vector) {</b>
&nbsp;            // is this the right entity?
<b class="nc">&nbsp;            if (ea.getEntityId() != entity.getId()) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Attack packet has wrong attacker&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ea instanceof PushAttackAction) {</b>
&nbsp;                // push attacks go the end of the displacement attacks
<b class="nc">&nbsp;                PushAttackAction paa = (PushAttackAction) ea;</b>
<b class="nc">&nbsp;                entity.setDisplacementAttack(paa);</b>
<b class="nc">&nbsp;                game.addCharge(paa);</b>
<b class="nc">&nbsp;            } else if (ea instanceof DodgeAction) {</b>
<b class="nc">&nbsp;                entity.dodging = true;</b>
<b class="nc">&nbsp;            } else if (ea instanceof SpotAction) {</b>
<b class="nc">&nbsp;                entity.setSpotting(true);</b>
<b class="nc">&nbsp;                entity.setSpotTargetId(((SpotAction) ea).getTargetId());</b>
&nbsp;            } else {
&nbsp;                // add to the normal attack list.
<b class="nc">&nbsp;                game.addAction(ea);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Anti-mech and pointblank attacks from
&nbsp;            // hiding may allow the target to respond.
<b class="nc">&nbsp;            if (ea instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                final WeaponAttackAction waa = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                final String weaponName = entity.getEquipment(waa.getWeaponId()).getType()</b>
<b class="nc">&nbsp;                        .getInternalName();</b>
&nbsp;
<b class="nc">&nbsp;                if (Infantry.SWARM_MEK.equals(weaponName) || Infantry.LEG_ATTACK.equals(weaponName)) {</b>
&nbsp;
&nbsp;                    // Does the target have any AP Pods available?
<b class="nc">&nbsp;                    final Entity target = game.getEntity(waa.getTargetId());</b>
<b class="nc">&nbsp;                    for (Mounted equip : target.getMisc()) {</b>
<b class="nc">&nbsp;                        if (equip.getType().hasFlag(MiscType.F_AP_POD) &amp;&amp; equip.canFire()) {</b>
&nbsp;
&nbsp;                            // Yup. Insert a game turn to handle AP pods.
&nbsp;                            // ASSUMPTION : AP pod declarations come
&nbsp;                            // immediately after the attack declaration.
<b class="nc">&nbsp;                            game.insertNextTurn(new GameTurn.TriggerAPPodTurn(target.getOwnerId(),</b>
<b class="nc">&nbsp;                                    target.getId()));</b>
<b class="nc">&nbsp;                            send(createTurnVectorPacket());</b>
&nbsp;
&nbsp;                            // We can stop looking.
<b class="nc">&nbsp;                            break;</b>
&nbsp;
&nbsp;                        } // end found-available-ap-pod
&nbsp;
<b class="nc">&nbsp;                    } // Check the next piece of equipment on the target.</b>
&nbsp;
<b class="nc">&nbsp;                    for (Mounted weapon : target.getWeaponList()) {</b>
<b class="nc">&nbsp;                        if (weapon.getType().hasFlag(WeaponType.F_B_POD) &amp;&amp; weapon.canFire()) {</b>
&nbsp;
&nbsp;                            // Yup. Insert a game turn to handle B pods.
&nbsp;                            // ASSUMPTION : B pod declarations come
&nbsp;                            // immediately after the attack declaration.
<b class="nc">&nbsp;                            game.insertNextTurn(new GameTurn.TriggerBPodTurn(target.getOwnerId(),</b>
<b class="nc">&nbsp;                                    target.getId(), weaponName));</b>
<b class="nc">&nbsp;                            send(createTurnVectorPacket());</b>
&nbsp;
&nbsp;                            // We can stop looking.
<b class="nc">&nbsp;                            break;</b>
&nbsp;
&nbsp;                        } // end found-available-b-pod
<b class="nc">&nbsp;                    } // Check the next piece of equipment on the target.</b>
&nbsp;                } // End check-for-available-ap-pod
&nbsp;
&nbsp;                // Keep track of altitude loss for weapon attacks
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    IAero aero = (IAero) entity;</b>
<b class="nc">&nbsp;                    if (waa.getAltitudeLoss(game) &gt; aero.getAltLoss()) {</b>
<b class="nc">&nbsp;                        aero.setAltLoss(waa.getAltitudeLoss(game));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If attacker breaks grapple, defender may counter
<b class="nc">&nbsp;            if (ea instanceof BreakGrappleAttackAction) {</b>
<b class="nc">&nbsp;                final BreakGrappleAttackAction bgaa = (BreakGrappleAttackAction) ea;</b>
<b class="nc">&nbsp;                final Entity att = (game.getEntity(bgaa.getEntityId()));</b>
<b class="nc">&nbsp;                if (att.isGrappleAttacker()) {</b>
<b class="nc">&nbsp;                    final Entity def = (game.getEntity(bgaa.getTargetId()));</b>
&nbsp;                    // Remove existing break grapple by defender (if exists)
<b class="nc">&nbsp;                    if (def.isDone()) {</b>
<b class="nc">&nbsp;                        game.removeActionsFor(def.getId());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        game.removeTurnFor(def);</b>
<b class="nc">&nbsp;                        def.setDone(true);</b>
&nbsp;                    }
&nbsp;                    // If defender is able, add a turn to declare counterattack
<b class="nc">&nbsp;                    if (!def.isImmobile()) {</b>
<b class="nc">&nbsp;                        game.insertNextTurn(new GameTurn.CounterGrappleTurn(def.getOwnerId(), def.getId()));</b>
<b class="nc">&nbsp;                        send(createTurnVectorPacket());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (ea instanceof ArtilleryAttackAction) {</b>
<b class="nc">&nbsp;                boolean firingAtNewHex = false;</b>
<b class="nc">&nbsp;                final ArtilleryAttackAction aaa = (ArtilleryAttackAction) ea;</b>
<b class="nc">&nbsp;                final Entity firingEntity = game.getEntity(aaa.getEntityId());</b>
<b class="nc">&nbsp;                for (Enumeration&lt;AttackHandler&gt; j = game.getAttacks(); !firingAtNewHex</b>
<b class="nc">&nbsp;                        &amp;&amp; j.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                    WeaponHandler wh = (WeaponHandler) j.nextElement();</b>
<b class="nc">&nbsp;                    if (wh.waa instanceof ArtilleryAttackAction) {</b>
<b class="nc">&nbsp;                        ArtilleryAttackAction oaaa = (ArtilleryAttackAction) wh.waa;</b>
<b class="nc">&nbsp;                        if ((oaaa.getEntityId() == aaa.getEntityId())</b>
<b class="nc">&nbsp;                            &amp;&amp; !oaaa.getTarget(game).getPosition()</b>
<b class="nc">&nbsp;                                .equals(aaa.getTarget(game).getPosition())) {</b>
<b class="nc">&nbsp;                            firingAtNewHex = true;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (firingAtNewHex) {</b>
<b class="nc">&nbsp;                    clearArtillerySpotters(firingEntity.getId(), aaa.getWeaponId());</b>
&nbsp;                }
<b class="nc">&nbsp;                Iterator&lt;Entity&gt; spotters = game.getSelectedEntities(new EntitySelector() {</b>
<b class="nc">&nbsp;                            public int player = firingEntity.getOwnerId();</b>
<b class="nc">&nbsp;                            public Targetable target = aaa.getTarget(game);</b>
&nbsp;
&nbsp;                            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                                LosEffects los = LosEffects.calculateLos(game, entity.getId(), target);</b>
<b class="nc">&nbsp;                                return ((player == entity.getOwnerId()) &amp;&amp; !(los.isBlocked())</b>
<b class="nc">&nbsp;                                        &amp;&amp; entity.isActive());</b>
&nbsp;                            }
&nbsp;                        });
<b class="nc">&nbsp;                Vector&lt;Integer&gt; spotterIds = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                while (spotters.hasNext()) {</b>
<b class="nc">&nbsp;                    Integer id = spotters.next().getId();</b>
<b class="nc">&nbsp;                    spotterIds.addElement(id);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                aaa.setSpotterIds(spotterIds);</b>
&nbsp;            }
&nbsp;
&nbsp;            // The equipment type of a club needs to be restored.
<b class="nc">&nbsp;            if (ea instanceof ClubAttackAction) {</b>
<b class="nc">&nbsp;                ClubAttackAction caa = (ClubAttackAction) ea;</b>
<b class="nc">&nbsp;                Mounted club = caa.getClub();</b>
<b class="nc">&nbsp;                club.restore();</b>
&nbsp;            }
&nbsp;
&nbsp;            // Mark any AP Pod as used in this turn.
<b class="nc">&nbsp;            if (ea instanceof TriggerAPPodAction) {</b>
<b class="nc">&nbsp;                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;</b>
<b class="nc">&nbsp;                Mounted pod = entity.getEquipment(tapa.getPodId());</b>
<b class="nc">&nbsp;                pod.setUsedThisRound(true);</b>
&nbsp;            }
&nbsp;            // Mark any B Pod as used in this turn.
<b class="nc">&nbsp;            if (ea instanceof TriggerBPodAction) {</b>
<b class="nc">&nbsp;                TriggerBPodAction tba = (TriggerBPodAction) ea;</b>
<b class="nc">&nbsp;                Mounted pod = entity.getEquipment(tba.getPodId());</b>
<b class="nc">&nbsp;                pod.setUsedThisRound(true);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Mark illuminated hexes, so they can be displayed
<b class="nc">&nbsp;            if (ea instanceof SearchlightAttackAction) {</b>
<b class="nc">&nbsp;                boolean hexesAdded =</b>
<b class="nc">&nbsp;                        ((SearchlightAttackAction) ea).setHexesIlluminated(game);</b>
&nbsp;                // If we added new hexes, send them to all players.
&nbsp;                // These are spotlights at night, you know they&#39;re there.
<b class="nc">&nbsp;                if (hexesAdded) {</b>
<b class="nc">&nbsp;                    send(createIlluminatedHexesPacket());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Apply altitude loss
<b class="nc">&nbsp;        if (entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero aero = (IAero) entity;</b>
<b class="nc">&nbsp;            if (aero.getAltLoss() &gt; 0) {</b>
<b class="nc">&nbsp;                Report r = new Report(9095);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(aero.getAltLoss());</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                entity.setAltitude(entity.getAltitude() - aero.getAltLoss());</b>
<b class="nc">&nbsp;                aero.setAltLossThisRound(aero.getAltLoss());</b>
<b class="nc">&nbsp;                aero.resetAltLoss();</b>
<b class="nc">&nbsp;                entityUpdate(entity.getId());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Unless otherwise stated,
&nbsp;        // this entity is done for the round.
<b class="nc">&nbsp;        if (setDone) {</b>
<b class="nc">&nbsp;            entity.setDone(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        entityUpdate(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;        Packet p = createAttackPacket(vector, 0);</b>
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
&nbsp;            // Update attack only to player who declared it &amp; observers
<b class="nc">&nbsp;            for (IPlayer player : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;                if (player.canSeeAll() || player.isObserver()</b>
<b class="nc">&nbsp;                    || (entity.getOwnerId() == player.getId())) {</b>
<b class="nc">&nbsp;                    send(player.getId(), p);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
&nbsp;            // update all players on the attacks. Don&#39;t worry about pushes being
&nbsp;            // a &quot;charge&quot; attack. It doesn&#39;t matter to the client.
<b class="nc">&nbsp;            send(p);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine which telemissile attack actions could be affected by AMS, and
&nbsp;     * assign AMS to those attacks.
&nbsp;     */
&nbsp;    public void assignTeleMissileAMS(TeleMissileAttackAction taa) {
&nbsp;        // Map target to a list of telemissile attacks directed at entities
<b class="nc">&nbsp;        Hashtable&lt;Entity, Vector&lt;AttackAction&gt;&gt; htTMAttacks = new Hashtable&lt;&gt;();</b>
&nbsp;
&nbsp;        //This should be impossible but just in case...
<b class="nc">&nbsp;        if (taa == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Null TeleMissileAttackAction!&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entity target = (taa.getTargetType() == Targetable.TYPE_ENTITY)</b>
<b class="nc">&nbsp;                ? (Entity) taa.getTarget(game) : null;</b>
&nbsp;
&nbsp;        //If a telemissile is still on the board and its original target is not....
<b class="nc">&nbsp;        if (target == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().info(&quot;Telemissile has no target. AMS not assigned.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Vector&lt;AttackAction&gt; v = htTMAttacks.computeIfAbsent(target, k -&gt; new Vector&lt;&gt;());</b>
<b class="nc">&nbsp;        v.addElement(taa);</b>
&nbsp;        // Let each target assign its AMS
<b class="nc">&nbsp;        for (Entity e : htTMAttacks.keySet()) {</b>
<b class="nc">&nbsp;            Vector&lt;AttackAction&gt; vTMAttacks = htTMAttacks.get(e);</b>
&nbsp;            // Allow MM to automatically assign AMS targets
&nbsp;            // AMS bays can fire multiple times, so manual target assignment is kind of pointless
<b class="nc">&nbsp;            e.assignTMAMS(vTMAttacks);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine which missile attack actions could be affected by AMS, and
&nbsp;     * assign AMS (and APDS) to those attacks.
&nbsp;     */
&nbsp;    public void assignAMS() {
&nbsp;        // Get all of the coords that would be protected by APDS
<b class="nc">&nbsp;        Hashtable&lt;Coords, List&lt;Mounted&gt;&gt; apdsCoords = getAPDSProtectedCoords();</b>
&nbsp;        // Map target to a list of missile attacks directed at it
<b class="nc">&nbsp;        Hashtable&lt;Entity, Vector&lt;WeaponHandler&gt;&gt; htAttacks = new Hashtable&lt;&gt;();</b>
&nbsp;        // Keep track of each APDS, and which attacks it could affect
<b class="nc">&nbsp;        Hashtable&lt;Mounted, Vector&lt;WeaponHandler&gt;&gt; apdsTargets = new Hashtable&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (AttackHandler ah : game.getAttacksVector()) {</b>
<b class="nc">&nbsp;            WeaponHandler wh = (WeaponHandler) ah;</b>
<b class="nc">&nbsp;            WeaponAttackAction waa = wh.waa;</b>
&nbsp;
&nbsp;            // for artillery attacks, the attacking entity
&nbsp;            // might no longer be in the game.
&nbsp;            //TODO : Yeah, I know there&#39;s an exploit here, but better able to shoot some ArrowIVs than none, right?
<b class="nc">&nbsp;            if (game.getEntity(waa.getEntityId()) == null) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().info(&quot;Can&#39;t Assign AMS: Artillery firer is null!&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(waa.getWeaponId());</b>
&nbsp;
&nbsp;            // Only entities can have AMS. Arrow IV doesn&#39;t target an entity until later, so we have to ignore them
<b class="nc">&nbsp;            if (!(waa instanceof ArtilleryAttackAction) &amp;&amp; (Targetable.TYPE_ENTITY != waa.getTargetType())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // AMS is only used against attacks that hit (TW p129)
<b class="nc">&nbsp;            if (wh.roll &lt; wh.toHit.getValue()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Can only use AMS versus missiles. Artillery Bays might be firing Arrow IV homing missiles,
&nbsp;            // but lack the flag
<b class="nc">&nbsp;            boolean isHomingMissile = false;</b>
<b class="nc">&nbsp;            if (wh instanceof ArtilleryWeaponIndirectHomingHandler</b>
&nbsp;                    || wh instanceof ArtilleryBayWeaponIndirectHomingHandler) {
<b class="nc">&nbsp;                Mounted ammoUsed = game.getEntity(waa.getEntityId()).getEquipment(waa.getAmmoId());</b>
<b class="nc">&nbsp;                AmmoType atype = ammoUsed == null ? null : (AmmoType) ammoUsed.getType();</b>
<b class="nc">&nbsp;                if (atype != null </b>
<b class="nc">&nbsp;                        &amp;&amp; (atype.getAmmoType() == AmmoType.T_ARROW_IV || atype.getAmmoType() == BombType.B_HOMING)) {</b>
<b class="nc">&nbsp;                    isHomingMissile = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!weapon.getType().hasFlag(WeaponType.F_MISSILE) &amp;&amp; !isHomingMissile) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // For Bearings-only Capital Missiles, don&#39;t assign during the offboard phase
<b class="nc">&nbsp;            if (wh instanceof CapitalMissileBearingsOnlyHandler) {</b>
<b class="nc">&nbsp;                ArtilleryAttackAction aaa = (ArtilleryAttackAction) waa;</b>
<b class="nc">&nbsp;                if (aaa.getTurnsTilHit() &gt; 0 || game.getPhase() != IGame.Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // For Arrow IV homing artillery
&nbsp;            Entity target;
<b class="nc">&nbsp;            if (waa instanceof ArtilleryAttackAction) {</b>
<b class="nc">&nbsp;                target = (waa.getTargetType() == Targetable.TYPE_ENTITY) ? (Entity) waa</b>
<b class="nc">&nbsp;                    .getTarget(game) : null;</b>
&nbsp;
&nbsp;                // In case our target really is null.
<b class="nc">&nbsp;                if (target == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                target = game.getEntity(waa.getTargetId());</b>
&nbsp;            }
<b class="nc">&nbsp;            Vector&lt;WeaponHandler&gt; v = htAttacks.computeIfAbsent(target, k -&gt; new Vector&lt;&gt;());</b>
<b class="nc">&nbsp;            v.addElement(wh);</b>
&nbsp;            // Keep track of what weapon attacks could be affected by APDS
<b class="nc">&nbsp;            if (apdsCoords.containsKey(target.getPosition())) {</b>
<b class="nc">&nbsp;                for (Mounted apds : apdsCoords.get(target.getPosition())) {</b>
&nbsp;                    // APDS only affects attacks against friendly units
<b class="nc">&nbsp;                    if (target.isEnemyOf(apds.getEntity())) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Vector&lt;WeaponHandler&gt; handlerList = apdsTargets.computeIfAbsent(apds, k -&gt; new Vector&lt;&gt;());</b>
<b class="nc">&nbsp;                    handlerList.add(wh);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // Let each target assign its AMS
<b class="nc">&nbsp;        for (Entity e : htAttacks.keySet()) {</b>
<b class="nc">&nbsp;            Vector&lt;WeaponHandler&gt; vAttacks = htAttacks.get(e);</b>
&nbsp;            // Allow MM to automatically assign AMS targets
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.BASE_AUTO_AMS)) {</b>
<b class="nc">&nbsp;                e.assignAMS(vAttacks);</b>
&nbsp;            } else { // Allow user to manually assign targets
<b class="nc">&nbsp;                manuallyAssignAMSTarget(e, vAttacks);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Let each APDS assign itself to an attack
<b class="nc">&nbsp;        Set&lt;WeaponAttackAction&gt; targetedAttacks = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Mounted apds : apdsTargets.keySet()) {</b>
<b class="nc">&nbsp;            List&lt;WeaponHandler&gt; potentialTargets = apdsTargets.get(apds);</b>
&nbsp;            // Ensure we only target each attack once
<b class="nc">&nbsp;            List&lt;WeaponHandler&gt; targetsToRemove = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (WeaponHandler wh : potentialTargets) {</b>
<b class="nc">&nbsp;                if (targetedAttacks.contains(wh.getWaa())) {</b>
<b class="nc">&nbsp;                    targetsToRemove.add(wh);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            potentialTargets.removeAll(targetsToRemove);</b>
&nbsp;            WeaponAttackAction targetedWAA;
&nbsp;            // Assign APDS to an attack
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.BASE_AUTO_AMS)) {</b>
<b class="nc">&nbsp;                targetedWAA = apds.assignAPDS(potentialTargets);</b>
&nbsp;            } else { // Allow user to manually assign targets
<b class="nc">&nbsp;                targetedWAA = manuallyAssignAPDSTarget(apds, potentialTargets);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (targetedWAA != null) {</b>
<b class="nc">&nbsp;                targetedAttacks.add(targetedWAA);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for determining which missile attack will be targeted
&nbsp;     * with AMS on the supplied Entity
&nbsp;     *
&nbsp;     * @param apds
&nbsp;     *            The Entity with AMS
&nbsp;     * @param vAttacks
&nbsp;     *            List of missile attacks directed at e
&nbsp;     */
&nbsp;    private WeaponAttackAction manuallyAssignAPDSTarget(Mounted apds,
&nbsp;            List&lt;WeaponHandler&gt; vAttacks) {
<b class="nc">&nbsp;        Entity e = apds.getEntity();</b>
<b class="nc">&nbsp;        if (e == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Create a list of valid assignments for this APDS
<b class="nc">&nbsp;        List&lt;WeaponAttackAction&gt; vAttacksInArc = new ArrayList&lt;&gt;(vAttacks.size());</b>
<b class="nc">&nbsp;        for (WeaponHandler wr : vAttacks) {</b>
<b class="nc">&nbsp;            boolean isInArc = Compute.isInArc(e.getGame(), e.getId(),</b>
<b class="nc">&nbsp;                    e.getEquipmentNum(apds),</b>
<b class="nc">&nbsp;                    game.getEntity(wr.waa.getEntityId()));</b>
<b class="nc">&nbsp;            boolean isInRange = e.getPosition().distance(</b>
<b class="nc">&nbsp;                    wr.getWaa().getTarget(game).getPosition()) &lt;= 3;</b>
<b class="nc">&nbsp;            if (isInArc &amp;&amp; isInRange) {</b>
<b class="nc">&nbsp;                vAttacksInArc.add(wr.waa);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If there are no valid attacks left, don&#39;t bother
<b class="nc">&nbsp;        if (vAttacksInArc.size() &lt; 1) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        WeaponAttackAction targetedWAA = null;</b>
&nbsp;
<b class="nc">&nbsp;        if (apds.curMode().equals(&quot;Automatic&quot;)) {</b>
<b class="nc">&nbsp;            targetedWAA = Compute.getHighestExpectedDamage(game,</b>
&nbsp;                    vAttacksInArc, true);
&nbsp;        } else {
&nbsp;            // Send a client feedback request
<b class="nc">&nbsp;            List&lt;Integer&gt; apdsDists = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (WeaponAttackAction waa : vAttacksInArc) {</b>
<b class="nc">&nbsp;                apdsDists.add(waa.getTarget(game).getPosition()</b>
<b class="nc">&nbsp;                        .distance(e.getPosition()));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            sendAPDSAssignCFR(e, apdsDists, vAttacksInArc);</b>
<b class="nc">&nbsp;            synchronized (cfrPacketQueue) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    cfrPacketQueue.wait();</b>
<b class="nc">&nbsp;                } catch (InterruptedException ex) {</b>
&nbsp;                    // Do nothing
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (cfrPacketQueue.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    ReceivedPacket rp = cfrPacketQueue.poll();</b>
<b class="nc">&nbsp;                    int cfrType = (int) rp.packet.getData()[0];</b>
&nbsp;                    // Make sure we got the right type of response
<b class="nc">&nbsp;                    if (cfrType != Packet.COMMAND_CFR_APDS_ASSIGN) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Expected a COMMAND_CFR_AMS_ASSIGN CFR packet, received: &quot; + cfrType);</b>
<b class="nc">&nbsp;                        throw new IllegalStateException();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Integer waaIndex =</b>
<b class="nc">&nbsp;                            (Integer)rp.packet.getData()[1];</b>
<b class="nc">&nbsp;                    if (waaIndex != null) {</b>
<b class="nc">&nbsp;                        targetedWAA = vAttacksInArc.get(waaIndex);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (targetedWAA != null) {</b>
<b class="nc">&nbsp;            targetedWAA.addCounterEquipment(apds);</b>
<b class="nc">&nbsp;            return targetedWAA;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for determining which missile attack will be targeted
&nbsp;     * with AMS on the supplied Entity
&nbsp;     *
&nbsp;     * @param e
&nbsp;     *            The Entity with AMS
&nbsp;     * @param vAttacks
&nbsp;     *            List of missile attacks directed at e
&nbsp;     */
&nbsp;    private void manuallyAssignAMSTarget(Entity e,
&nbsp;            Vector&lt;WeaponHandler&gt; vAttacks) {
&nbsp;        //Fix for bug #1051 - don&#39;t send the targeting nag for a shutdown unit
<b class="nc">&nbsp;        if (e.isShutDown()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // Current AMS targets: each attack can only be targeted once
<b class="nc">&nbsp;        HashSet&lt;WeaponAttackAction&gt; amsTargets = new HashSet&lt;&gt;();</b>
&nbsp;        // Pick assignment for each active AMS
<b class="nc">&nbsp;        for (Mounted ams : e.getActiveAMS()) {</b>
&nbsp;            // Skip APDS
<b class="nc">&nbsp;            if (ams.isAPDS()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // Create a list of valid assignments for this AMS
<b class="nc">&nbsp;            List&lt;WeaponAttackAction&gt; vAttacksInArc = new ArrayList&lt;&gt;(vAttacks.size());</b>
<b class="nc">&nbsp;            for (WeaponHandler wr : vAttacks) {</b>
<b class="nc">&nbsp;                if (!amsTargets.contains(wr.waa)</b>
<b class="nc">&nbsp;                        &amp;&amp; Compute.isInArc(game, e.getId(),</b>
<b class="nc">&nbsp;                                e.getEquipmentNum(ams),</b>
<b class="nc">&nbsp;                                game.getEntity(wr.waa.getEntityId()))) {</b>
<b class="nc">&nbsp;                    vAttacksInArc.add(wr.waa);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // If there are no valid attacks left, don&#39;t bother
<b class="nc">&nbsp;            if (vAttacksInArc.size() &lt; 1) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            WeaponAttackAction targetedWAA = null;</b>
&nbsp;
<b class="nc">&nbsp;            if (ams.curMode().equals(&quot;Automatic&quot;)) {</b>
<b class="nc">&nbsp;                targetedWAA = Compute.getHighestExpectedDamage(game,</b>
&nbsp;                        vAttacksInArc, true);
&nbsp;            } else {
&nbsp;                // Send a client feedback request
<b class="nc">&nbsp;                sendAMSAssignCFR(e, ams, vAttacksInArc);</b>
<b class="nc">&nbsp;                synchronized (cfrPacketQueue) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        cfrPacketQueue.wait();</b>
<b class="nc">&nbsp;                    } catch (InterruptedException ex) {</b>
&nbsp;                        // Do nothing
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (cfrPacketQueue.size() &gt; 0) {</b>
<b class="nc">&nbsp;                        ReceivedPacket rp = cfrPacketQueue.poll();</b>
<b class="nc">&nbsp;                        int cfrType = (int) rp.packet.getData()[0];</b>
&nbsp;                        // Make sure we got the right type of response
<b class="nc">&nbsp;                        if (cfrType != Packet.COMMAND_CFR_AMS_ASSIGN) {</b>
<b class="nc">&nbsp;                            MegaMek.getLogger().error(&quot;Expected a COMMAND_CFR_AMS_ASSIGN CFR packet, received: &quot; + cfrType);</b>
<b class="nc">&nbsp;                            throw new IllegalStateException();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Integer waaIndex =</b>
<b class="nc">&nbsp;                                (Integer)rp.packet.getData()[1];</b>
<b class="nc">&nbsp;                        if (waaIndex != null) {</b>
<b class="nc">&nbsp;                            targetedWAA = vAttacksInArc.get(waaIndex);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (targetedWAA != null) {</b>
<b class="nc">&nbsp;                targetedWAA.addCounterEquipment(ams);</b>
<b class="nc">&nbsp;                amsTargets.add(targetedWAA);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for computing a mapping of which Coords are
&nbsp;     * &quot;protected&quot; by an APDS. Protection implies that the coords is within the
&nbsp;     * range/arc of an active APDS.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    private Hashtable&lt;Coords, List&lt;Mounted&gt;&gt; getAPDSProtectedCoords() {
&nbsp;        // Get all of the coords that would be protected by APDS
<b class="nc">&nbsp;        Hashtable&lt;Coords, List&lt;Mounted&gt;&gt; apdsCoords = new Hashtable&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
&nbsp;            // Ignore Entitys without positions
<b class="nc">&nbsp;            if (e.getPosition() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Coords origPos = e.getPosition();</b>
<b class="nc">&nbsp;            for (Mounted ams : e.getActiveAMS()) {</b>
&nbsp;                // Ignore non-APDS AMS
<b class="nc">&nbsp;                if (!ams.isAPDS()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Add the current hex as a defended location
<b class="nc">&nbsp;                List&lt;Mounted&gt; apdsList = apdsCoords.computeIfAbsent(origPos, k -&gt; new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;                apdsList.add(ams);</b>
&nbsp;                // Add each coords that is within arc/range as protected
<b class="nc">&nbsp;                int maxDist = 3;</b>
<b class="nc">&nbsp;                if (e instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                    int numTroopers = ((BattleArmor) e)</b>
<b class="nc">&nbsp;                            .getNumberActiverTroopers();</b>
<b class="nc">&nbsp;                    switch (numTroopers) {</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            maxDist = 1;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 2:
&nbsp;                        case 3:
<b class="nc">&nbsp;                            maxDist = 2;</b>
&nbsp;                            break;
&nbsp;                    // Anything above is the same as the default
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                for (int dist = 1; dist &lt;= maxDist; dist++) {</b>
<b class="nc">&nbsp;                    List&lt;Coords&gt; coords = e.getPosition().allAtDistance(dist);</b>
<b class="nc">&nbsp;                    for (Coords pos : coords) {</b>
&nbsp;                        // Check that we&#39;re in the right arc
<b class="nc">&nbsp;                        if (Compute.isInArc(game, e.getId(), e.getEquipmentNum(ams),</b>
<b class="nc">&nbsp;                                new HexTarget(pos, game.getBoard(), HexTarget.TYPE_HEX_CLEAR))) {</b>
<b class="nc">&nbsp;                            apdsList = apdsCoords.computeIfAbsent(pos, k -&gt; new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;                            apdsList.add(ams);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return apdsCoords;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called at the start and end of movement. Determines if an entity
&nbsp;     * has been detected and/or had a firing solution calculated
&nbsp;     */
&nbsp;    private void detectSpacecraft() {
&nbsp;        // Don&#39;t bother if we&#39;re not in space or if the game option isn&#39;t on
<b class="nc">&nbsp;        if (!game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Now, run the detection rolls
<b class="nc">&nbsp;        for (Entity detector : game.getEntitiesVector()) {</b>
&nbsp;            //Don&#39;t process for invalid units
&nbsp;            //in the case of squadrons and transports, we want the &#39;host&#39;
&nbsp;            //unit, not the component entities
<b class="nc">&nbsp;            if (detector.getPosition() == null</b>
<b class="nc">&nbsp;                    || detector.isDestroyed()</b>
<b class="nc">&nbsp;                    || detector.isDoomed()</b>
<b class="nc">&nbsp;                    || detector.isOffBoard()</b>
<b class="nc">&nbsp;                    || detector.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                    || detector.getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Entity target : game.getEntitiesVector()) {</b>
&nbsp;                //Once a target is detected, we don&#39;t need to detect it again
<b class="nc">&nbsp;                if (detector.hasSensorContactFor(target.getId())) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                //Don&#39;t process for invalid units
&nbsp;                //in the case of squadrons and transports, we want the &#39;host&#39;
&nbsp;                //unit, not the component entities
<b class="nc">&nbsp;                if (target.getPosition() == null</b>
<b class="nc">&nbsp;                        || target.isDestroyed()</b>
<b class="nc">&nbsp;                        || target.isDoomed()</b>
<b class="nc">&nbsp;                        || target.isOffBoard()</b>
<b class="nc">&nbsp;                        || target.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                        || target.getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Only process for enemy units
<b class="nc">&nbsp;                if (!detector.isEnemyOf(target)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                //If we successfully detect the enemy, add it to the appropriate detector&#39;s sensor contacts list
<b class="nc">&nbsp;                if (Compute.calcSensorContact(game, detector, target)) {</b>
<b class="nc">&nbsp;                    game.getEntity(detector.getId()).addSensorContact(target.getId());</b>
&nbsp;                    //If detector is part of a C3 network, share the contact
<b class="nc">&nbsp;                    if (detector.hasNavalC3()) {</b>
<b class="nc">&nbsp;                        for (Entity c3NetMate : game.getC3NetworkMembers(detector)) {</b>
<b class="nc">&nbsp;                            game.getEntity(c3NetMate.getId()).addSensorContact(target.getId());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        //Now, run the firing solution calculations
<b class="nc">&nbsp;        for (Entity detector : game.getEntitiesVector()) {</b>
&nbsp;            //Don&#39;t process for invalid units
&nbsp;            //in the case of squadrons and transports, we want the &#39;host&#39;
&nbsp;            //unit, not the component entities
<b class="nc">&nbsp;            if (detector.getPosition() == null</b>
<b class="nc">&nbsp;                    || detector.isDestroyed()</b>
<b class="nc">&nbsp;                    || detector.isDoomed()</b>
<b class="nc">&nbsp;                    || detector.isOffBoard()</b>
<b class="nc">&nbsp;                    || detector.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                    || detector.getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int targetId : detector.getSensorContacts()) {</b>
<b class="nc">&nbsp;                Entity target = game.getEntity(targetId);</b>
&nbsp;                //if we already have a firing solution, no need to process a new one
<b class="nc">&nbsp;                if (detector.hasFiringSolutionFor(targetId)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                //Don&#39;t process for invalid units
&nbsp;                //in the case of squadrons and transports, we want the &#39;host&#39;
&nbsp;                //unit, not the component entities
<b class="nc">&nbsp;                if (target == null</b>
<b class="nc">&nbsp;                        || target.getPosition() == null</b>
<b class="nc">&nbsp;                        || target.isDestroyed()</b>
<b class="nc">&nbsp;                        || target.isDoomed()</b>
<b class="nc">&nbsp;                        || target.isOffBoard()</b>
<b class="nc">&nbsp;                        || target.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                        || target.getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Only process for enemy units
<b class="nc">&nbsp;                if (!detector.isEnemyOf(target)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                //If we successfully lock up the enemy, add it to the appropriate detector&#39;s firing solutions list
<b class="nc">&nbsp;                if (Compute.calcFiringSolution(game, detector, target)) {</b>
<b class="nc">&nbsp;                    game.getEntity(detector.getId()).addFiringSolution(targetId);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called at the end of movement. Determines if an entity
&nbsp;     * has moved beyond sensor range
&nbsp;     */
&nbsp;    private void updateSpacecraftDetection() {
&nbsp;        // Don&#39;t bother if we&#39;re not in space or if the game option isn&#39;t on
<b class="nc">&nbsp;        if (!game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        //Run through our list of units and remove any entities from the plotting board that have moved out of range
<b class="nc">&nbsp;        for (Entity detector : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            Compute.updateFiringSolutions(game, detector);</b>
<b class="nc">&nbsp;            Compute.updateSensorContacts(game, detector);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if any units can detected hidden units.
&nbsp;     */
&nbsp;    private void detectHiddenUnits() {
&nbsp;        // If hidden units aren&#39;t on, nothing to do
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // Get all hidden units
<b class="nc">&nbsp;        List&lt;Entity&gt; hiddenUnits = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (ent.isHidden()) {</b>
<b class="nc">&nbsp;                hiddenUnits.add(ent);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If no one is hidden, there&#39;s nothing to do
<b class="nc">&nbsp;        if (hiddenUnits.size() &lt; 1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Set&lt;Integer&gt; reportPlayers = new HashSet&lt;&gt;();</b>
&nbsp;        // See if any unit with a probe, detects any hidden units
<b class="nc">&nbsp;        for (Entity detector : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            int probeRange = detector.getBAPRange();</b>
&nbsp;
&nbsp;            // Units without a position won&#39;t be able to detect
<b class="nc">&nbsp;            if (detector.getPosition() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (Entity detected : hiddenUnits) {</b>
&nbsp;                // Only detected enemy units
<b class="nc">&nbsp;                if (!detector.isEnemyOf(detected)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Can&#39;t detect units without a position
<b class="nc">&nbsp;                if (detected.getPosition() == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Can only detect units within the probes range
<b class="nc">&nbsp;                int dist = detector.getPosition().distance(</b>
<b class="nc">&nbsp;                        detected.getPosition());</b>
&nbsp;
&nbsp;                // An adjacent enemy unit will detect hidden units, TW pg 259
<b class="nc">&nbsp;                if (dist &gt; 1 &amp;&amp; dist &gt; probeRange) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Check for Void/Null Sig - only detected by Bloodhound probes
<b class="nc">&nbsp;                if (dist &gt; 1 &amp;&amp; (detected instanceof Mech)) {</b>
<b class="nc">&nbsp;                    Mech m = (Mech)detected;</b>
<b class="nc">&nbsp;                    if ((m.isVoidSigActive() || m.isNullSigActive())</b>
<b class="nc">&nbsp;                            &amp;&amp; !detector.hasWorkingMisc(MiscType.F_BLOODHOUND)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Check for Infantry stealth armor
<b class="nc">&nbsp;                if (dist &gt; 1 &amp;&amp; (detected instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    BattleArmor ba = (BattleArmor) detected;</b>
&nbsp;                    // Need Bloodhound to detect BA stealth armor
<b class="nc">&nbsp;                    if (ba.isStealthy()</b>
<b class="nc">&nbsp;                            &amp;&amp; !detector.hasWorkingMisc(MiscType.F_BLOODHOUND)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (dist &gt; 1 &amp;&amp; (detected instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    Infantry inf = (Infantry) detected;</b>
&nbsp;                    // Can&#39;t detect sneaky infantry
<b class="nc">&nbsp;                    if (inf.isStealthy()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Need bloodhound to detect non-sneaky inf
<b class="nc">&nbsp;                    if (!detector.hasWorkingMisc(MiscType.F_BLOODHOUND)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                LosEffects los = LosEffects.calculateLos(game,</b>
<b class="nc">&nbsp;                        detector.getId(), detected);</b>
<b class="nc">&nbsp;                if (los.canSee() || dist &lt;= 1) {</b>
<b class="nc">&nbsp;                    detected.setHidden(false);</b>
<b class="nc">&nbsp;                    entityUpdate(detected.getId());</b>
<b class="nc">&nbsp;                    Report r = new Report(9960);</b>
<b class="nc">&nbsp;                    r.addDesc(detector);</b>
<b class="nc">&nbsp;                    r.subject = detector.getId();</b>
<b class="nc">&nbsp;                    r.add(detected.getPosition().getBoardNum());</b>
<b class="nc">&nbsp;                    vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                    Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                    reportPlayers.add(detector.getOwnerId());</b>
<b class="nc">&nbsp;                    reportPlayers.add(detected.getOwnerId());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (vPhaseReport.size() &gt; 0 &amp;&amp; game.getPhase() == Phase.PHASE_MOVEMENT</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getTurnIndex() + 1) &lt; game.getTurnVector().size()) {</b>
<b class="nc">&nbsp;            for (Integer playerId : reportPlayers) {</b>
<b class="nc">&nbsp;                send(playerId, createSpecialReportPacket());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called to what players can see what units. This is used to determine who
&nbsp;     * can see what in double blind reports.
&nbsp;     */
&nbsp;    private void resolveWhatPlayersCanSeeWhatUnits() {
<b class="nc">&nbsp;        List&lt;ECMInfo&gt; allECMInfo = null;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</b>
<b class="nc">&nbsp;            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</b>
<b class="nc">&nbsp;                    .getEntitiesVector());</b>
&nbsp;        }
<b class="nc">&nbsp;        Map&lt;EntityTargetPair, LosEffects&gt; losCache = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
&nbsp;            // We are hidden once again!
<b class="nc">&nbsp;            entity.clearSeenBy();</b>
<b class="nc">&nbsp;            entity.clearDetectedBy();</b>
&nbsp;            // Handle visual spotting
<b class="nc">&nbsp;            for (IPlayer p : whoCanSee(entity, false, losCache)) {</b>
<b class="nc">&nbsp;                entity.addBeenSeenBy(p);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Handle detection by sensors
<b class="nc">&nbsp;            for (IPlayer p : whoCanDetect(entity, allECMInfo, losCache)) {</b>
<b class="nc">&nbsp;                    entity.addBeenDetectedBy(p);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called during the weapons fire phase. Resolves anything other than
&nbsp;     * weapons fire that happens. Torso twists, for example.
&nbsp;     */
&nbsp;    private void resolveAllButWeaponAttacks() {
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; triggerPodActions = new Vector&lt;&gt;();</b>
&nbsp;        // loop through actions and handle everything we expect except attacks
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;            Entity entity = game.getEntity(ea.getEntityId());</b>
<b class="nc">&nbsp;            if (ea instanceof TorsoTwistAction) {</b>
<b class="nc">&nbsp;                TorsoTwistAction tta = (TorsoTwistAction) ea;</b>
<b class="nc">&nbsp;                if (entity.canChangeSecondaryFacing()) {</b>
<b class="nc">&nbsp;                    entity.setSecondaryFacing(tta.getFacing());</b>
<b class="nc">&nbsp;                    entity.postProcessFacingChange();</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (ea instanceof FlipArmsAction) {</b>
<b class="nc">&nbsp;                FlipArmsAction faa = (FlipArmsAction) ea;</b>
<b class="nc">&nbsp;                entity.setArmsFlipped(faa.getIsFlipped());</b>
<b class="nc">&nbsp;            } else if (ea instanceof FindClubAction) {</b>
<b class="nc">&nbsp;                resolveFindClub(entity);</b>
<b class="nc">&nbsp;            } else if (ea instanceof UnjamAction) {</b>
<b class="nc">&nbsp;                resolveUnjam(entity);</b>
<b class="nc">&nbsp;            } else if (ea instanceof ClearMinefieldAction) {</b>
<b class="nc">&nbsp;                resolveClearMinefield(entity,</b>
<b class="nc">&nbsp;                                      ((ClearMinefieldAction) ea).getMinefield());</b>
<b class="nc">&nbsp;            } else if (ea instanceof TriggerAPPodAction) {</b>
<b class="nc">&nbsp;                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;</b>
&nbsp;
&nbsp;                // Don&#39;t trigger the same pod twice.
<b class="nc">&nbsp;                if (!triggerPodActions.contains(tapa)) {</b>
<b class="nc">&nbsp;                    triggerAPPod(entity, tapa.getPodId());</b>
<b class="nc">&nbsp;                    triggerPodActions.addElement(tapa);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;AP Pod #&quot; + tapa.getPodId() + &quot; on &quot; + entity.getDisplayName()</b>
&nbsp;                                    + &quot; was already triggered this round!!&quot;);
&nbsp;                }
<b class="nc">&nbsp;            } else if (ea instanceof TriggerBPodAction) {</b>
<b class="nc">&nbsp;                TriggerBPodAction tba = (TriggerBPodAction) ea;</b>
&nbsp;
&nbsp;                // Don&#39;t trigger the same pod twice.
<b class="nc">&nbsp;                if (!triggerPodActions.contains(tba)) {</b>
<b class="nc">&nbsp;                    triggerBPod(entity, tba.getPodId(),</b>
<b class="nc">&nbsp;                                game.getEntity(tba.getTargetId()));</b>
<b class="nc">&nbsp;                    triggerPodActions.addElement(tba);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;B Pod #&quot; + tba.getPodId() + &quot; on &quot; + entity.getDisplayName()</b>
&nbsp;                                    + &quot; was already triggered this round!!&quot;);
&nbsp;                }
<b class="nc">&nbsp;            } else if (ea instanceof SearchlightAttackAction) {</b>
<b class="nc">&nbsp;                SearchlightAttackAction saa = (SearchlightAttackAction) ea;</b>
<b class="nc">&nbsp;                addReport(saa.resolveAction(game));</b>
<b class="nc">&nbsp;            } else if (ea instanceof UnjamTurretAction) {</b>
<b class="nc">&nbsp;                if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                    ((Tank) entity).unjamTurret(((Tank) entity).getLocTurret());</b>
<b class="nc">&nbsp;                    ((Tank) entity)</b>
<b class="nc">&nbsp;                            .unjamTurret(((Tank) entity).getLocTurret2());</b>
<b class="nc">&nbsp;                    Report r = new Report(3033);</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Non-Tank tried to unjam turret&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (ea instanceof RepairWeaponMalfunctionAction) {</b>
<b class="nc">&nbsp;                if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                    Mounted m = entity</b>
<b class="nc">&nbsp;                            .getEquipment(((RepairWeaponMalfunctionAction) ea)</b>
<b class="nc">&nbsp;                                                  .getWeaponId());</b>
<b class="nc">&nbsp;                    m.setJammed(false);</b>
<b class="nc">&nbsp;                    ((Tank) entity).getJammedWeapons().remove(m);</b>
<b class="nc">&nbsp;                    Report r = new Report(3034);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(m.getName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Non-Tank tried to repair weapon malfunction&quot;);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Called during the weapons firing phase to initiate self destruction.
&nbsp;     */
&nbsp;    private void resolveSelfDestructions() {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.getSelfDestructInitiated() &amp;&amp; e.hasEngine()) {</b>
<b class="nc">&nbsp;                r = new Report(6166, Report.PUBLIC);</b>
<b class="nc">&nbsp;                int target = e.getCrew().getPiloting();</b>
<b class="nc">&nbsp;                int roll = e.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(target);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                if (roll &gt;= target) {</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(false);</b>
&nbsp;                }
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;
&nbsp;                // Blow it up...
<b class="nc">&nbsp;                if (roll &gt;= target) {</b>
<b class="nc">&nbsp;                    int engineRating = e.getEngine().getRating();</b>
<b class="nc">&nbsp;                    r = new Report(5400, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.subject = e.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                    if (e instanceof Mech) {</b>
<b class="nc">&nbsp;                        Mech mech = (Mech) e;</b>
<b class="nc">&nbsp;                        if (mech.isAutoEject()</b>
<b class="nc">&nbsp;                                &amp;&amp; (!game.getOptions().booleanOption(</b>
&nbsp;                                        OptionsConstants.RPG_CONDITIONAL_EJECTION) || (game
<b class="nc">&nbsp;                                        .getOptions().booleanOption(</b>
&nbsp;                                                OptionsConstants.RPG_CONDITIONAL_EJECTION) &amp;&amp; mech
<b class="nc">&nbsp;                                        .isCondEjectEngine()))) {</b>
<b class="nc">&nbsp;                            vDesc.addAll(ejectEntity(e, true));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    e.setSelfDestructedThisTurn(true);</b>
<b class="nc">&nbsp;                    doFusionEngineExplosion(engineRating, e.getPosition(),</b>
&nbsp;                            vDesc, null);
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                    r = new Report(5410, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.subject = e.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                e.setSelfDestructInitiated(false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        addReport(vDesc);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void reportGhostTargetRolls() {
&nbsp;        // run through an enumeration of deployed game entities. If they have
&nbsp;        // ghost targets, then check the roll
&nbsp;        // and report it
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity ent = e.next();</b>
<b class="nc">&nbsp;            if (ent.isDeployed() &amp;&amp; ent.hasGhostTargets(false)) {</b>
<b class="nc">&nbsp;                r = new Report(3630);</b>
<b class="nc">&nbsp;                r.subject = ent.getId();</b>
<b class="nc">&nbsp;                r.addDesc(ent);</b>
&nbsp;                // Ghost target mod is +3 per errata
<b class="nc">&nbsp;                int target = ent.getCrew().getPiloting() + 3;</b>
<b class="nc">&nbsp;                if (ent.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {</b>
<b class="nc">&nbsp;                    target = ent.getCrew().getGunnery() + 3;</b>
&nbsp;                }
<b class="nc">&nbsp;                int roll = ent.getGhostTargetRoll();</b>
<b class="nc">&nbsp;                r.add(target);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                if (roll &gt;= target) {</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(false);</b>
&nbsp;                }
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void reportLargeCraftECCMRolls() {
&nbsp;        // run through an enumeration of deployed game entities. If they are
&nbsp;        // large craft in space, then check the roll
&nbsp;        // and report it
<b class="nc">&nbsp;        if (!game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity ent = e.next();</b>
<b class="nc">&nbsp;            if (ent.isDeployed() &amp;&amp; ent.isLargeCraft()) {</b>
<b class="nc">&nbsp;                r = new Report(3635);</b>
<b class="nc">&nbsp;                r.subject = ent.getId();</b>
<b class="nc">&nbsp;                r.addDesc(ent);</b>
<b class="nc">&nbsp;                int target = ((Aero) ent).getECCMTarget();</b>
<b class="nc">&nbsp;                int roll = ((Aero) ent).getECCMRoll();</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.add(target);</b>
<b class="nc">&nbsp;                int mod = ((Aero) ent).getECCMBonus();</b>
<b class="nc">&nbsp;                r.add(mod);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void resolveClearMinefield(Entity ent, Minefield mf) {
&nbsp;
<b class="nc">&nbsp;        if ((null == mf) || (null == ent) || ent.isDoomed()</b>
<b class="nc">&nbsp;            || ent.isDestroyed()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Coords pos = mf.getCoords();</b>
<b class="nc">&nbsp;        int clear = Minefield.CLEAR_NUMBER_INFANTRY;</b>
<b class="nc">&nbsp;        int boom = Minefield.CLEAR_NUMBER_INFANTRY_ACCIDENT;</b>
&nbsp;
<b class="nc">&nbsp;        Report r = new Report(2245);</b>
&nbsp;        // Does the entity has a minesweeper?
<b class="nc">&nbsp;        if ((ent instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            BattleArmor ba = (BattleArmor)ent;</b>
<b class="nc">&nbsp;            String mcmName = BattleArmor.MANIPULATOR_TYPE_STRINGS</b>
&nbsp;                    [BattleArmor.MANIPULATOR_BASIC_MINE_CLEARANCE];
<b class="nc">&nbsp;            if (ba.getLeftManipulatorName().equals(mcmName)) {</b>
<b class="nc">&nbsp;                clear = Minefield.CLEAR_NUMBER_BA_SWEEPER;</b>
<b class="nc">&nbsp;                boom = Minefield.CLEAR_NUMBER_BA_SWEEPER_ACCIDENT;</b>
<b class="nc">&nbsp;                r = new Report(2246);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (ent instanceof Infantry) { // Check Minesweeping Engineers</b>
<b class="nc">&nbsp;            Infantry inf = (Infantry) ent;</b>
<b class="nc">&nbsp;            if (inf.hasSpecialization(Infantry.MINE_ENGINEERS)) {</b>
<b class="nc">&nbsp;                clear = Minefield.CLEAR_NUMBER_INF_ENG;</b>
<b class="nc">&nbsp;                boom = Minefield.CLEAR_NUMBER_INF_ENG_ACCIDENT;</b>
<b class="nc">&nbsp;                r = new Report(2247);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // mine clearing roll
<b class="nc">&nbsp;        r.subject = ent.getId();</b>
<b class="nc">&nbsp;        r.add(ent.getShortName(), true);</b>
<b class="nc">&nbsp;        r.add(Minefield.getDisplayableName(mf.getType()));</b>
<b class="nc">&nbsp;        r.add(pos.getBoardNum(), true);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (clearMinefield(mf, ent, clear, boom, vPhaseReport)) {</b>
<b class="nc">&nbsp;            removeMinefield(mf);</b>
&nbsp;        }
&nbsp;        // some mines might have blown up
<b class="nc">&nbsp;        resetMines();</b>
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called during the fire phase to resolve all (and only) weapon attacks
&nbsp;     */
&nbsp;    private void resolveOnlyWeaponAttacks() {
&nbsp;        // loop through received attack actions, getting attack handlers
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;            if (ea instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                Entity ae = game.getEntity(waa.getEntityId());</b>
<b class="nc">&nbsp;                Mounted m = ae.getEquipment(waa.getWeaponId());</b>
<b class="nc">&nbsp;                Weapon w = (Weapon) m.getType();</b>
&nbsp;                // Track attacks original target, for things like swarm LRMs
<b class="nc">&nbsp;                waa.setOriginalTargetId(waa.getTargetId());</b>
<b class="nc">&nbsp;                waa.setOriginalTargetType(waa.getTargetType());</b>
<b class="nc">&nbsp;                AttackHandler ah = w.fire(waa, game, this);</b>
<b class="nc">&nbsp;                if (ah != null) {</b>
<b class="nc">&nbsp;                    ah.setStrafing(waa.isStrafing());</b>
<b class="nc">&nbsp;                    ah.setStrafingFirstShot(waa.isStrafingFirstShot());</b>
<b class="nc">&nbsp;                    game.addAttack(ah);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // and clear the attacks Vector
<b class="nc">&nbsp;        game.resetActions();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Trigger the indicated AP Pod of the entity.
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; triggering the AP Pod.
&nbsp;     * @param podId  the &lt;code&gt;int&lt;/code&gt; ID of the AP Pod.
&nbsp;     */
&nbsp;    private void triggerAPPod(Entity entity, int podId) {
&nbsp;        // Get the mount for this pod.
<b class="nc">&nbsp;        Mounted mount = entity.getEquipment(podId);</b>
&nbsp;
&nbsp;        // Confirm that this is, indeed, an AP Pod.
<b class="nc">&nbsp;        if (null == mount) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Expecting to find an AP Pod at &quot; + podId + &quot; on the unit, &quot; + entity.getDisplayName()</b>
&nbsp;                            + &quot; but found NO equipment at all!!!&quot;);
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        EquipmentType equip = mount.getType();</b>
<b class="nc">&nbsp;        if (!(equip instanceof MiscType) || !equip.hasFlag(MiscType.F_AP_POD)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Expecting to find an AP Pod at &quot; + podId + &quot; on the unit, &quot;+ entity.getDisplayName()</b>
<b class="nc">&nbsp;                            + &quot; but found &quot; + equip.getName() + &quot; instead!!!&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now confirm that the entity can trigger the pod.
&nbsp;        // Ignore the &quot;used this round&quot; flag.
<b class="nc">&nbsp;        boolean oldFired = mount.isUsedThisRound();</b>
<b class="nc">&nbsp;        mount.setUsedThisRound(false);</b>
<b class="nc">&nbsp;        boolean canFire = mount.canFire();</b>
<b class="nc">&nbsp;        mount.setUsedThisRound(oldFired);</b>
<b class="nc">&nbsp;        if (!canFire) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Can not trigger the AP Pod at &quot; + podId + &quot; on the unit, &quot;</b>
<b class="nc">&nbsp;                    + entity.getDisplayName() + &quot;!!!&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Mark the pod as fired and log the action.
<b class="nc">&nbsp;        mount.setFired(true);</b>
<b class="nc">&nbsp;        r = new Report(3010);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Walk through ALL entities in the triggering entity&#39;s hex.
<b class="nc">&nbsp;        for (Entity target : game.getEntitiesVector(entity.getPosition())) {</b>
&nbsp;
&nbsp;            // Is this an unarmored infantry platoon?
<b class="nc">&nbsp;            if ((target instanceof Infantry)</b>
&nbsp;                &amp;&amp; !(target instanceof BattleArmor)) {
&nbsp;
&nbsp;                // Roll d6-1 for damage.
<b class="nc">&nbsp;                final int damage = Math.max(1, Compute.d6() - 1);</b>
&nbsp;
&nbsp;                // Damage the platoon.
<b class="nc">&nbsp;                addReport(damageEntity(target, new HitData(</b>
&nbsp;                        Infantry.LOC_INFANTRY), damage));
&nbsp;
&nbsp;                // Damage from AP Pods is applied immediately.
<b class="nc">&nbsp;                target.applyDamage();</b>
&nbsp;
<b class="nc">&nbsp;            } // End target-is-unarmored</b>
&nbsp;
&nbsp;            // Nope, the target is immune.
&nbsp;            // Don&#39;t make a log entry for the triggering entity.
<b class="nc">&nbsp;            else if (!entity.equals(target)) {</b>
<b class="nc">&nbsp;                r = new Report(3020);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = target.getId();</b>
<b class="nc">&nbsp;                r.addDesc(target);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } // Check the next entity in the triggering entity&#39;s hex.</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Trigger the indicated B Pod of the entity.
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; triggering the B Pod.
&nbsp;     * @param podId  the &lt;code&gt;int&lt;/code&gt; ID of the B Pod.
&nbsp;     */
&nbsp;    private void triggerBPod(Entity entity, int podId, Entity target) {
&nbsp;        // Get the mount for this pod.
<b class="nc">&nbsp;        Mounted mount = entity.getEquipment(podId);</b>
&nbsp;
&nbsp;        // Confirm that this is, indeed, an Anti-BA Pod.
<b class="nc">&nbsp;        if (null == mount) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Expecting to find an B Pod at &quot; + podId + &quot; on the unit, &quot;</b>
<b class="nc">&nbsp;                    + entity.getDisplayName() + &quot; but found NO equipment at all!!!&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        EquipmentType equip = mount.getType();</b>
<b class="nc">&nbsp;        if (!(equip instanceof WeaponType)</b>
<b class="nc">&nbsp;            || !equip.hasFlag(WeaponType.F_B_POD)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Expecting to find an B Pod at &quot; + podId + &quot; on the unit, &quot;</b>
<b class="nc">&nbsp;                    + entity.getDisplayName() + &quot; but found &quot; + equip.getName() + &quot; instead!!!&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now confirm that the entity can trigger the pod.
&nbsp;        // Ignore the &quot;used this round&quot; flag.
<b class="nc">&nbsp;        boolean oldFired = mount.isUsedThisRound();</b>
<b class="nc">&nbsp;        mount.setUsedThisRound(false);</b>
<b class="nc">&nbsp;        boolean canFire = mount.canFire();</b>
<b class="nc">&nbsp;        mount.setUsedThisRound(oldFired);</b>
<b class="nc">&nbsp;        if (!canFire) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Can not trigger the B Pod at &quot; + podId + &quot; on the unit, &quot;</b>
<b class="nc">&nbsp;                    + entity.getDisplayName() + &quot;!!!&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Mark the pod as fired and log the action.
<b class="nc">&nbsp;        mount.setFired(true);</b>
<b class="nc">&nbsp;        r = new Report(3011);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Is this an unarmored infantry platoon?
<b class="nc">&nbsp;        if ((target instanceof Infantry) &amp;&amp; !(target instanceof BattleArmor)) {</b>
&nbsp;
&nbsp;            // Roll d6 for damage.
<b class="nc">&nbsp;            final int damage = Compute.d6();</b>
&nbsp;
&nbsp;            // Damage the platoon.
<b class="nc">&nbsp;            addReport(damageEntity(target, new HitData(Infantry.LOC_INFANTRY),</b>
&nbsp;                                   damage));
&nbsp;
&nbsp;            // Damage from AP Pods is applied immediately.
<b class="nc">&nbsp;            target.applyDamage();</b>
&nbsp;
&nbsp;            // End target-is-unarmored
<b class="nc">&nbsp;        } else if (target instanceof BattleArmor) {</b>
&nbsp;            // 20 damage in 5 point clusters
<b class="nc">&nbsp;            final int damage = 5;</b>
&nbsp;
&nbsp;            // Damage the squad.
<b class="nc">&nbsp;            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));</b>
<b class="nc">&nbsp;            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));</b>
<b class="nc">&nbsp;            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));</b>
<b class="nc">&nbsp;            addReport(damageEntity(target, target.rollHitLocation(0, 0), damage));</b>
&nbsp;
&nbsp;            // Damage from B Pods is applied immediately.
<b class="nc">&nbsp;            target.applyDamage();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Nope, the target is immune.
&nbsp;        // Don&#39;t make a log entry for the triggering entity.
<b class="nc">&nbsp;        else if (!entity.equals(target)) {</b>
<b class="nc">&nbsp;            r = new Report(3020);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.subject = target.getId();</b>
<b class="nc">&nbsp;            r.addDesc(target);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolve an Unjam Action object
&nbsp;     */
&nbsp;    private void resolveUnjam(Entity entity) {
&nbsp;        Report r;
<b class="nc">&nbsp;        final int TN = entity.getCrew().getGunnery() + 3;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UNJAM_UAC)) {</b>
<b class="nc">&nbsp;            r = new Report(3026);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(3025);</b>
&nbsp;        }
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        for (Mounted mounted : entity.getTotalWeaponList()) {</b>
<b class="nc">&nbsp;            if (mounted.isJammed() &amp;&amp; !mounted.isDestroyed()) {</b>
<b class="nc">&nbsp;                WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="nc">&nbsp;                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</b>
<b class="nc">&nbsp;                    int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    r = new Report(3030);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(wtype.getName());</b>
<b class="nc">&nbsp;                    r.add(TN);</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    if (roll &gt;= TN) {</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
<b class="nc">&nbsp;                        mounted.setJammed(false);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.choose(false);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;                // Unofficial option to unjam UACs, ACs, and LACs like Rotary
&nbsp;                // Autocannons
<b class="nc">&nbsp;                if (((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                        || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;                        || (wtype.getAmmoType() == AmmoType.T_AC)</b>
<b class="nc">&nbsp;                        || (wtype.getAmmoType() == AmmoType.T_AC_IMP)</b>
<b class="nc">&nbsp;                        || (wtype.getAmmoType() == AmmoType.T_PAC)</b>
<b class="nc">&nbsp;                        || (wtype.getAmmoType() == AmmoType.T_LAC))</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UNJAM_UAC)) {</b>
<b class="nc">&nbsp;                    int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    r = new Report(3030);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(wtype.getName());</b>
<b class="nc">&nbsp;                    r.add(TN);</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    if (roll &gt;= TN) {</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
<b class="nc">&nbsp;                        mounted.setJammed(false);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.choose(false);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void resolveFindClub(Entity entity) {
<b class="nc">&nbsp;        EquipmentType clubType = null;</b>
&nbsp;
<b class="nc">&nbsp;        entity.setFindingClub(true);</b>
&nbsp;
&nbsp;        // Get the entity&#39;s current hex.
<b class="nc">&nbsp;        Coords coords = entity.getPosition();</b>
<b class="nc">&nbsp;        IHex curHex = game.getBoard().getHex(coords);</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Is there a blown off arm in the hex?
<b class="nc">&nbsp;        if (curHex.terrainLevel(Terrains.ARMS) &gt; 0) {</b>
<b class="nc">&nbsp;            clubType = EquipmentType.get(EquipmentTypeLookup.LIMB_CLUB);</b>
<b class="nc">&nbsp;            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                    Terrains.ARMS, curHex.terrainLevel(Terrains.ARMS) - 1));</b>
<b class="nc">&nbsp;            sendChangedHex(entity.getPosition());</b>
<b class="nc">&nbsp;            r = new Report(3035);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;        // Is there a blown off leg in the hex?
<b class="nc">&nbsp;        else if (curHex.terrainLevel(Terrains.LEGS) &gt; 0) {</b>
<b class="nc">&nbsp;            clubType = EquipmentType.get(EquipmentTypeLookup.LIMB_CLUB);</b>
<b class="nc">&nbsp;            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                    Terrains.LEGS, curHex.terrainLevel(Terrains.LEGS) - 1));</b>
<b class="nc">&nbsp;            sendChangedHex(entity.getPosition());</b>
<b class="nc">&nbsp;            r = new Report(3040);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is there the rubble of a medium, heavy,
&nbsp;        // or hardened building in the hex?
<b class="nc">&nbsp;        else if (Building.LIGHT &lt; curHex.terrainLevel(Terrains.RUBBLE)) {</b>
&nbsp;
&nbsp;            // Finding a club is not guaranteed. The chances are
&nbsp;            // based on the type of building that produced the
&nbsp;            // rubble.
<b class="nc">&nbsp;            boolean found = false;</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            switch (curHex.terrainLevel(Terrains.RUBBLE)) {</b>
&nbsp;                case Building.MEDIUM:
<b class="nc">&nbsp;                    if (roll &gt;= 7) {</b>
<b class="nc">&nbsp;                        found = true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Building.HEAVY:
<b class="nc">&nbsp;                    if (roll &gt;= 6) {</b>
<b class="nc">&nbsp;                        found = true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Building.HARDENED:
<b class="nc">&nbsp;                    if (roll &gt;= 5) {</b>
<b class="nc">&nbsp;                        found = true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Building.WALL:
<b class="nc">&nbsp;                    if (roll &gt;= 13) {</b>
<b class="nc">&nbsp;                        found = true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                default:
&nbsp;                    // we must be in ultra
<b class="nc">&nbsp;                    if (roll &gt;= 4) {</b>
<b class="nc">&nbsp;                        found = true;</b>
&nbsp;                    }
&nbsp;            }
&nbsp;
&nbsp;            // Let the player know if they found a club.
<b class="nc">&nbsp;            if (found) {</b>
<b class="nc">&nbsp;                clubType = EquipmentType.get(EquipmentTypeLookup.GIRDER_CLUB);</b>
<b class="nc">&nbsp;                r = new Report(3045);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
&nbsp;                // Sorry, no club for you.
<b class="nc">&nbsp;                r = new Report(3050);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Are there woods in the hex?
<b class="nc">&nbsp;        else if (curHex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                 || curHex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;            clubType = EquipmentType.get(EquipmentTypeLookup.TREE_CLUB);</b>
<b class="nc">&nbsp;            r = new Report(3055);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // add the club
&nbsp;        try {
<b class="nc">&nbsp;            if (clubType != null) {</b>
<b class="nc">&nbsp;                entity.addEquipment(clubType, Entity.LOC_NONE);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (LocationFullException ex) {</b>
&nbsp;            // unlikely...
<b class="nc">&nbsp;            r = new Report(3060);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Try to ignite the hex, taking into account existing fires and the
&nbsp;     * effects of Inferno rounds.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the hex being lit.
&nbsp;     * @param entityId
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; id of the entity involved.
&nbsp;     * @param bInferno
&nbsp;     *            - &lt;code&gt;true&lt;/code&gt; if the weapon igniting the hex is an
&nbsp;     *            Inferno round. If some other weapon or ammo is causing the
&nbsp;     *            roll, this should be &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * @param bHotGun
&nbsp;     *            - &lt;code&gt;true&lt;/code&gt; if the weapon is plasma/flamer/incendiary
&nbsp;     *            LRM/etc
&nbsp;     * @param nTargetRoll
&nbsp;     *            - the &lt;code&gt;TargetRoll&lt;/code&gt; for the ignition roll.
&nbsp;     * @param bReportAttempt
&nbsp;     *            - &lt;code&gt;true&lt;/code&gt; if the attempt roll should be added to the
&nbsp;     *            report.
&nbsp;     * @param accidentTarget
&nbsp;     *            - &lt;code&gt;int&lt;/code&gt; the target number below which a roll has to
&nbsp;     *            be made in order to try igniting a hex accidentally. -1 for
&nbsp;     *            intentional
&nbsp;     */
&nbsp;    public boolean tryIgniteHex(Coords c, int entityId, boolean bHotGun,
&nbsp;            boolean bInferno, TargetRoll nTargetRoll, boolean bReportAttempt,
&nbsp;            int accidentTarget, Vector&lt;Report&gt; vPhaseReport) {
&nbsp;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // Ignore bad coordinates.
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Ignore if fire is not enabled as a game option
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_START_FIRE)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // is the hex ignitable (how are infernos handled?)
<b class="nc">&nbsp;        if (!hex.isIgnitable()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // first for accidental ignitions, make the necessary roll
<b class="nc">&nbsp;        if (accidentTarget &gt; -1) {</b>
&nbsp;            // if this hex is in snow, then accidental ignitions are not
&nbsp;            // possible
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.SNOW)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            nTargetRoll.addModifier(2, &quot;accidental&quot;);</b>
<b class="nc">&nbsp;            int accidentRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(3066);</b>
<b class="nc">&nbsp;            r.subject = entityId;</b>
<b class="nc">&nbsp;            r.add(accidentTarget);</b>
<b class="nc">&nbsp;            r.add(accidentRoll);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            if (accidentRoll &gt; accidentTarget) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int terrainMod = hex.getIgnitionModifier();</b>
<b class="nc">&nbsp;        if (terrainMod != 0) {</b>
<b class="nc">&nbsp;            nTargetRoll.addModifier(terrainMod, &quot;terrain&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // building modifiers
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(c);</b>
<b class="nc">&nbsp;        if (null != bldg) {</b>
<b class="nc">&nbsp;            nTargetRoll.addModifier(bldg.getType() - 3, &quot;building&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // add in any modifiers for planetary conditions
<b class="nc">&nbsp;        int weatherMod = game.getPlanetaryConditions().getIgniteModifiers();</b>
<b class="nc">&nbsp;        if (weatherMod != 0) {</b>
<b class="nc">&nbsp;            nTargetRoll.addModifier(weatherMod, &quot;conditions&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if there is snow on the ground and this a hotgun or inferno, it may
&nbsp;        // melt the snow instead
<b class="nc">&nbsp;        if ((hex.containsTerrain(Terrains.SNOW) || hex</b>
<b class="nc">&nbsp;                .containsTerrain(Terrains.ICE)) &amp;&amp; (bHotGun || bInferno)) {</b>
<b class="nc">&nbsp;            boolean melted = false;</b>
<b class="nc">&nbsp;            int meltCheck = Compute.d6(2);</b>
<b class="nc">&nbsp;            if ((hex.terrainLevel(Terrains.SNOW) &gt; 1) &amp;&amp; (meltCheck == 12)) {</b>
<b class="nc">&nbsp;                melted = true;</b>
<b class="nc">&nbsp;            } else if (hex.containsTerrain(Terrains.ICE) &amp;&amp; (meltCheck &gt; 9)) {</b>
<b class="nc">&nbsp;                melted = true;</b>
<b class="nc">&nbsp;            } else if (hex.containsTerrain(Terrains.SNOW) &amp;&amp; (meltCheck &gt; 7)) {</b>
<b class="nc">&nbsp;                melted = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (bInferno) {</b>
<b class="nc">&nbsp;                melted = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (melted) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(meltIceAndSnow(c, entityId));</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // inferno always ignites
&nbsp;        // ERRATA not if targeting clear hexes for ignition is disabled.
<b class="nc">&nbsp;        if (bInferno &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVANCED_NO_IGNITE_CLEAR)) {</b>
<b class="nc">&nbsp;            nTargetRoll = new TargetRoll(0, &quot;inferno&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // no lighting fires in tornadoes
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().getWindStrength() &gt; PlanetaryConditions.WI_STORM) {</b>
<b class="nc">&nbsp;            nTargetRoll = new TargetRoll(TargetRoll.AUTOMATIC_FAIL, &quot;tornado&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // The hex may already be on fire.
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            if (bReportAttempt) {</b>
<b class="nc">&nbsp;                r = new Report(3065);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (checkIgnition(c, nTargetRoll, bInferno, entityId,</b>
&nbsp;                vPhaseReport)) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Try to ignite the hex, taking into account existing fires and the
&nbsp;     * effects of Inferno rounds. This version of the method will not report the
&nbsp;     * attempt roll.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the hex being lit.
&nbsp;     * @param entityId
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; id of the entity involved.
&nbsp;     * @param bInferno
&nbsp;     *            - &lt;code&gt;true&lt;/code&gt; if the weapon igniting the hex is an
&nbsp;     *            Inferno round. If some other weapon or ammo is causing the
&nbsp;     *            roll, this should be &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * @param nTargetRoll
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; roll target for the attempt.
&nbsp;     */
&nbsp;    public boolean tryIgniteHex(Coords c, int entityId, boolean bHotGun, boolean bInferno,
&nbsp;                                TargetRoll nTargetRoll, int accidentTarget,
&nbsp;                                Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        return tryIgniteHex(c, entityId, bHotGun, bInferno, nTargetRoll, false,</b>
&nbsp;                accidentTarget, vPhaseReport);
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Report&gt; tryClearHex(Coords c, int nDamage, int entityId) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        IHex h = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        if (h == null) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
<b class="nc">&nbsp;        ITerrain woods = h.getTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;        ITerrain jungle = h.getTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;        ITerrain ice = h.getTerrain(Terrains.ICE);</b>
<b class="nc">&nbsp;        ITerrain magma = h.getTerrain(Terrains.MAGMA);</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        int reportType = Report.HIDDEN;</b>
<b class="nc">&nbsp;        if (entityId == Entity.NONE) {</b>
<b class="nc">&nbsp;            reportType = Report.PUBLIC;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (woods != null) {</b>
<b class="nc">&nbsp;            int tf = woods.getTerrainFactor() - nDamage;</b>
<b class="nc">&nbsp;            int level = woods.getLevel();</b>
<b class="nc">&nbsp;            int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;            if (tf &lt;= 0) {</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.ROUGH, 1));
&nbsp;                // light converted to rough
<b class="nc">&nbsp;                r = new Report(3090, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            } else if ((tf &lt;= 50) &amp;&amp; (level &gt; 1)) {</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.WOODS, 1));
<b class="nc">&nbsp;                if (folEl != 1) {</b>
<b class="nc">&nbsp;                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.FOLIAGE_ELEV, 2));
&nbsp;                }
<b class="nc">&nbsp;                woods = h.getTerrain(Terrains.WOODS);</b>
&nbsp;                // heavy converted to light
<b class="nc">&nbsp;                r = new Report(3085, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            } else if ((tf &lt;= 90) &amp;&amp; (level &gt; 2)) {</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.WOODS, 2));
<b class="nc">&nbsp;                if (folEl != 1) {</b>
<b class="nc">&nbsp;                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.FOLIAGE_ELEV, 2));
&nbsp;                }
<b class="nc">&nbsp;                woods = h.getTerrain(Terrains.WOODS);</b>
&nbsp;                // ultra heavy converted to heavy
<b class="nc">&nbsp;                r = new Report(3082, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            woods.setTerrainFactor(tf);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (jungle != null) {</b>
<b class="nc">&nbsp;            int tf = jungle.getTerrainFactor() - nDamage;</b>
<b class="nc">&nbsp;            int level = jungle.getLevel();</b>
<b class="nc">&nbsp;            int folEl = h.terrainLevel(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;            if (tf &lt; 0) {</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.ROUGH, 1));
&nbsp;                // light converted to rough
<b class="nc">&nbsp;                r = new Report(3091, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            } else if ((tf &lt;= 50) &amp;&amp; (level &gt; 1)) {</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.JUNGLE, 1));
<b class="nc">&nbsp;                if (folEl != 1) {</b>
<b class="nc">&nbsp;                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.FOLIAGE_ELEV, 2));
&nbsp;                }
<b class="nc">&nbsp;                jungle = h.getTerrain(Terrains.JUNGLE);</b>
&nbsp;                // heavy converted to light
<b class="nc">&nbsp;                r = new Report(3086, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            } else if ((tf &lt;= 90) &amp;&amp; (level &gt; 2)) {</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.JUNGLE, 2));
<b class="nc">&nbsp;                if (folEl != 1) {</b>
<b class="nc">&nbsp;                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.FOLIAGE_ELEV, 2));
&nbsp;                }
<b class="nc">&nbsp;                jungle = h.getTerrain(Terrains.JUNGLE);</b>
&nbsp;                // ultra heavy converted to heavy
<b class="nc">&nbsp;                r = new Report(3083, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            jungle.setTerrainFactor(tf);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (ice != null) {</b>
<b class="nc">&nbsp;            int tf = ice.getTerrainFactor() - nDamage;</b>
<b class="nc">&nbsp;            if (tf &lt;= 0) {</b>
&nbsp;                // ice melted
<b class="nc">&nbsp;                r = new Report(3092, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(resolveIceBroken(c));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ice.setTerrainFactor(tf);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((magma != null) &amp;&amp; (magma.getLevel() == 1)) {</b>
<b class="nc">&nbsp;            int tf = magma.getTerrainFactor() - nDamage;</b>
<b class="nc">&nbsp;            if (tf &lt;= 0) {</b>
&nbsp;                // magma crust destroyed
<b class="nc">&nbsp;                r = new Report(3093, reportType);</b>
<b class="nc">&nbsp;                r.subject = entityId;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                h.removeTerrain(Terrains.MAGMA);</b>
<b class="nc">&nbsp;                h.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                        Terrains.MAGMA, 2));
<b class="nc">&nbsp;                for (Entity en : game.getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                    doMagmaDamage(en, false);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                magma.setTerrainFactor(tf);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        sendChangedHex(c);</b>
&nbsp;
&nbsp;        // any attempt to clear an heavy industrial hex may cause an exposion
<b class="nc">&nbsp;        checkExplodeIndustrialZone(c, vPhaseReport);</b>
&nbsp;
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handle all physical attacks for the round
&nbsp;     */
&nbsp;    private void resolvePhysicalAttacks() {
&nbsp;        // Physical phase header
<b class="nc">&nbsp;        addReport(new Report(4000, Report.PUBLIC));</b>
&nbsp;
&nbsp;        // add any pending charges
<b class="nc">&nbsp;        for (Enumeration&lt;AttackAction&gt; i = game.getCharges(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            game.addAction(i.nextElement());</b>
&nbsp;        }
<b class="nc">&nbsp;        game.resetCharges();</b>
&nbsp;
&nbsp;        // add any pending rams
<b class="nc">&nbsp;        for (Enumeration&lt;AttackAction&gt; i = game.getRams(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            game.addAction(i.nextElement());</b>
&nbsp;        }
<b class="nc">&nbsp;        game.resetRams();</b>
&nbsp;
&nbsp;        // add any pending Tele Missile Attacks
<b class="nc">&nbsp;        for (Enumeration&lt;AttackAction&gt; i = game.getTeleMissileAttacks(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            game.addAction(i.nextElement());</b>
&nbsp;        }
<b class="nc">&nbsp;        game.resetTeleMissileAttacks();</b>
&nbsp;
&nbsp;        // remove any duplicate attack declarations
<b class="nc">&nbsp;        cleanupPhysicalAttacks();</b>
&nbsp;
&nbsp;        // loop thru received attack actions
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            Object o = i.nextElement();</b>
&nbsp;            // verify that the attacker is still active
<b class="nc">&nbsp;            AttackAction aa = (AttackAction) o;</b>
<b class="nc">&nbsp;            if (!game.getEntity(aa.getEntityId()).isActive()</b>
&nbsp;                &amp;&amp; !(o instanceof DfaAttackAction)) {
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            AbstractAttackAction aaa = (AbstractAttackAction) o;</b>
&nbsp;            // do searchlights immediately
<b class="nc">&nbsp;            if (aaa instanceof SearchlightAttackAction) {</b>
<b class="nc">&nbsp;                SearchlightAttackAction saa = (SearchlightAttackAction) aaa;</b>
<b class="nc">&nbsp;                addReport(saa.resolveAction(game));</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                physicalResults.addElement(preTreatPhysicalAttack(aaa));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        int cen = Entity.NONE;</b>
<b class="nc">&nbsp;        for (PhysicalResult pr : physicalResults) {</b>
<b class="nc">&nbsp;            resolvePhysicalAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = pr.aaa.getEntityId();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        physicalResults.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Cleans up the attack declarations for the physical phase by removing all
&nbsp;     * attacks past the first for any one mech. Also clears out attacks by dead
&nbsp;     * or disabled mechs.
&nbsp;     */
&nbsp;    private void cleanupPhysicalAttacks() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = i.next();</b>
<b class="nc">&nbsp;            removeDuplicateAttacks(entity.getId());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        removeDeadAttacks();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes any actions in the attack queue beyond the first by the specified
&nbsp;     * entity, unless that entity has melee master in which case it allows two
&nbsp;     * attacks.
&nbsp;     */
&nbsp;    private void removeDuplicateAttacks(int entityId) {
<b class="nc">&nbsp;        int allowed = 1;</b>
<b class="nc">&nbsp;        Entity en = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if (null != en) {</b>
<b class="nc">&nbsp;            allowed = en.getAllowedPhysicalAttacks();</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; toKeep = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction action = i.nextElement();</b>
<b class="nc">&nbsp;            if (action.getEntityId() != entityId) {</b>
<b class="nc">&nbsp;                toKeep.addElement(action);</b>
<b class="nc">&nbsp;            } else if (allowed &gt; 0) {</b>
<b class="nc">&nbsp;                toKeep.addElement(action);</b>
<b class="nc">&nbsp;                if (!(action instanceof SearchlightAttackAction)) {</b>
<b class="nc">&nbsp;                    allowed--;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Removing duplicate phys attack for id#&quot; + entityId</b>
<b class="nc">&nbsp;                                + &quot;\n\t\taction was &quot; + action.toString());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // reset actions and re-add valid elements
<b class="nc">&nbsp;        game.resetActions();</b>
<b class="nc">&nbsp;        for (EntityAction entityAction : toKeep) {</b>
<b class="nc">&nbsp;            game.addAction(entityAction);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all attacks by any dead entities. It does this by going through
&nbsp;     * all the attacks and only keeping ones from active entities. DFAs are kept
&nbsp;     * even if the pilot is unconscious, so that he can fail.
&nbsp;     */
&nbsp;    private void removeDeadAttacks() {
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; toKeep = new Vector&lt;&gt;(game.actionsSize());</b>
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction action = i.nextElement();</b>
<b class="nc">&nbsp;            Entity entity = game.getEntity(action.getEntityId());</b>
<b class="nc">&nbsp;            if ((entity != null) &amp;&amp; !entity.isDestroyed()</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.isActive() || (action instanceof DfaAttackAction))) {</b>
<b class="nc">&nbsp;                toKeep.addElement(action);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // reset actions and re-add valid elements
<b class="nc">&nbsp;        game.resetActions();</b>
<b class="nc">&nbsp;        for (EntityAction entityAction : toKeep) {</b>
<b class="nc">&nbsp;            game.addAction(entityAction);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply damage to mech for zweihandering (melee attack with both hands) as per
&nbsp;     * pg. 82, CamOps
&nbsp;     * 
&nbsp;     * @param ae           - the attacking entity
&nbsp;     * @param missed       - did the attack missed. If so PSR is necessary.
&nbsp;     * @param criticalLocs - the locations for possible criticals, should be one or
&nbsp;     *                     both arms depending on if it was an unarmed attack (both
&nbsp;     *                     arms) or a weapon attack (the arm with the weapon).
&nbsp;     */
&nbsp;    private void applyZweihanderSelfDamage(Entity ae, boolean missed, List&lt;Integer&gt; criticalLocs) {
<b class="nc">&nbsp;        Report r = new Report(4022);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(ae);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        for (Integer loc : criticalLocs) {</b>
<b class="nc">&nbsp;            addReport(criticalEntity(ae, loc, false, 0, 1));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if(missed) {</b>
<b class="nc">&nbsp;            game.addPSR(new PilotingRollData(ae.getId(), 0, &quot;Zweihander miss&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a punch attack
&nbsp;     */
&nbsp;    private void resolvePunchAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final PunchAttackAction paa = (PunchAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(paa.getEntityId());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(paa.getTargetType(), paa.getTargetId());</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        final String armName = paa.getArm() == PunchAttackAction.LEFT ? &quot;Left Arm&quot; : &quot;Right Arm&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        final int armLoc = paa.getArm() == PunchAttackAction.LEFT ? Mech.LOC_LARM : Mech.LOC_RARM;</b>
&nbsp;
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = paa.getArm() == PunchAttackAction.LEFT ? pr.damage : pr.damageRight;</b>
&nbsp;        // LAMs in airmech mode do half damage if airborne.
<b class="nc">&nbsp;        if (ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            damage = (int)Math.ceil(damage * 0.5);</b>
&nbsp;        }
<b class="nc">&nbsp;        final ToHitData toHit = paa.getArm() == PunchAttackAction.LEFT ? pr.toHit : pr.toHitRight;</b>
<b class="nc">&nbsp;        int roll = paa.getArm() == PunchAttackAction.LEFT ? pr.roll : pr.rollRight;</b>
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(target.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != paa.getEntityId()) {</b>
&nbsp;            // report who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4010);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(armName);</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4015);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed punch attack&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4020);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // nope
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed punch attack&quot;));</b>
&nbsp;            }
&nbsp;            // If the target is in a building, the building absorbs the damage.
<b class="nc">&nbsp;            if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
&nbsp;
&nbsp;                // Only report if damage was done to the building.
<b class="nc">&nbsp;                if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;                    for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = ae.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(buildingReport);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(paa.isZweihandering()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                criticalLocs.add(Mech.LOC_RARM);</b>
<b class="nc">&nbsp;                criticalLocs.add(Mech.LOC_LARM);</b>
<b class="nc">&nbsp;                applyZweihanderSelfDamage(ae, true, criticalLocs);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Targeting a building.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
<b class="nc">&nbsp;            if(paa.isZweihandering()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                criticalLocs.add(Mech.LOC_RARM);</b>
<b class="nc">&nbsp;                criticalLocs.add(Mech.LOC_LARM);</b>
<b class="nc">&nbsp;                applyZweihanderSelfDamage(ae, false, criticalLocs);</b>
&nbsp;            }
&nbsp;
&nbsp;            // And we&#39;re done!
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;        r = new Report(4045);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;        r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // The building shields all units from a certain amount of damage.
&nbsp;        // The amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;        if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
<b class="nc">&nbsp;            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());</b>
<b class="nc">&nbsp;            int toBldg = Math.min(bldgAbsorbs, damage);</b>
<b class="nc">&nbsp;            damage -= toBldg;</b>
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, toBldg, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // some buildings scale remaining damage that is not absorbed
&nbsp;            // TODO : this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;            damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
&nbsp;        }
&nbsp;
&nbsp;        // A building may absorb the entire shot.
<b class="nc">&nbsp;        if (damage == 0) {</b>
<b class="nc">&nbsp;            r = new Report(4050);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getShortName());</b>
<b class="nc">&nbsp;            r.add(te.getOwner().getName());</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (glancing) {</b>
&nbsp;                // Round up glancing blows against conventional infantry
<b class="nc">&nbsp;                if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                damage += toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;                hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            damage = checkForSpikes(te, hit.getLocation(), damage, ae,</b>
<b class="nc">&nbsp;                    (paa.getArm() == PunchAttackAction.LEFT) ?  Mech.LOC_LARM : Mech.LOC_RARM);</b>
<b class="nc">&nbsp;            DamageType damageType = DamageType.NONE;</b>
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage, false, damageType, false,</b>
&nbsp;                                   false, throughFront));
<b class="nc">&nbsp;            if (target instanceof VTOL) {</b>
&nbsp;                // destroy rotor
<b class="nc">&nbsp;                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,</b>
&nbsp;                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM, VTOL.CRIT_ROTOR_DESTROYED),
&nbsp;                        false, 0, false));
&nbsp;            }
&nbsp;            // check for extending retractable blades
<b class="nc">&nbsp;            if (paa.isBladeExtended(paa.getArm())) {</b>
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                r = new Report(4455);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // conventional infantry don&#39;t take crits and battle armor need
&nbsp;                // to be handled differently
<b class="nc">&nbsp;                if (!(target instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    addReport(criticalEntity(te, hit.getLocation(), hit.isRear(), 0,</b>
&nbsp;                            true, false, damage));
&nbsp;                }
<b class="nc">&nbsp;                if ((target instanceof BattleArmor) &amp;&amp; (hit.getLocation() &lt; te.locations())</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getInternal(hit.getLocation()) &gt; 0)) {</b>
&nbsp;                    // TODO : we should really apply BA criticals through the critical
&nbsp;                    // TODO : hits methods. Right now they are applied in damageEntity
<b class="nc">&nbsp;                    HitData baHit = new HitData(hit.getLocation(), false,</b>
&nbsp;                            HitData.EFFECT_CRITICAL);
<b class="nc">&nbsp;                    addReport(damageEntity(te, baHit, 0));</b>
&nbsp;                }
&nbsp;                // extend the blade
&nbsp;                // since retracting/extending is a freebie in the movement
&nbsp;                // phase, lets assume that the
&nbsp;                // blade retracts to its original mode
&nbsp;                // ae.extendBlade(paa.getArm());
&nbsp;                // check for breaking a nail
<b class="nc">&nbsp;                if (Compute.d6(2) &gt; 9) {</b>
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    r = new Report(4456);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    ae.destroyRetractableBlade(armLoc);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
<b class="nc">&nbsp;        if(paa.isZweihandering()) {</b>
<b class="nc">&nbsp;            ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            criticalLocs.add(Mech.LOC_RARM);</b>
<b class="nc">&nbsp;            criticalLocs.add(Mech.LOC_LARM);</b>
<b class="nc">&nbsp;            applyZweihanderSelfDamage(ae, false, criticalLocs);</b>
&nbsp;        }
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((target instanceof Mech) &amp;&amp; ((Mech) target).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) target).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a kick attack
&nbsp;     */
&nbsp;    private void resolveKickAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        KickAttackAction kaa = (KickAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(kaa.getEntityId());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(kaa.getTargetType(), kaa.getTargetId());</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        String legName = (kaa.getLeg() == KickAttackAction.LEFT)</b>
<b class="nc">&nbsp;                || (kaa.getLeg() == KickAttackAction.LEFTMULE) ? &quot;Left &quot; : &quot;Right &quot;;</b>
<b class="nc">&nbsp;        if ((kaa.getLeg() == KickAttackAction.LEFTMULE)</b>
<b class="nc">&nbsp;                || (kaa.getLeg() == KickAttackAction.RIGHTMULE)) {</b>
<b class="nc">&nbsp;            legName = legName.concat(&quot;rear &quot;);</b>
<b class="nc">&nbsp;        } else if (ae instanceof QuadMech) {</b>
<b class="nc">&nbsp;            legName = legName.concat(&quot;front &quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        legName = legName.concat(&quot;leg&quot;);</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
&nbsp;        // LAMs in airmech mode do half damage if airborne.
<b class="nc">&nbsp;        if (ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            damage = (int)Math.ceil(damage * 0.5);</b>
&nbsp;        }
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(target.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != ae.getId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4055);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(legName);</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4060);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed a kick&quot;));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                game.addPSR(new PilotingRollData(ae.getId(), 0, &quot;missed a kick&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4065);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed a kick&quot;));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                game.addPSR(new PilotingRollData(ae.getId(), 0, &quot;missed a kick&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // If the target is in a building, the building absorbs the damage.
<b class="nc">&nbsp;            if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
&nbsp;
&nbsp;                // Only report if damage was done to the building.
<b class="nc">&nbsp;                if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;                    for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = ae.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(buildingReport);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Targeting a building.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
&nbsp;            // And we&#39;re done!
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;        r = new Report(4045);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;        r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // The building shields all units from a certain amount of damage.
&nbsp;        // The amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;        if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
<b class="nc">&nbsp;            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());</b>
<b class="nc">&nbsp;            int toBldg = Math.min(bldgAbsorbs, damage);</b>
<b class="nc">&nbsp;            damage -= toBldg;</b>
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // some buildings scale remaining damage that is not absorbed
&nbsp;            // TODO : this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;            damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
&nbsp;        }
&nbsp;
&nbsp;        // A building may absorb the entire shot.
<b class="nc">&nbsp;        if (damage == 0) {</b>
<b class="nc">&nbsp;            r = new Report(4050);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getShortName());</b>
<b class="nc">&nbsp;            r.add(te.getOwner().getName());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (glancing) {</b>
&nbsp;                // Round up glancing blows against conventional infantry
<b class="nc">&nbsp;                if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                damage += toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;                hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;            }
&nbsp;
&nbsp;            int leg;
<b class="nc">&nbsp;            switch (kaa.getLeg()) {</b>
&nbsp;                case KickAttackAction.LEFT:
<b class="nc">&nbsp;                    if (ae instanceof QuadMech) {</b>
<b class="nc">&nbsp;                        leg = Mech.LOC_LARM;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        leg = Mech.LOC_LLEG;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case KickAttackAction.RIGHT:
<b class="nc">&nbsp;                    if (ae instanceof QuadMech) {</b>
<b class="nc">&nbsp;                        leg = Mech.LOC_RARM;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        leg = Mech.LOC_RLEG;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case KickAttackAction.LEFTMULE:
<b class="nc">&nbsp;                    leg = Mech.LOC_LLEG;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case KickAttackAction.RIGHTMULE:
&nbsp;                default:
<b class="nc">&nbsp;                    leg = Mech.LOC_RLEG;</b>
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            damage = checkForSpikes(te, hit.getLocation(), damage, ae, leg);</b>
<b class="nc">&nbsp;            DamageType damageType = DamageType.NONE;</b>
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage, false, damageType, false,</b>
&nbsp;                    false, throughFront));
<b class="nc">&nbsp;            if (target instanceof VTOL) {</b>
&nbsp;                // destroy rotor
<b class="nc">&nbsp;                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,</b>
&nbsp;                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
&nbsp;                                VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
&nbsp;            }
<b class="nc">&nbsp;            if (te.hasQuirk(OptionsConstants.QUIRK_NEG_WEAK_LEGS)) {</b>
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                addReport(criticalEntity(te, hit.getLocation(), hit.isRear(), 0, 0));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (te.canFall()) {</b>
<b class="nc">&nbsp;            PilotingRollData kickPRD = getKickPushPSR(te, ae, te, &quot;was kicked&quot;);</b>
<b class="nc">&nbsp;            game.addPSR(kickPRD);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((te instanceof Mech) &amp;&amp; ((Mech) te).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) te).setCheckForCrit(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a kick attack
&nbsp;     */
&nbsp;    private void resolveJumpJetAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        JumpJetAttackAction kaa = (JumpJetAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(kaa.getEntityId());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(kaa.getTargetType(), kaa.getTargetId());</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
&nbsp;        String legName;
<b class="nc">&nbsp;        switch (kaa.getLeg()) {</b>
&nbsp;            case JumpJetAttackAction.LEFT:
<b class="nc">&nbsp;                legName = &quot;Left leg&quot;;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case JumpJetAttackAction.RIGHT:
<b class="nc">&nbsp;                legName = &quot;Right leg&quot;;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                legName = &quot;Both legs&quot;;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(target.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != ae.getId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4290);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(legName);</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4075);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4080);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // If the target is in a building, the building absorbs the damage.
<b class="nc">&nbsp;            if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
&nbsp;
<b class="nc">&nbsp;                damage += pr.damageRight;</b>
&nbsp;                // Only report if damage was done to the building.
<b class="nc">&nbsp;                if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; buildingReport = damageBuilding(bldg,</b>
<b class="nc">&nbsp;                                                                   damage, target.getPosition());</b>
<b class="nc">&nbsp;                    for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = ae.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(buildingReport);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Targeting a building.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
<b class="nc">&nbsp;            damage += pr.damageRight;</b>
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage,</b>
<b class="nc">&nbsp;                                                           target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
&nbsp;            // And we&#39;re done!
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4040);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        for (int leg = 0; leg &lt; 2; leg++) {</b>
<b class="nc">&nbsp;            if (leg == 1) {</b>
<b class="nc">&nbsp;                damage = pr.damageRight;</b>
<b class="nc">&nbsp;                if (damage == 0) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_ENERGY);</b>
&nbsp;
&nbsp;            // The building shields all units from a certain amount of damage.
&nbsp;            // The amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;            if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
<b class="nc">&nbsp;                int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());</b>
<b class="nc">&nbsp;                int toBldg = Math.min(bldgAbsorbs, damage);</b>
<b class="nc">&nbsp;                damage -= toBldg;</b>
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage,</b>
<b class="nc">&nbsp;                                                               target.getPosition());</b>
<b class="nc">&nbsp;                for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                    report.subject = ae.getId();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                addReport(buildingReport);</b>
&nbsp;
&nbsp;                // some buildings scale remaining damage that is not absorbed
&nbsp;                // TODO : this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;                damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
&nbsp;            }
&nbsp;
&nbsp;            // A building may absorb the entire shot.
<b class="nc">&nbsp;            if (damage == 0) {</b>
<b class="nc">&nbsp;                r = new Report(4050);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(te.getShortName());</b>
<b class="nc">&nbsp;                r.add(te.getOwner().getName());</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (glancing) {</b>
&nbsp;                    // Round up glancing blows against conventional infantry
<b class="nc">&nbsp;                    if ((te instanceof Infantry)</b>
&nbsp;                        &amp;&amp; !(te instanceof BattleArmor)) {
<b class="nc">&nbsp;                        damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (directBlow) {</b>
<b class="nc">&nbsp;                    damage += toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;                    hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;                }
<b class="nc">&nbsp;                addReport(damageEntity(te, hit, damage, false, DamageType.NONE,</b>
&nbsp;                                       false, false, throughFront));
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((target instanceof Mech) &amp;&amp; ((Mech) target).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) target).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a ProtoMech physical attack
&nbsp;     */
&nbsp;
&nbsp;    private void resolveProtoAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final ProtomechPhysicalAttackAction ppaa = (ProtomechPhysicalAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(ppaa.getEntityId());</b>
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(ppaa.getTargetType(), ppaa.getTargetId());</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(target.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != ae.getId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4070);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4075);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4080);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // If the target is in a building, the building absorbs the damage.
<b class="nc">&nbsp;            if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
&nbsp;
&nbsp;                // Only report if damage was done to the building.
<b class="nc">&nbsp;                if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;                    for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = ae.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(buildingReport);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Targeting a building.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;                || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
&nbsp;            // And we&#39;re done!
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
&nbsp;
<b class="nc">&nbsp;        r = new Report(4045);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;        r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // The building shields all units from a certain amount of damage.
&nbsp;        // The amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;        if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
<b class="nc">&nbsp;            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());</b>
<b class="nc">&nbsp;            int toBldg = Math.min(bldgAbsorbs, damage);</b>
<b class="nc">&nbsp;            damage -= toBldg;</b>
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage,</b>
<b class="nc">&nbsp;                                                           target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // some buildings scale remaining damage that is not absorbed
&nbsp;            // TODO : this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;            damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
&nbsp;        }
&nbsp;
&nbsp;        // A building may absorb the entire shot.
<b class="nc">&nbsp;        if (damage == 0) {</b>
<b class="nc">&nbsp;            r = new Report(4050);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getShortName());</b>
<b class="nc">&nbsp;            r.add(te.getOwner().getName());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (glancing) {</b>
&nbsp;                // Round up glancing blows against conventional infantry
<b class="nc">&nbsp;                if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                damage += toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;                hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;            }
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage, false, DamageType.NONE,</b>
&nbsp;                                   false, false, throughFront));
<b class="nc">&nbsp;            if (((Protomech) ae).isEDPCharged()) {</b>
<b class="nc">&nbsp;                r = new Report(3701);</b>
<b class="nc">&nbsp;                int taserRoll = Compute.d6(2) - 2;</b>
<b class="nc">&nbsp;                r.add(taserRoll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (te instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                    r = new Report(3706);</b>
<b class="nc">&nbsp;                    r.addDesc(te);</b>
&nbsp;                    // shut down for rest of scenario, so we actually kill it
&nbsp;                    // TODO : fix for salvage purposes
<b class="nc">&nbsp;                    HitData targetTrooper = te.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    r.add(te.getLocationAbbr(targetTrooper));</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(criticalEntity(ae, targetTrooper.getLocation(),</b>
<b class="nc">&nbsp;                            targetTrooper.isRear(), 0, false, false, 0));</b>
<b class="nc">&nbsp;                } else if (te instanceof Mech) {</b>
<b class="nc">&nbsp;                    if (((Mech) te).isIndustrial()) {</b>
<b class="nc">&nbsp;                        if (taserRoll &gt;= 8) {</b>
<b class="nc">&nbsp;                            r = new Report(3705);</b>
<b class="nc">&nbsp;                            r.addDesc(te);</b>
<b class="nc">&nbsp;                            r.add(4);</b>
<b class="nc">&nbsp;                            te.taserShutdown(4, false);</b>
&nbsp;                        } else {
&nbsp;                            // suffer +2 to piloting and gunnery for 4 rounds
<b class="nc">&nbsp;                            r = new Report(3710);</b>
<b class="nc">&nbsp;                            r.addDesc(te);</b>
<b class="nc">&nbsp;                            r.add(2);</b>
<b class="nc">&nbsp;                            r.add(4);</b>
<b class="nc">&nbsp;                            te.setTaserInterference(2, 4, true);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (taserRoll &gt;= 11) {</b>
<b class="nc">&nbsp;                            r = new Report(3705);</b>
<b class="nc">&nbsp;                            r.addDesc(te);</b>
<b class="nc">&nbsp;                            r.add(3);</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                            te.taserShutdown(3, false);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r = new Report(3710);</b>
<b class="nc">&nbsp;                            r.addDesc(te);</b>
<b class="nc">&nbsp;                            r.add(2);</b>
<b class="nc">&nbsp;                            r.add(3);</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                            te.setTaserInterference(2, 3, true);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((te instanceof Protomech) || (te instanceof Tank)</b>
&nbsp;                           || (te instanceof Aero)) {
<b class="nc">&nbsp;                    if (taserRoll &gt;= 8) {</b>
<b class="nc">&nbsp;                        r = new Report(3705);</b>
<b class="nc">&nbsp;                        r.addDesc(te);</b>
<b class="nc">&nbsp;                        r.add(4);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        te.taserShutdown(4, false);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(3710);</b>
<b class="nc">&nbsp;                        r.addDesc(te);</b>
<b class="nc">&nbsp;                        r.add(2);</b>
<b class="nc">&nbsp;                        r.add(4);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        te.setTaserInterference(2, 4, false);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((target instanceof Mech) &amp;&amp; ((Mech) target).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) target).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a brush off attack
&nbsp;     */
&nbsp;    private void resolveBrushOffAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final BrushOffAttackAction baa = (BrushOffAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(baa.getEntityId());</b>
&nbsp;        // PLEASE NOTE: buildings are *never* the target
&nbsp;        // of a &quot;brush off&quot;, but iNarc pods **are**.
<b class="nc">&nbsp;        Targetable target = game.getTarget(baa.getTargetType(), baa.getTargetId());</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        final String armName = baa.getArm() == BrushOffAttackAction.LEFT ? &quot;Left Arm&quot; : &quot;Right Arm&quot;;</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = game.getEntity(baa.getTargetId());</b>
&nbsp;        }
&nbsp;
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
&nbsp;        // ASSUMPTION: buildings can&#39;t absorb *this* damage.
<b class="nc">&nbsp;        int damage = baa.getArm() == BrushOffAttackAction.LEFT ? pr.damage : pr.damageRight;</b>
<b class="nc">&nbsp;        final ToHitData toHit = baa.getArm() == BrushOffAttackAction.LEFT ? pr.toHit : pr.toHitRight;</b>
<b class="nc">&nbsp;        int roll = baa.getArm() == BrushOffAttackAction.LEFT ? pr.roll : pr.rollRight;</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != baa.getEntityId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4085);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.add(armName);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4090);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // report the roll
<b class="nc">&nbsp;        r = new Report(4025);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getValue());</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // Missed Brush Off attacks cause punch damage to the attacker.
<b class="nc">&nbsp;            toHit.setHitTable(ToHitData.HIT_PUNCH);</b>
<b class="nc">&nbsp;            toHit.setSideTable(ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;            HitData hit = ae.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            r = new Report(4095);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            r.add(ae.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, damage));</b>
<b class="nc">&nbsp;            addNewLines();</b>
&nbsp;            // if this is an industrial mech, it needs to check for crits
&nbsp;            // at the end of turn
<b class="nc">&nbsp;            if ((ae instanceof Mech) &amp;&amp; ((Mech) ae).isIndustrial()) {</b>
<b class="nc">&nbsp;                ((Mech) ae).setCheckForCrit(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Different target types get different handling.
<b class="nc">&nbsp;        switch (target.getTargetType()) {</b>
&nbsp;            case Targetable.TYPE_ENTITY:
&nbsp;                // Handle Entity targets.
<b class="nc">&nbsp;                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                r = new Report(4045);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;                r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(damageEntity(te, hit, damage));</b>
<b class="nc">&nbsp;                addNewLines();</b>
&nbsp;
&nbsp;                // Dislodge the swarming infantry.
<b class="nc">&nbsp;                ae.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                te.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;                r = new Report(4100);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(te.getDisplayName());</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Targetable.TYPE_INARC_POD:
&nbsp;                // Handle iNarc pod targets.
&nbsp;                // TODO : check the return code and handle false appropriately.
<b class="nc">&nbsp;                ae.removeINarcPod((INarcPod) target);</b>
&nbsp;                // // TODO : confirm that we don&#39;t need to update the attacker.
&nbsp;                // //killme
&nbsp;                // entityUpdate( ae.getId() ); // killme
<b class="nc">&nbsp;                r = new Report(4105);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                break;
&nbsp;            // TODO : add a default: case and handle it appropriately.
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a thrash attack
&nbsp;     */
&nbsp;    private void resolveThrashAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final ThrashAttackAction taa = (ThrashAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(taa.getEntityId());</b>
&nbsp;
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int hits = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
<b class="nc">&nbsp;                                 &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
<b class="nc">&nbsp;                                   &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        // PLEASE NOTE: buildings are *never* the target of a &quot;thrash&quot;.
<b class="nc">&nbsp;        final Entity te = game.getEntity(taa.getTargetId());</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != taa.getEntityId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4110);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(te);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4115);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Thrash attack may hit automatically
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4120);</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // do we hit?
<b class="nc">&nbsp;            if (roll &lt; toHit.getValue()) {</b>
&nbsp;                // miss
<b class="nc">&nbsp;                r = new Report(4035);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report(4125);</b>
&nbsp;        }
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Standard damage loop in 5 point clusters.
<b class="nc">&nbsp;        if (glancing) {</b>
<b class="nc">&nbsp;            hits = (int) Math.floor(hits / 2.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (directBlow) {</b>
<b class="nc">&nbsp;            hits += toHit.getMoS() / 3;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4130);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(hits);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        if (glancing) {</b>
<b class="nc">&nbsp;            r = new Report(3186);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (directBlow) {</b>
<b class="nc">&nbsp;            r = new Report(3189);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (hits &gt; 0) {</b>
<b class="nc">&nbsp;            int damage = Math.min(5, hits);</b>
<b class="nc">&nbsp;            hits -= damage;</b>
<b class="nc">&nbsp;            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            r = new Report(4135);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;        // Thrash attacks cause PSRs. Failed PSRs cause falling damage.
&nbsp;        // This fall damage applies even though the Thrashing Mek is prone.
<b class="nc">&nbsp;        PilotingRollData rollData = ae.getBasePilotingRoll();</b>
<b class="nc">&nbsp;        ae.addPilotingModifierForTerrain(rollData);</b>
<b class="nc">&nbsp;        rollData.addModifier(0, &quot;thrashing at infantry&quot;);</b>
<b class="nc">&nbsp;        r = new Report(4140);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.addDesc(ae);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(2190);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(rollData.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(rollData.getDesc());</b>
<b class="nc">&nbsp;        r.add(diceRoll);</b>
<b class="nc">&nbsp;        if (diceRoll &lt; rollData.getValue()) {</b>
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(doEntityFall(ae, rollData));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a thrash attack
&nbsp;     */
&nbsp;    private void resolveBAVibroClawAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final BAVibroClawAttackAction bvaa = (BAVibroClawAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(bvaa.getEntityId());</b>
&nbsp;
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int hits = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)
<b class="nc">&nbsp;                                 &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)
<b class="nc">&nbsp;                                   &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        // PLEASE NOTE: buildings are *never* the target of a BA vibroclaw
&nbsp;        // attack.
<b class="nc">&nbsp;        final Entity te = game.getEntity(bvaa.getTargetId());</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != bvaa.getEntityId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4146);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(te);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4147);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we may hit automatically
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4120);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // do we hit?
<b class="nc">&nbsp;            if (roll &lt; toHit.getValue()) {</b>
&nbsp;                // miss
<b class="nc">&nbsp;                r = new Report(4035);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Standard damage loop
<b class="nc">&nbsp;        if (glancing) {</b>
<b class="nc">&nbsp;            hits = (int) Math.floor(hits / 2.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (directBlow) {</b>
<b class="nc">&nbsp;            hits += toHit.getMoS() / 3;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            r = new Report(4149);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(hits);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(4148);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(hits);</b>
<b class="nc">&nbsp;            r.add(ae.getVibroClaws());</b>
&nbsp;        }
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        if (glancing) {</b>
<b class="nc">&nbsp;            r = new Report(3186);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (directBlow) {</b>
<b class="nc">&nbsp;            r = new Report(3189);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        while (hits &gt; 0) {</b>
&nbsp;            // BA get hit separately by each attacking BA trooper
<b class="nc">&nbsp;            int damage = Math.min(ae.getVibroClaws(), hits);</b>
&nbsp;            // conventional infantry get hit in one lump
<b class="nc">&nbsp;            if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                damage = hits;</b>
&nbsp;            }
<b class="nc">&nbsp;            hits -= damage;</b>
<b class="nc">&nbsp;            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            r = new Report(4135);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a club attack
&nbsp;     */
&nbsp;    private void resolveClubAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final ClubAttackAction caa = (ClubAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(caa.getEntityId());</b>
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
&nbsp;        // LAMs in airmech mode do half damage if airborne.
<b class="nc">&nbsp;        if (ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            damage = (int)Math.ceil(damage * 0.5);</b>
&nbsp;        }
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute</b>
<b class="nc">&nbsp;                    .isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
&nbsp;        // Make sure the MoS is zero for *automatic* hits in case direct blows
&nbsp;        // are in force.
<b class="nc">&nbsp;        toHit.setMoS((roll == Integer.MAX_VALUE) ? 0 : roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(target.getPosition());</b>
&nbsp;
&nbsp;        // restore club attack
<b class="nc">&nbsp;        caa.getClub().restore();</b>
&nbsp;
&nbsp;        // Shield bash causes 1 point of damage to the shield
<b class="nc">&nbsp;        if (((MiscType) caa.getClub().getType()).isShield()) {</b>
<b class="nc">&nbsp;            ((Mech) ae).shieldAbsorptionDamage(1, caa.getClub().getLocation(), false);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != caa.getEntityId()) {</b>
&nbsp;            // who is making the attacks
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4145);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(caa.getClub().getName());</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Flail/Wrecking Ball auto misses on a 2 and hits themself.
<b class="nc">&nbsp;        if ((caa.getClub().getType().hasSubType(MiscType.S_FLAIL)</b>
<b class="nc">&nbsp;                || caa.getClub().getType().hasSubType(MiscType.S_WRECKING_BALL))</b>
&nbsp;            &amp;&amp; (roll == 2)) {
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            ToHitData newToHit = new ToHitData(TargetRoll.AUTOMATIC_SUCCESS,</b>
&nbsp;                                               &quot;hit with own flail/wrecking ball&quot;);
<b class="nc">&nbsp;            pr.damage = ClubAttackAction.getDamageFor(ae, caa.getClub(), false, caa.isZweihandering());</b>
<b class="nc">&nbsp;            pr.damage = (pr.damage / 2) + (pr.damage % 2);</b>
<b class="nc">&nbsp;            newToHit.setHitTable(ToHitData.HIT_NORMAL);</b>
<b class="nc">&nbsp;            newToHit.setSideTable(ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;            pr.toHit = newToHit;</b>
<b class="nc">&nbsp;            pr.aaa.setTargetId(ae.getId());</b>
<b class="nc">&nbsp;            pr.aaa.setTargetType(Targetable.TYPE_ENTITY);</b>
<b class="nc">&nbsp;            pr.roll = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            resolveClubAttack(pr, ae.getId());</b>
<b class="nc">&nbsp;            if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                        &quot;missed a flail/wrecking ball attack&quot;));
&nbsp;            } else {
<b class="nc">&nbsp;                game.addPSR(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                                                 &quot;missed a flail/wrecking ball attack&quot;));
&nbsp;            }
<b class="nc">&nbsp;            if(caa.isZweihandering()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                criticalLocs.add(caa.getClub().getLocation());</b>
<b class="nc">&nbsp;                applyZweihanderSelfDamage(ae, true, criticalLocs);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Need to compute 2d6 damage. and add +3 heat build up.
<b class="nc">&nbsp;        if (caa.getClub().getType().hasSubType(MiscType.S_BUZZSAW)) {</b>
<b class="nc">&nbsp;            damage = Compute.d6(2);</b>
<b class="nc">&nbsp;            ae.heatBuildup += 3;</b>
&nbsp;
&nbsp;            // Buzzsaw&#39;s blade will shatter on a roll of 2.
<b class="nc">&nbsp;            if (roll == 2) {</b>
&nbsp;
<b class="nc">&nbsp;                Mounted club = caa.getClub();</b>
&nbsp;
<b class="nc">&nbsp;                for (Mounted eq : ae.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if ((eq.getLocation() == club.getLocation())</b>
<b class="nc">&nbsp;                        &amp;&amp; (eq.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                        &amp;&amp; eq.getType().hasFlag(MiscType.F_CLUB)</b>
<b class="nc">&nbsp;                        &amp;&amp; eq.getType().hasSubType(MiscType.S_BUZZSAW)) {</b>
<b class="nc">&nbsp;                        eq.setHit(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                r = new Report(4037);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                if(caa.isZweihandering()) {</b>
<b class="nc">&nbsp;                    ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                    criticalLocs.add(caa.getClub().getLocation());</b>
<b class="nc">&nbsp;                    applyZweihanderSelfDamage(ae, true, criticalLocs);</b>
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4075);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (caa.getClub().getType().hasSubType(MiscType.S_MACE_THB)) {</b>
<b class="nc">&nbsp;                if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                } else {
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (caa.getClub().getType().hasSubType(MiscType.S_MACE)) {</b>
<b class="nc">&nbsp;                if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                } else {
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if(caa.isZweihandering()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                criticalLocs.add(caa.getClub().getLocation());</b>
<b class="nc">&nbsp;                applyZweihanderSelfDamage(ae, true, criticalLocs);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4080);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (caa.getClub().getType().hasSubType(MiscType.S_MACE_THB)) {</b>
<b class="nc">&nbsp;                if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                } else {
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(ae.getId(), 0,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (caa.getClub().getType().hasSubType(MiscType.S_MACE)) {</b>
<b class="nc">&nbsp;                if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(ae.getId(), 2,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                } else {
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(ae.getId(), 2,</b>
&nbsp;                            &quot;missed a mace attack&quot;));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If the target is in a building, the building absorbs the damage.
<b class="nc">&nbsp;            if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
&nbsp;
&nbsp;                // Only report if damage was done to the building.
<b class="nc">&nbsp;                if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; buildingReport = damageBuilding(bldg,</b>
<b class="nc">&nbsp;                                                                   damage, target.getPosition());</b>
<b class="nc">&nbsp;                    for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                        report.subject = ae.getId();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    addReport(buildingReport);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            if(caa.isZweihandering()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                criticalLocs.add(caa.getClub().getLocation());</b>
<b class="nc">&nbsp;                applyZweihanderSelfDamage(ae, true, criticalLocs);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Targeting a building.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
<b class="nc">&nbsp;            if(caa.isZweihandering()) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                criticalLocs.add(caa.getClub().getLocation());</b>
<b class="nc">&nbsp;                applyZweihanderSelfDamage(ae, false, criticalLocs);</b>
<b class="nc">&nbsp;                if (caa.getClub().getType().hasSubType(MiscType.S_CLUB)) {</b>
&nbsp;                    // the club breaks
<b class="nc">&nbsp;                    r = new Report(4150);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.add(caa.getClub().getName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    ae.removeMisc(caa.getClub().getName());</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // And we&#39;re done!
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;        hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;        r = new Report(4045);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;        r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // The building shields all units from a certain amount of damage.
&nbsp;        // The amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;        if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
<b class="nc">&nbsp;            int bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());</b>
<b class="nc">&nbsp;            int toBldg = Math.min(bldgAbsorbs, damage);</b>
<b class="nc">&nbsp;            damage -= toBldg;</b>
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // some buildings scale remaining damage that is not absorbed
&nbsp;            // TODO : this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;            damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
&nbsp;        }
&nbsp;
&nbsp;        // A building may absorb the entire shot.
<b class="nc">&nbsp;        if (damage == 0) {</b>
<b class="nc">&nbsp;            r = new Report(4050);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getShortName());</b>
<b class="nc">&nbsp;            r.add(te.getOwner().getName());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (glancing) {</b>
&nbsp;                // Round up glancing blows against conventional infantry
<b class="nc">&nbsp;                if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                damage += toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;                hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            damage = checkForSpikes(te, hit.getLocation(), damage, ae, Entity.LOC_NONE);</b>
&nbsp;
<b class="nc">&nbsp;            DamageType damageType = DamageType.NONE;</b>
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage, false, damageType, false,</b>
&nbsp;                                   false, throughFront));
<b class="nc">&nbsp;            if (target instanceof VTOL) {</b>
&nbsp;                // destroy rotor
<b class="nc">&nbsp;                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,</b>
&nbsp;                                           new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
&nbsp;                                                            VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // On a roll of 10+ a lance hitting a mech/Vehicle can cause 1 point of
&nbsp;        // internal damage
<b class="nc">&nbsp;        if (caa.getClub().getType().hasSubType(MiscType.S_LANCE)</b>
<b class="nc">&nbsp;            &amp;&amp; (te.getArmor(hit) &gt; 0)</b>
<b class="nc">&nbsp;            &amp;&amp; (te.getArmorType(hit.getLocation()) != EquipmentType.T_ARMOR_HARDENED)</b>
<b class="nc">&nbsp;            &amp;&amp; (te.getArmorType(hit.getLocation()) != EquipmentType.T_ARMOR_FERRO_LAMELLOR)) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;            // Pierce checking report
<b class="nc">&nbsp;            r = new Report(4021);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (roll &gt;= 10) {</b>
<b class="nc">&nbsp;                hit.makeGlancingBlow();</b>
<b class="nc">&nbsp;                addReport(damageEntity(te, hit, 1, false, DamageType.NONE,</b>
&nbsp;                                       true, false, throughFront));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // TODO : Verify this is correct according to latest rules
<b class="nc">&nbsp;        if (caa.getClub().getType().hasSubType(MiscType.S_WRECKING_BALL)</b>
&nbsp;                &amp;&amp; (ae instanceof SupportTank) &amp;&amp; (te instanceof Mech)) {
&nbsp;            // forces a PSR like a charge
<b class="nc">&nbsp;            if (te instanceof LandAirMech &amp;&amp; te.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(te.getId(), 2,</b>
&nbsp;                        &quot;was hit by wrecking ball&quot;));
&nbsp;            } else {
<b class="nc">&nbsp;                game.addPSR(new PilotingRollData(te.getId(), 2,</b>
&nbsp;                        &quot;was hit by wrecking ball&quot;));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Chain whips can entangle &#39;Mech and ProtoMech limbs. This
&nbsp;        // implementation assumes that in order to do so the limb must still
&nbsp;        // have some structure left, so if the whip hits and destroys a
&nbsp;        // location in the same attack no special effects take place.
<b class="nc">&nbsp;        if (caa.getClub().getType().hasSubType(MiscType.S_CHAIN_WHIP)</b>
&nbsp;                &amp;&amp; ((te instanceof Mech) || (te instanceof Protomech))) {
<b class="nc">&nbsp;            addNewLines();</b>
&nbsp;
<b class="nc">&nbsp;            int loc = hit.getLocation();</b>
<b class="nc">&nbsp;            int toHitNumber = toHit.getValue();</b>
&nbsp;
<b class="nc">&nbsp;            boolean mightTrip = (te instanceof Mech)</b>
<b class="nc">&nbsp;                    &amp;&amp; te.locationIsLeg(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.isLocationBad(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.isLocationDoomed(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.hasActiveShield(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.hasPassiveShield(loc);</b>
&nbsp;
<b class="nc">&nbsp;            boolean mightGrapple = ((te instanceof Mech)</b>
&nbsp;                    &amp;&amp; ((loc == Mech.LOC_LARM) || (loc == Mech.LOC_RARM))
<b class="nc">&nbsp;                    &amp;&amp; !te.isLocationBad(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.isLocationDoomed(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.hasActiveShield(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.hasPassiveShield(loc)</b>
<b class="nc">&nbsp;                    &amp;&amp; !te.hasNoDefenseShield(loc))</b>
&nbsp;                    || ((te instanceof Protomech)
&nbsp;                        &amp;&amp; ((loc == Protomech.LOC_LARM) || (loc == Protomech.LOC_RARM)
&nbsp;                            || (loc == Protomech.LOC_LEG))
&nbsp;                        // Only check location status after confirming we did
&nbsp;                        // hit a limb -- Protos have no actual near-miss
&nbsp;                        // &quot;location&quot; and will throw an exception if it&#39;s
&nbsp;                        // referenced here.
<b class="nc">&nbsp;                        &amp;&amp; !te.isLocationBad(loc)</b>
<b class="nc">&nbsp;                        &amp;&amp; !te.isLocationDoomed(loc));</b>
&nbsp;
<b class="nc">&nbsp;            if (mightTrip) {</b>
<b class="nc">&nbsp;                roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;                if ((ae instanceof Mech) &amp;&amp; (((Mech) ae).hasTSM() &amp;&amp; (ae.heat &gt;= 9))</b>
<b class="nc">&nbsp;                        &amp;&amp; (!((Mech) te).hasTSM() || ((((Mech) te).hasTSM()) &amp;&amp; (te.heat &lt; 9)))) {</b>
<b class="nc">&nbsp;                    toHitNumber -= 2;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                r = new Report(4450);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(ae.getShortName());</b>
<b class="nc">&nbsp;                r.add(te.getShortName());</b>
<b class="nc">&nbsp;                r.add(toHitNumber);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (roll &gt;= toHit.getValue()) {</b>
<b class="nc">&nbsp;                    r = new Report(2270);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(te.getId(), 3, &quot;Snared by chain whip&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(2357);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (mightGrapple) {</b>
<b class="nc">&nbsp;                GrappleAttackAction gaa = new GrappleAttackAction(ae.getId(), te.getId());</b>
&nbsp;                int grappleSide;
<b class="nc">&nbsp;                if (caa.getClub().getLocation() == Mech.LOC_RARM) {</b>
<b class="nc">&nbsp;                    grappleSide = Entity.GRAPPLE_RIGHT;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    grappleSide = Entity.GRAPPLE_LEFT;</b>
&nbsp;                }
<b class="nc">&nbsp;                ToHitData grappleHit = GrappleAttackAction.toHit(game, ae.getId(), target,</b>
&nbsp;                        grappleSide, true);
<b class="nc">&nbsp;                PhysicalResult grappleResult = new PhysicalResult();</b>
<b class="nc">&nbsp;                grappleResult.aaa = gaa;</b>
<b class="nc">&nbsp;                grappleResult.toHit = grappleHit;</b>
<b class="nc">&nbsp;                grappleResult.roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                resolveGrappleAttack(grappleResult, lastEntityId, grappleSide,</b>
<b class="nc">&nbsp;                        hit.getLocation() == Mech.LOC_RARM ? Entity.GRAPPLE_RIGHT : Entity.GRAPPLE_LEFT);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
<b class="nc">&nbsp;        if (caa.getClub().getType().hasSubType(MiscType.S_TREE_CLUB)) {</b>
&nbsp;            // the club breaks
<b class="nc">&nbsp;            r = new Report(4150);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(caa.getClub().getName());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            ae.removeMisc(caa.getClub().getName());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if(caa.isZweihandering()) {</b>
<b class="nc">&nbsp;            ArrayList&lt;Integer&gt; criticalLocs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            criticalLocs.add(caa.getClub().getLocation());</b>
<b class="nc">&nbsp;            applyZweihanderSelfDamage(ae, false, criticalLocs);</b>
<b class="nc">&nbsp;            if (caa.getClub().getType().hasSubType(MiscType.S_CLUB)) {</b>
&nbsp;                // the club breaks
<b class="nc">&nbsp;                r = new Report(4150);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(caa.getClub().getName());</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                ae.removeMisc(caa.getClub().getName());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((target instanceof Mech) &amp;&amp; ((Mech) target).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) target).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a push attack
&nbsp;     */
&nbsp;    private void resolvePushAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final PushAttackAction paa = (PushAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(paa.getEntityId());</b>
&nbsp;        // PLEASE NOTE: buildings are *never* the target of a &quot;push&quot;.
<b class="nc">&nbsp;        final Entity te = game.getEntity(paa.getTargetId());</b>
&nbsp;        // get roll and ToHitData from the PhysicalResult
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // was this push resolved earlier?
<b class="nc">&nbsp;        if (pr.pushBackResolved) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // don&#39;t try this one again
<b class="nc">&nbsp;        pr.pushBackResolved = true;</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != paa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4155);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(te);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4160);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // report the roll
<b class="nc">&nbsp;        r = new Report(4025);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getValue());</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // check if our target has a push against us, too, and get it
<b class="nc">&nbsp;        PhysicalResult targetPushResult = null;</b>
<b class="nc">&nbsp;        for (PhysicalResult tpr : physicalResults) {</b>
<b class="nc">&nbsp;            if ((tpr.aaa.getEntityId() == te.getId()) &amp;&amp; (tpr.aaa instanceof PushAttackAction)</b>
<b class="nc">&nbsp;                    &amp;&amp; (tpr.aaa.getTargetId() == ae.getId())) {</b>
<b class="nc">&nbsp;                targetPushResult = tpr;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // if our target has a push against us,
&nbsp;        // and we are hitting, we need to resolve both now
<b class="nc">&nbsp;        if ((targetPushResult != null) &amp;&amp; !targetPushResult.pushBackResolved</b>
<b class="nc">&nbsp;            &amp;&amp; (roll &gt;= toHit.getValue())) {</b>
<b class="nc">&nbsp;            targetPushResult.pushBackResolved = true;</b>
&nbsp;            // do they hit?
<b class="nc">&nbsp;            if (targetPushResult.roll &gt;= targetPushResult.toHit.getValue()) {</b>
<b class="nc">&nbsp;                r = new Report(4165);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                r.addDesc(ae);</b>
<b class="nc">&nbsp;                r.add(targetPushResult.toHit.getValue());</b>
<b class="nc">&nbsp;                r.add(targetPushResult.roll);</b>
<b class="nc">&nbsp;                r.addDesc(ae);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                if (ae.canFall()) {</b>
<b class="nc">&nbsp;                    PilotingRollData pushPRD = getKickPushPSR(ae, ae, te, &quot;was pushed&quot;);</b>
<b class="nc">&nbsp;                    game.addPSR(pushPRD);</b>
<b class="nc">&nbsp;                } else if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(getKickPushPSR(ae, ae, te, &quot;was pushed&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (te.canFall()) {</b>
<b class="nc">&nbsp;                    PilotingRollData targetPushPRD = getKickPushPSR(te, ae, te, &quot;was pushed&quot;);</b>
<b class="nc">&nbsp;                    game.addPSR(targetPushPRD);</b>
<b class="nc">&nbsp;                } else if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(getKickPushPSR(te, ae, te, &quot;was pushed&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // report the miss
<b class="nc">&nbsp;            r = new Report(4166);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            r.add(targetPushResult.toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(targetPushResult.roll);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we hit...
<b class="nc">&nbsp;        int direction = ae.getFacing();</b>
&nbsp;
<b class="nc">&nbsp;        Coords src = te.getPosition();</b>
<b class="nc">&nbsp;        Coords dest = src.translated(direction);</b>
&nbsp;
<b class="nc">&nbsp;        PilotingRollData pushPRD = getKickPushPSR(te, ae, te, &quot;was pushed&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {</b>
<b class="nc">&nbsp;            r = new Report(4170);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (game.getBoard().contains(dest)) {</b>
<b class="nc">&nbsp;                r = new Report(4175);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(dest.getBoardNum(), true);</b>
&nbsp;            } else {
&nbsp;                // uh-oh, pushed off board
<b class="nc">&nbsp;                r = new Report(4180);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
&nbsp;            }
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            addReport(doEntityDisplacement(te, src, dest, pushPRD));</b>
&nbsp;
&nbsp;            // if push actually moved the target, attacker follows through
<b class="nc">&nbsp;            if (!te.getPosition().equals(src)) {</b>
<b class="nc">&nbsp;                ae.setPosition(src);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // target immovable
<b class="nc">&nbsp;            r = new Report(4185);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (te.canFall()) {</b>
<b class="nc">&nbsp;                game.addPSR(pushPRD);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((te instanceof Mech) &amp;&amp; ((Mech) te).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) te).setCheckForCrit(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        checkForSpikes(te, ae.rollHitLocation(ToHitData.HIT_PUNCH, Compute.targetSideTable(ae, te)).getLocation(),</b>
&nbsp;                0, ae, Mech.LOC_LARM, Mech.LOC_RARM);
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a trip attack
&nbsp;     */
&nbsp;    private void resolveTripAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final TripAttackAction paa = (TripAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(paa.getEntityId());</b>
&nbsp;        // PLEASE NOTE: buildings are *never* the target of a &quot;trip&quot;.
<b class="nc">&nbsp;        final Entity te = game.getEntity(paa.getTargetId());</b>
&nbsp;        // get roll and ToHitData from the PhysicalResult
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != paa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4280);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(te);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4285);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // report the roll
<b class="nc">&nbsp;        r = new Report(4025);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getValue());</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we hit...
<b class="nc">&nbsp;        if (te.canFall()) {</b>
<b class="nc">&nbsp;            PilotingRollData pushPRD = getKickPushPSR(te, ae, te, &quot;was tripped&quot;);</b>
<b class="nc">&nbsp;            game.addPSR(pushPRD);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4040);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((te instanceof Mech) &amp;&amp; ((Mech) te).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) te).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a grapple attack
&nbsp;     */
&nbsp;    private void resolveGrappleAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        resolveGrappleAttack(pr, lastEntityId, Entity.GRAPPLE_BOTH,</b>
&nbsp;                Entity.GRAPPLE_BOTH);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves a grapple attack.
&nbsp;     *
&nbsp;     * @param pr            the result of a physical attack - this one specifically being a grapple
&nbsp;     * @param lastEntityId  the entity making the attack
&nbsp;     * @param aeGrappleSide
&nbsp;     *            The side that the attacker is grappling with. For normal
&nbsp;     *            grapples this will be both, for chain whip grapples this will
&nbsp;     *            be the arm with the chain whip in it.
&nbsp;     * @param teGrappleSide
&nbsp;     *            The that the the target is grappling with. For normal grapples
&nbsp;     *            this will be both, for chain whip grapples this will be the
&nbsp;     *            arm that is being whipped.
&nbsp;     */
&nbsp;    private void resolveGrappleAttack(PhysicalResult pr, int lastEntityId,
&nbsp;                                      int aeGrappleSide, int teGrappleSide) {
<b class="nc">&nbsp;        final GrappleAttackAction paa = (GrappleAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(paa.getEntityId());</b>
&nbsp;        // PLEASE NOTE: buildings are *never* the target of a &quot;push&quot;.
<b class="nc">&nbsp;        final Entity te = game.getEntity(paa.getTargetId());</b>
&nbsp;        // get roll and ToHitData from the PhysicalResult
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // same method as push, for counterattacks
<b class="nc">&nbsp;        if (pr.pushBackResolved) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((te.getGrappled() != Entity.NONE)</b>
<b class="nc">&nbsp;            || (ae.getGrappled() != Entity.NONE)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(TargetRoll.IMPOSSIBLE, &quot;Already Grappled&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != paa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4295);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(te);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4300);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // report the roll
<b class="nc">&nbsp;        r = new Report(4025);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(toHit.getValue());</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we hit...
<b class="nc">&nbsp;        ae.setGrappled(te.getId(), true);</b>
<b class="nc">&nbsp;        te.setGrappled(ae.getId(), false);</b>
<b class="nc">&nbsp;        ae.setGrappledThisRound(true);</b>
<b class="nc">&nbsp;        te.setGrappledThisRound(true);</b>
&nbsp;        // For normal grapples, AE moves into targets hex.
<b class="nc">&nbsp;        if (aeGrappleSide == Entity.GRAPPLE_BOTH) {</b>
<b class="nc">&nbsp;            Coords pos = te.getPosition();</b>
<b class="nc">&nbsp;            ae.setPosition(pos);</b>
<b class="nc">&nbsp;            ae.setElevation(te.getElevation());</b>
<b class="nc">&nbsp;            te.setFacing((ae.getFacing() + 3) % 6);</b>
<b class="nc">&nbsp;            addReport(doSetLocationsExposure(ae, game.getBoard().getHex(pos),</b>
<b class="nc">&nbsp;                    false, ae.getElevation()));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ae.setGrappleSide(aeGrappleSide);</b>
<b class="nc">&nbsp;        te.setGrappleSide(teGrappleSide);</b>
&nbsp;
<b class="nc">&nbsp;        r = new Report(4040);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((te instanceof Mech) &amp;&amp; ((Mech) te).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) te).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a break grapple attack
&nbsp;     */
&nbsp;    private void resolveBreakGrappleAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final BreakGrappleAttackAction paa = (BreakGrappleAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(paa.getEntityId());</b>
&nbsp;        // PLEASE NOTE: buildings are *never* the target of a &quot;push&quot;.
<b class="nc">&nbsp;        final Entity te = game.getEntity(paa.getTargetId());</b>
&nbsp;        // get roll and ToHitData from the PhysicalResult
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != paa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4305);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.addDesc(te);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(4310);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed a physical attack&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4320);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // do we hit?
<b class="nc">&nbsp;            if (roll &lt; toHit.getValue()) {</b>
&nbsp;                // miss
<b class="nc">&nbsp;                r = new Report(4035);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                if (ae instanceof LandAirMech &amp;&amp; ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed a physical attack&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // hit
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // is there a counterattack?
<b class="nc">&nbsp;        PhysicalResult targetGrappleResult = null;</b>
<b class="nc">&nbsp;        for (PhysicalResult tpr : physicalResults) {</b>
<b class="nc">&nbsp;            if ((tpr.aaa.getEntityId() == te.getId())</b>
&nbsp;                &amp;&amp; (tpr.aaa instanceof GrappleAttackAction)
<b class="nc">&nbsp;                &amp;&amp; (tpr.aaa.getTargetId() == ae.getId())) {</b>
<b class="nc">&nbsp;                targetGrappleResult = tpr;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (targetGrappleResult != null) {</b>
<b class="nc">&nbsp;            targetGrappleResult.pushBackResolved = true;</b>
&nbsp;            // counterattack
<b class="nc">&nbsp;            r = new Report(4315);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.add(targetGrappleResult.toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(targetGrappleResult.roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // do we hit?
<b class="nc">&nbsp;            if (roll &lt; toHit.getValue()) {</b>
&nbsp;                // miss
<b class="nc">&nbsp;                r = new Report(4035);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
&nbsp;                // hit
<b class="nc">&nbsp;                r = new Report(4040);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // exchange attacker and defender
<b class="nc">&nbsp;                ae.setGrappled(te.getId(), false);</b>
<b class="nc">&nbsp;                te.setGrappled(ae.getId(), true);</b>
&nbsp;
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // score the adjacent hexes
<b class="nc">&nbsp;        Coords[] hexes = new Coords[6];</b>
<b class="nc">&nbsp;        int[] scores = new int[6];</b>
&nbsp;
<b class="nc">&nbsp;        IHex curHex = game.getBoard().getHex(ae.getPosition());</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            hexes[i] = ae.getPosition().translated(i);</b>
<b class="nc">&nbsp;            scores[i] = 0;</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(hexes[i]);</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.MAGMA)) {</b>
<b class="nc">&nbsp;                scores[i] += 10;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                scores[i] += hex.terrainLevel(Terrains.WATER);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((curHex.surface() - hex.surface()) &gt;= 2) {</b>
<b class="nc">&nbsp;                scores[i] += 2 * (curHex.surface() - hex.surface());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int bestScore = 99999;</b>
<b class="nc">&nbsp;        int best = 0;</b>
<b class="nc">&nbsp;        int worstScore = -99999;</b>
<b class="nc">&nbsp;        int worst = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            if (bestScore &gt; scores[i]) {</b>
<b class="nc">&nbsp;                best = i;</b>
<b class="nc">&nbsp;                bestScore = scores[i];</b>
&nbsp;            }
<b class="nc">&nbsp;            if (worstScore &lt; scores[i]) {</b>
<b class="nc">&nbsp;                worst = i;</b>
<b class="nc">&nbsp;                worstScore = scores[i];</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // attacker doesn&#39;t fall, unless off a cliff
<b class="nc">&nbsp;        if (ae.isGrappleAttacker()) {</b>
&nbsp;            // move self to least dangerous hex
<b class="nc">&nbsp;            PilotingRollData psr = ae.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            psr.addModifier(TargetRoll.AUTOMATIC_SUCCESS, &quot;break grapple&quot;);</b>
<b class="nc">&nbsp;            addReport(doEntityDisplacement(ae, ae.getPosition(), hexes[best], psr));</b>
<b class="nc">&nbsp;            ae.setFacing(hexes[best].direction(te.getPosition()));</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // move enemy to most dangerous hex
<b class="nc">&nbsp;            PilotingRollData psr = te.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            psr.addModifier(TargetRoll.AUTOMATIC_SUCCESS, &quot;break grapple&quot;);</b>
<b class="nc">&nbsp;            addReport(doEntityDisplacement(te, te.getPosition(), hexes[worst], psr));</b>
<b class="nc">&nbsp;            te.setFacing(hexes[worst].direction(ae.getPosition()));</b>
&nbsp;        }
&nbsp;
&nbsp;        // grapple is broken
<b class="nc">&nbsp;        ae.setGrappled(Entity.NONE, false);</b>
<b class="nc">&nbsp;        te.setGrappled(Entity.NONE, false);</b>
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a charge attack
&nbsp;     */
&nbsp;    private void resolveChargeAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final ChargeAttackAction caa = (ChargeAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(caa.getEntityId());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());</b>
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
&nbsp;
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if ((target != null) &amp;&amp; (target.getTargetType() == Targetable.TYPE_ENTITY)) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(caa.getTargetPos());</b>
&nbsp;
&nbsp;        // is the attacker dead? because that sure messes up the calculations
<b class="nc">&nbsp;        if (ae == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int direction = ae.getFacing();</b>
&nbsp;
&nbsp;        // entity isn&#39;t charging any more
<b class="nc">&nbsp;        ae.setDisplacementAttack(null);</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != caa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // should we even bother?
<b class="nc">&nbsp;        if ((target == null) || ((target.getTargetType() == Targetable.TYPE_ENTITY)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.getCrew().isDead()))) {</b>
<b class="nc">&nbsp;            r = new Report(4190);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(),
&nbsp;            // null);
&nbsp;            // Randall said that if a charge fails because of target
&nbsp;            // destruction,
&nbsp;            // the attacker stays in the hex he was in at the end of the
&nbsp;            // movement phase
&nbsp;            // See Bug 912094
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // attacker fell down?
<b class="nc">&nbsp;        if (ae.isProne()) {</b>
<b class="nc">&nbsp;            r = new Report(4195);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // attacker immobile?
<b class="nc">&nbsp;        if (ae.isImmobile()) {</b>
<b class="nc">&nbsp;            r = new Report(4200);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // target fell down, only for attacking Mechs, though
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; (te.isProne()) &amp;&amp; (ae instanceof Mech)) {</b>
<b class="nc">&nbsp;            r = new Report(4205);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4210);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // target still in the same position?
<b class="nc">&nbsp;        if (!target.getPosition().equals(caa.getTargetPos())) {</b>
<b class="nc">&nbsp;            r = new Report(4215);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            addReport(doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(), null));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if the attacker&#39;s prone, fudge the roll
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            roll = -12;</b>
<b class="nc">&nbsp;            r = new Report(4220);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            r = new Report(4225);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
<b class="nc">&nbsp;            Coords src = ae.getPosition();</b>
<b class="nc">&nbsp;            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);</b>
&nbsp;
&nbsp;            // TODO : handle movement into/out of/through a building. Do it here?
&nbsp;
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // move attacker to side hex
<b class="nc">&nbsp;            addReport(doEntityDisplacement(ae, src, dest, null));</b>
<b class="nc">&nbsp;        } else if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;                   || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) { // Targeting</b>
&nbsp;            // a building.
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
&nbsp;            // Apply damage to the attacker.
<b class="nc">&nbsp;            int toAttacker = ChargeAttackAction.getDamageTakenBy(ae, bldg, target.getPosition());</b>
<b class="nc">&nbsp;            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, ae.sideTable(target.getPosition()));</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, toAttacker, false, DamageType.NONE,</b>
&nbsp;                                   false, false, throughFront));
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            entityUpdate(ae.getId());</b>
&nbsp;
&nbsp;            // TODO : Does the attacker enter the building?
&nbsp;            // TODO : What if the building collapses?
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Resolve the damage.
<b class="nc">&nbsp;            resolveChargeDamage(ae, te, toHit, direction, glancing, throughFront, false);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle an Airmech ram attack
&nbsp;     */
&nbsp;    private void resolveAirmechRamAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final AirmechRamAttackAction caa = (AirmechRamAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(caa.getEntityId());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());</b>
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
&nbsp;
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if ((target != null) &amp;&amp; (target.getTargetType() == Targetable.TYPE_ENTITY)) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(caa.getTargetPos());</b>
&nbsp;
&nbsp;        // is the attacker dead? because that sure messes up the calculations
<b class="nc">&nbsp;        if (ae == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int direction = ae.getFacing();</b>
&nbsp;
&nbsp;        // entity isn&#39;t charging any more
<b class="nc">&nbsp;        ae.setDisplacementAttack(null);</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != caa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // should we even bother?
<b class="nc">&nbsp;        if ((target == null) || ((target.getTargetType() == Targetable.TYPE_ENTITY)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.getCrew().isDead()))) {</b>
<b class="nc">&nbsp;            r = new Report(4192);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            game.addControlRoll(new PilotingRollData(</b>
<b class="nc">&nbsp;                    ae.getId(), 0, &quot;missed a ramming attack&quot;));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // attacker landed?
<b class="nc">&nbsp;        if (!ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            r = new Report(4197);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // attacker immobile?
<b class="nc">&nbsp;        if (ae.isImmobile()) {</b>
<b class="nc">&nbsp;            r = new Report(4202);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4212);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // if the attacker&#39;s prone, fudge the roll
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            roll = -12;</b>
<b class="nc">&nbsp;            r = new Report(4222);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            r = new Report(4227);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // attacker must make a control roll
<b class="nc">&nbsp;            game.addControlRoll(new PilotingRollData(ae.getId(), 0, &quot;missed ramming attack&quot;));</b>
<b class="nc">&nbsp;        } else if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;                   || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) { // Targeting</b>
&nbsp;            // a building.
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            r = new Report(4040);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
&nbsp;
&nbsp;            // Apply damage to the attacker.
<b class="nc">&nbsp;            int toAttacker = AirmechRamAttackAction.getDamageTakenBy(ae, target,</b>
&nbsp;                    ae.delta_distance);
<b class="nc">&nbsp;            HitData hit = new HitData(Mech.LOC_CT);</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, toAttacker, false, DamageType.NONE,</b>
&nbsp;                                   false, false, throughFront));
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            entityUpdate(ae.getId());</b>
&nbsp;
&nbsp;            // TODO : Does the attacker enter the building?
&nbsp;            // TODO : What if the building collapses?
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Resolve the damage.
<b class="nc">&nbsp;            resolveChargeDamage(ae, te, toHit, direction, glancing, throughFront, true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a telemissile attack
&nbsp;     */
&nbsp;    private void resolveTeleMissileAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final TeleMissileAttackAction taa = (TeleMissileAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(taa.getEntityId());</b>
<b class="nc">&nbsp;        if (!(ae instanceof TeleMissile)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        TeleMissile tm = (TeleMissile) ae;</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(taa.getTargetType(), taa.getTargetId());</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        int amsDamage = taa.CounterAVInt;</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if ((target != null) &amp;&amp; (target.getTargetType() == Targetable.TYPE_ENTITY)) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != taa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // should we even bother?
<b class="nc">&nbsp;        if ((target == null)</b>
<b class="nc">&nbsp;                || ((target.getTargetType() == Targetable.TYPE_ENTITY) &amp;&amp; (te.isDestroyed()</b>
<b class="nc">&nbsp;                || te.isDoomed() || te.getCrew().isDead()))) {</b>
<b class="nc">&nbsp;            r = new Report(4191);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(9031);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 1;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        //If point defenses engaged the missile, handle that damage
<b class="nc">&nbsp;        if (amsDamage &gt; 0) {</b>
&nbsp;            //Report the attack
<b class="nc">&nbsp;            r = new Report(3362);</b>
<b class="nc">&nbsp;            r.newlines = 1;</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;
&nbsp;            //If the target&#39;s point defenses overheated, report that
<b class="nc">&nbsp;            if (taa.getPDOverheated()) {</b>
<b class="nc">&nbsp;                r = new Report(3361);</b>
<b class="nc">&nbsp;                r.newlines = 1;</b>
<b class="nc">&nbsp;                r.subject = te.getId();</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            //Damage the missile
<b class="nc">&nbsp;            HitData hit = tm.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                    tm.sideTable(te.getPosition(), true));</b>
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, amsDamage, false,</b>
&nbsp;                    DamageType.NONE, false, false, false));
&nbsp;
&nbsp;            //If point defense fire destroys the missile, don&#39;t process a hit
<b class="nc">&nbsp;            if (ae.isDoomed()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // add some stuff to the to hit value
&nbsp;        // need to add damage done modifier
<b class="nc">&nbsp;        int damageTaken = (ae.getOArmor(TeleMissile.LOC_BODY) - ae.getArmor(TeleMissile.LOC_BODY));</b>
<b class="nc">&nbsp;        if (damageTaken &gt; 10) {</b>
<b class="nc">&nbsp;            toHit.addModifier((int) (Math.floor(damageTaken / 10.0)), &quot;damage taken&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // add modifiers for the originating unit missing CIC, FCS, or sensors
<b class="nc">&nbsp;        Entity ride = game.getEntity(tm.getOriginalRideId());</b>
<b class="nc">&nbsp;        if (ride instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero aride = (Aero) ride;</b>
<b class="nc">&nbsp;            int cic = aride.getCICHits();</b>
<b class="nc">&nbsp;            if (cic &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(cic * 2, &quot;CIC damage&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // sensor hits
<b class="nc">&nbsp;            int sensors = aride.getSensorHits();</b>
<b class="nc">&nbsp;            if ((sensors &gt; 0) &amp;&amp; (sensors &lt; 3)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(sensors, &quot;sensor damage&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (sensors &gt; 2) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+5, &quot;sensors destroyed&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // FCS hits
<b class="nc">&nbsp;            int fcs = aride.getFCSHits();</b>
<b class="nc">&nbsp;            if (fcs &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(fcs * 2, &quot;fcs damage&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            r = new Report(4226);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(9033);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
&nbsp;            // Resolve the damage.
<b class="nc">&nbsp;            HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                    te.sideTable(ae.getPosition(), true));</b>
<b class="nc">&nbsp;            hit.setCapital(true);</b>
<b class="nc">&nbsp;            hit.setCapMisCritMod(tm.getCritMod());</b>
<b class="nc">&nbsp;            addReport(damageEntity(te, hit,</b>
<b class="nc">&nbsp;                    TeleMissileAttackAction.getDamageFor(ae), false,</b>
&nbsp;                    DamageType.NONE, false, false, throughFront));
<b class="nc">&nbsp;            destroyEntity(ae, &quot;successful attack&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a ramming attack
&nbsp;     */
&nbsp;    private void resolveRamAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final RamAttackAction raa = (RamAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(raa.getEntityId());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(raa.getTargetType(), raa.getTargetId());</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if ((target != null) &amp;&amp; (target.getTargetType() == Targetable.TYPE_ENTITY)) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        boolean glancing = Compute.d6(1) == 6;</b>
&nbsp;
&nbsp;        // entity isn&#39;t ramming any more
<b class="nc">&nbsp;        ae.setRamming(false);</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != raa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // should we even bother?
<b class="nc">&nbsp;        if ((target == null)</b>
<b class="nc">&nbsp;                || ((target.getTargetType() == Targetable.TYPE_ENTITY) &amp;&amp; (te.isDestroyed()</b>
<b class="nc">&nbsp;                || te.isDoomed() || te.getCrew().isDead()))) {</b>
<b class="nc">&nbsp;            r = new Report(4190);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // steel yourself for attack
<b class="nc">&nbsp;        int steelRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9020);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(steelRoll);</b>
&nbsp;
<b class="nc">&nbsp;        if (steelRoll &gt;= 11) {</b>
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // attacker immobile?
<b class="nc">&nbsp;        if (ae.isImmobile()) {</b>
<b class="nc">&nbsp;            r = new Report(4200);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(9030);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            r = new Report(4225);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        } else {
&nbsp;            // Resolve the damage.
<b class="nc">&nbsp;            resolveRamDamage((IAero) ae, te, toHit, glancing, throughFront);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a ramming attack&#39;s damage
&nbsp;     */
&nbsp;    private void resolveRamDamage(IAero aero, Entity te, ToHitData toHit,
&nbsp;                                  boolean glancing, boolean throughFront) {
&nbsp;
<b class="nc">&nbsp;        Entity ae = (Entity) aero;</b>
&nbsp;
<b class="nc">&nbsp;        int damage = RamAttackAction.getDamageFor(aero, te);</b>
<b class="nc">&nbsp;        int damageTaken = RamAttackAction.getDamageTakenBy(aero, te);</b>
<b class="nc">&nbsp;        if (glancing) {</b>
&nbsp;            // Round up glancing blows against conventional infantry
<b class="nc">&nbsp;            if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;            }
<b class="nc">&nbsp;            damageTaken = (int) Math.floor(damageTaken / 2.0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // are they capital scale?
<b class="nc">&nbsp;        if (te.isCapitalScale()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            damage = (int) Math.floor(damage / 10.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (ae.isCapitalScale()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            damageTaken = (int) Math.floor(damageTaken / 10.0);</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (glancing) {</b>
<b class="nc">&nbsp;            r = new Report(9015);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // damage to attacker
<b class="nc">&nbsp;        r = new Report(4240);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(damageTaken);</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                ae.sideTable(te.getPosition(), true));</b>
&nbsp;        // if the damage is greater than the initial armor then destroy the
&nbsp;        // entity
<b class="nc">&nbsp;        if ((2 * ae.getOArmor(hit)) &lt; damageTaken) {</b>
<b class="nc">&nbsp;            addReport(destroyEntity(ae, &quot;by massive ramming damage&quot;, false));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, damageTaken, false,</b>
&nbsp;                    DamageType.NONE, false, false, throughFront));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4230);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(damage);</b>
<b class="nc">&nbsp;        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;        if ((2 * te.getOArmor(hit)) &lt; damage) {</b>
<b class="nc">&nbsp;            addReport(destroyEntity(te, &quot;by massive ramming damage&quot;, false));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            addReport(damageEntity(te, hit, damage, false, DamageType.NONE,</b>
&nbsp;                    false, false, throughFront));
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a charge&#39;s damage
&nbsp;     */
&nbsp;    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction) {
<b class="nc">&nbsp;        resolveChargeDamage(ae, te, toHit, direction, false, true, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction,
&nbsp;                                     boolean glancing, boolean throughFront, boolean airmechRam) {
&nbsp;
&nbsp;        // we hit...
&nbsp;
<b class="nc">&nbsp;        PilotingRollData chargePSR = null;</b>
&nbsp;        // If we&#39;re upright, we may fall down.
<b class="nc">&nbsp;        if (!ae.isProne() &amp;&amp; !airmechRam) {</b>
<b class="nc">&nbsp;            chargePSR = new PilotingRollData(ae.getId(), 2, &quot;charging&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Damage To Target
&nbsp;        int damage;
&nbsp;
&nbsp;        // Damage to Attacker
&nbsp;        int damageTaken;
&nbsp;
<b class="nc">&nbsp;        if (airmechRam) {</b>
<b class="nc">&nbsp;            damage = AirmechRamAttackAction.getDamageFor(ae);</b>
<b class="nc">&nbsp;            damageTaken = AirmechRamAttackAction.getDamageTakenBy(ae, te);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            damage = ChargeAttackAction.getDamageFor(ae, te, game.getOptions()</b>
<b class="nc">&nbsp;                    .booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE), toHit.getMoS());</b>
<b class="nc">&nbsp;            damageTaken = ChargeAttackAction.getDamageTakenBy(ae, te, game</b>
<b class="nc">&nbsp;                    .getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_RAM_PLATE)) {</b>
<b class="nc">&nbsp;            damage = (int) Math.ceil(damage * 1.5);</b>
<b class="nc">&nbsp;            damageTaken = (int) Math.floor(damageTaken * 0.5);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (glancing) {</b>
&nbsp;            // Glancing Blow rule doesn&#39;t state whether damage to attacker on charge
&nbsp;            // or DFA is halved as well, assume yes. TODO : Check with PM
<b class="nc">&nbsp;            if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;            }
<b class="nc">&nbsp;            damageTaken = (int) Math.floor(damageTaken / 2.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean bDirect = false;</b>
<b class="nc">&nbsp;        int directBlowCritMod = toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)</b>
<b class="nc">&nbsp;            &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1)) {</b>
<b class="nc">&nbsp;            damage += toHit.getMoS() / 3;</b>
<b class="nc">&nbsp;            bDirect = false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the target inside a building?
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
&nbsp;
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(te.getPosition());</b>
&nbsp;
&nbsp;        // The building shields all units from a certain amount of damage.
&nbsp;        // The amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;        int bldgAbsorbs = 0;</b>
<b class="nc">&nbsp;        if (targetInBuilding &amp;&amp; (bldg != null)) {</b>
<b class="nc">&nbsp;            bldgAbsorbs = bldg.getAbsorbtion(te.getPosition());</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // damage to attacker
<b class="nc">&nbsp;        r = new Report(4240);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(damageTaken);</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Charging vehicles check for possible motive system hits.
<b class="nc">&nbsp;        if (ae instanceof Tank) {</b>
<b class="nc">&nbsp;            r = new Report(4241);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            int side = Compute.targetSideTable(te, ae);</b>
<b class="nc">&nbsp;            int mod = ae.getMotiveSideMod(side);</b>
<b class="nc">&nbsp;            addReport(vehicleMotiveDamage((Tank)ae, mod));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (damageTaken &gt; 0) {</b>
&nbsp;            int cluster;
&nbsp;            HitData hit;
&nbsp;            // An airmech ramming attack does all damage to attacker&#39;s CT
<b class="nc">&nbsp;            if (airmechRam) {</b>
<b class="nc">&nbsp;                cluster = damageTaken;</b>
<b class="nc">&nbsp;                hit = new HitData(Mech.LOC_CT);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                cluster = Math.min(5, damageTaken);</b>
<b class="nc">&nbsp;                hit = ae.rollHitLocation(toHit.getHitTable(), ae.sideTable(te.getPosition()));</b>
&nbsp;            }
<b class="nc">&nbsp;            damageTaken -= cluster;</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            cluster = checkForSpikes(ae, hit.getLocation(), cluster, te, Mech.LOC_CT);</b>
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, cluster, false, DamageType.NONE,</b>
&nbsp;                    false, false, throughFront));
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Damage to target
<b class="nc">&nbsp;        if (ae instanceof Mech) {</b>
<b class="nc">&nbsp;            int spikeDamage = 0;</b>
<b class="nc">&nbsp;            for (int loc = 0; loc &lt; ae.locations(); loc++) {</b>
<b class="nc">&nbsp;                if (((Mech) ae).locationIsTorso(loc) &amp;&amp; ae.hasWorkingMisc(MiscType.F_SPIKES, -1, loc)) {</b>
<b class="nc">&nbsp;                    spikeDamage += 2;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (spikeDamage &gt; 0) {</b>
<b class="nc">&nbsp;                r = new Report(4335);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(spikeDamage);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            damage += spikeDamage;</b>
&nbsp;        }
<b class="nc">&nbsp;        r = new Report(4230);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(damage);</b>
<b class="nc">&nbsp;        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // Vehicles that have *been* charged check for motive system damage,
&nbsp;        // too...
&nbsp;        // ...though VTOLs don&#39;t use that table and should lose their rotor
&nbsp;        // instead,
&nbsp;        // which would be handled as part of the damage already.
<b class="nc">&nbsp;        if ((te instanceof Tank) &amp;&amp; !(te instanceof VTOL)) {</b>
<b class="nc">&nbsp;            r = new Report(4242);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            int side = Compute.targetSideTable(ae, te);</b>
<b class="nc">&nbsp;            int mod = te.getMotiveSideMod(side);</b>
<b class="nc">&nbsp;            addReport(vehicleMotiveDamage((Tank)te, mod));</b>
&nbsp;        }
&nbsp;
&nbsp;        // track any additional damage to the attacker due to the target having spikes
<b class="nc">&nbsp;        int spikeDamage = 0;</b>
<b class="nc">&nbsp;        while (damage &gt; 0) {</b>
<b class="nc">&nbsp;            int cluster = Math.min(5, damage);</b>
&nbsp;            // Airmech ramming attacks do all damage to a single location
<b class="nc">&nbsp;            if (airmechRam) {</b>
<b class="nc">&nbsp;                cluster = damage;</b>
&nbsp;            }
<b class="nc">&nbsp;            damage -= cluster;</b>
<b class="nc">&nbsp;            if (bldgAbsorbs &gt; 0) {</b>
<b class="nc">&nbsp;                int toBldg = Math.min(bldgAbsorbs, cluster);</b>
<b class="nc">&nbsp;                cluster -= toBldg;</b>
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage,</b>
<b class="nc">&nbsp;                                                               te.getPosition());</b>
<b class="nc">&nbsp;                for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                    report.subject = ae.getId();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                addReport(buildingReport);</b>
&nbsp;
&nbsp;                // some buildings scale remaining damage that is not absorbed
&nbsp;                // TODO : this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;                damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
&nbsp;            }
&nbsp;
&nbsp;            // A building may absorb the entire shot.
<b class="nc">&nbsp;            if (cluster == 0) {</b>
<b class="nc">&nbsp;                r = new Report(4235);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                if (bDirect) {</b>
<b class="nc">&nbsp;                    hit.makeDirectBlow(directBlowCritMod);</b>
&nbsp;                }
<b class="nc">&nbsp;                cluster = checkForSpikes(te, hit.getLocation(), cluster, ae, Mech.LOC_CT);</b>
<b class="nc">&nbsp;                addReport(damageEntity(te, hit, cluster, false,</b>
&nbsp;                                       DamageType.NONE, false, false, throughFront));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (airmechRam) {</b>
<b class="nc">&nbsp;            if (!ae.isDoomed()) {</b>
<b class="nc">&nbsp;                PilotingRollData controlRoll = ae.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                r = new Report(9320);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.addDesc(ae);</b>
<b class="nc">&nbsp;                r.add(&quot;successful ramming attack&quot;);</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                int diceRoll = Compute.d6(2);</b>
&nbsp;                // different reports depending on out-of-control status
<b class="nc">&nbsp;                r = new Report(9606);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(controlRoll.getValueAsString());</b>
<b class="nc">&nbsp;                r.add(controlRoll.getDesc());</b>
<b class="nc">&nbsp;                r.add(diceRoll);</b>
<b class="nc">&nbsp;                r.newlines = 1;</b>
<b class="nc">&nbsp;                if (diceRoll &lt; controlRoll.getValue()) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    crashAirMech(ae, controlRoll, reports);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
<b class="nc">&nbsp;                    if (ae instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                        reports.addAll(landAirMech((LandAirMech)ae, ae.getPosition(), 1, ae.delta_distance));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                addReport(reports);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
&nbsp;            // move attacker and target, if possible
<b class="nc">&nbsp;            Coords src = te.getPosition();</b>
<b class="nc">&nbsp;            Coords dest = src.translated(direction);</b>
&nbsp;
<b class="nc">&nbsp;            if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(),</b>
&nbsp;                                            direction)) {
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                addReport(doEntityDisplacement(te, src, dest, new PilotingRollData(</b>
<b class="nc">&nbsp;                        te.getId(), 2, &quot;was charged&quot;)));</b>
<b class="nc">&nbsp;                addReport(doEntityDisplacement(ae, ae.getPosition(), src, chargePSR));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            addNewLines();</b>
&nbsp;        }
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((te instanceof Mech) &amp;&amp; ((Mech) te).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) te).setCheckForCrit(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    } // End private void resolveChargeDamage( Entity, Entity, ToHitData )</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether the location has spikes, and if so handles the damage to the
&nbsp;     * attack and returns the reduced damage. Locations without spikes return the
&nbsp;     * original damage amount.
&nbsp;     *
&nbsp;     * @param target            The target of a physical attack
&nbsp;     * @param targetLocation    The location that was hit
&nbsp;     * @param damage            The amount of damage dealt to the target
&nbsp;     * @param attacker          The attacker
&nbsp;     * @param attackerLocation  The location on the attacker that is damaged if the
&nbsp;     *                          target has spikes. Entity.LOC_NONE if the attacker
&nbsp;     *                          can&#39;t be damaged by spikes in this attack.
&nbsp;     * @return          The damage after applying any reduction due to spikes
&nbsp;     */
&nbsp;    private int checkForSpikes(Entity target, int targetLocation, int damage,
&nbsp;                               Entity attacker, int attackerLocation) {
<b class="nc">&nbsp;        return checkForSpikes(target, targetLocation, damage, attacker, attackerLocation, Entity.LOC_NONE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether the location has spikes, and if so handles the damage to the
&nbsp;     * attack and returns the reduced damage. Locations without spikes return the
&nbsp;     * original damage amount.
&nbsp;     *
&nbsp;     * @param target            The target of a physical attack
&nbsp;     * @param targetLocation    The location that was hit
&nbsp;     * @param damage            The amount of damage dealt to the target
&nbsp;     * @param attacker          The attacker
&nbsp;     * @param attackerLocation  The location on the attacker that is damaged if the
&nbsp;     *                          target has spikes. Entity.LOC_NONE if the attacker
&nbsp;     *                          can&#39;t be damaged by spikes in this attack.
&nbsp;     * @param attackerLocation2 If not Entity.LOC_NONE, the damage to the attacker
&nbsp;     *                          will be split between two locations.
&nbsp;     * @return          The damage after applying any reduction due to spikes
&nbsp;     */
&nbsp;    private int checkForSpikes(Entity target, int targetLocation, int damage,
&nbsp;                               Entity attacker, int attackerLocation, int attackerLocation2) {
<b class="nc">&nbsp;        if (target.hasWorkingMisc(MiscType.F_SPIKES, -1, targetLocation)) {</b>
&nbsp;            Report r;
<b class="nc">&nbsp;            if (damage == 0) {</b>
&nbsp;                // Only show damage to attacker (push attack)
<b class="nc">&nbsp;                r = new Report(4333);</b>
<b class="nc">&nbsp;            } else if (attackerLocation != Entity.LOC_NONE) {</b>
&nbsp;                // Show damage reduction and damage to attacker
<b class="nc">&nbsp;                r = new Report(4330);</b>
&nbsp;            } else {
&nbsp;                // Only show damage reduction (club/physical weapon attack)
<b class="nc">&nbsp;                r = new Report(4331);</b>
&nbsp;            }
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.subject = target.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // An attack that deals zero damage can still damage the attacker in the case of a push
<b class="nc">&nbsp;            if (attackerLocation != Entity.LOC_NONE) {</b>
&nbsp;                // Spikes also protect from retaliatory spike damage
<b class="nc">&nbsp;                if (attacker.hasWorkingMisc(MiscType.F_SPIKES, -1, attackerLocation)) {</b>
<b class="nc">&nbsp;                    r = new Report(4332);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = attacker.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else if (attackerLocation2 == Entity.LOC_NONE) {</b>
<b class="nc">&nbsp;                    addReport(damageEntity(attacker, new HitData(attackerLocation), 2, false,</b>
&nbsp;                            DamageType.NONE,false, false, false));
&nbsp;                } else {
<b class="nc">&nbsp;                    addReport(damageEntity(attacker, new HitData(attackerLocation), 1, false,</b>
&nbsp;                            DamageType.NONE, false, false, false));
<b class="nc">&nbsp;                    addReport(damageEntity(attacker, new HitData(attackerLocation2), 1, false,</b>
&nbsp;                            DamageType.NONE, false, false, false));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return Math.max(1, damage - 4);</b>
&nbsp;        }
<b class="nc">&nbsp;        return damage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * End-phase checks for laid explosives; check whether explosives are
&nbsp;     * touched off, or if we should report laying explosives
&nbsp;     */
&nbsp;    private void checkLayExplosives() {
&nbsp;        // Report continuing explosive work
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (!(e instanceof Infantry)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Infantry inf = (Infantry) e;</b>
<b class="nc">&nbsp;            if (inf.turnsLayingExplosives &gt; 0) {</b>
<b class="nc">&nbsp;                Report r = new Report(4271);</b>
<b class="nc">&nbsp;                r.subject = inf.getId();</b>
<b class="nc">&nbsp;                r.addDesc(inf);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Check for touched-off explosives
<b class="nc">&nbsp;        Vector&lt;Building&gt; updatedBuildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (DemolitionCharge charge : explodingCharges) {</b>
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(charge.pos);</b>
<b class="nc">&nbsp;            if (bldg == null) { // Shouldn&#39;t happen...</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            bldg.removeDemolitionCharge(charge);</b>
<b class="nc">&nbsp;            updatedBuildings.add(bldg);</b>
<b class="nc">&nbsp;            Report r = new Report(4272, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.add(bldg.getName());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; dmgReports = damageBuilding(bldg, charge.damage,</b>
&nbsp;                    &quot; explodes for &quot;, charge.pos);
<b class="nc">&nbsp;            for (Report rep : dmgReports) {</b>
<b class="nc">&nbsp;                rep.indent();</b>
<b class="nc">&nbsp;                addReport(rep);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        explodingCharges.clear();</b>
<b class="nc">&nbsp;        sendChangedBuildings(updatedBuildings);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void resolveLayExplosivesAttack(PhysicalResult pr) {
<b class="nc">&nbsp;        final LayExplosivesAttackAction laa = (LayExplosivesAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(laa.getEntityId());</b>
<b class="nc">&nbsp;        if (ae instanceof Infantry) {</b>
<b class="nc">&nbsp;            Infantry inf = (Infantry) ae;</b>
<b class="nc">&nbsp;            if (inf.turnsLayingExplosives &lt; 0) {</b>
<b class="nc">&nbsp;                inf.turnsLayingExplosives = 0;</b>
<b class="nc">&nbsp;                Report r = new Report(4270);</b>
<b class="nc">&nbsp;                r.subject = inf.getId();</b>
<b class="nc">&nbsp;                r.addDesc(inf);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                Building building = game.getBoard().getBuildingAt(ae.getPosition());</b>
<b class="nc">&nbsp;                if (building != null) {</b>
<b class="nc">&nbsp;                    building.addDemolitionCharge(ae.getOwner().getId(), pr.damage, ae.getPosition());</b>
<b class="nc">&nbsp;                    Report r = new Report(4275);</b>
<b class="nc">&nbsp;                    r.subject = inf.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(inf);</b>
<b class="nc">&nbsp;                    r.add(pr.damage);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // Update clients with this info
<b class="nc">&nbsp;                    Vector&lt;Building&gt; updatedBuildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                    updatedBuildings.add(building);</b>
<b class="nc">&nbsp;                    sendChangedBuildings(updatedBuildings);</b>
&nbsp;                }
<b class="nc">&nbsp;                inf.turnsLayingExplosives = -1;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle a death from above attack
&nbsp;     */
&nbsp;    private void resolveDfaAttack(PhysicalResult pr, int lastEntityId) {
<b class="nc">&nbsp;        final DfaAttackAction daa = (DfaAttackAction) pr.aaa;</b>
<b class="nc">&nbsp;        final Entity ae = game.getEntity(daa.getEntityId());</b>
&nbsp;
&nbsp;        // is the attacker dead? because that sure messes up the calculations
<b class="nc">&nbsp;        if (ae == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final IHex aeHex = game.getBoard().getHex(ae.getPosition());</b>
<b class="nc">&nbsp;        final IHex teHex = game.getBoard().getHex(daa.getTargetPos());</b>
<b class="nc">&nbsp;        final Targetable target = game.getTarget(daa.getTargetType(), daa.getTargetId());</b>
&nbsp;        // get damage, ToHitData and roll from the PhysicalResult
<b class="nc">&nbsp;        int damage = pr.damage;</b>
<b class="nc">&nbsp;        final ToHitData toHit = pr.toHit;</b>
<b class="nc">&nbsp;        int roll = pr.roll;</b>
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if ((target != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (target.getTargetType() == Targetable.TYPE_ENTITY)) {</b>
&nbsp;            // Lets re-write around that horrible hack that was here before.
&nbsp;            // So instead of asking if a specific location is wet and praying
&nbsp;            // that it won&#39;t cause an NPE...
&nbsp;            // We&#39;ll check 1) if the hex has water, and 2) if it&#39;s deep enough
&nbsp;            // to cover the unit in question at its current elevation.
&nbsp;            // It&#39;s especially important to make sure it&#39;s done this way,
&nbsp;            // because some units (Sylph, submarines) can be at ANY elevation
&nbsp;            // underwater, and VTOLs can be well above the surface.
<b class="nc">&nbsp;            te = (Entity) target;</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(te.getPosition());</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                if (te.relHeight() &lt; 0) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage * 0.5f);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        boolean throughFront = true;</b>
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(), te);</b>
&nbsp;        }
<b class="nc">&nbsp;        final boolean glancing = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS) &amp;&amp; (roll == toHit.getValue());</b>
&nbsp;        // Set Margin of Success/Failure.
<b class="nc">&nbsp;        toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;        final boolean directBlow = game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW) &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1);</b>
&nbsp;
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        final int direction = ae.getFacing();</b>
&nbsp;
<b class="nc">&nbsp;        if (lastEntityId != daa.getEntityId()) {</b>
&nbsp;            // who is making the attack
<b class="nc">&nbsp;            r = new Report(4005);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.addDesc(ae);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // should we even bother?
<b class="nc">&nbsp;        if ((target == null) || ((target.getTargetType() == Targetable.TYPE_ENTITY)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.getCrew().isDead()))) {</b>
<b class="nc">&nbsp;            r = new Report(4245);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // entity isn&#39;t DFAing any more
<b class="nc">&nbsp;            ae.setDisplacementAttack(null);</b>
<b class="nc">&nbsp;            if (ae.isProne()) {</b>
&nbsp;                // attacker prone during weapons phase
<b class="nc">&nbsp;                addReport(doEntityFall(ae, daa.getTargetPos(), 2, 3,</b>
<b class="nc">&nbsp;                        ae.getBasePilotingRoll(), false, false));</b>
&nbsp;
&nbsp;            } else {
&nbsp;                // same effect as successful DFA
<b class="nc">&nbsp;                ae.setElevation(ae.calcElevation(aeHex, teHex, 0, false, false));</b>
<b class="nc">&nbsp;                addReport(doEntityDisplacement(ae, ae.getPosition(),</b>
<b class="nc">&nbsp;                        daa.getTargetPos(), new PilotingRollData(ae.getId(), 4,</b>
&nbsp;                                &quot;executed death from above&quot;)));
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(4246);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(target.getDisplayName());</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // target still in the same position?
<b class="nc">&nbsp;        if (!target.getPosition().equals(daa.getTargetPos())) {</b>
<b class="nc">&nbsp;            r = new Report(4215);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // entity isn&#39;t DFAing any more
<b class="nc">&nbsp;            ae.setDisplacementAttack(null);</b>
<b class="nc">&nbsp;            addReport(doEntityFallsInto(ae, ae.getElevation(), ae.getPosition(), daa.getTargetPos(),</b>
<b class="nc">&nbsp;                    ae.getBasePilotingRoll(), true));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // hack: if the attacker&#39;s prone, or incapacitated, fudge the roll
<b class="nc">&nbsp;        if (ae.isProne() || !ae.isActive()) {</b>
<b class="nc">&nbsp;            roll = -12;</b>
<b class="nc">&nbsp;            r = new Report(4250);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            r.newlines--;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            roll = -12;</b>
<b class="nc">&nbsp;            r = new Report(4255);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;            r = new Report(4260);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            roll = Integer.MAX_VALUE;</b>
&nbsp;        } else {
&nbsp;            // report the roll
<b class="nc">&nbsp;            r = new Report(4025);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(toHit.getValue());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                r = new Report(3186);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                r = new Report(3189);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // do we hit?
<b class="nc">&nbsp;        if (roll &lt; toHit.getValue()) {</b>
<b class="nc">&nbsp;            Coords dest = te.getPosition();</b>
<b class="nc">&nbsp;            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);</b>
&nbsp;            // miss
<b class="nc">&nbsp;            r = new Report(4035);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (targetDest != null) {</b>
&nbsp;                // move target to preferred hex
<b class="nc">&nbsp;                addReport(doEntityDisplacement(te, dest, targetDest, null));</b>
&nbsp;                // attacker falls into destination hex
<b class="nc">&nbsp;                r = new Report(4265);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.addDesc(ae);</b>
<b class="nc">&nbsp;                r.add(dest.getBoardNum(), true);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // entity isn&#39;t DFAing any more
<b class="nc">&nbsp;                ae.setDisplacementAttack(null);</b>
<b class="nc">&nbsp;                addReport(doEntityFall(ae, dest, 2, 3, ae.getBasePilotingRoll(),</b>
&nbsp;                        false, false), 1);
<b class="nc">&nbsp;                Entity violation = Compute.stackingViolation(game, ae.getId(), dest);</b>
<b class="nc">&nbsp;                if (violation != null) {</b>
&nbsp;                    // target gets displaced
<b class="nc">&nbsp;                    targetDest = Compute.getValidDisplacement(game,</b>
<b class="nc">&nbsp;                            violation.getId(), dest, direction);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityDisplacement(violation, dest,</b>
<b class="nc">&nbsp;                            targetDest, new PilotingRollData(violation.getId(),</b>
&nbsp;                                    0, &quot;domino effect&quot;)));
&nbsp;                    // Update the violating entity&#39;s position on the client.
<b class="nc">&nbsp;                    if (!game.getOutOfGameEntitiesVector().contains(violation)) {</b>
<b class="nc">&nbsp;                        entityUpdate(violation.getId());</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
&nbsp;                // attacker destroyed
&nbsp;                // Tanks suffer an ammo/power plant hit.
&nbsp;                // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                addReport(destroyEntity(ae, &quot;impossible displacement&quot;,</b>
&nbsp;                        ae instanceof Mech, ae instanceof Mech));
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we hit...
&nbsp;
<b class="nc">&nbsp;        r = new Report(4040);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;        Coords dest = target.getPosition();</b>
&nbsp;
&nbsp;        // Can&#39;t DFA a target inside of a building.
<b class="nc">&nbsp;        int damageTaken = DfaAttackAction.getDamageTakenBy(ae);</b>
&nbsp;
&nbsp;        // Targeting a building.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
&nbsp;
&nbsp;            // Which building takes the damage?
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(daa.getTargetPos());</b>
&nbsp;            
&nbsp;            // The building takes the full brunt of the attack.
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damage, target.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = ae.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(buildingReport);</b>
&nbsp;
&nbsp;            // Damage any infantry in the hex.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, damage, target.getPosition()));</b>
<b class="nc">&nbsp;        } else { // Target isn&#39;t building.</b>
&nbsp;
<b class="nc">&nbsp;            if (glancing) {</b>
<b class="nc">&nbsp;                if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage / 2.0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    damage = (int) Math.floor(damage / 2.0);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (directBlow) {</b>
<b class="nc">&nbsp;                damage += toHit.getMoS() / 3;</b>
&nbsp;            }
&nbsp;            // damage target
<b class="nc">&nbsp;            r = new Report(4230);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());</b>
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                if (directBlow) {</b>
<b class="nc">&nbsp;                    hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;                }
<b class="nc">&nbsp;                damage -= cluster;</b>
<b class="nc">&nbsp;                cluster = checkForSpikes(te, hit.getLocation(), cluster, ae, Mech.LOC_LLEG, Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                addReport(damageEntity(te, hit, cluster, false,</b>
&nbsp;                                       DamageType.NONE, false, false, throughFront));
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (target instanceof VTOL) {</b>
&nbsp;                // destroy rotor
<b class="nc">&nbsp;                addReport(applyCriticalHit(te, VTOL.LOC_ROTOR,</b>
&nbsp;                        new CriticalSlot(CriticalSlot.TYPE_SYSTEM,
&nbsp;                                VTOL.CRIT_ROTOR_DESTROYED), false, 0, false));
&nbsp;            }
&nbsp;            // Target entities are pushed away or destroyed.
<b class="nc">&nbsp;            Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);</b>
<b class="nc">&nbsp;            if (targetDest != null) {</b>
<b class="nc">&nbsp;                addReport(doEntityDisplacement(te, dest, targetDest,</b>
<b class="nc">&nbsp;                        new PilotingRollData(te.getId(), 2, &quot;hit by death from above&quot;)));</b>
&nbsp;            } else {
&nbsp;                // ack! automatic death! Tanks
&nbsp;                // suffer an ammo/power plant hit.
&nbsp;                // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                addReport(destroyEntity(te, &quot;impossible displacement&quot;,</b>
&nbsp;                        te instanceof Mech, te instanceof Mech));
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (glancing) {</b>
&nbsp;            // Glancing Blow rule doesn&#39;t state whether damage to attacker on charge
&nbsp;            // or DFA is halved as well, assume yes. TODO : Check with PM
<b class="nc">&nbsp;            damageTaken = (int) Math.floor(damageTaken / 2.0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ae.hasQuirk(OptionsConstants.QUIRK_POS_REINFORCED_LEGS)) {</b>
<b class="nc">&nbsp;            damageTaken = (int) Math.floor(damageTaken / 2.0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // damage attacker
<b class="nc">&nbsp;        r = new Report(4240);</b>
<b class="nc">&nbsp;        r.subject = ae.getId();</b>
<b class="nc">&nbsp;        r.add(damageTaken);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        while (damageTaken &gt; 0) {</b>
<b class="nc">&nbsp;            int cluster = Math.min(5, damageTaken);</b>
<b class="nc">&nbsp;            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;            hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;            addReport(damageEntity(ae, hit, cluster));</b>
<b class="nc">&nbsp;            damageTaken -= cluster;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (ae.hasQuirk(OptionsConstants.QUIRK_NEG_WEAK_LEGS)) {</b>
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            addReport(criticalEntity(ae, Mech.LOC_LLEG, false, 0, 0));</b>
<b class="nc">&nbsp;            addNewLines();</b>
<b class="nc">&nbsp;            addReport(criticalEntity(ae, Mech.LOC_RLEG, false, 0, 0));</b>
<b class="nc">&nbsp;            if (ae instanceof QuadMech) {</b>
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                addReport(criticalEntity(ae, Mech.LOC_LARM, false, 0, 0));</b>
<b class="nc">&nbsp;                addNewLines();</b>
<b class="nc">&nbsp;                addReport(criticalEntity(ae, Mech.LOC_RARM, false, 0, 0));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewLines();</b>
&nbsp;
&nbsp;        // That&#39;s it for target buildings.
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_BUILDING)</b>
<b class="nc">&nbsp;            || (target.getTargetType() == Targetable.TYPE_FUEL_TANK)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        ae.setElevation(ae.calcElevation(aeHex, teHex, 0, false, false));</b>
&nbsp;        // HACK: to avoid automatic falls, displace from dest to dest
<b class="nc">&nbsp;        addReport(doEntityDisplacement(ae, dest, dest, new PilotingRollData(</b>
<b class="nc">&nbsp;                ae.getId(), 4, &quot;executed death from above&quot;)));</b>
&nbsp;
&nbsp;        // entity isn&#39;t DFAing any more
<b class="nc">&nbsp;        ae.setDisplacementAttack(null);</b>
&nbsp;
&nbsp;        // if the target is an industrial mech, it needs to check for crits
&nbsp;        // at the end of turn
<b class="nc">&nbsp;        if ((target instanceof Mech) &amp;&amp; ((Mech) target).isIndustrial()) {</b>
<b class="nc">&nbsp;            ((Mech) target).setCheckForCrit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the Kick or Push PSR, modified by weight class
&nbsp;     *
&nbsp;     * @param psrEntity The &lt;code&gt;Entity&lt;/code&gt; that should make a PSR
&nbsp;     * @param attacker  The attacking &lt;code&gt;Entity&gt;&lt;/code&gt;
&nbsp;     * @param target    The target &lt;code&gt;Entity&lt;/code&gt;
&nbsp;     * @return The &lt;code&gt;PilotingRollData&lt;/code&gt;
&nbsp;     */
&nbsp;    private PilotingRollData getKickPushPSR(Entity psrEntity, Entity attacker,
&nbsp;                                            Entity target, String reason) {
<b class="nc">&nbsp;        int mod = 0;</b>
<b class="nc">&nbsp;        PilotingRollData psr = new PilotingRollData(psrEntity.getId(), mod,</b>
&nbsp;                                                    reason);
<b class="nc">&nbsp;        if (psrEntity.hasQuirk(OptionsConstants.QUIRK_POS_STABLE)) {</b>
<b class="nc">&nbsp;            psr.addModifier(-1, &quot;stable&quot;, false);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_PHYSICAL_PSR)) {</b>
&nbsp;
<b class="nc">&nbsp;            switch (target.getWeightClass()) {</b>
&nbsp;                case EntityWeightClass.WEIGHT_LIGHT:
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case EntityWeightClass.WEIGHT_MEDIUM:
<b class="nc">&nbsp;                    mod = 0;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case EntityWeightClass.WEIGHT_HEAVY:
<b class="nc">&nbsp;                    mod = -1;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case EntityWeightClass.WEIGHT_ASSAULT:
<b class="nc">&nbsp;                    mod = -2;</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;            String reportStr;
<b class="nc">&nbsp;            if (mod &gt; 0) {</b>
<b class="nc">&nbsp;                reportStr = (&quot;weight class modifier +&quot;) + mod;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                reportStr = (&quot;weight class modifier &quot;) + mod;</b>
&nbsp;            }
<b class="nc">&nbsp;            psr.addModifier(mod, reportStr, false);</b>
&nbsp;        }
<b class="nc">&nbsp;        return psr;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Each mech sinks the amount of heat appropriate to its current heat
&nbsp;     * capacity.
&nbsp;     */
&nbsp;    private void resolveHeat() {
&nbsp;        Report r;
&nbsp;        // Heat phase header
<b class="nc">&nbsp;        addReport(new Report(5000, Report.PUBLIC));</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) &amp;&amp; !entity.isAero()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            IHex entityHex = game.getBoard().getHex(entity.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;            int hotDogMod = 0;</b>
<b class="nc">&nbsp;            if (entity.hasAbility(OptionsConstants.PILOT_HOT_DOG)) {</b>
<b class="nc">&nbsp;                hotDogMod = 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.getTaserInterferenceHeat()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.hasDamagedRHS() &amp;&amp; entity.weaponFired()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity instanceof Mech) &amp;&amp; ((Mech)entity).hasDamagedCoolantSystem() &amp;&amp; entity.weaponFired()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 1;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int radicalHSBonus = 0;</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; rhsReports = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            if (entity.hasActivatedRadicalHS()) {</b>
<b class="nc">&nbsp;                if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                    radicalHSBonus = ((Mech) entity).getActiveSinks();</b>
<b class="nc">&nbsp;                } else if (entity instanceof Aero) {</b>
<b class="nc">&nbsp;                    radicalHSBonus = ((Aero) entity).getHeatSinks();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Radical heat sinks mounted on non-mech, non-aero Entity!&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                int rhsRoll = Compute.d6(2);</b>
&nbsp;                int targetNumber;
<b class="nc">&nbsp;                switch (entity.getConsecutiveRHSUses()) {</b>
&nbsp;                    case 0:
<b class="nc">&nbsp;                        targetNumber = 2;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        targetNumber = 3;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        targetNumber = 5;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        targetNumber = 7;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        targetNumber = 10;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        targetNumber = 11;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 6:
&nbsp;                    default:
<b class="nc">&nbsp;                        targetNumber = TargetRoll.AUTOMATIC_FAIL;</b>
&nbsp;                        break;
&nbsp;                }
<b class="nc">&nbsp;                entity.setConsecutiveRHSUses(entity.getConsecutiveRHSUses() + 1);</b>
&nbsp;
&nbsp;                // RHS activation report
<b class="nc">&nbsp;                r = new Report(5540);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(radicalHSBonus);</b>
<b class="nc">&nbsp;                rhsReports.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                boolean rhsFailure = rhsRoll &lt; targetNumber;</b>
<b class="nc">&nbsp;                r = new Report(5541);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(targetNumber);</b>
<b class="nc">&nbsp;                r.add(rhsRoll);</b>
<b class="nc">&nbsp;                r.choose(rhsFailure);</b>
<b class="nc">&nbsp;                rhsReports.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (rhsFailure) {</b>
<b class="nc">&nbsp;                    entity.setHasDamagedRHS(true);</b>
<b class="nc">&nbsp;                    int loc = Entity.LOC_NONE;</b>
<b class="nc">&nbsp;                    for (Mounted m : entity.getEquipment()) {</b>
<b class="nc">&nbsp;                        if (m.getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {</b>
<b class="nc">&nbsp;                            loc = m.getLocation();</b>
<b class="nc">&nbsp;                            m.setDestroyed(true);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (loc == Entity.LOC_NONE) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Server.resolveHeat(): &quot; +</b>
&nbsp;                                &quot;Could not find Radical Heat Sink mount on unit that used RHS!&quot;);
&nbsp;                    }
<b class="nc">&nbsp;                    for (int s = 0; s &lt; entity.getNumberOfCriticals(loc); s++) {</b>
<b class="nc">&nbsp;                        CriticalSlot slot = entity.getCritical(loc, s);</b>
<b class="nc">&nbsp;                        if ((slot.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                                &amp;&amp; slot.getMount().getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {</b>
<b class="nc">&nbsp;                            slot.setHit(true);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // put in ASF heat build-up first because there are few differences
<b class="nc">&nbsp;            if (entity instanceof Aero &amp;&amp; !(entity instanceof ConvFighter)) {</b>
<b class="nc">&nbsp;                ServerHelper.resolveAeroHeat(game, entity, vPhaseReport, rhsReports, radicalHSBonus, hotDogMod, this);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // heat doesn&#39;t matter for non-mechs
<b class="nc">&nbsp;            if (!(entity instanceof Mech)) {</b>
<b class="nc">&nbsp;                entity.heat = 0;</b>
<b class="nc">&nbsp;                entity.heatBuildup = 0;</b>
<b class="nc">&nbsp;                entity.heatFromExternal = 0;</b>
<b class="nc">&nbsp;                entity.coolFromExternal = 0;</b>
&nbsp;
<b class="nc">&nbsp;                if (entity.infernos.isStillBurning()) {</b>
<b class="nc">&nbsp;                    doFlamingDamage(entity);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity.getTaserShutdownRounds() == 0) {</b>
<b class="nc">&nbsp;                    entity.setBATaserShutdown(false);</b>
<b class="nc">&nbsp;                    if (entity.isShutDown() &amp;&amp; !entity.isManualShutdown()</b>
<b class="nc">&nbsp;                            &amp;&amp; (entity.getTsempEffect() != TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) {</b>
<b class="nc">&nbsp;                        entity.setShutDown(false);</b>
<b class="nc">&nbsp;                        r = new Report(5045);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (entity.isBATaserShutdown()) {</b>
&nbsp;                    // if we&#39;re shutdown by a BA taser, we might activate again
<b class="nc">&nbsp;                    int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    if (roll &gt;= 8) {</b>
<b class="nc">&nbsp;                        entity.setTaserShutdownRounds(0);</b>
<b class="nc">&nbsp;                        if (!(entity.isManualShutdown())) {</b>
<b class="nc">&nbsp;                            entity.setShutDown(false);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        entity.setBATaserShutdown(false);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                continue;
&nbsp;            }
&nbsp;
&nbsp;            // Only Mechs after this point
&nbsp;
&nbsp;            // Meks gain heat from inferno hits.
<b class="nc">&nbsp;            if (entity.infernos.isStillBurning()) {</b>
<b class="nc">&nbsp;                int infernoHeat = entity.infernos.getHeat();</b>
<b class="nc">&nbsp;                entity.heatFromExternal += infernoHeat;</b>
<b class="nc">&nbsp;                r = new Report(5010);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(infernoHeat);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // should we even bother for this mech?
<b class="nc">&nbsp;            if (entity.isDestroyed() || entity.isDoomed() || entity.getCrew().isDoomed()</b>
<b class="nc">&nbsp;                    || entity.getCrew().isDead()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // engine hits add a lot of heat, provided the engine is on
<b class="nc">&nbsp;            entity.heatBuildup += entity.getEngineCritHeat();</b>
&nbsp;
&nbsp;            // If a Mek had an active Stealth suite, add 10 heat.
<b class="nc">&nbsp;            if (entity.isStealthOn()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 10;</b>
<b class="nc">&nbsp;                r = new Report(5015);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Greg: Nova CEWS If a Mek had an active Nova suite, add 2 heat.
<b class="nc">&nbsp;            if (entity.hasActiveNovaCEWS()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 2;</b>
<b class="nc">&nbsp;                r = new Report(5013);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // void sig adds 10 heat
<b class="nc">&nbsp;            if (entity.isVoidSigOn()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 10;</b>
<b class="nc">&nbsp;                r = new Report(5016);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // null sig adds 10 heat
<b class="nc">&nbsp;            if (entity.isNullSigOn()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 10;</b>
<b class="nc">&nbsp;                r = new Report(5017);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // chameleon polarization field adds 6
<b class="nc">&nbsp;            if (entity.isChameleonShieldOn()) {</b>
<b class="nc">&nbsp;                entity.heatBuildup += 6;</b>
<b class="nc">&nbsp;                r = new Report(5014);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // If a Mek is in extreme Temperatures, add or subtract one
&nbsp;            // heat per 10 degrees (or fraction of 10 degrees) above or
&nbsp;            // below 50 or -30 degrees Celsius
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().getTemperatureDifference(50, -30) != 0</b>
<b class="nc">&nbsp;                    &amp;&amp; !((Mech) entity).hasLaserHeatSinks()) {</b>
<b class="nc">&nbsp;                if (game.getPlanetaryConditions().getTemperature() &gt; 50) {</b>
<b class="nc">&nbsp;                    int heatToAdd = game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                            .getTemperatureDifference(50, -30);</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        heatToAdd /= 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    entity.heatFromExternal += heatToAdd;</b>
<b class="nc">&nbsp;                    r = new Report(5020);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(heatToAdd);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        r = new Report(5550);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    entity.heatFromExternal -= game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                            .getTemperatureDifference(50, -30);</b>
<b class="nc">&nbsp;                    r = new Report(5025);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(game.getPlanetaryConditions().getTemperatureDifference(50, -30));</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Add +5 Heat if the hex you&#39;re in is on fire
&nbsp;            // and was on fire for the full round.
<b class="nc">&nbsp;            if (entityHex != null) {</b>
<b class="nc">&nbsp;                if (entityHex.containsTerrain(Terrains.FIRE) &amp;&amp; (entityHex.getFireTurn() &gt; 0)</b>
<b class="nc">&nbsp;                        &amp;&amp; (entity.getElevation() &lt;= 1)) {</b>
<b class="nc">&nbsp;                    int heatToAdd = 5;</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        heatToAdd /= 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    entity.heatFromExternal += heatToAdd;</b>
<b class="nc">&nbsp;                    r = new Report(5030);</b>
<b class="nc">&nbsp;                    r.add(heatToAdd);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        r = new Report(5550);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                int magma = entityHex.terrainLevel(Terrains.MAGMA);</b>
<b class="nc">&nbsp;                if ((magma &gt; 0) &amp;&amp; (entity.getElevation() == 0)) {</b>
<b class="nc">&nbsp;                    int heatToAdd = 5 * magma;</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        heatToAdd /= 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    entity.heatFromExternal += heatToAdd;</b>
<b class="nc">&nbsp;                    r = new Report(5032);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(heatToAdd);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    if (((Mech) entity).hasIntactHeatDissipatingArmor()) {</b>
<b class="nc">&nbsp;                        r = new Report(5550);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Check the mech for vibroblades if so then check to see if any
&nbsp;            // are active and what heat they will produce.
<b class="nc">&nbsp;            if (entity.hasVibroblades()) {</b>
&nbsp;                int vibroHeat;
&nbsp;
<b class="nc">&nbsp;                vibroHeat = entity.getActiveVibrobladeHeat(Mech.LOC_RARM);</b>
<b class="nc">&nbsp;                vibroHeat += entity.getActiveVibrobladeHeat(Mech.LOC_LARM);</b>
&nbsp;
<b class="nc">&nbsp;                if (vibroHeat &gt; 0) {</b>
<b class="nc">&nbsp;                    r = new Report(5018);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(vibroHeat);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entity.heatBuildup += vibroHeat;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int capHeat = 0;</b>
<b class="nc">&nbsp;            for (Mounted m : entity.getEquipment()) {</b>
<b class="nc">&nbsp;                if ((m.hasChargedOrChargingCapacitor() == 1) &amp;&amp; !m.isUsedThisRound()) {</b>
<b class="nc">&nbsp;                    capHeat += 5;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((m.hasChargedOrChargingCapacitor() == 2) &amp;&amp; !m.isUsedThisRound()) {</b>
<b class="nc">&nbsp;                    capHeat += 10;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (capHeat &gt; 0) {</b>
<b class="nc">&nbsp;                r = new Report(5019);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(capHeat);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                entity.heatBuildup += capHeat;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Add heat from external sources to the heat buildup
<b class="nc">&nbsp;            int max_ext_heat = game.getOptions().intOption(OptionsConstants.ADVCOMBAT_MAX_EXTERNAL_HEAT);</b>
&nbsp;            // Check Game Options
<b class="nc">&nbsp;            if (max_ext_heat &lt; 0) {</b>
<b class="nc">&nbsp;                max_ext_heat = 15; // standard value specified in TW p.159</b>
&nbsp;            }
<b class="nc">&nbsp;            entity.heatBuildup += Math.min(max_ext_heat, entity.heatFromExternal);</b>
<b class="nc">&nbsp;            entity.heatFromExternal = 0;</b>
&nbsp;            // remove heat we cooled down
<b class="nc">&nbsp;            entity.heatBuildup -= Math.min(9, entity.coolFromExternal);</b>
<b class="nc">&nbsp;            entity.coolFromExternal = 0;</b>
&nbsp;
&nbsp;            // Combat computers help manage heat
<b class="nc">&nbsp;            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_COMBAT_COMPUTER)) {</b>
<b class="nc">&nbsp;                int reduce = Math.min(entity.heatBuildup, 4);</b>
<b class="nc">&nbsp;                r = new Report(5026);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(reduce);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                entity.heatBuildup -= reduce;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((Mech) entity).isCoolingFlawActive()) {</b>
<b class="nc">&nbsp;                int flaw = 5;</b>
<b class="nc">&nbsp;                r = new Report(5021);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(flaw);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                entity.heatBuildup += flaw;</b>
&nbsp;            }
&nbsp;            // if heat build up is negative due to temperature, set it to 0
&nbsp;            // for prettier turn reports
<b class="nc">&nbsp;            if (entity.heatBuildup &lt; 0) {</b>
<b class="nc">&nbsp;                entity.heatBuildup = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // add the heat we&#39;ve built up so far.
<b class="nc">&nbsp;            entity.heat += entity.heatBuildup;</b>
&nbsp;
&nbsp;            // how much heat can we sink?
<b class="nc">&nbsp;            int toSink = entity.getHeatCapacityWithWater() + radicalHSBonus;</b>
&nbsp;
<b class="nc">&nbsp;            if (entity.getCoolantFailureAmount() &gt; 0) {</b>
<b class="nc">&nbsp;                int failureAmount = entity.getCoolantFailureAmount();</b>
<b class="nc">&nbsp;                r = new Report(5520);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(failureAmount);</b>
<b class="nc">&nbsp;                toSink -= failureAmount;</b>
&nbsp;            }
&nbsp;
&nbsp;            // should we use a coolant pod?
<b class="nc">&nbsp;            int safeHeat = entity.hasInfernoAmmo() ? 9 : 13;</b>
<b class="nc">&nbsp;            int possibleSinkage = ((Mech) entity).getNumberOfSinks() - entity.getCoolantFailureAmount();</b>
<b class="nc">&nbsp;            for (Mounted m : entity.getEquipment()) {</b>
<b class="nc">&nbsp;                if (m.getType() instanceof AmmoType) {</b>
<b class="nc">&nbsp;                    AmmoType at = (AmmoType) m.getType();</b>
<b class="nc">&nbsp;                    if ((at.getAmmoType() == AmmoType.T_COOLANT_POD) &amp;&amp; m.isAmmoUsable()) {</b>
<b class="nc">&nbsp;                        EquipmentMode mode = m.curMode();</b>
<b class="nc">&nbsp;                        if (mode.equals(&quot;dump&quot;)) {</b>
<b class="nc">&nbsp;                            r = new Report(5260);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            m.setShotsLeft(0);</b>
<b class="nc">&nbsp;                            toSink += possibleSinkage;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (mode.equals(&quot;safe&quot;) &amp;&amp; ((entity.heat - toSink) &gt; safeHeat)) {</b>
<b class="nc">&nbsp;                            r = new Report(5265);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            m.setShotsLeft(0);</b>
<b class="nc">&nbsp;                            toSink += possibleSinkage;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (mode.equals(&quot;efficient&quot;) &amp;&amp; ((entity.heat - toSink) &gt;= possibleSinkage)) {</b>
<b class="nc">&nbsp;                            r = new Report(5270);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            addReport(r);</b>
<b class="nc">&nbsp;                            m.setShotsLeft(0);</b>
<b class="nc">&nbsp;                            toSink += possibleSinkage;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            toSink = Math.min(toSink, entity.heat);</b>
<b class="nc">&nbsp;            entity.heat -= toSink;</b>
<b class="nc">&nbsp;            r = new Report(5035);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(entity.heatBuildup);</b>
<b class="nc">&nbsp;            r.add(toSink);</b>
<b class="nc">&nbsp;            r.add(entity.heat);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            entity.heatBuildup = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(rhsReports);</b>
&nbsp;
&nbsp;            // Does the unit have inferno ammo?
<b class="nc">&nbsp;            if (entity.hasInfernoAmmo()) {</b>
&nbsp;
&nbsp;                // Roll for possible inferno ammo explosion.
<b class="nc">&nbsp;                if (entity.heat &gt;= 10) {</b>
<b class="nc">&nbsp;                    int boom = (4 + (entity.heat &gt;= 14 ? 2 : 0) + (entity.heat &gt;= 19 ? 2 : 0)</b>
<b class="nc">&nbsp;                                + (entity.heat &gt;= 23 ? 2 : 0) + (entity.heat &gt;= 28 ? 2 : 0))</b>
&nbsp;                               - hotDogMod;
<b class="nc">&nbsp;                    int boomRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    if (entity.getCrew().hasActiveTechOfficer()) {</b>
<b class="nc">&nbsp;                        boomRoll += 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r = new Report(5040);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(boom);</b>
<b class="nc">&nbsp;                    if (entity.getCrew().hasActiveTechOfficer()) {</b>
<b class="nc">&nbsp;                        r.add(boomRoll + &quot;(&quot; + (boomRoll - 2) + &quot;+2)&quot;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.add(boomRoll);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (boomRoll &gt;= boom) {</b>
&nbsp;                        // avoided
<b class="nc">&nbsp;                        r.choose(true);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.choose(false);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        addReport(explodeInfernoAmmoFromHeat(entity));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } // End avoid-inferno-explosion
&nbsp;            int autoShutDownHeat;
&nbsp;            boolean mtHeat;
&nbsp;
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HEAT)) {</b>
<b class="nc">&nbsp;                autoShutDownHeat = 50;</b>
<b class="nc">&nbsp;                mtHeat = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                autoShutDownHeat = 30;</b>
<b class="nc">&nbsp;                mtHeat = false;</b>
&nbsp;            }
&nbsp;            // heat effects: start up
<b class="nc">&nbsp;            if ((entity.heat &lt; autoShutDownHeat) &amp;&amp; entity.isShutDown() &amp;&amp; !entity.isStalled()) {</b>
<b class="nc">&nbsp;                if ((entity.getTaserShutdownRounds() == 0)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getTsempEffect() != TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) {</b>
<b class="nc">&nbsp;                    if ((entity.heat &lt; 14) &amp;&amp; !(entity.isManualShutdown())) {</b>
&nbsp;                        // automatically starts up again
<b class="nc">&nbsp;                        entity.setShutDown(false);</b>
<b class="nc">&nbsp;                        r = new Report(5045);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                    } else if (!(entity.isManualShutdown())) {</b>
&nbsp;                        // If the pilot is KO and we need to roll, auto-fail.
<b class="nc">&nbsp;                        if (!entity.getCrew().isActive()) {</b>
<b class="nc">&nbsp;                            r = new Report(5049);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
&nbsp;                        } else {
&nbsp;                            // roll for startup
<b class="nc">&nbsp;                            int startup = (4 + (((entity.heat - 14) / 4) * 2)) - hotDogMod;</b>
<b class="nc">&nbsp;                            if (mtHeat) {</b>
<b class="nc">&nbsp;                                startup -= 5;</b>
<b class="nc">&nbsp;                                switch (entity.getCrew().getPiloting()) {</b>
&nbsp;                                    case 0:
&nbsp;                                    case 1:
<b class="nc">&nbsp;                                        startup -= 2;</b>
<b class="nc">&nbsp;                                        break;</b>
&nbsp;                                    case 2:
&nbsp;                                    case 3:
<b class="nc">&nbsp;                                        startup -= 1;</b>
<b class="nc">&nbsp;                                        break;</b>
&nbsp;                                    case 6:
&nbsp;                                    case 7:
<b class="nc">&nbsp;                                        startup += 1;</b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            int suRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                            r = new Report(5050);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.add(startup);</b>
<b class="nc">&nbsp;                            r.add(suRoll);</b>
<b class="nc">&nbsp;                            if (suRoll &gt;= startup) {</b>
&nbsp;                                // start &#39;er back up
<b class="nc">&nbsp;                                entity.setShutDown(false);</b>
<b class="nc">&nbsp;                                r.choose(true);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                r.choose(false);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // if we&#39;re shutdown by a BA taser, we might activate
&nbsp;                    // again
<b class="nc">&nbsp;                    if (entity.isBATaserShutdown()) {</b>
<b class="nc">&nbsp;                        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                        if (roll &gt;= 7) {</b>
<b class="nc">&nbsp;                            entity.setTaserShutdownRounds(0);</b>
<b class="nc">&nbsp;                            if (!(entity.isManualShutdown())) {</b>
<b class="nc">&nbsp;                                entity.setShutDown(false);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            entity.setBATaserShutdown(false);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // heat effects: shutdown!
&nbsp;            // Don&#39;t shut down if you just restarted.
<b class="nc">&nbsp;            else if ((entity.heat &gt;= 14) &amp;&amp; !entity.isShutDown()) {</b>
<b class="nc">&nbsp;                if (entity.heat &gt;= autoShutDownHeat) {</b>
<b class="nc">&nbsp;                    r = new Report(5055);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // add a piloting roll and resolve immediately
<b class="nc">&nbsp;                    if (entity.canFall()) {</b>
<b class="nc">&nbsp;                        game.addPSR(new PilotingRollData(entity.getId(), 3, &quot;reactor shutdown&quot;));</b>
<b class="nc">&nbsp;                        addReport(resolvePilotingRolls());</b>
&nbsp;                    }
&nbsp;                    // okay, now mark shut down
<b class="nc">&nbsp;                    entity.setShutDown(true);</b>
&nbsp;                } else {
&nbsp;                    // Again, pilot KO means shutdown is automatic.
<b class="nc">&nbsp;                    if (!entity.getCrew().isActive()) {</b>
<b class="nc">&nbsp;                        r = new Report(5056);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        entity.setShutDown(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        int shutdown = (4 + (((entity.heat - 14) / 4) * 2)) - hotDogMod;</b>
<b class="nc">&nbsp;                        if (mtHeat) {</b>
<b class="nc">&nbsp;                            shutdown -= 5;</b>
<b class="nc">&nbsp;                            switch (entity.getCrew().getPiloting()) {</b>
&nbsp;                                case 0:
&nbsp;                                case 1:
<b class="nc">&nbsp;                                    shutdown -= 2;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case 2:
&nbsp;                                case 3:
<b class="nc">&nbsp;                                    shutdown -= 1;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case 6:
&nbsp;                                case 7:
<b class="nc">&nbsp;                                    shutdown += 1;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        int shutdownRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                        r = new Report(5060);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.add(shutdown);</b>
<b class="nc">&nbsp;                        if (entity.getCrew().hasActiveTechOfficer()) {</b>
<b class="nc">&nbsp;                            r.add((shutdownRoll + 2) + &quot; (&quot; + shutdownRoll + &quot;+2)&quot;);</b>
<b class="nc">&nbsp;                            shutdownRoll += 2;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r.add(shutdownRoll);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (shutdownRoll &gt;= shutdown) {</b>
&nbsp;                            // avoided
<b class="nc">&nbsp;                            r.choose(true);</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                        } else {
&nbsp;                            // shutting down...
<b class="nc">&nbsp;                            r.choose(false);</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                            // add a piloting roll and resolve immediately
<b class="nc">&nbsp;                            if (entity.canFall()) {</b>
<b class="nc">&nbsp;                                game.addPSR(new PilotingRollData(entity.getId(), 3, &quot;reactor shutdown&quot;));</b>
<b class="nc">&nbsp;                                addReport(resolvePilotingRolls());</b>
&nbsp;                            }
&nbsp;                            // okay, now mark shut down
<b class="nc">&nbsp;                            entity.setShutDown(true);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // LAMs in fighter mode need to check for random movement due to heat
<b class="nc">&nbsp;            checkRandomAeroMovement(entity, hotDogMod);</b>
&nbsp;
&nbsp;            // heat effects: ammo explosion!
<b class="nc">&nbsp;            if (entity.heat &gt;= 19) {</b>
<b class="nc">&nbsp;                int boom = (4 + (entity.heat &gt;= 23 ? 2 : 0) + (entity.heat &gt;= 28 ? 2 : 0))</b>
&nbsp;                           - hotDogMod;
<b class="nc">&nbsp;                if (mtHeat) {</b>
<b class="nc">&nbsp;                    boom += (entity.heat &gt;= 35 ? 2 : 0)</b>
<b class="nc">&nbsp;                            + (entity.heat &gt;= 40 ? 2 : 0)</b>
<b class="nc">&nbsp;                            + (entity.heat &gt;= 45 ? 2 : 0);</b>
&nbsp;                    // Last line is a crutch; 45 heat should be no roll
&nbsp;                    // but automatic explosion.
&nbsp;                }
<b class="nc">&nbsp;                if (((Mech) entity).hasLaserHeatSinks()) {</b>
<b class="nc">&nbsp;                    boom--;</b>
&nbsp;                }
<b class="nc">&nbsp;                int boomRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                r = new Report(5065);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(boom);</b>
<b class="nc">&nbsp;                if (entity.getCrew().hasActiveTechOfficer()) {</b>
<b class="nc">&nbsp;                    r.add((boomRoll + 2) + &quot; (&quot; + boomRoll + &quot;+2)&quot;);</b>
<b class="nc">&nbsp;                    boomRoll += 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.add(boomRoll);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (boomRoll &gt;= boom) {</b>
&nbsp;                    // mech is ok
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                } else {
&nbsp;                    // boom!
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addReport(explodeAmmoFromHeat(entity));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // heat effects: mechwarrior damage
&nbsp;            // N.B. The pilot may already be dead.
&nbsp;            int lifeSupportCritCount;
<b class="nc">&nbsp;            boolean torsoMountedCockpit = ((Mech) entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED;</b>
<b class="nc">&nbsp;            if (torsoMountedCockpit) {</b>
<b class="nc">&nbsp;                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                        Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_RT);
<b class="nc">&nbsp;                lifeSupportCritCount += entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                        Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_LT);
&nbsp;            } else {
<b class="nc">&nbsp;                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                        Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD);
&nbsp;            }
<b class="nc">&nbsp;            int damageHeat = entity.heat;</b>
<b class="nc">&nbsp;            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_IMP_LIFE_SUPPORT)) {</b>
<b class="nc">&nbsp;                damageHeat -= 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_LIFE_SUPPORT)) {</b>
<b class="nc">&nbsp;                damageHeat += 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((lifeSupportCritCount &gt; 0)</b>
&nbsp;                    &amp;&amp; ((damageHeat &gt;= 15) || (torsoMountedCockpit &amp;&amp; (damageHeat &gt; 0)))
<b class="nc">&nbsp;                    &amp;&amp; !entity.getCrew().isDead() &amp;&amp; !entity.getCrew().isDoomed()</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.getCrew().isEjected()) {</b>
<b class="nc">&nbsp;                int heatLimitDesc = 1;</b>
<b class="nc">&nbsp;                int damageToCrew = 0;</b>
<b class="nc">&nbsp;                if ((damageHeat &gt;= 47) &amp;&amp; mtHeat) {</b>
&nbsp;                    // mechwarrior takes 5 damage
<b class="nc">&nbsp;                    heatLimitDesc = 47;</b>
<b class="nc">&nbsp;                    damageToCrew = 5;</b>
<b class="nc">&nbsp;                } else if ((damageHeat &gt;= 39) &amp;&amp; mtHeat) {</b>
&nbsp;                    // mechwarrior takes 4 damage
<b class="nc">&nbsp;                    heatLimitDesc = 39;</b>
<b class="nc">&nbsp;                    damageToCrew = 4;</b>
<b class="nc">&nbsp;                } else if ((damageHeat &gt;= 32) &amp;&amp; mtHeat) {</b>
&nbsp;                    // mechwarrior takes 3 damage
<b class="nc">&nbsp;                    heatLimitDesc = 32;</b>
<b class="nc">&nbsp;                    damageToCrew = 3;</b>
<b class="nc">&nbsp;                } else if (damageHeat &gt;= 25) {</b>
&nbsp;                    // mechwarrior takes 2 damage
<b class="nc">&nbsp;                    heatLimitDesc = 25;</b>
<b class="nc">&nbsp;                    damageToCrew = 2;</b>
<b class="nc">&nbsp;                } else if (damageHeat &gt;= 15) {</b>
&nbsp;                    // mechwarrior takes 1 damage
<b class="nc">&nbsp;                    heatLimitDesc = 15;</b>
<b class="nc">&nbsp;                    damageToCrew = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((((Mech) entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {</b>
<b class="nc">&nbsp;                    damageToCrew += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = new Report(5070);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(heatLimitDesc);</b>
<b class="nc">&nbsp;                r.add(damageToCrew);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(damageCrew(entity, damageToCrew));</b>
<b class="nc">&nbsp;            } else if (mtHeat &amp;&amp; (entity.heat &gt;= 32) &amp;&amp; !entity.getCrew().isDead()</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.getCrew().isDoomed()</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {</b>
&nbsp;                // Crew may take damage from heat if MaxTech option is set
<b class="nc">&nbsp;                int heatRoll = Compute.d6(2);</b>
&nbsp;                int avoidNumber;
<b class="nc">&nbsp;                if (entity.heat &gt;= 47) {</b>
<b class="nc">&nbsp;                    avoidNumber = 12;</b>
<b class="nc">&nbsp;                } else if (entity.heat &gt;= 39) {</b>
<b class="nc">&nbsp;                    avoidNumber = 10;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    avoidNumber = 8;</b>
&nbsp;                }
<b class="nc">&nbsp;                avoidNumber -= hotDogMod;</b>
<b class="nc">&nbsp;                r = new Report(5075);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(avoidNumber);</b>
<b class="nc">&nbsp;                r.add(heatRoll);</b>
<b class="nc">&nbsp;                if (heatRoll &gt;= avoidNumber) {</b>
&nbsp;                    // damage avoided
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    addReport(damageCrew(entity, 1));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // The pilot may have just expired.
<b class="nc">&nbsp;            if ((entity.getCrew().isDead() || entity.getCrew().isDoomed())</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.getCrew().isEjected()) {</b>
<b class="nc">&nbsp;                r = new Report(5080);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(destroyEntity(entity, &quot;crew death&quot;, true));</b>
&nbsp;            }
&nbsp;
&nbsp;            // With MaxTech Heat Scale, there may occur critical damage
<b class="nc">&nbsp;            if (mtHeat) {</b>
<b class="nc">&nbsp;                if (entity.heat &gt;= 36) {</b>
<b class="nc">&nbsp;                    int damageRoll = Compute.d6(2);</b>
&nbsp;                    int damageNumber;
<b class="nc">&nbsp;                    if (entity.heat &gt;= 44) {</b>
<b class="nc">&nbsp;                        damageNumber = 10;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        damageNumber = 8;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    damageNumber -= hotDogMod;</b>
<b class="nc">&nbsp;                    r = new Report(5085);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(damageNumber);</b>
<b class="nc">&nbsp;                    r.add(damageRoll);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    if (damageRoll &gt;= damageNumber) {</b>
<b class="nc">&nbsp;                        r.choose(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.choose(false);</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        addReport(oneCriticalEntity(entity, Compute.randomInt(8), false, 0));</b>
&nbsp;                        // add an empty report, for line breaking
<b class="nc">&nbsp;                        r = new Report(1210, Report.PUBLIC);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_COOLANT_FAILURE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getHeatCapacity() &gt; entity.getCoolantFailureAmount())</b>
&nbsp;                    &amp;&amp; (entity.heat &gt;= 5)) {
<b class="nc">&nbsp;                int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                int hitNumber = 10;</b>
&nbsp;
<b class="nc">&nbsp;                hitNumber -= Math.max(0, (int) Math.ceil(entity.heat / 5.0) - 2);</b>
&nbsp;
<b class="nc">&nbsp;                r = new Report(5525);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getShortName());</b>
<b class="nc">&nbsp;                r.add(hitNumber);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                if (roll &gt;= hitNumber) {</b>
<b class="nc">&nbsp;                    r = new Report(5052);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    r = new Report(5526);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getShortNameRaw());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entity.addCoolantFailureAmount(1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(5041);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (vPhaseReport.size() == 1) {</b>
&nbsp;            // I guess nothing happened...
<b class="nc">&nbsp;            addReport(new Report(1205, Report.PUBLIC));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    void checkRandomAeroMovement(Entity entity, int hotDogMod) {
<b class="nc">&nbsp;        if (!entity.isAero()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        IAero a = (IAero) entity;</b>
&nbsp;        // heat effects: control effects (must make it unless already random moving)
<b class="nc">&nbsp;        if ((entity.heat &gt;= 5) &amp;&amp; !a.isRandomMove()) {</b>
<b class="nc">&nbsp;            int controlAvoid = (5 + (entity.heat &gt;= 10 ? 1 : 0) + (entity.heat &gt;= 15 ? 1 : 0)</b>
<b class="nc">&nbsp;                    + (entity.heat &gt;= 20 ? 1 : 0) + (entity.heat &gt;= 25 ? 2 : 0)) - hotDogMod;</b>
<b class="nc">&nbsp;            int controlRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            Report r = new Report(9210);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(controlAvoid);</b>
<b class="nc">&nbsp;            r.add(controlRoll);</b>
<b class="nc">&nbsp;            if (controlRoll &gt;= controlAvoid) {</b>
&nbsp;                // in control
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
&nbsp;                // out of control
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;                // if not already out of control, this may lead to
&nbsp;                // elevation decline
<b class="nc">&nbsp;                if (!a.isOutControl() &amp;&amp; !a.isSpaceborne()</b>
<b class="nc">&nbsp;                    &amp;&amp; a.isAirborne()) {</b>
<b class="nc">&nbsp;                    int loss = Compute.d6(1);</b>
<b class="nc">&nbsp;                    r = new Report(9366);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(loss);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entity.setAltitude(entity.getAltitude() - loss);</b>
&nbsp;                    // check for crash
<b class="nc">&nbsp;                    if (checkCrash(entity, entity.getPosition(), entity.getAltitude())) {</b>
<b class="nc">&nbsp;                        addReport(processCrash(entity, a.getCurrentVelocity(), entity.getPosition()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // force unit out of control through heat
<b class="nc">&nbsp;                a.setOutCtrlHeat(true);</b>
<b class="nc">&nbsp;                a.setRandomMove(true);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void resolveEmergencyCoolantSystem() {
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if ((e instanceof Mech) &amp;&amp; e.hasWorkingMisc(MiscType.F_EMERGENCY_COOLANT_SYSTEM)</b>
&nbsp;                    &amp;&amp; (e.heat &gt; 13)) {
<b class="nc">&nbsp;                Mech mech = (Mech)e;</b>
<b class="nc">&nbsp;                Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                HashMap&lt;Integer, List&lt;CriticalSlot&gt;&gt; crits = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;                if (!(mech.doRISCEmergencyCoolantCheckFor(vDesc, crits))) {</b>
<b class="nc">&nbsp;                    mech.heat -= 6 + mech.getCoolantSystemMOS();</b>
<b class="nc">&nbsp;                    Report r = new Report(5027);</b>
<b class="nc">&nbsp;                    r.add(6+mech.getCoolantSystemMOS());</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                addReport(vDesc);</b>
<b class="nc">&nbsp;                for (Integer loc : crits.keySet()) {</b>
<b class="nc">&nbsp;                    List&lt;CriticalSlot&gt; lcs = crits.get(loc);</b>
<b class="nc">&nbsp;                    for (CriticalSlot cs : lcs) {</b>
<b class="nc">&nbsp;                        addReport(applyCriticalHit(mech, loc, cs, true, 0, false));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Resolve HarJel II/III repairs for Mechs so equipped.
&nbsp;     */
&nbsp;    private void resolveHarJelRepairs() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = i.next();</b>
<b class="nc">&nbsp;            if (!(entity instanceof Mech)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Mech me = (Mech) entity;</b>
<b class="nc">&nbsp;            for (int loc = 0; loc &lt; me.locations(); ++loc) {</b>
<b class="nc">&nbsp;                boolean harJelII = me.hasHarJelIIIn(loc); // false implies HarJel III</b>
<b class="nc">&nbsp;                if ((harJelII || me.hasHarJelIIIIn(loc))</b>
<b class="nc">&nbsp;                    &amp;&amp; me.isArmorDamagedThisTurn(loc)) {</b>
<b class="nc">&nbsp;                    if (me.hasRearArmor(loc)) {</b>
&nbsp;                        // must have at least one remaining armor in location
<b class="nc">&nbsp;                        if (!((me.getArmor(loc) &gt; 0) || (me.getArmor(loc, true) &gt; 0))) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        int toRepair = harJelII ? 2 : 4;</b>
&nbsp;                        int frontRepair, rearRepair;
&nbsp;                        int desiredFrontRepair, desiredRearRepair;
&nbsp;
<b class="nc">&nbsp;                        Mounted harJel = null;</b>
&nbsp;                        // find HarJel item
&nbsp;                        // don&#39;t need to check ready or worry about null,
&nbsp;                        // we already know there is one, it&#39;s ready,
&nbsp;                        // and there can be at most one in a given location
<b class="nc">&nbsp;                        for (Mounted m: me.getMisc()) {</b>
<b class="nc">&nbsp;                            if ((m.getLocation() == loc)</b>
<b class="nc">&nbsp;                                &amp;&amp; (m.getType().hasFlag(MiscType.F_HARJEL_II)</b>
<b class="nc">&nbsp;                                    || m.getType().hasFlag(MiscType.F_HARJEL_III))) {</b>
<b class="nc">&nbsp;                                harJel = m;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;
<b class="nc">&nbsp;                        if (harJelII) {</b>
<b class="nc">&nbsp;                            if (harJel.curMode().equals(MiscType.S_HARJEL_II_1F1R)) {</b>
<b class="nc">&nbsp;                                desiredFrontRepair = 1;</b>
<b class="nc">&nbsp;                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_II_2F0R)) {</b>
<b class="nc">&nbsp;                                desiredFrontRepair = 2;</b>
&nbsp;                            } else { // 0F2R
<b class="nc">&nbsp;                                desiredFrontRepair = 0;</b>
&nbsp;                            }
&nbsp;                        } else { // HarJel III
<b class="nc">&nbsp;                            if (harJel.curMode().equals(MiscType.S_HARJEL_III_2F2R)) {</b>
<b class="nc">&nbsp;                                desiredFrontRepair = 2;</b>
<b class="nc">&nbsp;                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_III_4F0R)) {</b>
<b class="nc">&nbsp;                                desiredFrontRepair = 4;</b>
<b class="nc">&nbsp;                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_III_3F1R)) {</b>
<b class="nc">&nbsp;                                desiredFrontRepair = 3;</b>
<b class="nc">&nbsp;                            } else if (harJel.curMode().equals(MiscType.S_HARJEL_III_1F3R)) {</b>
<b class="nc">&nbsp;                                desiredFrontRepair = 1;</b>
&nbsp;                            } else { // 0F4R
<b class="nc">&nbsp;                                desiredFrontRepair = 0;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        desiredRearRepair = toRepair - desiredFrontRepair;</b>
&nbsp;
<b class="nc">&nbsp;                        int availableFrontRepair = me.getOArmor(loc) - me.getArmor(loc);</b>
<b class="nc">&nbsp;                        int availableRearRepair = me.getOArmor(loc, true) - me.getArmor(loc, true);</b>
<b class="nc">&nbsp;                        frontRepair = Math.min(availableFrontRepair, desiredFrontRepair);</b>
<b class="nc">&nbsp;                        rearRepair = Math.min(availableRearRepair, desiredRearRepair);</b>
<b class="nc">&nbsp;                        int surplus = desiredFrontRepair - frontRepair;</b>
<b class="nc">&nbsp;                        if (surplus &gt; 0) { // we couldn&#39;t use all the points we wanted in front</b>
<b class="nc">&nbsp;                            rearRepair = Math.min(availableRearRepair, rearRepair + surplus);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            surplus = desiredRearRepair - rearRepair;</b>
&nbsp;                            // try to move any excess points from rear to front
<b class="nc">&nbsp;                            frontRepair = Math.min(availableFrontRepair, frontRepair + surplus);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (frontRepair &gt; 0) {</b>
<b class="nc">&nbsp;                            me.setArmor(me.getArmor(loc) + frontRepair, loc);</b>
<b class="nc">&nbsp;                            r = new Report(harJelII ? 9850 : 9851);</b>
<b class="nc">&nbsp;                            r.subject = me.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.add(frontRepair);</b>
<b class="nc">&nbsp;                            r.add(me.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (rearRepair &gt; 0) {</b>
<b class="nc">&nbsp;                            me.setArmor(me.getArmor(loc, true) + rearRepair, loc, true);</b>
<b class="nc">&nbsp;                            r = new Report(harJelII ? 9850 : 9851);</b>
<b class="nc">&nbsp;                            r.subject = me.getId();</b>
<b class="nc">&nbsp;                            r.addDesc(entity);</b>
<b class="nc">&nbsp;                            r.add(rearRepair);</b>
<b class="nc">&nbsp;                            r.add(me.getLocationAbbr(loc) + &quot; (R)&quot;);</b>
<b class="nc">&nbsp;                            addReport(r);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        // must have at least one remaining armor in location
<b class="nc">&nbsp;                        if (!(me.getArmor(loc) &gt; 0)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        int toRepair = harJelII ? 2 : 4;</b>
<b class="nc">&nbsp;                        toRepair = Math.min(toRepair, me.getOArmor(loc) - me.getArmor(loc));</b>
<b class="nc">&nbsp;                        me.setArmor(me.getArmor(loc) + toRepair, loc);</b>
<b class="nc">&nbsp;                        r = new Report(harJelII ? 9850 : 9851);</b>
<b class="nc">&nbsp;                        r.subject = me.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.add(toRepair);</b>
<b class="nc">&nbsp;                        r.add(me.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolve Flaming Damage for the given Entity Taharqa: This is now updated
&nbsp;     * to TacOps rules which is much more lenient So I have change the name to
&nbsp;     * Flaming Damage rather than flaming death
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that may experience flaming damage.
&nbsp;     */
&nbsp;    private void doFlamingDamage(Entity entity) {
&nbsp;        Report r;
<b class="nc">&nbsp;        int boomRoll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;        if ((entity.getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.infernos.isStillBurning()) {</b>
&nbsp;            // VTOLs don&#39;t check as long as they are flying higher than
&nbsp;            // the burning terrain. TODO : Check for rules conformity (ATPM?)
&nbsp;            // according to maxtech, elevation 0 or 1 should be affected,
&nbsp;            // this makes sense for level 2 as well
&nbsp;
<b class="nc">&nbsp;            if (entity.getElevation() &gt; 1) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Battle Armor squads equipped with fire protection
&nbsp;        // gear automatically avoid flaming damage
&nbsp;        // TODO : can conventional infantry mount fire-resistant armor?
<b class="nc">&nbsp;        if ((entity instanceof BattleArmor)</b>
<b class="nc">&nbsp;            &amp;&amp; ((BattleArmor) entity).isFireResistant()) {</b>
<b class="nc">&nbsp;            r = new Report(5095);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // mechs shouldn&#39;t be here, but just in case
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // fire has no effect on dropships
<b class="nc">&nbsp;        if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Must roll 8+ to survive...
<b class="nc">&nbsp;        r = new Report(5100);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(boomRoll);</b>
<b class="nc">&nbsp;        if (boomRoll &gt;= 8) {</b>
&nbsp;            // phew!
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
&nbsp;        } else {
&nbsp;            // eek
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            r.newlines = 1;</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;            // gun emplacements have their own critical rules
<b class="nc">&nbsp;            if (entity instanceof GunEmplacement) {</b>
<b class="nc">&nbsp;                Vector&lt;GunEmplacement&gt; gun = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                gun.add((GunEmplacement) entity);</b>
&nbsp;                
<b class="nc">&nbsp;                Building building = getGame().getBoard().getBuildingAt(entity.getPosition());</b>
&nbsp;                
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                addReport(criticalGunEmplacement(gun, building, entity.getPosition()));            </b>
&nbsp;            // Taharqa: TacOps rules, protos and vees no longer die instantly
&nbsp;            // (hurray!)
<b class="nc">&nbsp;            } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                int bonus = -2;</b>
<b class="nc">&nbsp;                if ((entity instanceof SupportTank)</b>
&nbsp;                    || (entity instanceof SupportVTOL)) {
<b class="nc">&nbsp;                    bonus = 0;</b>
&nbsp;                }
&nbsp;                // roll a critical hit
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;                addReport(criticalTank((Tank) entity, Tank.LOC_FRONT, bonus, 0, true));</b>
<b class="nc">&nbsp;            } else if (entity instanceof Protomech) {</b>
&nbsp;                // this code is taken from inferno hits
<b class="nc">&nbsp;                HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                if (hit.getLocation() == Protomech.LOC_NMISS) {</b>
<b class="nc">&nbsp;                    Protomech proto = (Protomech) entity;</b>
<b class="nc">&nbsp;                    r = new Report(6035);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    if (proto.isGlider()) {</b>
<b class="nc">&nbsp;                        r.messageId = 6036;</b>
<b class="nc">&nbsp;                        proto.setWingHits(proto.getWingHits() + 1);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    r = new Report(6690);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(1);</b>
<b class="nc">&nbsp;                    r.add(entity.getLocationName(hit));</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    entity.destroyLocation(hit.getLocation());</b>
&nbsp;                    // Handle ProtoMech pilot damage due to location destruction
<b class="nc">&nbsp;                    int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]</b>
<b class="nc">&nbsp;                               - ((Protomech) entity).getPilotDamageTaken(hit.getLocation());</b>
<b class="nc">&nbsp;                    if (hits &gt; 0) {</b>
<b class="nc">&nbsp;                        addReport(damageCrew(entity, hits));</b>
<b class="nc">&nbsp;                        ((Protomech) entity).setPilotDamageTaken(hit.getLocation(),</b>
<b class="nc">&nbsp;                                Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (entity.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {</b>
<b class="nc">&nbsp;                        addReport(destroyEntity(entity, &quot;flaming death&quot;, false, true));</b>
<b class="nc">&nbsp;                        Report.addNewline(vPhaseReport);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
&nbsp;                // sucks to be you
<b class="nc">&nbsp;                addReport(destroyEntity(entity, &quot;fire&quot;, false, false));</b>
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void clearFlawedCoolingFlags(Entity entity) {
&nbsp;        // If we&#39;re not using quirks, no need to do this check.
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // Only applies to Mechs.
<b class="nc">&nbsp;        if (!(entity instanceof Mech)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check for existence of flawed cooling quirk.
<b class="nc">&nbsp;        if (!entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        entity.setFallen(false);</b>
<b class="nc">&nbsp;        entity.setStruck(false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void checkForFlawedCooling() {
&nbsp;
&nbsp;        // If we&#39;re not using quirks, no need to do this check.
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
&nbsp;
&nbsp;            // Only applies to Mechs.
<b class="nc">&nbsp;            if (!(entity instanceof Mech)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Check for existence of flawed cooling quirk.
<b class="nc">&nbsp;            if (!entity.hasQuirk(OptionsConstants.QUIRK_NEG_FLAWED_COOLING)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Check for active Cooling Flaw
<b class="nc">&nbsp;            if (((Mech) entity).isCoolingFlawActive()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Perform the check.
<b class="nc">&nbsp;            if (entity.damageThisPhase &gt;= 20) {</b>
<b class="nc">&nbsp;                addReport(doFlawedCoolingCheck(&quot;20+ damage&quot;, entity));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.hasFallen()) {</b>
<b class="nc">&nbsp;                addReport(doFlawedCoolingCheck(&quot;fall&quot;, entity));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.wasStruck()) {</b>
<b class="nc">&nbsp;                addReport(doFlawedCoolingCheck(&quot;being struck&quot;, entity));</b>
&nbsp;            }
<b class="nc">&nbsp;            clearFlawedCoolingFlags(entity);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if Flawed Cooling is triggered and generates a report of
&nbsp;     * the result.
&nbsp;     *
&nbsp;     * @param reason
&nbsp;     * @param entity
&nbsp;     * @return
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doFlawedCoolingCheck(String reason, Entity entity) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; out = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        Report r = new Report(9800);</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(reason);</b>
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        out.add(r);</b>
<b class="nc">&nbsp;        if (roll &gt;= 10) {</b>
<b class="nc">&nbsp;            Report s = new Report(9805);</b>
<b class="nc">&nbsp;            ((Mech) entity).setCoolingFlawActive(true);</b>
<b class="nc">&nbsp;            out.add(s);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return out;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For chain whip grapples, a roll needs to be made at the end of the
&nbsp;     * physical phase to maintain the grapple.
&nbsp;     */
&nbsp;    private void checkForChainWhipGrappleChecks() {
<b class="nc">&nbsp;        for (Entity ae : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if ((ae.getGrappled() != Entity.NONE) &amp;&amp; ae.isChainWhipGrappled()</b>
<b class="nc">&nbsp;                    &amp;&amp; ae.isGrappleAttacker() &amp;&amp; !ae.isGrappledThisRound()) {</b>
<b class="nc">&nbsp;                Entity te = game.getEntity(ae.getGrappled());</b>
<b class="nc">&nbsp;                ToHitData grappleHit = GrappleAttackAction.toHit(game,</b>
<b class="nc">&nbsp;                        ae.getId(), te, ae.getGrappleSide(), true);</b>
<b class="nc">&nbsp;                int roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;                Report r = new Report(4317);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.addDesc(ae);</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (grappleHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                    r = new Report(4300);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.add(grappleHit.getDesc());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
&nbsp;                // report the roll
<b class="nc">&nbsp;                r = new Report(4025);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                r.add(grappleHit.getValue());</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // do we hit?
<b class="nc">&nbsp;                if (roll &gt;= grappleHit.getValue()) {</b>
&nbsp;                    // hit
<b class="nc">&nbsp;                    r = new Report(4040);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // Nothing else to do
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
&nbsp;                // miss
<b class="nc">&nbsp;                r = new Report(4035);</b>
<b class="nc">&nbsp;                r.subject = ae.getId();</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;
&nbsp;                // Need to break grapple
<b class="nc">&nbsp;                ae.setGrappled(Entity.NONE, false);</b>
<b class="nc">&nbsp;                te.setGrappled(Entity.NONE, false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if any entity takes enough damage that requires them to
&nbsp;     * make a piloting roll
&nbsp;     */
&nbsp;    private void checkForPSRFromDamage() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if (entity.canFall()) {</b>
<b class="nc">&nbsp;                if (entity.isAirborne()) {</b>
&nbsp;                    // you can&#39;t fall over when you are combat dropping because
&nbsp;                    // you are already falling!
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // if this mech has 20+ damage, add another roll to the list.
&nbsp;                // Hulldown &#39;mechs ignore this rule, TO Errata
<b class="nc">&nbsp;                int psrThreshold = 20;</b>
<b class="nc">&nbsp;                if (((Mech) entity).getCockpitType() == Mech.COCKPIT_DUAL</b>
<b class="nc">&nbsp;                        &amp;&amp; entity.getCrew().hasDedicatedPilot()) {</b>
<b class="nc">&nbsp;                    psrThreshold = 30;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((entity.damageThisPhase &gt;= psrThreshold) &amp;&amp; !entity.isHullDown()) {</b>
<b class="nc">&nbsp;                    if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_TAKING_DAMAGE)) {</b>
<b class="nc">&nbsp;                        PilotingRollData damPRD = new PilotingRollData(entity.getId());</b>
<b class="nc">&nbsp;                        int damMod = entity.damageThisPhase / psrThreshold;</b>
<b class="nc">&nbsp;                        damPRD.addModifier(damMod, (damMod * psrThreshold) + &quot;+ damage&quot;);</b>
<b class="nc">&nbsp;                        int weightMod = 0;</b>
<b class="nc">&nbsp;                        if (game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVGRNDMOV_TACOPS_PHYSICAL_PSR)) {
<b class="nc">&nbsp;                            switch (entity.getWeightClass()) {</b>
&nbsp;                                case EntityWeightClass.WEIGHT_LIGHT:
<b class="nc">&nbsp;                                    weightMod = 1;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case EntityWeightClass.WEIGHT_MEDIUM:
<b class="nc">&nbsp;                                    weightMod = 0;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case EntityWeightClass.WEIGHT_HEAVY:
<b class="nc">&nbsp;                                    weightMod = -1;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case EntityWeightClass.WEIGHT_ASSAULT:
<b class="nc">&nbsp;                                    weightMod = -2;</b>
&nbsp;                                    break;
&nbsp;                            }
<b class="nc">&nbsp;                            if ((entity instanceof Mech) &amp;&amp; entity.isSuperHeavy()) {</b>
<b class="nc">&nbsp;                                weightMod = -4;</b>
&nbsp;                            }
&nbsp;                            // the weight class PSR modifier is not cumulative
<b class="nc">&nbsp;                            damPRD.addModifier(weightMod,</b>
&nbsp;                                               &quot;weight class modifier&quot;, false);
&nbsp;                        }
<b class="nc">&nbsp;                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)</b>
<b class="nc">&nbsp;                            &amp;&amp; (entity.getCrew().getPiloting() &gt; 3)) {</b>
<b class="nc">&nbsp;                            damPRD.addModifier(-1, &quot;easy to pilot&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        game.addPSR(damPRD);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        PilotingRollData damPRD = new PilotingRollData(</b>
<b class="nc">&nbsp;                                entity.getId(), 1, psrThreshold + &quot;+ damage&quot;);</b>
<b class="nc">&nbsp;                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)</b>
<b class="nc">&nbsp;                            &amp;&amp; (entity.getCrew().getPiloting() &gt; 3)) {</b>
<b class="nc">&nbsp;                            damPRD.addModifier(-1, &quot;easy to pilot&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        game.addPSR(damPRD);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (entity.isAero() &amp;&amp; entity.isAirborne() &amp;&amp; !game.getBoard().inSpace()) {</b>
&nbsp;                // if this aero has any damage, add another roll to the list.
<b class="nc">&nbsp;                if (entity.damageThisPhase &gt; 0) {</b>
<b class="nc">&nbsp;                    if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_ATMOSPHERIC_CONTROL)) {</b>
<b class="nc">&nbsp;                        int damMod = entity.damageThisPhase / 20;</b>
<b class="nc">&nbsp;                        PilotingRollData damPRD = new PilotingRollData(entity.getId(), damMod, entity.damageThisPhase + &quot; damage +&quot; + damMod);</b>
<b class="nc">&nbsp;                        if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)</b>
<b class="nc">&nbsp;                                &amp;&amp; (entity.getCrew().getPiloting() &gt; 3)) {</b>
<b class="nc">&nbsp;                            damPRD.addModifier(-1, &quot;easy to pilot&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        game.addControlRoll(damPRD);</b>
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        // was the damage threshold exceeded this round?
<b class="nc">&nbsp;                        if (((IAero) entity).wasCritThresh()) {</b>
<b class="nc">&nbsp;                            PilotingRollData damThresh = new PilotingRollData(entity.getId(), 0,</b>
&nbsp;                                    &quot;damage threshold exceeded&quot;);
<b class="nc">&nbsp;                            if (entity.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT)</b>
<b class="nc">&nbsp;                                    &amp;&amp; (entity.getCrew().getPiloting() &gt; 3)) {</b>
<b class="nc">&nbsp;                                damThresh.addModifier(-1, &quot;easy to pilot&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            game.addControlRoll(damThresh);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // Airborne AirMechs that take 20+ damage make a control roll instead of a PSR.
<b class="nc">&nbsp;            if (entity instanceof LandAirMech &amp;&amp; entity.isAirborneVTOLorWIGE()</b>
&nbsp;                    &amp;&amp; entity.damageThisPhase &gt;= 20) {
<b class="nc">&nbsp;                PilotingRollData damPRD = new PilotingRollData(entity.getId());</b>
<b class="nc">&nbsp;                int damMod = entity.damageThisPhase / 20;</b>
<b class="nc">&nbsp;                damPRD.addModifier(damMod, (damMod * 20) + &quot;+ damage&quot;);</b>
<b class="nc">&nbsp;                game.addControlRoll(damPRD);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if any non-mech units are standing in fire. Called at the
&nbsp;     * end of the movement phase
&nbsp;     */
&nbsp;    public void checkForFlamingDamage() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) || (entity instanceof Mech)</b>
<b class="nc">&nbsp;                    || entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final IHex curHex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;            final boolean underwater = curHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (curHex.depth() &gt; 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getElevation() &lt; curHex.surface());</b>
<b class="nc">&nbsp;            final int numFloors = curHex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;            if (curHex.containsTerrain(Terrains.FIRE) &amp;&amp; !underwater</b>
<b class="nc">&nbsp;                    &amp;&amp; ((entity.getElevation() &lt;= 1)</b>
<b class="nc">&nbsp;                            || (entity.getElevation() &lt;= numFloors))) {</b>
<b class="nc">&nbsp;                doFlamingDamage(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if any telemissiles are in a hex with enemy units. If so,
&nbsp;     * then attack one.
&nbsp;     */
&nbsp;    private void checkForTeleMissileAttacks() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if (entity instanceof TeleMissile) {</b>
&nbsp;                // check for enemy units
<b class="nc">&nbsp;                Vector&lt;Integer&gt; potTargets = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Entity te : game.getEntitiesVector(entity.getPosition())) {</b>
&nbsp;                    //Telemissiles cannot target fighters or other telemissiles
&nbsp;                    //Fighters don&#39;t have a distinctive Etype flag, so we have to do
&nbsp;                    //this by exclusion.
<b class="nc">&nbsp;                    if (!(te.hasETypeFlag(Entity.ETYPE_DROPSHIP)</b>
<b class="nc">&nbsp;                            || te.hasETypeFlag(Entity.ETYPE_SMALL_CRAFT)</b>
<b class="nc">&nbsp;                            || te.hasETypeFlag(Entity.ETYPE_JUMPSHIP)</b>
<b class="nc">&nbsp;                            || te.hasETypeFlag(Entity.ETYPE_WARSHIP)</b>
<b class="nc">&nbsp;                            || te.hasETypeFlag(Entity.ETYPE_SPACE_STATION))) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (te.isEnemyOf(entity)) {</b>
&nbsp;                        // then add it to a vector of potential targets
<b class="nc">&nbsp;                        potTargets.add(te.getId());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (potTargets.size() &gt; 0) {</b>
&nbsp;                    // determine randomly
<b class="nc">&nbsp;                    Entity target = game.getEntity(potTargets.get(Compute</b>
<b class="nc">&nbsp;                            .randomInt(potTargets.size())));</b>
&nbsp;                    // report this and add a new TeleMissileAttackAction
<b class="nc">&nbsp;                    Report r = new Report(9085);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.addDesc(target);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    game.addTeleMissileAttack(new TeleMissileAttackAction(entity, target));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void checkForBlueShieldDamage() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if (!(entity instanceof Aero) &amp;&amp; entity.hasActiveBlueShield()</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getBlueShieldRounds() &gt;= 6)) {</b>
<b class="nc">&nbsp;                int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                int target = (3 + entity.getBlueShieldRounds()) - 6;</b>
<b class="nc">&nbsp;                r = new Report(1240);</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(target);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                if (roll &lt; target) {</b>
<b class="nc">&nbsp;                    for (Mounted m : entity.getMisc()) {</b>
<b class="nc">&nbsp;                        if (m.getType().hasFlag(MiscType.F_BLUE_SHIELD)) {</b>
<b class="nc">&nbsp;                            m.setBreached(true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(false);</b>
&nbsp;                }
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if anyone dies due to being in certain planetary conditions.
&nbsp;     */
&nbsp;    private void checkForConditionDeath() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) &amp;&amp; !entity.isOffBoard() || (entity.getTransportId() != Entity.NONE)) {</b>
&nbsp;                // Ignore transported units, and units that don&#39;t have a position for some unknown reason
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            String reason = game.getPlanetaryConditions().whyDoomed(entity, game);</b>
<b class="nc">&nbsp;            if (null != reason) {</b>
<b class="nc">&nbsp;                r = new Report(6015);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.add(reason);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(destroyEntity(entity, reason, true, true));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if anyone dies due to being in atmosphere.
&nbsp;     */
&nbsp;    private void checkForAtmosphereDeath() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) || entity.isOffBoard()) {</b>
&nbsp;                // If it&#39;s not on the board - aboard something else, for
&nbsp;                // example...
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.doomedInAtmosphere() &amp;&amp; (entity.getAltitude() == 0)) {</b>
<b class="nc">&nbsp;                r = new Report(6016);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(destroyEntity(entity,</b>
&nbsp;                        &quot;being in atmosphere where it can&#39;t survive&quot;, true,
&nbsp;                        true));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * checks if IndustrialMechs should die because they moved into to-deep
&nbsp;     * water last round
&nbsp;     */
&nbsp;    private void checkForIndustrialWaterDeath() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) || entity.isOffBoard()) {</b>
&nbsp;                // If it&#39;s not on the board - aboard something else, for
&nbsp;                // example...
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity instanceof Mech) &amp;&amp; ((Mech) entity).isIndustrial()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((Mech) entity).shouldDieAtEndOfTurnBecauseOfWater()) {</b>
<b class="nc">&nbsp;                addReport(destroyEntity(entity,</b>
&nbsp;                        &quot;being in water without environmental shielding&quot;, true,
&nbsp;                        true));
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void checkForIndustrialEndOfTurn() {
<b class="nc">&nbsp;        checkForIndustrialWaterDeath();</b>
<b class="nc">&nbsp;        checkForIndustrialUnstall();</b>
<b class="nc">&nbsp;        checkForIndustrialCrit(); // This might hit an actuator or gyro, so...</b>
<b class="nc">&nbsp;        addReport(resolvePilotingRolls());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void checkForIndustrialUnstall() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            entity.checkUnstall(vPhaseReport);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * industrial mechs might need to check for critical damage
&nbsp;     */
&nbsp;    private void checkForIndustrialCrit() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((entity instanceof Mech) &amp;&amp; ((Mech) entity).isIndustrial()) {</b>
<b class="nc">&nbsp;                Mech mech = (Mech) entity;</b>
&nbsp;                // should we check for critical damage?
<b class="nc">&nbsp;                if (mech.isCheckForCrit()) {</b>
<b class="nc">&nbsp;                    Report r = new Report(5530);</b>
<b class="nc">&nbsp;                    r.addDesc(mech);</b>
<b class="nc">&nbsp;                    r.subject = mech.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
&nbsp;                    // for being hit by a physical weapon
<b class="nc">&nbsp;                    if (mech.getLevelsFallen() == 0) {</b>
<b class="nc">&nbsp;                        r = new Report(5531);</b>
<b class="nc">&nbsp;                        r.subject = mech.getId();</b>
&nbsp;                        // or for falling
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(5532);</b>
<b class="nc">&nbsp;                        r.subject = mech.getId();</b>
<b class="nc">&nbsp;                        r.add(mech.getLevelsFallen());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    HitData newHit = mech.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(criticalEntity(mech,</b>
<b class="nc">&nbsp;                            newHit.getLocation(), newHit.isRear(),</b>
<b class="nc">&nbsp;                            mech.getLevelsFallen(), 0));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if anyone dies due to being in space.
&nbsp;     */
&nbsp;    private void checkForSpaceDeath() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) || entity.isOffBoard()) {</b>
&nbsp;                // If it&#39;s not on the board - aboard something else, for
&nbsp;                // example...
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.doomedInSpace()) {</b>
<b class="nc">&nbsp;                r = new Report(6017);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(destroyEntity(entity,</b>
&nbsp;                        &quot;being in space where it can&#39;t survive&quot;, true, true));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if any entities are underwater (or in vacuum) with damaged
&nbsp;     * life support. Called during the end phase.
&nbsp;     */
&nbsp;    private void checkForSuffocation() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext();) {</b>
<b class="nc">&nbsp;            final Entity entity = i.next();</b>
<b class="nc">&nbsp;            if ((null == entity.getPosition()) || entity.isOffBoard()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final IHex curHex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;            if ((((entity.getElevation() &lt; 0) &amp;&amp; ((curHex</b>
<b class="nc">&nbsp;                    .terrainLevel(Terrains.WATER) &gt; 1) || ((curHex</b>
<b class="nc">&nbsp;                    .terrainLevel(Terrains.WATER) == 1) &amp;&amp; entity.isProne()))) || game</b>
<b class="nc">&nbsp;                    .getPlanetaryConditions().isVacuum())</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                            Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0)) {
<b class="nc">&nbsp;                Report r = new Report(6020);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                addReport(damageCrew(entity, 1));</b>
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Iterates over all entities and gets rid of Narc pods attached to destroyed
&nbsp;     * or lost locations.
&nbsp;     */
&nbsp;    private void cleanupDestroyedNarcPods() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            i.next().clearDestroyedNarcPods();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves all built up piloting skill rolls. Used at end of weapons,
&nbsp;     * physical phases.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolvePilotingRolls() {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(resolvePilotingRolls(i.next()));</b>
&nbsp;        }
<b class="nc">&nbsp;        game.resetPSRs();</b>
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves and reports all piloting skill rolls for a single mech.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolvePilotingRolls(Entity entity) {
<b class="nc">&nbsp;        return resolvePilotingRolls(entity, false, entity.getPosition(),</b>
<b class="nc">&nbsp;                                    entity.getPosition());</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; resolvePilotingRolls(Entity entity, boolean moving,
&nbsp;                                                Coords src, Coords dest) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
&nbsp;        // dead and undeployed and offboard units don&#39;t need to.
<b class="nc">&nbsp;        if (entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard() || !entity.isDeployed()</b>
<b class="nc">&nbsp;                || (entity.getTransportId() != Entity.NONE)) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        // airborne units don&#39;t make piloting rolls, they make control rolls
<b class="nc">&nbsp;        if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // first, do extreme gravity PSR, because non-mechs do these, too
<b class="nc">&nbsp;        PilotingRollData rollTarget = null;</b>
<b class="nc">&nbsp;        for (Enumeration&lt;PilotingRollData&gt; i = game.getExtremeGravityPSRs(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final PilotingRollData roll = i.nextElement();</b>
<b class="nc">&nbsp;            if (roll.getEntityId() != entity.getId()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // found a roll, use it (there can be only 1 per entity)
<b class="nc">&nbsp;            rollTarget = roll;</b>
<b class="nc">&nbsp;            game.resetExtremeGravityPSRs(entity);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if ((rollTarget != null) &amp;&amp; (rollTarget.getValue() != TargetRoll.CHECK_FALSE)) {</b>
&nbsp;            // okay, print the info
<b class="nc">&nbsp;            r = new Report(2180);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(rollTarget.getLastPlainDesc());</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;            // roll
<b class="nc">&nbsp;            final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(2190);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(rollTarget.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(rollTarget.getDesc());</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            if ((diceRoll &lt; rollTarget.getValue())</b>
<b class="nc">&nbsp;                    || (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES)</b>
&nbsp;                    &amp;&amp; (diceRoll == 2))) {
<b class="nc">&nbsp;                r.choose(false);</b>
&nbsp;                // Report the fumble
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES)</b>
&nbsp;                    &amp;&amp; (diceRoll == 2)) {
<b class="nc">&nbsp;                    r.messageId = 2306;</b>
&nbsp;                }
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;                // walking and running, 1 damage per MP used more than we would
&nbsp;                // have normally
<b class="nc">&nbsp;                if ((entity.moved == EntityMovementType.MOVE_WALK)</b>
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_RUN)
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_SPRINT)
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT)) {
<b class="nc">&nbsp;                    if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                        int j = entity.mpUsed;</b>
<b class="nc">&nbsp;                        int damage = 0;</b>
<b class="nc">&nbsp;                        while (j &gt; entity.getRunningGravityLimit()) {</b>
<b class="nc">&nbsp;                            j--;</b>
<b class="nc">&nbsp;                            damage++;</b>
&nbsp;                        }
&nbsp;                        // Wee, direct internal damage
<b class="nc">&nbsp;                        vPhaseReport.addAll(doExtremeGravityDamage(entity,</b>
&nbsp;                                                                   damage));
<b class="nc">&nbsp;                    } else if (entity instanceof Tank) {</b>
&nbsp;                        // if we got a pavement bonus, take care of it
<b class="nc">&nbsp;                        int k = entity.gotPavementBonus ? 1 : 0;</b>
<b class="nc">&nbsp;                        if (!entity.gotPavementBonus) {</b>
<b class="nc">&nbsp;                            int j = entity.mpUsed;</b>
<b class="nc">&nbsp;                            int damage = 0;</b>
<b class="nc">&nbsp;                            while (j &gt; (entity.getRunMP(false, false, false) + k)) {</b>
<b class="nc">&nbsp;                                j--;</b>
<b class="nc">&nbsp;                                damage++;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            vPhaseReport.addAll(doExtremeGravityDamage(entity,</b>
&nbsp;                                                                       damage));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                // jumping
<b class="nc">&nbsp;                if ((entity.moved == EntityMovementType.MOVE_JUMP)</b>
&nbsp;                    &amp;&amp; (entity instanceof Mech)) {
&nbsp;                    // low g, 1 damage for each hex jumped further than
&nbsp;                    // possible normally
<b class="nc">&nbsp;                    if (game.getPlanetaryConditions().getGravity() &lt; 1) {</b>
<b class="nc">&nbsp;                        int j = entity.mpUsed;</b>
<b class="nc">&nbsp;                        int damage = 0;</b>
<b class="nc">&nbsp;                        while (j &gt; entity.getJumpMP(false)) {</b>
<b class="nc">&nbsp;                            j--;</b>
<b class="nc">&nbsp;                            damage++;</b>
&nbsp;                        }
&nbsp;                        // Wee, direct internal damage
<b class="nc">&nbsp;                        vPhaseReport.addAll(doExtremeGravityDamage(entity,</b>
&nbsp;                                                                   damage));
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // high g, 1 damage for each MP we have less than normally
<b class="nc">&nbsp;                    else if (game.getPlanetaryConditions().getGravity() &gt; 1) {</b>
<b class="nc">&nbsp;                        int damage = entity.getWalkMP(false, false)</b>
<b class="nc">&nbsp;                                     - entity.getWalkMP();</b>
&nbsp;                        // Wee, direct internal damage
<b class="nc">&nbsp;                        vPhaseReport.addAll(doExtremeGravityDamage(entity,</b>
&nbsp;                                                                   damage));
&nbsp;                    }
&nbsp;                }
&nbsp;                // failed a PSR, check for ICE engine stalling
<b class="nc">&nbsp;                entity.doCheckEngineStallRoll(vPhaseReport);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Glider ProtoMechs without sufficient movement to stay airborne make forced landings.
<b class="nc">&nbsp;        if ((entity instanceof Protomech) &amp;&amp; ((Protomech)entity).isGlider()</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isAirborneVTOLorWIGE() &amp;&amp; (entity.getRunMP() &lt; 4)) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(landGliderPM((Protomech) entity, entity.getPosition(), entity.getElevation(),</b>
&nbsp;                    entity.delta_distance));
&nbsp;        }
&nbsp;
&nbsp;        // non mechs and prone mechs can now return
<b class="nc">&nbsp;        if (!entity.canFall() || (entity.isHullDown() &amp;&amp; entity.canGoHullDown())) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mechs with UMU float and don&#39;t have to roll???
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;            int water = hex.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;            if ((water &gt; 0) &amp;&amp; (entity.getElevation() != -hex.depth(true))</b>
<b class="nc">&nbsp;                    &amp;&amp; ((entity.getElevation() &lt; 0) || ((entity.getElevation() == 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (hex.terrainLevel(Terrains.BRIDGE_ELEV) != 0) &amp;&amp; !hex.containsTerrain(Terrains.ICE)))</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isMakingDfa() &amp;&amp; !entity.isDropping()) {</b>
&nbsp;                // mech is floating in water....
<b class="nc">&nbsp;                if (entity.hasUMU()) {</b>
<b class="nc">&nbsp;                    return vPhaseReport;</b>
&nbsp;                }
&nbsp;                // game.addPSR(new PilotingRollData(entity.getId(),
&nbsp;                // TargetRoll.AUTOMATIC_FAIL, &quot;lost buoyancy&quot;));
&nbsp;            }
&nbsp;        }
&nbsp;        // add all cumulative mods from other rolls to each PSR
&nbsp;        // holds all rolls to make
<b class="nc">&nbsp;        Vector&lt;PilotingRollData&gt; rolls = new Vector&lt;&gt;();</b>
&nbsp;        // holds the initial reason for each roll
<b class="nc">&nbsp;        StringBuilder reasons = new StringBuilder();</b>
<b class="nc">&nbsp;        PilotingRollData base = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;        entity.addPilotingModifierForTerrain(base);</b>
<b class="nc">&nbsp;        for (Enumeration&lt;PilotingRollData&gt; i = game.getPSRs(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            PilotingRollData psr = i.nextElement();</b>
<b class="nc">&nbsp;            if (psr.getEntityId() != entity.getId()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // found a roll
<b class="nc">&nbsp;            if (reasons.length() &gt; 0) {</b>
<b class="nc">&nbsp;                reasons.append(&quot;; &quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            reasons.append(psr.getPlainDesc());</b>
<b class="nc">&nbsp;            PilotingRollData toUse = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            entity.addPilotingModifierForTerrain(toUse);</b>
<b class="nc">&nbsp;            toUse.append(psr);</b>
&nbsp;            // now, append all other roll&#39;s cumulative mods, not the
&nbsp;            // non-cumulative
&nbsp;            // ones
<b class="nc">&nbsp;            for (Enumeration&lt;PilotingRollData&gt; j = game.getPSRs(); j.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                final PilotingRollData other = j.nextElement();</b>
<b class="nc">&nbsp;                if ((other.getEntityId() != entity.getId()) || other.equals(psr)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                toUse.append(other, false);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            rolls.add(toUse);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // any rolls needed?
<b class="nc">&nbsp;        if (rolls.size() == 0) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;        // is our base roll impossible?
<b class="nc">&nbsp;        if ((base.getValue() == TargetRoll.AUTOMATIC_FAIL) || (base.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
<b class="nc">&nbsp;            r = new Report(2275);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(rolls.size());</b>
<b class="nc">&nbsp;            r.add(base.getDesc()); // international issue</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            if (moving) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest,</b>
&nbsp;                        base, true));
<b class="nc">&nbsp;            } else if ((entity instanceof Mech) &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                    OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
<b class="nc">&nbsp;                    &amp;&amp; (entity.getCrew().getPiloting() &lt; 6)</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                if (entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                    r = new Report(2317);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFall(entity, base));</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                vPhaseReport.addAll(doEntityFall(entity, base));</b>
&nbsp;            }
&nbsp;            // failed a PSR, check for ICE engine stalling
<b class="nc">&nbsp;            entity.doCheckEngineStallRoll(vPhaseReport);</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;        // loop through rolls we do have to make...
<b class="nc">&nbsp;        r = new Report(2280);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.addDesc(entity);</b>
<b class="nc">&nbsp;        r.add(rolls.size());</b>
<b class="nc">&nbsp;        r.add(reasons.toString()); // international issue</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        r = new Report(2285);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(base.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(base.getDesc()); // international issue</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; rolls.size(); i++) {</b>
<b class="nc">&nbsp;            PilotingRollData roll = rolls.elementAt(i);</b>
<b class="nc">&nbsp;            r = new Report(2290);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.add(i + 1);</b>
<b class="nc">&nbsp;            r.add(roll.getDesc()); // international issue</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            if ((roll.getValue() == TargetRoll.AUTOMATIC_FAIL)</b>
<b class="nc">&nbsp;                || (roll.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
<b class="nc">&nbsp;                r = new Report(2295);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                if (moving) {</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFallsInto(entity, entity.getElevation(), src, dest,</b>
&nbsp;                            roll, true));
&nbsp;                } else {
<b class="nc">&nbsp;                    if ((entity instanceof Mech) &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
<b class="nc">&nbsp;                            &amp;&amp; (entity.getCrew().getPiloting() &lt; 6)</b>
<b class="nc">&nbsp;                            &amp;&amp; !entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                        if (entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                            r = new Report(2317);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            vPhaseReport.addAll(doEntityFall(entity, roll));</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        vPhaseReport.addAll(doEntityFall(entity, roll));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // failed a PSR, check for ICE engine stalling
<b class="nc">&nbsp;                entity.doCheckEngineStallRoll(vPhaseReport);</b>
<b class="nc">&nbsp;                return vPhaseReport;</b>
&nbsp;            }
<b class="nc">&nbsp;            int diceRoll = entity.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;            r = new Report(2300);</b>
<b class="nc">&nbsp;            r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            if ((diceRoll &lt; roll.getValue())</b>
<b class="nc">&nbsp;                || (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES) &amp;&amp; (diceRoll == 2))) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
&nbsp;                // Report the fumble
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FUMBLES)</b>
&nbsp;                    &amp;&amp; (diceRoll == 2)) {
<b class="nc">&nbsp;                    r.messageId = 2306;</b>
&nbsp;                }
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                if (moving) {</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFallsInto(entity,</b>
<b class="nc">&nbsp;                                                          entity.getElevation(), src, dest, roll, true));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if ((entity instanceof Mech)</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                            OptionsConstants.ADVGRNDMOV_TACOPS_FALLING_EXPANDED)
<b class="nc">&nbsp;                        &amp;&amp; (entity.getCrew().getPiloting() &lt; 6)</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                        if ((entity.getCrew().getPiloting() &gt; 1)</b>
<b class="nc">&nbsp;                            &amp;&amp; ((roll.getValue() - diceRoll) &lt; 2)) {</b>
<b class="nc">&nbsp;                            entity.setHullDown(true);</b>
<b class="nc">&nbsp;                        } else if ((entity.getCrew().getPiloting() &lt;= 1)</b>
<b class="nc">&nbsp;                                   &amp;&amp; ((roll.getValue() - diceRoll) &lt; 3)) {</b>
<b class="nc">&nbsp;                            entity.setHullDown(true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (entity.isHullDown() &amp;&amp; entity.canGoHullDown()) {</b>
<b class="nc">&nbsp;                            ServerHelper.sinkToBottom(entity);</b>
&nbsp;                            
<b class="nc">&nbsp;                            r = new Report(2317);</b>
<b class="nc">&nbsp;                            r.subject = entity.getId();</b>
<b class="nc">&nbsp;                            r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            vPhaseReport.addAll(doEntityFall(entity, roll));</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        vPhaseReport.addAll(doEntityFall(entity, roll));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // failed a PSR, check for ICE engine stalling
<b class="nc">&nbsp;                entity.doCheckEngineStallRoll(vPhaseReport);</b>
<b class="nc">&nbsp;                return vPhaseReport;</b>
&nbsp;            }
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; checkForTraitors() {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vFullReport = new Vector&lt;&gt;();</b>
&nbsp;        // check for traitors
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Entity entity = i.next();</b>
<b class="nc">&nbsp;            if (entity.isDoomed() || entity.isDestroyed() || entity.isOffBoard()</b>
<b class="nc">&nbsp;                    || !entity.isDeployed()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity.getTraitorId() != -1) &amp;&amp; (entity.getOwnerId() != entity.getTraitorId())) {</b>
<b class="nc">&nbsp;                IPlayer p = game.getPlayer(entity.getTraitorId());</b>
<b class="nc">&nbsp;                if (null != p) {</b>
<b class="nc">&nbsp;                    Report r = new Report(7305);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                    r.add(p.getName());</b>
<b class="nc">&nbsp;                    entity.setOwner(p);</b>
<b class="nc">&nbsp;                    entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;                    vFullReport.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                entity.setTraitorId(-1);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (!vFullReport.isEmpty()) {</b>
<b class="nc">&nbsp;            vFullReport.add(0, new Report(7300));</b>
&nbsp;        }
<b class="nc">&nbsp;        return vFullReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves all built up control rolls. Used only during end phase
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolveControlRolls() {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vFullReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        vFullReport.add(new Report(5001, Report.PUBLIC));</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            vFullReport.addAll(resolveControl(i.next()));</b>
&nbsp;        }
<b class="nc">&nbsp;        game.resetControlRolls();</b>
<b class="nc">&nbsp;        return vFullReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves and reports all control skill rolls for a single aero or airborne LAM in airmech mode.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolveControl(Entity e) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        if (e.isDoomed() || e.isDestroyed() || e.isOffBoard() || !e.isDeployed()) {</b>
<b class="nc">&nbsp;            return vReport;</b>
&nbsp;        }
&nbsp;        Report r;
&nbsp;
&nbsp;        /*
&nbsp;         * See forum answers on OOC
&nbsp;         * http://forums.classicbattletech.com/index.php/topic,20424.0.html
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;        IAero a = null;</b>
<b class="nc">&nbsp;        boolean canRecover = false;</b>
<b class="nc">&nbsp;        if (e.isAero() &amp;&amp; (e.isAirborne() || e.isSpaceborne())) {</b>
<b class="nc">&nbsp;            a = (IAero) e;</b>
&nbsp;            // they should get a shot at a recovery roll at the end of all this
&nbsp;            // if they are already out of control
<b class="nc">&nbsp;            canRecover = a.isOutControl();</b>
<b class="nc">&nbsp;        } else if (!(e instanceof LandAirMech) || !e.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            return vReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if the unit already is moving randomly then it can&#39;t get any
&nbsp;        // worse
<b class="nc">&nbsp;        if (a == null || !a.isRandomMove()) {</b>
&nbsp;
&nbsp;            // find control rolls and make them
<b class="nc">&nbsp;            Vector&lt;PilotingRollData&gt; rolls = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            StringBuilder reasons = new StringBuilder();</b>
<b class="nc">&nbsp;            PilotingRollData target = e.getBasePilotingRoll();</b>
&nbsp;            // maneuvering ace
&nbsp;            // TODO : pending rules query
&nbsp;            // http://www.classicbattletech.com/forums/index.php/topic,63552.new.html#new
&nbsp;            // for now I am assuming Man Ace applies to all out-of-control
&nbsp;            // rolls, but not other
&nbsp;            // uses of control rolls (thus it doesn&#39;t go in
&nbsp;            // Entity#addEntityBonuses) and
&nbsp;            // furthermore it doesn&#39;t apply to recovery rolls
<b class="nc">&nbsp;            if (e.isUsingManAce()) {</b>
<b class="nc">&nbsp;                target.addModifier(-1, &quot;maneuvering ace&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Enumeration&lt;PilotingRollData&gt; j = game.getControlRolls(); j.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                final PilotingRollData modifier = j.nextElement();</b>
<b class="nc">&nbsp;                if (modifier.getEntityId() != e.getId()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // found a roll, add it
<b class="nc">&nbsp;                rolls.addElement(modifier);</b>
<b class="nc">&nbsp;                if (reasons.length() &gt; 0) {</b>
<b class="nc">&nbsp;                    reasons.append(&quot;; &quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                reasons.append(modifier.getCumulativePlainDesc());</b>
<b class="nc">&nbsp;                target.append(modifier);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // any rolls needed?
<b class="nc">&nbsp;            if (rolls.size() &gt; 0) {</b>
&nbsp;                // loop through rolls we do have to make...
<b class="nc">&nbsp;                r = new Report(9310);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                r.add(rolls.size());</b>
<b class="nc">&nbsp;                r.add(reasons.toString()); // international issue</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
<b class="nc">&nbsp;                r = new Report(2285);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.add(target.getValueAsString());</b>
<b class="nc">&nbsp;                r.add(target.getDesc()); // international issue</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
<b class="nc">&nbsp;                for (int j = 0; j &lt; rolls.size(); j++) {</b>
<b class="nc">&nbsp;                    PilotingRollData modifier = rolls.elementAt(j);</b>
<b class="nc">&nbsp;                    r = new Report(2290);</b>
<b class="nc">&nbsp;                    r.subject = e.getId();</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    r.add(j + 1);</b>
<b class="nc">&nbsp;                    r.add(modifier.getPlainDesc()); // international issue</b>
<b class="nc">&nbsp;                    vReport.add(r);</b>
<b class="nc">&nbsp;                    int diceRoll = Compute.d6(2);</b>
&nbsp;                    // different reports depending on out-of-control status
<b class="nc">&nbsp;                    if (a != null &amp;&amp; a.isOutControl()) {</b>
<b class="nc">&nbsp;                        r = new Report(9360);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.add(target.getValueAsString());</b>
<b class="nc">&nbsp;                        r.add(diceRoll);</b>
<b class="nc">&nbsp;                        if (diceRoll &lt; (target.getValue() - 5)) {</b>
<b class="nc">&nbsp;                            r.choose(false);</b>
<b class="nc">&nbsp;                            vReport.add(r);</b>
<b class="nc">&nbsp;                            a.setRandomMove(true);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r.choose(true);</b>
<b class="nc">&nbsp;                            vReport.add(r);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(9315);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.add(target.getValueAsString());</b>
<b class="nc">&nbsp;                        r.add(diceRoll);</b>
<b class="nc">&nbsp;                        r.newlines = 1;</b>
<b class="nc">&nbsp;                        if (diceRoll &lt; target.getValue()) {</b>
<b class="nc">&nbsp;                            r.choose(false);</b>
<b class="nc">&nbsp;                            vReport.add(r);</b>
<b class="nc">&nbsp;                            if (a != null) {</b>
<b class="nc">&nbsp;                                a.setOutControl(true);</b>
&nbsp;                                // do we have random movement?
<b class="nc">&nbsp;                                if ((target.getValue() - diceRoll) &gt; 5) {</b>
<b class="nc">&nbsp;                                    r = new Report(9365);</b>
<b class="nc">&nbsp;                                    r.newlines = 0;</b>
<b class="nc">&nbsp;                                    r.subject = e.getId();</b>
<b class="nc">&nbsp;                                    vReport.add(r);</b>
<b class="nc">&nbsp;                                    a.setRandomMove(true);</b>
&nbsp;                                }
&nbsp;                                // if on the atmospheric map, then lose altitude
&nbsp;                                // and check
&nbsp;                                // for crash
<b class="nc">&nbsp;                                if (!a.isSpaceborne() &amp;&amp; a.isAirborne()) {</b>
<b class="nc">&nbsp;                                    int loss = Compute.d6(1);</b>
<b class="nc">&nbsp;                                    int origAltitude = e.getAltitude();</b>
<b class="nc">&nbsp;                                    e.setAltitude(e.getAltitude() - loss);</b>
&nbsp;                                    //Reroll altitude loss with edge if the new altitude would result in a crash
<b class="nc">&nbsp;                                    if (e.getAltitude() &lt;= 0</b>
&nbsp;                                            //Don&#39;t waste the edge if it won&#39;t help
&nbsp;                                            &amp;&amp; origAltitude &gt; 1
<b class="nc">&nbsp;                                            &amp;&amp; e.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                            &amp;&amp; e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_ALT_LOSS)) {</b>
<b class="nc">&nbsp;                                        loss = Compute.d6(1);</b>
&nbsp;                                        //Report the edge use
<b class="nc">&nbsp;                                        r = new Report(9367);</b>
<b class="nc">&nbsp;                                        r.newlines = 1;</b>
<b class="nc">&nbsp;                                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                                        vReport.add(r);</b>
<b class="nc">&nbsp;                                        e.setAltitude(origAltitude - loss);</b>
&nbsp;                                        // and spend the edge point
<b class="nc">&nbsp;                                        e.getCrew().decreaseEdge();</b>
&nbsp;                                    }
&nbsp;                                    //Report the altitude loss
<b class="nc">&nbsp;                                    r = new Report(9366);</b>
<b class="nc">&nbsp;                                    r.newlines = 0;</b>
<b class="nc">&nbsp;                                    r.subject = e.getId();</b>
<b class="nc">&nbsp;                                    r.addDesc(e);</b>
<b class="nc">&nbsp;                                    r.add(loss);</b>
<b class="nc">&nbsp;                                    vReport.add(r);</b>
&nbsp;                                    // check for crash
<b class="nc">&nbsp;                                    if (checkCrash(e, e.getPosition(),</b>
<b class="nc">&nbsp;                                            e.getAltitude())) {</b>
<b class="nc">&nbsp;                                        vReport.addAll(processCrash(e,</b>
<b class="nc">&nbsp;                                                a.getCurrentVelocity(),</b>
<b class="nc">&nbsp;                                                e.getPosition()));</b>
<b class="nc">&nbsp;                                        break;</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            } else if (e instanceof LandAirMech &amp;&amp; e.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                                int loss = target.getValue() - diceRoll;</b>
<b class="nc">&nbsp;                                r = new Report(9366);</b>
<b class="nc">&nbsp;                                r.subject = e.getId();</b>
<b class="nc">&nbsp;                                r.addDesc(e);</b>
<b class="nc">&nbsp;                                r.add(loss);</b>
<b class="nc">&nbsp;                                vReport.add(r);</b>
<b class="nc">&nbsp;                                IHex hex = game.getBoard().getHex(e.getPosition());</b>
<b class="nc">&nbsp;                                int elevation = Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;                                if (e.getElevation() - loss &lt;= elevation) {</b>
<b class="nc">&nbsp;                                    crashAirMech(e, target, vReport);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    e.setElevation(e.getElevation() - loss);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r.choose(true);</b>
<b class="nc">&nbsp;                            vReport.add(r);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if they were out-of-control to start with, give them a chance to
&nbsp;        // regain control
<b class="nc">&nbsp;        if (canRecover) {</b>
<b class="nc">&nbsp;            PilotingRollData base = e.getBasePilotingRoll();</b>
&nbsp;            // is our base roll impossible?
<b class="nc">&nbsp;            if ((base.getValue() == TargetRoll.AUTOMATIC_FAIL)</b>
<b class="nc">&nbsp;                    || (base.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
&nbsp;                // report something
<b class="nc">&nbsp;                r = new Report(9340);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                r.add(base.getDesc()); // international issue</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
<b class="nc">&nbsp;                return vReport;</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report(9345);</b>
<b class="nc">&nbsp;            r.subject = e.getId();</b>
<b class="nc">&nbsp;            r.addDesc(e);</b>
<b class="nc">&nbsp;            r.add(base.getDesc()); // international issue</b>
<b class="nc">&nbsp;            vReport.add(r);</b>
<b class="nc">&nbsp;            int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(9350);</b>
<b class="nc">&nbsp;            r.subject = e.getId();</b>
<b class="nc">&nbsp;            r.add(base.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            if (diceRoll &lt; base.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
<b class="nc">&nbsp;                a.setOutControl(false);</b>
<b class="nc">&nbsp;                a.setOutCtrlHeat(false);</b>
<b class="nc">&nbsp;                a.setRandomMove(false);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inflict damage on a pilot
&nbsp;     *
&nbsp;     * @param en     The &lt;code&gt;Entity&lt;/code&gt; who&#39;s pilot gets damaged.
&nbsp;     * @param damage The &lt;code&gt;int&lt;/code&gt; amount of damage.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageCrew(Entity en, int damage) {
<b class="nc">&nbsp;        return damageCrew(en, damage, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inflict damage on a pilot
&nbsp;     *
&nbsp;     * @param en        The &lt;code&gt;Entity&lt;/code&gt; who&#39;s pilot gets damaged.
&nbsp;     * @param damage    The &lt;code&gt;int&lt;/code&gt; amount of damage.
&nbsp;     * @param crewPos   The &lt;code&gt;int&lt;/code&gt;position of the crew member in a &lt;code&gt;MultiCrewCockpit&lt;/crew&gt;
&nbsp;     *                  that takes the damage. A value &lt; 0 applies the damage to all crew members.
&nbsp;     *                  The basic &lt;crew&gt;Crew&lt;/crew&gt; ignores this value.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageCrew(Entity en, int damage, int crewPos) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        Crew crew = en.getCrew();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (!crew.isDead() &amp;&amp; !crew.isEjected() &amp;&amp; !crew.isDoomed()) {</b>
<b class="nc">&nbsp;            for (int pos = 0; pos &lt; en.getCrew().getSlotCount(); pos++) {</b>
<b class="nc">&nbsp;                if (crewPos &gt;= 0</b>
<b class="nc">&nbsp;                        &amp;&amp; (crewPos != pos || crew.isDead(crewPos))) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                boolean wasPilot = crew.getCurrentPilotIndex() == pos;</b>
<b class="nc">&nbsp;                boolean wasGunner = crew.getCurrentGunnerIndex() == pos;</b>
<b class="nc">&nbsp;                crew.setHits(crew.getHits(pos) + damage, pos);</b>
<b class="nc">&nbsp;                if (en.isLargeCraft()) {</b>
<b class="nc">&nbsp;                    r = new Report (6028);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.addDesc(en);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    if (((Aero)en).isEjecting()) {</b>
<b class="nc">&nbsp;                        r.add(&quot;as crew depart the ship&quot;);</b>
&nbsp;                    } else {
&nbsp;                        //Blank data
<b class="nc">&nbsp;                        r.add(&quot;&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.add(crew.getHits(pos));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    if (Crew.DEATH &gt; crew.getHits()) {</b>
<b class="nc">&nbsp;                        vDesc.addAll(resolveCrewDamage(en, damage, pos));</b>
<b class="nc">&nbsp;                    } else if (!crew.isDoomed()) {</b>
<b class="nc">&nbsp;                        crew.setDoomed(true);</b>
&nbsp;                        //Safety. We might use this logic for large naval vessels later on
<b class="nc">&nbsp;                        if (en instanceof Aero &amp;&amp; ((Aero)en).isEjecting()) {</b>
<b class="nc">&nbsp;                            vDesc.addAll(destroyEntity(en, &quot;ejection&quot;, true));</b>
<b class="nc">&nbsp;                            ((Aero)en).setEjecting(false);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            vDesc.addAll(destroyEntity(en, &quot;crew casualties&quot;, true));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    if (Crew.DEATH &gt; crew.getHits(pos)) {</b>
<b class="nc">&nbsp;                        r = new Report(6025);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(6026);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.add(crew.getCrewType().getRoleName(pos));</b>
<b class="nc">&nbsp;                    r.addDesc(en);</b>
<b class="nc">&nbsp;                    r.add(crew.getName(pos));</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    r.add(crew.getHits(pos));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    if (crew.isDead(pos)) {</b>
<b class="nc">&nbsp;                        r = createCrewTakeoverReport(en, pos, wasPilot, wasGunner);</b>
<b class="nc">&nbsp;                        if (null != r) {</b>
<b class="nc">&nbsp;                            vDesc.addElement(r);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (Crew.DEATH &gt; crew.getHits()) {</b>
<b class="nc">&nbsp;                        vDesc.addAll(resolveCrewDamage(en, damage, pos));</b>
<b class="nc">&nbsp;                    } else if (!crew.isDoomed()) {</b>
<b class="nc">&nbsp;                        crew.setDoomed(true);</b>
<b class="nc">&nbsp;                        vDesc.addAll(destroyEntity(en, &quot;pilot death&quot;, true));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            boolean isPilot = (en instanceof Mech) || ((en instanceof Aero)</b>
&nbsp;                    &amp;&amp; !(en instanceof SmallCraft) &amp;&amp; !(en instanceof Jumpship));
<b class="nc">&nbsp;            if (crew.isDead() || crew.isDoomed()) {</b>
<b class="nc">&nbsp;                if (isPilot) {</b>
<b class="nc">&nbsp;                    r = new Report(6021);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(6022);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (isPilot) {</b>
<b class="nc">&nbsp;                    r = new Report(6023);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(6024);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.addDesc(en);</b>
<b class="nc">&nbsp;            r.add(crew.getName());</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (en.isAirborneVTOLorWIGE() &amp;&amp; !en.getCrew().isActive()) {</b>
<b class="nc">&nbsp;            if (en instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                crashAirMech(en, en.getBasePilotingRoll(), vDesc);</b>
<b class="nc">&nbsp;            } else if (en instanceof Protomech) {</b>
<b class="nc">&nbsp;                vDesc.addAll(landGliderPM((Protomech)en));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that fills in a report showing that a crew member of a multicrew cockpit
&nbsp;     * has taken over for another incapacitated crew member.
&nbsp;     *
&nbsp;     * @param e         The &lt;code&gt;Entity&lt;/code&gt; for the crew.
&nbsp;     * @param slot      The slot index of the crew member that was incapacitated.
&nbsp;     * @param wasPilot  Whether the crew member was the pilot before becoming incapacitated.
&nbsp;     * @param wasGunner Whether the crew member was the gunner before becoming incapacitated.
&nbsp;     * @return          A completed &lt;code&gt;Report&lt;/code&gt; if the position was assumed by another
&nbsp;     *                  crew members, otherwise null.
&nbsp;     */
&nbsp;    private Report createCrewTakeoverReport(Entity e, int slot, boolean wasPilot, boolean wasGunner) {
<b class="nc">&nbsp;        if (wasPilot &amp;&amp; e.getCrew().getCurrentPilotIndex() != slot) {</b>
<b class="nc">&nbsp;            Report r = new Report(5560);</b>
<b class="nc">&nbsp;            r.subject = e.getId();</b>
<b class="nc">&nbsp;            r.indent(4);</b>
<b class="nc">&nbsp;            r.add(e.getCrew().getNameAndRole(e.getCrew().getCurrentPilotIndex()));</b>
<b class="nc">&nbsp;            r.add(e.getCrew().getCrewType().getRoleName(e.getCrew().getCrewType().getPilotPos()));</b>
<b class="nc">&nbsp;            r.addDesc(e);</b>
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (wasGunner &amp;&amp; e.getCrew().getCurrentGunnerIndex() != slot) {</b>
<b class="nc">&nbsp;            Report r = new Report(5560);</b>
<b class="nc">&nbsp;            r.subject = e.getId();</b>
<b class="nc">&nbsp;            r.indent(4);</b>
<b class="nc">&nbsp;            r.add(e.getCrew().getNameAndRole(e.getCrew().getCurrentGunnerIndex()));</b>
<b class="nc">&nbsp;            r.add(e.getCrew().getCrewType().getRoleName(e.getCrew().getCrewType().getGunnerPos()));</b>
<b class="nc">&nbsp;            r.addDesc(e);</b>
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * resolves consciousness rolls for one entity
&nbsp;     *
&nbsp;     * @param e         The &lt;code&gt;Entity&lt;/code&gt; that took damage
&nbsp;     * @param damage    The &lt;code&gt;int&lt;/code&gt; damage taken by the pilot
&nbsp;     * @param crewPos   The &lt;code&gt;int&lt;/code&gt; index of the crew member for multi crew cockpits, ignored by
&nbsp;     *                  basic &lt;code&gt;crew&lt;/code&gt;
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolveCrewDamage(Entity e, int damage, int crewPos) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        final int totalHits = e.getCrew().getHits(crewPos);</b>
<b class="nc">&nbsp;        if ((e instanceof MechWarrior) || !e.isTargetable()</b>
<b class="nc">&nbsp;            || !e.getCrew().isActive(crewPos) || (damage == 0)) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // no consciousness roll for pain-shunted warriors
<b class="nc">&nbsp;        if (e.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // no consciousness roll for capital fighter pilots or large craft crews
<b class="nc">&nbsp;        if (e.isCapitalFighter() || e.isLargeCraft()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int hit = (totalHits - damage) + 1; hit &lt;= totalHits; hit++) {</b>
<b class="nc">&nbsp;            int rollTarget = Compute.getConsciousnessNumber(hit);</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.RPG_TOUGHNESS)) {</b>
<b class="nc">&nbsp;                rollTarget -= e.getCrew().getToughness(crewPos);</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean edgeUsed = false;</b>
&nbsp;            do {
<b class="nc">&nbsp;                if (edgeUsed) {</b>
<b class="nc">&nbsp;                    e.getCrew().decreaseEdge();</b>
&nbsp;                }
<b class="nc">&nbsp;                int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                if (e.hasAbility(OptionsConstants.MISC_PAIN_RESISTANCE)) {</b>
<b class="nc">&nbsp;                    roll = Math.min(12, roll + 1);</b>
&nbsp;                }
<b class="nc">&nbsp;                Report r = new Report(6030);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.add(e.getCrew().getCrewType().getRoleName(crewPos));</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                r.add(e.getCrew().getName(crewPos));</b>
<b class="nc">&nbsp;                r.add(rollTarget);</b>
<b class="nc">&nbsp;                r.add(roll);</b>
<b class="nc">&nbsp;                if (roll &gt;= rollTarget) {</b>
<b class="nc">&nbsp;                    e.getCrew().setKoThisRound(false, crewPos);</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    e.getCrew().setKoThisRound(true, crewPos);</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    if (e.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; (e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_KO)</b>
<b class="nc">&nbsp;                            || e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_KO))) {</b>
<b class="nc">&nbsp;                        edgeUsed = true;</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
<b class="nc">&nbsp;                        r = new Report(6520);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(e);</b>
<b class="nc">&nbsp;                        r.add(e.getCrew().getName(crewPos));</b>
<b class="nc">&nbsp;                        r.add(e.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
&nbsp;                    } // if
&nbsp;                    // return true;
&nbsp;                } // else
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;            } while (e.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                     &amp;&amp; e.getCrew().isKoThisRound(crewPos)</b>
<b class="nc">&nbsp;                     &amp;&amp; (e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_KO)</b>
<b class="nc">&nbsp;                         || e.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_KO)));</b>
&nbsp;            // end of do-while
<b class="nc">&nbsp;            if (e.getCrew().isKoThisRound(crewPos)) {</b>
<b class="nc">&nbsp;                boolean wasPilot = e.getCrew().getCurrentPilotIndex() == crewPos;</b>
<b class="nc">&nbsp;                boolean wasGunner = e.getCrew().getCurrentGunnerIndex() == crewPos;</b>
<b class="nc">&nbsp;                e.getCrew().setUnconscious(true, crewPos);</b>
<b class="nc">&nbsp;                Report r = createCrewTakeoverReport(e, crewPos, wasPilot, wasGunner);</b>
<b class="nc">&nbsp;                if (null != r) {</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Make the rolls indicating whether any unconscious crews wake up
&nbsp;     */
&nbsp;    private void resolveCrewWakeUp() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity e = i.next();</b>
&nbsp;
&nbsp;            // only unconscious pilots of mechs and protos, ASF and Small Craft
&nbsp;            // and MechWarriors can roll to wake up
<b class="nc">&nbsp;            if (e.isTargetable()</b>
&nbsp;                    &amp;&amp; ((e instanceof Mech) || (e instanceof Protomech)
&nbsp;                            || (e instanceof MechWarrior) || ((e instanceof Aero) &amp;&amp; !(e instanceof Jumpship)))) {
<b class="nc">&nbsp;                for (int pos = 0; pos &lt; e.getCrew().getSlotCount(); pos++) {</b>
<b class="nc">&nbsp;                    if (e.getCrew().isMissing(pos)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (e.getCrew().isUnconscious(pos)</b>
<b class="nc">&nbsp;                            &amp;&amp; !e.getCrew().isKoThisRound(pos)) {</b>
<b class="nc">&nbsp;                        int roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;                        if (e.hasAbility(OptionsConstants.MISC_PAIN_RESISTANCE)) {</b>
<b class="nc">&nbsp;                            roll = Math.min(12, roll + 1);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        int rollTarget = Compute.getConsciousnessNumber(e.getCrew()</b>
<b class="nc">&nbsp;                                                                         .getHits(pos));</b>
<b class="nc">&nbsp;                        Report r = new Report(6029);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.add(e.getCrew().getCrewType().getRoleName(pos));</b>
<b class="nc">&nbsp;                        r.addDesc(e);</b>
<b class="nc">&nbsp;                        r.add(e.getCrew().getName(pos));</b>
<b class="nc">&nbsp;                        r.add(rollTarget);</b>
<b class="nc">&nbsp;                        r.add(roll);</b>
<b class="nc">&nbsp;                        if (roll &gt;= rollTarget) {</b>
<b class="nc">&nbsp;                            r.choose(true);</b>
<b class="nc">&nbsp;                            e.getCrew().setUnconscious(false, pos);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r.choose(false);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        addReport(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check whether any &lt;code&gt;Entity&lt;/code&gt; with a cockpit command console has been scheduled to swap
&nbsp;     * roles between the two crew members.
&nbsp;     */
&nbsp;    private void resolveConsoleCrewSwaps() {
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; i = game.getEntities(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            final Entity e = i.next();</b>
<b class="nc">&nbsp;            if (e.getCrew().doConsoleRoleSwap()) {</b>
<b class="nc">&nbsp;                final Crew crew = e.getCrew();</b>
<b class="nc">&nbsp;                final int current = crew.getCurrentPilotIndex();</b>
<b class="nc">&nbsp;                Report r = new Report(5560);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.add(crew.getNameAndRole(current));</b>
<b class="nc">&nbsp;                r.add(crew.getCrewType().getRoleName(0));</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Resolve any outstanding self destructions...
&nbsp;     */
&nbsp;    private void resolveSelfDestruct() {
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.getSelfDestructing()) {</b>
<b class="nc">&nbsp;                e.setSelfDestructing(false);</b>
<b class="nc">&nbsp;                e.setSelfDestructInitiated(true);</b>
<b class="nc">&nbsp;                Report r = new Report(5535, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Resolve any outstanding crashes from shutting down and being airborne
&nbsp;     * VTOL or WiGE...
&nbsp;     */
&nbsp;    private void resolveShutdownCrashes() {
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.isShutDown() &amp;&amp; e.isAirborneVTOLorWIGE()</b>
<b class="nc">&nbsp;                &amp;&amp; !(e.isDestroyed() || e.isDoomed())) {</b>
<b class="nc">&nbsp;                Tank t = (Tank) e;</b>
<b class="nc">&nbsp;                t.immobilize();</b>
<b class="nc">&nbsp;                addReport(forceLandVTOLorWiGE(t));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolve any potential fatal damage to Capital Fighter after each
&nbsp;     * individual attacker is finished
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; checkFatalThresholds(int nextAE, int prevAE) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; e = game.getEntities(); e.hasNext();) {</b>
<b class="nc">&nbsp;            Entity en = e.next();</b>
<b class="nc">&nbsp;            if (!en.isCapitalFighter() || (nextAE == Entity.NONE)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            IAero ship = (IAero) en;</b>
<b class="nc">&nbsp;            int damage = ship.getCurrentDamage();</b>
<b class="nc">&nbsp;            double divisor = 2.0;</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;                divisor = 20.0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (damage &gt;= ship.getFatalThresh()) {</b>
<b class="nc">&nbsp;                int roll = Compute.d6(2)</b>
<b class="nc">&nbsp;                        + (int) Math.floor((damage - ship.getFatalThresh())</b>
&nbsp;                                / divisor);
<b class="nc">&nbsp;                if (roll &gt; 9) {</b>
&nbsp;                    // Lets auto-eject if we can!
<b class="nc">&nbsp;                    if (ship instanceof LandAirMech) {</b>
&nbsp;                        // LAMs eject if the CT destroyed switch is on
<b class="nc">&nbsp;                        LandAirMech lam = (LandAirMech) ship;</b>
<b class="nc">&nbsp;                        if (lam.isAutoEject()</b>
<b class="nc">&nbsp;                            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                    || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                            &amp;&amp; lam.isCondEjectCTDest()))) {</b>
<b class="nc">&nbsp;                            addReport(ejectEntity(en, true, false));</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        // Aeros eject if the SI Destroyed switch is on
<b class="nc">&nbsp;                        Aero aero = (Aero) ship;</b>
<b class="nc">&nbsp;                        if (aero.isAutoEject()</b>
<b class="nc">&nbsp;                            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                    || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                            &amp;&amp; aero.isCondEjectSIDest()))) {</b>
<b class="nc">&nbsp;                            addReport(ejectEntity(en, true, false));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    vDesc.addAll(destroyEntity((Entity)ship, &quot;fatal damage threshold&quot;));</b>
<b class="nc">&nbsp;                    ship.doDisbandDamage();</b>
<b class="nc">&nbsp;                    if (prevAE != Entity.NONE) {</b>
<b class="nc">&nbsp;                        creditKill(en, game.getEntity(prevAE));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            ship.setCurrentDamage(0);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * damage an Entity
&nbsp;     *
&nbsp;     * @param te            the &lt;code&gt;Entity&lt;/code&gt; to be damaged
&nbsp;     * @param hit           the corresponding &lt;code&gt;HitData&lt;/code&gt;
&nbsp;     * @param damage        the &lt;code&gt;int&lt;/code&gt; amount of damage
&nbsp;     * @param ammoExplosion a &lt;code&gt;boolean&lt;/code&gt; indicating if this is an ammo explosion
&nbsp;     * @return a &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing the phase reports
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage,
&nbsp;                                        boolean ammoExplosion) {
<b class="nc">&nbsp;        return damageEntity(te, hit, damage, ammoExplosion, DamageType.NONE,</b>
&nbsp;                            false, false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deals the listed damage to an entity. Returns a vector of Reports for the
&nbsp;     * phase report
&nbsp;     *
&nbsp;     * @param te     the target entity
&nbsp;     * @param hit    the hit data for the location hit
&nbsp;     * @param damage the damage to apply
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage) {
<b class="nc">&nbsp;        return damageEntity(te, hit, damage, false, DamageType.NONE, false,</b>
&nbsp;                            false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deals the listed damage to an entity. Returns a vector of Reports for the
&nbsp;     * phase report
&nbsp;     *
&nbsp;     * @param te            the target entity
&nbsp;     * @param hit           the hit data for the location hit
&nbsp;     * @param damage        the damage to apply
&nbsp;     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
&nbsp;     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
&nbsp;     *                      smithereens
&nbsp;     * @param bFrag         The DamageType of the attack.
&nbsp;     * @param damageIS      Should the target location&#39;s internal structure be damaged
&nbsp;     *                      directly?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage,
&nbsp;                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS) {
<b class="nc">&nbsp;        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,</b>
&nbsp;                            false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deals the listed damage to an entity. Returns a vector of Reports for the
&nbsp;     * phase report
&nbsp;     *
&nbsp;     * @param te            the target entity
&nbsp;     * @param hit           the hit data for the location hit
&nbsp;     * @param damage        the damage to apply
&nbsp;     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
&nbsp;     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
&nbsp;     *                      smithereens
&nbsp;     * @param bFrag         The DamageType of the attack.
&nbsp;     * @param damageIS      Should the target location&#39;s internal structure be damaged
&nbsp;     *                      directly?
&nbsp;     * @param areaSatArty   Is the damage from an area saturating artillery attack?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage,
&nbsp;                                        boolean ammoExplosion, DamageType bFrag, boolean damageIS,
&nbsp;                                        boolean areaSatArty) {
<b class="nc">&nbsp;        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,</b>
&nbsp;                            areaSatArty, true);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deals the listed damage to an entity. Returns a vector of Reports for the
&nbsp;     * phase report
&nbsp;     *
&nbsp;     * @param te            the target entity
&nbsp;     * @param hit           the hit data for the location hit
&nbsp;     * @param damage        the damage to apply
&nbsp;     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
&nbsp;     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
&nbsp;     *                      smithereens
&nbsp;     * @param bFrag         The DamageType of the attack.
&nbsp;     * @param damageIS      Should the target location&#39;s internal structure be damaged
&nbsp;     *                      directly?
&nbsp;     * @param areaSatArty   Is the damage from an area saturating artillery attack?
&nbsp;     * @param throughFront  Is the damage coming through the hex the unit is facing?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage,
&nbsp;                                       boolean ammoExplosion, DamageType bFrag, boolean damageIS,
&nbsp;                                       boolean areaSatArty, boolean throughFront) {
<b class="nc">&nbsp;        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,</b>
&nbsp;                            areaSatArty, throughFront, false, false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deals the listed damage to an entity. Returns a vector of Reports for the
&nbsp;     * phase report
&nbsp;     *
&nbsp;     * @param te            the target entity
&nbsp;     * @param hit           the hit data for the location hit
&nbsp;     * @param damage        the damage to apply
&nbsp;     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
&nbsp;     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
&nbsp;     *                      smithereens
&nbsp;     * @param bFrag         The DamageType of the attack.
&nbsp;     * @param damageIS      Should the target location&#39;s internal structure be damaged
&nbsp;     *                      directly?
&nbsp;     * @param areaSatArty   Is the damage from an area saturating artillery attack?
&nbsp;     * @param throughFront  Is the damage coming through the hex the unit is facing?
&nbsp;     * @param underWater    Is the damage coming from an underwater attack
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage,
&nbsp;            boolean ammoExplosion, DamageType bFrag, boolean damageIS,
&nbsp;            boolean areaSatArty, boolean throughFront, boolean underWater) {
<b class="nc">&nbsp;        return damageEntity(te, hit, damage, ammoExplosion, bFrag, damageIS,</b>
&nbsp;                            areaSatArty, throughFront, underWater, false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deals the listed damage to an entity. Returns a vector of Reports for the
&nbsp;     * phase report
&nbsp;     *
&nbsp;     * @param te            the target entity
&nbsp;     * @param hit           the hit data for the location hit
&nbsp;     * @param damage        the damage to apply
&nbsp;     * @param ammoExplosion ammo explosion type damage is applied directly to the IS,
&nbsp;     *                      hurts the pilot, causes auto-ejects, and can blow the unit to
&nbsp;     *                      smithereens
&nbsp;     * @param bFrag         The DamageType of the attack.
&nbsp;     * @param damageIS      Should the target location&#39;s internal structure be damaged
&nbsp;     *                      directly?
&nbsp;     * @param areaSatArty   Is the damage from an area saturating artillery attack?
&nbsp;     * @param throughFront  Is the damage coming through the hex the unit is facing?
&nbsp;     * @param underWater    Is the damage coming from an underwater attack?
&nbsp;     * @param nukeS2S       is this a ship-to-ship nuke?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageEntity(Entity te, HitData hit, int damage,
&nbsp;            boolean ammoExplosion, DamageType bFrag, boolean damageIS,
&nbsp;            boolean areaSatArty, boolean throughFront, boolean underWater,
&nbsp;            boolean nukeS2S) {
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        int te_n = te.getId();</b>
&nbsp;
&nbsp;        // if this is a fighter squadron then pick an active fighter and pass on
&nbsp;        // the damage
<b class="nc">&nbsp;        if (te instanceof FighterSquadron) {</b>
<b class="nc">&nbsp;            if(te.getActiveSubEntities().orElse(Collections.emptyList()).isEmpty()) {</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
<b class="nc">&nbsp;            List&lt;Entity&gt; fighters = te.getSubEntities().orElse(Collections.emptyList());</b>
<b class="nc">&nbsp;            Entity fighter = fighters.get(hit.getLocation());</b>
<b class="nc">&nbsp;            HitData new_hit = fighter.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;            new_hit.setBoxCars(hit.rolledBoxCars());</b>
<b class="nc">&nbsp;            new_hit.setGeneralDamageType(hit.getGeneralDamageType());</b>
<b class="nc">&nbsp;            new_hit.setCapital(hit.isCapital());</b>
<b class="nc">&nbsp;            new_hit.setCapMisCritMod(hit.getCapMisCritMod());</b>
<b class="nc">&nbsp;            new_hit.setSingleAV(hit.getSingleAV());</b>
<b class="nc">&nbsp;            new_hit.setAttackerId(hit.getAttackerId());</b>
<b class="nc">&nbsp;            return damageEntity(fighter, new_hit, damage, ammoExplosion, bFrag,</b>
&nbsp;                                damageIS, areaSatArty, throughFront, underWater, nukeS2S);
&nbsp;        }
&nbsp;
&nbsp;        // Battle Armor takes full damage to each trooper from area-effect.
<b class="nc">&nbsp;        if (areaSatArty &amp;&amp; (te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            r = new Report(6044);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; ((BattleArmor) te).getTroopers(); i++) {</b>
<b class="nc">&nbsp;                hit.setLocation(BattleArmor.LOC_TROOPER_1 + i);</b>
<b class="nc">&nbsp;                if (te.getInternal(hit) &gt; 0) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(damageEntity(te, hit, damage, ammoExplosion, bFrag,</b>
&nbsp;                            damageIS, false, throughFront, underWater, nukeS2S));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // This is good for shields if a shield absorps the hit it shouldn&#39;t
&nbsp;        // effect the pilot.
&nbsp;        // TC SRM&#39;s that hit the head do external and internal damage but its
&nbsp;        // one hit and shouldn&#39;t cause
&nbsp;        // 2 hits to the pilot.
<b class="nc">&nbsp;        boolean isHeadHit = (te instanceof Mech)</b>
<b class="nc">&nbsp;                            &amp;&amp; (((Mech) te).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED)</b>
<b class="nc">&nbsp;                            &amp;&amp; (hit.getLocation() == Mech.LOC_HEAD)</b>
<b class="nc">&nbsp;                            &amp;&amp; ((hit.getEffect() &amp; HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS);</b>
&nbsp;
&nbsp;        // booleans to indicate criticals for AT2
<b class="nc">&nbsp;        boolean critSI = false;</b>
<b class="nc">&nbsp;        boolean critThresh = false;</b>
&nbsp;
&nbsp;        // get the relevant damage for damage thresholding
<b class="nc">&nbsp;        int threshDamage = damage;</b>
&nbsp;        // weapon groups only get the damage of one weapon
<b class="nc">&nbsp;        if ((hit.getSingleAV() &gt; -1)</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            threshDamage = hit.getSingleAV();</b>
&nbsp;        }
&nbsp;
&nbsp;        // is this capital-scale damage
<b class="nc">&nbsp;        boolean isCapital = hit.isCapital();</b>
&nbsp;
&nbsp;        // check capital/standard damage
<b class="nc">&nbsp;        if (isCapital</b>
<b class="nc">&nbsp;            &amp;&amp; (!te.isCapitalScale() || game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVAERORULES_AERO_SANITY))) {
<b class="nc">&nbsp;            damage = 10 * damage;</b>
<b class="nc">&nbsp;            threshDamage = 10 * threshDamage;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!isCapital &amp;&amp; te.isCapitalScale()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            damage = (int) Math.round(damage / 10.0);</b>
<b class="nc">&nbsp;            threshDamage = (int) Math.round(threshDamage / 10.0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int damage_orig = damage;</b>
&nbsp;
&nbsp;        // show Locations which have rerolled with Edge
<b class="nc">&nbsp;        HitData undoneLocation = hit.getUndoneLocation();</b>
<b class="nc">&nbsp;        while (undoneLocation != null) {</b>
<b class="nc">&nbsp;            r = new Report(6500);</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            r.add(te.getLocationAbbr(undoneLocation));</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            undoneLocation = undoneLocation.getUndoneLocation();</b>
&nbsp;        } // while
&nbsp;        // if edge was uses, give at end overview of remaining
<b class="nc">&nbsp;        if (hit.getUndoneLocation() != null) {</b>
<b class="nc">&nbsp;            r = new Report(6510);</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            r.add(te.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        } // if
&nbsp;
<b class="nc">&nbsp;        boolean autoEject = false;</b>
<b class="nc">&nbsp;        if (ammoExplosion) {</b>
<b class="nc">&nbsp;            if (te instanceof Mech) {</b>
<b class="nc">&nbsp;                Mech mech = (Mech) te;</b>
<b class="nc">&nbsp;                if (mech.isAutoEject() &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                        || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                                &amp;&amp; mech.isCondEjectAmmo()))) {</b>
<b class="nc">&nbsp;                    autoEject = true;</b>
<b class="nc">&nbsp;                    vDesc.addAll(ejectEntity(te, true));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (te instanceof Aero) {</b>
<b class="nc">&nbsp;                Aero aero = (Aero) te;</b>
<b class="nc">&nbsp;                if (aero.isAutoEject() &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                        || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                                &amp;&amp; aero.isCondEjectAmmo()))) {</b>
<b class="nc">&nbsp;                    autoEject = true;</b>
<b class="nc">&nbsp;                    vDesc.addAll(ejectEntity(te, true));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        boolean isBattleArmor = te instanceof BattleArmor;</b>
<b class="nc">&nbsp;        boolean isPlatoon = !isBattleArmor &amp;&amp; (te instanceof Infantry);</b>
<b class="nc">&nbsp;        boolean isFerroFibrousTarget = false;</b>
<b class="nc">&nbsp;        boolean wasDamageIS = false;</b>
<b class="nc">&nbsp;        boolean tookInternalDamage = damageIS;</b>
<b class="nc">&nbsp;        IHex te_hex = null;</b>
&nbsp;
<b class="nc">&nbsp;        boolean hardenedArmor = ((te instanceof Mech) || (te instanceof Tank))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED);</b>
<b class="nc">&nbsp;        boolean ferroLamellorArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_LAMELLOR);</b>
<b class="nc">&nbsp;        boolean reflectiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REFLECTIVE))</b>
<b class="nc">&nbsp;                || (isBattleArmor &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REFLECTIVE));</b>
<b class="nc">&nbsp;        boolean reactiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REACTIVE))</b>
<b class="nc">&nbsp;                || (isBattleArmor &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REACTIVE));</b>
<b class="nc">&nbsp;        boolean ballisticArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BALLISTIC_REINFORCED);</b>
<b class="nc">&nbsp;        boolean impactArmor = (te instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_IMPACT_RESISTANT);</b>
<b class="nc">&nbsp;        boolean bar5 = te.getBARRating(hit.getLocation()) &lt;= 5;</b>
&nbsp;
&nbsp;        // TACs from the hit location table
&nbsp;        int crits;
<b class="nc">&nbsp;        if ((hit.getEffect() &amp; HitData.EFFECT_CRITICAL) == HitData.EFFECT_CRITICAL) {</b>
<b class="nc">&nbsp;            crits = 1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            crits = 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // this is for special crits, like AP and tandem-charge
<b class="nc">&nbsp;        int specCrits = 0;</b>
&nbsp;
&nbsp;        // the bonus to the crit roll if using the
&nbsp;        // &quot;advanced determining critical hits rule&quot;
<b class="nc">&nbsp;        int critBonus = 0;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CRIT_ROLL)</b>
&nbsp;            &amp;&amp; (damage_orig &gt; 0)
&nbsp;            &amp;&amp; ((te instanceof Mech) || (te instanceof Protomech))) {
<b class="nc">&nbsp;            critBonus = Math.min((damage_orig - 1) / 5, 4);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Find out if Human TRO plays a part it crit bonus
<b class="nc">&nbsp;        Entity ae = game.getEntity(hit.getAttackerId());</b>
<b class="nc">&nbsp;        if ((ae != null) &amp;&amp; !areaSatArty) {</b>
<b class="nc">&nbsp;            if ((te instanceof Mech) &amp;&amp; ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_MECH)) {</b>
<b class="nc">&nbsp;                critBonus += 1;</b>
<b class="nc">&nbsp;            } else if ((te instanceof Aero) &amp;&amp; ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_AERO)) {</b>
<b class="nc">&nbsp;                critBonus += 1;</b>
<b class="nc">&nbsp;            } else if ((te instanceof Tank) &amp;&amp; ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_VEE)) {</b>
<b class="nc">&nbsp;                critBonus += 1;</b>
<b class="nc">&nbsp;            } else if ((te instanceof BattleArmor) &amp;&amp; ae.hasAbility(OptionsConstants.MISC_HUMAN_TRO, Crew.HUMANTRO_BA)) {</b>
<b class="nc">&nbsp;                critBonus += 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HitData nextHit = null;</b>
&nbsp;
&nbsp;        // Some &quot;hits&quot; on a ProtoMech are actually misses.
<b class="nc">&nbsp;        if ((te instanceof Protomech) &amp;&amp; (hit.getLocation() == Protomech.LOC_NMISS)) {</b>
<b class="nc">&nbsp;            Protomech proto = (Protomech) te;</b>
<b class="nc">&nbsp;            r = new Report(6035);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            if (proto.isGlider()) {</b>
<b class="nc">&nbsp;                r.messageId = 6036;</b>
<b class="nc">&nbsp;                proto.setWingHits(proto.getWingHits() + 1);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for critical hit/miss vs. a BA
<b class="nc">&nbsp;        if ((crits &gt; 0) &amp;&amp; (te instanceof BattleArmor)) {</b>
&nbsp;            // possible critical miss if the rerolled location isn&#39;t alive
<b class="nc">&nbsp;            if ((hit.getLocation() &gt;= te.locations()) || (te.getInternal(hit.getLocation()) &lt;= 0)) {</b>
<b class="nc">&nbsp;                r = new Report(6037);</b>
<b class="nc">&nbsp;                r.add(hit.getLocation());</b>
<b class="nc">&nbsp;                r.subject = te_n;</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;            // otherwise critical hit
<b class="nc">&nbsp;            r = new Report(6225);</b>
<b class="nc">&nbsp;            r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;            crits = 0;</b>
<b class="nc">&nbsp;            damage = Math.max(te.getInternal(hit.getLocation()) + te.getArmor(hit.getLocation()), damage);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((te.getArmor(hit) &gt; 0) &amp;&amp; ((te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_FIBROUS)</b>
<b class="nc">&nbsp;                || (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_LIGHT_FERRO)</b>
<b class="nc">&nbsp;                || (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HEAVY_FERRO))) {</b>
<b class="nc">&nbsp;            isFerroFibrousTarget = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // area effect against infantry is double damage
<b class="nc">&nbsp;        if (isPlatoon &amp;&amp; areaSatArty) {</b>
&nbsp;            // PBI. Double damage.
<b class="nc">&nbsp;            damage *= 2;</b>
<b class="nc">&nbsp;            r = new Report(6039);</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the infantry in the open?
<b class="nc">&nbsp;        if(ServerHelper.infantryInOpen(te, te_hex, game, isPlatoon, ammoExplosion, hit.isIgnoreInfantryDoubleDamage())) {</b>
&nbsp;            // PBI. Damage is doubled.
<b class="nc">&nbsp;            damage *= 2;</b>
<b class="nc">&nbsp;            r = new Report(6040);</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the infantry in vacuum?
<b class="nc">&nbsp;        if ((isPlatoon || isBattleArmor) &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed()</b>
<b class="nc">&nbsp;            &amp;&amp; game.getPlanetaryConditions().isVacuum()) {</b>
&nbsp;            // PBI. Double damage.
<b class="nc">&nbsp;            damage *= 2;</b>
<b class="nc">&nbsp;            r = new Report(6041);</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
&nbsp;        // If dealing with fragmentation missiles,
&nbsp;        // it does double damage to infantry...
&nbsp;        // We&#39;re actually going to abuse this for AX-head warheads, too, so as
&nbsp;        // to not add another parameter.
<b class="nc">&nbsp;        switch (bFrag) {</b>
&nbsp;            case FRAGMENTATION:
&nbsp;                // Fragmentation missiles deal full damage to conventional
&nbsp;                // infantry
&nbsp;                // (only) and no damage to other target types.
<b class="nc">&nbsp;                if (!isPlatoon) {</b>
<b class="nc">&nbsp;                    damage = 0;</b>
<b class="nc">&nbsp;                    r = new Report(6050); // For some reason this report never</b>
&nbsp;                    // actually shows up...
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(6045); // ...but this one displays just fine.</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case NONPENETRATING:
<b class="nc">&nbsp;                if (!isPlatoon) {</b>
<b class="nc">&nbsp;                    damage = 0;</b>
<b class="nc">&nbsp;                    r = new Report(6051);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case FLECHETTE:
&nbsp;                // Flechette ammo deals full damage to conventional infantry and
&nbsp;                // half damage to other targets (including battle armor).
<b class="nc">&nbsp;                if (!isPlatoon) {</b>
<b class="nc">&nbsp;                    damage /= 2;</b>
<b class="nc">&nbsp;                    r = new Report(6060);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(6055);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case ACID:
<b class="nc">&nbsp;                if (isFerroFibrousTarget || reactiveArmor || reflectiveArmor</b>
&nbsp;                    || ferroLamellorArmor || bar5) {
<b class="nc">&nbsp;                    if (te.getArmor(hit) &lt;= 0) {</b>
<b class="nc">&nbsp;                        break; // hitting IS, not acid-affected armor</b>
&nbsp;                    }
<b class="nc">&nbsp;                    damage = Math.min(te.getArmor(hit), 3);</b>
<b class="nc">&nbsp;                    r = new Report(6061);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (isPlatoon) {</b>
<b class="nc">&nbsp;                    damage = (int) Math.ceil(damage * 1.5);</b>
<b class="nc">&nbsp;                    r = new Report(6062);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case INCENDIARY:
&nbsp;                // Incendiary AC ammo does +2 damage to unarmoured infantry
<b class="nc">&nbsp;                if (isPlatoon) {</b>
<b class="nc">&nbsp;                    damage += 2;</b>
<b class="nc">&nbsp;                    r = new Report(6064);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case ANTI_TSM:
<b class="nc">&nbsp;                te.hitThisRoundByAntiTSM = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case NAIL_RIVET:
&nbsp;                // no damage against armor of BAR rating &gt;=5
<b class="nc">&nbsp;                if ((te.getBARRating(hit.getLocation()) &gt;= 5)</b>
<b class="nc">&nbsp;                    &amp;&amp; (te.getArmor(hit.getLocation()) &gt; 0)) {</b>
<b class="nc">&nbsp;                    damage = 0;</b>
<b class="nc">&nbsp;                    r = new Report(6063);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
&nbsp;                // We can ignore this.
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        // adjust VTOL rotor damage
<b class="nc">&nbsp;        if ((te instanceof VTOL) &amp;&amp; (hit.getLocation() == VTOL.LOC_ROTOR)</b>
<b class="nc">&nbsp;            &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_PHYSICAL)</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_FULL_ROTOR_HITS)) {</b>
<b class="nc">&nbsp;            damage = (damage + 9) / 10;</b>
&nbsp;        }
&nbsp;
&nbsp;        // save EI status, in case sensors crit destroys it
<b class="nc">&nbsp;        final boolean eiStatus = te.hasActiveEiCockpit();</b>
&nbsp;        // BA using EI implants receive +1 damage from attacks
<b class="nc">&nbsp;        if (!(te instanceof Mech) &amp;&amp; !(te instanceof Protomech) &amp;&amp; eiStatus) {</b>
<b class="nc">&nbsp;            damage += 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for case on Aeros
<b class="nc">&nbsp;        if (te instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero a = (Aero) te;</b>
<b class="nc">&nbsp;            if (ammoExplosion &amp;&amp; a.hasCase()) {</b>
&nbsp;                // damage should be reduced by a factor of 2 for ammo explosions
&nbsp;                // according to p. 161, TW
<b class="nc">&nbsp;                damage /= 2;</b>
<b class="nc">&nbsp;                r = new Report(9010);</b>
<b class="nc">&nbsp;                r.subject = te_n;</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                r.indent(3);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // infantry armor can reduce damage
<b class="nc">&nbsp;        if (isPlatoon &amp;&amp; (((Infantry) te).calcDamageDivisor() != 1.0)) {</b>
<b class="nc">&nbsp;            r = new Report(6074);</b>
<b class="nc">&nbsp;            r.subject = te_n;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            damage = (int) Math.ceil((damage) / ((Infantry) te).calcDamageDivisor());</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Allocate the damage
<b class="nc">&nbsp;        while (damage &gt; 0) {</b>
&nbsp;
&nbsp;            // first check for ammo explosions on aeros separately, because it
&nbsp;            // must be done before
&nbsp;            // standard to capital damage conversions
<b class="nc">&nbsp;            if ((te instanceof Aero) &amp;&amp; (hit.getLocation() == Aero.LOC_AFT)</b>
&nbsp;                &amp;&amp; !damageIS) {
<b class="nc">&nbsp;                for (Mounted mAmmo : te.getAmmo()) {</b>
<b class="nc">&nbsp;                    if (mAmmo.isDumping() &amp;&amp; !mAmmo.isDestroyed() &amp;&amp; !mAmmo.isHit()</b>
<b class="nc">&nbsp;                            &amp;&amp; !(mAmmo.getType() instanceof BombType)) {</b>
&nbsp;                        // doh. explode it
<b class="nc">&nbsp;                        vDesc.addAll(explodeEquipment(te, mAmmo.getLocation(), mAmmo));</b>
<b class="nc">&nbsp;                        mAmmo.setHit(true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (te.isAero()) {</b>
&nbsp;                // chance of a critical if damage greater than threshold
<b class="nc">&nbsp;                IAero a = (IAero) te;</b>
<b class="nc">&nbsp;                if ((threshDamage &gt; a.getThresh(hit.getLocation()))) {</b>
<b class="nc">&nbsp;                    critThresh = true;</b>
<b class="nc">&nbsp;                    a.setCritThresh(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Capital fighters receive damage differently
<b class="nc">&nbsp;            if (te.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                IAero a = (IAero) te;</b>
<b class="nc">&nbsp;                a.setCurrentDamage(a.getCurrentDamage() + damage);</b>
<b class="nc">&nbsp;                a.setCapArmor(a.getCapArmor() - damage);</b>
<b class="nc">&nbsp;                r = new Report(9065);</b>
<b class="nc">&nbsp;                r.subject = te_n;</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                r = new Report(6085);</b>
<b class="nc">&nbsp;                r.subject = te_n;</b>
<b class="nc">&nbsp;                r.add(Math.max(a.getCapArmor(), 0));</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;                // check to see if this destroyed the entity
<b class="nc">&nbsp;                if (a.getCapArmor() &lt;= 0) {</b>
&nbsp;                    // Lets auto-eject if we can!
<b class="nc">&nbsp;                    if (a instanceof LandAirMech) {</b>
&nbsp;                        // LAMs eject if the CT destroyed switch is on
<b class="nc">&nbsp;                        LandAirMech lam = (LandAirMech) a;</b>
<b class="nc">&nbsp;                        if (lam.isAutoEject()</b>
<b class="nc">&nbsp;                            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                    || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                            &amp;&amp; lam.isCondEjectCTDest()))) {</b>
<b class="nc">&nbsp;                            addReport(ejectEntity(te, true, false));</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        // Aeros eject if the SI Destroyed switch is on
<b class="nc">&nbsp;                        Aero aero = (Aero) a;</b>
<b class="nc">&nbsp;                        if (aero.isAutoEject()</b>
<b class="nc">&nbsp;                                &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                                    || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                            &amp;&amp; aero.isCondEjectSIDest()))) {</b>
<b class="nc">&nbsp;                            addReport(ejectEntity(te, true, false));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    vDesc.addAll(destroyEntity(te, &quot;Structural Integrity Collapse&quot;));</b>
<b class="nc">&nbsp;                    a.doDisbandDamage();</b>
<b class="nc">&nbsp;                    a.setCapArmor(0);</b>
<b class="nc">&nbsp;                    if (hit.getAttackerId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                        creditKill(te, game.getEntity(hit.getAttackerId()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // check for aero crits from natural 12 or threshold; LAMs take damage as mechs
<b class="nc">&nbsp;                if (te instanceof Aero) {</b>
<b class="nc">&nbsp;                    checkAeroCrits(vDesc, (Aero) te, hit, damage_orig, critThresh,</b>
&nbsp;                                   critSI, ammoExplosion, nukeS2S);
&nbsp;                }
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!((te instanceof Aero) &amp;&amp; ammoExplosion)) {</b>
&nbsp;                // report something different for Aero ammo explosions
<b class="nc">&nbsp;                r = new Report(6065);</b>
<b class="nc">&nbsp;                r.subject = te_n;</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                if (damageIS) {</b>
<b class="nc">&nbsp;                    r.messageId = 6070;</b>
&nbsp;                }
<b class="nc">&nbsp;                r.add(te.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // was the section destroyed earlier this phase?
<b class="nc">&nbsp;            if (te.getInternal(hit) == IArmorState.ARMOR_DOOMED) {</b>
&nbsp;                // cannot transfer a through armor crit if so
<b class="nc">&nbsp;                crits = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // here goes the fun :)
&nbsp;            // Shields take damage first then cowls then armor whee
&nbsp;            // Shield does not protect from ammo explosions or falls.
<b class="nc">&nbsp;            if (!ammoExplosion &amp;&amp; !hit.isFallDamage() &amp;&amp; !damageIS &amp;&amp; te.hasShield()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((hit.getEffect() &amp; HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {</b>
<b class="nc">&nbsp;                Mech me = (Mech) te;</b>
<b class="nc">&nbsp;                int damageNew = me.shieldAbsorptionDamage(damage, hit.getLocation(), hit.isRear());</b>
&nbsp;                // if a shield absorbed the damage then lets tell the world
&nbsp;                // about it.
<b class="nc">&nbsp;                if (damageNew != damage) {</b>
<b class="nc">&nbsp;                    int absorb = damage - damageNew;</b>
<b class="nc">&nbsp;                    te.damageThisPhase += absorb;</b>
<b class="nc">&nbsp;                    damage = damageNew;</b>
&nbsp;
<b class="nc">&nbsp;                    r = new Report(3530);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(absorb);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                    if (damage &lt;= 0) {</b>
<b class="nc">&nbsp;                        crits = 0;</b>
<b class="nc">&nbsp;                        specCrits = 0;</b>
<b class="nc">&nbsp;                        isHeadHit = false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Armored Cowl may absorb some damage from hit
<b class="nc">&nbsp;            if (te instanceof Mech) {</b>
<b class="nc">&nbsp;                Mech me = (Mech) te;</b>
<b class="nc">&nbsp;                if (me.hasCowl() &amp;&amp; (hit.getLocation() == Mech.LOC_HEAD)</b>
&nbsp;                    &amp;&amp; !throughFront) {
<b class="nc">&nbsp;                    int damageNew = me.damageCowl(damage);</b>
<b class="nc">&nbsp;                    int damageDiff = damage - damageNew;</b>
<b class="nc">&nbsp;                    me.damageThisPhase += damageDiff;</b>
<b class="nc">&nbsp;                    damage = damageNew;</b>
&nbsp;
<b class="nc">&nbsp;                    r = new Report(3520);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(damageDiff);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // So might modular armor, if the location mounts any.
<b class="nc">&nbsp;            if (!ammoExplosion &amp;&amp; !damageIS</b>
<b class="nc">&nbsp;                    &amp;&amp; ((hit.getEffect() &amp; HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {</b>
<b class="nc">&nbsp;                int damageNew = te.getDamageReductionFromModularArmor(hit, damage, vDesc);</b>
<b class="nc">&nbsp;                int damageDiff = damage - damageNew;</b>
<b class="nc">&nbsp;                te.damageThisPhase += damageDiff;</b>
<b class="nc">&nbsp;                damage = damageNew;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Destroy searchlights on 7+ (torso hits on mechs)
<b class="nc">&nbsp;            if (te.hasSpotlight()) {</b>
<b class="nc">&nbsp;                boolean spotlightHittable = true;</b>
<b class="nc">&nbsp;                int loc = hit.getLocation();</b>
<b class="nc">&nbsp;                if (te instanceof Mech) {</b>
<b class="nc">&nbsp;                    if ((loc != Mech.LOC_CT) &amp;&amp; (loc != Mech.LOC_LT) &amp;&amp; (loc != Mech.LOC_RT)) {</b>
<b class="nc">&nbsp;                        spotlightHittable = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (te instanceof Tank) {</b>
<b class="nc">&nbsp;                    if (te instanceof SuperHeavyTank) {</b>
<b class="nc">&nbsp;                        if ((loc != Tank.LOC_FRONT)</b>
&nbsp;                                &amp;&amp; (loc != SuperHeavyTank.LOC_FRONTRIGHT)
&nbsp;                                &amp;&amp; (loc != SuperHeavyTank.LOC_FRONTLEFT)
&nbsp;                                &amp;&amp; (loc != SuperHeavyTank.LOC_REARRIGHT)
&nbsp;                                &amp;&amp; (loc != SuperHeavyTank.LOC_REARLEFT)) {
<b class="nc">&nbsp;                            spotlightHittable = false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (te instanceof LargeSupportTank) {</b>
<b class="nc">&nbsp;                        if ((loc != Tank.LOC_FRONT)</b>
&nbsp;                                &amp;&amp; (loc != LargeSupportTank.LOC_FRONTRIGHT)
&nbsp;                                &amp;&amp; (loc != LargeSupportTank.LOC_FRONTLEFT)
&nbsp;                                &amp;&amp; (loc != LargeSupportTank.LOC_REARRIGHT)
&nbsp;                                &amp;&amp; (loc != LargeSupportTank.LOC_REARLEFT)) {
<b class="nc">&nbsp;                            spotlightHittable = false;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        if ((loc != Tank.LOC_FRONT) &amp;&amp; (loc != Tank.LOC_RIGHT)</b>
&nbsp;                                &amp;&amp; (loc != Tank.LOC_LEFT)) {
<b class="nc">&nbsp;                            spotlightHittable = false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
<b class="nc">&nbsp;                if (spotlightHittable) {</b>
<b class="nc">&nbsp;                    int spotroll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    r = new Report(6072);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.add(&quot;7+&quot;);</b>
<b class="nc">&nbsp;                    r.add(&quot;Searchlight&quot;);</b>
<b class="nc">&nbsp;                    r.add(spotroll);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    if (spotroll &gt;= 7) {</b>
<b class="nc">&nbsp;                        r = new Report(6071);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.add(&quot;Searchlight&quot;);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                        te.destroyOneSpotlight();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Does an exterior passenger absorb some of the damage?
<b class="nc">&nbsp;            if (!damageIS) {</b>
<b class="nc">&nbsp;                int nLoc = hit.getLocation();</b>
<b class="nc">&nbsp;                Entity passenger = te.getExteriorUnitAt(nLoc, hit.isRear());</b>
&nbsp;                // Does an exterior passenger absorb some of the damage?
<b class="nc">&nbsp;                if (!ammoExplosion &amp;&amp; (null != passenger) &amp;&amp; !passenger.isDoomed()</b>
&nbsp;                        &amp;&amp; (bFrag != DamageType.IGNORE_PASSENGER)) {
<b class="nc">&nbsp;                    damage = damageExternalPassenger(te, hit, damage, vDesc, passenger);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                boolean bTorso = (nLoc == Mech.LOC_CT) || (nLoc == Mech.LOC_RT)</b>
&nbsp;                        || (nLoc == Mech.LOC_LT);
&nbsp;
&nbsp;                // Does a swarming unit absorb damage?
<b class="nc">&nbsp;                int swarmer = te.getSwarmAttackerId();</b>
<b class="nc">&nbsp;                if ((!(te instanceof Mech) || bTorso) &amp;&amp; (swarmer != Entity.NONE)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((hit.getEffect() &amp; HitData.EFFECT_CRITICAL) == 0) &amp;&amp; (Compute.d6() &gt;= 5)</b>
&nbsp;                        &amp;&amp; (bFrag != DamageType.IGNORE_PASSENGER) &amp;&amp; !ammoExplosion) {
<b class="nc">&nbsp;                    Entity swarm = game.getEntity(swarmer);</b>
&nbsp;                    // Yup. Roll up some hit data for that passenger.
<b class="nc">&nbsp;                    r = new Report(6076);</b>
<b class="nc">&nbsp;                    r.subject = swarmer;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.addDesc(swarm);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                    HitData passHit = swarm.rollHitLocation(</b>
&nbsp;                            ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);
&nbsp;
&nbsp;                    // How much damage will the swarm absorb?
<b class="nc">&nbsp;                    int absorb = 0;</b>
<b class="nc">&nbsp;                    HitData nextPassHit = passHit;</b>
&nbsp;                    do {
<b class="nc">&nbsp;                        if (0 &lt; swarm.getArmor(nextPassHit)) {</b>
<b class="nc">&nbsp;                            absorb += swarm.getArmor(nextPassHit);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (0 &lt; swarm.getInternal(nextPassHit)) {</b>
<b class="nc">&nbsp;                            absorb += swarm.getInternal(nextPassHit);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        nextPassHit = swarm.getTransferLocation(nextPassHit);</b>
<b class="nc">&nbsp;                    } while ((damage &gt; absorb)</b>
<b class="nc">&nbsp;                             &amp;&amp; (nextPassHit.getLocation() &gt;= 0));</b>
&nbsp;
&nbsp;                    // Damage the swarm.
<b class="nc">&nbsp;                    int absorbedDamage = Math.min(damage, absorb);</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; newReports = damageEntity(swarm, passHit,</b>
&nbsp;                                                             absorbedDamage);
<b class="nc">&nbsp;                    for (Report newReport : newReports) {</b>
<b class="nc">&nbsp;                        newReport.indent(2);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    vDesc.addAll(newReports);</b>
&nbsp;
&nbsp;                    // Did some damage pass on?
<b class="nc">&nbsp;                    if (damage &gt; absorb) {</b>
&nbsp;                        // Yup. Remove the absorbed damage.
<b class="nc">&nbsp;                        damage -= absorb;</b>
<b class="nc">&nbsp;                        r = new Report(6080);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.add(damage);</b>
<b class="nc">&nbsp;                        r.addDesc(te);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                    } else {
&nbsp;                        // Nope. Return our description.
<b class="nc">&nbsp;                        return vDesc;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // is this a mech/tank dumping ammo being hit in the rear torso?
<b class="nc">&nbsp;                if (((te instanceof Mech) &amp;&amp; hit.isRear() &amp;&amp; bTorso)</b>
<b class="nc">&nbsp;                        || ((te instanceof Tank) &amp;&amp; (hit.getLocation() == (te instanceof SuperHeavyTank ? SuperHeavyTank.LOC_REAR</b>
<b class="nc">&nbsp;                                : Tank.LOC_REAR)))) {</b>
<b class="nc">&nbsp;                    for (Mounted mAmmo : te.getAmmo()) {</b>
<b class="nc">&nbsp;                        if (mAmmo.isDumping() &amp;&amp; !mAmmo.isDestroyed()</b>
<b class="nc">&nbsp;                            &amp;&amp; !mAmmo.isHit()) {</b>
&nbsp;                            // doh. explode it
<b class="nc">&nbsp;                            vDesc.addAll(explodeEquipment(te,</b>
<b class="nc">&nbsp;                                                          mAmmo.getLocation(), mAmmo));</b>
<b class="nc">&nbsp;                            mAmmo.setHit(true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // is there armor in the location hit?
<b class="nc">&nbsp;            if (!ammoExplosion &amp;&amp; (te.getArmor(hit) &gt; 0) &amp;&amp; !damageIS) {</b>
<b class="nc">&nbsp;                int tmpDamageHold = -1;</b>
<b class="nc">&nbsp;                int origDamage = damage;</b>
&nbsp;
<b class="nc">&nbsp;                if (isPlatoon) {</b>
&nbsp;                    // infantry armour works differently
<b class="nc">&nbsp;                    int armor = te.getArmor(hit);</b>
<b class="nc">&nbsp;                    int men = te.getInternal(hit);</b>
<b class="nc">&nbsp;                    tmpDamageHold = damage % 2;</b>
<b class="nc">&nbsp;                    damage /= 2;</b>
<b class="nc">&nbsp;                    if ((tmpDamageHold == 1) &amp;&amp; (armor &gt;= men)) {</b>
&nbsp;                        // extra 1 point of damage to armor
<b class="nc">&nbsp;                        tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                        damage++;</b>
&nbsp;                    } else {
&nbsp;                        // extra 0 or 1 point of damage to men
<b class="nc">&nbsp;                        tmpDamageHold += damage;</b>
&nbsp;                    }
&nbsp;                    // If the target has Ferro-Lamellor armor, we need to adjust
&nbsp;                    // damage. (4/5ths rounded down),
&nbsp;                    // Also check to eliminate crit chances for damage reduced
&nbsp;                    // to 0
<b class="nc">&nbsp;                } else if (ferroLamellorArmor</b>
<b class="nc">&nbsp;                           &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)</b>
<b class="nc">&nbsp;                           &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)</b>
<b class="nc">&nbsp;                           &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {</b>
<b class="nc">&nbsp;                    tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                    damage = (int) Math.floor((((double) damage) * 4) / 5);</b>
<b class="nc">&nbsp;                    if (damage &lt;= 0) {</b>
<b class="nc">&nbsp;                        isHeadHit = false;</b>
<b class="nc">&nbsp;                        crits = 0;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r = new Report(6073);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (ballisticArmor</b>
<b class="nc">&nbsp;                           &amp;&amp; ((hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE)</b>
<b class="nc">&nbsp;                               || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING)</b>
<b class="nc">&nbsp;                               || (hit.getGeneralDamageType() == HitData.DAMAGE_BALLISTIC)</b>
<b class="nc">&nbsp;                               || (hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE))) {</b>
<b class="nc">&nbsp;                    tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                    damage = Math.max(1, damage / 2);</b>
<b class="nc">&nbsp;                    r = new Report(6088);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (impactArmor</b>
<b class="nc">&nbsp;                           &amp;&amp; (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)) {</b>
<b class="nc">&nbsp;                    tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                    damage -= (int) Math.ceil((double) damage / 3);</b>
<b class="nc">&nbsp;                    damage = Math.max(1, damage);</b>
<b class="nc">&nbsp;                    r = new Report(6089);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (reflectiveArmor</b>
<b class="nc">&nbsp;                           &amp;&amp; (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)</b>
&nbsp;                           &amp;&amp; !isBattleArmor) { // BA reflec does not receive extra physical damage
<b class="nc">&nbsp;                    tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                    int currArmor = te.getArmor(hit);</b>
<b class="nc">&nbsp;                    int dmgToDouble = Math.min(damage, currArmor / 2);</b>
<b class="nc">&nbsp;                    damage += dmgToDouble;</b>
<b class="nc">&nbsp;                    r = new Report(6066);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(currArmor);</b>
<b class="nc">&nbsp;                    r.add(tmpDamageHold);</b>
<b class="nc">&nbsp;                    r.add(dmgToDouble);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (reflectiveArmor &amp;&amp; areaSatArty &amp;&amp; !isBattleArmor) {</b>
<b class="nc">&nbsp;                    tmpDamageHold = damage; // BA reflec does not receive extra AE damage</b>
<b class="nc">&nbsp;                    int currArmor = te.getArmor(hit);</b>
<b class="nc">&nbsp;                    int dmgToDouble = Math.min(damage, currArmor / 2);</b>
<b class="nc">&nbsp;                    damage += dmgToDouble;</b>
<b class="nc">&nbsp;                    r = new Report(6087);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(currArmor);</b>
<b class="nc">&nbsp;                    r.add(tmpDamageHold);</b>
<b class="nc">&nbsp;                    r.add(dmgToDouble);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (reflectiveArmor</b>
<b class="nc">&nbsp;                           &amp;&amp; (hit.getGeneralDamageType() == HitData.DAMAGE_ENERGY)) {</b>
<b class="nc">&nbsp;                    tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                    damage = (int) Math.floor(((double) damage) / 2);</b>
<b class="nc">&nbsp;                    if (tmpDamageHold == 1) {</b>
<b class="nc">&nbsp;                        damage = 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r = new Report(6067);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (reactiveArmor</b>
<b class="nc">&nbsp;                           &amp;&amp; ((hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE)</b>
<b class="nc">&nbsp;                               || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE) ||</b>
&nbsp;                               areaSatArty)) {
<b class="nc">&nbsp;                    tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                    damage = (int) Math.floor(((double) damage) / 2);</b>
<b class="nc">&nbsp;                    if (tmpDamageHold == 1) {</b>
<b class="nc">&nbsp;                        damage = 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r = new Report(6068);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;
&nbsp;                // If we&#39;re using optional tank damage thresholds, setup our hit
&nbsp;                // effects now...
<b class="nc">&nbsp;                if ((te instanceof Tank)</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions()</b>
<b class="nc">&nbsp;                                .booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD)</b>
&nbsp;                        &amp;&amp; !((te instanceof VTOL) || (te instanceof GunEmplacement))) {
<b class="nc">&nbsp;                    int thresh = (int) Math.ceil(</b>
<b class="nc">&nbsp;                            (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD_VARIABLE)</b>
<b class="nc">&nbsp;                                    ? te.getArmor(hit)</b>
<b class="nc">&nbsp;                                    : te.getOArmor(hit)) / (double) game.getOptions().intOption(</b>
&nbsp;                                            OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD_DIVISOR));
&nbsp;
&nbsp;                    // adjust for hardened armor
<b class="nc">&nbsp;                    if (hardenedArmor</b>
<b class="nc">&nbsp;                            &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)</b>
<b class="nc">&nbsp;                            &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)</b>
<b class="nc">&nbsp;                            &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {</b>
<b class="nc">&nbsp;                        thresh *= 2;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if ((damage &gt; thresh) || (te.getArmor(hit) &lt; damage)) {</b>
<b class="nc">&nbsp;                        hit.setEffect(((Tank) te).getPotCrit());</b>
<b class="nc">&nbsp;                        ((Tank) te).setOverThresh(true);</b>
&nbsp;                        // TACs from the hit location table
<b class="nc">&nbsp;                        crits = ((hit.getEffect() &amp; HitData.EFFECT_CRITICAL)</b>
<b class="nc">&nbsp;                                == HitData.EFFECT_CRITICAL) ? 1 : 0;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        ((Tank) te).setOverThresh(false);</b>
<b class="nc">&nbsp;                        crits = 0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // if there&#39;s a mast mount in the rotor, it and all other
&nbsp;                // equipment
&nbsp;                // on it get destroyed
<b class="nc">&nbsp;                if ((te instanceof VTOL)</b>
<b class="nc">&nbsp;                    &amp;&amp; (hit.getLocation() == VTOL.LOC_ROTOR)</b>
<b class="nc">&nbsp;                    &amp;&amp; te.hasWorkingMisc(MiscType.F_MAST_MOUNT, -1,</b>
&nbsp;                                         VTOL.LOC_ROTOR)) {
<b class="nc">&nbsp;                    r = new Report(6081);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    for (Mounted mount : te.getMisc()) {</b>
<b class="nc">&nbsp;                        if (mount.getLocation() == VTOL.LOC_ROTOR) {</b>
<b class="nc">&nbsp;                            mount.setHit(true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // Need to account for the possibility of hardened armor here
<b class="nc">&nbsp;                int armorThreshold = te.getArmor(hit);</b>
<b class="nc">&nbsp;                if (hardenedArmor</b>
<b class="nc">&nbsp;                    &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)</b>
<b class="nc">&nbsp;                    &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {</b>
<b class="nc">&nbsp;                    armorThreshold *= 2;</b>
<b class="nc">&nbsp;                    armorThreshold -= (te.isHardenedArmorDamaged(hit)) ? 1 : 0;</b>
<b class="nc">&nbsp;                    vDesc.lastElement().newlines = 0;</b>
<b class="nc">&nbsp;                    r = new Report(6069);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    int reportedDamage = damage / 2;</b>
<b class="nc">&nbsp;                    if ((damage % 2) &gt; 0) {</b>
<b class="nc">&nbsp;                        r.add(reportedDamage + &quot;.5&quot;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r.add(reportedDamage);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (armorThreshold &gt;= damage) {</b>
&nbsp;
&nbsp;                    // armor absorbs all damage
&nbsp;                    // Hardened armor deals with damage in its own fashion...
<b class="nc">&nbsp;                    if (hardenedArmor</b>
<b class="nc">&nbsp;                        &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)</b>
<b class="nc">&nbsp;                        &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)</b>
<b class="nc">&nbsp;                        &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_IGNORES_DMG_REDUCTION)) {</b>
<b class="nc">&nbsp;                        armorThreshold -= damage;</b>
<b class="nc">&nbsp;                        te.setHardenedArmorDamaged(hit, (armorThreshold % 2) &gt; 0);</b>
<b class="nc">&nbsp;                        te.setArmor((armorThreshold / 2) + (armorThreshold % 2), hit);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        te.setArmor(te.getArmor(hit) - damage, hit);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // set &quot;armor damage&quot; flag for HarJel II/III
&nbsp;                    // we only care about this if there is armor remaining,
&nbsp;                    // so don&#39;t worry about the case where damage exceeds
&nbsp;                    // armorThreshold
<b class="nc">&nbsp;                    if ((te instanceof Mech) &amp;&amp; (damage &gt; 0)) {</b>
<b class="nc">&nbsp;                        ((Mech) te).setArmorDamagedThisTurn(hit.getLocation(), true);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // if the armor is hardened, any penetrating crits are
&nbsp;                    // rolled at -2
<b class="nc">&nbsp;                    if (hardenedArmor) {</b>
<b class="nc">&nbsp;                        critBonus -= 2;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (tmpDamageHold &gt;= 0) {</b>
<b class="nc">&nbsp;                        te.damageThisPhase += tmpDamageHold;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        te.damageThisPhase += damage;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    damage = 0;</b>
<b class="nc">&nbsp;                    if (!te.isHardenedArmorDamaged(hit)) {</b>
<b class="nc">&nbsp;                        r = new Report(6085);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(6086);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(te.getArmor(hit));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;
&nbsp;                    // telemissiles are destroyed if they lose all armor
<b class="nc">&nbsp;                    if ((te instanceof TeleMissile)</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmor(hit) == damage)) {</b>
<b class="nc">&nbsp;                        vDesc.addAll(destroyEntity(te, &quot;damage&quot;, false));</b>
&nbsp;                    }
&nbsp;
&nbsp;                } else {
&nbsp;                    // damage goes on to internal
<b class="nc">&nbsp;                    int absorbed = Math.max(te.getArmor(hit), 0);</b>
<b class="nc">&nbsp;                    if (hardenedArmor</b>
<b class="nc">&nbsp;                        &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING)</b>
<b class="nc">&nbsp;                        &amp;&amp; (hit.getGeneralDamageType() != HitData.DAMAGE_ARMOR_PIERCING_MISSILE)) {</b>
<b class="nc">&nbsp;                        absorbed = (absorbed * 2)</b>
<b class="nc">&nbsp;                                   - ((te.isHardenedArmorDamaged(hit)) ? 1 : 0);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (reflectiveArmor &amp;&amp; (hit.getGeneralDamageType() == HitData.DAMAGE_PHYSICAL)</b>
&nbsp;                            &amp;&amp; !isBattleArmor) {
<b class="nc">&nbsp;                        absorbed = (int) Math.ceil(absorbed / 2.0);</b>
<b class="nc">&nbsp;                        damage = tmpDamageHold;</b>
<b class="nc">&nbsp;                        tmpDamageHold = 0;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    te.setArmor(IArmorState.ARMOR_DESTROYED, hit);</b>
<b class="nc">&nbsp;                    if (tmpDamageHold &gt;= 0) {</b>
<b class="nc">&nbsp;                        te.damageThisPhase += 2 * absorbed;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        te.damageThisPhase += absorbed;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    damage -= absorbed;</b>
<b class="nc">&nbsp;                    r = new Report(6090);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    if (te instanceof GunEmplacement) {</b>
&nbsp;                        // gun emplacements have no internal,
&nbsp;                        // destroy the section
<b class="nc">&nbsp;                        te.destroyLocation(hit.getLocation());</b>
<b class="nc">&nbsp;                        r = new Report(6115);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                        if (te.getTransferLocation(hit).getLocation() == Entity.LOC_DESTROYED) {</b>
<b class="nc">&nbsp;                            vDesc.addAll(destroyEntity(te, &quot;damage&quot;, false));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // targets with BAR armor get crits, depending on damage and BAR
&nbsp;                // rating
<b class="nc">&nbsp;                if (te.hasBARArmor(hit.getLocation())) {</b>
<b class="nc">&nbsp;                    if (origDamage &gt; te.getBARRating(hit.getLocation())) {</b>
<b class="nc">&nbsp;                        if (te.hasArmoredChassis()) {</b>
&nbsp;                            // crit roll with -1 mod
<b class="nc">&nbsp;                            vDesc.addAll(criticalEntity(te, hit.getLocation(),</b>
<b class="nc">&nbsp;                                                        hit.isRear(), -1 + critBonus, damage_orig));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            vDesc.addAll(criticalEntity(te, hit.getLocation(),</b>
<b class="nc">&nbsp;                                                        hit.isRear(), critBonus, damage_orig));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if ((tmpDamageHold &gt; 0) &amp;&amp; isPlatoon) {</b>
<b class="nc">&nbsp;                    damage = tmpDamageHold;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // For optional tank damage thresholds, the overthresh flag won&#39;t
&nbsp;            // be set if IS is damaged, so set it here.
<b class="nc">&nbsp;            if ((te instanceof Tank)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((te.getArmor(hit) &lt; 1) || damageIS)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD)</b>
&nbsp;                    &amp;&amp; !((te instanceof VTOL)
&nbsp;                            || (te instanceof GunEmplacement))) {
<b class="nc">&nbsp;                ((Tank) te).setOverThresh(true);</b>
&nbsp;            }
&nbsp;
&nbsp;            // is there damage remaining?
<b class="nc">&nbsp;            if (damage &gt; 0) {</b>
&nbsp;
&nbsp;                // if this is an Aero then I need to apply internal damage
&nbsp;                // to the SI after halving it. Return from here to prevent
&nbsp;                // further processing
<b class="nc">&nbsp;                if (te instanceof Aero) {</b>
<b class="nc">&nbsp;                    Aero a = (Aero) te;</b>
&nbsp;
&nbsp;                    // check for large craft ammo explosions here: damage vented through armor, excess
&nbsp;                    // dissipating, much like Tank CASE.
<b class="nc">&nbsp;                    if (ammoExplosion &amp;&amp; te.isLargeCraft()) {</b>
<b class="nc">&nbsp;                        te.damageThisPhase += damage;</b>
<b class="nc">&nbsp;                        r = new Report(6128);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.add(damage);</b>
<b class="nc">&nbsp;                        int loc = hit.getLocation();</b>
&nbsp;                        //Roll for broadside weapons so fore/aft side armor facing takes the damage
<b class="nc">&nbsp;                        if (loc == Warship.LOC_LBS) {</b>
<b class="nc">&nbsp;                            int locRoll = Compute.d6();</b>
<b class="nc">&nbsp;                            if (locRoll &lt; 4) {</b>
<b class="nc">&nbsp;                                loc = Jumpship.LOC_FLS;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                loc = Jumpship.LOC_ALS;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        if (loc == Warship.LOC_RBS) {</b>
<b class="nc">&nbsp;                            int locRoll = Compute.d6();</b>
<b class="nc">&nbsp;                            if (locRoll &lt; 4) {</b>
<b class="nc">&nbsp;                                loc = Jumpship.LOC_FRS;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                loc = Jumpship.LOC_ARS;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        r.add(te.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
<b class="nc">&nbsp;                        if (damage &gt; te.getArmor(loc)) {</b>
<b class="nc">&nbsp;                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc);</b>
<b class="nc">&nbsp;                            r = new Report(6090);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            te.setArmor(te.getArmor(loc) - damage, loc);</b>
<b class="nc">&nbsp;                            r = new Report(6085);</b>
<b class="nc">&nbsp;                            r.add(te.getArmor(loc));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
<b class="nc">&nbsp;                        damage = 0;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // check for overpenetration
<b class="nc">&nbsp;                    if (game.getOptions().booleanOption(</b>
&nbsp;                            OptionsConstants.ADVAERORULES_STRATOPS_OVER_PENETRATE)) {
<b class="nc">&nbsp;                        int opRoll = Compute.d6(1);</b>
<b class="nc">&nbsp;                        if ((((te instanceof Jumpship) || (te instanceof SpaceStation))</b>
&nbsp;                             &amp;&amp; !(te instanceof Warship) &amp;&amp; (opRoll &gt; 3))
&nbsp;                            || ((te instanceof Dropship) &amp;&amp; (opRoll &gt; 4))
&nbsp;                            || ((te instanceof Warship)
<b class="nc">&nbsp;                                &amp;&amp; (a.get0SI() &lt;= 30) &amp;&amp; (opRoll &gt; 5))) {</b>
&nbsp;                            // over-penetration happened
<b class="nc">&nbsp;                            r = new Report(9090);</b>
<b class="nc">&nbsp;                            r.subject = te_n;</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            vDesc.addElement(r);</b>
<b class="nc">&nbsp;                            int new_loc = a.getOppositeLocation(hit</b>
<b class="nc">&nbsp;                                                                        .getLocation());</b>
<b class="nc">&nbsp;                            damage = Math.min(damage, te.getArmor(new_loc));</b>
&nbsp;                            // We don&#39;t want to deal negative damage
<b class="nc">&nbsp;                            damage = Math.max(damage, 0);</b>
<b class="nc">&nbsp;                            r = new Report(6065);</b>
<b class="nc">&nbsp;                            r.subject = te_n;</b>
<b class="nc">&nbsp;                            r.indent(2);</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            r.addDesc(te);</b>
<b class="nc">&nbsp;                            r.add(damage);</b>
<b class="nc">&nbsp;                            r.add(te.getLocationAbbr(new_loc));</b>
<b class="nc">&nbsp;                            vDesc.addElement(r);</b>
<b class="nc">&nbsp;                            te.setArmor(te.getArmor(new_loc) - damage, new_loc);</b>
<b class="nc">&nbsp;                            if ((te instanceof Warship)</b>
&nbsp;                                || (te instanceof Dropship)) {
<b class="nc">&nbsp;                                damage = 2;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                damage = 0;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // divide damage in half
&nbsp;                    // do not divide by half if it is an ammo exposion
<b class="nc">&nbsp;                    if (!ammoExplosion &amp;&amp; !nukeS2S</b>
<b class="nc">&nbsp;                        &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;                        damage /= 2;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // this should result in a crit
&nbsp;                    // but only if it really did damage after rounding down
<b class="nc">&nbsp;                    if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                        critSI = true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Now apply damage to the structural integrity
<b class="nc">&nbsp;                    a.setSI(a.getSI() - damage);</b>
<b class="nc">&nbsp;                    te.damageThisPhase += damage;</b>
&nbsp;                    // send the report
<b class="nc">&nbsp;                    r = new Report(1210);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.newlines = 1;</b>
<b class="nc">&nbsp;                    if (!ammoExplosion) {</b>
<b class="nc">&nbsp;                        r.messageId = 9005;</b>
&nbsp;                    }
&nbsp;                    //Only for fighters
<b class="nc">&nbsp;                    if (ammoExplosion &amp;&amp; !a.isLargeCraft()) {</b>
<b class="nc">&nbsp;                        r.messageId = 9006;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    r.add(Math.max(a.getSI(), 0));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                    // check to see if this would destroy the ASF
<b class="nc">&nbsp;                    if (a.getSI() &lt;= 0) {</b>
&nbsp;                        // Lets auto-eject if we can!
<b class="nc">&nbsp;                        if (a.isAutoEject()</b>
<b class="nc">&nbsp;                            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                    || (game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION) </b>
<b class="nc">&nbsp;                                            &amp;&amp; a.isCondEjectSIDest()))) {</b>
<b class="nc">&nbsp;                            vDesc.addAll(ejectEntity(te, true, false));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            vDesc.addAll(destroyEntity(te,&quot;Structural Integrity Collapse&quot;));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        a.setSI(0);</b>
<b class="nc">&nbsp;                        if (hit.getAttackerId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                            creditKill(a, game.getEntity(hit.getAttackerId()));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    checkAeroCrits(vDesc, a, hit, damage_orig, critThresh, critSI, ammoExplosion, nukeS2S);</b>
<b class="nc">&nbsp;                    return vDesc;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Check for CASE II right away. if so reduce damage to 1
&nbsp;                // and let it hit the IS.
&nbsp;                // Also remove as much of the rear armor as allowed by the
&nbsp;                // damage. If arm/leg/head
&nbsp;                // Then they lose all their armor if its less then the
&nbsp;                // explosion damage.
<b class="nc">&nbsp;                if (ammoExplosion &amp;&amp; te.hasCASEII(hit.getLocation())) {</b>
&nbsp;                    // 1 point of damage goes to IS
<b class="nc">&nbsp;                    damage--;</b>
&nbsp;                    // Remaining damage prevented by CASE II
<b class="nc">&nbsp;                    r = new Report(6126);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    int loc = hit.getLocation();</b>
<b class="nc">&nbsp;                    if ((te instanceof Mech) &amp;&amp; ((loc == Mech.LOC_HEAD) || ((Mech) te).isArm(loc)</b>
<b class="nc">&nbsp;                            || te.locationIsLeg(loc))) {</b>
<b class="nc">&nbsp;                        int half = (int) Math.ceil(te.getOArmor(loc, false) / 2.0);</b>
<b class="nc">&nbsp;                        if (damage &gt; half) {</b>
<b class="nc">&nbsp;                            damage = half;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (damage &gt;= te.getArmor(loc, false)) {</b>
<b class="nc">&nbsp;                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc, false);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            te.setArmor(te.getArmor(loc, false) - damage, loc, false);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        if (damage &gt;= te.getArmor(loc, true)) {</b>
<b class="nc">&nbsp;                            te.setArmor(IArmorState.ARMOR_DESTROYED, loc, true);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            te.setArmor(te.getArmor(loc, true) - damage, loc, true);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (te.getInternal(hit) &gt; 0) {</b>
&nbsp;                        // Mek takes 1 point of IS damage
<b class="nc">&nbsp;                        damage = 1;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        damage = 0;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    te.damageThisPhase += damage;</b>
&nbsp;
<b class="nc">&nbsp;                    int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    r = new Report(6127);</b>
<b class="nc">&nbsp;                    r.subject = te.getId();</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    if (roll &gt;= 8) {</b>
<b class="nc">&nbsp;                        hit.setEffect(HitData.EFFECT_NO_CRITICALS);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // check for tank CASE here: damage to rear armor, excess
&nbsp;                // dissipating, and a crew stunned crit
<b class="nc">&nbsp;                if (ammoExplosion &amp;&amp; (te instanceof Tank)</b>
<b class="nc">&nbsp;                    &amp;&amp; te.locationHasCase(Tank.LOC_BODY)) {</b>
<b class="nc">&nbsp;                    te.damageThisPhase += damage;</b>
<b class="nc">&nbsp;                    r = new Report(6124);</b>
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    int loc = (te instanceof SuperHeavyTank) ? SuperHeavyTank.LOC_REAR</b>
<b class="nc">&nbsp;                            : (te instanceof LargeSupportTank) ? LargeSupportTank.LOC_REAR : Tank.LOC_REAR;</b>
<b class="nc">&nbsp;                    if (damage &gt; te.getArmor(loc)) {</b>
<b class="nc">&nbsp;                        te.setArmor(IArmorState.ARMOR_DESTROYED, loc);</b>
<b class="nc">&nbsp;                        r = new Report(6090);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        te.setArmor(te.getArmor(loc) - damage, loc);</b>
<b class="nc">&nbsp;                        r = new Report(6085);</b>
<b class="nc">&nbsp;                        r.add(te.getArmor(loc));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.subject = te_n;</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    damage = 0;</b>
&nbsp;                    int critIndex;
<b class="nc">&nbsp;                    if (((Tank) te).isCommanderHit()</b>
<b class="nc">&nbsp;                        &amp;&amp; ((Tank) te).isDriverHit()) {</b>
<b class="nc">&nbsp;                        critIndex = Tank.CRIT_CREW_KILLED;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        critIndex = Tank.CRIT_CREW_STUNNED;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vDesc.addAll(applyCriticalHit(te, Entity.NONE, new CriticalSlot(0, critIndex), true, 0, false));</b>
&nbsp;                }
&nbsp;
&nbsp;                // is there internal structure in the location hit?
<b class="nc">&nbsp;                if (te.getInternal(hit) &gt; 0) {</b>
&nbsp;
&nbsp;                    // Now we need to consider alternate structure types!
<b class="nc">&nbsp;                    int tmpDamageHold = -1;</b>
<b class="nc">&nbsp;                    if ((te instanceof Mech)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((Mech) te).hasCompositeStructure()) {</b>
<b class="nc">&nbsp;                        tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                        damage *= 2;</b>
<b class="nc">&nbsp;                        r = new Report(6091);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((te instanceof Mech)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((Mech) te).hasReinforcedStructure()) {</b>
<b class="nc">&nbsp;                        tmpDamageHold = damage;</b>
<b class="nc">&nbsp;                        damage /= 2;</b>
<b class="nc">&nbsp;                        damage += tmpDamageHold % 2;</b>
<b class="nc">&nbsp;                        r = new Report(6092);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((te.getInternal(hit) &gt; damage) &amp;&amp; (damage &gt; 0)) {</b>
&nbsp;                        // internal structure absorbs all damage
<b class="nc">&nbsp;                        te.setInternal(te.getInternal(hit) - damage, hit);</b>
&nbsp;                        // Triggers a critical hit on Vehicles and Mechs.
<b class="nc">&nbsp;                        if (!isPlatoon &amp;&amp; !isBattleArmor) {</b>
<b class="nc">&nbsp;                            crits++;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        tookInternalDamage = true;</b>
&nbsp;                        // Alternate structures don&#39;t affect our damage total
&nbsp;                        // for later PSR purposes, so use the previously stored
&nbsp;                        // value here as necessary.
<b class="nc">&nbsp;                        te.damageThisPhase += (tmpDamageHold &gt; -1) ?</b>
<b class="nc">&nbsp;                                tmpDamageHold : damage;</b>
<b class="nc">&nbsp;                        damage = 0;</b>
<b class="nc">&nbsp;                        r = new Report(6100);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
&nbsp;                        // Infantry platoons have men not &quot;Internals&quot;.
<b class="nc">&nbsp;                        if (isPlatoon) {</b>
<b class="nc">&nbsp;                            r.messageId = 6095;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        r.add(te.getInternal(hit));</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    } else if (damage &gt; 0) {</b>
&nbsp;                        // Triggers a critical hit on Vehicles and Mechs.
<b class="nc">&nbsp;                        if (!isPlatoon &amp;&amp; !isBattleArmor) {</b>
<b class="nc">&nbsp;                            crits++;</b>
&nbsp;                        }
&nbsp;                        // damage transfers, maybe
<b class="nc">&nbsp;                        int absorbed = Math.max(te.getInternal(hit), 0);</b>
&nbsp;
&nbsp;                        // Handle ProtoMech pilot damage
&nbsp;                        // due to location destruction
<b class="nc">&nbsp;                        if (te instanceof Protomech) {</b>
<b class="nc">&nbsp;                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]</b>
<b class="nc">&nbsp;                                    - ((Protomech) te).getPilotDamageTaken(hit.getLocation());</b>
<b class="nc">&nbsp;                            if (hits &gt; 0) {</b>
<b class="nc">&nbsp;                                vDesc.addAll(damageCrew(te, hits));</b>
<b class="nc">&nbsp;                                ((Protomech) te).setPilotDamageTaken(hit.getLocation(),</b>
<b class="nc">&nbsp;                                        Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // Platoon, Trooper, or Section destroyed message
<b class="nc">&nbsp;                        r = new Report(1210);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        if (isPlatoon) {</b>
&nbsp;                            // Infantry have only one section, and
&nbsp;                            // are therefore destroyed.
<b class="nc">&nbsp;                            if (((Infantry) te).isSquad()) {</b>
<b class="nc">&nbsp;                                r.messageId = 6106; // Squad Killed</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                r.messageId = 6105; // Platoon Killed</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } else if (isBattleArmor) {</b>
<b class="nc">&nbsp;                            r.messageId = 6110;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r.messageId = 6115;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;
&nbsp;                        // If a sidetorso got destroyed, and the
&nbsp;                        // corresponding arm is not yet destroyed, add
&nbsp;                        // it as a club to that hex (p.35 BMRr)
<b class="nc">&nbsp;                        if ((te instanceof Mech)</b>
<b class="nc">&nbsp;                                &amp;&amp; (((hit.getLocation() == Mech.LOC_RT)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (te.getInternal(Mech.LOC_RARM) &gt; 0))</b>
<b class="nc">&nbsp;                                    || ((hit.getLocation() == Mech.LOC_LT)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (te.getInternal(Mech.LOC_LARM) &gt; 0)))) {</b>
&nbsp;                            int blownOffLocation;
<b class="nc">&nbsp;                            if (hit.getLocation() == Mech.LOC_RT) {</b>
<b class="nc">&nbsp;                                blownOffLocation = Mech.LOC_RARM;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                blownOffLocation = Mech.LOC_LARM;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            te.destroyLocation(blownOffLocation, true);</b>
<b class="nc">&nbsp;                            r = new Report(6120);</b>
<b class="nc">&nbsp;                            r.subject = te_n;</b>
<b class="nc">&nbsp;                            r.add(te.getLocationName(blownOffLocation));</b>
<b class="nc">&nbsp;                            vDesc.addElement(r);</b>
<b class="nc">&nbsp;                            IHex h = game.getBoard().getHex(te.getPosition());</b>
<b class="nc">&nbsp;                            if(null != h) {</b>
<b class="nc">&nbsp;                                if (te instanceof BipedMech) {</b>
<b class="nc">&nbsp;                                    if (!h.containsTerrain(Terrains.ARMS)) {</b>
<b class="nc">&nbsp;                                        h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                                             .createTerrain(Terrains.ARMS, 1));</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        h.addTerrain(Terrains</b>
<b class="nc">&nbsp;                                                             .getTerrainFactory()</b>
<b class="nc">&nbsp;                                                             .createTerrain(</b>
&nbsp;                                                                     Terrains.ARMS,
<b class="nc">&nbsp;                                                                     h.terrainLevel(Terrains.ARMS) + 1));</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                } else if (!h.containsTerrain(Terrains.LEGS)) {</b>
<b class="nc">&nbsp;                                    h.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                                         .createTerrain(Terrains.LEGS, 1));</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    h.addTerrain(Terrains</b>
<b class="nc">&nbsp;                                                         .getTerrainFactory()</b>
<b class="nc">&nbsp;                                                         .createTerrain(</b>
&nbsp;                                                                 Terrains.LEGS,
<b class="nc">&nbsp;                                                                 h.terrainLevel(Terrains.LEGS) + 1));</b>
&nbsp;                                }
<b class="nc">&nbsp;                                sendChangedHex(te.getPosition());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // Troopers riding on a location
&nbsp;                        // all die when the location is destroyed.
<b class="nc">&nbsp;                        if ((te instanceof Mech) || (te instanceof Tank)) {</b>
<b class="nc">&nbsp;                            Entity passenger = te.getExteriorUnitAt(</b>
<b class="nc">&nbsp;                                    hit.getLocation(), hit.isRear());</b>
<b class="nc">&nbsp;                            if ((null != passenger) &amp;&amp; !passenger.isDoomed()) {</b>
<b class="nc">&nbsp;                                HitData passHit = passenger</b>
<b class="nc">&nbsp;                                        .getTrooperAtLocation(hit, te);</b>
&nbsp;                                // ensures a kill
<b class="nc">&nbsp;                                passHit.setEffect(HitData.EFFECT_CRITICAL);</b>
<b class="nc">&nbsp;                                if (passenger.getInternal(passHit) &gt; 0) {</b>
<b class="nc">&nbsp;                                    vDesc.addAll(damageEntity(passenger,</b>
&nbsp;                                                              passHit, damage));
&nbsp;                                }
<b class="nc">&nbsp;                                passHit = new HitData(hit.getLocation(),</b>
<b class="nc">&nbsp;                                                      !hit.isRear());</b>
<b class="nc">&nbsp;                                passHit = passenger.getTrooperAtLocation(</b>
&nbsp;                                        passHit, te);
&nbsp;                                // ensures a kill
<b class="nc">&nbsp;                                passHit.setEffect(HitData.EFFECT_CRITICAL);</b>
<b class="nc">&nbsp;                                if (passenger.getInternal(passHit) &gt; 0) {</b>
<b class="nc">&nbsp;                                    vDesc.addAll(damageEntity(passenger,</b>
&nbsp;                                                              passHit, damage));
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // BA inferno explosions
<b class="nc">&nbsp;                        if (te instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                            int infernos = 0;</b>
<b class="nc">&nbsp;                            for (Mounted m : te.getEquipment()) {</b>
<b class="nc">&nbsp;                                if (m.getType() instanceof AmmoType) {</b>
<b class="nc">&nbsp;                                    AmmoType at = (AmmoType) m.getType();</b>
<b class="nc">&nbsp;                                    if (((at.getAmmoType() == AmmoType.T_SRM) || (at.getAmmoType() == AmmoType.T_MML))</b>
<b class="nc">&nbsp;                                            &amp;&amp; (at.getMunitionType() == AmmoType.M_INFERNO)) {</b>
<b class="nc">&nbsp;                                        infernos += at.getRackSize() * m.getHittableShotsLeft();</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                } else if (m.getType().hasFlag(MiscType.F_FIRE_RESISTANT)) {</b>
&nbsp;                                    // immune to inferno explosion
<b class="nc">&nbsp;                                    infernos = 0;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            if (infernos &gt; 0) {</b>
<b class="nc">&nbsp;                                int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                                r = new Report(6680);</b>
<b class="nc">&nbsp;                                r.add(roll);</b>
<b class="nc">&nbsp;                                vDesc.add(r);</b>
<b class="nc">&nbsp;                                if (roll &gt;= 8) {</b>
<b class="nc">&nbsp;                                    Coords c = te.getPosition();</b>
<b class="nc">&nbsp;                                    if (c == null) {</b>
<b class="nc">&nbsp;                                        Entity transport = game.getEntity(te.getTransportId());</b>
<b class="nc">&nbsp;                                        if (transport != null) {</b>
<b class="nc">&nbsp;                                            c = transport.getPosition();</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                        vPhaseReport.addAll(deliverInfernoMissiles(te, te, infernos));</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    if (c != null) {</b>
<b class="nc">&nbsp;                                        vPhaseReport.addAll(deliverInfernoMissiles(te,</b>
<b class="nc">&nbsp;                                                new HexTarget(c, game.getBoard(), Targetable.TYPE_HEX_ARTILLERY),</b>
&nbsp;                                                infernos));
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // Mark off the internal structure here, but *don&#39;t*
&nbsp;                        // destroy the location just yet -- there are checks
&nbsp;                        // still to run!
<b class="nc">&nbsp;                        te.setInternal(0, hit);</b>
<b class="nc">&nbsp;                        te.damageThisPhase += absorbed;</b>
<b class="nc">&nbsp;                        damage -= absorbed;</b>
&nbsp;
&nbsp;                        // Now we need to consider alternate structure types!
<b class="nc">&nbsp;                        if (tmpDamageHold &gt; 0) {</b>
<b class="nc">&nbsp;                            if (((Mech) te).hasCompositeStructure()) {</b>
&nbsp;                                // If there&#39;s a remainder, we can actually
&nbsp;                                // ignore it.
<b class="nc">&nbsp;                                damage /= 2;</b>
<b class="nc">&nbsp;                            } else if (((Mech) te).hasReinforcedStructure()) {</b>
<b class="nc">&nbsp;                                damage *= 2;</b>
<b class="nc">&nbsp;                                damage -= tmpDamageHold % 2;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (te.getInternal(hit) &lt;= 0) {</b>
&nbsp;                    // internal structure is gone, what are the transfer
&nbsp;                    // potentials?
<b class="nc">&nbsp;                    nextHit = te.getTransferLocation(hit);</b>
<b class="nc">&nbsp;                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {</b>
<b class="nc">&nbsp;                        if (te instanceof Mech) {</b>
&nbsp;                            // Start with the number of engine crits in this
&nbsp;                            // location, if any...
<b class="nc">&nbsp;                            te.engineHitsThisPhase += te.getNumberOfCriticals(</b>
&nbsp;                                    CriticalSlot.TYPE_SYSTEM,
<b class="nc">&nbsp;                                    Mech.SYSTEM_ENGINE, hit.getLocation());</b>
&nbsp;                            // ...then deduct the ones destroyed previously or
&nbsp;                            // critically
&nbsp;                            // hit this round already. That leaves the ones
&nbsp;                            // actually
&nbsp;                            // destroyed with the location.
<b class="nc">&nbsp;                            te.engineHitsThisPhase -= te.getHitCriticals(</b>
&nbsp;                                    CriticalSlot.TYPE_SYSTEM,
<b class="nc">&nbsp;                                    Mech.SYSTEM_ENGINE, hit.getLocation());</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        boolean engineExploded = checkEngineExplosion(te,</b>
&nbsp;                                vDesc, te.engineHitsThisPhase);
&nbsp;
<b class="nc">&nbsp;                        if (!engineExploded) {</b>
&nbsp;                            // Entity destroyed. Ammo explosions are
&nbsp;                            // neither survivable nor salvageable.
&nbsp;                            // Only ammo explosions in the CT are devastating.
<b class="nc">&nbsp;                            vDesc.addAll(destroyEntity(te, &quot;damage&quot;, !ammoExplosion,</b>
&nbsp;                                    !((ammoExplosion || areaSatArty) &amp;&amp; ((te instanceof Tank)
<b class="nc">&nbsp;                                            || ((te instanceof Mech) &amp;&amp; (hit.getLocation() == Mech.LOC_CT))))));</b>
&nbsp;                            // If the head is destroyed, kill the crew.
&nbsp;
<b class="nc">&nbsp;                            if ((te instanceof Mech) &amp;&amp; (hit.getLocation() == Mech.LOC_HEAD)</b>
<b class="nc">&nbsp;                                    &amp;&amp; !te.getCrew().isDead() &amp;&amp; !te.getCrew().isDoomed()</b>
<b class="nc">&nbsp;                                    &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                                            OptionsConstants.ADVANCED_TACOPS_SKIN_OF_THE_TEETH_EJECTION)) {
<b class="nc">&nbsp;                                Mech mech = (Mech) te;</b>
<b class="nc">&nbsp;                                if (mech.isAutoEject()</b>
<b class="nc">&nbsp;                                        &amp;&amp; (!game.getOptions().booleanOption(</b>
&nbsp;                                                OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                                        || (game.getOptions().booleanOption(</b>
&nbsp;                                                OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                                                &amp;&amp; mech.isCondEjectHeadshot()))) {</b>
<b class="nc">&nbsp;                                    autoEject = true;</b>
<b class="nc">&nbsp;                                    vDesc.addAll(ejectEntity(te, true, true));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            if ((te instanceof Mech) &amp;&amp; (hit.getLocation() == Mech.LOC_CT)</b>
<b class="nc">&nbsp;                                    &amp;&amp; !te.getCrew().isDead() &amp;&amp; !te.getCrew().isDoomed()) {</b>
<b class="nc">&nbsp;                                Mech mech = (Mech) te;</b>
<b class="nc">&nbsp;                                if (mech.isAutoEject()</b>
<b class="nc">&nbsp;                                        &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                                                OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                                        &amp;&amp; mech.isCondEjectCTDest()) {</b>
<b class="nc">&nbsp;                                    if (mech.getCrew().getHits() &lt; 5) {</b>
<b class="nc">&nbsp;                                        Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                                        mech.setDoomed(false);</b>
<b class="nc">&nbsp;                                        mech.setDoomed(true);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    autoEject = true;</b>
<b class="nc">&nbsp;                                    vDesc.addAll(ejectEntity(te, true));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            if ((hit.getLocation() == Mech.LOC_HEAD)</b>
<b class="nc">&nbsp;                                    || ((hit.getLocation() == Mech.LOC_CT)</b>
&nbsp;                                    &amp;&amp; ((ammoExplosion &amp;&amp; !autoEject) || areaSatArty))) {
<b class="nc">&nbsp;                                te.getCrew().setDoomed(true);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (game.getOptions().booleanOption(</b>
&nbsp;                                    OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {
<b class="nc">&nbsp;                                vDesc.addAll(abandonEntity(te));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // nowhere for further damage to go
<b class="nc">&nbsp;                        damage = 0;</b>
<b class="nc">&nbsp;                    } else if (nextHit.getLocation() == Entity.LOC_NONE) {</b>
&nbsp;                        // Rest of the damage is wasted.
<b class="nc">&nbsp;                        damage = 0;</b>
<b class="nc">&nbsp;                    } else if (ammoExplosion</b>
<b class="nc">&nbsp;                               &amp;&amp; te.locationHasCase(hit.getLocation())) {</b>
&nbsp;                        // Remaining damage prevented by CASE
<b class="nc">&nbsp;                        r = new Report(6125);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.add(damage);</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;
&nbsp;                        // The target takes no more damage from the explosion.
<b class="nc">&nbsp;                        damage = 0;</b>
<b class="nc">&nbsp;                    } else if (damage &gt; 0) {</b>
&nbsp;                        // remaining damage transfers
<b class="nc">&nbsp;                        r = new Report(6130);</b>
<b class="nc">&nbsp;                        r.subject = te_n;</b>
<b class="nc">&nbsp;                        r.indent(2);</b>
<b class="nc">&nbsp;                        r.add(damage);</b>
<b class="nc">&nbsp;                        r.add(te.getLocationAbbr(nextHit));</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;
&nbsp;                        // If there are split weapons in this location, mark it
&nbsp;                        // as hit, even if it took no criticals.
<b class="nc">&nbsp;                        for (Mounted m : te.getWeaponList()) {</b>
<b class="nc">&nbsp;                            if (m.isSplit()) {</b>
<b class="nc">&nbsp;                                if ((m.getLocation() == hit.getLocation())</b>
<b class="nc">&nbsp;                                    || (m.getLocation() == nextHit</b>
<b class="nc">&nbsp;                                        .getLocation())) {</b>
<b class="nc">&nbsp;                                    te.setWeaponHit(m);</b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                        // if this is damage from a nail/rivet gun, and we
&nbsp;                        // transfer
&nbsp;                        // to a location that has armor, and BAR &gt;=5, no damage
<b class="nc">&nbsp;                        if ((bFrag == DamageType.NAIL_RIVET)</b>
<b class="nc">&nbsp;                            &amp;&amp; (te.getArmor(nextHit.getLocation()) &gt; 0)</b>
<b class="nc">&nbsp;                            &amp;&amp; (te.getBARRating(nextHit.getLocation()) &gt;= 5)) {</b>
<b class="nc">&nbsp;                            damage = 0;</b>
<b class="nc">&nbsp;                            r = new Report(6065);</b>
<b class="nc">&nbsp;                            r.subject = te_n;</b>
<b class="nc">&nbsp;                            r.indent(2);</b>
<b class="nc">&nbsp;                            vDesc.add(r);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (hit.getSpecCrit()) {</b>
&nbsp;                // ok, we dealt damage but didn&#39;t go on to internal
&nbsp;                // we get a chance of a crit, using Armor Piercing.
&nbsp;                // but only if we don&#39;t have hardened, Ferro-Lamellor, or reactive armor
<b class="nc">&nbsp;                if (!hardenedArmor &amp;&amp; !ferroLamellorArmor &amp;&amp; !reactiveArmor) {</b>
<b class="nc">&nbsp;                    specCrits++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // check for breaching
<b class="nc">&nbsp;            vDesc.addAll(breachCheck(te, hit.getLocation(), null, underWater));</b>
&nbsp;
&nbsp;            // resolve special results
<b class="nc">&nbsp;            if ((hit.getEffect() &amp; HitData.EFFECT_VEHICLE_MOVE_DAMAGED) == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {</b>
<b class="nc">&nbsp;                vDesc.addAll(vehicleMotiveDamage((Tank) te, hit.getMotiveMod()));</b>
&nbsp;            }
&nbsp;            // Damage from any source can break spikes
<b class="nc">&nbsp;            if (te.hasWorkingMisc(MiscType.F_SPIKES, -1, hit.getLocation())) {</b>
<b class="nc">&nbsp;                vDesc.add(checkBreakSpikes(te, hit.getLocation()));</b>
&nbsp;            }
&nbsp;
&nbsp;            // roll all critical hits against this location
&nbsp;            // unless the section destroyed in a previous phase?
&nbsp;            // Cause a crit.
<b class="nc">&nbsp;            if ((te.getInternal(hit) != IArmorState.ARMOR_DESTROYED)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((hit.getEffect() &amp; HitData.EFFECT_NO_CRITICALS) != HitData.EFFECT_NO_CRITICALS)) {</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; crits; i++) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(criticalEntity(te, hit.getLocation(), hit.isRear(),</b>
<b class="nc">&nbsp;                            hit.glancingMod() + critBonus, damage_orig));</b>
&nbsp;                }
<b class="nc">&nbsp;                crits = 0;</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; specCrits; i++) {</b>
&nbsp;                    // against BAR or reflective armor, we get a +2 mod
<b class="nc">&nbsp;                    int critMod = te.hasBARArmor(hit.getLocation()) ? 2 : 0;</b>
<b class="nc">&nbsp;                    critMod += (reflectiveArmor &amp;&amp; !isBattleArmor) ? 2 : 0; // BA</b>
&nbsp;                    // against impact armor, we get a +1 mod
<b class="nc">&nbsp;                    critMod += impactArmor ? 1 : 0;</b>
&nbsp;                    // hardened armour has no crit penalty
<b class="nc">&nbsp;                    if (!hardenedArmor) {</b>
&nbsp;                        // non-hardened armor gets modifiers
&nbsp;                        // the -2 for hardened is handled in the critBonus
&nbsp;                        // variable
<b class="nc">&nbsp;                        critMod += hit.getSpecCritMod();</b>
<b class="nc">&nbsp;                        critMod += hit.glancingMod();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vDesc.addAll(criticalEntity(te, hit.getLocation(), hit.isRear(),</b>
&nbsp;                            critMod + critBonus, damage_orig));
&nbsp;                }
<b class="nc">&nbsp;                specCrits = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // resolve Aero crits
<b class="nc">&nbsp;            if (te instanceof Aero) {</b>
<b class="nc">&nbsp;                checkAeroCrits(vDesc, (Aero) te, hit, damage_orig, critThresh, critSI,</b>
&nbsp;                        ammoExplosion, nukeS2S);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (isHeadHit</b>
<b class="nc">&nbsp;                &amp;&amp; !te.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)) {</b>
<b class="nc">&nbsp;                Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(te, 1));</b>
&nbsp;            }
&nbsp;
&nbsp;            // If the location has run out of internal structure, finally
&nbsp;            // actually
&nbsp;            // destroy it here. *EXCEPTION:* Aero units have 0 internal
&nbsp;            // structure
&nbsp;            // in every location by default and are handled elsewhere, so they
&nbsp;            // get a bye.
<b class="nc">&nbsp;            if (!(te instanceof Aero) &amp;&amp; (te.getInternal(hit) &lt;= 0)) {</b>
<b class="nc">&nbsp;                te.destroyLocation(hit.getLocation());</b>
&nbsp;
&nbsp;                // Check for possible engine destruction here
<b class="nc">&nbsp;                if ((te instanceof Mech)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((hit.getLocation() == Mech.LOC_RT) || (hit.getLocation() == Mech.LOC_LT))) {</b>
&nbsp;
<b class="nc">&nbsp;                    int numEngineHits = te.getEngineHits();</b>
<b class="nc">&nbsp;                    boolean engineExploded = checkEngineExplosion(te, vDesc, numEngineHits);</b>
&nbsp;
<b class="nc">&nbsp;                    int hitsToDestroy = 3;</b>
<b class="nc">&nbsp;                    if ((te instanceof Mech) &amp;&amp; te.isSuperHeavy() &amp;&amp; te.hasEngine()</b>
<b class="nc">&nbsp;                            &amp;&amp; (te.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {</b>
<b class="nc">&nbsp;                        hitsToDestroy = 2;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (!engineExploded &amp;&amp; (numEngineHits &gt;= hitsToDestroy)) {</b>
&nbsp;                        // third engine hit
<b class="nc">&nbsp;                        vDesc.addAll(destroyEntity(te, &quot;engine destruction&quot;));</b>
<b class="nc">&nbsp;                        if (game.getOptions()</b>
<b class="nc">&nbsp;                                .booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {</b>
<b class="nc">&nbsp;                            vDesc.addAll(abandonEntity(te));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        te.setSelfDestructing(false);</b>
<b class="nc">&nbsp;                        te.setSelfDestructInitiated(false);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Torso destruction in airborne LAM causes immediate crash.
<b class="nc">&nbsp;                    if ((te instanceof LandAirMech) &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed()) {</b>
<b class="nc">&nbsp;                        r = new Report(9710);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(te);</b>
<b class="nc">&nbsp;                        if (te.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                            vDesc.add(r);</b>
<b class="nc">&nbsp;                            crashAirMech(te, new PilotingRollData(te.getId(), TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                    &quot;side torso destroyed&quot;), vDesc);
<b class="nc">&nbsp;                        } else if (te.isAirborne() &amp;&amp; te.isAero()) {</b>
<b class="nc">&nbsp;                            vDesc.add(r);</b>
<b class="nc">&nbsp;                            vDesc.addAll(processCrash(te, ((IAero)te).getCurrentVelocity(), te.getPosition()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            // If damage remains, loop to next location; if not, be sure to stop
&nbsp;            // here because we may need to refer back to the last *damaged*
&nbsp;            // location again later. (This is safe because at damage &lt;= 0 the
&nbsp;            // loop terminates anyway.)
<b class="nc">&nbsp;            if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                hit = nextHit;</b>
&nbsp;                // Need to update armor status for the new location
<b class="nc">&nbsp;                hardenedArmor = ((te instanceof Mech) || (te instanceof Tank))</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_HARDENED);</b>
<b class="nc">&nbsp;                ferroLamellorArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_FERRO_LAMELLOR);</b>
<b class="nc">&nbsp;                reflectiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REFLECTIVE))</b>
&nbsp;                        || (isBattleArmor
<b class="nc">&nbsp;                                &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REFLECTIVE));</b>
<b class="nc">&nbsp;                reactiveArmor = (((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_REACTIVE))</b>
<b class="nc">&nbsp;                        || (isBattleArmor &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BA_REACTIVE));</b>
<b class="nc">&nbsp;                ballisticArmor = ((te instanceof Mech) || (te instanceof Tank) || (te instanceof Aero))</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_BALLISTIC_REINFORCED);</b>
<b class="nc">&nbsp;                impactArmor = (te instanceof Mech)</b>
<b class="nc">&nbsp;                        &amp;&amp; (te.getArmorType(hit.getLocation()) == EquipmentType.T_ARMOR_IMPACT_RESISTANT);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (damageIS) {</b>
<b class="nc">&nbsp;                wasDamageIS = true;</b>
<b class="nc">&nbsp;                damageIS = false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Mechs using EI implants take pilot damage each time a hit
&nbsp;        // inflicts IS damage
<b class="nc">&nbsp;        if (tookInternalDamage</b>
&nbsp;            &amp;&amp; ((te instanceof Mech) || (te instanceof Protomech))
<b class="nc">&nbsp;            &amp;&amp; te.hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(5075);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            r.add(7);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.choose(roll &gt;= 7);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            if (roll &lt; 7) {</b>
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(te, 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if using VDNI (but not buffered), check for damage on an internal hit
<b class="nc">&nbsp;        if (tookInternalDamage</b>
<b class="nc">&nbsp;            &amp;&amp; te.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;            &amp;&amp; !te.hasAbility(OptionsConstants.MD_BVDNI)</b>
<b class="nc">&nbsp;            &amp;&amp; !te.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {</b>
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(3580);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            r.add(7);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.choose(roll &gt;= 8);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            if (roll &gt;= 8) {</b>
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(te, 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // TacOps p.78 Ammo booms can hurt other units in same and adjacent hexes
&nbsp;        // But, this does not apply to CASE&#39;d units and it only applies if the
&nbsp;        // ammo explosion
&nbsp;        // destroyed the unit
<b class="nc">&nbsp;        if (ammoExplosion &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_AMMUNITION)</b>
&nbsp;            // For &#39;Mechs we care whether there was CASE specifically in the
&nbsp;            // location that went boom...
<b class="nc">&nbsp;            &amp;&amp; !(te.locationHasCase(hit.getLocation()) || te.hasCASEII(hit.getLocation()))</b>
&nbsp;            // ...but vehicles and ASFs just have one CASE item for the
&nbsp;            // whole unit, so we need to look whether there&#39;s CASE anywhere
&nbsp;            // at all.
&nbsp;            &amp;&amp; !(((te instanceof Tank) || (te instanceof Aero)) &amp;&amp; te
<b class="nc">&nbsp;                .hasCase()) &amp;&amp; (te.isDestroyed() || te.isDoomed())</b>
&nbsp;            &amp;&amp; (damage_orig &gt; 0) &amp;&amp; ((damage_orig / 10) &gt; 0)) {
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            r = new Report(5068, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.addDesc(te);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            r = new Report(5400, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            int[] damages = {(int) Math.floor(damage_orig / 10.0),</b>
<b class="nc">&nbsp;                             (int) Math.floor(damage_orig / 20.0)};</b>
<b class="nc">&nbsp;            doExplosion(damages, false, te.getPosition(), true, vDesc, null, 5,</b>
<b class="nc">&nbsp;                        te.getId(), false);</b>
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            r = new Report(5410, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // This flag indicates the hit was directly to IS
<b class="nc">&nbsp;        if (wasDamageIS) {</b>
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply damage to an Entity carrying external Battle Armor or ProtoMech
&nbsp;     * when a location with a trooper present is hit.
&nbsp;     *
&nbsp;     * @param te             The carrying Entity
&nbsp;     * @param hit            The hit to resolve
&nbsp;     * @param damage         The amount of damage to be allocated
&nbsp;     * @param vDesc          The report vector
&nbsp;     * @param passenger      The BA squad
&nbsp;     * @return               The amount of damage remaining
&nbsp;     */
&nbsp;    private int damageExternalPassenger(Entity te, HitData hit, int damage, Vector&lt;Report&gt; vDesc,
&nbsp;                                        Entity passenger) {
&nbsp;        Report r;
<b class="nc">&nbsp;        int passengerDamage = damage;</b>
<b class="nc">&nbsp;        int avoidRoll = Compute.d6();</b>
<b class="nc">&nbsp;        HitData passHit = passenger.getTrooperAtLocation(hit, te);</b>
<b class="nc">&nbsp;        if (passenger.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {</b>
<b class="nc">&nbsp;            passengerDamage -= damage / 2;</b>
<b class="nc">&nbsp;            passHit = passenger.rollHitLocation(ToHitData.HIT_SPECIAL_PROTO, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;        } else if (avoidRoll &lt; 5) {</b>
<b class="nc">&nbsp;            passengerDamage = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        passHit.setGeneralDamageType(hit.getGeneralDamageType());</b>
&nbsp;
<b class="nc">&nbsp;        if (passengerDamage &gt; 0) {</b>
&nbsp;            // Yup. Roll up some hit data for that passenger.
<b class="nc">&nbsp;            r = new Report(6075);</b>
<b class="nc">&nbsp;            r.subject = passenger.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.addDesc(passenger);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
&nbsp;            // How much damage will the passenger absorb?
<b class="nc">&nbsp;            int absorb = 0;</b>
<b class="nc">&nbsp;            HitData nextPassHit = passHit;</b>
&nbsp;            do {
<b class="nc">&nbsp;                int armorType = passenger.getArmorType(nextPassHit.getLocation());</b>
<b class="nc">&nbsp;                boolean armorDamageReduction = false;</b>
<b class="nc">&nbsp;                if (((armorType == EquipmentType.T_ARMOR_BA_REACTIVE)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((hit.getGeneralDamageType() == HitData.DAMAGE_MISSILE)))</b>
<b class="nc">&nbsp;                        || (hit.getGeneralDamageType() == HitData.DAMAGE_ARMOR_PIERCING_MISSILE)) {</b>
<b class="nc">&nbsp;                    armorDamageReduction = true;</b>
&nbsp;                }
&nbsp;                // Check for reflective armor
<b class="nc">&nbsp;                if ((armorType == EquipmentType.T_ARMOR_BA_REFLECTIVE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (hit.getGeneralDamageType() == HitData.DAMAGE_ENERGY)) {</b>
<b class="nc">&nbsp;                    armorDamageReduction = true;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (0 &lt; passenger.getArmor(nextPassHit)) {</b>
<b class="nc">&nbsp;                    absorb += passenger.getArmor(nextPassHit);</b>
<b class="nc">&nbsp;                    if (armorDamageReduction) {</b>
<b class="nc">&nbsp;                        absorb *= 2;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (0 &lt; passenger.getInternal(nextPassHit)) {</b>
<b class="nc">&nbsp;                    absorb += passenger.getInternal(nextPassHit);</b>
&nbsp;                    // Armor damage reduction, like for reflective or
&nbsp;                    // reactive armor will divide the whole damage
&nbsp;                    // total by 2 and round down. If we have an odd
&nbsp;                    // damage total, need to add 1 to make this
&nbsp;                    // evenly divisible by 2
<b class="nc">&nbsp;                    if (((absorb % 2) != 0) &amp;&amp; armorDamageReduction) {</b>
<b class="nc">&nbsp;                        absorb++;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                nextPassHit = passenger.getTransferLocation(nextPassHit);</b>
<b class="nc">&nbsp;            } while ((damage &gt; absorb) &amp;&amp; (nextPassHit.getLocation() &gt;= 0));</b>
&nbsp;
&nbsp;            // Damage the passenger.
<b class="nc">&nbsp;            absorb = Math.min(passengerDamage, absorb);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; newReports = damageEntity(passenger, passHit, absorb);</b>
<b class="nc">&nbsp;            for (Report newReport : newReports) {</b>
<b class="nc">&nbsp;                newReport.indent(2);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vDesc.addAll(newReports);</b>
&nbsp;
&nbsp;            // Did some damage pass on?
<b class="nc">&nbsp;            if (damage &gt; absorb) {</b>
&nbsp;                // Yup. Remove the absorbed damage.
<b class="nc">&nbsp;                damage -= absorb;</b>
<b class="nc">&nbsp;                r = new Report(6080);</b>
<b class="nc">&nbsp;                r.subject = te.getId();</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                r.addDesc(te);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            } else {
&nbsp;                // Nope. Return our description.
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Report that a passenger that could&#39;ve been missed
&nbsp;            // narrowly avoids damage
<b class="nc">&nbsp;            r = new Report(6084);</b>
<b class="nc">&nbsp;            r.subject = passenger.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.addDesc(passenger);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        } // End nLoc-has-exterior-passenger
<b class="nc">&nbsp;        if (passenger.hasETypeFlag(Entity.ETYPE_PROTOMECH)</b>
<b class="nc">&nbsp;                &amp;&amp; (passengerDamage &gt; 0) &amp;&amp; !passenger.isDoomed() &amp;&amp; !passenger.isDestroyed()) {</b>
<b class="nc">&nbsp;            r = new Report(3850);</b>
<b class="nc">&nbsp;            r.subject = passenger.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.addDesc(passenger);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            int facing = te.getFacing();</b>
&nbsp;            // We&#39;re going to assume that it&#39;s mounted facing the mech
<b class="nc">&nbsp;            Coords position = te.getPosition();</b>
<b class="nc">&nbsp;            if (!hit.isRear()) {</b>
<b class="nc">&nbsp;                facing = (facing + 3) % 6;</b>
&nbsp;            }
<b class="nc">&nbsp;            unloadUnit(te, passenger, position, facing, te.getElevation(), false, false);</b>
<b class="nc">&nbsp;            Entity violation = Compute.stackingViolation(game,</b>
<b class="nc">&nbsp;                    passenger.getId(), position);</b>
<b class="nc">&nbsp;            if (violation != null) {</b>
<b class="nc">&nbsp;                Coords targetDest = Compute.getValidDisplacement(game, passenger.getId(), position,</b>
<b class="nc">&nbsp;                        Compute.d6() - 1);</b>
<b class="nc">&nbsp;                addReport(doEntityDisplacement(violation, position, targetDest, null));</b>
&nbsp;                // Update the violating entity&#39;s position on the client.
<b class="nc">&nbsp;                entityUpdate(violation.getId());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return damage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if the entity&#39;s engine explodes. Rules for ICE explosions
&nbsp;     * are different to fusion engines.
&nbsp;     *
&nbsp;     * @param en    - the &lt;code&gt;Entity&lt;/code&gt; in question. This value must not be
&nbsp;     *              &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param vDesc - the &lt;code&gt;Vector&lt;/code&gt; that this function should add its
&nbsp;     *              &lt;code&gt;Report&lt;code&gt;s to.  It may be empty, but not
&nbsp;     *              &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param hits  - the number of criticals on the engine
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit&#39;s engine exploded,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if not.
&nbsp;     */
&nbsp;    private boolean checkEngineExplosion(Entity en, Vector&lt;Report&gt; vDesc, int hits) {
<b class="nc">&nbsp;        if (!(en instanceof Mech) &amp;&amp; !(en instanceof Aero) &amp;&amp; !(en instanceof Tank)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // If this method gets called for an entity that&#39;s already destroyed or
&nbsp;        // that hasn&#39;t taken any actual engine hits this phase yet, do nothing.
<b class="nc">&nbsp;        if (en.isDestroyed() || (en.engineHitsThisPhase &lt;= 0)</b>
<b class="nc">&nbsp;                || en.getSelfDestructedThisTurn() || !en.hasEngine()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int explosionBTH = 10;</b>
<b class="nc">&nbsp;        int hitsPerRound = 4;</b>
<b class="nc">&nbsp;        Engine engine = en.getEngine();</b>
&nbsp;
<b class="nc">&nbsp;        if(en instanceof Tank) {</b>
<b class="nc">&nbsp;            explosionBTH = 12;</b>
<b class="nc">&nbsp;            hitsPerRound = 1;</b>
<b class="nc">&nbsp;        } else if(!(en instanceof Mech)) {</b>
<b class="nc">&nbsp;            explosionBTH = 12;</b>
<b class="nc">&nbsp;            hitsPerRound = 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Non mechs and mechs that already rolled are safe
<b class="nc">&nbsp;        if (en.rolledForEngineExplosion || !(en instanceof Mech)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // ICE can always explode and roll every time hit
<b class="nc">&nbsp;        if (engine.isFusion()</b>
<b class="nc">&nbsp;                &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_ENGINE_EXPLOSIONS)</b>
&nbsp;                        || (en.engineHitsThisPhase &lt; hitsPerRound))) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!engine.isFusion()) {</b>
<b class="nc">&nbsp;            switch (hits) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    explosionBTH = 10;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    explosionBTH = 7;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3:
&nbsp;                default:
<b class="nc">&nbsp;                    explosionBTH = 4;</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        int explosionRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        boolean didExplode = explosionRoll &gt;= explosionBTH;</b>
&nbsp;
&nbsp;        Report r;
<b class="nc">&nbsp;        r = new Report(6150);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.addDesc(en);</b>
<b class="nc">&nbsp;        r.add(en.engineHitsThisPhase);</b>
<b class="nc">&nbsp;        vDesc.addElement(r);</b>
<b class="nc">&nbsp;        r = new Report(6155);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(explosionBTH);</b>
<b class="nc">&nbsp;        r.add(explosionRoll);</b>
<b class="nc">&nbsp;        vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (!didExplode) {</b>
&nbsp;            // whew!
<b class="nc">&nbsp;            if (engine.isFusion()) {</b>
<b class="nc">&nbsp;                en.rolledForEngineExplosion = true;</b>
&nbsp;            }
&nbsp;            // fusion engines only roll 1/phase but ICE roll every time damaged
<b class="nc">&nbsp;            r = new Report(6160);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            en.rolledForEngineExplosion = true;</b>
<b class="nc">&nbsp;            r = new Report(6165, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(en, &quot;engine explosion&quot;, false, false));</b>
&nbsp;            // kill the crew
<b class="nc">&nbsp;            en.getCrew().setDoomed(true);</b>
&nbsp;
&nbsp;            // This is a hack so MM.NET marks the mech as not salvageable
<b class="nc">&nbsp;            en.destroyLocation(Mech.LOC_CT);</b>
&nbsp;
&nbsp;            // ICE explosions don&#39;t hurt anyone else, but fusion do
<b class="nc">&nbsp;            if (engine.isFusion()) {</b>
<b class="nc">&nbsp;                int engineRating = en.getEngine().getRating();</b>
<b class="nc">&nbsp;                Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                r = new Report(5400, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                Mech mech = (Mech) en;</b>
<b class="nc">&nbsp;                if (mech.isAutoEject() &amp;&amp; (!game.getOptions().booleanOption(</b>
&nbsp;                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                        || (game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                        &amp;&amp; mech.isCondEjectEngine()))) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(ejectEntity(en, true));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                doFusionEngineExplosion(engineRating, en.getPosition(), vDesc, null);</b>
<b class="nc">&nbsp;                Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                r = new Report(5410, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return didExplode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extract explosion functionality for generalized explosions in areas.
&nbsp;     */
&nbsp;    public void doFusionEngineExplosion(int engineRating, Coords position, Vector&lt;Report&gt; vDesc,
&nbsp;                                        Vector&lt;Integer&gt; vUnits) {
<b class="nc">&nbsp;        int[] myDamages = { engineRating, (engineRating / 10), (engineRating / 20),</b>
&nbsp;                (engineRating / 40) };
<b class="nc">&nbsp;        doExplosion(myDamages, true, position, false, vDesc, vUnits, 5, -1, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * General function to cause explosions in areas.
&nbsp;     */
&nbsp;    public void doExplosion(int damage, int degradation, boolean autoDestroyInSameHex,
&nbsp;                            Coords position, boolean allowShelter, Vector&lt;Report&gt; vDesc,
&nbsp;                            Vector&lt;Integer&gt; vUnits, int excludedUnitId) {
<b class="nc">&nbsp;        if (degradation &lt; 1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int[] myDamages = new int[damage / degradation];</b>
&nbsp;
<b class="nc">&nbsp;        if (myDamages.length &lt; 1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        myDamages[0] = damage;</b>
<b class="nc">&nbsp;        for (int x = 1; x &lt; myDamages.length; x++) {</b>
<b class="nc">&nbsp;            myDamages[x] = myDamages[x - 1] - degradation;</b>
&nbsp;        }
<b class="nc">&nbsp;        doExplosion(myDamages, autoDestroyInSameHex, position, allowShelter, vDesc, vUnits,</b>
&nbsp;                5, excludedUnitId, false);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * General function to cause explosions in areas.
&nbsp;     */
&nbsp;    public void doExplosion(int[] damages, boolean autoDestroyInSameHex, Coords position,
&nbsp;                            boolean allowShelter, Vector&lt;Report&gt; vDesc, Vector&lt;Integer&gt; vUnits,
&nbsp;                            int clusterAmt, int excludedUnitId, boolean engineExplosion) {
<b class="nc">&nbsp;        if (vDesc == null) {</b>
<b class="nc">&nbsp;            vDesc = new Vector&lt;&gt;();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (vUnits == null) {</b>
<b class="nc">&nbsp;            vUnits = new Vector&lt;&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
<b class="nc">&nbsp;        HashSet&lt;Entity&gt; entitiesHit = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        // We need to damage buildings.
<b class="nc">&nbsp;        Enumeration&lt;Building&gt; buildings = game.getBoard().getBuildings();</b>
<b class="nc">&nbsp;        while (buildings.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Building bldg = buildings.nextElement();</b>
&nbsp;
&nbsp;            // Lets find the closest hex from the building.
<b class="nc">&nbsp;            Enumeration&lt;Coords&gt; hexes = bldg.getCoords();</b>
&nbsp;
<b class="nc">&nbsp;            while (hexes.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Coords coords = hexes.nextElement();</b>
<b class="nc">&nbsp;                int dist = position.distance(coords);</b>
<b class="nc">&nbsp;                if (dist &lt; damages.length) {</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, damages[dist], coords);</b>
<b class="nc">&nbsp;                    for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                        report.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    vDesc.addAll(buildingReport);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // We need to damage terrain
<b class="nc">&nbsp;        int maxDist = damages.length;</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(position);</b>
&nbsp;        // Center hex starts on fire for engine explosions
<b class="nc">&nbsp;        if (engineExplosion &amp;&amp; (hex != null) &amp;&amp; !hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            r = new Report(5136);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            r.add(position.getBoardNum());</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            ignite(position, Terrains.FIRE_LVL_NORMAL, reports);</b>
<b class="nc">&nbsp;            for (Report report : reports) {</b>
<b class="nc">&nbsp;                report.indent();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vDesc.addAll(reports);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((hex != null) &amp;&amp; hex.hasTerrainfactor()) {</b>
<b class="nc">&nbsp;            r = new Report(3384);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            r.add(position.getBoardNum());</b>
<b class="nc">&nbsp;            r.add(damages[0]);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = tryClearHex(position, damages[0], Entity.NONE);</b>
<b class="nc">&nbsp;        for (Report report : reports) {</b>
<b class="nc">&nbsp;            report.indent(3);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        vDesc.addAll(reports);</b>
&nbsp;
&nbsp;        // Handle surrounding coords
<b class="nc">&nbsp;        for (int dist = 1; dist &lt; maxDist; dist++) {</b>
<b class="nc">&nbsp;            List&lt;Coords&gt; coords = position.allAtDistance(dist);</b>
<b class="nc">&nbsp;            for (Coords c : coords) {</b>
<b class="nc">&nbsp;                hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;                if ((hex != null) &amp;&amp; hex.hasTerrainfactor()) {</b>
<b class="nc">&nbsp;                    r = new Report(3384);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                    r.add(c.getBoardNum());</b>
<b class="nc">&nbsp;                    r.add(damages[dist]);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                reports = tryClearHex(c, damages[dist], Entity.NONE);</b>
<b class="nc">&nbsp;                for (Report report : reports) {</b>
<b class="nc">&nbsp;                    report.indent(3);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                vDesc.addAll(reports);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now we damage people near the explosion.
<b class="nc">&nbsp;        List&lt;Entity&gt; loaded = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Iterator&lt;Entity&gt; ents = game.getEntities(); ents.hasNext();) {</b>
<b class="nc">&nbsp;            Entity entity = ents.next();</b>
&nbsp;
<b class="nc">&nbsp;            if (entitiesHit.contains(entity)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.getId() == excludedUnitId) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.isDestroyed() || !entity.isDeployed()) {</b>
&nbsp;                // FIXME
&nbsp;                // IS this the behavior we want?
&nbsp;                // This means, incidentally, that salvage is never affected by
&nbsp;                // explosions
&nbsp;                // as long as it was destroyed before the explosion.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // We are going to assume that explosions are on the ground here so
&nbsp;            // flying entities should be unaffected
<b class="nc">&nbsp;            if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((entity instanceof MechWarrior) &amp;&amp; !((MechWarrior) entity).hasLanded()) {</b>
&nbsp;                // MechWarrior is still up in the air ejecting hence safe
&nbsp;                // from this explosion.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Coords entityPos = entity.getPosition();</b>
<b class="nc">&nbsp;            if (entityPos == null) {</b>
&nbsp;                // maybe its loaded?
<b class="nc">&nbsp;                Entity transport = game.getEntity(entity.getTransportId());</b>
<b class="nc">&nbsp;                if ((transport != null) &amp;&amp; !transport.isAirborne()) {</b>
<b class="nc">&nbsp;                    loaded.add(entity);</b>
&nbsp;                }
&nbsp;                continue;
&nbsp;            }
<b class="nc">&nbsp;            int range = position.distance(entityPos);</b>
&nbsp;
<b class="nc">&nbsp;            if (range &gt;= damages.length) {</b>
&nbsp;                // Yeah, this is fine. It&#39;s outside the blast radius.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // We might need to nuke everyone in the explosion hex. If so...
<b class="nc">&nbsp;            if ((range == 0) &amp;&amp; autoDestroyInSameHex) {</b>
&nbsp;                // Add the reports
<b class="nc">&nbsp;                vDesc.addAll(destroyEntity(entity, &quot;explosion proximity&quot;, false, false));</b>
&nbsp;                // Add it to the &quot;blasted units&quot; list
<b class="nc">&nbsp;                vUnits.add(entity.getId());</b>
&nbsp;                // Kill the crew
<b class="nc">&nbsp;                entity.getCrew().setDoomed(true);</b>
&nbsp;
<b class="nc">&nbsp;                entitiesHit.add(entity);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int damage = damages[range];</b>
&nbsp;
<b class="nc">&nbsp;            if (allowShelter &amp;&amp; canShelter(entityPos, position, entity.relHeight())) {</b>
<b class="nc">&nbsp;                if (isSheltered()) {</b>
<b class="nc">&nbsp;                    r = new Report(6545);</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // If shelter is allowed but didn&#39;t work, report that.
<b class="nc">&nbsp;                r = new Report(6546);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Since it&#39;s taking damage, add it to the list of units hit.
<b class="nc">&nbsp;            vUnits.add(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;            AreaEffectHelper.applyExplosionClusterDamageToEntity(entity, damage, clusterAmt, position, vDesc, this);</b>
&nbsp;            
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // now deal with loaded units...
<b class="nc">&nbsp;        for (Entity e : loaded) {</b>
&nbsp;            // This can be null, if the transport died from damage
<b class="nc">&nbsp;            final Entity transporter = game.getEntity(e.getTransportId());</b>
<b class="nc">&nbsp;            if ((transporter == null) || transporter.getExternalUnits().contains(e)) {</b>
&nbsp;                // Its external or transport was destroyed - hit it.
<b class="nc">&nbsp;                final Coords entityPos = (transporter == null ? e.getPosition()</b>
<b class="nc">&nbsp;                        : transporter.getPosition());</b>
<b class="nc">&nbsp;                final int range = position.distance(entityPos);</b>
&nbsp;
<b class="nc">&nbsp;                if (range &gt;= damages.length) {</b>
&nbsp;                    // Yeah, this is fine. It&#39;s outside the blast radius.
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int damage = damages[range];</b>
<b class="nc">&nbsp;                if (allowShelter) {</b>
<b class="nc">&nbsp;                    final int absHeight = (transporter == null ? e.relHeight()</b>
<b class="nc">&nbsp;                            : transporter.relHeight());</b>
<b class="nc">&nbsp;                    if (canShelter(entityPos, position, absHeight)) {</b>
<b class="nc">&nbsp;                        if (isSheltered()) {</b>
<b class="nc">&nbsp;                            r = new Report(6545);</b>
<b class="nc">&nbsp;                            r.addDesc(e);</b>
<b class="nc">&nbsp;                            r.subject = e.getId();</b>
<b class="nc">&nbsp;                            vDesc.addElement(r);</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;                        // If shelter is allowed but didn&#39;t work, report that.
<b class="nc">&nbsp;                        r = new Report(6546);</b>
<b class="nc">&nbsp;                        r.subject = e.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(e);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // No shelter
&nbsp;                // Since it&#39;s taking damage, add it to the list of units hit.
<b class="nc">&nbsp;                vUnits.add(e.getId());</b>
&nbsp;
<b class="nc">&nbsp;                r = new Report(6175);</b>
<b class="nc">&nbsp;                r.subject = e.getId();</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.addDesc(e);</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                    int table = ToHitData.HIT_NORMAL;</b>
<b class="nc">&nbsp;                    if (e instanceof Protomech) {</b>
<b class="nc">&nbsp;                        table = ToHitData.HIT_SPECIAL_PROTO;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    HitData hit = e.rollHitLocation(table, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    vDesc.addAll(damageEntity(e, hit, cluster, false,</b>
&nbsp;                            DamageType.IGNORE_PASSENGER, false, true));
<b class="nc">&nbsp;                    damage -= cluster;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                Report.addNewline(vDesc);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check if an Entity of the passed height can find shelter from a nuke blast
&nbsp;     *
&nbsp;     * @param entityPosition  the &lt;code&gt;Coords&lt;/code&gt; the Entity is at
&nbsp;     * @param position        the &lt;code&gt;Coords&lt;/code&gt; of the explosion
&nbsp;     * @param entityAbsHeight the &lt;code&gt;int&lt;/code&gt; height of the entity
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; value indicating if the entity of the
&nbsp;     * given height can find shelter
&nbsp;     */
&nbsp;    public boolean canShelter(Coords entityPosition, Coords position, int entityAbsHeight) {
&nbsp;        // What is the next hex in the direction of the blast?
<b class="nc">&nbsp;        Coords shelteringCoords = Coords.nextHex(entityPosition, position);</b>
<b class="nc">&nbsp;        IHex shelteringHex = game.getBoard().getHex(shelteringCoords);</b>
&nbsp;
&nbsp;        // This is an error condition. It really shouldn&#39;t ever happen.
<b class="nc">&nbsp;        if (shelteringHex == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now figure out the height to which that hex will provide shelter.
&nbsp;        // It&#39;s worth noting, this assumes that any building in the hex has
&nbsp;        // already survived the bomb blast. In the case where a building
&nbsp;        // won&#39;t survive the blast but hasn&#39;t actually taken the damage
&nbsp;        // yet, this will be wrong.
<b class="nc">&nbsp;        int shelterLevel = shelteringHex.floor();</b>
<b class="nc">&nbsp;        if (shelteringHex.containsTerrain(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;            shelterLevel = shelteringHex.ceiling();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the absolute height of the unit relative to level 0.
<b class="nc">&nbsp;        entityAbsHeight += game.getBoard().getHex(entityPosition).surface();</b>
&nbsp;
&nbsp;        // Now find the height that needs to be sheltered, and compare.
<b class="nc">&nbsp;        return entityAbsHeight &lt; shelterLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if the unit succeeds a shelter roll
&nbsp;     */
&nbsp;    private boolean isSheltered() {
<b class="nc">&nbsp;        return Compute.d6(2) &gt;= 9;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * add a nuke to be exploded in the next weapons attack phase
&nbsp;     *
&nbsp;     * @param nuke this is an int[] with i=0 and i=1 being X and Y coordinates respectively,
&nbsp;     *             If the input array is length 3, then i=2 is NukeType (from HS:3070)
&nbsp;     *             If the input array is length 6, then i=2 is the base damage dealt,
&nbsp;     *             i=3 is the degradation, i=4 is the secondary radius, and i=5 is the crater depth
&nbsp;     */
&nbsp;    public void addScheduledNuke(int[] nuke) {
<b class="nc">&nbsp;        scheduledNukes.add(nuke);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * explode any scheduled nukes
&nbsp;     */
&nbsp;    private void resolveScheduledNukes() {
<b class="nc">&nbsp;        for (int[] nuke : scheduledNukes) {</b>
<b class="nc">&nbsp;            if (nuke.length == 3) {</b>
<b class="nc">&nbsp;                doNuclearExplosion(new Coords(nuke[0] - 1, nuke[1] - 1), nuke[2],</b>
&nbsp;                        vPhaseReport);
&nbsp;            }
<b class="nc">&nbsp;            if (nuke.length == 6) {</b>
<b class="nc">&nbsp;                doNuclearExplosion(new Coords(nuke[0] - 1, nuke[1] - 1), nuke[2], nuke[3],</b>
&nbsp;                        nuke[4], nuke[5], vPhaseReport);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        scheduledNukes.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * do a nuclear explosion
&nbsp;     *
&nbsp;     * @param position the position that will be hit by the nuke
&nbsp;     * @param nukeType the type of nuke
&nbsp;     * @param vDesc    a vector that contains the output report
&nbsp;     */
&nbsp;    public void doNuclearExplosion(Coords position, int nukeType, Vector&lt;Report&gt; vDesc) {
<b class="nc">&nbsp;        NukeStats nukeStats = AreaEffectHelper.getNukeStats(nukeType);</b>
&nbsp;        
<b class="nc">&nbsp;        if(nukeStats == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Illegal nuke not listed in HS:3070&quot;);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        doNuclearExplosion(position, nukeStats.baseDamage, nukeStats.degradation, nukeStats.secondaryRadius,</b>
&nbsp;                nukeStats.craterDepth, vDesc);        
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * explode a nuke
&nbsp;     *
&nbsp;     * @param position          the position that will be hit by the nuke
&nbsp;     * @param baseDamage        the base damage from the blast
&nbsp;     * @param degradation       how fast the blast&#39;s power degrades
&nbsp;     * @param secondaryRadius   the secondary blast radius
&nbsp;     * @param craterDepth       the depth of the crater created by the blast
&nbsp;     * @param vDesc             a vector that contains the output report
&nbsp;     */
&nbsp;    public void doNuclearExplosion(Coords position, int baseDamage, int degradation,
&nbsp;                                   int secondaryRadius, int craterDepth, Vector&lt;Report&gt; vDesc) {
&nbsp;        // Just in case.
<b class="nc">&nbsp;        if (vDesc == null) {</b>
<b class="nc">&nbsp;            vDesc = new Vector&lt;&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        // First, crater the terrain.
&nbsp;        // All terrain, units, buildings... EVERYTHING in here is just gone.
&nbsp;        // Gotta love nukes.
<b class="nc">&nbsp;        Report r = new Report(1215, Report.PUBLIC);</b>
&nbsp;
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.add(position.getBoardNum(), true);</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
&nbsp;
<b class="nc">&nbsp;        int curDepth = craterDepth;</b>
<b class="nc">&nbsp;        int range = 0;</b>
<b class="nc">&nbsp;        while (range &lt; (2 * craterDepth)) {</b>
&nbsp;            // Get the set of hexes at this range.
<b class="nc">&nbsp;            List&lt;Coords&gt; hexSet = position.allAtDistance(range);</b>
&nbsp;
&nbsp;            // Iterate through the hexes.
<b class="nc">&nbsp;            for (Coords myHexCoords: hexSet) {</b>
&nbsp;                // ignore out of bounds coordinates
<b class="nc">&nbsp;                if (!game.getBoard().contains(myHexCoords)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                IHex myHex = game.getBoard().getHex(myHexCoords);</b>
&nbsp;                // In each hex, first, sink the terrain if necessary.
<b class="nc">&nbsp;                myHex.setLevel((myHex.getLevel() - curDepth));</b>
&nbsp;
&nbsp;                // Then, remove ANY terrains here.
&nbsp;                // I mean ALL of them; they&#39;re all just gone.
&nbsp;                // No ruins, no water, no rough, no nothing.
<b class="nc">&nbsp;                if (myHex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                    myHex.setLevel(myHex.floor());</b>
&nbsp;                }
<b class="nc">&nbsp;                myHex.removeAllTerrains();</b>
<b class="nc">&nbsp;                myHex.clearExits();</b>
&nbsp;
<b class="nc">&nbsp;                sendChangedHex(myHexCoords);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Lastly, if the next distance is a multiple of 2...
&nbsp;            // The crater depth goes down one.
<b class="nc">&nbsp;            if ((range &gt; 0) &amp;&amp; ((range % 2) == 0)) {</b>
<b class="nc">&nbsp;                curDepth--;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Now that the hexes are dealt with, increment the distance.
<b class="nc">&nbsp;            range++;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // This is technically part of cratering, but...
&nbsp;        // Now we destroy all the units inside the cratering range.
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
&nbsp;            // loaded units and off board units don&#39;t have a position,
&nbsp;            // so we don&#39;t count &#39;em here
<b class="nc">&nbsp;            if ((entity.getTransportId() != Entity.NONE) || (entity.getPosition() == null)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If it&#39;s too far away for this...
<b class="nc">&nbsp;            if (position.distance(entity.getPosition()) &gt;= range) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If it&#39;s already destroyed...
<b class="nc">&nbsp;            if (entity.isDestroyed()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(entity, &quot;nuclear explosion proximity&quot;,</b>
&nbsp;                    false, false));
&nbsp;            // Kill the crew
<b class="nc">&nbsp;            entity.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Then, do actual blast damage.
&nbsp;        // Use the standard blast function for this.
<b class="nc">&nbsp;        Vector&lt;Report&gt; tmpV = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        Vector&lt;Integer&gt; blastedUnitsVec = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        doExplosion(baseDamage, degradation, true, position, true, tmpV,</b>
&nbsp;                    blastedUnitsVec, -1);
<b class="nc">&nbsp;        Report.indentAll(tmpV, 2);</b>
<b class="nc">&nbsp;        vDesc.addAll(tmpV);</b>
&nbsp;
&nbsp;        // Everything that was blasted by the explosion has to make a piloting
&nbsp;        // check at +6.
<b class="nc">&nbsp;        for (int i : blastedUnitsVec) {</b>
<b class="nc">&nbsp;            Entity o = game.getEntity(i);</b>
<b class="nc">&nbsp;            if (o.canFall()) {</b>
&nbsp;                // Needs a piloting check at +6 to avoid falling over.
<b class="nc">&nbsp;                game.addPSR(new PilotingRollData(o.getId(), 6,</b>
&nbsp;                        &quot;hit by nuclear blast&quot;));
<b class="nc">&nbsp;            } else if (o instanceof VTOL) {</b>
&nbsp;                // Needs a piloting check at +6 to avoid crashing.
&nbsp;                // Wheeeeee!
<b class="nc">&nbsp;                VTOL vt = (VTOL) o;</b>
&nbsp;
&nbsp;                // Check only applies if it&#39;s in the air.
&nbsp;                // FIXME: is this actually correct? What about
&nbsp;                // buildings/bridges?
<b class="nc">&nbsp;                if (vt.getElevation() &gt; 0) {</b>
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(vt.getId(), 6,</b>
&nbsp;                                                     &quot;hit by nuclear blast&quot;));
&nbsp;                }
<b class="nc">&nbsp;            } else if (o instanceof Tank) {</b>
&nbsp;                // As per official answer on the rules questions board...
&nbsp;                // Needs a piloting check at +6 to avoid a 1-level fall...
&nbsp;                // But ONLY if a hover-tank.
&nbsp;                // TODO : Fix me
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // This ISN&#39;T part of the blast, but if there&#39;s ANYTHING in the ground
&nbsp;        // zero hex, destroy it.
<b class="nc">&nbsp;        Building tmpB = game.getBoard().getBuildingAt(position);</b>
<b class="nc">&nbsp;        if (tmpB != null) {</b>
<b class="nc">&nbsp;            r = new Report(2415);</b>
<b class="nc">&nbsp;            r.add(tmpB.getName());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            tmpB.setCurrentCF(0, position);</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex gzHex = game.getBoard().getHex(position);</b>
<b class="nc">&nbsp;        if (gzHex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            gzHex.setLevel(gzHex.floor());</b>
&nbsp;        }
<b class="nc">&nbsp;        gzHex.removeAllTerrains();</b>
&nbsp;
&nbsp;        // Next, for whatever&#39;s left, do terrain effects
&nbsp;        // such as clearing, roughing, and boiling off water.
<b class="nc">&nbsp;        boolean damageFlag = true;</b>
<b class="nc">&nbsp;        int damageAtRange = baseDamage - (degradation * range);</b>
<b class="nc">&nbsp;        if (damageAtRange &gt; 0) {</b>
<b class="nc">&nbsp;            for (int x = range; damageFlag; x++) {</b>
&nbsp;                // Damage terrain as necessary.
&nbsp;                // Get all the hexes, and then iterate through them.
<b class="nc">&nbsp;                List&lt;Coords&gt; hexSet = position.allAtDistance(x);</b>
&nbsp;
&nbsp;                // Iterate through the hexes.
<b class="nc">&nbsp;                for (Coords myHexCoords : hexSet) {</b>
&nbsp;                    // ignore out of bounds coordinates
<b class="nc">&nbsp;                    if (!game.getBoard().contains(myHexCoords)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    IHex myHex = game.getBoard().getHex(myHexCoords);</b>
&nbsp;
&nbsp;                    // For each 3000 damage, water level is reduced by 1.
<b class="nc">&nbsp;                    if ((damageAtRange &gt;= 3000) &amp;&amp; (myHex.containsTerrain(Terrains.WATER))) {</b>
<b class="nc">&nbsp;                        int numCleared = damageAtRange / 3000;</b>
<b class="nc">&nbsp;                        int oldLevel = myHex.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;                        myHex.removeTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;                        if (oldLevel &gt; numCleared) {</b>
<b class="nc">&nbsp;                            myHex.setLevel(myHex.getLevel() - numCleared);</b>
<b class="nc">&nbsp;                            myHex.addTerrain(new Terrain(Terrains.WATER, oldLevel - numCleared));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            myHex.setLevel(myHex.getLevel() - oldLevel);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // ANY non-water hex that takes 200 becomes rough.
<b class="nc">&nbsp;                    if ((damageAtRange &gt;= 200) &amp;&amp; (!myHex.containsTerrain(Terrains.WATER))) {</b>
<b class="nc">&nbsp;                        myHex.removeAllTerrains();</b>
<b class="nc">&nbsp;                        myHex.clearExits();</b>
<b class="nc">&nbsp;                        myHex.addTerrain(new Terrain(Terrains.ROUGH, 1));</b>
<b class="nc">&nbsp;                    } else if ((damageAtRange &gt;= 20)</b>
<b class="nc">&nbsp;                            &amp;&amp; ((myHex.containsTerrain(Terrains.WOODS))</b>
<b class="nc">&nbsp;                            || (myHex.containsTerrain(Terrains.JUNGLE)))) {</b>
&nbsp;                        // Each 20 clears woods by 1 level.
<b class="nc">&nbsp;                        int numCleared = damageAtRange / 20;</b>
<b class="nc">&nbsp;                        int terrainType = (myHex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                                ? Terrains.WOODS : Terrains.JUNGLE);</b>
<b class="nc">&nbsp;                        int oldLevel = myHex.terrainLevel(terrainType);</b>
<b class="nc">&nbsp;                        int oldEl = myHex.terrainLevel(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                        myHex.removeTerrain(terrainType);</b>
<b class="nc">&nbsp;                        if (oldLevel &gt; numCleared) {</b>
<b class="nc">&nbsp;                            myHex.addTerrain(new Terrain(terrainType, oldLevel - numCleared));</b>
<b class="nc">&nbsp;                            if (oldEl != 1) {</b>
<b class="nc">&nbsp;                                myHex.addTerrain(new Terrain(Terrains.FOLIAGE_ELEV, </b>
<b class="nc">&nbsp;                                        oldLevel - numCleared == 3 ? 3 : 2));</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            myHex.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    sendChangedHex(myHexCoords);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                // Initialize for the next iteration.
<b class="nc">&nbsp;                damageAtRange = baseDamage - ((degradation * x) + 1);</b>
&nbsp;
&nbsp;                // If the damage is less than 20, it has no terrain effect.
<b class="nc">&nbsp;                if (damageAtRange &lt; 20) {</b>
<b class="nc">&nbsp;                    damageFlag = false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Lastly, do secondary effects.
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
&nbsp;            // loaded units and off board units don&#39;t have a position,
&nbsp;            // so we don&#39;t count &#39;em here
<b class="nc">&nbsp;            if ((entity.getTransportId() != Entity.NONE) || (entity.getPosition() == null)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If it&#39;s already destroyed...
<b class="nc">&nbsp;            if ((entity.isDoomed()) || (entity.isDestroyed())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If it&#39;s too far away for this...
<b class="nc">&nbsp;            if (position.distance(entity.getPosition()) &gt; secondaryRadius) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Actually do secondary effects against it.
&nbsp;            // Since the effects are unit-dependant, we&#39;ll just define it in the
&nbsp;            // entity.
<b class="nc">&nbsp;            applySecondaryNuclearEffects(entity, position, vDesc);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // All right. We&#39;re done.
<b class="nc">&nbsp;        r = new Report(1216, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.indent();</b>
<b class="nc">&nbsp;        r.newlines = 2;</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handles secondary effects from nuclear blasts against all units in range.
&nbsp;     *
&nbsp;     * @param entity   The entity to affect.
&nbsp;     * @param position The coordinates of the nuclear blast, for to-hit directions.
&nbsp;     * @param vDesc    a description vector to use for reports.
&nbsp;     */
&nbsp;    public void applySecondaryNuclearEffects(Entity entity, Coords position, Vector&lt;Report&gt; vDesc) {
&nbsp;        // If it&#39;s already destroyed, give up. We really don&#39;t care.
<b class="nc">&nbsp;        if (entity.isDestroyed()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check to see if the infantry is in a protective structure.
<b class="nc">&nbsp;        boolean inHardenedBuilding = (Compute.isInBuilding(game, entity)</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getBoard().getHex(entity.getPosition()).terrainLevel(Terrains.BUILDING) == 4));</b>
&nbsp;
&nbsp;        // Roll 2d6.
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;        Report r = new Report(6555);</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;        r.add(roll);</b>
&nbsp;
&nbsp;        // If they are in protective structure, add 2 to the roll.
<b class="nc">&nbsp;        if (inHardenedBuilding) {</b>
<b class="nc">&nbsp;            roll += 2;</b>
<b class="nc">&nbsp;            r.add(&quot; + 2 (unit is in hardened building)&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.add(&quot;&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Also, if the entity is &quot;hardened&quot; against EMI, it gets a +2.
&nbsp;        // For these purposes, I&#39;m going to hand this off to the Entity itself
&nbsp;        // to tell us.
&nbsp;        // Right now, it IS based purely on class, but I won&#39;t rule out the idea
&nbsp;        // of
&nbsp;        // &quot;nuclear hardening&quot; as equipment for a support vehicle, for example.
<b class="nc">&nbsp;        if (entity.isNuclearHardened()) {</b>
<b class="nc">&nbsp;            roll += 2;</b>
<b class="nc">&nbsp;            r.add(&quot; + 2 (unit is hardened against EMI)&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.add(&quot;&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
&nbsp;
&nbsp;        // Now, compare it to the table, and apply the effects.
<b class="nc">&nbsp;        if (roll &lt;= 4) {</b>
&nbsp;            // The unit is destroyed.
&nbsp;            // Sucks, doesn&#39;t it?
&nbsp;            // This applies to all units.
&nbsp;            // Yup, just sucks.
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(entity,</b>
&nbsp;                    &quot;nuclear explosion secondary effects&quot;, false, false));
&nbsp;            // Kill the crew
<b class="nc">&nbsp;            entity.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;        } else if (roll &lt;= 6) {</b>
<b class="nc">&nbsp;            if (entity instanceof BattleArmor) {</b>
&nbsp;                // It takes 50% casualties, rounded up.
<b class="nc">&nbsp;                BattleArmor myBA = (BattleArmor) entity;</b>
<b class="nc">&nbsp;                int numDeaths = (int) (Math.ceil((myBA.getNumberActiverTroopers())) / 2.0);</b>
<b class="nc">&nbsp;                for (int x = 0; x &lt; numDeaths; x++) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(applyCriticalHit(entity, 0, null, false,</b>
&nbsp;                            0, false));
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity instanceof Infantry) {</b>
&nbsp;                // Standard infantry are auto-killed in this band, unless
&nbsp;                // they&#39;re in a building.
<b class="nc">&nbsp;                if (game.getBoard().getHex(entity.getPosition()).containsTerrain(Terrains.BUILDING)) {</b>
&nbsp;                    // 50% casualties, rounded up.
<b class="nc">&nbsp;                    int damage = (int) (Math.ceil((entity.getInternal(Infantry.LOC_INFANTRY)) / 2.0));</b>
<b class="nc">&nbsp;                    vDesc.addAll(damageEntity(entity, new HitData(</b>
&nbsp;                            Infantry.LOC_INFANTRY), damage, true));
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    vDesc.addAll(destroyEntity(entity,</b>
&nbsp;                            &quot;nuclear explosion secondary effects&quot;, false, false));
<b class="nc">&nbsp;                    entity.getCrew().setDoomed(true);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity instanceof Tank) {</b>
&nbsp;                // All vehicles suffer two critical hits...
<b class="nc">&nbsp;                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));</b>
<b class="nc">&nbsp;                hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));</b>
&nbsp;
&nbsp;                // ...and a Crew Killed hit.
<b class="nc">&nbsp;                vDesc.addAll(applyCriticalHit(entity, 0, new CriticalSlot(0,</b>
&nbsp;                        Tank.CRIT_CREW_KILLED), false, 0, false));
<b class="nc">&nbsp;            } else if ((entity instanceof Mech) || (entity instanceof Protomech)) {</b>
&nbsp;                // &#39;Mechs suffer two critical hits...
<b class="nc">&nbsp;                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));</b>
<b class="nc">&nbsp;                hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));</b>
&nbsp;
&nbsp;                // and four pilot hits.
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(entity, 4));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Buildings and gun emplacements and such are only affected by the EMI.
&nbsp;            // No auto-crits or anything.
<b class="nc">&nbsp;        } else if (roll &lt;= 10) {</b>
<b class="nc">&nbsp;            if (entity instanceof BattleArmor) {</b>
&nbsp;                // It takes 25% casualties, rounded up.
<b class="nc">&nbsp;                BattleArmor myBA = (BattleArmor) entity;</b>
<b class="nc">&nbsp;                int numDeaths = (int) (Math.ceil(((myBA.getNumberActiverTroopers())) / 4.0));</b>
<b class="nc">&nbsp;                for (int x = 0; x &lt; numDeaths; x++) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(applyCriticalHit(entity, 0, null, false, 0, false));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;                if (game.getBoard().getHex(entity.getPosition()).containsTerrain(Terrains.BUILDING)) {</b>
&nbsp;                    // 25% casualties, rounded up.
<b class="nc">&nbsp;                    int damage = (int) (Math.ceil((entity.getInternal(Infantry.LOC_INFANTRY)) / 4.0));</b>
<b class="nc">&nbsp;                    vDesc.addAll(damageEntity(entity, new HitData(Infantry.LOC_INFANTRY), damage, true));</b>
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // 50% casualties, rounded up.
<b class="nc">&nbsp;                    int damage = (int) (Math.ceil((entity.getInternal(Infantry.LOC_INFANTRY)) / 2.0));</b>
<b class="nc">&nbsp;                    vDesc.addAll(damageEntity(entity, new HitData(Infantry.LOC_INFANTRY), damage, true));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } else if (entity instanceof Tank) {</b>
&nbsp;                // It takes one crit...
<b class="nc">&nbsp;                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));</b>
&nbsp;
&nbsp;                // Plus a Crew Stunned critical.
<b class="nc">&nbsp;                vDesc.addAll(applyCriticalHit(entity, 0, new CriticalSlot(0,</b>
&nbsp;                        Tank.CRIT_CREW_STUNNED), false, 0, false));
<b class="nc">&nbsp;            } else if ((entity instanceof Mech) || (entity instanceof Protomech)) {</b>
&nbsp;                // &#39;Mechs suffer a critical hit...
<b class="nc">&nbsp;                HitData hd = entity.rollHitLocation(ToHitData.HIT_NORMAL, entity.sideTable(position));</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(entity, hd.getLocation(), hd.isRear(), 0));</b>
&nbsp;
&nbsp;                // and two pilot hits.
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(entity, 2));</b>
&nbsp;            }
&nbsp;            // Buildings and gun emplacements and such are only affected by
&nbsp;            // the EMI.
&nbsp;            // No auto-crits or anything.
&nbsp;        }
&nbsp;        // If it&#39;s 11+, there are no secondary effects beyond EMI.
&nbsp;        // Lucky bastards.
&nbsp;
&nbsp;        // And lastly, the unit is now affected by electromagnetic interference.
<b class="nc">&nbsp;        entity.setEMI(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply a single critical hit. The following private member of Server are
&nbsp;     * accessed from this function, preventing it from being factored out of the
&nbsp;     * Server class: destroyEntity() destroyLocation() checkEngineExplosion()
&nbsp;     * damageCrew() explodeEquipment() game
&nbsp;     *
&nbsp;     * @param en               the &lt;code&gt;Entity&lt;/code&gt; that is being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param loc              the &lt;code&gt;int&lt;/code&gt; location of critical hit. This value may
&nbsp;     *                         be &lt;code&gt;Entity.NONE&lt;/code&gt; for hits to &lt;code&gt;Tank&lt;/code&gt;s and
&nbsp;     *                         for hits to a &lt;code&gt;Protomech&lt;/code&gt; torso weapon.
&nbsp;     * @param cs               the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;. For critical hits on a
&nbsp;     *                         &lt;code&gt;Tank&lt;/code&gt;, the index of the slot should be the index
&nbsp;     *                         of the critical hit table.
&nbsp;     * @param secondaryEffects the &lt;code&gt;boolean&lt;/code&gt; flag that indicates whether to allow
&nbsp;     *                         critical hits to cause secondary effects (such as triggering
&nbsp;     *                         an ammo explosion, sending hovercraft to watery graves, or
&nbsp;     *                         damaging ProtoMech torso weapons). This value is normally
&nbsp;     *                         &lt;code&gt;true&lt;/code&gt;, but it will be &lt;code&gt;false&lt;/code&gt; when the
&nbsp;     *                         hit is being applied from a saved game or scenario.
&nbsp;     * @param damageCaused     the amount of damage causing this critical.
&nbsp;     * @param isCapital        whether it was capital scale damage that caused critical
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; applyCriticalHit(Entity en, int loc, CriticalSlot cs,
&nbsp;                                           boolean secondaryEffects, int damageCaused,
&nbsp;                                           boolean isCapital) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (en instanceof Tank) {</b>
<b class="nc">&nbsp;            vDesc.addAll(applyTankCritical((Tank)en, loc, cs, damageCaused));</b>
<b class="nc">&nbsp;        } else if (en instanceof Aero) {</b>
<b class="nc">&nbsp;            vDesc.addAll(applyAeroCritical((Aero)en, loc, cs, damageCaused, isCapital));</b>
<b class="nc">&nbsp;        } else if (en instanceof BattleArmor) {</b>
&nbsp;            // We might as well handle this here.
&nbsp;            // However, we&#39;re considering a crit against BA as a &quot;crew kill&quot;.
<b class="nc">&nbsp;            BattleArmor ba = (BattleArmor) en;</b>
<b class="nc">&nbsp;            r = new Report(6111);</b>
<b class="nc">&nbsp;            int randomTrooper = ba.getRandomTrooper();</b>
<b class="nc">&nbsp;            ba.destroyLocation(randomTrooper);</b>
<b class="nc">&nbsp;            r.add(randomTrooper);</b>
<b class="nc">&nbsp;            r.newlines = 1;</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;        } else if (CriticalSlot.TYPE_SYSTEM == cs.getType()) {</b>
&nbsp;            // Handle critical hits on system slots.
<b class="nc">&nbsp;            cs.setHit(true);</b>
<b class="nc">&nbsp;            if (en instanceof Protomech) {</b>
<b class="nc">&nbsp;                vDesc.addAll(applyProtomechCritical((Protomech)en, loc, cs, secondaryEffects, damageCaused, isCapital));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                vDesc.addAll(applyMechSystemCritical(en, loc, cs));</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (CriticalSlot.TYPE_EQUIPMENT == cs.getType()) {</b>
<b class="nc">&nbsp;            vDesc.addAll(applyEquipmentCritical(en, loc, cs, secondaryEffects));</b>
&nbsp;        } // End crit-on-equipment-slot
&nbsp;        // mechs with TSM hit by anti-tsm missiles this round get another
&nbsp;        // crit
<b class="nc">&nbsp;        if ((en instanceof Mech) &amp;&amp; en.hitThisRoundByAntiTSM) {</b>
<b class="nc">&nbsp;            Mech mech = (Mech) en;</b>
<b class="nc">&nbsp;            if (mech.hasTSM()) {</b>
<b class="nc">&nbsp;                r = new Report(6430);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.addDesc(en);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                vDesc.addAll(oneCriticalEntity(en, Compute.d6(2), false, damageCaused));</b>
&nbsp;            }
<b class="nc">&nbsp;            en.hitThisRoundByAntiTSM = false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if using buffered VDNI then a possible pilot hit
<b class="nc">&nbsp;        if (en.hasAbility(OptionsConstants.MD_BVDNI) &amp;&amp; !en.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {</b>
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(3580);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.addDesc(en);</b>
<b class="nc">&nbsp;            r.add(7);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.choose(roll &gt;= 8);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            if (roll &gt;= 8) {</b>
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(en, 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Return the results of the damage.
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply a single critical hit to an equipment slot.
&nbsp;     *
&nbsp;     * @param en               the &lt;code&gt;Entity&lt;/code&gt; that is being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param loc              the &lt;code&gt;int&lt;/code&gt; location of critical hit.
&nbsp;     * @param cs               the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged.
&nbsp;     * @param secondaryEffects the &lt;code&gt;boolean&lt;/code&gt; flag that indicates whether to allow
&nbsp;     *                         critical hits to cause secondary effects (such as triggering
&nbsp;     *                         an ammo explosion, sending hovercraft to watery graves, or
&nbsp;     *                         damaging ProtoMech torso weapons). This value is normally
&nbsp;     *                         &lt;code&gt;true&lt;/code&gt;, but it will be &lt;code&gt;false&lt;/code&gt; when the
&nbsp;     *                         hit is being applied from a saved game or scenario.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; applyEquipmentCritical(Entity en, int loc, CriticalSlot cs,
&nbsp;                                                  boolean secondaryEffects) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        cs.setHit(true);</b>
<b class="nc">&nbsp;        Mounted mounted = cs.getMount();</b>
<b class="nc">&nbsp;        EquipmentType eqType = mounted.getType();</b>
<b class="nc">&nbsp;        boolean hitBefore = mounted.isHit();</b>
&nbsp;
<b class="nc">&nbsp;        r = new Report(6225);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        r.indent(3);</b>
<b class="nc">&nbsp;        r.add(mounted.getDesc());</b>
<b class="nc">&nbsp;        reports.addElement(r);</b>
&nbsp;
&nbsp;        // Shield objects are not useless when they take one crit.
&nbsp;        // Shields can be critted and still be usable.
<b class="nc">&nbsp;        if ((eqType instanceof MiscType) &amp;&amp; ((MiscType) eqType).isShield()) {</b>
<b class="nc">&nbsp;            mounted.setHit(false);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            mounted.setHit(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((eqType instanceof MiscType) &amp;&amp; eqType.hasFlag(MiscType.F_EMERGENCY_COOLANT_SYSTEM)) {</b>
<b class="nc">&nbsp;            ((Mech)en).setHasDamagedCoolantSystem(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((eqType instanceof MiscType) &amp;&amp; eqType.hasFlag(MiscType.F_HARJEL)) {</b>
<b class="nc">&nbsp;            reports.addAll(breachLocation(en, loc, null, true));</b>
&nbsp;        }
&nbsp;
&nbsp;        // HarJel II/III hits trigger another possible critical hit on
&nbsp;        // the same location
&nbsp;        // it&#39;s like an ammunition explosion---a secondary effect
<b class="nc">&nbsp;        if (secondaryEffects &amp;&amp; (eqType instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; (eqType.hasFlag(MiscType.F_HARJEL_II) || eqType.hasFlag(MiscType.F_HARJEL_III))</b>
&nbsp;                &amp;&amp; !hitBefore) {
<b class="nc">&nbsp;            r = new Report(9852);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            reports.addElement(r);</b>
<b class="nc">&nbsp;            reports.addAll(criticalEntity(en, loc, false, 0, 0));</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the item is the ECM suite of a Mek Stealth system
&nbsp;        // then it&#39;s destruction turns off the stealth.
<b class="nc">&nbsp;        if (!hitBefore &amp;&amp; (eqType instanceof MiscType)</b>
<b class="nc">&nbsp;            &amp;&amp; eqType.hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;            &amp;&amp; (mounted.getLinkedBy() != null)) {</b>
<b class="nc">&nbsp;            Mounted stealth = mounted.getLinkedBy();</b>
<b class="nc">&nbsp;            r = new Report(6255);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.add(stealth.getType().getName());</b>
<b class="nc">&nbsp;            reports.addElement(r);</b>
<b class="nc">&nbsp;            stealth.setMode(&quot;Off&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Handle equipment explosions.
&nbsp;        // Equipment explosions are secondary effects and
&nbsp;        // do not occur when loading from a scenario.
<b class="nc">&nbsp;        if (((secondaryEffects &amp;&amp; eqType.isExplosive(mounted))</b>
<b class="nc">&nbsp;                || mounted.isHotLoaded() || (mounted.hasChargedCapacitor() != 0))</b>
&nbsp;                &amp;&amp; !hitBefore) {
<b class="nc">&nbsp;            reports.addAll(explodeEquipment(en, loc, mounted));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Make sure that ammo in this slot is exhausted.
<b class="nc">&nbsp;        if (mounted.getBaseShotsLeft() &gt; 0) {</b>
<b class="nc">&nbsp;            mounted.setShotsLeft(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // LAMs that are part of a fighter squadron will need to have the squadron recalculate
&nbsp;        // the bomb load out on a bomb bay critical.
<b class="nc">&nbsp;        if (en.isPartOfFighterSquadron() &amp;&amp; (mounted.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.getType().hasFlag(MiscType.F_BOMB_BAY)) {</b>
<b class="nc">&nbsp;            Entity squadron = game.getEntity(en.getTransportId());</b>
<b class="nc">&nbsp;            if (squadron instanceof FighterSquadron) {</b>
<b class="nc">&nbsp;                ((FighterSquadron) squadron).computeSquadronBombLoadout();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply a single critical hit to a Mech system.
&nbsp;     *
&nbsp;     * @param en   the &lt;code&gt;Entity&lt;/code&gt; that is being damaged. This value may
&nbsp;     *             not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param loc  the &lt;code&gt;int&lt;/code&gt; location of critical hit.
&nbsp;     * @param cs   the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged. This value may
&nbsp;     *             not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; applyMechSystemCritical(Entity en, int loc, CriticalSlot cs) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        r = new Report(6225);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        r.indent(3);</b>
<b class="nc">&nbsp;        r.add(((Mech) en).getSystemName(cs.getIndex()));</b>
<b class="nc">&nbsp;        reports.addElement(r);</b>
<b class="nc">&nbsp;        switch (cs.getIndex()) {</b>
&nbsp;            case Mech.SYSTEM_COCKPIT:
&nbsp;                // Lets auto-eject if we can!
<b class="nc">&nbsp;                Mech mech = (Mech) en;</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(</b>
&nbsp;                        OptionsConstants.ADVANCED_TACOPS_SKIN_OF_THE_TEETH_EJECTION)) {
<b class="nc">&nbsp;                    if (mech.isAutoEject()</b>
<b class="nc">&nbsp;                        &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)</b>
<b class="nc">&nbsp;                            || (game.getOptions().booleanOption(</b>
&nbsp;                                    OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                            &amp;&amp; mech.isCondEjectHeadshot()))) {</b>
<b class="nc">&nbsp;                        reports.addAll(ejectEntity(en, true, true));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //First check whether this hit takes out the whole crew; for multi-crew cockpits
&nbsp;                //we need to check the other critical positions (if any).
<b class="nc">&nbsp;                boolean allDead = true;</b>
<b class="nc">&nbsp;                int crewSlot = ((Mech)en).getCrewForCockpitSlot(loc, cs);</b>
<b class="nc">&nbsp;                if (crewSlot &gt;= 0) {</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; en.getCrew().getSlotCount(); i++) {</b>
<b class="nc">&nbsp;                        if (i != crewSlot &amp;&amp; !en.getCrew().isDead(i) &amp;&amp; !en.getCrew().isMissing(i)) {</b>
<b class="nc">&nbsp;                            allDead = false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (allDead) {</b>
&nbsp;                    // Don&#39;t kill a pilot multiple times.
<b class="nc">&nbsp;                    if (Crew.DEATH &gt; en.getCrew().getHits()) {</b>
&nbsp;                        // Single pilot or tripod cockpit; all crew are killed.
<b class="nc">&nbsp;                        en.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;                        Report.addNewline(reports);</b>
<b class="nc">&nbsp;                        reports.addAll(destroyEntity(en, &quot;pilot death&quot;, true));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (!en.getCrew().isMissing(crewSlot)){</b>
<b class="nc">&nbsp;                    boolean wasPilot = en.getCrew().getCurrentPilotIndex() == crewSlot;</b>
<b class="nc">&nbsp;                    boolean wasGunner = en.getCrew().getCurrentGunnerIndex() == crewSlot;</b>
<b class="nc">&nbsp;                    en.getCrew().setDead(true, crewSlot);</b>
<b class="nc">&nbsp;                    r = new Report(6027);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.add(en.getCrew().getCrewType().getRoleName(crewSlot));</b>
<b class="nc">&nbsp;                    r.addDesc(en);</b>
<b class="nc">&nbsp;                    r.add(en.getCrew().getName(crewSlot));</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
<b class="nc">&nbsp;                    r = createCrewTakeoverReport(en, crewSlot, wasPilot, wasGunner);</b>
<b class="nc">&nbsp;                    if (null != r) {</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                break;
&nbsp;            case Mech.SYSTEM_ENGINE:
&nbsp;                // if the slot is missing, the location was previously
&nbsp;                // destroyed and the engine hit was then counted already
<b class="nc">&nbsp;                if (!cs.isMissing()) {</b>
<b class="nc">&nbsp;                    en.engineHitsThisPhase++;</b>
&nbsp;                }
<b class="nc">&nbsp;                int numEngineHits = en.getEngineHits();</b>
<b class="nc">&nbsp;                boolean engineExploded = checkEngineExplosion(en, reports, numEngineHits);</b>
<b class="nc">&nbsp;                int hitsToDestroy = 3;</b>
<b class="nc">&nbsp;                if (en.isSuperHeavy() &amp;&amp; en.hasEngine()</b>
<b class="nc">&nbsp;                        &amp;&amp; (en.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {</b>
<b class="nc">&nbsp;                    hitsToDestroy = 2;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (!engineExploded &amp;&amp; (numEngineHits &gt;= hitsToDestroy)) {</b>
&nbsp;                    // third engine hit
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(en, &quot;engine destruction&quot;));</b>
<b class="nc">&nbsp;                    if (game.getOptions()</b>
<b class="nc">&nbsp;                            .booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {</b>
<b class="nc">&nbsp;                        reports.addAll(abandonEntity(en));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    en.setSelfDestructing(false);</b>
<b class="nc">&nbsp;                    en.setSelfDestructInitiated(false);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Mech.SYSTEM_GYRO:
<b class="nc">&nbsp;                int gyroHits = en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, loc);</b>
<b class="nc">&nbsp;                if (en.getGyroType() != Mech.GYRO_HEAVY_DUTY) {</b>
<b class="nc">&nbsp;                    gyroHits++;</b>
&nbsp;                }
&nbsp;                // Automatically falls in AirMech mode, which it seems would indicate a crash if airborne.
<b class="nc">&nbsp;                if (gyroHits == 3 &amp;&amp; en instanceof LandAirMech &amp;&amp; en.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    crashAirMech(en, new PilotingRollData(en.getId(),</b>
&nbsp;                            TargetRoll.AUTOMATIC_FAIL, 1, &quot;gyro destroyed&quot;), reports);
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                //No PSR for Mechs in non-leg mode
<b class="nc">&nbsp;                if (!en.canFall(true)) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                switch (gyroHits) {</b>
&nbsp;                    case 3:
&nbsp;                        // HD 3 hits, standard 2 hits
<b class="nc">&nbsp;                        game.addPSR(new PilotingRollData(en.getId(), TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                1, &quot;gyro destroyed&quot;));
&nbsp;                        // Gyro destroyed entities may not be hull down
<b class="nc">&nbsp;                        en.setHullDown(false);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 2:
&nbsp;                        // HD 2 hits, standard 1 hit
<b class="nc">&nbsp;                        game.addPSR(new PilotingRollData(en.getId(), 3, &quot;gyro hit&quot;));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 1:
&nbsp;                        // HD 1 hit
<b class="nc">&nbsp;                        game.addPSR(new PilotingRollData(en.getId(), 2, &quot;gyro hit&quot;));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                        // ignore if &gt;4 hits (don&#39;t over do it, the auto fail
&nbsp;                        // already happened.)
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Mech.ACTUATOR_UPPER_LEG:
&nbsp;            case Mech.ACTUATOR_LOWER_LEG:
&nbsp;            case Mech.ACTUATOR_FOOT:
<b class="nc">&nbsp;                if (en.canFall(true)) {</b>
&nbsp;                    // leg/foot actuator piloting roll
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(en.getId(), 1, &quot;leg/foot actuator hit&quot;));</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Mech.ACTUATOR_HIP:
<b class="nc">&nbsp;                if (en.canFall(true)) {</b>
&nbsp;                    // hip piloting roll
<b class="nc">&nbsp;                    game.addPSR(new PilotingRollData(en.getId(), 2, &quot;hip actuator hit&quot;));</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case LandAirMech.LAM_AVIONICS:
<b class="nc">&nbsp;                if (en.getConversionMode() == LandAirMech.CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                    if (en.isPartOfFighterSquadron()) {</b>
<b class="nc">&nbsp;                        game.addControlRoll(new PilotingRollData(</b>
<b class="nc">&nbsp;                                en.getTransportId(), 1, &quot;avionics hit&quot;));</b>
<b class="nc">&nbsp;                    } else if (en.isCapitalFighter()){</b>
<b class="nc">&nbsp;                        game.addControlRoll(new PilotingRollData(en.getId(), 1,</b>
&nbsp;                                &quot;avionics hit&quot;));
&nbsp;                    } else {
<b class="nc">&nbsp;                        game.addControlRoll(new PilotingRollData(en.getId(), 0,</b>
&nbsp;                                &quot;avionics hit&quot;));
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply a single critical hit to a ProtoMech.
&nbsp;     *
&nbsp;     * @param pm               the &lt;code&gt;Protomech&lt;/code&gt; that is being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param loc              the &lt;code&gt;int&lt;/code&gt; location of critical hit. This value may
&nbsp;     *                         be &lt;code&gt;Entity.NONE&lt;/code&gt; for hits to a &lt;code&gt;Protomech&lt;/code&gt;
&nbsp;     *                         torso weapon.
&nbsp;     * @param cs               the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param secondaryEffects the &lt;code&gt;boolean&lt;/code&gt; flag that indicates whether to allow
&nbsp;     *                         critical hits to cause secondary effects (such as damaging
&nbsp;     *                         ProtoMech torso weapons). This value is normally
&nbsp;     *                         &lt;code&gt;true&lt;/code&gt;, but it will be &lt;code&gt;false&lt;/code&gt; when the
&nbsp;     *                         hit is being applied from a saved game or scenario.
&nbsp;     * @param damageCaused     the amount of damage causing this critical.
&nbsp;     * @param isCapital        whether it was capital scale damage that caused critical
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; applyProtomechCritical(Protomech pm, int loc, CriticalSlot cs,
&nbsp;                                                  boolean secondaryEffects, int damageCaused,
&nbsp;                                                  boolean isCapital) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        int numHit = pm.getCritsHit(loc);</b>
<b class="nc">&nbsp;        if ((cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_A)</b>
<b class="nc">&nbsp;                &amp;&amp; (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_B)</b>
<b class="nc">&nbsp;                &amp;&amp; (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_C)</b>
<b class="nc">&nbsp;                &amp;&amp; (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_D)</b>
<b class="nc">&nbsp;                &amp;&amp; (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_E)</b>
<b class="nc">&nbsp;                &amp;&amp; (cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_F)) {</b>
<b class="nc">&nbsp;            r = new Report(6225);</b>
<b class="nc">&nbsp;            r.subject = pm.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.add(Protomech.systemNames[cs.getIndex()]);</b>
<b class="nc">&nbsp;            reports.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (cs.getIndex()) {</b>
&nbsp;            case Protomech.SYSTEM_HEADCRIT:
<b class="nc">&nbsp;                if (2 == numHit) {</b>
<b class="nc">&nbsp;                    r = new Report(6230);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
<b class="nc">&nbsp;                    pm.destroyLocation(loc);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_ARMCRIT:
<b class="nc">&nbsp;                if (2 == numHit) {</b>
<b class="nc">&nbsp;                    r = new Report(6235);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
<b class="nc">&nbsp;                    pm.destroyLocation(loc);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_LEGCRIT:
<b class="nc">&nbsp;                if (3 == numHit) {</b>
<b class="nc">&nbsp;                    r = new Report(6240);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
<b class="nc">&nbsp;                    pm.destroyLocation(loc);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSOCRIT:
<b class="nc">&nbsp;                if (3 == numHit) {</b>
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(pm, &quot;torso destruction&quot;));</b>
&nbsp;                }
&nbsp;                // Torso weapon hits are secondary effects and
&nbsp;                // do not occur when loading from a scenario.
<b class="nc">&nbsp;                else if (secondaryEffects) {</b>
<b class="nc">&nbsp;                    int tweapRoll = Compute.d6(1);</b>
&nbsp;                    CriticalSlot newSlot;
&nbsp;
<b class="nc">&nbsp;                    switch (tweapRoll) {</b>
&nbsp;                        case 1:
<b class="nc">&nbsp;                            if (pm.isQuad()) {</b>
<b class="nc">&nbsp;                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Protomech.SYSTEM_TORSO_WEAPON_A);
<b class="nc">&nbsp;                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                        secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        case 2:
<b class="nc">&nbsp;                            if (pm.isQuad()) {</b>
<b class="nc">&nbsp;                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Protomech.SYSTEM_TORSO_WEAPON_B);
<b class="nc">&nbsp;                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                        secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                    Protomech.SYSTEM_TORSO_WEAPON_A);
<b class="nc">&nbsp;                            reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                    secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            if (pm.isQuad()) {</b>
<b class="nc">&nbsp;                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Protomech.SYSTEM_TORSO_WEAPON_C);
<b class="nc">&nbsp;                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                        secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        case 4:
<b class="nc">&nbsp;                            if (pm.isQuad()) {</b>
<b class="nc">&nbsp;                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Protomech.SYSTEM_TORSO_WEAPON_D);
<b class="nc">&nbsp;                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                        secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                    Protomech.SYSTEM_TORSO_WEAPON_B);
<b class="nc">&nbsp;                            reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                    secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case 5:
<b class="nc">&nbsp;                            if (pm.getWeight() &gt; 9) {</b>
<b class="nc">&nbsp;                                if (pm.isQuad()) {</b>
<b class="nc">&nbsp;                                    newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                            Protomech.SYSTEM_TORSO_WEAPON_E);
<b class="nc">&nbsp;                                    reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                            secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                newSlot = new CriticalSlot(</b>
&nbsp;                                        CriticalSlot.TYPE_SYSTEM,
&nbsp;                                        Protomech.SYSTEM_TORSO_WEAPON_C);
<b class="nc">&nbsp;                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                        secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        case 6:
<b class="nc">&nbsp;                            if (pm.getWeight() &gt; 9) {</b>
<b class="nc">&nbsp;                                if (pm.isQuad()) {</b>
<b class="nc">&nbsp;                                    newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                            Protomech.SYSTEM_TORSO_WEAPON_F);
<b class="nc">&nbsp;                                    reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                            secondaryEffects, damageCaused, isCapital));
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                newSlot = new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Protomech.SYSTEM_TORSO_WEAPON_C);
<b class="nc">&nbsp;                                reports.addAll(applyCriticalHit(pm, Entity.NONE, newSlot,</b>
&nbsp;                                        secondaryEffects, damageCaused, isCapital));
&nbsp;                                break;
&nbsp;                            }
&nbsp;                    }
&nbsp;                    // A magnetic clamp system is destroyed by any torso critical.
<b class="nc">&nbsp;                    Mounted magClamp = pm.getMisc().stream().filter(m -&gt; m.getType()</b>
<b class="nc">&nbsp;                            .hasFlag(MiscType.F_MAGNETIC_CLAMP)).findFirst().orElse(null);</b>
<b class="nc">&nbsp;                    if ((magClamp != null) &amp;&amp; !magClamp.isHit()) {</b>
<b class="nc">&nbsp;                        magClamp.setHit(true);</b>
<b class="nc">&nbsp;                        r = new Report(6252);</b>
<b class="nc">&nbsp;                        r.subject = pm.getId();</b>
<b class="nc">&nbsp;                        reports.addElement(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSO_WEAPON_A:
<b class="nc">&nbsp;                Mounted weaponA = pm.getTorsoWeapon(cs.getIndex());</b>
<b class="nc">&nbsp;                if (null != weaponA) {</b>
<b class="nc">&nbsp;                    weaponA.setHit(true);</b>
<b class="nc">&nbsp;                    r = new Report(6245);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSO_WEAPON_B:
<b class="nc">&nbsp;                Mounted weaponB = pm.getTorsoWeapon(cs.getIndex());</b>
<b class="nc">&nbsp;                if (null != weaponB) {</b>
<b class="nc">&nbsp;                    weaponB.setHit(true);</b>
<b class="nc">&nbsp;                    r = new Report(6246);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSO_WEAPON_C:
<b class="nc">&nbsp;                Mounted weaponC = pm.getTorsoWeapon(cs.getIndex());</b>
<b class="nc">&nbsp;                if (null != weaponC) {</b>
<b class="nc">&nbsp;                    weaponC.setHit(true);</b>
<b class="nc">&nbsp;                    r = new Report(6247);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSO_WEAPON_D:
<b class="nc">&nbsp;                Mounted weaponD = pm.getTorsoWeapon(cs.getIndex());</b>
<b class="nc">&nbsp;                if (null != weaponD) {</b>
<b class="nc">&nbsp;                    weaponD.setHit(true);</b>
<b class="nc">&nbsp;                    r = new Report(6248);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSO_WEAPON_E:
<b class="nc">&nbsp;                Mounted weaponE = pm.getTorsoWeapon(cs.getIndex());</b>
<b class="nc">&nbsp;                if (null != weaponE) {</b>
<b class="nc">&nbsp;                    weaponE.setHit(true);</b>
<b class="nc">&nbsp;                    r = new Report(6249);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Protomech.SYSTEM_TORSO_WEAPON_F:
<b class="nc">&nbsp;                Mounted weaponF = pm.getTorsoWeapon(cs.getIndex());</b>
<b class="nc">&nbsp;                if (null != weaponF) {</b>
<b class="nc">&nbsp;                    weaponF.setHit(true);</b>
<b class="nc">&nbsp;                    r = new Report(6250);</b>
<b class="nc">&nbsp;                    r.subject = pm.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    reports.addElement(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        } // End switch( cs.getType() )
&nbsp;
&nbsp;        // Shaded hits cause pilot damage.
<b class="nc">&nbsp;        if (pm.shaded(loc, numHit)) {</b>
&nbsp;            // Destroyed ProtoMech sections have
&nbsp;            // already damaged the pilot.
<b class="nc">&nbsp;            int pHits = Protomech.POSSIBLE_PILOT_DAMAGE[loc]</b>
<b class="nc">&nbsp;                        - pm.getPilotDamageTaken(loc);</b>
<b class="nc">&nbsp;            if (Math.min(1, pHits) &gt; 0) {</b>
<b class="nc">&nbsp;                Report.addNewline(reports);</b>
<b class="nc">&nbsp;                reports.addAll(damageCrew(pm, 1));</b>
<b class="nc">&nbsp;                pHits = 1 + pm.getPilotDamageTaken(loc);</b>
<b class="nc">&nbsp;                pm.setPilotDamageTaken(loc, pHits);</b>
&nbsp;            }
&nbsp;        } // End have-shaded-hit
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply a single critical hit to an aerospace unit.
&nbsp;     *
&nbsp;     * @param aero             the &lt;code&gt;Aero&lt;/code&gt; that is being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param loc              the &lt;code&gt;int&lt;/code&gt; location of critical hit.
&nbsp;     * @param cs               the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param damageCaused     the amount of damage causing this critical.
&nbsp;     * @param isCapital        whether it was capital scale damage that caused critical
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; applyAeroCritical(Aero aero, int loc, CriticalSlot cs, int damageCaused, boolean isCapital) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        Jumpship js = null;</b>
<b class="nc">&nbsp;        if (aero instanceof Jumpship) {</b>
<b class="nc">&nbsp;            js = (Jumpship)aero;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (cs.getIndex()) {</b>
&nbsp;            case Aero.CRIT_NONE:
&nbsp;                // no effect
<b class="nc">&nbsp;                r = new Report(6005);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_FCS:
&nbsp;                // Fire control system
<b class="nc">&nbsp;                r = new Report(9105);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setFCSHits(aero.getFCSHits() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_SENSOR:
&nbsp;                // sensors
<b class="nc">&nbsp;                r = new Report(6620);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setSensorHits(aero.getSensorHits() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_AVIONICS:
&nbsp;                // avionics
<b class="nc">&nbsp;                r = new Report(9110);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setAvionicsHits(aero.getAvionicsHits() + 1);</b>
<b class="nc">&nbsp;                if (aero.isPartOfFighterSquadron()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(</b>
<b class="nc">&nbsp;                            aero.getTransportId(), 1, &quot;avionics hit&quot;));</b>
<b class="nc">&nbsp;                } else if (aero.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(aero.getId(), 1,</b>
&nbsp;                                                             &quot;avionics hit&quot;));
&nbsp;                } else {
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(aero.getId(), 0,</b>
&nbsp;                                                             &quot;avionics hit&quot;));
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_CONTROL:
&nbsp;                // force control roll
<b class="nc">&nbsp;                r = new Report(9115);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                if (aero.isPartOfFighterSquadron()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(</b>
<b class="nc">&nbsp;                            aero.getTransportId(), 1, &quot;critical hit&quot;));</b>
<b class="nc">&nbsp;                } else if (aero.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(aero.getId(), 1,</b>
&nbsp;                                                             &quot;critical hit&quot;));
&nbsp;                } else {
<b class="nc">&nbsp;                    game.addControlRoll(new PilotingRollData(aero.getId(), 0,</b>
&nbsp;                                                             &quot;critical hit&quot;));
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_FUEL_TANK:
&nbsp;                // fuel tank
<b class="nc">&nbsp;                int boomTarget = 10;</b>
<b class="nc">&nbsp;                if (aero.hasQuirk(OptionsConstants.QUIRK_NEG_FRAGILE_FUEL)) {</b>
<b class="nc">&nbsp;                    boomTarget = 8;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aero.isLargeCraft() &amp;&amp; aero.isClan()</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVAERORULES_STRATOPS_HARJEL)) {
<b class="nc">&nbsp;                    boomTarget = 12;</b>
&nbsp;                }
&nbsp;                // check for possible explosion
<b class="nc">&nbsp;                int fuelroll = Compute.d6(2);</b>
<b class="nc">&nbsp;                r = new Report(9120);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                if (fuelroll &gt;= boomTarget) {</b>
&nbsp;                    // A chance to reroll the explosion with edge
<b class="nc">&nbsp;                    if (aero.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; aero.getCrew().getOptions().booleanOption(</b>
&nbsp;                                    OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)) {
&nbsp;                        // Reporting this is funky because 9120 only has room for 2 choices. Replace it.
<b class="nc">&nbsp;                        r = new Report(9123);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        aero.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        fuelroll = Compute.d6(2);</b>
&nbsp;                        // To explode, or not to explode
<b class="nc">&nbsp;                        if (fuelroll &gt;= boomTarget) {</b>
<b class="nc">&nbsp;                            r = new Report(9124);</b>
<b class="nc">&nbsp;                            r.subject = aero.getId();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r = new Report(9122);</b>
<b class="nc">&nbsp;                            r.subject = aero.getId();</b>
<b class="nc">&nbsp;                            reports.add(r);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                    // Lets auto-eject if we can!
<b class="nc">&nbsp;                    if (aero.isFighter()) {</b>
<b class="nc">&nbsp;                        if (aero.isAutoEject()</b>
<b class="nc">&nbsp;                                &amp;&amp; (!game.getOptions().booleanOption(</b>
&nbsp;                                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                                || (game.getOptions().booleanOption(</b>
&nbsp;                                        OptionsConstants.RPG_CONDITIONAL_EJECTION)
<b class="nc">&nbsp;                                &amp;&amp; aero.isCondEjectFuel()))) {</b>
<b class="nc">&nbsp;                            reports.addAll(ejectEntity(aero, true, false));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(aero, &quot;fuel explosion&quot;, false, false));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                aero.setFuelTankHit(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_CREW:
&nbsp;                // pilot hit
<b class="nc">&nbsp;                r = new Report(6650);</b>
<b class="nc">&nbsp;                if (aero.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)) {</b>
<b class="nc">&nbsp;                    r = new Report(6651);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    break;</b>
<b class="nc">&nbsp;                } else if (aero.hasAbility(OptionsConstants.MD_TSM_IMPLANT)) {</b>
<b class="nc">&nbsp;                    r = new Report(6652);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((aero instanceof SmallCraft) || (aero instanceof Jumpship)) {</b>
<b class="nc">&nbsp;                    r = new Report(9197);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aero.isLargeCraft() &amp;&amp; aero.isClan()</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVAERORULES_STRATOPS_HARJEL)
<b class="nc">&nbsp;                        &amp;&amp; (aero.getIgnoredCrewHits() &lt; 2)) {</b>
<b class="nc">&nbsp;                    aero.setIgnoredCrewHits(aero.getIgnoredCrewHits() + 1);</b>
<b class="nc">&nbsp;                    r = new Report(9198);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                reports.addAll(damageCrew(aero, 1));</b>
&nbsp;                // The pilot may have just expired.
<b class="nc">&nbsp;                if ((aero.getCrew().isDead() || aero.getCrew().isDoomed())</b>
<b class="nc">&nbsp;                       &amp;&amp; !aero.getCrew().isEjected()) {</b>
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(aero, &quot;pilot death&quot;, true, true));</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Aero.CRIT_GEAR:
&nbsp;                // landing gear
<b class="nc">&nbsp;                r = new Report(9125);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setGearHit(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_BOMB:
&nbsp;                // bomb destroyed
&nbsp;                // go through bomb list and choose one
<b class="nc">&nbsp;                List&lt;Mounted&gt; bombs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Mounted bomb : aero.getBombs()) {</b>
<b class="nc">&nbsp;                    if (bomb.getType().isHittable() &amp;&amp; (bomb.getHittableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;                        bombs.add(bomb);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (bombs.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    Mounted hitbomb = bombs.get(Compute.randomInt(bombs.size()));</b>
<b class="nc">&nbsp;                    hitbomb.setShotsLeft(0);</b>
<b class="nc">&nbsp;                    hitbomb.setDestroyed(true);</b>
<b class="nc">&nbsp;                    r = new Report(9130);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    r.add(hitbomb.getDesc());</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                    // If we are part of a squadron, we should recalculate
&nbsp;                    // the bomb salvo for the squadron
<b class="nc">&nbsp;                    if (aero.getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                        Entity e = game.getEntity(aero.getTransportId());</b>
<b class="nc">&nbsp;                        if (e instanceof FighterSquadron) {</b>
<b class="nc">&nbsp;                            ((FighterSquadron) e).computeSquadronBombLoadout();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    r = new Report(9131);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_HEATSINK:
&nbsp;                // heat sink hit
<b class="nc">&nbsp;                int sinksLost = 1;</b>
<b class="nc">&nbsp;                if (isCapital) {</b>
<b class="nc">&nbsp;                    sinksLost = 10;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = new Report(9135);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                r.add(sinksLost);</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setHeatSinks(Math.max(0, aero.getHeatSinks() - sinksLost));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_WEAPON_BROAD:
<b class="nc">&nbsp;                if (aero instanceof Warship) {</b>
<b class="nc">&nbsp;                    if ((loc == Jumpship.LOC_ALS) || (loc == Jumpship.LOC_FLS)) {</b>
<b class="nc">&nbsp;                        loc = Warship.LOC_LBS;</b>
<b class="nc">&nbsp;                    } else if ((loc == Jumpship.LOC_ARS)</b>
&nbsp;                               || (loc == Jumpship.LOC_FRS)) {
<b class="nc">&nbsp;                        loc = Warship.LOC_RBS;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            case Aero.CRIT_WEAPON:
<b class="nc">&nbsp;                if (aero.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                    boolean destroyAll = false;</b>
&nbsp;                    // CRIT_WEAPON damages the capital fighter/squadron&#39;s weapon groups
&nbsp;                    // Go ahead and map damage for the fighter&#39;s weapon criticals for MHQ
&nbsp;                    // resolution.
<b class="nc">&nbsp;                    aero.damageCapFighterWeapons(loc);</b>
<b class="nc">&nbsp;                    if ((loc == Aero.LOC_NOSE) || (loc == Aero.LOC_AFT)) {</b>
<b class="nc">&nbsp;                        destroyAll = true;</b>
&nbsp;                    }
&nbsp;                    
&nbsp;                    // Convert L/R wing location to wings, else wing weapons never get hit
<b class="nc">&nbsp;                    if (loc == Aero.LOC_LWING || loc == Aero.LOC_RWING) {</b>
<b class="nc">&nbsp;                        loc = Aero.LOC_WINGS;</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if (loc == Aero.LOC_WINGS) {</b>
<b class="nc">&nbsp;                        if (aero.areWingsHit()) {</b>
<b class="nc">&nbsp;                            destroyAll = true;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            aero.setWingsHit(true);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    for (Mounted weapon : aero.getWeaponList()) {</b>
<b class="nc">&nbsp;                        if (weapon.getLocation() == loc) {</b>
<b class="nc">&nbsp;                            if (destroyAll) {</b>
<b class="nc">&nbsp;                                weapon.setHit(true);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                weapon.setNWeapons(weapon.getNWeapons() / 2);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // also destroy any ECM or BAP in the location hit
<b class="nc">&nbsp;                    for (Mounted misc : aero.getMisc()) {</b>
<b class="nc">&nbsp;                        if ((misc.getType().hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;                            || misc.getType().hasFlag(MiscType.F_ANGEL_ECM)</b>
<b class="nc">&nbsp;                            || misc.getType().hasFlag(MiscType.F_BAP))</b>
<b class="nc">&nbsp;                                &amp;&amp; misc.getLocation() == loc) {</b>
<b class="nc">&nbsp;                            misc.setHit(true);</b>
&nbsp;                            //Taharqa: We should also damage the critical slot, or
&nbsp;                            //MM and MHQ won&#39;t remember that this weapon is damaged on the MUL
&nbsp;                            //file
<b class="nc">&nbsp;                            for (int i = 0; i &lt; aero.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                                CriticalSlot slot1 = aero.getCritical(loc, i);</b>
<b class="nc">&nbsp;                                if ((slot1 == null) ||</b>
<b class="nc">&nbsp;                                        (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                Mounted mounted = slot1.getMount();</b>
<b class="nc">&nbsp;                                if (mounted.equals(misc)) {</b>
<b class="nc">&nbsp;                                    aero.hitAllCriticals(loc, i);</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    r = new Report(9152);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    r.add(aero.getLocationName(loc));</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = new Report(9150);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                List&lt;Mounted&gt; weapons = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Mounted weapon : aero.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if ((weapon.getLocation() == loc) &amp;&amp; !weapon.isDestroyed()</b>
<b class="nc">&nbsp;                            &amp;&amp; weapon.getType().isHittable()) {</b>
<b class="nc">&nbsp;                        weapons.add(weapon);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // add in in hittable misc equipment
<b class="nc">&nbsp;                for (Mounted misc : aero.getMisc()) {</b>
<b class="nc">&nbsp;                    if (misc.getType().isHittable()</b>
<b class="nc">&nbsp;                        &amp;&amp; (misc.getLocation() == loc)</b>
<b class="nc">&nbsp;                        &amp;&amp; !misc.isDestroyed()) {</b>
<b class="nc">&nbsp;                        weapons.add(misc);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (weapons.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    Mounted weapon = weapons.get(Compute.randomInt(weapons.size()));</b>
&nbsp;                    // possibly check for an ammo explosion
&nbsp;                    // don&#39;t allow ammo explosions on fighter squadrons
<b class="nc">&nbsp;                    if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AMMO_EXPLOSIONS)</b>
&nbsp;                        &amp;&amp; !(aero instanceof FighterSquadron)
<b class="nc">&nbsp;                        &amp;&amp; (weapon.getType() instanceof WeaponType)) {</b>
&nbsp;                        //Bay Weapons
<b class="nc">&nbsp;                        if (aero.usesWeaponBays()) {</b>
&nbsp;                            //Finish reporting(9150) a hit on the bay
<b class="nc">&nbsp;                            r.add(weapon.getName());</b>
<b class="nc">&nbsp;                            reports.add(r);</b>
&nbsp;                            //Pick a random weapon in the bay and get the stats
<b class="nc">&nbsp;                            int wId = weapon.getBayWeapons().get(Compute.randomInt(weapon.getBayWeapons().size()));</b>
<b class="nc">&nbsp;                            Mounted bayW = aero.getEquipment(wId);</b>
<b class="nc">&nbsp;                            Mounted bayWAmmo = bayW.getLinked();</b>
<b class="nc">&nbsp;                            if (bayWAmmo != null &amp;&amp; bayWAmmo.getType().isExplosive(bayWAmmo)) {</b>
<b class="nc">&nbsp;                                r = new Report(9156);</b>
<b class="nc">&nbsp;                                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                                r.newlines = 1;</b>
<b class="nc">&nbsp;                                r.indent(2);</b>
&nbsp;                                //On a roll of 10+, the ammo bin explodes
<b class="nc">&nbsp;                                int ammoRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                                boomTarget = 10;</b>
<b class="nc">&nbsp;                                r.choose(ammoRoll &gt;= boomTarget);</b>
&nbsp;                                // A chance to reroll an explosion with edge
<b class="nc">&nbsp;                                if (aero.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                        &amp;&amp; aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)</b>
&nbsp;                                        &amp;&amp; ammoRoll &gt;= boomTarget) {
&nbsp;                                    // Report 9156 doesn&#39;t offer the right choices. Replace it.
<b class="nc">&nbsp;                                    r = new Report(9158);</b>
<b class="nc">&nbsp;                                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                                    r.newlines = 0;</b>
<b class="nc">&nbsp;                                    r.indent(2);</b>
<b class="nc">&nbsp;                                    reports.add(r);</b>
<b class="nc">&nbsp;                                    aero.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                                    ammoRoll = Compute.d6(2);</b>
&nbsp;                                    // To explode, or not to explode
<b class="nc">&nbsp;                                    if (ammoRoll &gt;= boomTarget) {</b>
<b class="nc">&nbsp;                                        reports.addAll(explodeEquipment(aero, loc, bayWAmmo));</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        r = new Report(9157);</b>
<b class="nc">&nbsp;                                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                                        reports.add(r);</b>
&nbsp;                                    }
&nbsp;                                } else {
&nbsp;                                    //Finish handling report 9156
<b class="nc">&nbsp;                                    reports.add(r);</b>
<b class="nc">&nbsp;                                    if (ammoRoll &gt;= boomTarget) {</b>
<b class="nc">&nbsp;                                        reports.addAll(explodeEquipment(aero, loc, bayWAmmo));</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                            //Hit the weapon then also hit all the other weapons in the bay
<b class="nc">&nbsp;                            weapon.setHit(true);</b>
<b class="nc">&nbsp;                            for(int next : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                                Mounted bayWeap = aero.getEquipment(next);</b>
<b class="nc">&nbsp;                                if(null != bayWeap) {</b>
<b class="nc">&nbsp;                                    bayWeap.setHit(true);</b>
&nbsp;                                    //Taharqa: We should also damage the critical slot, or
&nbsp;                                    //MM and MHQ won&#39;t remember that this weapon is damaged on the MUL
&nbsp;                                    //file
<b class="nc">&nbsp;                                    for (int i = 0; i &lt; aero.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                                        CriticalSlot slot1 = aero.getCritical(loc, i);</b>
<b class="nc">&nbsp;                                        if ((slot1 == null) ||</b>
<b class="nc">&nbsp;                                                (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {</b>
<b class="nc">&nbsp;                                            continue;</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                        Mounted mounted = slot1.getMount();</b>
<b class="nc">&nbsp;                                        if (mounted.equals(bayWeap)) {</b>
<b class="nc">&nbsp;                                            aero.hitAllCriticals(loc, i);</b>
<b class="nc">&nbsp;                                            break;</b>
&nbsp;                                        }
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        // does it use Ammo?
<b class="nc">&nbsp;                        WeaponType wtype = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;                        if (wtype.getAmmoType() != AmmoType.T_NA) {</b>
<b class="nc">&nbsp;                            Mounted m = weapon.getLinked();</b>
<b class="nc">&nbsp;                            int ammoroll = Compute.d6(2);</b>
<b class="nc">&nbsp;                            if (ammoroll &gt;= 10) {</b>
&nbsp;                                // A chance to reroll an explosion with edge
<b class="nc">&nbsp;                                if (aero.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                        &amp;&amp; aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)) {</b>
<b class="nc">&nbsp;                                    aero.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                                    r = new Report(6530);</b>
<b class="nc">&nbsp;                                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                                    r.add(aero.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;                                    reports.add(r);</b>
<b class="nc">&nbsp;                                    ammoroll = Compute.d6(2);</b>
<b class="nc">&nbsp;                                    if (ammoroll &gt;= 10) {</b>
<b class="nc">&nbsp;                                        reports.addAll(explodeEquipment(aero, loc, m));</b>
<b class="nc">&nbsp;                                        break;</b>
&nbsp;                                    } else {
&nbsp;                                        //Crisis averted, set report 9150 back up
<b class="nc">&nbsp;                                        r = new Report(9150);</b>
<b class="nc">&nbsp;                                        r.subject = aero.getId();</b>
&nbsp;                                    }
&nbsp;                                } else {
<b class="nc">&nbsp;                                    r = new Report(9151);</b>
<b class="nc">&nbsp;                                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                                    r.add(m.getName());</b>
<b class="nc">&nbsp;                                    r.newlines = 0;</b>
<b class="nc">&nbsp;                                    reports.add(r);</b>
<b class="nc">&nbsp;                                    reports.addAll(explodeEquipment(aero, loc, m));</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                    // If the weapon is explosive, use edge to roll up a new one
<b class="nc">&nbsp;                    if (aero.getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_EXPLOSION)</b>
<b class="nc">&nbsp;                            &amp;&amp; (weapon.getType().isExplosive(weapon) &amp;&amp; !weapon.isHit()</b>
<b class="nc">&nbsp;                                    &amp;&amp; !weapon.isDestroyed())) {</b>
<b class="nc">&nbsp;                        aero.getCrew().decreaseEdge();</b>
&nbsp;                        //Try something new for an interrupting report. r is still 9150.
<b class="nc">&nbsp;                        Report r1 = new Report(6530);</b>
<b class="nc">&nbsp;                        r1.subject = aero.getId();</b>
<b class="nc">&nbsp;                        r1.add(aero.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;                        reports.add(r1);</b>
<b class="nc">&nbsp;                        weapon = weapons.get(Compute.randomInt(weapons.size()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.add(weapon.getName());</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                    // explosive weapons e.g. gauss now explode
<b class="nc">&nbsp;                    if (weapon.getType().isExplosive(weapon) &amp;&amp; !weapon.isHit()</b>
<b class="nc">&nbsp;                        &amp;&amp; !weapon.isDestroyed()) {</b>
<b class="nc">&nbsp;                        reports.addAll(explodeEquipment(aero, loc, weapon));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    weapon.setHit(true);</b>
&nbsp;                    //Taharqa: We should also damage the critical slot, or
&nbsp;                    //MM and MHQ won&#39;t remember that this weapon is damaged on the MUL
&nbsp;                    //file
<b class="nc">&nbsp;                    for (int i = 0; i &lt; aero.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                        CriticalSlot slot1 = aero.getCritical(loc, i);</b>
<b class="nc">&nbsp;                        if ((slot1 == null) ||</b>
<b class="nc">&nbsp;                                (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Mounted mounted = slot1.getMount();</b>
<b class="nc">&nbsp;                        if (mounted.equals(weapon)) {</b>
<b class="nc">&nbsp;                            aero.hitAllCriticals(loc, i);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    //if this is a weapons bay then also hit all the other weapons
<b class="nc">&nbsp;                    for(int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                        Mounted bayWeap = aero.getEquipment(wId);</b>
<b class="nc">&nbsp;                        if(null != bayWeap) {</b>
<b class="nc">&nbsp;                            bayWeap.setHit(true);</b>
&nbsp;                            //Taharqa: We should also damage the critical slot, or
&nbsp;                            //MM and MHQ won&#39;t remember that this weapon is damaged on the MUL
&nbsp;                            //file
<b class="nc">&nbsp;                            for (int i = 0; i &lt; aero.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                                CriticalSlot slot1 = aero.getCritical(loc, i);</b>
<b class="nc">&nbsp;                                if ((slot1 == null) ||</b>
<b class="nc">&nbsp;                                        (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                Mounted mounted = slot1.getMount();</b>
<b class="nc">&nbsp;                                if (mounted.equals(bayWeap)) {</b>
<b class="nc">&nbsp;                                    aero.hitAllCriticals(loc, i);</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    r = new Report(9155);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_ENGINE:
&nbsp;                // engine hit
<b class="nc">&nbsp;                r = new Report(9140);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.engineHitsThisPhase++;</b>
<b class="nc">&nbsp;                boolean engineExploded = checkEngineExplosion(aero, reports, 1);</b>
<b class="nc">&nbsp;                aero.setEngineHits(aero.getEngineHits() + 1);</b>
<b class="nc">&nbsp;                if ((aero.getEngineHits() &gt;= aero.getMaxEngineHits())</b>
&nbsp;                    || engineExploded) {
&nbsp;                    // this engine hit puts the ASF out of commission
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(aero, &quot;engine destruction&quot;, true,</b>
&nbsp;                                               true));
<b class="nc">&nbsp;                    aero.setSelfDestructing(false);</b>
<b class="nc">&nbsp;                    aero.setSelfDestructInitiated(false);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Aero.CRIT_LEFT_THRUSTER:
&nbsp;                // thruster hit
<b class="nc">&nbsp;                r = new Report(9160);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setLeftThrustHits(aero.getLeftThrustHits() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_RIGHT_THRUSTER:
&nbsp;                // thruster hit
<b class="nc">&nbsp;                r = new Report(9160);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                aero.setRightThrustHits(aero.getRightThrustHits() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_CARGO:
<b class="nc">&nbsp;                applyCargoCritical(aero, damageCaused, reports);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_DOOR:
&nbsp;                // door hit
&nbsp;                // choose a random bay
<b class="nc">&nbsp;                String bayType = aero.damageBayDoor();</b>
<b class="nc">&nbsp;                if (!bayType.equals(&quot;none&quot;)) {</b>
<b class="nc">&nbsp;                    r = new Report(9170);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    r.add(bayType);</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(9171);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_DOCK_COLLAR:
&nbsp;                // docking collar hit
&nbsp;                // different effect for DropShips and JumpShips
<b class="nc">&nbsp;                if (aero instanceof Dropship) {</b>
<b class="nc">&nbsp;                    ((Dropship)aero).setDamageDockCollar(true);</b>
<b class="nc">&nbsp;                    r = new Report(9175);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (aero instanceof Jumpship) {</b>
&nbsp;                    // damage a random docking collar
<b class="nc">&nbsp;                    if (aero.damageDockCollar()) {</b>
<b class="nc">&nbsp;                        r = new Report(9176);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(9177);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            case Aero.CRIT_KF_BOOM:
&nbsp;                // KF boom hit
&nbsp;                // no real effect yet
<b class="nc">&nbsp;                if (aero instanceof Dropship) {</b>
<b class="nc">&nbsp;                    ((Dropship)aero).setDamageKFBoom(true);</b>
<b class="nc">&nbsp;                    r = new Report(9180);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Aero.CRIT_CIC:
<b class="nc">&nbsp;                if (js == null) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                // CIC hit
<b class="nc">&nbsp;                r = new Report(9185);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                js.setCICHits(js.getCICHits() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_KF_DRIVE:
&nbsp;                //Per SO construction rules, stations have no KF drive, therefore they can&#39;t take a hit to it...
<b class="nc">&nbsp;                if (js == null || js instanceof SpaceStation) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                // KF Drive hit - damage the drive integrity
<b class="nc">&nbsp;                js.setKFIntegrity(Math.max(0, (js.getKFIntegrity() - 1)));</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_EXPANDED_KF_DRIVE_DAMAGE)) {</b>
&nbsp;                    //Randomize the component struck - probabilities taken from the old BattleSpace record sheets
<b class="nc">&nbsp;                    switch (Compute.d6(2)) {</b>
&nbsp;                    case 2:
&nbsp;                        //Drive Coil Hit
<b class="nc">&nbsp;                        r = new Report(9186);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        js.setKFDriveCoilHit(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 3:
&nbsp;                    case 11:
&nbsp;                        //Charging System Hit
<b class="nc">&nbsp;                        r = new Report(9187);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        js.setKFChargingSystemHit(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 5:
&nbsp;                        //Field Initiator Hit
<b class="nc">&nbsp;                        r = new Report(9190);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        js.setKFFieldInitiatorHit(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 4:
&nbsp;                    case 6:
&nbsp;                    case 7:
&nbsp;                    case 8:
&nbsp;                        //Helium Tank Hit
<b class="nc">&nbsp;                        r = new Report(9189);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        js.setKFHeliumTankHit(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 9:
&nbsp;                        //Drive Controller Hit
<b class="nc">&nbsp;                        r = new Report(9191);</b>
<b class="nc">&nbsp;                        r.subject = aero.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        js.setKFDriveControllerHit(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case 10:
&nbsp;                    case 12:
&nbsp;                        //LF Battery Hit - if you don&#39;t have one, treat as helium tank
<b class="nc">&nbsp;                        if (js.hasLF()) {</b>
<b class="nc">&nbsp;                            r = new Report(9188);</b>
<b class="nc">&nbsp;                            r.subject = aero.getId();</b>
<b class="nc">&nbsp;                            reports.add(r);</b>
<b class="nc">&nbsp;                            js.setLFBatteryHit(true);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            r = new Report(9189);</b>
<b class="nc">&nbsp;                            r.subject = aero.getId();</b>
<b class="nc">&nbsp;                            reports.add(r);</b>
<b class="nc">&nbsp;                            js.setKFHeliumTankHit(true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    //Just report the standard KF hit, per SO rules
<b class="nc">&nbsp;                    r = new Report(9194);</b>
<b class="nc">&nbsp;                    r.subject = aero.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_GRAV_DECK:
<b class="nc">&nbsp;                if (js == null) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                int choice = Compute.randomInt(js.getTotalGravDeck());</b>
&nbsp;                // Grav Deck hit
<b class="nc">&nbsp;                r = new Report(9195);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                js.setGravDeckDamageFlag(choice, 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Aero.CRIT_LIFE_SUPPORT:
&nbsp;                // Life Support hit
<b class="nc">&nbsp;                aero.setLifeSupport(false);</b>
<b class="nc">&nbsp;                r = new Report(9196);</b>
<b class="nc">&nbsp;                r.subject = aero.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects random undestroyed bay and applies damage, destroying loaded units where applicable.
&nbsp;     *
&nbsp;     * @param aero           The unit that received the cargo critical.
&nbsp;     * @param damageCaused   The amount of damage applied by the hit that resulted in the cargo critical.
&nbsp;     * @param reports        Used to return any report generated while applying the critical.
&nbsp;     */
&nbsp;    private void applyCargoCritical(Aero aero, int damageCaused, Vector&lt;Report&gt; reports) {
&nbsp;        Report r;
&nbsp;        // cargo hit
&nbsp;        // First what percentage of the cargo did the hit destroy?
<b class="nc">&nbsp;        double percentDestroyed = 0.0;</b>
<b class="nc">&nbsp;        double mult = 2.0;</b>
<b class="nc">&nbsp;        if (aero.isLargeCraft() &amp;&amp; aero.isClan()</b>
<b class="nc">&nbsp;            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_HARJEL)) {</b>
<b class="nc">&nbsp;            mult = 4.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (damageCaused &gt; 0) {</b>
<b class="nc">&nbsp;            percentDestroyed = Math.min(</b>
<b class="nc">&nbsp;                    damageCaused / (mult * aero.getSI()), 1.0);</b>
&nbsp;        }
&nbsp;        List&lt;Bay&gt; bays;
<b class="nc">&nbsp;        double destroyed = 0;</b>
&nbsp;        // did it hit cargo or units
<b class="nc">&nbsp;        int roll = Compute.d6(1);</b>
&nbsp;        // A hit on a bay filled with transported units is devastating
&nbsp;        // allow a reroll with edge
<b class="nc">&nbsp;        if (aero.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_UNIT_CARGO_LOST)</b>
<b class="nc">&nbsp;                &amp;&amp; aero.getCrew().hasEdgeRemaining() &amp;&amp; roll &gt; 3) {</b>
<b class="nc">&nbsp;            aero.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;            r = new Report(9172);</b>
<b class="nc">&nbsp;            r.subject = aero.getId();</b>
<b class="nc">&nbsp;            r.add(aero.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;            reports.add(r);</b>
&nbsp;            //Reroll. Maybe we&#39;ll hit cargo.
<b class="nc">&nbsp;            roll = Compute.d6(1);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (roll &lt; 4) {</b>
<b class="nc">&nbsp;            bays = aero.getTransportBays().stream().filter(Bay::isCargo).collect(Collectors.toList());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bays = aero.getTransportBays().stream()</b>
<b class="nc">&nbsp;                    .filter(b -&gt; !b.isCargo() &amp;&amp; !b.isQuarters()).collect(Collectors.toList());</b>
&nbsp;        }
<b class="nc">&nbsp;        Bay hitBay = null;</b>
<b class="nc">&nbsp;        while ((null == hitBay) &amp;&amp; !bays.isEmpty()) {</b>
<b class="nc">&nbsp;            hitBay = bays.remove(Compute.randomInt(bays.size()));</b>
<b class="nc">&nbsp;            if (hitBay.getBayDamage() &lt; hitBay.getCapacity()) {</b>
<b class="nc">&nbsp;                if (hitBay.isCargo()) {</b>
<b class="nc">&nbsp;                    destroyed = (hitBay.getCapacity() * percentDestroyed * 2.0) / 2.0;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    destroyed = Math.ceil(hitBay.getCapacity() * percentDestroyed);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                hitBay = null;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (null != hitBay) {</b>
<b class="nc">&nbsp;            destroyed = Math.min(destroyed, hitBay.getCapacity() - hitBay.getBayDamage());</b>
<b class="nc">&nbsp;            if (hitBay.isCargo()) {</b>
<b class="nc">&nbsp;                r = new Report(9165);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(9166);</b>
&nbsp;            }
<b class="nc">&nbsp;            r.subject = aero.getId();</b>
<b class="nc">&nbsp;            r.add(hitBay.getBayNumber());</b>
<b class="nc">&nbsp;            if (destroyed == (int) destroyed) {</b>
<b class="nc">&nbsp;                r.add((int) destroyed);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.add(String.valueOf(Math.ceil(destroyed * 2.0) / 2.0));</b>
&nbsp;            }
<b class="nc">&nbsp;            reports.add(r);</b>
<b class="nc">&nbsp;            if (!hitBay.isCargo()) {</b>
<b class="nc">&nbsp;                List&lt;Entity&gt; units = new ArrayList&lt;&gt;(hitBay.getLoadedUnits());</b>
<b class="nc">&nbsp;                List&lt;Entity&gt; toRemove = new ArrayList&lt;&gt;();</b>
&nbsp;                //We&#39;re letting destroyed units stay in the bay now, but take them off the targets list
<b class="nc">&nbsp;                for (Entity en : units) {</b>
<b class="nc">&nbsp;                    if (en.isDestroyed() || en.isDoomed()) {</b>
<b class="nc">&nbsp;                        toRemove.add(en);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                units.removeAll(toRemove);</b>
<b class="nc">&nbsp;                while ((destroyed &gt; 0) &amp;&amp; !units.isEmpty()) {</b>
<b class="nc">&nbsp;                    Entity target = units.remove(Compute.randomInt(units.size()));</b>
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(target, &quot;cargo damage&quot;,</b>
&nbsp;                            false, true));
<b class="nc">&nbsp;                    destroyed--;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(9167);</b>
<b class="nc">&nbsp;            r.subject = aero.getId();</b>
<b class="nc">&nbsp;            r.choose(roll &lt; 4); // cargo or transport</b>
<b class="nc">&nbsp;            reports.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply a single critical hit to a vehicle.
&nbsp;     *
&nbsp;     * @param tank             the &lt;code&gt;Tank&lt;/code&gt; that is being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param loc              the &lt;code&gt;int&lt;/code&gt; location of critical hit. This value may
&nbsp;     *                         be &lt;code&gt;Entity.NONE&lt;/code&gt; for hits to &lt;code&gt;Tank&lt;/code&gt;s and
&nbsp;     *                         for hits to a &lt;code&gt;Protomech&lt;/code&gt; torso weapon.
&nbsp;     * @param cs               the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged. This value may
&nbsp;     *                         not be &lt;code&gt;null&lt;/code&gt;. The index of the slot should be the index
&nbsp;     *                         of the critical hit table.
&nbsp;     * @param damageCaused     the amount of damage causing this critical.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; applyTankCritical(Tank tank, int loc, CriticalSlot cs, int damageCaused) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;        HitData hit;
<b class="nc">&nbsp;        switch (cs.getIndex()) {</b>
&nbsp;            case Tank.CRIT_NONE:
&nbsp;                // no effect
<b class="nc">&nbsp;                r = new Report(6005);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_AMMO:
&nbsp;                // ammo explosion
<b class="nc">&nbsp;                r = new Report(6610);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                int damage = 0;</b>
<b class="nc">&nbsp;                for (Mounted m : tank.getAmmo()) {</b>
&nbsp;                    // Don&#39;t include ammo of one-shot weapons.
<b class="nc">&nbsp;                    if (m.getLocation() == Entity.LOC_NONE) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    m.setHit(true);</b>
<b class="nc">&nbsp;                    int tmp = m.getHittableShotsLeft()</b>
<b class="nc">&nbsp;                              * ((AmmoType) m.getType()).getDamagePerShot()</b>
<b class="nc">&nbsp;                              * ((AmmoType) m.getType()).getRackSize();</b>
<b class="nc">&nbsp;                    m.setShotsLeft(0);</b>
&nbsp;                    // non-explosive ammo can&#39;t explode
<b class="nc">&nbsp;                    if (!m.getType().isExplosive(m)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    damage += tmp;</b>
<b class="nc">&nbsp;                    r = new Report(6390);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    r.add(m.getName());</b>
<b class="nc">&nbsp;                    r.add(tmp);</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                hit = new HitData(loc);</b>
<b class="nc">&nbsp;                reports.addAll(damageEntity(tank, hit, damage, true));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_CARGO:
&nbsp;                // Cargo/infantry damage
<b class="nc">&nbsp;                r = new Report(6615);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                List&lt;Entity&gt; passengers = tank.getLoadedUnits();</b>
<b class="nc">&nbsp;                if (passengers.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    Entity target = passengers.get(Compute.randomInt(passengers.size()));</b>
<b class="nc">&nbsp;                    hit = target.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    reports.addAll(damageEntity(target, hit, damageCaused));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case Tank.CRIT_COMMANDER:
<b class="nc">&nbsp;                if (tank.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {</b>
<b class="nc">&nbsp;                    r = new Report(6191);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    reports.addAll(damageCrew(tank, 1));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT)</b>
<b class="nc">&nbsp;                        &amp;&amp; !tank.isCommanderHitPS()) {</b>
<b class="nc">&nbsp;                        r = new Report(6606);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.setCommanderHitPS(true);</b>
<b class="nc">&nbsp;                    } else if (tank.hasWorkingMisc(MiscType.F_COMMAND_CONSOLE)</b>
<b class="nc">&nbsp;                            &amp;&amp; !tank.isUsingConsoleCommander()) {</b>
<b class="nc">&nbsp;                        r = new Report(6607);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.setUsingConsoleCommander(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(6605);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.setCommanderHit(true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // fall through here, because effects of crew stunned also
&nbsp;                // apply
&nbsp;            case Tank.CRIT_CREW_STUNNED:
<b class="nc">&nbsp;                if (tank.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {</b>
<b class="nc">&nbsp;                    r = new Report(6191);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    reports.addAll(damageCrew(tank, 1));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT)</b>
<b class="nc">&nbsp;                            || tank.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)) {</b>
<b class="nc">&nbsp;                        r = new Report(6186);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        tank.stunCrew();</b>
<b class="nc">&nbsp;                        r = new Report(6185);</b>
<b class="nc">&nbsp;                        r.add(tank.getStunnedTurns() - 1);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_DRIVER:
<b class="nc">&nbsp;                if (tank.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {</b>
<b class="nc">&nbsp;                    r = new Report(6191);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    reports.addAll(damageCrew(tank, 1));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT)</b>
<b class="nc">&nbsp;                        &amp;&amp; !tank.isDriverHitPS()) {</b>
<b class="nc">&nbsp;                        r = new Report(6601);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.setDriverHitPS(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(6600);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.setDriverHit(true);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_CREW_KILLED:
<b class="nc">&nbsp;                if (tank.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                        || tank.hasAbility(OptionsConstants.MD_BVDNI)) {</b>
<b class="nc">&nbsp;                    r = new Report(6191);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    reports.addAll(damageCrew(tank, 1));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (tank.hasAbility(OptionsConstants.MD_PAIN_SHUNT) &amp;&amp; !tank.isCrewHitPS()) {</b>
<b class="nc">&nbsp;                        r = new Report(6191);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.setCrewHitPS(true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(6190);</b>
<b class="nc">&nbsp;                        r.subject = tank.getId();</b>
<b class="nc">&nbsp;                        reports.add(r);</b>
<b class="nc">&nbsp;                        tank.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;                        if (tank.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                            reports.addAll(crashVTOLorWiGE(tank));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            case Tank.CRIT_ENGINE:
<b class="nc">&nbsp;                r = new Report(6210);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.engineHit();</b>
<b class="nc">&nbsp;                tank.engineHitsThisPhase++;</b>
<b class="nc">&nbsp;                boolean engineExploded = checkEngineExplosion(tank, reports, 1);</b>
<b class="nc">&nbsp;                if (engineExploded) {</b>
<b class="nc">&nbsp;                    reports.addAll(destroyEntity(tank, &quot;engine destruction&quot;, true, true));</b>
<b class="nc">&nbsp;                    tank.setSelfDestructing(false);</b>
<b class="nc">&nbsp;                    tank.setSelfDestructInitiated(false);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (tank.isAirborneVTOLorWIGE()</b>
<b class="nc">&nbsp;                    &amp;&amp; !(tank.isDestroyed() || tank.isDoomed())) {</b>
<b class="nc">&nbsp;                    tank.immobilize();</b>
<b class="nc">&nbsp;                    reports.addAll(forceLandVTOLorWiGE(tank));</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Tank.CRIT_FUEL_TANK:
<b class="nc">&nbsp;                r = new Report(6215);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                reports.addAll(destroyEntity(tank, &quot;fuel explosion&quot;, false, false));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_SENSOR:
<b class="nc">&nbsp;                r = new Report(6620);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.setSensorHits(tank.getSensorHits() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_STABILIZER:
<b class="nc">&nbsp;                r = new Report(6625);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.setStabiliserHit(loc);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_TURRET_DESTROYED:
<b class="nc">&nbsp;                r = new Report(6630);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.destroyLocation(tank.getLocTurret());</b>
<b class="nc">&nbsp;                reports.addAll(destroyEntity(tank, &quot;turret blown off&quot;, true, true));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_TURRET_JAM:
<b class="nc">&nbsp;                if (tank.isTurretEverJammed(loc)) {</b>
<b class="nc">&nbsp;                    r = new Report(6640);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    tank.lockTurret(loc);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = new Report(6635);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.jamTurret(loc);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_TURRET_LOCK:
<b class="nc">&nbsp;                r = new Report(6640);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.lockTurret(loc);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Tank.CRIT_WEAPON_DESTROYED: {
<b class="nc">&nbsp;                r = new Report(6305);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                List&lt;Mounted&gt; weapons = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Mounted weapon : tank.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if ((weapon.getLocation() == loc) &amp;&amp; !weapon.isHit() &amp;&amp; !weapon.isDestroyed()) {</b>
<b class="nc">&nbsp;                        weapons.add(weapon);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // sort weapons by BV
<b class="nc">&nbsp;                weapons.sort(new WeaponComparatorBV());</b>
<b class="nc">&nbsp;                int roll = Compute.d6();</b>
&nbsp;                Mounted weapon;
<b class="nc">&nbsp;                if (roll &lt; 4) {</b>
&nbsp;                    // defender should choose, we&#39;ll just use the lowest BV
&nbsp;                    // weapon
<b class="nc">&nbsp;                    weapon = weapons.get(weapons.size() - 1);</b>
&nbsp;                } else {
&nbsp;                    // attacker chooses, we&#39;ll use the highest BV weapon
<b class="nc">&nbsp;                    weapon = weapons.get(0);</b>
&nbsp;                }
<b class="nc">&nbsp;                r.add(weapon.getName());</b>
<b class="nc">&nbsp;                reports.add(r);</b>
&nbsp;                // explosive weapons e.g. gauss now explode
<b class="nc">&nbsp;                if (weapon.getType().isExplosive(weapon) &amp;&amp; !weapon.isHit()</b>
<b class="nc">&nbsp;                       &amp;&amp; !weapon.isDestroyed()) {</b>
<b class="nc">&nbsp;                    reports.addAll(explodeEquipment(tank, loc, weapon));</b>
&nbsp;                }
<b class="nc">&nbsp;                weapon.setHit(true);</b>
&nbsp;                //Taharqa: We should also damage the critical slot, or
&nbsp;                //MM and MHQ won&#39;t remember that this weapon is damaged on the MUL
&nbsp;                //file
<b class="nc">&nbsp;                for (int i = 0; i &lt; tank.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                    CriticalSlot slot1 = tank.getCritical(loc, i);</b>
<b class="nc">&nbsp;                    if ((slot1 == null) || (slot1.getType() == CriticalSlot.TYPE_SYSTEM)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Mounted mounted = slot1.getMount();</b>
<b class="nc">&nbsp;                    if (mounted.equals(weapon)) {</b>
<b class="nc">&nbsp;                        tank.hitAllCriticals(loc, i);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            case Tank.CRIT_WEAPON_JAM: {
<b class="nc">&nbsp;                r = new Report(6645);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                ArrayList&lt;Mounted&gt; weapons = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Mounted weapon : tank.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if ((weapon.getLocation() == loc) &amp;&amp; !weapon.isJammed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !weapon.jammedThisPhase() &amp;&amp; !weapon.isHit()</b>
<b class="nc">&nbsp;                        &amp;&amp; !weapon.isDestroyed()) {</b>
<b class="nc">&nbsp;                        weapons.add(weapon);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (weapons.size() &gt; 0) {</b>
<b class="nc">&nbsp;                    Mounted weapon = weapons.get(Compute.randomInt(weapons.size()));</b>
<b class="nc">&nbsp;                    weapon.setJammed(true);</b>
<b class="nc">&nbsp;                    tank.addJammedWeapon(weapon);</b>
<b class="nc">&nbsp;                    r.add(weapon.getName());</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            }
&nbsp;            case VTOL.CRIT_PILOT:
<b class="nc">&nbsp;                r = new Report(6650);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.setDriverHit(true);</b>
<b class="nc">&nbsp;                PilotingRollData psr = tank.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                psr.addModifier(0, &quot;pilot injury&quot;);</b>
<b class="nc">&nbsp;                if (!doSkillCheckInPlace(tank, psr)) {</b>
<b class="nc">&nbsp;                    r = new Report(6675);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(tank);</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    boolean crash = true;</b>
<b class="nc">&nbsp;                    if (tank.canGoDown()) {</b>
<b class="nc">&nbsp;                        tank.setElevation(tank.getElevation() - 1);</b>
<b class="nc">&nbsp;                        crash = !tank.canGoDown();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (crash) {</b>
<b class="nc">&nbsp;                        reports.addAll(crashVTOLorWiGE(tank));</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case VTOL.CRIT_COPILOT:
<b class="nc">&nbsp;                r = new Report(6655);</b>
<b class="nc">&nbsp;                r.subject = tank.getId();</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                tank.setCommanderHit(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case VTOL.CRIT_ROTOR_DAMAGE: {
&nbsp;                // Only resolve rotor crits if the rotor was actually still
&nbsp;                // there.
<b class="nc">&nbsp;                if (!(tank.isLocationBad(VTOL.LOC_ROTOR) || tank.isLocationDoomed(VTOL.LOC_ROTOR))) {</b>
<b class="nc">&nbsp;                    r = new Report(6660);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    tank.setMotiveDamage(tank.getMotiveDamage() + 1);</b>
<b class="nc">&nbsp;                    if (tank.getMotiveDamage() &gt;= tank.getOriginalWalkMP()) {</b>
<b class="nc">&nbsp;                        tank.immobilize();</b>
<b class="nc">&nbsp;                        if (tank.isAirborneVTOLorWIGE()</b>
&nbsp;                            // Don&#39;t bother with forcing a landing if
&nbsp;                            // we&#39;re already otherwise destroyed.
<b class="nc">&nbsp;                            &amp;&amp; !(tank.isDestroyed() || tank.isDoomed())) {</b>
<b class="nc">&nbsp;                            reports.addAll(forceLandVTOLorWiGE(tank));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            }
&nbsp;            case VTOL.CRIT_ROTOR_DESTROYED:
&nbsp;                // Only resolve rotor crits if the rotor was actually still
&nbsp;                // there. Note that despite the name this critical hit does
&nbsp;                // not in itself physically destroy the rotor *location*
&nbsp;                // (which would simply kill the VTOL).
<b class="nc">&nbsp;                if (!(tank.isLocationBad(VTOL.LOC_ROTOR) || tank.isLocationDoomed(VTOL.LOC_ROTOR))) {</b>
<b class="nc">&nbsp;                    r = new Report(6670);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    tank.immobilize();</b>
<b class="nc">&nbsp;                    reports.addAll(crashVTOLorWiGE(tank, true));</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case VTOL.CRIT_FLIGHT_STABILIZER:
&nbsp;                // Only resolve rotor crits if the rotor was actually still
&nbsp;                // there.
<b class="nc">&nbsp;                if (!(tank.isLocationBad(VTOL.LOC_ROTOR) || tank.isLocationDoomed(VTOL.LOC_ROTOR))) {</b>
<b class="nc">&nbsp;                    r = new Report(6665);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    reports.add(r);</b>
<b class="nc">&nbsp;                    tank.setStabiliserHit(VTOL.LOC_ROTOR);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls and resolves critical hits with a die roll modifier.
&nbsp;     */
&nbsp;
&nbsp;    public Vector&lt;Report&gt; criticalEntity(Entity en, int loc, boolean isRear, int critMod, int damage) {
<b class="nc">&nbsp;        return criticalEntity(en, loc, isRear, critMod, true, false, damage);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls and resolves critical hits with a die roll modifier.
&nbsp;     */
&nbsp;
&nbsp;    public Vector&lt;Report&gt; criticalEntity(Entity en, int loc, boolean isRear, int critMod, int damage,
&nbsp;                                         boolean damagedByFire) {
<b class="nc">&nbsp;        return criticalEntity(en, loc, isRear, critMod, true, false, damage, damagedByFire);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls one critical hit
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; oneCriticalEntity(Entity en, int loc, boolean isRear, int damage) {
<b class="nc">&nbsp;        return criticalEntity(en, loc, isRear, 0, false, false, damage);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes any roll required when an AirMech lands and resolve any damage or
&nbsp;     * skidding resulting from a failed roll. Updates final position and elevation.
&nbsp;     *
&nbsp;     * @param lam       the landing LAM
&nbsp;     * @param pos       the &lt;code&gt;Coords&lt;/code&gt; of the landing hex
&nbsp;     * @param elevation the elevation from which the landing is attempted (usually 1, but may be higher
&nbsp;     *                          if the unit is forced to land due to insufficient movement
&nbsp;     * @param distance  the distance the unit moved in the turn prior to landing
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; landAirMech(LandAirMech lam, Coords pos, int elevation, int distance) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        lam.setPosition(pos);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            lam.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            lam.setElevation(0);</b>
&nbsp;        }
<b class="nc">&nbsp;        PilotingRollData psr = lam.checkAirMechLanding();</b>
<b class="nc">&nbsp;        if (psr.getValue() != TargetRoll.CHECK_FALSE</b>
<b class="nc">&nbsp;                &amp;&amp; (0 &gt; doSkillCheckWhileMoving(lam, elevation, pos, pos, psr, false))) {</b>
<b class="nc">&nbsp;            crashAirMech(lam, pos, elevation, distance, psr, vDesc);</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean crashAirMech(Entity en, PilotingRollData psr, Vector&lt;Report&gt; vDesc) {
<b class="nc">&nbsp;        return crashAirMech(en, en.getPosition(), en.getElevation(), en.delta_distance, psr, vDesc);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean crashAirMech(Entity en, Coords pos, int elevation, int distance,
&nbsp;                                 PilotingRollData psr, Vector&lt;Report&gt; vDesc) {
<b class="nc">&nbsp;        MoveStep step = new MoveStep(null, MoveStepType.DOWN);</b>
<b class="nc">&nbsp;        step.setFromEntity(en, game);</b>
<b class="nc">&nbsp;        return crashAirMech(en, pos, elevation, distance, psr, step, vDesc);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean crashAirMech(Entity en, Coords pos, int elevation, int distance,
&nbsp;                                 PilotingRollData psr, MoveStep lastStep, Vector&lt;Report&gt; vDesc) {
<b class="nc">&nbsp;        vDesc.addAll(doEntityFallsInto(en, elevation, pos, pos, psr, true, 0));</b>
<b class="nc">&nbsp;        return en.isDoomed()</b>
<b class="nc">&nbsp;                || processSkid(en, pos, 0, 0, distance, lastStep, en.moved, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes the landing roll required for a glider ProtoMech and resolves any damage
&nbsp;     * resulting from a failed roll. Updates final position and elevation.
&nbsp;     *
&nbsp;     * @param en    the landing glider ProtoMech
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; landGliderPM(Protomech en) {
<b class="nc">&nbsp;        return landGliderPM(en, en.getPosition(), en.getElevation(), en.delta_distance);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes the landing roll required for a glider ProtoMech and resolves any damage
&nbsp;     * resulting from a failed roll. Updates final position and elevation.
&nbsp;     *
&nbsp;     * @param en    the landing glider ProtoMech
&nbsp;     * @param pos   the &lt;code&gt;Coords&lt;/code&gt; of the landing hex
&nbsp;     * @param startElevation    the elevation from which the landing is attempted (usually 1, but may be higher
&nbsp;     *                          if the unit is forced to land due to insufficient movement
&nbsp;     * @param distance  the distance the unit moved in the turn prior to landing
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; landGliderPM(Protomech en, Coords pos, int startElevation,
&nbsp;                                        int distance) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        en.setPosition(pos);</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            en.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            en.setElevation(0);</b>
&nbsp;        }
<b class="nc">&nbsp;        PilotingRollData psr = en.checkGliderLanding();</b>
<b class="nc">&nbsp;        if ((psr.getValue() != TargetRoll.CHECK_FALSE)</b>
<b class="nc">&nbsp;                &amp;&amp; (0 &gt; doSkillCheckWhileMoving(en, startElevation, pos, pos, psr, false))) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; en.getNumberOfCriticals(Protomech.LOC_LEG); i++) {</b>
<b class="nc">&nbsp;                en.getCritical(Protomech.LOC_LEG, i).setHit(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            HitData hit = new HitData(Protomech.LOC_LEG);</b>
<b class="nc">&nbsp;            vDesc.addAll(damageEntity(en, hit, 2 * startElevation));</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves the forced landing of one airborne {@code VTOL} or {@code WiGE}
&nbsp;     * in its current hex. As this method is only for internal use and not part
&nbsp;     * of the exported public API, it simply relies on its client code to only
&nbsp;     * ever hand it a valid airborne vehicle and does not run any further checks
&nbsp;     * of its own.
&nbsp;     *
&nbsp;     * @param en The {@code VTOL} or {@code WiGE} in question.
&nbsp;     * @return The resulting {@code Vector} of {@code Report}s.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; forceLandVTOLorWiGE(Tank en) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        PilotingRollData psr = en.getBasePilotingRoll();</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(en.getPosition());</b>
<b class="nc">&nbsp;        if (en instanceof VTOL) {</b>
<b class="nc">&nbsp;            psr.addModifier(4, &quot;VTOL making forced landing&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            psr.addModifier(0, &quot;WiGE making forced landing&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        int elevation = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),</b>
<b class="nc">&nbsp;                                 hex.terrainLevel(Terrains.BRIDGE_ELEV));</b>
<b class="nc">&nbsp;        elevation = Math.max(elevation, 0);</b>
<b class="nc">&nbsp;        elevation = Math.min(elevation, en.getElevation());</b>
<b class="nc">&nbsp;        if (en.getElevation() &gt; elevation) {</b>
<b class="nc">&nbsp;            if (!hex.containsTerrain(Terrains.FUEL_TANK)</b>
<b class="nc">&nbsp;                    &amp;&amp; !hex.containsTerrain(Terrains.JUNGLE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !hex.containsTerrain(Terrains.MAGMA)</b>
<b class="nc">&nbsp;                    &amp;&amp; !hex.containsTerrain(Terrains.MUD)</b>
<b class="nc">&nbsp;                    &amp;&amp; !hex.containsTerrain(Terrains.RUBBLE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !hex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; !hex.containsTerrain(Terrains.WOODS)) {</b>
<b class="nc">&nbsp;                Report r = new Report(2180);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.addDesc(en);</b>
<b class="nc">&nbsp;                r.add(psr.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;
&nbsp;                // roll
<b class="nc">&nbsp;                final int diceRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                r = new Report(2185);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.add(psr.getValueAsString());</b>
<b class="nc">&nbsp;                r.add(psr.getDesc());</b>
<b class="nc">&nbsp;                r.add(diceRoll);</b>
<b class="nc">&nbsp;                if (diceRoll &lt; psr.getValue()) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    vDesc.addAll(crashVTOLorWiGE(en, true));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    en.setElevation(elevation);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                vDesc.addAll(crashVTOLorWiGE(en, true));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Crash a VTOL
&nbsp;     *
&nbsp;     * @param en the &lt;code&gt;VTOL&lt;/code&gt; to be crashed
&nbsp;     * @return the &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing phase reports
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; crashVTOLorWiGE(Tank en) {
<b class="nc">&nbsp;        return crashVTOLorWiGE(en, false, false, 0, en.getPosition(),</b>
<b class="nc">&nbsp;                               en.getElevation(), 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Crash a VTOL or WiGE.
&nbsp;     *
&nbsp;     * @param en              The {@code VTOL} or {@code WiGE} to crash.
&nbsp;     * @param rerollRotorHits Whether any rotor hits from the crash should be rerolled,
&nbsp;     *                        typically after a &quot;rotor destroyed&quot; critical hit.
&nbsp;     * @return The {@code Vector&lt;Report&gt;} of resulting reports.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; crashVTOLorWiGE(Tank en, boolean rerollRotorHits) {
<b class="nc">&nbsp;        return crashVTOLorWiGE(en, rerollRotorHits, false, 0, en.getPosition(),</b>
<b class="nc">&nbsp;                               en.getElevation(), 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Crash a VTOL or WiGE.
&nbsp;     *
&nbsp;     * @param en              The {@code VTOL} or {@code WiGE} to crash.
&nbsp;     * @param rerollRotorHits Whether any rotor hits from the crash should be rerolled,
&nbsp;     *                        typically after a &quot;rotor destroyed&quot; critical hit.
&nbsp;     * @param sideSlipCrash   A &lt;code&gt;boolean&lt;/code&gt; value indicating whether this is a
&nbsp;     *                        sideslip crash or not.
&nbsp;     * @param hexesMoved      The &lt;code&gt;int&lt;/code&gt; number of hexes moved.
&nbsp;     * @param crashPos        The &lt;code&gt;Coords&lt;/code&gt; of the crash
&nbsp;     * @param crashElevation  The &lt;code&gt;int&lt;/code&gt; elevation of the VTOL
&nbsp;     * @param impactSide      The &lt;code&gt;int&lt;/code&gt; describing the side on which the VTOL
&nbsp;     *                        falls
&nbsp;     * @return a &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; of Reports.
&nbsp;     */
&nbsp;
&nbsp;    private Vector&lt;Report&gt; crashVTOLorWiGE(Tank en, boolean rerollRotorHits,
&nbsp;                                           boolean sideSlipCrash, int hexesMoved, Coords crashPos,
&nbsp;                                           int crashElevation, int impactSide) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // we might be off the board after a DFA, so return then
<b class="nc">&nbsp;        if (!game.getBoard().contains(crashPos)) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!sideSlipCrash) {</b>
&nbsp;            // report lost movement and crashing
<b class="nc">&nbsp;            r = new Report(6260);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.addDesc(en);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            int newElevation = 0;</b>
<b class="nc">&nbsp;            IHex fallHex = game.getBoard().getHex(crashPos);</b>
&nbsp;
&nbsp;            // May land on roof of building or bridge
<b class="nc">&nbsp;            if (fallHex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                newElevation = fallHex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;            } else if (fallHex.containsTerrain(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;                newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;                if (newElevation &gt; crashElevation) {</b>
<b class="nc">&nbsp;                    newElevation = 0; // vtol was under bridge already</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int fall = crashElevation - newElevation;</b>
<b class="nc">&nbsp;            if (fall == 0) {</b>
&nbsp;                // already on ground, no harm done
<b class="nc">&nbsp;                r = new Report(6265);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;            // set elevation 1st to avoid multiple crashes
<b class="nc">&nbsp;            en.setElevation(newElevation);</b>
&nbsp;
&nbsp;            // plummets to ground
<b class="nc">&nbsp;            r = new Report(6270);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.add(fall);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
&nbsp;            // facing after fall
&nbsp;            String side;
&nbsp;            int table;
<b class="nc">&nbsp;            int facing = Compute.d6() - 1;</b>
<b class="nc">&nbsp;            switch (facing) {</b>
&nbsp;                case 1:
&nbsp;                case 2:
<b class="nc">&nbsp;                    side = &quot;right side&quot;;</b>
<b class="nc">&nbsp;                    table = ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    side = &quot;rear&quot;;</b>
<b class="nc">&nbsp;                    table = ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 4:
&nbsp;                case 5:
<b class="nc">&nbsp;                    side = &quot;left side&quot;;</b>
<b class="nc">&nbsp;                    table = ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 0:
&nbsp;                default:
<b class="nc">&nbsp;                    side = &quot;front&quot;;</b>
<b class="nc">&nbsp;                    table = ToHitData.SIDE_FRONT;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (newElevation &lt;= 0) {</b>
<b class="nc">&nbsp;                boolean waterFall = fallHex.containsTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;                if (waterFall &amp;&amp; fallHex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;                    int roll = Compute.d6(1);</b>
<b class="nc">&nbsp;                    r = new Report(2119);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(en);</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    if (roll &gt; 3) {</b>
<b class="nc">&nbsp;                        vDesc.addAll(resolveIceBroken(crashPos));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        waterFall = false; // saved by ice</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (waterFall) {</b>
&nbsp;                    // falls into water and is destroyed
<b class="nc">&nbsp;                    r = new Report(6275);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    vDesc.addAll(destroyEntity(en, &quot;Fell into water&quot;, false, false));</b>
&nbsp;                    // not sure, is this salvageable?
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // calculate damage for hitting the surface
<b class="nc">&nbsp;            int damage = (int) Math.round(en.getWeight() / 10.0) * (fall + 1);</b>
&nbsp;
&nbsp;            // adjust damage for gravity
<b class="nc">&nbsp;            damage = Math.round(damage * game.getPlanetaryConditions().getGravity());</b>
&nbsp;            // report falling
<b class="nc">&nbsp;            r = new Report(6280);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(en);</b>
<b class="nc">&nbsp;            r.add(side);</b>
<b class="nc">&nbsp;            r.add(damage);</b>
&nbsp;            //r.newlines = 0;
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;            en.setFacing((en.getFacing() + (facing)) % 6);</b>
&nbsp;
<b class="nc">&nbsp;            boolean exploded = false;</b>
&nbsp;
&nbsp;            // standard damage loop
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, table);</b>
<b class="nc">&nbsp;                if ((en instanceof VTOL) &amp;&amp; (hit.getLocation() == VTOL.LOC_ROTOR) &amp;&amp; rerollRotorHits) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                int[] isBefore = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),</b>
<b class="nc">&nbsp;                                  en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};</b>
<b class="nc">&nbsp;                vDesc.addAll(damageEntity(en, hit, cluster));</b>
<b class="nc">&nbsp;                int[] isAfter = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),</b>
<b class="nc">&nbsp;                                 en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};</b>
<b class="nc">&nbsp;                for (int x = 0; x &lt;= 3; x++) {</b>
<b class="nc">&nbsp;                    if (isBefore[x] != isAfter[x]) {</b>
<b class="nc">&nbsp;                        exploded = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                damage -= cluster;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (exploded) {</b>
<b class="nc">&nbsp;                r = new Report(6285);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.addDesc(en);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                vDesc.addAll(explodeVTOLorWiGE(en));</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for location exposure
<b class="nc">&nbsp;            vDesc.addAll(doSetLocationsExposure(en, fallHex, false, newElevation));</b>
&nbsp;
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            en.setElevation(0);// considered landed in the hex.</b>
&nbsp;            // crashes into ground thanks to sideslip
<b class="nc">&nbsp;            r = new Report(6290);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.addDesc(en);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            int damage = (int) Math.round(en.getWeight() / 10.0) * (hexesMoved + 1);</b>
<b class="nc">&nbsp;            boolean exploded = false;</b>
&nbsp;
&nbsp;            // standard damage loop
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, impactSide);</b>
<b class="nc">&nbsp;                hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                int[] isBefore = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),</b>
<b class="nc">&nbsp;                                  en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};</b>
<b class="nc">&nbsp;                vDesc.addAll(damageEntity(en, hit, cluster));</b>
<b class="nc">&nbsp;                int[] isAfter = {en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT),</b>
<b class="nc">&nbsp;                                 en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};</b>
<b class="nc">&nbsp;                for (int x = 0; x &lt;= 3; x++) {</b>
<b class="nc">&nbsp;                    if (isBefore[x] != isAfter[x]) {</b>
<b class="nc">&nbsp;                        exploded = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                damage -= cluster;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (exploded) {</b>
<b class="nc">&nbsp;                r = new Report(6295);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.addDesc(en);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                vDesc.addAll(explodeVTOLorWiGE(en));</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.containsMinefield(crashPos)) {</b>
&nbsp;            // may set off any minefields in the hex
<b class="nc">&nbsp;            enterMinefield(en, crashPos, 0, true, vDesc, 7);</b>
&nbsp;            // it may also clear any minefields that it detonated
<b class="nc">&nbsp;            clearDetonatedMines(crashPos, 5);</b>
<b class="nc">&nbsp;            resetMines();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Explode a VTOL
&nbsp;     *
&nbsp;     * @param en The &lt;code&gt;VTOL&lt;/code&gt; to explode.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of reports
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; explodeVTOLorWiGE(Tank en) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if(en.hasEngine() &amp;&amp; en.getEngine().isFusion()) {</b>
&nbsp;            // fusion engine, no effect
<b class="nc">&nbsp;            r = new Report(6300);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Coords pos = en.getPosition();</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                ignite(pos, Terrains.FIRE_LVL_NORMAL, vDesc);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ignite(pos, Terrains.FIRE_LVL_INFERNO, vDesc);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(en, &quot;crashed and burned&quot;, false, false));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * rolls and resolves one tank critical hit
&nbsp;     *
&nbsp;     * @param t       the &lt;code&gt;Tank&lt;/code&gt; to be critted
&nbsp;     * @param loc     the &lt;code&gt;int&lt;/code&gt; location of the Tank to be critted
&nbsp;     * @param critMod the &lt;code&gt;int&lt;/code&gt; modifier to the crit roll
&nbsp;     * @return a &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing the phase reports
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; criticalTank(Tank t, int loc, int critMod, int damage, boolean damagedByFire) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // roll the critical
<b class="nc">&nbsp;        r = new Report(6305);</b>
<b class="nc">&nbsp;        r.subject = t.getId();</b>
<b class="nc">&nbsp;        r.indent(3);</b>
<b class="nc">&nbsp;        r.add(t.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(6310);</b>
<b class="nc">&nbsp;        r.subject = t.getId();</b>
<b class="nc">&nbsp;        String rollString = &quot;&quot;;</b>
<b class="nc">&nbsp;        if (critMod != 0) {</b>
<b class="nc">&nbsp;            rollString = &quot;(&quot; + roll;</b>
<b class="nc">&nbsp;            if (critMod &gt; 0) {</b>
<b class="nc">&nbsp;                rollString += &quot;+&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            rollString += critMod + &quot;) = &quot;;</b>
<b class="nc">&nbsp;            roll += critMod;</b>
&nbsp;        }
<b class="nc">&nbsp;        rollString += roll;</b>
<b class="nc">&nbsp;        r.add(rollString);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
&nbsp;
&nbsp;        // now look up on vehicle crits table
<b class="nc">&nbsp;        int critType = t.getCriticalEffect(roll, loc, damagedByFire);</b>
<b class="nc">&nbsp;        if ((critType == Tank.CRIT_NONE)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_THRESHOLD)</b>
&nbsp;                &amp;&amp; !((t instanceof VTOL) || (t instanceof GunEmplacement))
<b class="nc">&nbsp;                &amp;&amp; !t.getOverThresh()) {</b>
<b class="nc">&nbsp;            r = new Report(6006);</b>
<b class="nc">&nbsp;            r.subject = t.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        vDesc.addAll(applyCriticalHit(t, loc, new CriticalSlot(0, critType),</b>
&nbsp;                                      true, damage, false));
<b class="nc">&nbsp;        if ((critType != Tank.CRIT_NONE) &amp;&amp; t.hasEngine() &amp;&amp; !t.getEngine().isFusion()</b>
<b class="nc">&nbsp;                &amp;&amp; t.hasQuirk(OptionsConstants.QUIRK_NEG_FRAGILE_FUEL) &amp;&amp; (Compute.d6(2) &gt; 9)) {</b>
&nbsp;            // BOOM!!
<b class="nc">&nbsp;            vDesc.addAll(applyCriticalHit(t, loc, new CriticalSlot(0,</b>
&nbsp;                    Tank.CRIT_FUEL_TANK), true, damage, false));
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for aero criticals
&nbsp;     *
&nbsp;     * @param vDesc         - report vector
&nbsp;     * @param a             - the entity being critted
&nbsp;     * @param hit           - the hitdata for the attack
&nbsp;     * @param damage_orig   - the original damage of the attack
&nbsp;     * @param critThresh    - did the attack go over the damage threshold
&nbsp;     * @param critSI        - did the attack damage SI
&nbsp;     * @param ammoExplosion - was the damage from an ammo explosion
&nbsp;     * @param nukeS2S       - was this a ship 2 ship nuke attack
&nbsp;     */
&nbsp;    private void checkAeroCrits(Vector&lt;Report&gt; vDesc, Aero a, HitData hit,
&nbsp;                                int damage_orig, boolean critThresh, boolean critSI,
&nbsp;                                boolean ammoExplosion, boolean nukeS2S) {
&nbsp;
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        boolean isCapital = hit.isCapital();</b>
&nbsp;        // get any capital missile critical mods
<b class="nc">&nbsp;        int capitalMissile = hit.getCapMisCritMod();</b>
&nbsp;
&nbsp;        // check for nuclear critical
<b class="nc">&nbsp;        if (nukeS2S) {</b>
&nbsp;            // add a control roll
<b class="nc">&nbsp;            PilotingRollData nukePSR = new PilotingRollData(a.getId(), 4,</b>
&nbsp;                    &quot;Nuclear attack&quot;, false);
<b class="nc">&nbsp;            game.addControlRoll(nukePSR);</b>
&nbsp;
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
&nbsp;            // need some kind of report
<b class="nc">&nbsp;            int nukeroll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(9145);</b>
<b class="nc">&nbsp;            r.subject = a.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.add(capitalMissile);</b>
<b class="nc">&nbsp;            r.add(nukeroll);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            if (nukeroll &gt;= capitalMissile) {</b>
&nbsp;                // Allow a reroll with edge
<b class="nc">&nbsp;                if (a.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_NUKE_CRIT)</b>
<b class="nc">&nbsp;                        &amp;&amp; a.getCrew().hasEdgeRemaining()) {</b>
<b class="nc">&nbsp;                    a.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                    r = new Report(9148);</b>
<b class="nc">&nbsp;                    r.subject = a.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(a.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                    // Reroll
<b class="nc">&nbsp;                    nukeroll = Compute.d6(2);</b>
&nbsp;                    // and report the new results
<b class="nc">&nbsp;                    r = new Report(9149);</b>
<b class="nc">&nbsp;                    r.subject = a.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(capitalMissile);</b>
<b class="nc">&nbsp;                    r.add(nukeroll);</b>
<b class="nc">&nbsp;                    r.choose(nukeroll &gt;= capitalMissile);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    if (nukeroll &lt; capitalMissile) {</b>
&nbsp;                        // We might be vaporized by the damage itself, but no additional effect
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                a.setSI(a.getSI() - (damage_orig * 10));</b>
<b class="nc">&nbsp;                a.damageThisPhase += (damage_orig * 10);</b>
<b class="nc">&nbsp;                r = new Report(9146);</b>
<b class="nc">&nbsp;                r.subject = a.getId();</b>
<b class="nc">&nbsp;                r.add((damage_orig * 10));</b>
<b class="nc">&nbsp;                r.indent(4);</b>
<b class="nc">&nbsp;                r.add(Math.max(a.getSI(), 0));</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                if (a.getSI() &lt;= 0) {</b>
&nbsp;                    //No auto-ejection chance here. Nuke would vaporize the pilot.
<b class="nc">&nbsp;                    vDesc.addAll(destroyEntity(a, &quot;Structural Integrity Collapse&quot;));</b>
<b class="nc">&nbsp;                    a.setSI(0);</b>
<b class="nc">&nbsp;                    if (hit.getAttackerId() != Entity.NONE) {</b>
<b class="nc">&nbsp;                        creditKill(a, game.getEntity(hit.getAttackerId()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (!critSI) {</b>
<b class="nc">&nbsp;                    critSI = true;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(9147);</b>
<b class="nc">&nbsp;                r.subject = a.getId();</b>
<b class="nc">&nbsp;                r.indent(4);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // apply crits
<b class="nc">&nbsp;        if (hit.rolledBoxCars()) {</b>
<b class="nc">&nbsp;            if (hit.isFirstHit()) {</b>
&nbsp;                // Allow edge use to ignore the critical roll
<b class="nc">&nbsp;                if (a.getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_AERO_LUCKY_CRIT)</b>
<b class="nc">&nbsp;                        &amp;&amp; a.getCrew().hasEdgeRemaining()) {</b>
<b class="nc">&nbsp;                    a.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                    r = new Report(9103);</b>
<b class="nc">&nbsp;                    r.subject = a.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(a.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                    // Skip the critical roll
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(), &quot;12 to hit&quot;,</b>
&nbsp;                        8, damage_orig, isCapital));
&nbsp;            } else { // Let the user know why the lucky crit doesn&#39;t apply
<b class="nc">&nbsp;                r = new Report(9102);</b>
<b class="nc">&nbsp;                r.subject = a.getId();</b>
<b class="nc">&nbsp;                r.indent(3);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // ammo explosions shouldn&#39;t affect threshold because they
&nbsp;        // go right to SI
<b class="nc">&nbsp;        if (critThresh &amp;&amp; !ammoExplosion) {</b>
<b class="nc">&nbsp;            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),</b>
&nbsp;                    &quot;Damage threshold exceeded&quot;, 8, damage_orig, isCapital));
&nbsp;        }
<b class="nc">&nbsp;        if (critSI &amp;&amp; !ammoExplosion) {</b>
<b class="nc">&nbsp;            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),</b>
&nbsp;                    &quot;SI damaged&quot;, 8, damage_orig, isCapital));
&nbsp;        }
<b class="nc">&nbsp;        if ((capitalMissile &gt; 0) &amp;&amp; !nukeS2S) {</b>
<b class="nc">&nbsp;            vDesc.addAll(criticalAero(a, hit.getLocation(), hit.glancingMod(),</b>
&nbsp;                    &quot;Capital Missile&quot;, capitalMissile, damage_orig, isCapital));
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Vector&lt;Report&gt; criticalAero(Aero a, int loc, int critMod,
&nbsp;            String reason, int target, int damage, boolean isCapital) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        //Telemissiles don&#39;t take critical hits
<b class="nc">&nbsp;        if (a instanceof TeleMissile) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // roll the critical
<b class="nc">&nbsp;        r = new Report(9100);</b>
<b class="nc">&nbsp;        r.subject = a.getId();</b>
<b class="nc">&nbsp;        r.add(reason);</b>
<b class="nc">&nbsp;        r.indent(3);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        r = new Report(9101);</b>
<b class="nc">&nbsp;        r.subject = a.getId();</b>
<b class="nc">&nbsp;        r.add(target);</b>
<b class="nc">&nbsp;        String rollString = &quot;&quot;;</b>
<b class="nc">&nbsp;        if (critMod != 0) {</b>
<b class="nc">&nbsp;            rollString = &quot;(&quot; + roll;</b>
<b class="nc">&nbsp;            if (critMod &gt; 0) {</b>
<b class="nc">&nbsp;                rollString += &quot;+&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            rollString += critMod + &quot;) = &quot;;</b>
<b class="nc">&nbsp;            roll += critMod;</b>
&nbsp;        }
<b class="nc">&nbsp;        rollString += roll;</b>
<b class="nc">&nbsp;        r.add(rollString);</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
&nbsp;
&nbsp;        // now look up on vehicle crits table
<b class="nc">&nbsp;        int critType = a.getCriticalEffect(roll, target);</b>
<b class="nc">&nbsp;        vDesc.addAll(applyCriticalHit(a, loc, new CriticalSlot(0, critType),</b>
&nbsp;                true, damage, isCapital));
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls and resolves critical hits on mechs or vehicles. if rollNumber is
&nbsp;     * false, a single hit is applied - needed for MaxTech Heat Scale rule.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; criticalEntity(Entity en, int loc, boolean isRear,
&nbsp;            int critMod, boolean rollNumber, boolean isCapital, int damage) {
<b class="nc">&nbsp;        return criticalEntity(en, loc, isRear, critMod, rollNumber, isCapital,</b>
&nbsp;                damage, false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls and resolves critical hits on mechs or vehicles. if rollNumber is
&nbsp;     * false, a single hit is applied - needed for MaxTech Heat Scale rule.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; criticalEntity(Entity en, int loc, boolean isRear,
&nbsp;            int critMod, boolean rollNumber, boolean isCapital, int damage,
&nbsp;            boolean damagedByFire) {
&nbsp;
<b class="nc">&nbsp;        if (en.hasQuirk(&quot;poor_work&quot;)) {</b>
<b class="nc">&nbsp;            critMod += 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (en.hasQuirk(OptionsConstants.QUIRK_NEG_PROTOTYPE)) {</b>
<b class="nc">&nbsp;            critMod += 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Apply modifiers for Anti-penetrative ablation armor
<b class="nc">&nbsp;        if ((en.getArmor(loc, isRear) &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; (en.getArmorType(loc) == EquipmentType.T_ARMOR_ANTI_PENETRATIVE_ABLATION)) {</b>
<b class="nc">&nbsp;            critMod -= 2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (en instanceof Tank) {</b>
<b class="nc">&nbsp;            return criticalTank((Tank) en, loc, critMod, damage, damagedByFire);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (en instanceof Aero) {</b>
<b class="nc">&nbsp;            return criticalAero((Aero) en, loc, critMod, &quot;unknown&quot;, 8, damage,</b>
&nbsp;                    isCapital);
&nbsp;        }
&nbsp;        CriticalSlot slot;
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        Coords coords = en.getPosition();</b>
<b class="nc">&nbsp;        IHex hex = null;</b>
&nbsp;        int hits;
<b class="nc">&nbsp;        if (rollNumber) {</b>
<b class="nc">&nbsp;            if (null != coords) {</b>
<b class="nc">&nbsp;                hex = game.getBoard().getHex(coords);</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report(6305);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.add(en.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            hits = 0;</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r = new Report(6310);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            String rollString = &quot;&quot;;</b>
&nbsp;            // industrials get a +2 bonus on the roll
<b class="nc">&nbsp;            if ((en instanceof Mech) &amp;&amp; ((Mech) en).isIndustrial()) {</b>
<b class="nc">&nbsp;                critMod += 2;</b>
&nbsp;            }
&nbsp;            // reinforced structure gets a -1 mod
<b class="nc">&nbsp;            if ((en instanceof Mech) &amp;&amp; ((Mech) en).hasReinforcedStructure()) {</b>
<b class="nc">&nbsp;                critMod -= 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (critMod != 0) {</b>
<b class="nc">&nbsp;                rollString = &quot;(&quot; + roll;</b>
<b class="nc">&nbsp;                if (critMod &gt; 0) {</b>
<b class="nc">&nbsp;                    rollString += &quot;+&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                rollString += critMod + &quot;) = &quot;;</b>
<b class="nc">&nbsp;                roll += critMod;</b>
&nbsp;            }
<b class="nc">&nbsp;            rollString += roll;</b>
<b class="nc">&nbsp;            r.add(rollString);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            boolean advancedCrit = game.getOptions().booleanOption(</b>
&nbsp;                    OptionsConstants.ADVCOMBAT_TACOPS_CRIT_ROLL);
<b class="nc">&nbsp;            if ((!advancedCrit &amp;&amp; (roll &lt;= 7)) || (advancedCrit &amp;&amp; (roll &lt;= 8))) {</b>
&nbsp;                // no effect
<b class="nc">&nbsp;                r = new Report(6005);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                return vDesc;</b>
<b class="nc">&nbsp;            } else if ((!advancedCrit &amp;&amp; (roll &gt;= 8) &amp;&amp; (roll &lt;= 9))</b>
&nbsp;                    || (advancedCrit &amp;&amp; (roll &gt;= 9) &amp;&amp; (roll &lt;= 10))) {
<b class="nc">&nbsp;                hits = 1;</b>
<b class="nc">&nbsp;                r = new Report(6315);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;            } else if ((!advancedCrit &amp;&amp; (roll &gt;= 10) &amp;&amp; (roll &lt;= 11))</b>
&nbsp;                    || (advancedCrit &amp;&amp; (roll &gt;= 11) &amp;&amp; (roll &lt;= 12))) {
<b class="nc">&nbsp;                hits = 2;</b>
<b class="nc">&nbsp;                r = new Report(6320);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;            } else if (advancedCrit &amp;&amp; (roll &gt;= 13) &amp;&amp; (roll &lt;= 14)) {</b>
<b class="nc">&nbsp;                hits = 3;</b>
<b class="nc">&nbsp;                r = new Report(6325);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;            } else if ((!advancedCrit &amp;&amp; (roll &gt;= 12)) || (advancedCrit &amp;&amp; (roll &gt;= 15))) {</b>
<b class="nc">&nbsp;                if (en instanceof Protomech) {</b>
<b class="nc">&nbsp;                    hits = 3;</b>
<b class="nc">&nbsp;                    r = new Report(6325);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                } else if (en.locationIsLeg(loc)) {</b>
<b class="nc">&nbsp;                    CriticalSlot cs = en.getCritical(loc, 0);</b>
<b class="nc">&nbsp;                    if ((cs != null) &amp;&amp; cs.isArmored()) {</b>
<b class="nc">&nbsp;                        r = new Report(6700);</b>
<b class="nc">&nbsp;                        r.subject = en.getId();</b>
<b class="nc">&nbsp;                        r.add(en.getLocationName(loc));</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                        cs.setArmored(false);</b>
<b class="nc">&nbsp;                        return vDesc;</b>
&nbsp;                    }
&nbsp;                    // limb blown off
<b class="nc">&nbsp;                    r = new Report(6120);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.add(en.getLocationName(loc));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    if (en.getInternal(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        en.destroyLocation(loc, true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (null != hex) {</b>
<b class="nc">&nbsp;                        if (!hex.containsTerrain(Terrains.LEGS)) {</b>
<b class="nc">&nbsp;                            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                    .createTerrain(Terrains.LEGS, 1));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                    .createTerrain(Terrains.LEGS,</b>
<b class="nc">&nbsp;                                            hex.terrainLevel(Terrains.LEGS) + 1));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    sendChangedHex(en.getPosition());</b>
<b class="nc">&nbsp;                    return vDesc;</b>
<b class="nc">&nbsp;                } else if ((loc == Mech.LOC_RARM) || (loc == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                    CriticalSlot cs = en.getCritical(loc, 0);</b>
<b class="nc">&nbsp;                    if ((cs != null) &amp;&amp; cs.isArmored()) {</b>
<b class="nc">&nbsp;                        r = new Report(6700);</b>
<b class="nc">&nbsp;                        r.subject = en.getId();</b>
<b class="nc">&nbsp;                        r.add(en.getLocationName(loc));</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                        cs.setArmored(false);</b>
<b class="nc">&nbsp;                        return vDesc;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // limb blown off
<b class="nc">&nbsp;                    r = new Report(6120);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.add(en.getLocationName(loc));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    en.destroyLocation(loc, true);</b>
<b class="nc">&nbsp;                    if (null != hex) {</b>
<b class="nc">&nbsp;                        if (!hex.containsTerrain(Terrains.ARMS)) {</b>
<b class="nc">&nbsp;                            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                    .createTerrain(Terrains.ARMS, 1));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                                    .createTerrain(Terrains.ARMS,</b>
<b class="nc">&nbsp;                                            hex.terrainLevel(Terrains.ARMS) + 1));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    sendChangedHex(en.getPosition());</b>
<b class="nc">&nbsp;                    return vDesc;</b>
<b class="nc">&nbsp;                } else if (loc == Mech.LOC_HEAD) {</b>
&nbsp;                    // head blown off
<b class="nc">&nbsp;                    r = new Report(6330);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.add(en.getLocationName(loc));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    en.destroyLocation(loc, true);</b>
<b class="nc">&nbsp;                    if (((Mech) en).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED) {</b>
&nbsp;                        // Don&#39;t kill a pilot multiple times.
<b class="nc">&nbsp;                        if (Crew.DEATH &gt; en.getCrew().getHits()) {</b>
<b class="nc">&nbsp;                            en.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;                            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                            vDesc.addAll(destroyEntity(en, &quot;pilot death&quot;, true));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    return vDesc;</b>
&nbsp;                } else {
&nbsp;                    // torso hit
<b class="nc">&nbsp;                    hits = 3;</b>
&nbsp;                    // industrials get 4 crits on a modified result of 14
<b class="nc">&nbsp;                    if ((roll &gt;= 14) &amp;&amp; (en instanceof Mech) &amp;&amp; ((Mech) en).isIndustrial()) {</b>
<b class="nc">&nbsp;                        hits = 4;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r = new Report(6325);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            hits = 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check if there is the potential for a reactive armor crit
&nbsp;        // Because reactive armor isn&#39;t hittable, the transfer check doesn&#39;t
&nbsp;        // consider it
<b class="nc">&nbsp;        boolean possibleReactiveCrit = (en.getArmor(loc) &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; (en.getArmorType(loc) == EquipmentType.T_ARMOR_REACTIVE);</b>
<b class="nc">&nbsp;        boolean locContainsReactiveArmor = false;</b>
<b class="nc">&nbsp;        for (int i = 0; (i &lt; en.getNumberOfCriticals(loc)) &amp;&amp; possibleReactiveCrit; i++) {</b>
<b class="nc">&nbsp;            CriticalSlot crit = en.getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((crit != null) &amp;&amp; (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (crit.getMount() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; crit.getMount().getType().hasFlag(MiscType.F_REACTIVE)) {</b>
<b class="nc">&nbsp;                locContainsReactiveArmor = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        possibleReactiveCrit &amp;= locContainsReactiveArmor;</b>
&nbsp;
&nbsp;        // transfer criticals, if needed
<b class="nc">&nbsp;        while ((en.canTransferCriticals(loc) &amp;&amp; !possibleReactiveCrit)</b>
<b class="nc">&nbsp;                &amp;&amp; (en.getTransferLocation(loc) != Entity.LOC_DESTROYED)</b>
<b class="nc">&nbsp;                &amp;&amp; (en.getTransferLocation(loc) != Entity.LOC_NONE)) {</b>
<b class="nc">&nbsp;            loc = en.getTransferLocation(loc);</b>
<b class="nc">&nbsp;            r = new Report(6335);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.add(en.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Roll critical hits in this location.
<b class="nc">&nbsp;        while (hits &gt; 0) {</b>
&nbsp;
&nbsp;            // Have we hit all available slots in this location?
<b class="nc">&nbsp;            if (en.getHittableCriticals(loc) &lt;= 0) {</b>
<b class="nc">&nbsp;                r = new Report(6340);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.indent(3);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Randomly pick a slot to be hit.
<b class="nc">&nbsp;            int slotIndex = Compute.randomInt(en.getNumberOfCriticals(loc));</b>
<b class="nc">&nbsp;            slot = en.getCritical(loc, slotIndex);</b>
&nbsp;
&nbsp;            // There are certain special cases, like reactive armor
&nbsp;            // some crits aren&#39;t normally hittable, except in certain cases
<b class="nc">&nbsp;            boolean reactiveArmorCrit = false;</b>
<b class="nc">&nbsp;            if ((slot != null) &amp;&amp; (slot.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (slot.getMount() != null)) {</b>
<b class="nc">&nbsp;                Mounted eq = slot.getMount();</b>
<b class="nc">&nbsp;                if (eq.getType().hasFlag(MiscType.F_REACTIVE) &amp;&amp; (en.getArmor(loc) &gt; 0)) {</b>
<b class="nc">&nbsp;                    reactiveArmorCrit = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Ignore empty or unhitable slots (this
&nbsp;            // includes all previously hit slots).
<b class="nc">&nbsp;            if ((slot != null) &amp;&amp; (slot.isHittable() || reactiveArmorCrit)) {</b>
&nbsp;
<b class="nc">&nbsp;                if (slot.isArmored()) {</b>
<b class="nc">&nbsp;                    r = new Report(6710);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    if (slot.getType() == CriticalSlot.TYPE_SYSTEM) {</b>
&nbsp;                        // Pretty sure that only &#39;mechs have system crits,
&nbsp;                        // but just in case....
<b class="nc">&nbsp;                        if (en instanceof Mech) {</b>
<b class="nc">&nbsp;                            r.add(((Mech) en).getSystemName(slot.getIndex()));</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // Shouldn&#39;t be null, but we&#39;ll be careful...
<b class="nc">&nbsp;                        if (slot.getMount() != null) {</b>
<b class="nc">&nbsp;                            r.add(slot.getMount().getName());</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    slot.setArmored(false);</b>
<b class="nc">&nbsp;                    hits--;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // if explosive use edge
<b class="nc">&nbsp;                if ((en instanceof Mech)</b>
<b class="nc">&nbsp;                        &amp;&amp; (en.getCrew().hasEdgeRemaining() &amp;&amp; en.getCrew().getOptions()</b>
<b class="nc">&nbsp;                                .booleanOption(OptionsConstants.EDGE_WHEN_EXPLOSION))</b>
<b class="nc">&nbsp;                        &amp;&amp; (slot.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                        &amp;&amp; slot.getMount().getType().isExplosive(slot.getMount())) {</b>
<b class="nc">&nbsp;                    en.getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                    r = new Report(6530);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    r.add(en.getCrew().getOptions().intOption(OptionsConstants.EDGE));</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // check for reactive armor exploding
<b class="nc">&nbsp;                if (reactiveArmorCrit) {</b>
<b class="nc">&nbsp;                    Mounted mount = slot.getMount();</b>
<b class="nc">&nbsp;                    if ((mount != null) &amp;&amp; mount.getType().hasFlag(MiscType.F_REACTIVE)) {</b>
<b class="nc">&nbsp;                        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                        r = new Report(6082);</b>
<b class="nc">&nbsp;                        r.subject = en.getId();</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        r.add(roll);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                        // big budda boom
<b class="nc">&nbsp;                        if (roll == 2) {</b>
<b class="nc">&nbsp;                            r = new Report(6083);</b>
<b class="nc">&nbsp;                            r.subject = en.getId();</b>
<b class="nc">&nbsp;                            r.indent(4);</b>
<b class="nc">&nbsp;                            vDesc.addElement(r);</b>
<b class="nc">&nbsp;                            Vector&lt;Report&gt; newReports = new Vector&lt;&gt;(damageEntity(en,</b>
<b class="nc">&nbsp;                                    new HitData(loc), en.getArmor(loc)));</b>
<b class="nc">&nbsp;                            if (en.hasRearArmor(loc)) {</b>
<b class="nc">&nbsp;                                newReports.addAll(damageEntity(en, new HitData(loc, true),</b>
<b class="nc">&nbsp;                                        en.getArmor(loc, true)));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            newReports.addAll(damageEntity(en, new HitData(loc), 1));</b>
<b class="nc">&nbsp;                            for (Report rep : newReports) {</b>
<b class="nc">&nbsp;                                rep.indent(4);</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            vDesc.addAll(newReports);</b>
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            // If only hittable crits are reactive,
&nbsp;                            // this crit is absorbed
<b class="nc">&nbsp;                            boolean allHittableCritsReactive = true;</b>
<b class="nc">&nbsp;                            for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                                CriticalSlot crit = en.getCritical(loc, i);</b>
<b class="nc">&nbsp;                                if (crit.isHittable()) {</b>
<b class="nc">&nbsp;                                    allHittableCritsReactive = false;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                                // We must have reactive crits to get to this
&nbsp;                                // point, so if nothing else is hittable, we
&nbsp;                                // must only have reactive crits
&nbsp;                            }
<b class="nc">&nbsp;                            if (allHittableCritsReactive) {</b>
<b class="nc">&nbsp;                                hits--;</b>
&nbsp;                            }
&nbsp;                            continue;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                vDesc.addAll(applyCriticalHit(en, loc, slot, true, damage, isCapital));</b>
<b class="nc">&nbsp;                hits--;</b>
&nbsp;            }
<b class="nc">&nbsp;        } // Hit another slot in this location.</b>
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for location breach and returns phase logging.
&nbsp;     * &lt;p/&gt;
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.
&nbsp;     * @param loc    the &lt;code&gt;int&lt;/code&gt; location on the entity that needs to be
&nbsp;     *               checked for a breach.
&nbsp;     * @param hex    the &lt;code&gt;IHex&lt;/code&gt; the entity occupies when checking. This
&nbsp;     *               value will be &lt;code&gt;null&lt;/code&gt; if the check is the result of
&nbsp;     *               an attack, and non-null if it occurs during movement.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; breachCheck(Entity entity, int loc, IHex hex) {
<b class="nc">&nbsp;        return breachCheck(entity, loc, hex, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for location breach and returns phase logging.
&nbsp;     * &lt;p/&gt;
&nbsp;     *
&nbsp;     * @param entity     the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.
&nbsp;     * @param loc        the &lt;code&gt;int&lt;/code&gt; location on the entity that needs to be
&nbsp;     *                   checked for a breach.
&nbsp;     * @param hex        the &lt;code&gt;IHex&lt;/code&gt; the entity occupies when checking. This
&nbsp;     *                   value will be &lt;code&gt;null&lt;/code&gt; if the check is the result of
&nbsp;     *                   an attack, and non-null if it occurs during movement.
&nbsp;     * @param underWater Is the breach check a result of an underwater attack?
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; breachCheck(Entity entity, int loc, IHex hex, boolean underWater) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // Infantry do not suffer breaches, nor do Telemissiles
&nbsp;        // VTOLs can&#39;t operate in vacuum or underwater, so no breaches
<b class="nc">&nbsp;        if (entity instanceof Infantry || entity instanceof TeleMissile || entity instanceof VTOL) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean dumping = false;</b>
<b class="nc">&nbsp;        for (Mounted m : entity.getAmmo()) {</b>
<b class="nc">&nbsp;            if (m.isDumping()) {</b>
&nbsp;                // dumping ammo underwater is very stupid thing to do
<b class="nc">&nbsp;                dumping = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // This handles both water and vacuum breaches.
&nbsp;        // Also need to account for hull breaches on surface naval vessels which
&nbsp;        // are technically not &quot;wet&quot;
<b class="nc">&nbsp;        if ((entity.getLocationStatus(loc) &gt; ILocationExposureStatus.NORMAL)</b>
<b class="nc">&nbsp;                || (entity.isSurfaceNaval() &amp;&amp; (loc != ((Tank) entity).getLocTurret()))) {</b>
&nbsp;            // Does the location have armor (check rear armor on Mek)
&nbsp;            // and is the check due to damage?
<b class="nc">&nbsp;            int breachroll = 0;</b>
&nbsp;            // set the target roll for the breach
<b class="nc">&nbsp;            int target = 10;</b>
&nbsp;            // if this is a vacuum check and we are in trace atmosphere then
&nbsp;            // adjust target
<b class="nc">&nbsp;            if ((entity.getLocationStatus(loc) == ILocationExposureStatus.VACUUM)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_TRACE)) {</b>
<b class="nc">&nbsp;                target = 12;</b>
&nbsp;            }
&nbsp;            // if this is a surface naval vessel and the attack is not from
&nbsp;            // underwater
&nbsp;            // then the breach should only occur on a roll of 12
<b class="nc">&nbsp;            if (entity.isSurfaceNaval() &amp;&amp; !underWater) {</b>
<b class="nc">&nbsp;                target = 12;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity.getArmor(loc) &gt; 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (!(entity instanceof Mech) || entity.getArmor(loc, true) &gt; 0) &amp;&amp; (null == hex)) {</b>
&nbsp;                // functional HarJel prevents breach
<b class="nc">&nbsp;                if (entity.hasHarJelIn(loc)) {</b>
<b class="nc">&nbsp;                    r = new Report(6342);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    return vDesc;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((entity instanceof Mech) &amp;&amp; (((Mech) entity).hasHarJelIIIn(loc)</b>
<b class="nc">&nbsp;                        || ((Mech) entity).hasHarJelIIIIn(loc))) {</b>
<b class="nc">&nbsp;                    r = new Report(6343);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    target -= 2;</b>
&nbsp;                }
&nbsp;                // Impact-resistant armor easier to breach
<b class="nc">&nbsp;                if ((entity.getArmorType(loc) == EquipmentType.T_ARMOR_IMPACT_RESISTANT)) {</b>
<b class="nc">&nbsp;                    r = new Report(6344);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    target += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                breachroll = Compute.d6(2);</b>
<b class="nc">&nbsp;                r = new Report(6345);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent(3);</b>
<b class="nc">&nbsp;                r.add(entity.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;                r.add(breachroll);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                if (breachroll &gt;= target) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;            // Breach by damage or lack of armor.
<b class="nc">&nbsp;            if ((breachroll &gt;= target) || !(entity.getArmor(loc) &gt; 0)</b>
&nbsp;                    || (dumping &amp;&amp; (!(entity instanceof Mech)
&nbsp;                        || (loc == Mech.LOC_CT) || (loc == Mech.LOC_RT) || (loc == Mech.LOC_LT)))
<b class="nc">&nbsp;                    || !(!(entity instanceof Mech) || entity.getArmor(loc, true) &gt; 0)) {</b>
&nbsp;                // Functional HarJel prevents breach as long as armor remains
&nbsp;                // (and, presumably, as long as you don&#39;t open your chassis on
&nbsp;                // purpose, say to dump ammo...).
<b class="nc">&nbsp;                if ((entity.hasHarJelIn(loc)) &amp;&amp; (entity.getArmor(loc) &gt; 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (!(entity instanceof Mech) || entity.getArmor(loc, true) &gt; 0) &amp;&amp; !dumping) {</b>
<b class="nc">&nbsp;                    r = new Report(6342);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    return vDesc;</b>
&nbsp;                }
<b class="nc">&nbsp;                vDesc.addAll(breachLocation(entity, loc, hex, false));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks all equipment in a location on an entity as useless.
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.
&nbsp;     * @param loc    the &lt;code&gt;int&lt;/code&gt; location on the entity that needs to be
&nbsp;     *               checked for a breach.
&nbsp;     * @param hex    the &lt;code&gt;IHex&lt;/code&gt; the entity occupies when checking. This
&nbsp;     *               value will be &lt;code&gt;null&lt;/code&gt; if the check is the result of
&nbsp;     *               an attack, and non-null if it occurs during movement.
&nbsp;     * @param harJel a &lt;code&gt;boolean&lt;/code&gt; value indicating if the uselessness is
&nbsp;     *               the cause of a critically hit HarJel system
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; breachLocation(Entity entity, int loc, IHex hex, boolean harJel) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if ((entity.getInternal(loc) &lt; 0)</b>
<b class="nc">&nbsp;                || (entity.getLocationStatus(loc) &lt; ILocationExposureStatus.NORMAL)) {</b>
&nbsp;            // already destroyed or breached? don&#39;t bother
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(6350);</b>
<b class="nc">&nbsp;        if (harJel) {</b>
<b class="nc">&nbsp;            r.messageId = 6351;</b>
&nbsp;        }
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(entity.getShortName());</b>
<b class="nc">&nbsp;        r.add(entity.getLocationAbbr(loc));</b>
<b class="nc">&nbsp;        vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(entity, &quot;hull breach&quot;, true, true));</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            Mech mech = (Mech) entity;</b>
&nbsp;            // equipment and crits will be marked in applyDamage?
&nbsp;
&nbsp;            // equipment marked missing
<b class="nc">&nbsp;            for (Mounted mounted : entity.getEquipment()) {</b>
<b class="nc">&nbsp;                if (mounted.getLocation() == loc) {</b>
<b class="nc">&nbsp;                    mounted.setBreached(true);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // all critical slots set as useless
<b class="nc">&nbsp;            for (int i = 0; i &lt; entity.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;                final CriticalSlot cs = entity.getCritical(loc, i);</b>
<b class="nc">&nbsp;                if (cs != null) {</b>
&nbsp;                    // for every undamaged actuator destroyed by breaching,
&nbsp;                    // we make a PSR (see bug 1040858)
<b class="nc">&nbsp;                    if (entity.locationIsLeg(loc) &amp;&amp; entity.canFall(true)) {</b>
<b class="nc">&nbsp;                        if (cs.isHittable()) {</b>
<b class="nc">&nbsp;                            switch (cs.getIndex()) {</b>
&nbsp;                                case Mech.ACTUATOR_UPPER_LEG:
&nbsp;                                case Mech.ACTUATOR_LOWER_LEG:
&nbsp;                                case Mech.ACTUATOR_FOOT:
&nbsp;                                    // leg/foot actuator piloting roll
<b class="nc">&nbsp;                                    game.addPSR(new PilotingRollData(entity.getId(), 1,</b>
&nbsp;                                            &quot;leg/foot actuator hit&quot;));
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case Mech.ACTUATOR_HIP:
&nbsp;                                    // hip piloting roll at +0, because we get the +2 anyway
&nbsp;                                    // because the location is breached.
&nbsp;                                    // The phase report will look a bit weird, but the
&nbsp;                                    // roll is correct
<b class="nc">&nbsp;                                    game.addPSR(new PilotingRollData(entity.getId(), 0,</b>
&nbsp;                                            &quot;hip actuator hit&quot;));
&nbsp;                                    break;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    cs.setBreached(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Check location for engine/cockpit breach and report accordingly
<b class="nc">&nbsp;            if (loc == Mech.LOC_CT) {</b>
<b class="nc">&nbsp;                vDesc.addAll(destroyEntity(entity, &quot;hull breach&quot;));</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(abandonEntity(entity));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (loc == Mech.LOC_HEAD) {</b>
<b class="nc">&nbsp;                entity.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;                vDesc.addAll(destroyEntity(entity, &quot;hull breach&quot;));</b>
<b class="nc">&nbsp;                if (entity.getLocationStatus(loc) == ILocationExposureStatus.WET) {</b>
<b class="nc">&nbsp;                    r = new Report(6355);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(6360);</b>
&nbsp;                }
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Set the status of the location.
&nbsp;            // N.B. if we set the status before rolling water PSRs, we get a
&nbsp;            // &quot;LEG DESTROYED&quot; modifier; setting the status after gives a hip
&nbsp;            // actuator modifier.
<b class="nc">&nbsp;            entity.setLocationStatus(loc, ILocationExposureStatus.BREACHED);</b>
&nbsp;
&nbsp;            // Did the hull breach destroy the engine?
<b class="nc">&nbsp;            int hitsToDestroy = 3;</b>
<b class="nc">&nbsp;            if (mech.isSuperHeavy() &amp;&amp; mech.hasEngine()</b>
<b class="nc">&nbsp;                    &amp;&amp; (mech.getEngine().getEngineType() == Engine.COMPACT_ENGINE)) {</b>
<b class="nc">&nbsp;                hitsToDestroy = 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT)</b>
<b class="nc">&nbsp;                    + entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT)</b>
<b class="nc">&nbsp;                    + entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT))</b>
&nbsp;                    &gt;= hitsToDestroy) {
<b class="nc">&nbsp;                vDesc.addAll(destroyEntity(entity, &quot;engine destruction&quot;));</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_AUTO_ABANDON_UNIT)) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(abandonEntity(entity));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (loc == Mech.LOC_LT) {</b>
<b class="nc">&nbsp;                vDesc.addAll(breachLocation(entity, Mech.LOC_LARM, hex, false));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (loc == Mech.LOC_RT) {</b>
<b class="nc">&nbsp;                vDesc.addAll(breachLocation(entity, Mech.LOC_RARM, hex, false));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Mark the unit as destroyed! Units transported in the destroyed unit will
&nbsp;     * get a chance to escape.
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.
&nbsp;     * @param reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity was
&nbsp;     *               destroyed.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects that can be
&nbsp;     * sent to the output log.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; destroyEntity(Entity entity, String reason) {
<b class="nc">&nbsp;        return destroyEntity(entity, reason, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks a unit as destroyed! Units transported inside the destroyed unit
&nbsp;     * will get a chance to escape unless the destruction was not survivable.
&nbsp;     *
&nbsp;     * @param entity     - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.
&nbsp;     * @param reason     - a &lt;code&gt;String&lt;/code&gt; detailing why the entity was
&nbsp;     *                   destroyed.
&nbsp;     * @param survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the destruction as
&nbsp;     *                   unsurvivable for transported units.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects that can be
&nbsp;     * sent to the output log.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; destroyEntity(Entity entity, String reason, boolean survivable) {
&nbsp;        // Generally, the entity can still be salvaged.
<b class="nc">&nbsp;        return destroyEntity(entity, reason, survivable, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks a unit as destroyed! Units transported inside the destroyed unit
&nbsp;     * will get a chance to escape unless the destruction was not survivable.
&nbsp;     *
&nbsp;     * @param entity     - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.
&nbsp;     * @param reason     - a &lt;code&gt;String&lt;/code&gt; detailing why the entity was
&nbsp;     *                   destroyed.
&nbsp;     * @param survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the destruction as
&nbsp;     *                   unsurvivable for transported units.
&nbsp;     * @param canSalvage - a &lt;code&gt;boolean&lt;/code&gt; that indicates if the unit can be
&nbsp;     *                   salvaged (or cannibalized for spare parts). If
&nbsp;     *                   &lt;code&gt;true&lt;/code&gt;, salvage operations are possible, if
&nbsp;     *                   &lt;code&gt;false&lt;/code&gt;, the unit is too badly damaged.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects that can be
&nbsp;     * sent to the output log.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; destroyEntity(Entity entity, String reason, boolean survivable,
&nbsp;                                         boolean canSalvage) {
&nbsp;        // can&#39;t destroy an entity if it&#39;s already been destroyed        
<b class="nc">&nbsp;        if(entity.isDestroyed()) {</b>
<b class="nc">&nbsp;            return new Vector&lt;Report&gt;();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;        
&nbsp;        //We&#39;ll need this later...
<b class="nc">&nbsp;        Aero ship = null;</b>
<b class="nc">&nbsp;        if (entity.isLargeCraft()) {</b>
<b class="nc">&nbsp;            ship = (Aero) entity;</b>
&nbsp;        }
&nbsp;
&nbsp;        // regardless of what was passed in, units loaded onto aeros not on the
&nbsp;        // ground are destroyed
<b class="nc">&nbsp;        if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;            survivable = false;</b>
<b class="nc">&nbsp;        } else if (entity.isAero()) {</b>
<b class="nc">&nbsp;            survivable = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The unit can suffer an ammo explosion after it has been destroyed.
<b class="nc">&nbsp;        int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;</b>
<b class="nc">&nbsp;        if (!canSalvage) {</b>
<b class="nc">&nbsp;            entity.setSalvage(false);</b>
<b class="nc">&nbsp;            condition = IEntityRemovalConditions.REMOVE_DEVASTATED;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Destroy the entity, unless it&#39;s already destroyed.
<b class="nc">&nbsp;        if (!entity.isDoomed() &amp;&amp; !entity.isDestroyed()) {</b>
<b class="nc">&nbsp;            r = new Report(6365);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(reason);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;            entity.setDoomed(true);</b>
&nbsp;
&nbsp;            // Kill any picked up MechWarriors
<b class="nc">&nbsp;            Enumeration&lt;Integer&gt; iter = entity.getPickedUpMechWarriors().elements();</b>
<b class="nc">&nbsp;            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                int mechWarriorId = iter.nextElement();</b>
<b class="nc">&nbsp;                Entity mw = game.getEntity(mechWarriorId);</b>
&nbsp;
&nbsp;                // in some situations, a &quot;picked up&quot; mechwarrior won&#39;t actually exist
&nbsp;                // probably this is brought about by picking up a mechwarrior in a previous MekHQ scenario
&nbsp;                // then having the same unit get blown up in a subsequent scenario
&nbsp;                // in that case, we simply move on
<b class="nc">&nbsp;                if(mw == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                mw.setDestroyed(true);</b>
&nbsp;                // We can safely remove these, as they can&#39;t be targeted
<b class="nc">&nbsp;                game.removeEntity(mw.getId(), condition);</b>
<b class="nc">&nbsp;                entityUpdate(mw.getId());</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(mw.getId(), condition));</b>
<b class="nc">&nbsp;                r = new Report(6370);</b>
<b class="nc">&nbsp;                r.subject = mw.getId();</b>
<b class="nc">&nbsp;                r.addDesc(mw);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // make any remaining telemissiles operated by this entity
&nbsp;            // out of contact
<b class="nc">&nbsp;            for (int missileId : entity.getTMTracker().getMissiles()) {</b>
<b class="nc">&nbsp;                Entity tm = game.getEntity(missileId);</b>
<b class="nc">&nbsp;                if ((null != tm) &amp;&amp; !tm.isDestroyed() &amp;&amp; (tm instanceof TeleMissile)) {</b>
<b class="nc">&nbsp;                    ((TeleMissile) tm).setOutContact(true);</b>
<b class="nc">&nbsp;                    entityUpdate(tm.getId());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Mechanized BA that could die on a 3+
<b class="nc">&nbsp;            ArrayList&lt;Entity&gt; externalUnits = entity.getExternalUnits();</b>
&nbsp;
&nbsp;            // Handle escape of transported units.
<b class="nc">&nbsp;            if (entity.getLoadedUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;                Coords curPos = entity.getPosition();</b>
<b class="nc">&nbsp;                int curFacing = entity.getFacing();</b>
<b class="nc">&nbsp;                for (Entity other : entity.getLoadedUnits()) {</b>
&nbsp;                    //If the unit has been destroyed (as from a cargo hit), skip it
<b class="nc">&nbsp;                    if (other.isDestroyed()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Can the other unit survive?
<b class="nc">&nbsp;                    boolean survived = false;</b>
<b class="nc">&nbsp;                    if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                        if ((entity.getMovementMode() == EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                                || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)) {</b>
<b class="nc">&nbsp;                            if (other.getMovementMode() == EntityMovementMode.INF_UMU) {</b>
<b class="nc">&nbsp;                                survived = Compute.d6() &lt;= 3;</b>
<b class="nc">&nbsp;                            } else if (other.getMovementMode() == EntityMovementMode.INF_JUMP) {</b>
<b class="nc">&nbsp;                                survived = Compute.d6() == 1;</b>
<b class="nc">&nbsp;                            } else if (other.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;                                survived = Compute.d6() &lt;= 2;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } else if (entity.getMovementMode() == EntityMovementMode.SUBMARINE) {</b>
<b class="nc">&nbsp;                            if (other.getMovementMode() == EntityMovementMode.INF_UMU) {</b>
<b class="nc">&nbsp;                                survived = Compute.d6() == 1;</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            survived = Compute.d6() &lt;= 4;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (entity instanceof Mech) {</b>
&nbsp;                        // mechanized BA can escape on a roll of 1 or 2
<b class="nc">&nbsp;                        if (externalUnits.contains(other)) {</b>
<b class="nc">&nbsp;                            survived = Compute.d6() &lt; 3;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (!survivable || (externalUnits.contains(other) &amp;&amp; !survived)</b>
&nbsp;                            //Don&#39;t unload from ejecting spacecraft. The crews aren&#39;t in their units...
<b class="nc">&nbsp;                            || (ship != null &amp;&amp; ship.isEjecting())) {</b>
&nbsp;                        // Nope.
<b class="nc">&nbsp;                        other.setDestroyed(true);</b>
&nbsp;                        // We need to unload the unit, since it&#39;s ID goes away
<b class="nc">&nbsp;                        entity.unload(other);</b>
&nbsp;                        // Safe to remove, as they aren&#39;t targeted
<b class="nc">&nbsp;                        game.moveToGraveyard(other.getId());</b>
<b class="nc">&nbsp;                        send(createRemoveEntityPacket(other.getId(), condition));</b>
<b class="nc">&nbsp;                        r = new Report(6370);</b>
<b class="nc">&nbsp;                        r.subject = other.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(other);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                    }
&nbsp;                    // Can we unload the unit to the current hex?
&nbsp;                    // TODO : unloading into stacking violation is not
&nbsp;                    // explicitly prohibited in the BMRr.
<b class="nc">&nbsp;                    else if ((null != Compute.stackingViolation(game, other.getId(), curPos))</b>
<b class="nc">&nbsp;                             || other.isLocationProhibited(curPos)) {</b>
&nbsp;                        // Nope.
<b class="nc">&nbsp;                        other.setDestroyed(true);</b>
&nbsp;                        // We need to unload the unit, since it&#39;s ID goes away
<b class="nc">&nbsp;                        entity.unload(other);</b>
&nbsp;                        // Safe to remove, as they aren&#39;t targeted
<b class="nc">&nbsp;                        game.moveToGraveyard(other.getId());</b>
<b class="nc">&nbsp;                        send(createRemoveEntityPacket(other.getId(), condition));</b>
<b class="nc">&nbsp;                        r = new Report(6375);</b>
<b class="nc">&nbsp;                        r.subject = other.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(other);</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                    } // End can-not-unload
&nbsp;                    else {
&nbsp;                        // The other unit survives.
<b class="nc">&nbsp;                        unloadUnit(entity, other, curPos, curFacing,</b>
<b class="nc">&nbsp;                                   entity.getElevation(), true, false);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                } // Handle the next transported unit.</b>
&nbsp;
&nbsp;            } // End has-transported-unit
&nbsp;
&nbsp;            // Handle transporting unit.
<b class="nc">&nbsp;            if (Entity.NONE != entity.getTransportId()) {</b>
<b class="nc">&nbsp;                final Entity transport = game.getEntity(entity.getTransportId());</b>
<b class="nc">&nbsp;                Coords curPos = transport.getPosition();</b>
<b class="nc">&nbsp;                int curFacing = transport.getFacing();</b>
<b class="nc">&nbsp;                if (!transport.isLargeCraft()) {</b>
<b class="nc">&nbsp;                    unloadUnit(transport, entity, curPos, curFacing, transport.getElevation());</b>
&nbsp;                }
<b class="nc">&nbsp;                entityUpdate(transport.getId());</b>
&nbsp;
&nbsp;                // if this is the last fighter in a fighter squadron then remove
&nbsp;                // the squadron
<b class="nc">&nbsp;                if ((transport instanceof FighterSquadron)</b>
<b class="nc">&nbsp;                        &amp;&amp; transport.getSubEntities().orElse(Collections.emptyList()).isEmpty()) {</b>
<b class="nc">&nbsp;                    transport.setDestroyed(true);</b>
&nbsp;                    // Can&#39;t remove this here, otherwise later attacks will fail
&nbsp;                    //game.moveToGraveyard(transport.getId());
&nbsp;                    //entityUpdate(transport.getId());
&nbsp;                    //send(createRemoveEntityPacket(transport.getId(), condition));
<b class="nc">&nbsp;                    r = new Report(6365);</b>
<b class="nc">&nbsp;                    r.subject = transport.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(transport);</b>
<b class="nc">&nbsp;                    r.add(&quot;fighter destruction&quot;);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;
&nbsp;            } // End unit-is-transported
&nbsp;
&nbsp;            // Is this unit towing some trailers?
&nbsp;            // If so, disconnect them
<b class="nc">&nbsp;            if (!entity.getAllTowedUnits().isEmpty()) {</b>
&nbsp;                //Find the first trailer in the list and drop it
&nbsp;                //this will disconnect all that follow too
<b class="nc">&nbsp;                Entity leadTrailer = game.getEntity(entity.getAllTowedUnits().get(0));</b>
<b class="nc">&nbsp;                disconnectUnit(entity, leadTrailer, entity.getPosition());</b>
&nbsp;            }
&nbsp;
&nbsp;            // Is this unit a trailer being towed? If so, disconnect it from its tractor
<b class="nc">&nbsp;            if (entity.getTractor() != Entity.NONE) {</b>
<b class="nc">&nbsp;                Entity tractor = game.getEntity(entity.getTractor());</b>
<b class="nc">&nbsp;                disconnectUnit(tractor, entity, tractor.getPosition());</b>
&nbsp;            }
&nbsp;
&nbsp;            // Is this unit being swarmed?
<b class="nc">&nbsp;            final int swarmerId = entity.getSwarmAttackerId();</b>
<b class="nc">&nbsp;            if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;                final Entity swarmer = game.getEntity(swarmerId);</b>
&nbsp;
<b class="nc">&nbsp;                swarmer.setSwarmTargetId(Entity.NONE);</b>
&nbsp;                // a unit that stopped swarming due to the swarmed unit dieing
&nbsp;                // should be able to move: setSwarmTargetId to Entity.None
&nbsp;                // changes done to true and unloaded to true, need to undo this
<b class="nc">&nbsp;                swarmer.setUnloaded(false);</b>
<b class="nc">&nbsp;                swarmer.setDone(false);</b>
<b class="nc">&nbsp;                entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                r = new Report(6380);</b>
<b class="nc">&nbsp;                r.subject = swarmerId;</b>
<b class="nc">&nbsp;                r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;                // Swarming infantry shouldn&#39;t take damage when their target dies
&nbsp;                // http://bg.battletech.com/forums/total-warfare/swarming-question
<b class="nc">&nbsp;                entityUpdate(swarmerId);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Is this unit swarming somebody?
<b class="nc">&nbsp;            final int swarmedId = entity.getSwarmTargetId();</b>
<b class="nc">&nbsp;            if (Entity.NONE != swarmedId) {</b>
<b class="nc">&nbsp;                final Entity swarmed = game.getEntity(swarmedId);</b>
<b class="nc">&nbsp;                swarmed.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;                entity.setSwarmTargetId(Entity.NONE);</b>
<b class="nc">&nbsp;                r = new Report(6385);</b>
<b class="nc">&nbsp;                r.subject = swarmed.getId();</b>
<b class="nc">&nbsp;                r.addDesc(swarmed);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                entityUpdate(swarmedId);</b>
&nbsp;            }
&nbsp;
&nbsp;            // If in a grapple, release both mechs
<b class="nc">&nbsp;            if (entity.getGrappled() != Entity.NONE) {</b>
<b class="nc">&nbsp;                int grappler = entity.getGrappled();</b>
<b class="nc">&nbsp;                entity.setGrappled(Entity.NONE, false);</b>
<b class="nc">&nbsp;                Entity e = game.getEntity(grappler);</b>
<b class="nc">&nbsp;                if (e != null) {</b>
<b class="nc">&nbsp;                    e.setGrappled(Entity.NONE, false);</b>
&nbsp;                }
<b class="nc">&nbsp;                entityUpdate(grappler);</b>
&nbsp;            }
&nbsp;        } // End entity-not-already-destroyed.
&nbsp;
&nbsp;        // if using battlefield wreckage rules, then the destruction of this
&nbsp;        // unit
&nbsp;        // might convert the hex to rough
<b class="nc">&nbsp;        Coords curPos = entity.getPosition();</b>
<b class="nc">&nbsp;        IHex entityHex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_BATTLE_WRECK)</b>
<b class="nc">&nbsp;                &amp;&amp; (entityHex != null) &amp;&amp; game.getBoard().onGround()</b>
&nbsp;                &amp;&amp; !((entity instanceof Infantry) || (entity instanceof Protomech))) {
&nbsp;            // large support vees will create ultra rough, otherwise rough
<b class="nc">&nbsp;            if (entity instanceof LargeSupportTank) {</b>
<b class="nc">&nbsp;                if (entityHex.terrainLevel(Terrains.ROUGH) &lt; 2) {</b>
<b class="nc">&nbsp;                    entityHex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                            .createTerrain(Terrains.ROUGH, 2));</b>
<b class="nc">&nbsp;                    sendChangedHex(curPos);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((entity.getWeight() &gt;= 40) &amp;&amp; !entityHex.containsTerrain(Terrains.ROUGH)) {</b>
<b class="nc">&nbsp;                entityHex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                        .createTerrain(Terrains.ROUGH, 1));</b>
<b class="nc">&nbsp;                sendChangedHex(curPos);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // update our entity, so clients have correct data needed for MekWars stuff
<b class="nc">&nbsp;        entityUpdate(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes a piece of equipment on a mech explode! POW! This expects either
&nbsp;     * ammo, or an explosive weapon. Returns a vector of Report objects.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; explodeEquipment(Entity en, int loc, int slot) {
<b class="nc">&nbsp;        CriticalSlot critSlot = en.getCritical(loc, slot);</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = explodeEquipment(en, loc, critSlot.getMount());</b>
<b class="nc">&nbsp;        if (critSlot.getMount2() != null) {</b>
<b class="nc">&nbsp;            reports.addAll(explodeEquipment(en, loc, critSlot.getMount2()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Explodes a piece of equipment on the unit.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; explodeEquipment(Entity en, int loc, Mounted mounted) { 
<b class="nc">&nbsp;        return explodeEquipment(en, loc, mounted, false);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Makes a piece of equipment on a mech explode! POW! This expects either
&nbsp;     * ammo, or an explosive weapon. Returns a vector of Report objects.
&nbsp;     * Possible to override &#39;is explosive&#39; check
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; explodeEquipment(Entity en, int loc, Mounted mounted, boolean overrideExplosiveCheck) {
<b class="nc">&nbsp;        final String METHOD_NAME = &quot;explodeEquipment(Entity,int,Mounted)&quot;;</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        // is this already destroyed?
<b class="nc">&nbsp;        if (mounted.isDestroyed()) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Called on destroyed equipment(&quot; + mounted.getName() + &quot;)&quot;);</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Special case: LAM bomb bays explode the bomb stored there, which may involve going through a
&nbsp;        // launch weapon to the bomb ammo.
<b class="nc">&nbsp;        if ((mounted.getType() instanceof MiscType) &amp;&amp; mounted.getType().hasFlag(MiscType.F_BOMB_BAY)) {</b>
<b class="nc">&nbsp;            while (mounted.getLinked() != null) {</b>
<b class="nc">&nbsp;                mounted = mounted.getLinked();</b>
&nbsp;            }
&nbsp;            // Fuel tank explodes on 2d6 roll of 10+
<b class="nc">&nbsp;            if ((mounted.getType() instanceof MiscType) &amp;&amp; mounted.getType().hasFlag(MiscType.F_FUEL)) {</b>
<b class="nc">&nbsp;                Report r = new Report(9120);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                int boomTarget = 10;</b>
&nbsp;                // check for possible explosion
<b class="nc">&nbsp;                int fuelRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;                r.choose(fuelRoll &gt;= boomTarget);</b>
<b class="nc">&nbsp;                if (fuelRoll &gt;= boomTarget) {</b>
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    return vDesc;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if(!overrideExplosiveCheck &amp;&amp; !mounted.getType().isExplosive(mounted, false)) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Inferno ammo causes heat buildup as well as the damage
<b class="nc">&nbsp;        if ((mounted.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                &amp;&amp; ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                        || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                        || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_IATM)</b>
<b class="nc">&nbsp;                        || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_MML))</b>
<b class="nc">&nbsp;                &amp;&amp; (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_INFERNO)</b>
<b class="nc">&nbsp;                &amp;&amp; (mounted.getHittableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;            en.heatBuildup += Math.min(mounted.getExplosionDamage(), 30);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Inferno bombs in LAM bomb bays
<b class="nc">&nbsp;        if ((mounted.getType() instanceof BombType)</b>
<b class="nc">&nbsp;                &amp;&amp; (((BombType)mounted.getType()).getBombType() == BombType.B_INFERNO)) {</b>
<b class="nc">&nbsp;            en.heatBuildup += Math.min(mounted.getExplosionDamage(), 30);</b>
&nbsp;        }
&nbsp;
&nbsp;        // determine and deal damage
<b class="nc">&nbsp;        int damage = mounted.getExplosionDamage();</b>
&nbsp;
&nbsp;        // Smoke ammo halves damage
<b class="nc">&nbsp;        if ((mounted.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                &amp;&amp; ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                        || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                        || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                        || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_LRM_IMP))</b>
<b class="nc">&nbsp;                &amp;&amp; (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_SMOKE_WARHEAD)</b>
<b class="nc">&nbsp;                &amp;&amp; (mounted.getHittableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;            damage = ((mounted.getExplosionDamage()) / 2);</b>
&nbsp;        }
&nbsp;        // coolant explodes for 2 damage and reduces heat by 3
<b class="nc">&nbsp;        if ((mounted.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                &amp;&amp; ((((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_VEHICLE_FLAMER)</b>
<b class="nc">&nbsp;                || (((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_HEAVY_FLAMER))</b>
<b class="nc">&nbsp;                &amp;&amp; (((AmmoType) mounted.getType()).getMunitionType() == AmmoType.M_COOLANT)</b>
<b class="nc">&nbsp;                &amp;&amp; (mounted.getHittableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;            damage = 2;</b>
<b class="nc">&nbsp;            en.coolFromExternal += 3;</b>
&nbsp;        }
&nbsp;
&nbsp;        // divide damage by 10 for aeros, per TW rules on pg. 161
<b class="nc">&nbsp;        if (en instanceof Aero) {</b>
<b class="nc">&nbsp;            int newDamage = (int) Math.floor(damage / 10.0);</b>
<b class="nc">&nbsp;            if ((newDamage == 0) &amp;&amp; (damage &gt; 0)) {</b>
<b class="nc">&nbsp;                damage = 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                damage = newDamage;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (damage &lt;= 0) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Report r = new Report(6390);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        r.add(mounted.getName());</b>
<b class="nc">&nbsp;        r.add(damage);</b>
<b class="nc">&nbsp;        r.indent(3);</b>
<b class="nc">&nbsp;        vDesc.addElement(r);</b>
&nbsp;        // Mounted is a weapon and has Hot-Loaded ammo in it and it exploded now
&nbsp;        // we need to roll for chain reaction
<b class="nc">&nbsp;        if ((mounted.getType() instanceof WeaponType) &amp;&amp; mounted.isHotLoaded()) {</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            int ammoExploded = 0;</b>
<b class="nc">&nbsp;            r = new Report(6077);</b>
<b class="nc">&nbsp;            r.subject = en.getId();</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
&nbsp;            // roll of 2-5 means a chain reaction happened
<b class="nc">&nbsp;            if (roll &lt; 6) {</b>
<b class="nc">&nbsp;                for (Mounted ammo : en.getAmmo()) {</b>
<b class="nc">&nbsp;                    if ((ammo.getLocation() == loc) &amp;&amp; (ammo.getExplosionDamage() &gt; 0)</b>
&nbsp;                            // Dead-Fire ammo bins are designed not to explode
&nbsp;                            // from the chain reaction
&nbsp;                            // Of Critted Launchers with DFM or HotLoaded ammo.
<b class="nc">&nbsp;                            &amp;&amp; (((AmmoType) ammo.getType()).getMunitionType() != AmmoType.M_DEAD_FIRE)) {</b>
<b class="nc">&nbsp;                        ammoExploded++;</b>
<b class="nc">&nbsp;                        vDesc.addAll(this.explodeEquipment(en, loc, ammo));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (ammoExploded == 0) {</b>
<b class="nc">&nbsp;                    r = new Report(6078);</b>
<b class="nc">&nbsp;                    r.subject = en.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(6079);</b>
<b class="nc">&nbsp;                r.subject = en.getId();</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HitData hit = new HitData(loc);</b>
&nbsp;        // check to determine whether this is capital scale if we have a capital
&nbsp;        // scale entity
<b class="nc">&nbsp;        if (mounted.getType() instanceof AmmoType) {</b>
<b class="nc">&nbsp;            if (((AmmoType) mounted.getType()).isCapital()) {</b>
<b class="nc">&nbsp;                hit.setCapital(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // exploding RISC laser pulse module should cause no normal crits, just
&nbsp;        // automatically crit the first uncritted crit of the laser it&#39;s
&nbsp;        // attached to
<b class="nc">&nbsp;        if ((mounted.getType() instanceof MiscType)  &amp;&amp; mounted.getType().hasFlag(MiscType.F_RISC_LASER_PULSE_MODULE)) {</b>
<b class="nc">&nbsp;            hit.setEffect(HitData.EFFECT_NO_CRITICALS);</b>
<b class="nc">&nbsp;            Mounted laser = mounted.getLinkedBy();</b>
<b class="nc">&nbsp;            if (en instanceof Mech) {</b>
<b class="nc">&nbsp;                for (int slot = 0; slot &lt; en.getNumberOfCriticals(laser.getLocation()); slot++) {</b>
<b class="nc">&nbsp;                    CriticalSlot cs = en.getCritical(laser.getLocation(), slot);</b>
<b class="nc">&nbsp;                    if ((cs.getType() == CriticalSlot.TYPE_EQUIPMENT) &amp;&amp; cs.getMount().equals(laser)</b>
<b class="nc">&nbsp;                            &amp;&amp; cs.isHittable()) {</b>
<b class="nc">&nbsp;                        cs.setHit(true);</b>
<b class="nc">&nbsp;                        cs.setRepairable(true);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            laser.setHit(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        mounted.setShotsLeft(0);</b>
&nbsp;
<b class="nc">&nbsp;        int pilotDamage = 2;</b>
<b class="nc">&nbsp;        if (en instanceof Aero) {</b>
<b class="nc">&nbsp;            pilotDamage = 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_CASE_PILOT_DAMAGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (en.locationHasCase(hit.getLocation()) || en.hasCASEII(hit.getLocation()))) {</b>
<b class="nc">&nbsp;            pilotDamage = 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (en.hasAbility(OptionsConstants.MISC_PAIN_RESISTANCE)</b>
<b class="nc">&nbsp;                || en.hasAbility(OptionsConstants.MISC_IRON_MAN)) {</b>
<b class="nc">&nbsp;            pilotDamage -= 1;</b>
&nbsp;        }
&nbsp;        // tanks only take pilot damage when using BVDNI or VDNI
<b class="nc">&nbsp;        if ((en instanceof Tank) &amp;&amp; !(en.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                || en.hasAbility(OptionsConstants.MD_BVDNI))) {</b>
<b class="nc">&nbsp;            pilotDamage = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!en.hasAbility(OptionsConstants.MD_PAIN_SHUNT)) {</b>
<b class="nc">&nbsp;            vDesc.addAll(damageCrew(en, pilotDamage, en.getCrew().getCurrentPilotIndex()));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (en.getCrew().isDoomed() || en.getCrew().isDead()) {</b>
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(en, &quot;crew death&quot;, true));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Report&gt; newReports = damageEntity(en, hit, damage, true);</b>
<b class="nc">&nbsp;        for (Report rep : newReports) {</b>
<b class="nc">&nbsp;            rep.indent(2);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        vDesc.addAll(newReports);</b>
<b class="nc">&nbsp;        Report.addNewline(vDesc);</b>
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes one slot of ammo, determined by certain rules, explode on a mech.
&nbsp;     */
&nbsp;    Vector&lt;Report&gt; explodeAmmoFromHeat(Entity entity) {
<b class="nc">&nbsp;        int damage = 0;</b>
<b class="nc">&nbsp;        int rack = 0;</b>
<b class="nc">&nbsp;        int boomloc = -1;</b>
<b class="nc">&nbsp;        int boomslot = -1;</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (int j = 0; j &lt; entity.locations(); j++) {</b>
<b class="nc">&nbsp;            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {</b>
<b class="nc">&nbsp;                CriticalSlot cs = entity.getCritical(j, k);</b>
<b class="nc">&nbsp;                if ((cs == null) || cs.isDestroyed() || cs.isHit()</b>
<b class="nc">&nbsp;                        || (cs.getType() != CriticalSlot.TYPE_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                Mounted mounted = cs.getMount();</b>
<b class="nc">&nbsp;                if ((mounted == null) || (!(mounted.getType() instanceof AmmoType))) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                AmmoType atype = (AmmoType) mounted.getType();</b>
<b class="nc">&nbsp;                if (!atype.isExplosive(mounted)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // coolant pods and flamer coolant ammo don&#39;t explode from heat
<b class="nc">&nbsp;                if ((atype.getAmmoType() == AmmoType.T_COOLANT_POD)</b>
<b class="nc">&nbsp;                        || (((atype.getAmmoType() == AmmoType.T_VEHICLE_FLAMER)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_HEAVY_FLAMER))</b>
<b class="nc">&nbsp;                                &amp;&amp; (atype.getMunitionType() == AmmoType.M_COOLANT))) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // ignore empty, destroyed, or missing bins
<b class="nc">&nbsp;                if (mounted.getHittableShotsLeft() == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // TW page 160, compare one rack&#39;s
&nbsp;                // damage. Ties go to most rounds.
<b class="nc">&nbsp;                int newRack = atype.getDamagePerShot() * atype.getRackSize();</b>
<b class="nc">&nbsp;                int newDamage = mounted.getExplosionDamage();</b>
<b class="nc">&nbsp;                Mounted mount2 = cs.getMount2();</b>
<b class="nc">&nbsp;                if ((mount2 != null) &amp;&amp; (mount2.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                        &amp;&amp; (mount2.getHittableShotsLeft() &gt; 0)) {</b>
&nbsp;                    // must be for same weaponType, so rackSize stays
<b class="nc">&nbsp;                    atype = (AmmoType) mount2.getType();</b>
<b class="nc">&nbsp;                    newRack += atype.getDamagePerShot() * atype.getRackSize();</b>
<b class="nc">&nbsp;                    newDamage += mount2.getExplosionDamage();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!mounted.isHit()</b>
&nbsp;                        &amp;&amp; ((rack &lt; newRack) || ((rack == newRack) &amp;&amp; (damage &lt; newDamage)))) {
<b class="nc">&nbsp;                    rack = newRack;</b>
<b class="nc">&nbsp;                    damage = newDamage;</b>
<b class="nc">&nbsp;                    boomloc = j;</b>
<b class="nc">&nbsp;                    boomslot = k;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((boomloc != -1) &amp;&amp; (boomslot != -1)) {</b>
<b class="nc">&nbsp;            CriticalSlot slot = entity.getCritical(boomloc, boomslot);</b>
<b class="nc">&nbsp;            slot.setHit(true);</b>
<b class="nc">&nbsp;            slot.getMount().setHit(true);</b>
<b class="nc">&nbsp;            if (slot.getMount2() != null) {</b>
<b class="nc">&nbsp;                slot.getMount2().setHit(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.addAll(explodeEquipment(entity, boomloc, boomslot));</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Luckily, there is no ammo to explode.
<b class="nc">&nbsp;            Report r = new Report(5105);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes a mech fall.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            The Entity that is falling. It is expected that the Entity&#39;s
&nbsp;     *            position and elevation reflect the state prior to the fall
&nbsp;     * @param fallPos
&nbsp;     *            The location that the Entity is falling into.
&nbsp;     * @param fallHeight
&nbsp;     *            The height that Entity is falling.
&nbsp;     * @param facing
&nbsp;     *            The facing of the fall. Used to determine the the hit location
&nbsp;     *            and also determines facing after the fall (used as an offset
&nbsp;     *            of the Entity&#39;s current facing).
&nbsp;     * @param roll
&nbsp;     *            The PSR required to avoid damage to the pilot/crew.
&nbsp;     * @param intoBasement
&nbsp;     *            Flag that determines whether this is a fall into a basement or
&nbsp;     *            not.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityFall(Entity entity, Coords fallPos, int fallHeight, int facing,
&nbsp;                                        PilotingRollData roll, boolean intoBasement, boolean fromCliff) {
<b class="nc">&nbsp;        entity.setFallen(true);</b>
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        IHex fallHex = game.getBoard().getHex(fallPos);</b>
&nbsp;
<b class="nc">&nbsp;        boolean handlingBasement = false;</b>
<b class="nc">&nbsp;        int damageTable = ToHitData.HIT_NORMAL;</b>
&nbsp;
&nbsp;        // we don&#39;t need to deal damage yet, if the entity is doing DFA
<b class="nc">&nbsp;        if (entity.isMakingDfa()) {</b>
<b class="nc">&nbsp;            r = new Report(2305);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            entity.setProne(true);</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        // facing after fall
&nbsp;        String side;
&nbsp;        int table;
<b class="nc">&nbsp;        switch (facing) {</b>
&nbsp;            case 1:
&nbsp;            case 2:
<b class="nc">&nbsp;                side = &quot;right side&quot;;</b>
<b class="nc">&nbsp;                table = ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                side = &quot;rear&quot;;</b>
<b class="nc">&nbsp;                table = ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 4:
&nbsp;            case 5:
<b class="nc">&nbsp;                side = &quot;left side&quot;;</b>
<b class="nc">&nbsp;                table = ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 0:
&nbsp;            default:
<b class="nc">&nbsp;                side = &quot;front&quot;;</b>
<b class="nc">&nbsp;                table = ToHitData.SIDE_FRONT;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int waterDepth = 0;</b>
<b class="nc">&nbsp;        if (fallHex.containsTerrain(Terrains.WATER)) {</b>
&nbsp;            // *Only* use this if there actually is water in the hex, otherwise
&nbsp;            // we get ITerrain.LEVEL_NONE, i.e. Integer.minValue...
<b class="nc">&nbsp;            waterDepth = fallHex.terrainLevel(Terrains.WATER);</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean fallOntoBridge = false;</b>
&nbsp;        // only fall onto the bridge if we were in the hex and on it,
&nbsp;        // or we fell from a hex that the bridge exits to
<b class="nc">&nbsp;        if ((entity.climbMode() &amp;&amp; (entity.getPosition() != fallPos)</b>
<b class="nc">&nbsp;                &amp;&amp; fallHex.containsTerrain(Terrains.BRIDGE)</b>
<b class="nc">&nbsp;                &amp;&amp; fallHex.containsTerrainExit(Terrains.BRIDGE, fallPos.direction(entity.getPosition())))</b>
<b class="nc">&nbsp;                || (entity.getElevation() == fallHex.terrainLevel(Terrains.BRIDGE_ELEV))) {</b>
<b class="nc">&nbsp;            fallOntoBridge = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        int bridgeElev = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;        int buildingElev = fallHex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;        int damageHeight = fallHeight;</b>
<b class="nc">&nbsp;        int newElevation = 0;</b>
&nbsp;
&nbsp;        // we might have to check if the building/bridge we are falling onto
&nbsp;        // collapses
<b class="nc">&nbsp;        boolean checkCollapse = false;</b>
&nbsp;
<b class="nc">&nbsp;        if ((entity.getElevation() &gt;= buildingElev) &amp;&amp; (buildingElev &gt;= 0)) {</b>
&nbsp;            // fallHeight should already reflect this
<b class="nc">&nbsp;            newElevation = buildingElev;</b>
<b class="nc">&nbsp;            checkCollapse = true;</b>
<b class="nc">&nbsp;        } else if (fallOntoBridge &amp;&amp; (entity.getElevation() &gt;= bridgeElev) &amp;&amp; (bridgeElev &gt;= 0)) {</b>
&nbsp;            // fallHeight should already reflect this
<b class="nc">&nbsp;            waterDepth = 0;</b>
<b class="nc">&nbsp;            newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;            checkCollapse = true;</b>
<b class="nc">&nbsp;        } else if (fallHex.containsTerrain(Terrains.ICE) &amp;&amp; (entity.getElevation() == 0)) {</b>
<b class="nc">&nbsp;            waterDepth = 0;</b>
<b class="nc">&nbsp;            newElevation = 0;</b>
&nbsp;            // If we are in a basement, we are at a negative elevation, and so
&nbsp;            // setting newElevation = 0 will cause us to &quot;fall up&quot;
<b class="nc">&nbsp;        } else if ((entity.getMovementMode() != EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                   &amp;&amp; (game.getBoard().getBuildingAt(fallPos) != null)) {</b>
<b class="nc">&nbsp;            newElevation = entity.getElevation();</b>
&nbsp;        }
&nbsp;        // HACK: if the destination hex is water, assume that the fall height given is
&nbsp;        // to the floor of the hex, and modify it so that it&#39;s to the surface
<b class="nc">&nbsp;        else if (waterDepth &gt; 0) {</b>
<b class="nc">&nbsp;            damageHeight = fallHeight - waterDepth;</b>
<b class="nc">&nbsp;            newElevation = -waterDepth;</b>
&nbsp;        }
&nbsp;        // only do these basement checks if we didn&#39;t fall onto the building
&nbsp;        // from above
<b class="nc">&nbsp;        if (intoBasement) {</b>
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(fallPos);</b>
<b class="nc">&nbsp;            BasementType basement = bldg.getBasement(fallPos);</b>
<b class="nc">&nbsp;            if ((basement != BasementType.NONE) &amp;&amp; (basement != BasementType.ONE_DEEP_NORMALINFONLY)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getElevation() == 0) &amp;&amp; (bldg.getBasementCollapsed(fallPos))) {</b>
&nbsp;
<b class="nc">&nbsp;                if (fallHex.depth(true) == 0) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Entity &quot; + entity.getDisplayName() + &quot; is falling into a depth &quot;</b>
<b class="nc">&nbsp;                            + fallHex.depth(true) + &quot; basement -- not allowed!!&quot;);</b>
<b class="nc">&nbsp;                    return vPhaseReport;</b>
&nbsp;                }
<b class="nc">&nbsp;                damageHeight = basement.getDepth();</b>
&nbsp;
<b class="nc">&nbsp;                newElevation = newElevation - damageHeight;</b>
&nbsp;
<b class="nc">&nbsp;                handlingBasement = true;</b>
&nbsp;                // May have to adjust hit table for &#39;mechs
<b class="nc">&nbsp;                if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                    if ((basement == BasementType.TWO_DEEP_FEET)</b>
&nbsp;                            || (basement == BasementType.ONE_DEEP_FEET)) {
<b class="nc">&nbsp;                        damageTable = ToHitData.HIT_KICK;</b>
<b class="nc">&nbsp;                    } else if ((basement == BasementType.TWO_DEEP_HEAD)</b>
&nbsp;                            || (basement == BasementType.ONE_DEEP_HEAD)) {
<b class="nc">&nbsp;                        damageTable = ToHitData.HIT_PUNCH;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        damageTable = ToHitData.HIT_NORMAL;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;            damageTable = ToHitData.HIT_SPECIAL_PROTO;</b>
&nbsp;        }
&nbsp;        // Falling into water instantly destroys most non-mechs
<b class="nc">&nbsp;        if ((waterDepth &gt; 0)</b>
&nbsp;            &amp;&amp; !(entity instanceof Mech)
&nbsp;            &amp;&amp; !(entity instanceof Protomech)
<b class="nc">&nbsp;            &amp;&amp; !((entity.getRunMP() &gt; 0) &amp;&amp; (entity.getMovementMode() == EntityMovementMode.HOVER))</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.INF_UMU)) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(destroyEntity(entity, &quot;a watery grave&quot;, false));</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
&nbsp;
&nbsp;        // set how deep the mech has fallen
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            Mech mech = (Mech) entity;</b>
<b class="nc">&nbsp;            mech.setLevelsFallen(damageHeight + waterDepth + 1);</b>
&nbsp;            // an industrial mech now needs to check for a crit at the end of
&nbsp;            // the turn
<b class="nc">&nbsp;            if (mech.isIndustrial()) {</b>
<b class="nc">&nbsp;                mech.setCheckForCrit(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // calculate damage for hitting the surface
<b class="nc">&nbsp;        int damage = (int) Math.round(entity.getWeight() / 10.0)</b>
&nbsp;                     * (damageHeight + 1);
&nbsp;        // different rules (pg. 151 of TW) for battle armor and infantry
<b class="nc">&nbsp;        if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            damage = (int) Math.ceil(damageHeight / 2.0);</b>
&nbsp;            // no damage for fall from less than 2 levels
<b class="nc">&nbsp;            if (damageHeight &lt; 2) {</b>
<b class="nc">&nbsp;                damage = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!(entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                int dice = 3;</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.INF_MOTORIZED) {</b>
<b class="nc">&nbsp;                    dice = 2;</b>
<b class="nc">&nbsp;                } else if ((entity.getMovementMode() == EntityMovementMode.INF_JUMP)</b>
<b class="nc">&nbsp;                           || ((Infantry) entity).isMechanized()) {</b>
<b class="nc">&nbsp;                    dice = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                damage = damage * Compute.d6(dice);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Different rules (pg 62/63/152 of TW) for Tanks
<b class="nc">&nbsp;        if (entity instanceof Tank) {</b>
&nbsp;            // Falls from less than 2 levels don&#39;t damage combat vehicles
&nbsp;            // except if they fall off a sheer cliff
<b class="nc">&nbsp;            if (damageHeight &lt; 2 &amp;&amp; !fromCliff) {</b>
<b class="nc">&nbsp;                damage = 0; </b>
&nbsp;            }
&nbsp;            // Falls from &gt;= 2 elevations damage like crashing VTOLs
&nbsp;            // Ends up being the regular damage: weight / 10 * (height + 1)
&nbsp;            // And this was already computed
&nbsp;        }
&nbsp;        // calculate damage for hitting the ground, but only if we actually fell
&nbsp;        // into water
&nbsp;        // if we fell onto the water surface, that damage is halved.
<b class="nc">&nbsp;        int waterDamage = 0;</b>
<b class="nc">&nbsp;        if (waterDepth &gt; 0) {</b>
<b class="nc">&nbsp;            damage /= 2;</b>
<b class="nc">&nbsp;            waterDamage = ((int) Math.round(entity.getWeight() / 10.0) * (waterDepth + 1)) / 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the waterDepth is larger than the fall height, we fell underwater
<b class="nc">&nbsp;        if ((waterDepth &gt;= fallHeight) &amp;&amp; ((waterDepth != 0) || (fallHeight != 0))) {</b>
<b class="nc">&nbsp;            damage = 0;</b>
<b class="nc">&nbsp;            waterDamage = ((int) Math.round(entity.getWeight() / 10.0) * (fallHeight + 1)) / 2;</b>
&nbsp;        }
&nbsp;        // adjust damage for gravity
<b class="nc">&nbsp;        damage = Math</b>
<b class="nc">&nbsp;                .round(damage * game.getPlanetaryConditions().getGravity());</b>
<b class="nc">&nbsp;        waterDamage = Math.round(waterDamage</b>
<b class="nc">&nbsp;                                 * game.getPlanetaryConditions().getGravity());</b>
&nbsp;
&nbsp;        // report falling
<b class="nc">&nbsp;        if (waterDamage == 0) {</b>
<b class="nc">&nbsp;            r = new Report(2310);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(side); // international issue</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;        } else if (damage &gt; 0) {</b>
<b class="nc">&nbsp;            r = new Report(2315);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(side); // international issue</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            r.add(waterDamage);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(2310);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(side); // international issue</b>
<b class="nc">&nbsp;            r.add(waterDamage);</b>
&nbsp;        }
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
&nbsp;
&nbsp;        // Any swarming infantry will be dislodged, but we don&#39;t want to
&nbsp;        // interrupt the fall&#39;s report. We have to get the ID now because
&nbsp;        // the fall may kill the entity which will reset the attacker ID.
<b class="nc">&nbsp;        final int swarmerId = entity.getSwarmAttackerId();</b>
&nbsp;
&nbsp;        // Positioning must be prior to damage for proper handling of breaches
&nbsp;        // Only Mechs can fall prone.
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            entity.setProne(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        entity.setPosition(fallPos);</b>
<b class="nc">&nbsp;        entity.setElevation(newElevation);</b>
&nbsp;        // Only &#39;mechs change facing when they fall
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            entity.setFacing((entity.getFacing() + (facing)) % 6);</b>
<b class="nc">&nbsp;            entity.setSecondaryFacing(entity.getFacing());</b>
&nbsp;        }
&nbsp;
&nbsp;        // if falling into a bog-down hex, the entity automatically gets stuck (except when on a bridge or building)
&nbsp;        // but avoid reporting this twice in the case of DFAs
<b class="nc">&nbsp;        if (!entity.isStuck() &amp;&amp; (entity.getElevation() == 0)) {</b>
<b class="nc">&nbsp;            if (fallHex.getBogDownModifier(entity.getMovementMode(),</b>
&nbsp;                    entity instanceof LargeSupportTank) != TargetRoll.AUTOMATIC_SUCCESS) {
<b class="nc">&nbsp;                entity.setStuck(true);</b>
<b class="nc">&nbsp;                r = new Report(2081);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;                // check for quicksand
<b class="nc">&nbsp;                vPhaseReport.addAll(checkQuickSand(fallPos));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // standard damage loop
<b class="nc">&nbsp;        if ((entity instanceof Infantry) &amp;&amp; (damage &gt; 0)) {</b>
<b class="nc">&nbsp;            if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                for (int i = 1; i &lt; entity.locations(); i++) {</b>
<b class="nc">&nbsp;                    HitData h = new HitData(i);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(damageEntity(entity, h, damage));</b>
<b class="nc">&nbsp;                    addNewLines();</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                HitData h = new HitData(Infantry.LOC_INFANTRY);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageEntity(entity, h, damage));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
<b class="nc">&nbsp;            while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                int cluster = Math.min(5, damage);</b>
<b class="nc">&nbsp;                HitData hit = entity.rollHitLocation(damageTable, table);</b>
<b class="nc">&nbsp;                hit.makeFallDamage(true);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageEntity(entity, hit, cluster));</b>
<b class="nc">&nbsp;                damage -= cluster;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (waterDepth &gt; 0) {</b>
<b class="nc">&nbsp;            for (int loop = 0; loop &lt; entity.locations(); loop++) {</b>
<b class="nc">&nbsp;                entity.setLocationStatus(loop, ILocationExposureStatus.WET);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Water damage
<b class="nc">&nbsp;        while (waterDamage &gt; 0) {</b>
<b class="nc">&nbsp;            int cluster = Math.min(5, waterDamage);</b>
<b class="nc">&nbsp;            HitData hit = entity.rollHitLocation(damageTable, table);</b>
<b class="nc">&nbsp;            hit.makeFallDamage(true);</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(damageEntity(entity, hit, cluster));</b>
<b class="nc">&nbsp;            waterDamage -= cluster;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check for location exposure
<b class="nc">&nbsp;        vPhaseReport.addAll(doSetLocationsExposure(entity, fallHex, false,</b>
&nbsp;                                                   -waterDepth));
&nbsp;
&nbsp;        // only mechs should roll to avoid pilot damage
&nbsp;        // vehicles may fall due to sideslips
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(checkPilotAvoidFallDamage(entity, fallHeight, roll));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now dislodge any swarming infantry.
<b class="nc">&nbsp;        if (Entity.NONE != swarmerId) {</b>
<b class="nc">&nbsp;            final Entity swarmer = game.getEntity(swarmerId);</b>
<b class="nc">&nbsp;            entity.setSwarmAttackerId(Entity.NONE);</b>
<b class="nc">&nbsp;            swarmer.setSwarmTargetId(Entity.NONE);</b>
&nbsp;            // Did the infantry fall into water?
<b class="nc">&nbsp;            if ((waterDepth &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; (swarmer.getMovementMode() != EntityMovementMode.INF_UMU)) {</b>
&nbsp;                // Swarming infantry die.
<b class="nc">&nbsp;                swarmer.setPosition(fallPos);</b>
<b class="nc">&nbsp;                r = new Report(2330);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.subject = swarmer.getId();</b>
<b class="nc">&nbsp;                r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(destroyEntity(swarmer, &quot;a watery grave&quot;,</b>
&nbsp;                                                  false));
&nbsp;            } else {
&nbsp;                // Swarming infantry take a 2d6 point hit.
&nbsp;                // ASSUMPTION : damage should not be doubled.
<b class="nc">&nbsp;                r = new Report(2335);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.subject = swarmer.getId();</b>
<b class="nc">&nbsp;                r.addDesc(swarmer);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageEntity(swarmer, swarmer</b>
<b class="nc">&nbsp;                        .rollHitLocation(ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                                         ToHitData.SIDE_FRONT), Compute.d6(2)));</b>
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
&nbsp;            }
<b class="nc">&nbsp;            swarmer.setPosition(fallPos);</b>
<b class="nc">&nbsp;            entityUpdate(swarmerId);</b>
<b class="nc">&nbsp;            if (!swarmer.isDone()) {</b>
<b class="nc">&nbsp;                game.removeTurnFor(swarmer);</b>
<b class="nc">&nbsp;                swarmer.setDone(true);</b>
<b class="nc">&nbsp;                send(createTurnVectorPacket());</b>
&nbsp;            }
&nbsp;        } // End dislodge-infantry
&nbsp;
&nbsp;        // clear all PSRs after a fall -- the Mek has already failed ONE and
&nbsp;        // fallen, it&#39;d be cruel to make it fail some more!
<b class="nc">&nbsp;        game.resetPSRs(entity);</b>
&nbsp;
&nbsp;        // if there is a minefield in this hex, then the mech may set it off
<b class="nc">&nbsp;        if (game.containsMinefield(fallPos)</b>
<b class="nc">&nbsp;            &amp;&amp; enterMinefield(entity, fallPos, newElevation, true,</b>
&nbsp;                              vPhaseReport, 12)) {
<b class="nc">&nbsp;            resetMines();</b>
&nbsp;        }
&nbsp;        // if we have to, check if the building/bridge we fell on collapses -
&nbsp;        // unless it&#39;s a fall into a basement,
&nbsp;        // then we&#39;re already gonna check that in building collapse, where we
&nbsp;        // came from
<b class="nc">&nbsp;        if (checkCollapse &amp;&amp; !handlingBasement) {</b>
&nbsp;
<b class="nc">&nbsp;            checkForCollapse(game.getBoard().getBuildingAt(fallPos),</b>
<b class="nc">&nbsp;                             game.getPositionMap(), fallPos, false, vPhaseReport);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; checkPilotAvoidFallDamage(Entity entity, int fallHeight, PilotingRollData roll) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        if (entity.hasAbility(OptionsConstants.MD_DERMAL_ARMOR)</b>
<b class="nc">&nbsp;                || entity.hasAbility(OptionsConstants.MD_TSM_IMPLANT)) {</b>
<b class="nc">&nbsp;            return reports;</b>
&nbsp;        }
&nbsp;        // we want to be able to avoid pilot damage even when it was
&nbsp;        // an automatic fall, only unconsciousness should cause auto-damage
<b class="nc">&nbsp;        roll.removeAutos();</b>
&nbsp;
<b class="nc">&nbsp;        if (fallHeight &gt; 1) {</b>
<b class="nc">&nbsp;            roll.addModifier(fallHeight - 1, &quot;height of fall&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.getCrew().getSlotCount() &gt; 1) {</b>
&nbsp;            //Extract the base from the list of modifiers so we can replace it with the piloting
&nbsp;            //skill of each crew member.
<b class="nc">&nbsp;            List&lt;TargetRollModifier&gt; modifiers = new ArrayList&lt;&gt;(roll.getModifiers());</b>
<b class="nc">&nbsp;            if (modifiers.size() &gt; 0) {</b>
<b class="nc">&nbsp;                modifiers.remove(0);</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int pos = 0; pos &lt; entity.getCrew().getSlotCount(); pos++) {</b>
<b class="nc">&nbsp;                if (entity.getCrew().isMissing(pos) || entity.getCrew().isDead(pos)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                PilotingRollData prd;
<b class="nc">&nbsp;                if (entity.getCrew().isDead(pos)) {</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                } else if (entity.getCrew().isUnconscious(pos)) {</b>
<b class="nc">&nbsp;                    prd = new PilotingRollData(entity.getId(), TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                            &quot;Crew member unconscious&quot;);
&nbsp;                } else {
<b class="nc">&nbsp;                    prd = new PilotingRollData(entity.getId(),</b>
<b class="nc">&nbsp;                            entity.getCrew().getPiloting(pos), &quot;Base piloting skill&quot;);</b>
<b class="nc">&nbsp;                    modifiers.forEach(prd::addModifier);</b>
&nbsp;                }
<b class="nc">&nbsp;                reports.addAll(resolvePilotDamageFromFall(entity, prd, pos));</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            reports.addAll(resolvePilotDamageFromFall(entity, roll, 0));</b>
&nbsp;        }
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; resolvePilotDamageFromFall(Entity entity, PilotingRollData roll, int crewPos) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (roll.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            r = new Report(2320);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(entity.getCrew().getCrewType().getRoleName(crewPos));</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(entity.getCrew().getName(crewPos));</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            reports.add(r);</b>
<b class="nc">&nbsp;            reports.addAll(damageCrew(entity, 1, crewPos));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            int diceRoll = entity.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;            r = new Report(2325);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(entity.getCrew().getCrewType().getRoleName(crewPos));</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(entity.getCrew().getName(crewPos));</b>
<b class="nc">&nbsp;            r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            if (diceRoll &gt;= roll.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                reports.add(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                reports.add(r);</b>
<b class="nc">&nbsp;                reports.addAll(damageCrew(entity, 1, crewPos));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Report.addNewline(reports);</b>
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The mech falls into an unoccupied hex from the given height above
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityFall(Entity entity, Coords fallPos,
&nbsp;                                        int height, PilotingRollData roll) {
<b class="nc">&nbsp;        return doEntityFall(entity, fallPos, height, Compute.d6(1) - 1, roll,</b>
&nbsp;                            false, false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The mech falls down in place
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doEntityFall(Entity entity, PilotingRollData roll) {
<b class="nc">&nbsp;        boolean fallToSurface = false;</b>
&nbsp;        // on ice
<b class="nc">&nbsp;        int toSubtract = 0;</b>
<b class="nc">&nbsp;        IHex currHex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;        if (currHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getElevation() != -currHex.depth())) {</b>
<b class="nc">&nbsp;            fallToSurface = true;</b>
<b class="nc">&nbsp;            toSubtract = 0;</b>
&nbsp;        }
&nbsp;        // on a bridge
<b class="nc">&nbsp;        if (currHex.containsTerrain(Terrains.BRIDGE_ELEV)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getElevation() &gt;= currHex</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.BRIDGE_ELEV))) {</b>
<b class="nc">&nbsp;            fallToSurface = true;</b>
<b class="nc">&nbsp;            toSubtract = currHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
&nbsp;        }
&nbsp;        // on a building
<b class="nc">&nbsp;        if (currHex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getElevation() &gt;= currHex</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.BLDG_ELEV))) {</b>
<b class="nc">&nbsp;            fallToSurface = true;</b>
<b class="nc">&nbsp;            toSubtract = currHex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;        }
<b class="nc">&nbsp;        return doEntityFall(entity, entity.getPosition(), entity.getElevation()</b>
<b class="nc">&nbsp;                + (!fallToSurface ? currHex.depth(true) : -toSubtract), roll);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Report: - Any ammo dumps beginning the following round. - Any ammo dumps
&nbsp;     * that have ended with the end of this round.
&nbsp;     */
&nbsp;    private void resolveAmmoDumps() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            for (Mounted m : entity.getAmmo()) {</b>
<b class="nc">&nbsp;                if (m.isPendingDump()) {</b>
&nbsp;                    // report dumping next round
<b class="nc">&nbsp;                    r = new Report(5110);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(m.getName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // update status
<b class="nc">&nbsp;                    m.setPendingDump(false);</b>
<b class="nc">&nbsp;                    m.setDumping(true);</b>
<b class="nc">&nbsp;                } else if (m.isDumping()) {</b>
&nbsp;                    // report finished dumping
<b class="nc">&nbsp;                    r = new Report(5115);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.addDesc(entity);</b>
<b class="nc">&nbsp;                    r.add(m.getName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // update status
<b class="nc">&nbsp;                    m.setDumping(false);</b>
<b class="nc">&nbsp;                    m.setShotsLeft(0);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // also do DWP dumping
<b class="nc">&nbsp;            if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                for (Mounted m : entity.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if (m.isDWPMounted() &amp;&amp; m.isPendingDump()) {</b>
<b class="nc">&nbsp;                        m.setMissing(true);</b>
<b class="nc">&nbsp;                        r = new Report(5116);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.add(m.getName());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        m.setPendingDump(false);</b>
&nbsp;                        // Also dump all of the ammo in the DWP
<b class="nc">&nbsp;                        for (Mounted ammo : entity.getAmmo()) {</b>
<b class="nc">&nbsp;                            if (m.equals(ammo.getLinkedBy())) {</b>
<b class="nc">&nbsp;                                ammo.setMissing(true);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    // Check for jettisoning missiles
<b class="nc">&nbsp;                    } else if (m.isBodyMounted() &amp;&amp; m.isPendingDump()</b>
<b class="nc">&nbsp;                            &amp;&amp; m.getType().hasFlag(WeaponType.F_MISSILE)</b>
<b class="nc">&nbsp;                            &amp;&amp; (m.getLinked() != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; (m.getLinked().getUsableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;                        m.setMissing(true);</b>
<b class="nc">&nbsp;                        r = new Report(5116);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.addDesc(entity);</b>
<b class="nc">&nbsp;                        r.add(m.getName());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        m.setPendingDump(false);</b>
&nbsp;                        // Dump all ammo related to this launcher
&nbsp;                        // BA burdened is based on whether the launcher has
&nbsp;                        // ammo left
<b class="nc">&nbsp;                        while ((m.getLinked() != null)</b>
<b class="nc">&nbsp;                                &amp;&amp; (m.getLinked().getUsableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;                            m.getLinked().setMissing(true);</b>
<b class="nc">&nbsp;                            entity.loadWeapon(m);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            entity.reloadEmptyWeapons();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for fire ignition based on a given target roll. If successful,
&nbsp;     * lights a fire also checks to see that fire is possible in the specified
&nbsp;     * hex.
&nbsp;     *
&nbsp;     * @param c        - the &lt;code&gt;Coords&lt;/code&gt; to be lit.
&nbsp;     * @param roll     - the &lt;code&gt;TargetRoll&lt;/code&gt; for the ignition roll
&nbsp;     * @param bInferno - &lt;code&gt;true&lt;/code&gt; if the fire is an inferno fire. If this
&nbsp;     *                 value is &lt;code&gt;false&lt;/code&gt; the hex will be lit only if it
&nbsp;     *                 contains Woods,jungle or a Building.
&nbsp;     * @param entityId - the entityId responsible for the ignite attempt. If the
&nbsp;     *                 value is Entity.NONE, then the roll attempt will not be
&nbsp;     *                 included in the report.
&nbsp;     */
&nbsp;    public boolean checkIgnition(Coords c, TargetRoll roll, boolean bInferno, int entityId,
&nbsp;                                 Vector&lt;Report&gt; vPhaseReport) {
&nbsp;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
&nbsp;
&nbsp;        // The hex might be null due to spreadFire translation
&nbsp;        // goes outside of the board limit.
<b class="nc">&nbsp;        if (null == hex) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The hex may already be on fire.
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!bInferno &amp;&amp; !hex.isIgnitable()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int fireRoll = Compute.d6(2);</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (entityId != Entity.NONE) {</b>
<b class="nc">&nbsp;            r = new Report(3430);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.subject = entityId;</b>
<b class="nc">&nbsp;            r.add(roll.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(roll.getDesc());</b>
<b class="nc">&nbsp;            r.add(fireRoll);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (fireRoll &gt;= roll.getValue()) {</b>
<b class="nc">&nbsp;            ignite(c, Terrains.FIRE_LVL_NORMAL, vPhaseReport);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the hex is set on fire with the specified roll. Of
&nbsp;     * course, also checks to see that fire is possible in the specified hex.
&nbsp;     * This version of the method will not report the attempt roll.
&nbsp;     *
&nbsp;     * @param c        - the &lt;code&gt;Coords&lt;/code&gt; to be lit.
&nbsp;     * @param roll     - the &lt;code&gt;int&lt;/code&gt; target number for the ignition roll
&nbsp;     * @param bInferno - &lt;code&gt;true&lt;/code&gt; if the fire can be lit in any terrain. If
&nbsp;     *                 this value is &lt;code&gt;false&lt;/code&gt; the hex will be lit only if
&nbsp;     *                 it contains Woods, jungle or a Building.
&nbsp;     */
&nbsp;    public boolean checkIgnition(Coords c, TargetRoll roll, boolean bInferno) {
<b class="nc">&nbsp;        return checkIgnition(c, roll, bInferno, Entity.NONE, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the hex is set on fire with the specified roll. Of
&nbsp;     * course, also checks to see that fire is possible in the specified hex.
&nbsp;     * This version of the method will not report the attempt roll.
&nbsp;     *
&nbsp;     * @param c    - the &lt;code&gt;Coords&lt;/code&gt; to be lit.
&nbsp;     * @param roll - the &lt;code&gt;int&lt;/code&gt; target number for the ignition roll
&nbsp;     */
&nbsp;    public boolean checkIgnition(Coords c, TargetRoll roll) {
&nbsp;        // default signature, assuming only woods can burn
<b class="nc">&nbsp;        return checkIgnition(c, roll, false, Entity.NONE, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * add fire to a hex
&nbsp;     *
&nbsp;     * @param c         - the &lt;code&gt;Coords&lt;/code&gt; of the hex to be set on fire
&nbsp;     * @param fireLevel - The level of fire, see Terrains
&nbsp;     */
&nbsp;    public void ignite(Coords c, int fireLevel, Vector&lt;Report&gt; vReport) {
&nbsp;        // you can&#39;t start fires in some planetary conditions!
<b class="nc">&nbsp;        if (null != game.getPlanetaryConditions().cannotStartFire()) {</b>
<b class="nc">&nbsp;            if (null != vReport) {</b>
<b class="nc">&nbsp;                Report r = new Report(3007);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.add(game.getPlanetaryConditions().cannotStartFire());</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_START_FIRE)) {</b>
<b class="nc">&nbsp;            if (null != vReport) {</b>
<b class="nc">&nbsp;                Report r = new Report(3008);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                vReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        if (null == hex) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Report r = new Report(3005);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.add(c.getBoardNum());</b>
<b class="nc">&nbsp;        r.type = Report.PUBLIC;</b>
&nbsp;
&nbsp;        // Adjust report message for inferno types
<b class="nc">&nbsp;        switch (fireLevel) {</b>
&nbsp;            case Terrains.FIRE_LVL_INFERNO:
<b class="nc">&nbsp;                r.messageId = 3006;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Terrains.FIRE_LVL_INFERNO_BOMB:
<b class="nc">&nbsp;                r.messageId = 3003;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Terrains.FIRE_LVL_INFERNO_IV:
<b class="nc">&nbsp;                r.messageId = 3004;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        // report it
<b class="nc">&nbsp;        if (null != vReport) {</b>
<b class="nc">&nbsp;            vReport.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, fireLevel));</b>
<b class="nc">&nbsp;        sendChangedHex(c);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * remove fire from a hex
&nbsp;     *
&nbsp;     * @param fireCoords
&nbsp;     * @param reason
&nbsp;     */
&nbsp;    public void removeFire(Coords fireCoords, String reason) {
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(fireCoords);</b>
<b class="nc">&nbsp;        if (null == hex) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        hex.removeTerrain(Terrains.FIRE);</b>
<b class="nc">&nbsp;        hex.resetFireTurn();</b>
<b class="nc">&nbsp;        sendChangedHex(fireCoords);</b>
&nbsp;        // fire goes out
<b class="nc">&nbsp;        Report r = new Report(5170, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.add(fireCoords.getBoardNum());</b>
<b class="nc">&nbsp;        r.add(reason);</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called when a fire is burning. Called 3 times per fire hex.
&nbsp;     *
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; x-coordinate of the hex
&nbsp;     */
&nbsp;    public void addSmoke(ArrayList&lt;Coords&gt; coords, int windDir, boolean bInferno) {
&nbsp;        // if a tornado, then no smoke!
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().getWindStrength() &gt; PlanetaryConditions.WI_STORM) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int smokeLevel = 0;</b>
<b class="nc">&nbsp;        for (Coords smokeCoords : coords) {</b>
<b class="nc">&nbsp;            IHex smokeHex = game.getBoard().getHex(smokeCoords);</b>
&nbsp;            Report r;
<b class="nc">&nbsp;            if (smokeHex == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // Have to check if it&#39;s inferno smoke or from a heavy/hardened
&nbsp;            // building
&nbsp;            // - heavy smoke from those
<b class="nc">&nbsp;            if (bInferno || (Building.MEDIUM &lt; smokeHex.terrainLevel(Terrains.FUEL_TANK))</b>
<b class="nc">&nbsp;                    || (Building.MEDIUM &lt; smokeHex.terrainLevel(Terrains.BUILDING))) {</b>
<b class="nc">&nbsp;                if (smokeHex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</b>
&nbsp;                    // heavy smoke fills hex
<b class="nc">&nbsp;                    r = new Report(5180, Report.PUBLIC);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(5185, Report.PUBLIC);</b>
&nbsp;                }
<b class="nc">&nbsp;                smokeLevel = SmokeCloud.SMOKE_HEAVY;</b>
<b class="nc">&nbsp;                r.add(smokeCoords.getBoardNum());</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (smokeHex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</b>
&nbsp;                    // heavy smoke overpowers light
<b class="nc">&nbsp;                    r = new Report(5190, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(smokeCoords.getBoardNum());</b>
<b class="nc">&nbsp;                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else if (smokeHex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT) {</b>
&nbsp;                    // light smoke continue to fill hex
<b class="nc">&nbsp;                    r = new Report(5195, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(smokeCoords.getBoardNum());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    smokeLevel = Math.max(smokeLevel, SmokeCloud.SMOKE_LIGHT);</b>
&nbsp;                    // light smoke fills hex
<b class="nc">&nbsp;                    r = new Report(5200, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(smokeCoords.getBoardNum());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        createSmoke(coords, smokeLevel, 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Scans the boards directory for map boards of the appropriate size and
&nbsp;     * returns them.
&nbsp;     *
&nbsp;     * @return A list of relative paths to the board files, without the &#39;.board&#39;
&nbsp;     * extension.
&nbsp;     */
&nbsp;    private List&lt;String&gt; scanForBoardsInDir(final File boardDir, final String basePath,
&nbsp;                                            final BoardDimensions dimensions, List&lt;String&gt; boards) {
<b class="nc">&nbsp;        if (boardDir == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;must provide searchDir&quot;);</b>
<b class="nc">&nbsp;        } else if (basePath == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;must provide basePath&quot;);</b>
<b class="nc">&nbsp;        } else if (dimensions == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;must provide dimensions&quot;);</b>
<b class="nc">&nbsp;        } else if (boards == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;must provide boards&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String[] fileList = boardDir.list();</b>
<b class="nc">&nbsp;        if (fileList != null) {</b>
<b class="nc">&nbsp;            for (String filename : fileList) {</b>
<b class="nc">&nbsp;                File filePath = new MegaMekFile(boardDir, filename).getFile();</b>
<b class="nc">&nbsp;                if (filePath.isDirectory()) {</b>
<b class="nc">&nbsp;                    scanForBoardsInDir(new MegaMekFile(boardDir, filename).getFile(),</b>
<b class="nc">&nbsp;                            basePath.concat(File.separator).concat(filename), dimensions, boards);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (filename.endsWith(&quot;.board&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        if (Board.boardIsSize(filePath, dimensions)) {</b>
<b class="nc">&nbsp;                            boards.add(basePath.concat(File.separator)</b>
<b class="nc">&nbsp;                                    .concat(filename.substring(0, filename.lastIndexOf(&quot;.&quot;))));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return boards;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Recursively scan the specified path to determine the board sizes
&nbsp;     * available.
&nbsp;     *
&nbsp;     * @param searchDir The directory to search below this path (may be null for all
&nbsp;     *                  in base path).
&nbsp;     * @param sizes     Where to store the discovered board sizes
&nbsp;     */
&nbsp;    private void getBoardSizesInDir(final File searchDir, TreeSet&lt;BoardDimensions&gt; sizes) {
<b class="nc">&nbsp;        if (searchDir == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;must provide searchDir&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (sizes == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;must provide sizes&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String[] file_list = searchDir.list();</b>
&nbsp;
<b class="nc">&nbsp;        if (file_list != null) {</b>
<b class="nc">&nbsp;            for (String filename : file_list) {</b>
<b class="nc">&nbsp;                File query_file = new File(searchDir, filename);</b>
&nbsp;
<b class="nc">&nbsp;                if (query_file.isDirectory()) {</b>
<b class="nc">&nbsp;                    getBoardSizesInDir(query_file, sizes);</b>
&nbsp;                } else {
&nbsp;                    try {
<b class="nc">&nbsp;                        if (filename.endsWith(&quot;.board&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            BoardDimensions size = Board.getSize(query_file);</b>
<b class="nc">&nbsp;                            if (size == null) {</b>
<b class="nc">&nbsp;                                throw new Exception();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            sizes.add(Board.getSize(query_file));</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (Exception e) {</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Error parsing board: &quot; + query_file.getAbsolutePath(), e);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get a list of the available board sizes from the boards data directory.
&nbsp;     *
&nbsp;     * @return A Set containing all the available board sizes.
&nbsp;     */
&nbsp;    private Set&lt;BoardDimensions&gt; getBoardSizes() {
<b class="nc">&nbsp;        TreeSet&lt;BoardDimensions&gt; board_sizes = new TreeSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        File boards_dir = Configuration.boardsDir();</b>
&nbsp;        // Slightly overkill sanity check...
<b class="nc">&nbsp;        if (boards_dir.isDirectory()) {</b>
<b class="nc">&nbsp;            getBoardSizesInDir(boards_dir, board_sizes);</b>
&nbsp;        }
<b class="nc">&nbsp;        boards_dir = new File(Configuration.userdataDir(), Configuration.boardsDir().toString());</b>
<b class="nc">&nbsp;        if (boards_dir.isDirectory()) {</b>
<b class="nc">&nbsp;            getBoardSizesInDir(boards_dir, board_sizes);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return board_sizes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Scan for map boards with the specified dimensions.
&nbsp;     *
&nbsp;     * @param dimensions The desired board dimensions.
&nbsp;     * @return A list of path names, minus the &#39;.board&#39; extension, relative to
&nbsp;     * the boards data directory.
&nbsp;     */
&nbsp;    private ArrayList&lt;String&gt; scanForBoards(final BoardDimensions dimensions) {
<b class="nc">&nbsp;        ArrayList&lt;String&gt; boards = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        File boardDir = Configuration.boardsDir();</b>
<b class="nc">&nbsp;        boards.add(MapSettings.BOARD_GENERATED);</b>
&nbsp;        // just a check...
<b class="nc">&nbsp;        if (!boardDir.isDirectory()) {</b>
<b class="nc">&nbsp;            return boards;</b>
&nbsp;        }
&nbsp;
&nbsp;        // scan files
<b class="nc">&nbsp;        List&lt;String&gt; tempList = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Comparator&lt;String&gt; sortComp = StringUtil.stringComparator();</b>
<b class="nc">&nbsp;        scanForBoardsInDir(boardDir, &quot;&quot;, dimensions, tempList);</b>
&nbsp;        // Check boards in userData dir
<b class="nc">&nbsp;        boardDir = new File(Configuration.userdataDir(), Configuration.boardsDir().toString());</b>
<b class="nc">&nbsp;        if (boardDir.isDirectory()) {</b>
<b class="nc">&nbsp;            scanForBoardsInDir(boardDir, &quot;&quot;, dimensions, tempList);</b>
&nbsp;        }
&nbsp;        // if there are any boards, add these:
<b class="nc">&nbsp;        if (tempList.size() &gt; 0) {</b>
<b class="nc">&nbsp;            boards.add(MapSettings.BOARD_RANDOM);</b>
<b class="nc">&nbsp;            boards.add(MapSettings.BOARD_SURPRISE);</b>
<b class="nc">&nbsp;            tempList.sort(sortComp);</b>
<b class="nc">&nbsp;            boards.addAll(tempList);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return boards;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return whether this game is double blind or not and we should be blind in
&nbsp;     * the current phase
&nbsp;     */
&nbsp;    private boolean doBlind() {
<b class="nc">&nbsp;        return game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;               &amp;&amp; game.getPhase().isDuringOrAfter(IGame.Phase.PHASE_DEPLOYMENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean suppressBlindBV() {
<b class="nc">&nbsp;        return game.getOptions().booleanOption(OptionsConstants.ADVANCED_SUPPRESS_DB_BV);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * In a double-blind game, update only visible entities. Otherwise, update
&nbsp;     * everyone
&nbsp;     */
&nbsp;    public void entityUpdate(int nEntityID) {
<b class="nc">&nbsp;        entityUpdate(nEntityID, new Vector&lt;&gt;(), true, null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * In a double-blind game, update only visible entities. Otherwise, update
&nbsp;     * everyone
&nbsp;     *
&nbsp;     * @param updateVisibility Flag that determines if whoCanSee needs to be
&nbsp;     *                         called to update who can see the entity for
&nbsp;     *                         double-blind games.
&nbsp;     */
&nbsp;    public void entityUpdate(int nEntityID, Vector&lt;UnitLocation&gt; movePath, boolean updateVisibility,
&nbsp;                             Map&lt;EntityTargetPair, LosEffects&gt; losCache) {
<b class="nc">&nbsp;        Entity eTarget = game.getEntity(nEntityID);</b>
<b class="nc">&nbsp;        if (eTarget == null) {</b>
<b class="nc">&nbsp;            if (game.getOutOfGameEntity(nEntityID) != null) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;S: attempted to send entity update for out of game entity, id was &quot; + nEntityID);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;S: attempted to send entity update for null entity, id was &quot; + nEntityID);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return; // do not send the update it will crash the client</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we&#39;re doing double blind, be careful who can see it...
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            Vector&lt;IPlayer&gt; playersVector = game.getPlayersVector();</b>
&nbsp;            Vector&lt;IPlayer&gt; vCanSee;
<b class="nc">&nbsp;            if (updateVisibility) {</b>
<b class="nc">&nbsp;                vCanSee = whoCanSee(eTarget, true, losCache);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                vCanSee = eTarget.getWhoCanSee();</b>
&nbsp;            }
&nbsp;
&nbsp;            // If this unit has ECM, players with units affected by the ECM will
&nbsp;            //  need to know about this entity, even if they can&#39;t see it.
&nbsp;            //  Otherwise, the client can&#39;t properly report things like to-hits.
<b class="nc">&nbsp;            if ((eTarget.getECMRange() &gt; 0) &amp;&amp; (eTarget.getPosition() != null)) {</b>
<b class="nc">&nbsp;                int ecmRange = eTarget.getECMRange();</b>
<b class="nc">&nbsp;                Coords pos = eTarget.getPosition();</b>
<b class="nc">&nbsp;                for (Entity ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if ((ent.getPosition() != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (pos.distance(ent.getPosition()) &lt;= ecmRange)) {</b>
<b class="nc">&nbsp;                        if (!vCanSee.contains(ent.getOwner())) {</b>
<b class="nc">&nbsp;                            vCanSee.add(ent.getOwner());</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // send an entity update to everyone who can see
<b class="nc">&nbsp;            Packet pack = createEntityPacket(nEntityID, movePath);</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; vCanSee.size(); x++) {</b>
<b class="nc">&nbsp;                IPlayer p = vCanSee.elementAt(x);</b>
<b class="nc">&nbsp;                send(p.getId(), pack);</b>
&nbsp;            }
&nbsp;            // send an entity delete to everyone else
<b class="nc">&nbsp;            pack = createRemoveEntityPacket(nEntityID,</b>
<b class="nc">&nbsp;                                            eTarget.getRemovalCondition());</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; playersVector.size(); x++) {</b>
<b class="nc">&nbsp;                if (!vCanSee.contains(playersVector.elementAt(x))) {</b>
<b class="nc">&nbsp;                    IPlayer p = playersVector.elementAt(x);</b>
<b class="nc">&nbsp;                    send(p.getId(), pack);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            entityUpdateLoadedUnits(eTarget, vCanSee, playersVector);</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // But if we&#39;re not, then everyone can see.
<b class="nc">&nbsp;            send(createEntityPacket(nEntityID, movePath));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Whenever updating an Entity, we also need to update all of its loaded
&nbsp;     * Entity&#39;s, otherwise it could cause issues with Clients.
&nbsp;     *
&nbsp;     * @param loader        An Entity being updated that is transporting units that should
&nbsp;     *                      also send an update
&nbsp;     * @param vCanSee       The list of Players who can see the loader.
&nbsp;     * @param playersVector The list of all Players
&nbsp;     */
&nbsp;    private void entityUpdateLoadedUnits(Entity loader,
&nbsp;                                         Vector&lt;IPlayer&gt; vCanSee, Vector&lt;IPlayer&gt; playersVector) {
&nbsp;        Packet pack;
&nbsp;
&nbsp;        // In double-blind, the client may not know about the loaded units,
&nbsp;        // so we need to send them.
<b class="nc">&nbsp;        for (Entity eLoaded : loader.getLoadedUnits()) {</b>
&nbsp;            // send an entity update to everyone who can see
<b class="nc">&nbsp;            pack = createEntityPacket(eLoaded.getId(), null);</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; vCanSee.size(); x++) {</b>
<b class="nc">&nbsp;                IPlayer p = vCanSee.elementAt(x);</b>
<b class="nc">&nbsp;                send(p.getId(), pack);</b>
&nbsp;            }
&nbsp;            // send an entity delete to everyone else
<b class="nc">&nbsp;            pack = createRemoveEntityPacket(eLoaded.getId(),</b>
<b class="nc">&nbsp;                                            eLoaded.getRemovalCondition());</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; playersVector.size(); x++) {</b>
<b class="nc">&nbsp;                if (!vCanSee.contains(playersVector.elementAt(x))) {</b>
<b class="nc">&nbsp;                    IPlayer p = playersVector.elementAt(x);</b>
<b class="nc">&nbsp;                    send(p.getId(), pack);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            entityUpdateLoadedUnits(eLoaded, vCanSee, playersVector);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of which players can see this entity, always allowing
&nbsp;     * for sensor detections.
&nbsp;     */
&nbsp;    private Vector&lt;IPlayer&gt; whoCanSee(Entity entity) {
<b class="nc">&nbsp;        return whoCanSee(entity, true, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of which players can see the given entity, optionally
&nbsp;     * allowing for sensors to count.
&nbsp;     *
&nbsp;     * @param entity     The entity to check visibility for
&nbsp;     * @param useSensors A flag that determines whether sensors are allowed
&nbsp;     * @return A vector of the players who can see the entity
&nbsp;     */
&nbsp;    private Vector&lt;IPlayer&gt; whoCanSee(Entity entity, boolean useSensors,
&nbsp;            Map&lt;EntityTargetPair, LosEffects&gt; losCache) {
<b class="nc">&nbsp;        if (losCache == null) {</b>
<b class="nc">&nbsp;            losCache = new HashMap&lt;&gt;();</b>
&nbsp;        }
&nbsp;        // Some times Null entities are sent to this
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            return new Vector&lt;&gt;();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;ECMInfo&gt; allECMInfo = null;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS) &amp;&amp; useSensors) {</b>
<b class="nc">&nbsp;            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</b>
<b class="nc">&nbsp;                    .getEntitiesVector());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean bTeamVision = game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; vEntities = game.getEntitiesVector();</b>
&nbsp;
<b class="nc">&nbsp;        Vector&lt;IPlayer&gt; vCanSee = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        vCanSee.addElement(entity.getOwner());</b>
<b class="nc">&nbsp;        if (bTeamVision) {</b>
<b class="nc">&nbsp;            addTeammates(vCanSee, entity.getOwner());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Deal with players who can see all.
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; p = game.getPlayers(); p.hasMoreElements();) {</b>
<b class="nc">&nbsp;            IPlayer player = p.nextElement();</b>
&nbsp;
<b class="nc">&nbsp;            if (player.canSeeAll() &amp;&amp; !vCanSee.contains(player)) {</b>
<b class="nc">&nbsp;                vCanSee.addElement(player);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If the entity is hidden, skip; no one else will be able to see it.
<b class="nc">&nbsp;        if (entity.isHidden()) {</b>
<b class="nc">&nbsp;            return vCanSee;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity spotter : vEntities) {</b>
&nbsp;            // Certain conditions make the spotter ineligible
<b class="nc">&nbsp;            if (!spotter.isActive() || spotter.isOffBoard()</b>
<b class="nc">&nbsp;                    || vCanSee.contains(spotter.getOwner())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // See if the LosEffects is cached, and if not cache it
<b class="nc">&nbsp;            EntityTargetPair etp = new EntityTargetPair(spotter, entity);</b>
<b class="nc">&nbsp;            LosEffects los = losCache.get(etp);</b>
<b class="nc">&nbsp;            if (los == null) {</b>
<b class="nc">&nbsp;                los = LosEffects.calculateLos(game, spotter.getId(), entity);</b>
<b class="nc">&nbsp;                losCache.put(etp, los);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (Compute.canSee(game, spotter, entity, useSensors, los,</b>
&nbsp;                    allECMInfo)) {
<b class="nc">&nbsp;                if (!vCanSee.contains(spotter.getOwner())) {</b>
<b class="nc">&nbsp;                    vCanSee.addElement(spotter.getOwner());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bTeamVision) {</b>
<b class="nc">&nbsp;                    addTeammates(vCanSee, spotter.getOwner());</b>
&nbsp;                }
<b class="nc">&nbsp;                addObservers(vCanSee);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return vCanSee;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine which players can detect the given entity with sensors.
&nbsp;     * Because recomputing ECM and LosEffects frequently can get expensive, this
&nbsp;     * data can be cached and passed in.
&nbsp;     *
&nbsp;     * @param entity        The Entity being detected.
&nbsp;     * @param allECMInfo    Cached ECMInfo for all Entities in the game.
&nbsp;     * @param losCache      Cached LosEffects for particular Entity/Targetable
&nbsp;     *                      pairs.  Can be passed in null.
&nbsp;     * @return
&nbsp;     */
&nbsp;    private Vector&lt;IPlayer&gt; whoCanDetect(Entity entity,
&nbsp;            List&lt;ECMInfo&gt; allECMInfo,
&nbsp;            Map&lt;EntityTargetPair, LosEffects&gt; losCache) {
<b class="nc">&nbsp;        if (losCache == null) {</b>
<b class="nc">&nbsp;            losCache = new HashMap&lt;&gt;();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean bTeamVision = game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; vEntities = game.getEntitiesVector();</b>
&nbsp;
<b class="nc">&nbsp;        Vector&lt;IPlayer&gt; vCanDetect = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;        // If the entity is hidden, skip; no one else will be able to detect it
<b class="nc">&nbsp;        if (entity.isHidden() || entity.isOffBoard()) {</b>
<b class="nc">&nbsp;            return vCanDetect;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Entity spotter : vEntities) {</b>
<b class="nc">&nbsp;            if (!spotter.isActive() || spotter.isOffBoard()</b>
<b class="nc">&nbsp;                    || vCanDetect.contains(spotter.getOwner())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // See if the LosEffects is cached, and if not cache it
<b class="nc">&nbsp;            EntityTargetPair etp = new EntityTargetPair(spotter, entity);</b>
<b class="nc">&nbsp;            LosEffects los = losCache.get(etp);</b>
<b class="nc">&nbsp;            if (los == null) {</b>
<b class="nc">&nbsp;                los = LosEffects.calculateLos(game, spotter.getId(), entity);</b>
<b class="nc">&nbsp;                losCache.put(etp, los);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (Compute.inSensorRange(game, los, spotter, entity, allECMInfo)) {</b>
<b class="nc">&nbsp;                if (!vCanDetect.contains(spotter.getOwner())) {</b>
<b class="nc">&nbsp;                    vCanDetect.addElement(spotter.getOwner());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bTeamVision) {</b>
<b class="nc">&nbsp;                    addTeammates(vCanDetect, spotter.getOwner());</b>
&nbsp;                }
<b class="nc">&nbsp;                addObservers(vCanDetect);</b>
&nbsp;            }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;        return vCanDetect;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds teammates of a player to the Vector. Utility function for whoCanSee.
&nbsp;     */
&nbsp;    private void addTeammates(Vector&lt;IPlayer&gt; vector, IPlayer player) {
<b class="nc">&nbsp;        Vector&lt;IPlayer&gt; playersVector = game.getPlayersVector();</b>
<b class="nc">&nbsp;        for (int j = 0; j &lt; playersVector.size(); j++) {</b>
<b class="nc">&nbsp;            IPlayer p = playersVector.elementAt(j);</b>
<b class="nc">&nbsp;            if (!player.isEnemyOf(p) &amp;&amp; !vector.contains(p)) {</b>
<b class="nc">&nbsp;                vector.addElement(p);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds observers to the Vector. Utility function for whoCanSee.
&nbsp;     */
&nbsp;    private void addObservers(Vector&lt;IPlayer&gt; vector) {
<b class="nc">&nbsp;        Vector&lt;IPlayer&gt; playersVector = game.getPlayersVector();</b>
<b class="nc">&nbsp;        for (int j = 0; j &lt; playersVector.size(); j++) {</b>
<b class="nc">&nbsp;            IPlayer p = playersVector.elementAt(j);</b>
<b class="nc">&nbsp;            if (p.isObserver() &amp;&amp; !vector.contains(p)) {</b>
<b class="nc">&nbsp;                vector.addElement(p);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send the complete list of entities to the players. If double_blind is in
&nbsp;     * effect, enforce it by filtering the entities
&nbsp;     */
&nbsp;    private void entityAllUpdate() {
&nbsp;        // If double-blind is in effect, filter each players&#39; list individually,
&nbsp;        // and then quit out...
<b class="nc">&nbsp;        if (doBlind()) {</b>
<b class="nc">&nbsp;            Vector&lt;IPlayer&gt; playersVector = game.getPlayersVector();</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; playersVector.size(); x++) {</b>
<b class="nc">&nbsp;                IPlayer p = playersVector.elementAt(x);</b>
<b class="nc">&nbsp;                send(p.getId(), createFilteredEntitiesPacket(p, null));</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Otherwise, send the full list.
<b class="nc">&nbsp;        send(createEntitiesPacket());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Filters an entity vector according to LOS
&nbsp;     */
&nbsp;    private List&lt;Entity&gt; filterEntities(IPlayer pViewer,
&nbsp;            List&lt;Entity&gt; vEntities,
&nbsp;            Map&lt;EntityTargetPair, LosEffects&gt; losCache) {
<b class="nc">&nbsp;        if (losCache == null) {</b>
<b class="nc">&nbsp;            losCache = new HashMap&lt;&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Entity&gt; vCanSee = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        Vector&lt;Entity&gt; vMyEntities = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        boolean bTeamVision = game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);</b>
&nbsp;
&nbsp;        // If they can see all, return the input list
<b class="nc">&nbsp;        if (pViewer.canSeeAll()) {</b>
<b class="nc">&nbsp;            return vEntities;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;ECMInfo&gt; allECMInfo = null;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</b>
<b class="nc">&nbsp;            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game.getEntitiesVector());</b>
&nbsp;        }
&nbsp;
&nbsp;        // If they&#39;re an observer, they can see anything seen by any enemy.
<b class="nc">&nbsp;        if (pViewer.isObserver()) {</b>
<b class="nc">&nbsp;            vMyEntities.addAll(vEntities);</b>
<b class="nc">&nbsp;            for (Entity a : vMyEntities) {</b>
<b class="nc">&nbsp;                for (Entity b : vMyEntities) {</b>
<b class="nc">&nbsp;                    if (a.isEnemyOf(b)</b>
<b class="nc">&nbsp;                        &amp;&amp; Compute.canSee(game, b, a, true, null, allECMInfo)) {</b>
<b class="nc">&nbsp;                        addVisibleEntity(vCanSee, a);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return vCanSee;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If they aren&#39;t an observer and can&#39;t see all, create the list of
&nbsp;        // &quot;friendly&quot; units.
<b class="nc">&nbsp;        for (Entity e : vEntities) {</b>
<b class="nc">&nbsp;            if ((e.getOwner() == pViewer) || (bTeamVision &amp;&amp; !e.getOwner().isEnemyOf(pViewer))) {</b>
<b class="nc">&nbsp;                vMyEntities.addElement(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Then, break down the list by whether they&#39;re friendly,
&nbsp;        // or whether or not any friendly unit can see them.
<b class="nc">&nbsp;        for (Entity e : vEntities) {</b>
&nbsp;            // If it&#39;s their own unit, obviously, they can see it.
<b class="nc">&nbsp;            if (vMyEntities.contains(e)) {</b>
<b class="nc">&nbsp;                addVisibleEntity(vCanSee, e);</b>
<b class="nc">&nbsp;                continue;</b>
<b class="nc">&nbsp;            } else if (e.isHidden()) {</b>
&nbsp;                // If it&#39;s NOT friendly and is hidden, they can&#39;t see it,
&nbsp;                // period.
&nbsp;                // LOS doesn&#39;t matter.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Entity spotter : vMyEntities) {</b>
&nbsp;
&nbsp;                // If they&#39;re off-board, skip it; they can&#39;t see anything.
<b class="nc">&nbsp;                if (spotter.isOffBoard()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // See if the LosEffects is cached, and if not cache it
<b class="nc">&nbsp;                EntityTargetPair etp = new EntityTargetPair(spotter, e);</b>
<b class="nc">&nbsp;                LosEffects los = losCache.get(etp);</b>
<b class="nc">&nbsp;                if (los == null) {</b>
<b class="nc">&nbsp;                    los = LosEffects.calculateLos(game, spotter.getId(), e);</b>
<b class="nc">&nbsp;                    losCache.put(etp, los);</b>
&nbsp;                }
&nbsp;                // Otherwise, if they can see the entity in question
<b class="nc">&nbsp;                if (Compute.canSee(game, spotter, e, true, los, allECMInfo)) {</b>
<b class="nc">&nbsp;                    addVisibleEntity(vCanSee, e);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If this unit has ECM, players with units affected by the ECM
&nbsp;                //  will need to know about this entity, even if they can&#39;t see
&nbsp;                //  it.  Otherwise, the client can&#39;t properly report things
&nbsp;                //  like to-hits.
<b class="nc">&nbsp;                if ((e.getECMRange() &gt; 0) &amp;&amp; (e.getPosition() != null) &amp;&amp;</b>
<b class="nc">&nbsp;                    (spotter.getPosition() != null)) {</b>
<b class="nc">&nbsp;                    int ecmRange = e.getECMRange();</b>
<b class="nc">&nbsp;                    Coords pos = e.getPosition();</b>
<b class="nc">&nbsp;                    if (pos.distance(spotter.getPosition()) &lt;= ecmRange) {</b>
<b class="nc">&nbsp;                        addVisibleEntity(vCanSee, e);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return vCanSee;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Recursive method to add an &lt;code&gt;Entity&lt;/code&gt; and all of its transported
&nbsp;     * units to the list of units visible to a particular player. It is
&nbsp;     * important to ensure that if a unit is in the list of visible units then
&nbsp;     * all of its transported units (and their transported units, and so on) are
&nbsp;     * also considered visible, otherwise it can lead to issues. This method
&nbsp;     * also ensures that no duplicate Entities are added.
&nbsp;     *
&nbsp;     * @param vCanSee A collection of units that can be see
&nbsp;     * @param e       An Entity that is seen and needs to be added to the collection
&nbsp;     *                of seen entities. All of
&nbsp;     */
&nbsp;    private void addVisibleEntity(Vector&lt;Entity&gt; vCanSee, Entity e) {
<b class="nc">&nbsp;        if (!vCanSee.contains(e)) {</b>
<b class="nc">&nbsp;            vCanSee.add(e);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity transported : e.getLoadedUnits()) {</b>
<b class="nc">&nbsp;            addVisibleEntity(vCanSee, transported);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Filter a report vector for double blind.
&nbsp;     *
&nbsp;     * @param originalReportVector the original &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt;
&nbsp;     * @param p                    the &lt;code&gt;Player&lt;/code&gt; who should see stuff only visible to
&nbsp;     *                             him
&nbsp;     * @return the &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; with stuff only Player p can see
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; filterReportVector(Vector&lt;Report&gt; originalReportVector, IPlayer p) {
&nbsp;        // If no double blind, no filtering to do
<b class="nc">&nbsp;        if (!doBlind()) {</b>
<b class="nc">&nbsp;            return new Vector&lt;&gt;(originalReportVector);</b>
&nbsp;        }
&nbsp;        // But if it is, then filter everything properly.
<b class="nc">&nbsp;        Vector&lt;Report&gt; filteredReportVector = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Report r : originalReportVector) {</b>
<b class="nc">&nbsp;            Report filteredReport = filterReport(r, p, false);</b>
<b class="nc">&nbsp;            if (filteredReport != null) {</b>
<b class="nc">&nbsp;                filteredReportVector.addElement(filteredReport);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return filteredReportVector;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter a single report so that the correct double-blind obscuration takes
&nbsp;     * place. To mark a message as &quot;this should be visible to anyone seeing this
&nbsp;     * entity&quot; set r.subject to the entity id to mark a message as &quot;only visible
&nbsp;     * to the player&quot; set r.player to that player&#39;s id and set r.type to
&nbsp;     * Report.PLAYER to mark a message as visible to all, set r.type to
&nbsp;     * Report.PUBLIC
&nbsp;     *
&nbsp;     * @param r         the Report to filter
&nbsp;     * @param p         the Player that we are going to send the filtered report to
&nbsp;     * @param omitCheck boolean indicating that this report happened in the past, so we
&nbsp;     *                  no longer have access to the Player
&nbsp;     * @return a new Report, which has possibly been obscured
&nbsp;     */
&nbsp;    private Report filterReport(Report r, IPlayer p, boolean omitCheck) {
<b class="nc">&nbsp;        if ((r.subject == Entity.NONE) &amp;&amp; (r.type != Report.PLAYER) &amp;&amp; (r.type != Report.PUBLIC)) {</b>
&nbsp;            // Reports that don&#39;t have a subject should be public.
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Attempting to filter a Report object that is not public yet &quot;</b>
&nbsp;                            + &quot;but has no subject.\n\t\tmessageId: &quot; + r.messageId);
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((r.type == Report.PUBLIC) || ((p == null) &amp;&amp; !omitCheck)) {</b>
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
<b class="nc">&nbsp;        Entity entity = game.getEntity(r.subject);</b>
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            entity = game.getOutOfGameEntity(r.subject);</b>
&nbsp;        }
<b class="nc">&nbsp;        IPlayer owner = null;</b>
<b class="nc">&nbsp;        if (entity != null) {</b>
<b class="nc">&nbsp;            owner = entity.getOwner();</b>
&nbsp;            // off board (Artillery) units get treated as public messages
<b class="nc">&nbsp;            if (entity.isOffBoard()) {</b>
<b class="nc">&nbsp;                return r;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((r.type != Report.PLAYER) &amp;&amp; !omitCheck</b>
&nbsp;            &amp;&amp; ((entity == null) || (owner == null))) {
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Attempting to filter a report object that is not public but has a subject (&quot;</b>
&nbsp;                            + entity + &quot;) with owner (&quot; + owner + &quot;).\n\tmessageId: &quot; + r.messageId);
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean shouldObscure = omitCheck</b>
<b class="nc">&nbsp;                                || ((entity != null) &amp;&amp; !entity.hasSeenEntity(p))</b>
<b class="nc">&nbsp;                                || ((r.type == Report.PLAYER) &amp;&amp; (p.getId() != r.player));</b>
&nbsp;        // If suppressing double blind messages, don&#39;t send this report at all.
<b class="nc">&nbsp;        if (game.getOptions()</b>
<b class="nc">&nbsp;                .booleanOption(OptionsConstants.ADVANCED_SUPRESS_ALL_DB_MESSAGES)</b>
&nbsp;            &amp;&amp; shouldObscure) {
&nbsp;            // Mark the original report to indicate it was filtered
<b class="nc">&nbsp;            if (p != null) {</b>
<b class="nc">&nbsp;                r.addObscuredRecipient(p.getName());</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Report copy = new Report(r);</b>
&nbsp;        // Otherwise, obscure data in the report
<b class="nc">&nbsp;        for (int j = 0; j &lt; copy.dataCount(); j++) {</b>
<b class="nc">&nbsp;            if (shouldObscure) {</b>
&nbsp;                // This report should be obscured
<b class="nc">&nbsp;                if (r.isValueObscured(j)) {</b>
<b class="nc">&nbsp;                    copy.hideData(j);</b>
&nbsp;                    // Mark the original report to indicate which players
&nbsp;                    // received an obscured version of it.
<b class="nc">&nbsp;                    if (p != null) {</b>
<b class="nc">&nbsp;                        r.addObscuredRecipient(p.getName());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return copy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return a vector which has as its keys the round number and as its
&nbsp;     *         elements vectors that contain all the reports for the specified player
&nbsp;     *         that round. The reports returned this way are properly filtered for
&nbsp;     *         double blind.
&nbsp;     */
&nbsp;    private Vector&lt;Vector&lt;Report&gt;&gt; filterPastReports(
&nbsp;            Vector&lt;Vector&lt;Report&gt;&gt; pastReports, IPlayer p) {
&nbsp;        // Only actually bother with the filtering if double-blind is in effect.
<b class="nc">&nbsp;        if (!doBlind()) {</b>
<b class="nc">&nbsp;            return pastReports;</b>
&nbsp;        }
&nbsp;        // Perform filtering
<b class="nc">&nbsp;        Vector&lt;Vector&lt;Report&gt;&gt; filteredReports = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Vector&lt;Report&gt; roundReports : pastReports) {</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; filteredRoundReports = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Report r : roundReports) {</b>
<b class="nc">&nbsp;                if (r.isObscuredRecipient(p.getName())) {</b>
<b class="nc">&nbsp;                    r = filterReport(r, null, true);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (r != null) {</b>
<b class="nc">&nbsp;                    filteredRoundReports.addElement(r);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            filteredReports.addElement(filteredRoundReports);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return filteredReports;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates entities graphical &quot;visibility indications&quot; which are used in
&nbsp;     * double-blind games.
&nbsp;     *
&nbsp;     * @param losCache  It can be expensive to have to recompute LoSEffects
&nbsp;     *                  again and again, so in some cases where this may happen,
&nbsp;     *                  the LosEffects are cached.   This can safely be null.
&nbsp;     */
&nbsp;    private void updateVisibilityIndicator(Map&lt;EntityTargetPair, LosEffects&gt; losCache) {
<b class="nc">&nbsp;        if (losCache == null) {</b>
<b class="nc">&nbsp;            losCache = new HashMap&lt;&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;ECMInfo&gt; allECMInfo = null;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</b>
<b class="nc">&nbsp;            allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</b>
<b class="nc">&nbsp;                    .getEntitiesVector());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;Entity&gt; vAllEntities = game.getEntitiesVector();</b>
<b class="nc">&nbsp;        for (Entity e : vAllEntities) {</b>
<b class="nc">&nbsp;            Vector&lt;IPlayer&gt; whoCouldSee = new Vector&lt;&gt;(e.getWhoCanSee());</b>
<b class="nc">&nbsp;            Vector&lt;IPlayer&gt; whoCouldDetect = new Vector&lt;&gt;(e.getWhoCanDetect());</b>
<b class="nc">&nbsp;            e.setVisibleToEnemy(false);</b>
<b class="nc">&nbsp;            e.setDetectedByEnemy(false);</b>
<b class="nc">&nbsp;            e.clearSeenBy();</b>
<b class="nc">&nbsp;            e.clearDetectedBy();</b>
<b class="nc">&nbsp;            Vector&lt;IPlayer&gt; vCanSee = whoCanSee(e, false, losCache);</b>
&nbsp;            // Who can See this unit?
<b class="nc">&nbsp;            for (IPlayer p : vCanSee) {</b>
<b class="nc">&nbsp;                if (e.getOwner().isEnemyOf(p) &amp;&amp; !p.isObserver()) {</b>
<b class="nc">&nbsp;                    e.setVisibleToEnemy(true);</b>
<b class="nc">&nbsp;                    e.setEverSeenByEnemy(true);</b>
&nbsp;                    // If we can see it, it&#39;s detected
<b class="nc">&nbsp;                    e.setDetectedByEnemy(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                e.addBeenSeenBy(p);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Who can Detect this unit?
<b class="nc">&nbsp;            Vector&lt;IPlayer&gt; vCanDetect = whoCanDetect(e, allECMInfo, losCache);</b>
<b class="nc">&nbsp;            for (IPlayer p : vCanDetect) {</b>
<b class="nc">&nbsp;                if (e.getOwner().isEnemyOf(p) &amp;&amp; !p.isObserver()) {</b>
<b class="nc">&nbsp;                    e.setDetectedByEnemy(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                e.addBeenDetectedBy(p);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // If a client can now see/detect this entity, but couldn&#39;t before,
&nbsp;            // then the client needs to be updated with the Entity
<b class="nc">&nbsp;            boolean hasClientWithoutEntity = false;</b>
<b class="nc">&nbsp;            for (IPlayer p : vCanSee) {</b>
<b class="nc">&nbsp;                if (!whoCouldSee.contains(p) &amp;&amp; !whoCouldDetect.contains(p)) {</b>
<b class="nc">&nbsp;                    hasClientWithoutEntity = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!hasClientWithoutEntity) {</b>
<b class="nc">&nbsp;                for (IPlayer p : vCanDetect) {</b>
<b class="nc">&nbsp;                    if (!whoCouldSee.contains(p) &amp;&amp; !whoCouldDetect.contains(p)) {</b>
<b class="nc">&nbsp;                        hasClientWithoutEntity = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hasClientWithoutEntity) {</b>
<b class="nc">&nbsp;                entityUpdate(e.getId(), new Vector&lt;&gt;(), false, losCache);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sendVisibilityIndicator(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if an entity added by the client is valid and if so, adds it to
&nbsp;     * the list
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityAdd(Packet c, int connIndex) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        final List&lt;Entity&gt; entities = (List&lt;Entity&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; entityIds = new ArrayList&lt;&gt;(entities.size());</b>
&nbsp;        // Map client-received to server-given IDs: 
<b class="nc">&nbsp;        Map&lt;Integer, Integer&gt; idMap = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (final Entity entity : entities) {</b>
&nbsp;
&nbsp;            // Verify the entity&#39;s design
<b class="nc">&nbsp;            if (Server.entityVerifier == null) {</b>
<b class="nc">&nbsp;                Server.entityVerifier = EntityVerifier.getInstance(new MegaMekFile(</b>
<b class="nc">&nbsp;                        Configuration.unitsDir(), EntityVerifier.CONFIG_FILENAME).getFile());</b>
&nbsp;            }
&nbsp;
&nbsp;            // Create a TestEntity instance for supported unit types
<b class="nc">&nbsp;            TestEntity testEntity = null;</b>
<b class="nc">&nbsp;            entity.restore();</b>
<b class="nc">&nbsp;            if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                testEntity = new TestMech((Mech) entity, entityVerifier.mechOption, null);</b>
<b class="nc">&nbsp;            } else if ((entity.getEntityType() == Entity.ETYPE_TANK)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getEntityType() != Entity.ETYPE_GUN_EMPLACEMENT)) {</b>
<b class="nc">&nbsp;                if (entity.isSupportVehicle()) {</b>
<b class="nc">&nbsp;                    testEntity = new TestSupportVehicle(entity, entityVerifier.tankOption, null);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    testEntity = new TestTank((Tank) entity, entityVerifier.tankOption, null);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((entity.getEntityType() == Entity.ETYPE_AERO)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getEntityType() != Entity.ETYPE_DROPSHIP)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getEntityType() != Entity.ETYPE_SMALL_CRAFT)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getEntityType() != Entity.ETYPE_FIGHTER_SQUADRON)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getEntityType() != Entity.ETYPE_JUMPSHIP)</b>
<b class="nc">&nbsp;                       &amp;&amp; (entity.getEntityType() != Entity.ETYPE_SPACE_STATION)) {</b>
<b class="nc">&nbsp;                testEntity = new TestAero((Aero) entity, entityVerifier.aeroOption, null);</b>
<b class="nc">&nbsp;            } else if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                testEntity = new TestBattleArmor((BattleArmor) entity, entityVerifier.baOption, null);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (testEntity != null) {</b>
<b class="nc">&nbsp;                StringBuffer sb = new StringBuffer();</b>
<b class="nc">&nbsp;                if (testEntity.correctEntity(sb, TechConstants.getGameTechLevel(game, entity.isClan()))) {</b>
<b class="nc">&nbsp;                    entity.setDesignValid(true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    MegaMek.getLogger().error(sb.toString());</b>
<b class="nc">&nbsp;                    if (game.getOptions().booleanOption(OptionsConstants.ALLOWED_ALLOW_ILLEGAL_UNITS)) {</b>
<b class="nc">&nbsp;                        entity.setDesignValid(false);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        IPlayer cheater = game.getPlayer(connIndex);</b>
<b class="nc">&nbsp;                        sendServerChat(&quot;Player &quot; + cheater.getName()</b>
&nbsp;                                       + &quot; attempted to add an illegal unit design (&quot;
<b class="nc">&nbsp;                                       + entity.getShortNameRaw()</b>
&nbsp;                                       + &quot;), the unit was rejected.&quot;);
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If we&#39;re adding a ProtoMech, calculate it&#39;s unit number.
<b class="nc">&nbsp;            if (entity instanceof Protomech) {</b>
&nbsp;                // How many ProtoMechs does the player already have?
<b class="nc">&nbsp;                int numPlayerProtos = game</b>
<b class="nc">&nbsp;                        .getSelectedEntityCount(new EntitySelector() {</b>
<b class="nc">&nbsp;                            private final int ownerId = entity.getOwnerId();</b>
&nbsp;
&nbsp;                            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                                return (entity instanceof Protomech)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (ownerId == entity.getOwnerId());</b>
&nbsp;                            }
&nbsp;                        });
&nbsp;
&nbsp;                // According to page 54 of the BMRr, ProtoMechs must be
&nbsp;                // deployed in full Points of five, unless circumstances have
&nbsp;                // reduced the number to less than that.
<b class="nc">&nbsp;                entity.setUnitNumber((short) (numPlayerProtos / 5));</b>
&nbsp;            } // End added-ProtoMech
&nbsp;
&nbsp;            // Only assign an entity ID when the client hasn&#39;t.
<b class="nc">&nbsp;            if (Entity.NONE == entity.getId()) {</b>
<b class="nc">&nbsp;                entity.setId(getFreeEntityId());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int clientSideId = entity.getId();</b>
<b class="nc">&nbsp;            game.addEntity(entity);</b>
&nbsp;            
&nbsp;            // Remember which received ID corresponds to which actual ID
<b class="nc">&nbsp;            idMap.put(clientSideId, entity.getId());</b>
&nbsp;
&nbsp;            // Now we relink C3/NC3/C3i to our guys! Yes, this is hackish... but, we
&nbsp;            // do what we must. Its just too bad we have to loop over the entire entities array..
<b class="nc">&nbsp;            if (entity.hasC3() || entity.hasC3i() || entity.hasNavalC3()) {</b>
<b class="nc">&nbsp;                boolean C3iSet = false;</b>
&nbsp;
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
&nbsp;
&nbsp;                    // C3 Checks
<b class="nc">&nbsp;                    if (entity.hasC3()) {</b>
<b class="nc">&nbsp;                        if ((entity.getC3MasterIsUUIDAsString() != null)</b>
<b class="nc">&nbsp;                                &amp;&amp; entity.getC3MasterIsUUIDAsString().equals(e.getC3UUIDAsString())) {</b>
<b class="nc">&nbsp;                            entity.setC3Master(e, false);</b>
<b class="nc">&nbsp;                            entity.setC3MasterIsUUIDAsString(null);</b>
<b class="nc">&nbsp;                        } else if ((e.getC3MasterIsUUIDAsString() != null)</b>
<b class="nc">&nbsp;                                &amp;&amp; e.getC3MasterIsUUIDAsString().equals(entity.getC3UUIDAsString())) {</b>
<b class="nc">&nbsp;                            e.setC3Master(entity, false);</b>
<b class="nc">&nbsp;                            e.setC3MasterIsUUIDAsString(null);</b>
&nbsp;                            // Taharqa: we need to update the other entity for
&nbsp;                            // the
&nbsp;                            // client
&nbsp;                            // or it won&#39;t show up right. I am not sure if I
&nbsp;                            // like
&nbsp;                            // the idea of updating other entities in this
&nbsp;                            // method,
&nbsp;                            // but it
&nbsp;                            // will work for now.
<b class="nc">&nbsp;                            if (!entities.contains(e)) {</b>
<b class="nc">&nbsp;                                entityUpdate(e.getId());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // C3i Checks
<b class="nc">&nbsp;                    if (entity.hasC3i() &amp;&amp; !C3iSet) {</b>
<b class="nc">&nbsp;                        entity.setC3NetIdSelf();</b>
<b class="nc">&nbsp;                        int pos = 0;</b>
<b class="nc">&nbsp;                        while (pos &lt; Entity.MAX_C3i_NODES) {</b>
&nbsp;                            // We&#39;ve found a network, join it.
<b class="nc">&nbsp;                            if ((entity.getC3iNextUUIDAsString(pos) != null)</b>
<b class="nc">&nbsp;                                    &amp;&amp; (e.getC3UUIDAsString() != null)</b>
<b class="nc">&nbsp;                                    &amp;&amp; entity.getC3iNextUUIDAsString(pos)</b>
<b class="nc">&nbsp;                                    .equals(e.getC3UUIDAsString())) {</b>
<b class="nc">&nbsp;                                entity.setC3NetId(e);</b>
<b class="nc">&nbsp;                                C3iSet = true;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            pos++;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // NC3 Checks
<b class="nc">&nbsp;                    if (entity.hasNavalC3() &amp;&amp; !C3iSet) {</b>
<b class="nc">&nbsp;                        entity.setC3NetIdSelf();</b>
<b class="nc">&nbsp;                        int pos = 0;</b>
<b class="nc">&nbsp;                        while (pos &lt; Entity.MAX_C3i_NODES) {</b>
&nbsp;                            // We&#39;ve found a network, join it.
<b class="nc">&nbsp;                            if ((entity.getNC3NextUUIDAsString(pos) != null)</b>
<b class="nc">&nbsp;                                    &amp;&amp; (e.getC3UUIDAsString() != null)</b>
<b class="nc">&nbsp;                                    &amp;&amp; entity.getNC3NextUUIDAsString(pos)</b>
<b class="nc">&nbsp;                                    .equals(e.getC3UUIDAsString())) {</b>
<b class="nc">&nbsp;                                entity.setC3NetId(e);</b>
<b class="nc">&nbsp;                                C3iSet = true;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            pos++;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // Give the unit a spotlight, if it has the spotlight quirk
<b class="nc">&nbsp;            entity.setExternalSpotlight(entity.hasExternaSpotlight()</b>
<b class="nc">&nbsp;                    || entity.hasQuirk(OptionsConstants.QUIRK_POS_SEARCHLIGHT));</b>
<b class="nc">&nbsp;            entityIds.add(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;            if (game.getPhase() != Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;                entity.getOwner().increaseInitialBV(entity.calculateBattleValue(false, false));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // Cycle through the entities again and update any carried units
&nbsp;        // and carrier units to use the correct server-given IDs.
&nbsp;        // Typically necessary when loading a MUL containing transported units.
&nbsp;        
&nbsp;        // First, deal with units loaded into bays. These are saved for the carrier
&nbsp;        // in MULs and must be restored exactly to recreate the bay loading.
<b class="nc">&nbsp;        Set&lt;Entity&gt; transportCorrected = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (final Entity carrier: entities) {</b>
<b class="nc">&nbsp;            for (int carriedId: carrier.getBayLoadedUnitIds()) {</b>
&nbsp;                // First, see if a bay loaded unit can be found and unloaded,
&nbsp;                // because it might be the wrong unit
<b class="nc">&nbsp;                Entity carried = game.getEntity(carriedId);</b>
<b class="nc">&nbsp;                if (carried == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                int bay = carrier.getBay(carried).getBayNumber();</b>
<b class="nc">&nbsp;                carrier.unload(carried);</b>
&nbsp;                // Now, load the correct unit if there is one
<b class="nc">&nbsp;                if (idMap.containsKey(carriedId)) {</b>
<b class="nc">&nbsp;                    Entity newCarried = game.getEntity(idMap.get(carriedId));</b>
<b class="nc">&nbsp;                    if (carrier.canLoad(newCarried, false)) {</b>
<b class="nc">&nbsp;                        carrier.load(newCarried, false, bay);</b>
<b class="nc">&nbsp;                        newCarried.setTransportId(carrier.getId());</b>
&nbsp;                        // Remember that the carried unit should not be treated again below
<b class="nc">&nbsp;                        transportCorrected.add(newCarried);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Now restore the transport settings from the entities&#39; transporter IDs
&nbsp;        // With anything other than bays, MULs only show the carrier, not the carried units 
<b class="nc">&nbsp;        for (final Entity entity: entities) {</b>
&nbsp;            // Don&#39;t correct those that are already corrected
<b class="nc">&nbsp;            if (transportCorrected.contains(entity)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // Get the original (client side) ID of the transporter
<b class="nc">&nbsp;            int origTrsp = entity.getTransportId();</b>
&nbsp;            // Only act if the unit thinks it is transported
<b class="nc">&nbsp;            if (origTrsp != Entity.NONE) {</b>
&nbsp;                // If the transporter is among the new units, go on with loading 
<b class="nc">&nbsp;                if (idMap.containsKey(origTrsp)) {</b>
&nbsp;                    // The wrong transporter doesn&#39;t know of anything and does not need an update
<b class="nc">&nbsp;                    Entity carrier = game.getEntity(idMap.get(origTrsp)); </b>
<b class="nc">&nbsp;                    if (carrier.canLoad(entity, false)) {</b>
&nbsp;                        // The correct transporter must be told it&#39;s carrying something and
&nbsp;                        // the carried unit must be told where it is embarked
<b class="nc">&nbsp;                        carrier.load(entity, false);</b>
<b class="nc">&nbsp;                        entity.setTransportId(idMap.get(origTrsp));</b>
&nbsp;                    } else {
&nbsp;                        // This seems to be an invalid carrier; update the entity accordingly
<b class="nc">&nbsp;                        entity.setTransportId(Entity.NONE);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // this transporter does not exist; update the entity accordingly
<b class="nc">&nbsp;                    entity.setTransportId(Entity.NONE);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // Set the &quot;loaded keepers&quot; which is apparently used for deployment unloading to
&nbsp;        // differentiate between units loaded in the lobby and other carried units
&nbsp;        // When entering a game from the lobby, this list is generated again, but not when 
&nbsp;        // the added entities are loaded during a game. When getting loaded units from a MUL,
&nbsp;        // act as if they were loaded in the lobby.
<b class="nc">&nbsp;        for (final Entity entity: entities) {</b>
<b class="nc">&nbsp;            if (entity.getLoadedUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;                Vector&lt;Integer&gt; v = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Entity en : entity.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    v.add(en.getId());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                entity.setLoadedKeepers(v);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        send(createAddEntityPacket(entityIds));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * adds a squadron to the game
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveSquadronAdd(Packet c, int connIndex) {
&nbsp;
<b class="nc">&nbsp;        final FighterSquadron fs = (FighterSquadron) c.getObject(0);</b>
<b class="nc">&nbsp;        final Vector&lt;Integer&gt; fighters = (Vector&lt;Integer&gt;) c.getObject(1);</b>
<b class="nc">&nbsp;        if (fighters.size() &lt; 1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // fs.setOwner(fighters.firstElement().getOwner());
&nbsp;        // Only assign an entity ID when the client hasn&#39;t.
<b class="nc">&nbsp;        if (Entity.NONE == fs.getId()) {</b>
<b class="nc">&nbsp;            fs.setId(getFreeEntityId());</b>
&nbsp;        }
<b class="nc">&nbsp;        game.addEntity(fs);</b>
<b class="nc">&nbsp;        for (int id : fighters) {</b>
<b class="nc">&nbsp;            Entity fighter = game.getEntity(id);</b>
<b class="nc">&nbsp;            if (null != fighter) {</b>
<b class="nc">&nbsp;                fs.load(fighter, false);</b>
<b class="nc">&nbsp;                fs.autoSetMaxBombPoints();</b>
<b class="nc">&nbsp;                fighter.setTransportId(fs.getId());</b>
&nbsp;                // If this is the lounge, we want to configure bombs
<b class="nc">&nbsp;                if (game.getPhase() == Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;                    ((IBomber)fighter).setBombChoices(fs.getBombChoices());</b>
&nbsp;                }
<b class="nc">&nbsp;                entityUpdate(fighter.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        send(createAddEntityPacket(fs.getId()));</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Updates an entity with the info from the client. Only valid to do this
&nbsp;     * during the lounge phase, except for heat sink changing.
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityUpdate(Packet c, int connIndex) {
<b class="nc">&nbsp;        Entity entity = (Entity) c.getObject(0);</b>
<b class="nc">&nbsp;        Entity oldEntity = game.getEntity(entity.getId());</b>
<b class="nc">&nbsp;        if ((oldEntity != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((oldEntity.getOwner() == getPlayer(connIndex)) || (oldEntity</b>
<b class="nc">&nbsp;                        .getOwner().getTeam() == getPlayer(connIndex).getTeam()))) {</b>
<b class="nc">&nbsp;            game.setEntity(entity.getId(), entity);</b>
<b class="nc">&nbsp;            entityUpdate(entity.getId());</b>
&nbsp;            // In the chat lounge, notify players of customizing of unit
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;                StringBuilder message = new StringBuilder();</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) {</b>
<b class="nc">&nbsp;                    message.append(&quot;A Unit &quot;);</b>
<b class="nc">&nbsp;                    message.append(&#39;(&#39;).append(entity.getOwner().getName()).append(&#39;)&#39;);</b>
<b class="nc">&nbsp;                } else if (game.getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP)) {</b>
<b class="nc">&nbsp;                    message.append(&quot;Unit &quot;);</b>
<b class="nc">&nbsp;                    if (!entity.getExternalIdAsString().equals(&quot;-1&quot;)) {</b>
<b class="nc">&nbsp;                        message.append(&#39;[&#39;)</b>
<b class="nc">&nbsp;                               .append(entity.getExternalIdAsString())</b>
<b class="nc">&nbsp;                               .append(&quot;] &quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    message.append(entity.getId()).append(&quot; (&quot;)</b>
<b class="nc">&nbsp;                           .append(entity.getOwner().getName()).append(&#39;)&#39;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    message.append(&quot;Unit &quot;);</b>
<b class="nc">&nbsp;                    message.append(entity.getDisplayName());</b>
&nbsp;                }
<b class="nc">&nbsp;                message.append(&quot; has been customized.&quot;);</b>
<b class="nc">&nbsp;                sendServerChat(message.toString());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * loads an entity into another one. Meant to be called from the chat lounge
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityLoad(Packet c, int connIndex) {
<b class="nc">&nbsp;        int loadeeId = (Integer) c.getObject(0);</b>
<b class="nc">&nbsp;        int loaderId = (Integer) c.getObject(1);</b>
<b class="nc">&nbsp;        int bayNumber = (Integer) c.getObject(2);</b>
<b class="nc">&nbsp;        Entity loadee = game.getEntity(loadeeId);</b>
<b class="nc">&nbsp;        Entity loader = game.getEntity(loaderId);</b>
&nbsp;
<b class="nc">&nbsp;        if ((loadee != null) &amp;&amp; (loader != null)) {</b>
<b class="nc">&nbsp;            loadUnit(loader, loadee, bayNumber);</b>
&nbsp;            // In the chat lounge, notify players of customizing of unit
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_LOUNGE) {</b>
&nbsp;                /*
&nbsp;                 * StringBuffer message = new StringBuffer();
&nbsp;                 * message.append(&quot;Unit &quot;); if
&nbsp;                 * (game.getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP) ||
&nbsp;                 * game.getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) { if
&nbsp;                 * (!entity.getExternalIdAsString().equals(&quot;-1&quot;)) {
&nbsp;                 * message.append(&#39;[&#39;) .append(entity.getExternalIdAsString())
&nbsp;                 * .append(&quot;] &quot;); } message.append(entity.getId()).append(&#39;(&#39;)
&nbsp;                 * .append(entity.getOwner().getName()).append(&#39;)&#39;); } else {
&nbsp;                 * message.append(entity.getDisplayName()); }
&nbsp;                 * message.append(&quot; has been customized.&quot;);
&nbsp;                 * sendServerChat(message.toString());
&nbsp;                 */
&nbsp;                // Set this so units can be unloaded in the first movement phase
<b class="nc">&nbsp;                loadee.setLoadedThisTurn(false);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveCustomInit(Packet c, int connIndex) {
&nbsp;        // In the chat lounge, notify players of customizing of unit
<b class="nc">&nbsp;        if (game.getPhase() == IGame.Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;            IPlayer p = (IPlayer) c.getObject(0);</b>
<b class="nc">&nbsp;            sendServerChat(&quot;&quot; + p.getName() + &quot; has customized initiative.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive and process an entity mode change packet
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityModeChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int equipId = c.getIntValue(1);</b>
<b class="nc">&nbsp;        int mode = c.getIntValue(2);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if (e.getOwner() != getPlayer(connIndex)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        Mounted m = e.getEquipment(equipId);</b>
&nbsp;
<b class="nc">&nbsp;        if (m == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
&nbsp;            // Check for BA dumping body mounted missile launchers
<b class="nc">&nbsp;            if ((e instanceof BattleArmor) &amp;&amp; (!m.isMissing())</b>
<b class="nc">&nbsp;                    &amp;&amp; m.isBodyMounted()</b>
<b class="nc">&nbsp;                    &amp;&amp; m.getType().hasFlag(WeaponType.F_MISSILE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.getLinked() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.getLinked().getUsableShotsLeft() &gt; 0)</b>
&nbsp;                    &amp;&amp; (mode &lt;= 0)) {
<b class="nc">&nbsp;                m.setPendingDump(mode == -1);</b>
&nbsp;            // a mode change for ammo means dumping or hot loading
<b class="nc">&nbsp;            } else if ((m.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.getType().hasInstantModeSwitch() &amp;&amp; (mode &lt; 0</b>
<b class="nc">&nbsp;                            || mode == 0 &amp;&amp; m.isPendingDump())) {</b>
<b class="nc">&nbsp;                m.setPendingDump(mode == -1);</b>
<b class="nc">&nbsp;            } else if ((m.getType() instanceof WeaponType) &amp;&amp; m.isDWPMounted()</b>
&nbsp;                       &amp;&amp; (mode &lt;= 0)) {
<b class="nc">&nbsp;                m.setPendingDump(mode == -1);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (!m.setMode(mode)) {</b>
<b class="nc">&nbsp;                    String message = e.getShortName() + &quot;: &quot; + m.getName() + &quot;: &quot; + e.getLocationName(m.getLocation())</b>
&nbsp;                            + &quot; trying to compensate&quot;;
<b class="nc">&nbsp;                    MegaMek.getLogger().error(message);</b>
<b class="nc">&nbsp;                    sendServerChat(message);</b>
<b class="nc">&nbsp;                    e.setGameOptions();</b>
&nbsp;
<b class="nc">&nbsp;                    if (!m.setMode(mode)) {</b>
<b class="nc">&nbsp;                        message = e.getShortName() + &quot;: &quot; + m.getName() + &quot;: &quot; + e.getLocationName(m.getLocation())</b>
&nbsp;                                + &quot; unable to compensate&quot;;
<b class="nc">&nbsp;                        MegaMek.getLogger().error(message);</b>
<b class="nc">&nbsp;                        sendServerChat(message);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(ex);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receive and process an Entity Sensor Change Packet
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntitySensorChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int sensorId = c.getIntValue(1);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        e.setNextSensor(e.getSensors().elementAt(sensorId));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receive and process an Entity Heat Sinks Change Packet
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntitySinksChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int numSinks = c.getIntValue(1);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if ((e instanceof Mech) &amp;&amp; (connIndex == e.getOwnerId())) {</b>
<b class="nc">&nbsp;            ((Mech)e).setActiveSinksNextRound(numSinks);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityActivateHidden(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        IGame.Phase phase = (IGame.Phase)c.getObject(1);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if (connIndex != e.getOwnerId()) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Player &quot; + connIndex </b>
<b class="nc">&nbsp;                    + &quot; tried to activate a hidden unit owned by Player &quot; + e.getOwnerId());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        e.setHiddeActivationPhase(phase);</b>
<b class="nc">&nbsp;        entityUpdate(entityId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * receive and process an entity nova network mode change packet
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityNovaNetworkModeChange(Packet c, int connIndex) {
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;            String networkID = c.getObject(1).toString();</b>
<b class="nc">&nbsp;            Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;            if (e.getOwner() != getPlayer(connIndex)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // FIXME: Greg: This can result in setting the network to link to
&nbsp;            // hostile units.
&nbsp;            // However, it should be caught by both the isMemberOfNetwork test
&nbsp;            // from the c3 module as well as
&nbsp;            // by the clients possible input.
<b class="nc">&nbsp;            e.setNewRoundNovaNetworkString(networkID);</b>
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            ex.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive and process an entity mounted facing change packet
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityMountedFacingChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int equipId = c.getIntValue(1);</b>
<b class="nc">&nbsp;        int facing = c.getIntValue(2);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if (e.getOwner() != getPlayer(connIndex)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        Mounted m = e.getEquipment(equipId);</b>
&nbsp;
<b class="nc">&nbsp;        if (m == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        m.setFacing(facing);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive and process an entity mode change packet
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityCalledShotChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int equipId = c.getIntValue(1);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if (e.getOwner() != getPlayer(connIndex)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        Mounted m = e.getEquipment(equipId);</b>
&nbsp;
<b class="nc">&nbsp;        if (m == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        m.getCalledShot().switchCalledShot();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive and process an entity system mode change packet
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntitySystemModeChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int equipId = c.getIntValue(1);</b>
<b class="nc">&nbsp;        int mode = c.getIntValue(2);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if (e.getOwner() != getPlayer(connIndex)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((e instanceof Mech) &amp;&amp; (equipId == Mech.SYSTEM_COCKPIT)) {</b>
<b class="nc">&nbsp;            ((Mech) e).setCockpitStatus(mode);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receive a packet that contains an Entity ammo change
&nbsp;     *
&nbsp;     * @param c the packet to be processed
&nbsp;     * @param connIndex the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveEntityAmmoChange(Packet c, int connIndex) {
<b class="nc">&nbsp;        int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;        int weaponId = c.getIntValue(1);</b>
<b class="nc">&nbsp;        int ammoId = c.getIntValue(2);</b>
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
&nbsp;
&nbsp;        // Did we receive a request for a valid Entity?
<b class="nc">&nbsp;        if (null == e) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Could not find entity# &quot; + entityId);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        IPlayer player = getPlayer(connIndex);</b>
<b class="nc">&nbsp;        if ((null != player) &amp;&amp; (e.getOwner() != player)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Player &quot; + player.getName() + &quot; does not own the entity &quot; + e.getDisplayName());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Make sure that the entity has the given equipment.
<b class="nc">&nbsp;        Mounted mWeap = e.getEquipment(weaponId);</b>
<b class="nc">&nbsp;        Mounted mAmmo = e.getEquipment(ammoId);</b>
<b class="nc">&nbsp;        if (null == mAmmo) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Entity &quot; + e.getDisplayName() + &quot; does not have ammo #&quot; + ammoId);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!(mAmmo.getType() instanceof AmmoType)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Item #&quot; + ammoId + &quot; of entity &quot; + e.getDisplayName()</b>
<b class="nc">&nbsp;                    + &quot; is a &quot; + mAmmo.getName() + &quot; and not ammo.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (null == mWeap) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Entity &quot; + e.getDisplayName() + &quot; does not have weapon #&quot; + weaponId);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!(mWeap.getType() instanceof WeaponType)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Item #&quot; + weaponId + &quot; of entity &quot; + e.getDisplayName()</b>
<b class="nc">&nbsp;                    + &quot; is a &quot; + mWeap.getName() + &quot; and not a weapon.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (((WeaponType) mWeap.getType()).getAmmoType() == AmmoType.T_NA) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Item #&quot; + weaponId + &quot; of entity &quot; + e.getDisplayName()</b>
<b class="nc">&nbsp;                    + &quot; is a &quot; + mWeap.getName() + &quot; and does not use ammo.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mWeap.getType().hasFlag(WeaponType.F_ONESHOT)</b>
<b class="nc">&nbsp;                &amp;&amp; !mWeap.getType().hasFlag(WeaponType.F_DOUBLE_ONESHOT)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Item #&quot; + weaponId + &quot; of entity &quot; + e.getDisplayName()</b>
<b class="nc">&nbsp;                    + &quot; is a &quot; + mWeap.getName() + &quot; and cannot use external ammo.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Load the weapon.
<b class="nc">&nbsp;        e.loadWeapon(mWeap, mAmmo);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes an entity owned by a certain player from the list
&nbsp;     */
&nbsp;    private void receiveEntityDelete(Packet c, int connIndex) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Integer&gt; ids = (List&lt;Integer&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;        for (Integer entityId : ids) {</b>
<b class="nc">&nbsp;            final Entity entity = game.getEntity(entityId);</b>
&nbsp;
&nbsp;            // Only allow players to delete their *own* entities.
<b class="nc">&nbsp;            if ((entity != null) &amp;&amp; (entity.getOwner() == getPlayer(connIndex))) {</b>
&nbsp;
&nbsp;                // If we&#39;re deleting a ProtoMech, recalculate unit numbers.
<b class="nc">&nbsp;                if (entity instanceof Protomech) {</b>
&nbsp;
&nbsp;                    // How many ProtoMechs does the player have (include this one)?
<b class="nc">&nbsp;                    int numPlayerProtos = game.getSelectedEntityCount(new EntitySelector() {</b>
<b class="nc">&nbsp;                        private final int ownerId = entity.getOwnerId();</b>
&nbsp;
&nbsp;                        public boolean accept(Entity entity) {
<b class="nc">&nbsp;                            return (entity instanceof Protomech) &amp;&amp; (ownerId == entity.getOwnerId());</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;
&nbsp;                    // According to page 54 of the BMRr, ProtoMechs must be
&nbsp;                    // deployed in full Points of five, unless &quot;losses&quot; have
&nbsp;                    // reduced the number to less than that.
<b class="nc">&nbsp;                    final char oldMax = (char) (Math.ceil(numPlayerProtos / 5.0) - 1);</b>
<b class="nc">&nbsp;                    char newMax = (char) (Math.ceil((numPlayerProtos - 1) / 5.0) - 1);</b>
<b class="nc">&nbsp;                    short deletedUnitNum = entity.getUnitNumber();</b>
&nbsp;
&nbsp;                    // Do we have to update a ProtoMech from the last unit?
<b class="nc">&nbsp;                    if ((oldMax != deletedUnitNum) &amp;&amp; (oldMax != newMax)) {</b>
&nbsp;
&nbsp;                        // Yup. Find a ProtoMech from the last unit, and
&nbsp;                        // set it&#39;s unit number to the deleted entity.
<b class="nc">&nbsp;                        Iterator&lt;Entity&gt; lastUnit =</b>
<b class="nc">&nbsp;                                game.getSelectedEntities(new EntitySelector() {</b>
<b class="nc">&nbsp;                                    private final int ownerId = entity.getOwnerId();</b>
&nbsp;
<b class="nc">&nbsp;                                    private final char lastUnitNum = oldMax;</b>
&nbsp;
&nbsp;                                    public boolean accept(Entity entity) {
<b class="nc">&nbsp;                                        return (entity instanceof Protomech)</b>
<b class="nc">&nbsp;                                                &amp;&amp; (ownerId == entity.getOwnerId())</b>
<b class="nc">&nbsp;                                                &amp;&amp; (lastUnitNum == entity.getUnitNumber());</b>
&nbsp;                                    }
&nbsp;                                });
<b class="nc">&nbsp;                        Entity lastUnitMember = lastUnit.next();</b>
<b class="nc">&nbsp;                        lastUnitMember.setUnitNumber(deletedUnitNum);</b>
<b class="nc">&nbsp;                        entityUpdate(lastUnitMember.getId());</b>
&nbsp;                    } // End update-unit-number
&nbsp;                } // End added-ProtoMech
&nbsp;
<b class="nc">&nbsp;                if (game.getPhase() != IGame.Phase.PHASE_DEPLOYMENT) {</b>
&nbsp;                    // if a unit is removed during deployment just keep going
&nbsp;                    // without adjusting the turn vector.
<b class="nc">&nbsp;                    game.removeTurnFor(entity);</b>
<b class="nc">&nbsp;                    game.removeEntity(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // during deployment this absolutely must be called before game.removeEntity(), otherwise the game hangs
&nbsp;        // when a unit is removed. Cause unknown.
<b class="nc">&nbsp;        send(createRemoveEntityPacket(ids, IEntityRemovalConditions.REMOVE_NEVER_JOINED));</b>
&nbsp;
&nbsp;        // Prevents deployment hanging. Only do this during deployment.
<b class="nc">&nbsp;        if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {</b>
<b class="nc">&nbsp;            for (Integer entityId : ids) {</b>
<b class="nc">&nbsp;                final Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;                game.removeEntity(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED);</b>
<b class="nc">&nbsp;                endCurrentTurn(entity);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets a player&#39;s ready status
&nbsp;     */
&nbsp;    private void receivePlayerDone(Packet pkt, int connIndex) {
<b class="nc">&nbsp;        boolean ready = pkt.getBooleanValue(0);</b>
<b class="nc">&nbsp;        IPlayer player = getPlayer(connIndex);</b>
<b class="nc">&nbsp;        if (null != player) {</b>
<b class="nc">&nbsp;            player.setDone(ready);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void receiveInitiativeRerollRequest(Packet pkt, int connIndex) {
<b class="nc">&nbsp;        IPlayer player = getPlayer(connIndex);</b>
<b class="nc">&nbsp;        if (IGame.Phase.PHASE_INITIATIVE_REPORT != game.getPhase()) {</b>
<b class="nc">&nbsp;            StringBuilder message = new StringBuilder();</b>
<b class="nc">&nbsp;            if (null == player) {</b>
<b class="nc">&nbsp;                message.append(&quot;Player #&quot;).append(connIndex);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                message.append(player.getName());</b>
&nbsp;            }
<b class="nc">&nbsp;            message.append(&quot; is not allowed to ask for a reroll at this time.&quot;);</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(message.toString());</b>
<b class="nc">&nbsp;            sendServerChat(message.toString());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.hasTacticalGenius(player)) {</b>
<b class="nc">&nbsp;            game.addInitiativeRerollRequest(game.getTeamForPlayer(player));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (null != player) {</b>
<b class="nc">&nbsp;            player.setDone(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets game options, providing that the player has specified the password
&nbsp;     * correctly.
&nbsp;     *
&nbsp;     * @return true if any options have been successfully changed.
&nbsp;     */
&nbsp;    private boolean receiveGameOptions(Packet packet, int connId) {
<b class="nc">&nbsp;        IPlayer player = game.getPlayer(connId);</b>
&nbsp;        // Check player
<b class="nc">&nbsp;        if (null == player) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server does not recognize player at connection &quot; + connId);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check password
<b class="nc">&nbsp;        if ((password != null) &amp;&amp; (password.length() &gt; 0) &amp;&amp; !password.equals(packet.getObject(0))) {</b>
<b class="nc">&nbsp;            sendServerChat(connId, &quot;The password you specified to change game options is incorrect.&quot;);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getPhase().isDuringOrAfter(Phase.PHASE_DEPLOYMENT)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int changed = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;?&gt; i = ((Vector&lt;?&gt;) packet.getObject(1)).elements(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IBasicOption option = (IBasicOption) i.nextElement();</b>
<b class="nc">&nbsp;            IOption originalOption = game.getOptions().getOption(option.getName());</b>
&nbsp;
<b class="nc">&nbsp;            if (originalOption == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String message = &quot;Player &quot; + player.getName() + &quot; changed option \&quot;&quot; +</b>
<b class="nc">&nbsp;                    originalOption.getDisplayableName() + &quot;\&quot; to &quot; + option.getValue().toString() + &#39;.&#39;;</b>
<b class="nc">&nbsp;            sendServerChat(message);</b>
<b class="nc">&nbsp;            originalOption.setValue(option.getValue());</b>
<b class="nc">&nbsp;            changed++;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Set proper RNG
<b class="nc">&nbsp;        Compute.setRNG(game.getOptions().intOption(OptionsConstants.BASE_RNG_TYPE));</b>
&nbsp;
<b class="nc">&nbsp;        if (changed &gt; 0) {</b>
<b class="nc">&nbsp;            for (Entity en : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                en.setGameOptions();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            entityAllUpdate();</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the additional processing of the received options after the the
&nbsp;     * &lt;code&gt;receiveGameOptions&lt;code&gt; done its job; should be called after
&nbsp;     * &lt;code&gt;receiveGameOptions&lt;code&gt; only if the &lt;code&gt;receiveGameOptions&lt;code&gt;
&nbsp;     * returned &lt;code&gt;true&lt;/code&gt;
&nbsp;     *
&nbsp;     * @param packet the packet to be processed
&nbsp;     * @param connId the id for connection that received the packet.
&nbsp;     */
&nbsp;    private void receiveGameOptionsAux(Packet packet, int connId) {
<b class="nc">&nbsp;        for (Enumeration&lt;?&gt; i = ((Vector&lt;?&gt;) packet.getObject(1)).elements(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IBasicOption option = (IBasicOption) i.nextElement();</b>
<b class="nc">&nbsp;            IOption originalOption = game.getOptions().getOption(option.getName());</b>
<b class="nc">&nbsp;            if (originalOption != null) {</b>
<b class="nc">&nbsp;                if (&quot;maps_include_subdir&quot;.equals(originalOption.getName())) {</b>
<b class="nc">&nbsp;                    mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(</b>
<b class="nc">&nbsp;                            mapSettings.getBoardWidth(), mapSettings.getBoardHeight())));</b>
<b class="nc">&nbsp;                    mapSettings.removeUnavailable();</b>
<b class="nc">&nbsp;                    mapSettings.setNullBoards(DEFAULT_BOARD);</b>
<b class="nc">&nbsp;                    send(createMapSettingsPacket());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out the game victory event to all connections
&nbsp;     */
&nbsp;    private void transmitGameVictoryEventToAll() {
<b class="nc">&nbsp;        for (IConnection conn : connections) {</b>
<b class="nc">&nbsp;            send(conn.getId(), new Packet(Packet.COMMAND_GAME_VICTORY_EVENT));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out all player info to the specified connection
&nbsp;     */
&nbsp;    private void transmitAllPlayerConnects(int connId) {
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
&nbsp;
<b class="nc">&nbsp;            send(connId, createPlayerConnectPacket(player.getId()));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet informing that the player has connected
&nbsp;     */
&nbsp;    private Packet createPlayerConnectPacket(int playerId) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = playerId;</b>
<b class="nc">&nbsp;        data[1] = getPlayer(playerId);</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_PLAYER_ADD, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the player info, for update
&nbsp;     */
&nbsp;    private Packet createPlayerUpdatePacket(int playerId) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = playerId;</b>
<b class="nc">&nbsp;        data[1] = getPlayer(playerId);</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out the player info updates for all players to all connections
&nbsp;     */
&nbsp;    private void transmitAllPlayerUpdates() {
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;            if (null != player) {</b>
<b class="nc">&nbsp;                send(createPlayerUpdatePacket(player.getId()));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out the player ready stats for all players to all connections
&nbsp;     */
&nbsp;    private void transmitAllPlayerDones() {
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = game.getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
&nbsp;
<b class="nc">&nbsp;            send(createPlayerDonePacket(player.getId()));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the player ready status
&nbsp;     */
&nbsp;    private Packet createPlayerDonePacket(int playerId) {
<b class="nc">&nbsp;        Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = playerId;</b>
<b class="nc">&nbsp;        data[1] = getPlayer(playerId).isDone();</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_PLAYER_READY, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the current turn vector
&nbsp;     */
&nbsp;    private Packet createTurnVectorPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_TURNS, game.getTurnVector());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the current turn index
&nbsp;     */
&nbsp;    private Packet createTurnIndexPacket(int playerId) {
<b class="nc">&nbsp;        final Object[] data = new Object[3];</b>
<b class="nc">&nbsp;        data[0] = game.getTurnIndex();</b>
<b class="nc">&nbsp;        data[1] = playerId;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_TURN, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the map settings
&nbsp;     */
&nbsp;    private Packet createMapSettingsPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, mapSettings);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Packet createMapSizesPacket() {
<b class="nc">&nbsp;        Set&lt;BoardDimensions&gt; sizes = getBoardSizes();</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_AVAILABLE_MAP_SIZES, sizes);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the planetary conditions
&nbsp;     */
&nbsp;    private Packet createPlanetaryConditionsPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_PLANETARY_CONDITIONS,</b>
<b class="nc">&nbsp;                          game.getPlanetaryConditions());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the game settings
&nbsp;     */
&nbsp;    private Packet createGameSettingsPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, game.getOptions());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing the game board
&nbsp;     */
&nbsp;    private Packet createBoardPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_BOARD, game.getBoard());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a single entity, for update
&nbsp;     */
&nbsp;    private Packet createEntityPacket(int entityId, Vector&lt;UnitLocation&gt; movePath) {
<b class="nc">&nbsp;        final Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        final Object[] data = new Object[3];</b>
<b class="nc">&nbsp;        data[0] = entityId;</b>
<b class="nc">&nbsp;        data[1] = entity;</b>
<b class="nc">&nbsp;        data[2] = movePath;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a Vector of Reports
&nbsp;     */
&nbsp;    private Packet createReportPacket(IPlayer p) {
&nbsp;        // When the final report is created, MM sends a null player to create
&nbsp;        // the
&nbsp;        // report. This will handle that issue.
<b class="nc">&nbsp;        if ((p == null) || !doBlind()) {</b>
<b class="nc">&nbsp;            return new Packet(Packet.COMMAND_SENDING_REPORTS, vPhaseReport);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_REPORTS, filterReportVector(vPhaseReport, p));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a Vector of special Reports which needs to be
&nbsp;     * sent during a phase that is not a report phase.
&nbsp;     */
&nbsp;    private Packet createSpecialReportPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_REPORTS_SPECIAL, vPhaseReport.clone());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a Vector of Reports that represent a Tactical
&nbsp;     * Genius re-roll request which needs to update a current phase&#39;s report.
&nbsp;     */
&nbsp;    private Packet createTacticalGeniusReportPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS, vPhaseReport.clone());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing all the round reports
&nbsp;     */
&nbsp;    private Packet createAllReportsPacket(IPlayer p) {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_REPORTS_ALL,</b>
<b class="nc">&nbsp;                filterPastReports(game.getAllReports(), p));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing all current entities
&nbsp;     */
&nbsp;    private Packet createEntitiesPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing all current and out-of-game entities
&nbsp;     */
&nbsp;    private Packet createFullEntitiesPacket() {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = game.getEntitiesVector();</b>
<b class="nc">&nbsp;        data[1] = game.getOutOfGameEntitiesVector();</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing all entities visible to the player in a blind
&nbsp;     * game
&nbsp;     */
&nbsp;    private Packet createFilteredEntitiesPacket(IPlayer p, Map&lt;EntityTargetPair,
&nbsp;            LosEffects&gt; losCache) {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_ENTITIES,</b>
<b class="nc">&nbsp;                filterEntities(p, game.getEntitiesVector(), losCache));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing all entities, including wrecks, visible to
&nbsp;     * the player in a blind game
&nbsp;     */
&nbsp;    private Packet createFilteredFullEntitiesPacket(IPlayer p) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = filterEntities(p, game.getEntitiesVector(), null);</b>
<b class="nc">&nbsp;        data[1] = game.getOutOfGameEntitiesVector();</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Packet createAddEntityPacket(int entityId) {
<b class="nc">&nbsp;        ArrayList&lt;Integer&gt; entityIds = new ArrayList&lt;&gt;(1);</b>
<b class="nc">&nbsp;        entityIds.add(entityId);</b>
<b class="nc">&nbsp;        return createAddEntityPacket(entityIds);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet detailing the addition of an entity
&nbsp;     */
&nbsp;    private Packet createAddEntityPacket(List&lt;Integer&gt; entityIds) {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;&gt;(entityIds.size());</b>
<b class="nc">&nbsp;        for (Integer id : entityIds) {</b>
<b class="nc">&nbsp;            entities.add(game.getEntity(id));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = entityIds;</b>
<b class="nc">&nbsp;        data[1] = entities;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_ENTITY_ADD, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet detailing the removal of an entity. Maintained for
&nbsp;     * backwards compatibility.
&nbsp;     *
&nbsp;     * @param entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.
&nbsp;     * @return A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.
&nbsp;     */
&nbsp;    private Packet createRemoveEntityPacket(int entityId) {
<b class="nc">&nbsp;        return createRemoveEntityPacket(entityId, IEntityRemovalConditions.REMOVE_SALVAGEABLE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet detailing the removal of an entity.
&nbsp;     *
&nbsp;     * @param entityId  - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.
&nbsp;     * @param condition - the &lt;code&gt;int&lt;/code&gt; condition the unit was in. This value
&nbsp;     *                  must be one of constants in
&nbsp;     *                  &lt;code&gt;IEntityRemovalConditions&lt;/code&gt;, or an
&nbsp;     *                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
&nbsp;     * @return A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.
&nbsp;     */
&nbsp;    private Packet createRemoveEntityPacket(int entityId, int condition) {
<b class="nc">&nbsp;        List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(1);</b>
<b class="nc">&nbsp;        ids.add(entityId);</b>
<b class="nc">&nbsp;        return createRemoveEntityPacket(ids, condition);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet detailing the removal of a list of entities.
&nbsp;     *
&nbsp;     * @param entityIds - the &lt;code&gt;int&lt;/code&gt; ID of each entity being removed.
&nbsp;     * @param condition - the &lt;code&gt;int&lt;/code&gt; condition the units were in. This value
&nbsp;     *                  must be one of constants in
&nbsp;     *                  &lt;code&gt;IEntityRemovalConditions&lt;/code&gt;, or an
&nbsp;     *                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
&nbsp;     * @return A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.
&nbsp;     */
&nbsp;    private Packet createRemoveEntityPacket(List&lt;Integer&gt; entityIds, int condition) {
<b class="nc">&nbsp;        if ((condition != IEntityRemovalConditions.REMOVE_UNKNOWN)</b>
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_IN_RETREAT)
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_PUSHED)
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_SALVAGEABLE)
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_EJECTED)
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_CAPTURED)
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_DEVASTATED)
&nbsp;                &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_NEVER_JOINED)) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Unknown unit condition: &quot; + condition);</b>
&nbsp;        }
<b class="nc">&nbsp;        Object[] array = new Object[2];</b>
<b class="nc">&nbsp;        array[0] = entityIds;</b>
<b class="nc">&nbsp;        array[1] = condition;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_ENTITY_REMOVE, array);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet indicating end of game, including detailed unit status
&nbsp;     */
&nbsp;    private Packet createEndOfGamePacket() {
<b class="nc">&nbsp;        Object[] array = new Object[3];</b>
<b class="nc">&nbsp;        array[0] = getDetailedVictoryReport();</b>
<b class="nc">&nbsp;        array[1] = game.getVictoryPlayerId();</b>
<b class="nc">&nbsp;        array[2] = game.getVictoryTeam();</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_END_OF_GAME, array);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static String ORIGIN = &quot;***Server&quot;;</b>
&nbsp;
&nbsp;    public static String formatChatMessage(String origin, String message) {
<b class="fc">&nbsp;        return origin + &quot;: &quot; + message;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Transmits a chat message to all players
&nbsp;     */
&nbsp;    public void sendChat(int connId, String origin, String message) {
<b class="nc">&nbsp;        send(connId, new Packet(Packet.COMMAND_CHAT, formatChatMessage(origin, message)));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Transmits a chat message to all players
&nbsp;     */
&nbsp;    private void sendChat(String origin, String message) {
<b class="nc">&nbsp;        String chat = formatChatMessage(origin, message);</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_CHAT, chat));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendServerChat(int connId, String message) {
<b class="nc">&nbsp;        sendChat(connId, ORIGIN, message);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendServerChat(String message) {
<b class="nc">&nbsp;        sendChat(ORIGIN, message);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a hex, and the coordinates it goes at.
&nbsp;     */
&nbsp;    private Packet createHexChangePacket(Coords coords, IHex hex) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = coords;</b>
<b class="nc">&nbsp;        data[1] = hex;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_CHANGE_HEX, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void sendSmokeCloudAdded(SmokeCloud cloud) {
<b class="nc">&nbsp;        final Object[] data = new Object[1];</b>
<b class="nc">&nbsp;        data[0] = cloud;</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ADD_SMOKE_CLOUD, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends notification to clients that the specified hex has changed.
&nbsp;     */
&nbsp;    public void sendChangedHex(Coords coords) {
<b class="nc">&nbsp;        send(createHexChangePacket(coords, game.getBoard().getHex(coords)));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a hex, and the coordinates it goes at.
&nbsp;     */
&nbsp;    private Packet createHexesChangePacket(Set&lt;Coords&gt; coords, Set&lt;IHex&gt; hex) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = coords;</b>
<b class="nc">&nbsp;        data[1] = hex;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_CHANGE_HEXES, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends notification to clients that the specified hex has changed.
&nbsp;     */
&nbsp;    public void sendChangedHexes(Set&lt;Coords&gt; coords) {
<b class="nc">&nbsp;        Set&lt;IHex&gt; hexes = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Coords coord : coords) {</b>
<b class="nc">&nbsp;            hexes.add(game.getBoard().getHex(coord));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        send(createHexesChangePacket(coords, hexes));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing a vector of mines.
&nbsp;     */
&nbsp;    private Packet createMineChangePacket(Coords coords) {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_UPDATE_MINEFIELDS, game.getMinefields(coords));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends notification to clients that the specified hex has changed.
&nbsp;     */
&nbsp;    public void sendChangedMines(Coords coords) {
<b class="nc">&nbsp;        send(createMineChangePacket(coords));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendVisibilityIndicator(Entity e) {
<b class="nc">&nbsp;        final Object[] data = new Object[6];</b>
<b class="nc">&nbsp;        data[0] = e.getId();</b>
<b class="nc">&nbsp;        data[1] = e.isEverSeenByEnemy();</b>
<b class="nc">&nbsp;        data[2] = e.isVisibleToEnemy();</b>
<b class="nc">&nbsp;        data[3] = e.isDetectedByEnemy();</b>
<b class="nc">&nbsp;        data[4] = e.getWhoCanSee();</b>
<b class="nc">&nbsp;        data[5] = e.getWhoCanDetect();</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet for an attack
&nbsp;     */
&nbsp;    private Packet createAttackPacket(List&lt;?&gt; vector, int charges) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = vector;</b>
<b class="nc">&nbsp;        data[1] = charges;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet for an attack
&nbsp;     */
&nbsp;    private Packet createAttackPacket(EntityAction ea, int charge) {
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; vector = new Vector&lt;&gt;(1);</b>
<b class="nc">&nbsp;        vector.addElement(ea);</b>
<b class="nc">&nbsp;        Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = vector;</b>
<b class="nc">&nbsp;        data[1] = charge;</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private Packet createSpecialHexDisplayPacket(int toPlayer) {
<b class="nc">&nbsp;        Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt; shdTable = game</b>
<b class="nc">&nbsp;                .getBoard().getSpecialHexDisplayTable();</b>
<b class="nc">&nbsp;        Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt; shdTable2 = new Hashtable&lt;&gt;();</b>
&nbsp;        LinkedList&lt;SpecialHexDisplay&gt; tempList;
<b class="nc">&nbsp;        IPlayer player = getPlayer(toPlayer);</b>
<b class="nc">&nbsp;        if (player != null) {</b>
<b class="nc">&nbsp;            for (Coords coord : shdTable.keySet()) {</b>
<b class="nc">&nbsp;                tempList = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (SpecialHexDisplay shd : shdTable.get(coord)) {</b>
<b class="nc">&nbsp;                    if (!shd.isObscured(player)) {</b>
<b class="nc">&nbsp;                        tempList.add(0, shd);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (!tempList.isEmpty()) {</b>
<b class="nc">&nbsp;                    shdTable2.put(coord, tempList);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_SPECIAL_HEX_DISPLAY, shdTable2);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Packet createTagInfoUpdatesPacket() {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_TAGINFO, game.getTagInfo());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing off board artillery attacks
&nbsp;     */
&nbsp;    private Packet createArtilleryPacket(IPlayer p) {
<b class="nc">&nbsp;        Vector&lt;ArtilleryAttackAction&gt; v = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        int team = p.getTeam();</b>
<b class="nc">&nbsp;        for (Enumeration&lt;AttackHandler&gt; i = game.getAttacks(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            WeaponHandler wh = (WeaponHandler) i.nextElement();</b>
<b class="nc">&nbsp;            if (wh.waa instanceof ArtilleryAttackAction) {</b>
<b class="nc">&nbsp;                ArtilleryAttackAction aaa = (ArtilleryAttackAction) wh.waa;</b>
<b class="nc">&nbsp;                if ((aaa.getPlayerId() == p.getId())</b>
&nbsp;                        || ((team != IPlayer.TEAM_NONE)
<b class="nc">&nbsp;                        &amp;&amp; (team == game.getPlayer(aaa.getPlayerId()).getTeam()))</b>
<b class="nc">&nbsp;                        || p.getSeeAll()) {</b>
<b class="nc">&nbsp;                    v.addElement(aaa);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_ARTILLERYATTACKS, v);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Packet createIlluminatedHexesPacket() {
<b class="nc">&nbsp;        HashSet&lt;Coords&gt; illuminateHexes = game.getIlluminatedPositions();</b>
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_ILLUM_HEXES, illuminateHexes);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a packet containing flares
&nbsp;     */
&nbsp;    private Packet createFlarePacket() {
&nbsp;
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_SENDING_FLARES, game.getFlares());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Send a packet to all connected clients.
&nbsp;     */
&nbsp;    private void send(Packet packet) {
<b class="nc">&nbsp;        if (connections == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Enumeration&lt;IConnection&gt; connEnum = connections.elements(); connEnum.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IConnection conn = connEnum.nextElement();</b>
<b class="nc">&nbsp;            conn.send(packet);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // WOR
&nbsp;    public void send_Nova_Change(int Id, String net) {
<b class="nc">&nbsp;        Object[] data = {Id, net};</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void sendReport() {
<b class="nc">&nbsp;        sendReport(false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send the round report to all connected clients.
&nbsp;     */
&nbsp;    private void sendReport(boolean tacticalGeniusReport) {
<b class="nc">&nbsp;        if (connections == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Enumeration&lt;IConnection&gt; connEnum = connections.elements(); connEnum.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IConnection conn = connEnum.nextElement();</b>
<b class="nc">&nbsp;            IPlayer p = game.getPlayer(conn.getId());</b>
&nbsp;            Packet packet;
<b class="nc">&nbsp;            if (tacticalGeniusReport) {</b>
<b class="nc">&nbsp;                packet = createTacticalGeniusReportPacket();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                packet = createReportPacket(p);</b>
&nbsp;            }
<b class="nc">&nbsp;            conn.send(packet);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send a packet to a specific connection.
&nbsp;     */
&nbsp;    public void send(int connId, Packet packet) {
<b class="nc">&nbsp;        if (getClient(connId) != null) {</b>
<b class="nc">&nbsp;            getClient(connId).send(packet);</b>
&nbsp;        }
&nbsp;        // What should we do if we&#39;ve lost this client?
&nbsp;        // For now, nothing.
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send a packet to a pending connection
&nbsp;     */
&nbsp;    private void sendToPending(int connId, Packet packet) {
<b class="nc">&nbsp;        IConnection pendingConn = getPendingConnection(connId);</b>
<b class="nc">&nbsp;        if (pendingConn != null) {</b>
<b class="nc">&nbsp;            pendingConn.send(packet);</b>
&nbsp;        }
&nbsp;        // What should we do if we&#39;ve lost this client?
&nbsp;        // For now, nothing.
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Process an in-game command
&nbsp;     */
&nbsp;    private void processCommand(int connId, String commandString) {
&nbsp;        String[] args;
&nbsp;        String commandName;
&nbsp;        // all tokens are read as strings; if they&#39;re numbers, string-ize &#39;em.
&nbsp;        // replaced the tokenizer with the split function.
<b class="nc">&nbsp;        args = commandString.split(&quot;\\s+&quot;);</b>
&nbsp;
&nbsp;        // figure out which command this is
<b class="nc">&nbsp;        commandName = args[0].substring(1);</b>
&nbsp;
&nbsp;        // process it
<b class="nc">&nbsp;        ServerCommand command = getCommand(commandName);</b>
<b class="nc">&nbsp;        if (command != null) {</b>
<b class="nc">&nbsp;            command.run(connId, args);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            sendServerChat(connId,</b>
&nbsp;                    &quot;Command not recognized.  Type /help for a list of commands.&quot;);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Easter eggs. Happy April Fool&#39;s Day!!
&nbsp;    private static final String DUNE_CALL = &quot;They tried and failed?&quot;;
&nbsp;
&nbsp;    private static final String DUNE_RESPONSE = &quot;They tried and died!&quot;;
&nbsp;
&nbsp;    private static final String STAR_WARS_CALL = &quot;I&#39;d just as soon kiss a Wookiee.&quot;;
&nbsp;
&nbsp;    private static final String STAR_WARS_RESPONSE = &quot;I can arrange that!&quot;;
&nbsp;
&nbsp;    private static final String INVADER_ZIM_CALL = &quot;What does the G stand for?&quot;;
&nbsp;
&nbsp;    private static final String INVADER_ZIM_RESPONSE = &quot;I don&#39;t know.&quot;;
&nbsp;
&nbsp;    private static final String WARGAMES_CALL = &quot;Shall we play a game?&quot;;
&nbsp;
&nbsp;    private static final String WARGAMES_RESPONSE = &quot;Let&#39;s play global thermonuclear war.&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Process a packet from a connection.
&nbsp;     *
&nbsp;     * @param connId
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; ID the connection that received the
&nbsp;     *            packet.
&nbsp;     * @param packet
&nbsp;     *            - the &lt;code&gt;Packet&lt;/code&gt; to be processed.
&nbsp;     */
&nbsp;    protected void handle(int connId, Packet packet) {
<b class="nc">&nbsp;        IPlayer player = game.getPlayer(connId);</b>
&nbsp;        // Check player. Please note, the connection may be pending.
<b class="nc">&nbsp;        if ((null == player) &amp;&amp; (null == getPendingConnection(connId))) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server does not recognize player at connection &quot; + connId);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (packet == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Got null packet&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // act on it
<b class="nc">&nbsp;        switch (packet.getCommand()) {</b>
&nbsp;            case Packet.COMMAND_CLIENT_VERSIONS:
<b class="nc">&nbsp;                receivePlayerVersion(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CLOSE_CONNECTION:
&nbsp;                // We have a client going down!
<b class="nc">&nbsp;                IConnection c = getConnection(connId);</b>
<b class="nc">&nbsp;                if (c != null) {</b>
<b class="nc">&nbsp;                    c.close();</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Packet.COMMAND_CLIENT_NAME:
<b class="nc">&nbsp;                receivePlayerName(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_PLAYER_UPDATE:
<b class="nc">&nbsp;                receivePlayerInfo(packet, connId);</b>
<b class="nc">&nbsp;                validatePlayerInfo(connId);</b>
<b class="nc">&nbsp;                send(createPlayerUpdatePacket(connId));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_PLAYER_READY:
<b class="nc">&nbsp;                receivePlayerDone(packet, connId);</b>
<b class="nc">&nbsp;                send(createPlayerDonePacket(connId));</b>
<b class="nc">&nbsp;                checkReady();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_REROLL_INITIATIVE:
<b class="nc">&nbsp;                receiveInitiativeRerollRequest(packet, connId);</b>
&nbsp;                // send(createPlayerDonePacket(connId));
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_FORWARD_INITIATIVE:
<b class="nc">&nbsp;                receiveForwardIni(connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CHAT:
<b class="nc">&nbsp;                String chat = (String) packet.getObject(0);</b>
<b class="nc">&nbsp;                if (chat.startsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;                    processCommand(connId, chat);</b>
<b class="nc">&nbsp;                } else if (packet.getData().length &gt; 1) {</b>
<b class="nc">&nbsp;                    connId = (int) packet.getObject(1);</b>
<b class="nc">&nbsp;                    if (connId == IPlayer.PLAYER_NONE) {</b>
<b class="nc">&nbsp;                        sendServerChat(chat);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        sendServerChat(connId, chat);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    sendChat(player.getName(), chat);</b>
&nbsp;                }
&nbsp;                // Easter eggs. Happy April Fool&#39;s Day!!
<b class="nc">&nbsp;                if (DUNE_CALL.equalsIgnoreCase(chat)) {</b>
<b class="nc">&nbsp;                    sendServerChat(DUNE_RESPONSE);</b>
<b class="nc">&nbsp;                } else if (STAR_WARS_CALL.equalsIgnoreCase(chat)) {</b>
<b class="nc">&nbsp;                    sendServerChat(STAR_WARS_RESPONSE);</b>
<b class="nc">&nbsp;                } else if (INVADER_ZIM_CALL.equalsIgnoreCase(chat)) {</b>
<b class="nc">&nbsp;                    sendServerChat(INVADER_ZIM_RESPONSE);</b>
<b class="nc">&nbsp;                } else if (WARGAMES_CALL.equalsIgnoreCase(chat)) {</b>
<b class="nc">&nbsp;                    sendServerChat(WARGAMES_RESPONSE);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Packet.COMMAND_BLDG_EXPLODE:
<b class="nc">&nbsp;                DemolitionCharge charge = (DemolitionCharge)packet.getData()[0];</b>
<b class="nc">&nbsp;                if (charge.playerId == connId) {</b>
<b class="nc">&nbsp;                    if (!explodingCharges.contains(charge)) {</b>
<b class="nc">&nbsp;                        explodingCharges.add(charge);</b>
<b class="nc">&nbsp;                        IPlayer p = game.getPlayer(connId);</b>
<b class="nc">&nbsp;                        sendServerChat(p.getName() + &quot; has touched off explosives &quot;</b>
&nbsp;                                + &quot;(handled in end phase)!&quot;);
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Packet.COMMAND_ENTITY_MOVE:
<b class="nc">&nbsp;                receiveMovement(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_DEPLOY:
<b class="nc">&nbsp;                receiveDeployment(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_DEPLOY_UNLOAD:
<b class="nc">&nbsp;                receiveDeploymentUnload(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_DEPLOY_MINEFIELDS:
<b class="nc">&nbsp;                receiveDeployMinefields(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_ATTACK:
<b class="nc">&nbsp;                receiveAttack(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_GTA_HEX_SELECT:
<b class="nc">&nbsp;                receiveGroundToAirHexSelectPacket(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_ADD:
<b class="nc">&nbsp;                receiveEntityAdd(packet, connId);</b>
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_UPDATE:
<b class="nc">&nbsp;                receiveEntityUpdate(packet, connId);</b>
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_LOAD:
<b class="nc">&nbsp;                receiveEntityLoad(packet, connId);</b>
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_MODECHANGE:
<b class="nc">&nbsp;                receiveEntityModeChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_SENSORCHANGE:
<b class="nc">&nbsp;                receiveEntitySensorChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_SINKSCHANGE:
<b class="nc">&nbsp;                receiveEntitySinksChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_ACTIVATE_HIDDEN:
<b class="nc">&nbsp;                receiveEntityActivateHidden(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE:
<b class="nc">&nbsp;                receiveEntityNovaNetworkModeChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_MOUNTED_FACINGCHANGE:
<b class="nc">&nbsp;                receiveEntityMountedFacingChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_CALLEDSHOTCHANGE:
<b class="nc">&nbsp;                receiveEntityCalledShotChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_SYSTEMMODECHANGE:
<b class="nc">&nbsp;                receiveEntitySystemModeChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_AMMOCHANGE:
<b class="nc">&nbsp;                receiveEntityAmmoChange(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_REMOVE:
<b class="nc">&nbsp;                receiveEntityDelete(packet, connId);</b>
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_WORDER_UPDATE:
<b class="nc">&nbsp;                Object[] data = packet.getData();</b>
<b class="nc">&nbsp;                Entity ent = game.getEntity((Integer) data[0]);</b>
<b class="nc">&nbsp;                if (ent != null) {</b>
<b class="nc">&nbsp;                    Entity.WeaponSortOrder order = (Entity.WeaponSortOrder) data[1];</b>
<b class="nc">&nbsp;                    ent.setWeaponSortOrder(order);</b>
&nbsp;                    // Used by the client but is set in setWeaponSortOrder
<b class="nc">&nbsp;                    ent.setWeapOrderChanged(false);</b>
<b class="nc">&nbsp;                    if (order == Entity.WeaponSortOrder.CUSTOM) {</b>
&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                        // Unchecked cause of limitations in Java when casting
&nbsp;                        // to a collection
<b class="nc">&nbsp;                        Map&lt;Integer, Integer&gt; customWeaponOrder = (Map&lt;Integer, Integer&gt;) data[2];</b>
<b class="nc">&nbsp;                        ent.setCustomWeaponOrder(customWeaponOrder);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case Packet.COMMAND_SENDING_GAME_SETTINGS:
<b class="nc">&nbsp;                if (receiveGameOptions(packet, connId)) {</b>
<b class="nc">&nbsp;                    resetPlayersDone();</b>
<b class="nc">&nbsp;                    transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                    send(createGameSettingsPacket());</b>
<b class="nc">&nbsp;                    receiveGameOptionsAux(packet, connId);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Packet.COMMAND_SENDING_MAP_SETTINGS:
<b class="nc">&nbsp;                if (game.getPhase().isBefore(Phase.PHASE_DEPLOYMENT)) {</b>
<b class="nc">&nbsp;                    MapSettings newSettings = (MapSettings) packet.getObject(0);</b>
<b class="nc">&nbsp;                    if (!mapSettings.equalMapGenParameters(newSettings)) {</b>
<b class="nc">&nbsp;                        sendServerChat(&quot;Player &quot; + player.getName() + &quot; changed map settings&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    mapSettings = newSettings;</b>
<b class="nc">&nbsp;                    mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(</b>
<b class="nc">&nbsp;                            mapSettings.getBoardWidth(), mapSettings.getBoardHeight())));</b>
<b class="nc">&nbsp;                    mapSettings.removeUnavailable();</b>
<b class="nc">&nbsp;                    mapSettings.setNullBoards(DEFAULT_BOARD);</b>
<b class="nc">&nbsp;                    mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);</b>
<b class="nc">&nbsp;                    mapSettings.removeUnavailable();</b>
&nbsp;                    // if still only nulls left, use BOARD_GENERATED
<b class="nc">&nbsp;                    if (mapSettings.getBoardsSelected().next() == null) {</b>
<b class="nc">&nbsp;                        mapSettings.setNullBoards((MapSettings.BOARD_GENERATED));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    resetPlayersDone();</b>
<b class="nc">&nbsp;                    transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                    send(createMapSettingsPacket());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case Packet.COMMAND_SENDING_MAP_DIMENSIONS:
<b class="nc">&nbsp;                if (game.getPhase().isBefore(Phase.PHASE_DEPLOYMENT)) {</b>
<b class="nc">&nbsp;                    MapSettings newSettings = (MapSettings) packet.getObject(0);</b>
<b class="nc">&nbsp;                    if (!mapSettings.equalMapGenParameters(newSettings)) {</b>
<b class="nc">&nbsp;                        sendServerChat(&quot;Player &quot; + player.getName() + &quot; changed map dimensions&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    mapSettings = newSettings;</b>
<b class="nc">&nbsp;                    mapSettings.setBoardsAvailableVector(scanForBoards(new BoardDimensions(</b>
<b class="nc">&nbsp;                            mapSettings.getBoardWidth(), mapSettings.getBoardHeight())));</b>
<b class="nc">&nbsp;                    mapSettings.removeUnavailable();</b>
<b class="nc">&nbsp;                    mapSettings.setNullBoards(DEFAULT_BOARD);</b>
<b class="nc">&nbsp;                    mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);</b>
<b class="nc">&nbsp;                    mapSettings.removeUnavailable();</b>
&nbsp;                    // if still only nulls left, use BOARD_GENERATED
<b class="nc">&nbsp;                    if (mapSettings.getBoardsSelected().next() == null) {</b>
<b class="nc">&nbsp;                        mapSettings.setNullBoards((MapSettings.BOARD_GENERATED));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    resetPlayersDone();</b>
<b class="nc">&nbsp;                    transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                    send(createMapSettingsPacket());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case Packet.COMMAND_SENDING_PLANETARY_CONDITIONS:
&nbsp;                // MapSettings newSettings = (MapSettings) packet.getObject(0);
<b class="nc">&nbsp;                if (game.getPhase().isBefore(Phase.PHASE_DEPLOYMENT)) {</b>
<b class="nc">&nbsp;                    PlanetaryConditions conditions = (PlanetaryConditions) packet.getObject(0);</b>
<b class="nc">&nbsp;                    sendServerChat(&quot;Player &quot; + player.getName() + &quot; changed planetary conditions&quot;);</b>
<b class="nc">&nbsp;                    game.setPlanetaryConditions(conditions);</b>
<b class="nc">&nbsp;                    resetPlayersDone();</b>
<b class="nc">&nbsp;                    transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                    send(createPlanetaryConditionsPacket());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
&nbsp;            case Packet.COMMAND_UNLOAD_STRANDED:
<b class="nc">&nbsp;                receiveUnloadStranded(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SET_ARTYAUTOHITHEXES:
<b class="nc">&nbsp;                receiveArtyAutoHitHexes(packet, connId);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CUSTOM_INITIATIVE:
<b class="nc">&nbsp;                receiveCustomInit(packet, connId);</b>
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_LOAD_GAME:
&nbsp;                try {
<b class="nc">&nbsp;                    sendServerChat(getPlayer(connId).getName() + &quot; loaded a new game.&quot;);</b>
<b class="nc">&nbsp;                    setGame((IGame) packet.getObject(0));</b>
<b class="nc">&nbsp;                    for (IConnection conn : connections) {</b>
<b class="nc">&nbsp;                        sendCurrentInfo(conn.getId());</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Error loading save game sent from client&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SQUADRON_ADD:
<b class="nc">&nbsp;                receiveSquadronAdd(packet, connId);</b>
<b class="nc">&nbsp;                resetPlayersDone();</b>
<b class="nc">&nbsp;                transmitAllPlayerDones();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_RESET_ROUND_DEPLOYMENT:
<b class="nc">&nbsp;                game.setupRoundDeployment();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SPECIAL_HEX_DISPLAY_DELETE:
<b class="nc">&nbsp;                game.getBoard().removeSpecialHexDisplay((Coords) packet.getObject(0),</b>
<b class="nc">&nbsp;                        (SpecialHexDisplay) packet.getObject(1));</b>
<b class="nc">&nbsp;                sendSpecialHexDisplayPackets();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SPECIAL_HEX_DISPLAY_APPEND:
<b class="nc">&nbsp;                game.getBoard().addSpecialHexDisplay((Coords) packet.getObject(0),</b>
<b class="nc">&nbsp;                        (SpecialHexDisplay) packet.getObject(1));</b>
<b class="nc">&nbsp;                sendSpecialHexDisplayPackets();</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Listen for incoming clients.
&nbsp;     */
&nbsp;    public void run() {
<b class="nc">&nbsp;        Thread currentThread = Thread.currentThread();</b>
<b class="nc">&nbsp;        MegaMek.getLogger().info(&quot;s: listening for clients...&quot;);</b>
<b class="nc">&nbsp;        while (connector == currentThread) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                Socket s = serverSocket.accept();</b>
<b class="nc">&nbsp;                synchronized (serverLock) {</b>
<b class="nc">&nbsp;                    int id = getFreeConnectionId();</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().info(&quot;s: accepting player connection #&quot; + id + &quot;...&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                    IConnection c = ConnectionFactory.getInstance().createServerConnection(s, id);</b>
<b class="nc">&nbsp;                    c.addConnectionListener(connectionListener);</b>
<b class="nc">&nbsp;                    c.open();</b>
<b class="nc">&nbsp;                    connectionsPending.addElement(c);</b>
<b class="nc">&nbsp;                    ConnectionHandler ch = new ConnectionHandler(c);</b>
<b class="nc">&nbsp;                    Thread newConnThread = new Thread(ch, &quot;Connection &quot; + id);</b>
<b class="nc">&nbsp;                    newConnThread.start();</b>
<b class="nc">&nbsp;                    connectionHandlers.put(id, ch);</b>
&nbsp;
<b class="nc">&nbsp;                    greeting(id);</b>
<b class="nc">&nbsp;                    ConnectionWatchdog w = new ConnectionWatchdog(this, id);</b>
<b class="nc">&nbsp;                    watchdogTimer.schedule(w, 1000, 500);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (InterruptedIOException ignored) {</b>
&nbsp;                // ignore , just SOTimeout blowing..
<b class="nc">&nbsp;            } catch (IOException ignored) { }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Makes one slot of inferno ammo, determined by certain rules, explode on a
&nbsp;     * mech.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            The &lt;code&gt;Entity&lt;/code&gt; that should suffer an inferno ammo
&nbsp;     *            explosion.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; explodeInfernoAmmoFromHeat(Entity entity) {
<b class="nc">&nbsp;        int damage = 0;</b>
<b class="nc">&nbsp;        int rack = 0;</b>
<b class="nc">&nbsp;        int boomloc = -1;</b>
<b class="nc">&nbsp;        int boomslot = -1;</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // Find the most destructive Inferno ammo.
<b class="nc">&nbsp;        for (int j = 0; j &lt; entity.locations(); j++) {</b>
<b class="nc">&nbsp;            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {</b>
<b class="nc">&nbsp;                CriticalSlot cs = entity.getCritical(j, k);</b>
&nbsp;                // Ignore empty, destroyed, hit, and structure slots.
<b class="nc">&nbsp;                if ((cs == null) || cs.isDestroyed() || cs.isHit()</b>
<b class="nc">&nbsp;                        || (cs.getType() != CriticalSlot.TYPE_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Ignore everything but ammo or LAM bomb bay slots.
<b class="nc">&nbsp;                Mounted mounted = cs.getMount();</b>
&nbsp;                int newRack;
&nbsp;                int newDamage;
<b class="nc">&nbsp;                if (mounted.getType() instanceof AmmoType) {</b>
<b class="nc">&nbsp;                    AmmoType atype = (AmmoType) mounted.getType();</b>
<b class="nc">&nbsp;                    if (!atype.isExplosive(mounted)</b>
<b class="nc">&nbsp;                            || ((atype.getMunitionType() != AmmoType.M_INFERNO)</b>
<b class="nc">&nbsp;                            &amp;&amp; (atype.getMunitionType() != AmmoType.M_IATM_IIW))) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // ignore empty, destroyed, or missing bins
<b class="nc">&nbsp;                    if (mounted.getHittableShotsLeft() == 0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Find the most destructive undamaged ammo.
&nbsp;                    // TW page 160, compare one rack&#39;s
&nbsp;                    // damage. Ties go to most rounds.
<b class="nc">&nbsp;                    newRack = atype.getDamagePerShot() * atype.getRackSize();</b>
<b class="nc">&nbsp;                    newDamage = mounted.getExplosionDamage();</b>
<b class="nc">&nbsp;                    Mounted mount2 = cs.getMount2();</b>
<b class="nc">&nbsp;                    if ((mount2 != null) &amp;&amp; (mount2.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                            &amp;&amp; (mount2.getHittableShotsLeft() &gt; 0)) {</b>
&nbsp;                        // must be for same weaponType, so rackSize stays
<b class="nc">&nbsp;                        atype = (AmmoType) mount2.getType();</b>
<b class="nc">&nbsp;                        newRack += atype.getDamagePerShot() * atype.getRackSize();</b>
<b class="nc">&nbsp;                        newDamage += mount2.getExplosionDamage();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((mounted.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                        &amp;&amp; mounted.getType().hasFlag(MiscType.F_BOMB_BAY)) {</b>
<b class="nc">&nbsp;                    while (mounted.getLinked() != null) {</b>
<b class="nc">&nbsp;                        mounted = mounted.getLinked();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (mounted.getExplosionDamage() == 0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    newRack = 1;</b>
<b class="nc">&nbsp;                    newDamage = mounted.getExplosionDamage();</b>
&nbsp;                } else {
&nbsp;                    continue;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (!mounted.isHit()</b>
&nbsp;                        &amp;&amp; ((rack &lt; newRack) || ((rack == newRack) &amp;&amp; (damage &lt; newDamage)))) {
<b class="nc">&nbsp;                    rack = newRack;</b>
<b class="nc">&nbsp;                    damage = newDamage;</b>
<b class="nc">&nbsp;                    boomloc = j;</b>
<b class="nc">&nbsp;                    boomslot = k;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // Did we find anything to explode?
<b class="nc">&nbsp;        if ((boomloc != -1) &amp;&amp; (boomslot != -1)) {</b>
<b class="nc">&nbsp;            CriticalSlot slot = entity.getCritical(boomloc, boomslot);</b>
<b class="nc">&nbsp;            slot.setHit(true);</b>
<b class="nc">&nbsp;            Mounted equip = slot.getMount();</b>
<b class="nc">&nbsp;            equip.setHit(true);</b>
&nbsp;            // We&#39;ve allocated heatBuildup to heat in resolveHeat(),
&nbsp;            // so need to add to the entity&#39;s heat instead.
<b class="nc">&nbsp;            if ((equip.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                    || (equip.getLinked() != null</b>
<b class="nc">&nbsp;                        &amp;&amp; equip.getLinked().getType() instanceof BombType</b>
<b class="nc">&nbsp;                        &amp;&amp; ((BombType)equip.getLinked().getType()).getBombType() == BombType.B_INFERNO)) {</b>
<b class="nc">&nbsp;                entity.heat += Math.min(equip.getExplosionDamage(), 30);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.addAll(explodeEquipment(entity, boomloc, boomslot));</b>
<b class="nc">&nbsp;            r = new Report(5155);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(entity.heat);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            entity.heatBuildup = 0;</b>
<b class="nc">&nbsp;        } else { // no ammo to explode</b>
<b class="nc">&nbsp;            r = new Report(5160);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * checks for unintended explosion of heavy industrial zone hex and applies
&nbsp;     * damage to entities occupying the hex
&nbsp;     */
&nbsp;    public void checkExplodeIndustrialZone(Coords c, Vector&lt;Report&gt; vDesc) {
&nbsp;        Report r;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        if (null == hex) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!hex.containsTerrain(Terrains.INDUSTRIAL)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(3590, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.add(c.getBoardNum());</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        int effect = Compute.d6(2);</b>
<b class="nc">&nbsp;        r.add(8);</b>
<b class="nc">&nbsp;        r.add(effect);</b>
<b class="nc">&nbsp;        if (effect &gt; 7) {</b>
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            boolean onFire = false;</b>
<b class="nc">&nbsp;            boolean powerLine = false;</b>
<b class="nc">&nbsp;            boolean minorExp = false;</b>
<b class="nc">&nbsp;            boolean elecExp = false;</b>
<b class="nc">&nbsp;            boolean majorExp = false;</b>
<b class="nc">&nbsp;            if (effect == 8) {</b>
<b class="nc">&nbsp;                onFire = true;</b>
<b class="nc">&nbsp;                r = new Report(3600, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;            } else if (effect == 9) {</b>
<b class="nc">&nbsp;                powerLine = true;</b>
<b class="nc">&nbsp;                r = new Report(3605, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;            } else if (effect == 10) {</b>
<b class="nc">&nbsp;                minorExp = true;</b>
<b class="nc">&nbsp;                onFire = true;</b>
<b class="nc">&nbsp;                r = new Report(3610, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;            } else if (effect == 11) {</b>
<b class="nc">&nbsp;                elecExp = true;</b>
<b class="nc">&nbsp;                r = new Report(3615, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                onFire = true;</b>
<b class="nc">&nbsp;                majorExp = true;</b>
<b class="nc">&nbsp;                r = new Report(3620, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;            }
&nbsp;            // apply damage here
<b class="nc">&nbsp;            if (powerLine || minorExp || elecExp || majorExp) {</b>
&nbsp;                // cycle through the entities in the hex and apply damage
<b class="nc">&nbsp;                for (Entity en : game.getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                    int damage = 3;</b>
<b class="nc">&nbsp;                    if (minorExp) {</b>
<b class="nc">&nbsp;                        damage = 5;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (elecExp) {</b>
<b class="nc">&nbsp;                        damage = Compute.d6(1) + 3;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (majorExp) {</b>
<b class="nc">&nbsp;                        damage = Compute.d6(2);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    if (en instanceof BattleArmor) {</b>
&nbsp;                        // ugly - I have to apply damage to each trooper
&nbsp;                        // separately
<b class="nc">&nbsp;                        for (int loc = 0; loc &lt; en.locations(); loc++) {</b>
<b class="nc">&nbsp;                            if ((IArmorState.ARMOR_NA != en.getInternal(loc))</b>
<b class="nc">&nbsp;                                    &amp;&amp; (IArmorState.ARMOR_DESTROYED != en.getInternal(loc))</b>
<b class="nc">&nbsp;                                    &amp;&amp; (IArmorState.ARMOR_DOOMED != en.getInternal(loc))) {</b>
<b class="nc">&nbsp;                                vDesc.addAll(damageEntity(en, new HitData(loc), damage));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        vDesc.addAll(damageEntity(en, hit, damage));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (majorExp) {</b>
&nbsp;                        // lets pretend that the infernos came from the entity
&nbsp;                        // itself (should give us side_front)
<b class="nc">&nbsp;                        vDesc.addAll(deliverInfernoMissiles(en, en, Compute.d6(2)));</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;            if (onFire &amp;&amp; !hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;                ignite(c, Terrains.FIRE_LVL_NORMAL, vDesc);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // report no explosion
<b class="nc">&nbsp;            r.choose(false);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the results of an entity moving through a wall of a building
&nbsp;     * after having moved a certain distance. This gets called when a Mech or a
&nbsp;     * Tank enters a building, leaves a building, or travels from one hex to
&nbsp;     * another inside a multi-hex building.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            - the &lt;code&gt;Entity&lt;/code&gt; that passed through a wall. Don&#39;t
&nbsp;     *            pass &lt;code&gt;Infantry&lt;/code&gt; units to this method.
&nbsp;     * @param bldg
&nbsp;     *            - the &lt;code&gt;Building&lt;/code&gt; the entity is passing through.
&nbsp;     * @param lastPos
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the hex the entity is exiting.
&nbsp;     * @param curPos
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the hex the entity is entering
&nbsp;     * @param distance
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; number of hexes the entity has moved
&nbsp;     *            already this phase.
&nbsp;     * @param why
&nbsp;     *            - the &lt;code&gt;String&lt;/code&gt; explanation for this action.
&nbsp;     * @param backwards
&nbsp;     *            - the &lt;code&gt;boolean&lt;/code&gt; indicating if the entity is
&nbsp;     *            entering the hex backwards
&nbsp;     * @param entering
&nbsp;     *            - a &lt;code&gt;boolean&lt;/code&gt; if the entity is entering or exiting
&nbsp;     *            a building
&nbsp;     */
&nbsp;    private void passBuildingWall(Entity entity, Building bldg, Coords lastPos, Coords curPos,
&nbsp;                                  int distance, String why, boolean backwards,
&nbsp;                                  EntityMovementType overallMoveType, boolean entering) {
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; vBuildingReport = damageBuilding(bldg, 1, curPos);</b>
<b class="nc">&nbsp;            for (Report report : vBuildingReport) {</b>
<b class="nc">&nbsp;                report.subject = entity.getId();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            addReport(vBuildingReport);</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Need to roll based on building type.
<b class="nc">&nbsp;            PilotingRollData psr = entity.rollMovementInBuilding(bldg, distance, why, overallMoveType);</b>
&nbsp;
&nbsp;            // Did the entity make the roll?
<b class="nc">&nbsp;            if (0 &lt; doSkillCheckWhileMoving(entity, entity.getElevation(), lastPos, curPos, psr, false)) {</b>
&nbsp;
&nbsp;                // Divide the building&#39;s current CF by 10, round up.
<b class="nc">&nbsp;                int damage = (int) Math.floor(bldg.getDamageFromScale()</b>
<b class="nc">&nbsp;                        * Math.ceil(bldg.getCurrentCF(entering ? curPos : lastPos) / 10.0));</b>
&nbsp;
&nbsp;                // Infantry and Battle armor take different amounts of damage
&nbsp;                // then Meks and vehicles.
<b class="nc">&nbsp;                if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;                    damage = bldg.getType() + 1;</b>
&nbsp;                }
&nbsp;                // It is possible that the unit takes no damage.
<b class="nc">&nbsp;                if (damage == 0) {</b>
<b class="nc">&nbsp;                    r = new Report(6440);</b>
<b class="nc">&nbsp;                    r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                } else {
&nbsp;                    // TW, pg. 268: if unit moves forward, damage from front,
&nbsp;                    // if backwards, damage from rear.
<b class="nc">&nbsp;                    int side = ToHitData.SIDE_FRONT;</b>
<b class="nc">&nbsp;                    if (backwards) {</b>
<b class="nc">&nbsp;                        side = ToHitData.SIDE_REAR;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, side);</b>
<b class="nc">&nbsp;                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(entity, hit, damage));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Infantry and BA are damaged by buildings but do not damage them
<b class="nc">&nbsp;            if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // Damage the building. The CF can never drop below 0.
<b class="nc">&nbsp;            int toBldg = (int) Math.floor(bldg.getDamageToScale()</b>
<b class="nc">&nbsp;                    * Math.ceil(entity.getWeight() / 10.0));</b>
<b class="nc">&nbsp;            int curCF = bldg.getCurrentCF(entering ? curPos : lastPos);</b>
<b class="nc">&nbsp;            curCF -= Math.min(curCF, toBldg);</b>
<b class="nc">&nbsp;            bldg.setCurrentCF(curCF, entering ? curPos : lastPos);</b>
&nbsp;
&nbsp;            // Apply the correct amount of damage to infantry in the building.
&nbsp;            // ASSUMPTION: We inflict toBldg damage to infantry and
&nbsp;            // not the amount to bring building to 0 CF.
<b class="nc">&nbsp;            addReport(damageInfantryIn(bldg, toBldg, entering ? curPos : lastPos));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * check if a building collapses because of a moving entity
&nbsp;     *
&nbsp;     * @param bldg
&nbsp;     *            the &lt;code&gt;Building&lt;/code&gt;
&nbsp;     * @param entity
&nbsp;     *            the &lt;code&gt;Entity&lt;/code&gt;
&nbsp;     * @param curPos
&nbsp;     *            the &lt;code&gt;Coords&lt;/code&gt; of the position of the entity
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; value indicating if the building collapses
&nbsp;     */
&nbsp;    private boolean checkBuildingCollapseWhileMoving(Building bldg, Entity entity, Coords curPos) {
<b class="nc">&nbsp;        Coords oldPos = entity.getPosition();</b>
&nbsp;        // Count the moving entity in its current position, not
&nbsp;        // its pre-move position. Be sure to handle nulls.
<b class="nc">&nbsp;        entity.setPosition(curPos);</b>
&nbsp;
&nbsp;        // Get the position map of all entities in the game.
<b class="nc">&nbsp;        Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap = game.getPositionMap();</b>
&nbsp;
&nbsp;        // Check for collapse of this building due to overloading, and return.
<b class="nc">&nbsp;        boolean rv = checkForCollapse(bldg, positionMap, curPos, true, vPhaseReport);</b>
&nbsp;
&nbsp;        // If the entity was not displaced and didn&#39;t fall, move it back where it was
<b class="nc">&nbsp;        if (curPos.equals(entity.getPosition()) &amp;&amp; !entity.isProne()) {</b>
<b class="nc">&nbsp;            entity.setPosition(oldPos);</b>
&nbsp;        }
<b class="nc">&nbsp;        return rv;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Report&gt; damageInfantryIn(Building bldg, int damage, Coords hexCoords) {
<b class="nc">&nbsp;        return damageInfantryIn(bldg, damage, hexCoords, WeaponType.WEAPON_NA);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply the correct amount of damage that passes on to any infantry unit in
&nbsp;     * the given building, based upon the amount of damage the building just
&nbsp;     * sustained. This amount is a percentage dictated by pg. 172 of TW.
&nbsp;     *
&nbsp;     * @param bldg   - the &lt;code&gt;Building&lt;/code&gt; that sustained the damage.
&nbsp;     * @param damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageInfantryIn(Building bldg, int damage, Coords hexCoords,
&nbsp;                                           int infDamageClass) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        if (bldg == null) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;        // Calculate the amount of damage the infantry will sustain.
<b class="nc">&nbsp;        float percent = bldg.getDamageReductionFromOutside();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // Round up at .5 points of damage.
<b class="nc">&nbsp;        int toInf = Math.round(damage * percent);</b>
&nbsp;
&nbsp;        // some buildings scale remaining damage
<b class="nc">&nbsp;        toInf = (int) Math.floor(bldg.getDamageToScale() * toInf);</b>
&nbsp;
&nbsp;        // Walk through the entities in the game.
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            final Coords coords = entity.getPosition();</b>
&nbsp;
&nbsp;            // If the entity is infantry in the affected hex?
<b class="nc">&nbsp;            if ((entity instanceof Infantry) &amp;&amp; bldg.isIn(coords) &amp;&amp; coords.equals(hexCoords)) {</b>
&nbsp;                // Is the entity is inside of the building
&nbsp;                // (instead of just on top of it)?
<b class="nc">&nbsp;                if (Compute.isInBuilding(game, entity, coords)) {</b>
&nbsp;
&nbsp;                    // Report if the infantry receive no points of damage.
<b class="nc">&nbsp;                    if (toInf == 0) {</b>
<b class="nc">&nbsp;                        r = new Report(6445);</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                    } else {
&nbsp;                        // Yup. Damage the entity.
<b class="nc">&nbsp;                        r = new Report(6450);</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        r.subject = entity.getId();</b>
<b class="nc">&nbsp;                        r.add(toInf);</b>
<b class="nc">&nbsp;                        r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                        // need to adjust damage to conventional infantry
&nbsp;                        // TW page 217 says left over damage gets treated as
&nbsp;                        // direct fire ballistic damage
<b class="nc">&nbsp;                        if (!(entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                            toInf = Compute.directBlowInfantryDamage(toInf, 0,</b>
&nbsp;                                    WeaponType.WEAPON_DIRECT_FIRE, false, false);
&nbsp;                        }
<b class="nc">&nbsp;                        int remaining = toInf;</b>
<b class="nc">&nbsp;                        int cluster = toInf;</b>
&nbsp;                        // Battle Armor units use 5 point clusters.
<b class="nc">&nbsp;                        if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                            cluster = 5;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        while (remaining &gt; 0) {</b>
<b class="nc">&nbsp;                            int next = Math.min(cluster, remaining);</b>
<b class="nc">&nbsp;                            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                            vDesc.addAll((damageEntity(entity, hit, next)));</b>
<b class="nc">&nbsp;                            remaining -= next;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
&nbsp;                } // End infantry-inside-building
&nbsp;            } // End entity-is-infantry-in-building-hex
<b class="nc">&nbsp;        } // Handle the next entity</b>
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    } // End private void damageInfantryIn( Building, int )
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the given building should collapse. If so, inflict the
&nbsp;     * appropriate amount of damage on each entity in the building and update
&nbsp;     * the clients. If the building does not collapse, determine if any entities
&nbsp;     * crash through its floor into its basement. Again, apply appropriate
&nbsp;     * damage.
&nbsp;     *
&nbsp;     * @param bldg
&nbsp;     *            - the &lt;code&gt;Building&lt;/code&gt; being checked. This value should
&nbsp;     *            not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param positionMap
&nbsp;     *            - a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt;
&nbsp;     *            positions or each unit in the game to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     *            &lt;code&gt;Entity&lt;/code&gt;s at that position. This value should not
&nbsp;     *            be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the building hex to be checked
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the building collapsed.
&nbsp;     */
&nbsp;    public boolean checkForCollapse(Building bldg, Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap,
&nbsp;                                    Coords coords, boolean checkBecauseOfDamage,
&nbsp;                                    Vector&lt;Report&gt; vPhaseReport) {
&nbsp;
&nbsp;        // If the input is meaningless, do nothing and throw no exception.
<b class="nc">&nbsp;        if ((bldg == null) || (positionMap == null) || positionMap.isEmpty()</b>
<b class="nc">&nbsp;                || (coords == null) || !bldg.isIn(coords) || !bldg.hasCFIn(coords)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the building&#39;s current CF.
<b class="nc">&nbsp;        int currentCF = bldg.getCurrentCF(coords);</b>
&nbsp;
&nbsp;        // Track all units that fall into the building&#39;s basement by Coords.
<b class="nc">&nbsp;        Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; basementMap = new Hashtable&lt;&gt;();</b>
&nbsp;
&nbsp;        // look for a collapse.
<b class="nc">&nbsp;        boolean collapse = false;</b>
&nbsp;
<b class="nc">&nbsp;        boolean basementCollapse = false;</b>
&nbsp;
<b class="nc">&nbsp;        boolean topFloorCollapse = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (checkBecauseOfDamage &amp;&amp; (currentCF &lt;= 0)) {</b>
<b class="nc">&nbsp;            collapse = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the Vector of Entities at these coordinates.
<b class="nc">&nbsp;        final Vector&lt;Entity&gt; vector = positionMap.get(coords);</b>
&nbsp;
&nbsp;        // Are there any Entities at these coords?
<b class="nc">&nbsp;        if (vector != null) {</b>
&nbsp;            // How many levels does this building have in this hex?
<b class="nc">&nbsp;            final IHex curHex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;            final int numFloors = Math.max(0, curHex.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;            final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;            int numLoads = numFloors;</b>
<b class="nc">&nbsp;            if (bridgeEl != ITerrain.LEVEL_NONE) {</b>
<b class="nc">&nbsp;                numLoads++;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (numLoads &lt; 1) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Check for collapse: hex &quot; + coords.toString() </b>
&nbsp;                        + &quot; has no bridge or building&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Track the load of each floor (and of the roof) separately.
&nbsp;            // Track all units that fall into the basement in this hex.
&nbsp;            // track all floors, ground at index 0, the first floor is at
&nbsp;            // index 1, the second is at index 1, etc., and the roof is
&nbsp;            // at index (numFloors).
&nbsp;            // if bridge is present, bridge will be numFloors+1
<b class="nc">&nbsp;            double[] loads = new double[numLoads + 1];</b>
&nbsp;            // WiGEs flying over the building are also tracked, but can only collapse the top floor
&nbsp;            // and only count 25% of their tonnage.
<b class="nc">&nbsp;            double wigeLoad = 0;</b>
&nbsp;            // track all units that might fall into the basement
<b class="nc">&nbsp;            Vector&lt;Entity&gt; basement = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            boolean recheckLoop = true;</b>
<b class="nc">&nbsp;            for (int i = 0; (i &lt; 2) &amp;&amp; recheckLoop; i++) {</b>
<b class="nc">&nbsp;                recheckLoop = false;</b>
<b class="nc">&nbsp;                Arrays.fill(loads, 0);</b>
&nbsp;
&nbsp;                // Walk through the entities in this position.
<b class="nc">&nbsp;                Enumeration&lt;Entity&gt; entities = vector.elements();</b>
<b class="nc">&nbsp;                while (!collapse &amp;&amp; entities.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    final Entity entity = entities.nextElement();</b>
&nbsp;                    // WiGEs can collapse the top floor of a building by flying over it.
<b class="nc">&nbsp;                    final int entityElev = entity.getElevation();</b>
<b class="nc">&nbsp;                    final boolean wigeFlyover = entity.getMovementMode() == EntityMovementMode.WIGE</b>
&nbsp;                            &amp;&amp; entityElev == numFloors + 1;
&nbsp;
<b class="nc">&nbsp;                    if (entityElev != bridgeEl &amp;&amp; !wigeFlyover) {</b>
&nbsp;                        // Ignore entities not *inside* the building
<b class="nc">&nbsp;                        if (entityElev &gt; numFloors) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    
&nbsp;                    // if we&#39;re under a bridge, we can&#39;t collapse the bridge
<b class="nc">&nbsp;                    if (entityElev &lt; bridgeEl) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if ((entity.getMovementMode() == EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                            || (entity.getMovementMode() == EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                            || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;                            || (entity.getMovementMode() == EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                            || entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS)) {</b>
<b class="nc">&nbsp;                        continue; // under the bridge even at same level</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (entityElev == 0) {</b>
<b class="nc">&nbsp;                        basement.add(entity);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // units already in the basement
<b class="nc">&nbsp;                    if (entityElev &lt; 0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Add the weight to the correct floor.
<b class="nc">&nbsp;                    double load = entity.getWeight();</b>
<b class="nc">&nbsp;                    int floor = entityElev;</b>
<b class="nc">&nbsp;                    if (floor == bridgeEl) {</b>
<b class="nc">&nbsp;                        floor = numLoads;</b>
&nbsp;                    }
&nbsp;                    // Entities on the roof fall to the previous top floor/new roof
<b class="nc">&nbsp;                    if (topFloorCollapse &amp;&amp; floor == numFloors) {</b>
<b class="nc">&nbsp;                        floor--;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (wigeFlyover) {</b>
<b class="nc">&nbsp;                        wigeLoad += load;</b>
<b class="nc">&nbsp;                        if (wigeLoad &gt; currentCF * 4) {</b>
<b class="nc">&nbsp;                            topFloorCollapse = true;</b>
<b class="nc">&nbsp;                            loads[numFloors - 1] += loads[numFloors];</b>
<b class="nc">&nbsp;                            loads[numFloors] = 0;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        loads[floor] += load;</b>
<b class="nc">&nbsp;                        if (loads[floor] &gt; currentCF) {</b>
&nbsp;                            // If the load on any floor but the ground floor
&nbsp;                            // exceeds the building&#39;s current CF it collapses.
<b class="nc">&nbsp;                            if (floor != 0) {</b>
<b class="nc">&nbsp;                                collapse = true;</b>
<b class="nc">&nbsp;                            } else if (!bldg.getBasementCollapsed(coords)) {</b>
<b class="nc">&nbsp;                                basementCollapse = true;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } // End increase-load
<b class="nc">&nbsp;                } // Handle the next entity.</b>
&nbsp;
&nbsp;                // Track all entities that fell into the basement.
<b class="nc">&nbsp;                if (basementCollapse) {</b>
<b class="nc">&nbsp;                    basementMap.put(coords, basement);</b>
&nbsp;                }
&nbsp;
&nbsp;                // did anyone fall into the basement?
<b class="nc">&nbsp;                if (!basementMap.isEmpty() &amp;&amp; (bldg.getBasement(coords) != BasementType.NONE) &amp;&amp; !collapse) {</b>
<b class="nc">&nbsp;                    collapseBasement(bldg, basementMap, coords, vPhaseReport);</b>
<b class="nc">&nbsp;                    if (currentCF == 0) {</b>
<b class="nc">&nbsp;                        collapse = true;</b>
<b class="nc">&nbsp;                        recheckLoop = false;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        recheckLoop = true; // basement collapse might cause a further collapse</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    recheckLoop = false; // don&#39;t check again, we didn&#39;t change the CF</b>
&nbsp;                }
<b class="nc">&nbsp;                if (collapse) {</b>
<b class="nc">&nbsp;                    recheckLoop = false;</b>
&nbsp;                    // recheck if the basement collapsed since the basement falls
&nbsp;                    // might trigger a greater collapse.
&nbsp;                }
&nbsp;            } // End have-entities-here
&nbsp;        }
&nbsp;
&nbsp;        // Collapse the building if the flag is set.
<b class="nc">&nbsp;        if (collapse) {</b>
<b class="nc">&nbsp;            Report r = new Report(2375, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.add(bldg.getName());</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;            collapseBuilding(bldg, positionMap, coords, false, vPhaseReport);</b>
<b class="nc">&nbsp;        } else if (topFloorCollapse) {</b>
<b class="nc">&nbsp;                Report r = new Report(2376, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.add(bldg.getName());</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                collapseBuilding(bldg, positionMap, coords, false, true, vPhaseReport);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Return true if the building collapsed.
<b class="nc">&nbsp;        return collapse || topFloorCollapse;</b>
&nbsp;
&nbsp;    } // End private boolean checkForCollapse( Building, Hashtable )
&nbsp;
&nbsp;    public void collapseBuilding(Building bldg, Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap,
&nbsp;                                 Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        collapseBuilding(bldg, positionMap, coords, true, false, vPhaseReport);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void collapseBuilding(Building bldg, Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap,
&nbsp;                                 Coords coords, boolean collapseAll, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        collapseBuilding(bldg, positionMap, coords, collapseAll, false, vPhaseReport);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Collapse a building basement. Inflict the appropriate amount of damage on
&nbsp;     * all entities that fell to the basement. Update all clients.
&nbsp;     *
&nbsp;     * @param bldg
&nbsp;     *            - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.
&nbsp;     * @param positionMap
&nbsp;     *            - a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt;
&nbsp;     *            positions or each unit in the game to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     *            &lt;code&gt;Entity&lt;/code&gt;s at that position. This value should not
&nbsp;     *            be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param coords
&nbsp;     *            - The &lt;code&gt;Coords&gt;&lt;/code&gt; of the building basement hex that
&nbsp;     *            has collapsed
&nbsp;     */
&nbsp;    public void collapseBasement(Building bldg, Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap,
&nbsp;                                 Coords coords, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        if (!bldg.hasCFIn(coords)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        int runningCFTotal;
<b class="nc">&nbsp;        runningCFTotal = bldg.getCurrentCF(coords);</b>
&nbsp;
&nbsp;        // Get the Vector of Entities at these coordinates.
<b class="nc">&nbsp;        final Vector&lt;Entity&gt; entities = positionMap.get(coords);</b>
&nbsp;
<b class="nc">&nbsp;        if (bldg.getBasement(coords) == BasementType.NONE) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bldg.collapseBasement(coords, game.getBoard(), vPhaseReport);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Are there any Entities at these coords?
<b class="nc">&nbsp;        if (entities != null) {</b>
&nbsp;
&nbsp;            // Sort in elevation order
<b class="nc">&nbsp;            entities.sort((a, b) -&gt; {</b>
<b class="nc">&nbsp;                if (a.getElevation() &gt; b.getElevation()) {</b>
<b class="nc">&nbsp;                    return -1;</b>
<b class="nc">&nbsp;                } else if (a.getElevation() &gt; b.getElevation()) {</b>
<b class="nc">&nbsp;                    return 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            });
&nbsp;            // Walk through the entities in this position.
<b class="nc">&nbsp;            for (Entity entity : entities) {</b>
&nbsp;
&nbsp;                // int floor = entity.getElevation();
&nbsp;
<b class="nc">&nbsp;                int cfDamage = (int) Math.ceil(Math.round(entity.getWeight() / 10.0));</b>
&nbsp;
&nbsp;                // all entities should fall
&nbsp;                // ASSUMPTION: PSR to avoid pilot damage
<b class="nc">&nbsp;                PilotingRollData psr = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                entity.addPilotingModifierForTerrain(psr, coords);</b>
&nbsp;
&nbsp;                // fall into basement
<b class="nc">&nbsp;                if ((bldg.getBasement(coords) == BasementType.TWO_DEEP_HEAD)</b>
<b class="nc">&nbsp;                        || (bldg.getBasement(coords) == BasementType.TWO_DEEP_FEET)) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(entity.getDisplayName() + &quot; is falling 2 floors into &quot; + coords.toString());</b>
&nbsp;                    // Damage is determined by the depth of the basement, so a
&nbsp;                    //  fall of 0 elevation is correct in this case
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFall(entity, coords, 0,</b>
<b class="nc">&nbsp;                            Compute.d6(), psr, true, false));</b>
<b class="nc">&nbsp;                    runningCFTotal -= cfDamage * 2;</b>
<b class="nc">&nbsp;                } else if ((bldg.getBasement(coords) != BasementType.NONE)</b>
<b class="nc">&nbsp;                           &amp;&amp; (bldg.getBasement(coords) != BasementType.ONE_DEEP_NORMALINFONLY)) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(entity.getDisplayName() + &quot; is falling 1 floor into &quot; + coords.toString());</b>
&nbsp;                    // Damage is determined by the depth of the basement, so a
&nbsp;                    //  fall of 0 elevation is correct in this case
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFall(entity, coords, 0,</b>
<b class="nc">&nbsp;                            Compute.d6(), psr, true, false));</b>
<b class="nc">&nbsp;                    runningCFTotal -= cfDamage;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    MegaMek.getLogger().error(entity.getDisplayName() + &quot; is not falling into &quot; + coords.toString());</b>
&nbsp;                }
&nbsp;
&nbsp;                // Update this entity.
&nbsp;                // ASSUMPTION: this is the correct thing to do.
<b class="nc">&nbsp;                entityUpdate(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;            } // Handle the next entity.</b>
&nbsp;
&nbsp;        } // End have-entities-here.
&nbsp;
&nbsp;        // Update the building
<b class="nc">&nbsp;        if (runningCFTotal &lt; 0) {</b>
<b class="nc">&nbsp;            bldg.setCurrentCF(0, coords);</b>
<b class="nc">&nbsp;            bldg.setPhaseCF(0, coords);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bldg.setCurrentCF(runningCFTotal, coords);</b>
<b class="nc">&nbsp;            bldg.setPhaseCF(runningCFTotal, coords);</b>
&nbsp;        }
<b class="nc">&nbsp;        sendChangedHex(coords);</b>
<b class="nc">&nbsp;        Vector&lt;Building&gt; buildings = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        buildings.add(bldg);</b>
<b class="nc">&nbsp;        sendChangedBuildings(buildings);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Collapse a building hex. Inflict the appropriate amount of damage on all
&nbsp;     * entities in the building. Update all clients.
&nbsp;     *
&nbsp;     * @param bldg
&nbsp;     *            - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.
&nbsp;     * @param positionMap
&nbsp;     *            - a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt;
&nbsp;     *            positions or each unit in the game to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     *            &lt;code&gt;Entity&lt;/code&gt;s at that position. This value should not
&nbsp;     *            be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param coords
&nbsp;     *            - The &lt;code&gt;Coords&gt;&lt;/code&gt; of the building hex that has
&nbsp;     *            collapsed
&nbsp;     * @param collapseAll
&nbsp;     *            - A &lt;code&gt;boolean&lt;/code&gt; indicating whether or not this
&nbsp;     *            collapse of a hex should be able to collapse the whole
&nbsp;     *            building
&nbsp;     * @param topFloor
&nbsp;     *            - A &lt;code&gt;boolean&lt;/code&gt; indicating that only the top floor collapses
&nbsp;     *              (from a WiGE flying over the top).
&nbsp;     *
&nbsp;     */
&nbsp;    public void collapseBuilding(Building bldg,
&nbsp;            Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap, Coords coords,
&nbsp;            boolean collapseAll, boolean topFloor, Vector&lt;Report&gt; vPhaseReport) {
&nbsp;        // sometimes, buildings that reach CF 0 decide against collapsing
&nbsp;        // but we want them to go away anyway, as a building with CF 0 cannot stand
<b class="nc">&nbsp;        final int phaseCF = bldg.hasCFIn(coords) ? bldg.getPhaseCF(coords) : 0;</b>
&nbsp;
&nbsp;        // Loop through the hexes in the building, and apply
&nbsp;        // damage to all entities inside or on top of the building.
&nbsp;        Report r;
&nbsp;        
&nbsp;        // Get the Vector of Entities at these coordinates.
<b class="nc">&nbsp;        final Vector&lt;Entity&gt; vector = positionMap.get(coords);</b>
&nbsp;
&nbsp;        // Are there any Entities at these coords?
<b class="nc">&nbsp;        if (vector != null) {</b>
&nbsp;
&nbsp;            // How many levels does this building have in this hex?
<b class="nc">&nbsp;            final IHex curHex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;            final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;            final int numFloors = Math.max(bridgeEl,</b>
<b class="nc">&nbsp;                    curHex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;
&nbsp;            // Now collapse the building in this hex, so entities fall to
&nbsp;            // the ground
<b class="nc">&nbsp;            if (topFloor &amp;&amp; numFloors &gt; 1) {</b>
<b class="nc">&nbsp;                curHex.removeTerrain(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;                curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.BLDG_ELEV, numFloors - 1));</b>
<b class="nc">&nbsp;                sendChangedHex(coords);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                bldg.setCurrentCF(0, coords);</b>
<b class="nc">&nbsp;                bldg.setPhaseCF(0, coords);</b>
<b class="nc">&nbsp;                send(createCollapseBuildingPacket(coords));</b>
<b class="nc">&nbsp;                game.getBoard().collapseBuilding(coords);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Sort in elevation order
<b class="nc">&nbsp;            vector.sort((a, b) -&gt; {</b>
<b class="nc">&nbsp;                if (a.getElevation() &gt; b.getElevation()) {</b>
<b class="nc">&nbsp;                    return -1;</b>
<b class="nc">&nbsp;                } else if (a.getElevation() &gt; b.getElevation()) {</b>
<b class="nc">&nbsp;                    return 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            });
&nbsp;            // Walk through the entities in this position.
<b class="nc">&nbsp;            Enumeration&lt;Entity&gt; entities = vector.elements();</b>
<b class="nc">&nbsp;            while (entities.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Entity entity = entities.nextElement();</b>
&nbsp;                // all gun emplacements are simply destroyed
<b class="nc">&nbsp;                if (entity instanceof GunEmplacement) {</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(destroyEntity(entity, &quot;building collapse&quot;));</b>
<b class="nc">&nbsp;                    addNewLines();</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int floor = entity.getElevation();</b>
&nbsp;                // If only the top floor collapses, we only care about units on the top level
&nbsp;                // or on the roof.
<b class="nc">&nbsp;                if (topFloor &amp;&amp; floor &lt; numFloors - 1) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // units trapped in a basement under a collapsing building are
&nbsp;                // destroyed
<b class="nc">&nbsp;                if (floor &lt; 0) {</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(destroyEntity(entity,</b>
&nbsp;                            &quot;Crushed under building rubble&quot;, false, false));
&nbsp;                }
&nbsp;
&nbsp;                // Ignore units above the building / bridge.
<b class="nc">&nbsp;                if (floor &gt; numFloors) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Treat units on the roof like
&nbsp;                // they were in the top floor.
<b class="nc">&nbsp;                if (floor == numFloors) {</b>
<b class="nc">&nbsp;                    floor--;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Calculate collapse damage for this entity.
<b class="nc">&nbsp;                int damage = (int) Math.floor(bldg.getDamageFromScale()</b>
<b class="nc">&nbsp;                        * Math.ceil((phaseCF * (numFloors - floor)) / 10.0));</b>
&nbsp;
&nbsp;                // Infantry suffer more damage.
<b class="nc">&nbsp;                if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;                    if ((entity instanceof BattleArmor) || ((Infantry) entity).isMechanized()) {</b>
<b class="nc">&nbsp;                        damage *= 2;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        damage *= 3;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Apply collapse damage the entity.
<b class="nc">&nbsp;                r = new Report(6455);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                int remaining = damage;</b>
<b class="nc">&nbsp;                int cluster = damage;</b>
<b class="nc">&nbsp;                if ((entity instanceof BattleArmor) || (entity instanceof Mech)</b>
&nbsp;                        || (entity instanceof Tank)) {
<b class="nc">&nbsp;                    cluster = 5;</b>
&nbsp;                }
<b class="nc">&nbsp;                while (remaining &gt; 0) {</b>
<b class="nc">&nbsp;                    int next = Math.min(cluster, remaining);</b>
&nbsp;                    int table;
<b class="nc">&nbsp;                    if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                        table = ToHitData.HIT_SPECIAL_PROTO;</b>
<b class="nc">&nbsp;                    } else if (entity.getElevation() == numFloors) {</b>
<b class="nc">&nbsp;                        table = ToHitData.HIT_NORMAL;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        table = ToHitData.HIT_PUNCH;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    HitData hit = entity.rollHitLocation(table, ToHitData.SIDE_FRONT);</b>
<b class="nc">&nbsp;                    hit.setGeneralDamageType(HitData.DAMAGE_PHYSICAL);</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(damageEntity(entity, hit, next));</b>
<b class="nc">&nbsp;                    remaining -= next;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                vPhaseReport.add(new Report(1210, Report.PUBLIC));</b>
&nbsp;
&nbsp;                // all entities should fall
<b class="nc">&nbsp;                floor = entity.getElevation();</b>
<b class="nc">&nbsp;                if ((floor &gt; 0) || (floor == bridgeEl)) {</b>
&nbsp;                    // ASSUMPTION: PSR to avoid pilot damage
&nbsp;                    // should use mods for entity damage and
&nbsp;                    // 20+ points of collapse damage (if any).
<b class="nc">&nbsp;                    PilotingRollData psr = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;                    entity.addPilotingModifierForTerrain(psr, coords);</b>
<b class="nc">&nbsp;                    if (damage &gt;= 20) {</b>
<b class="nc">&nbsp;                        psr.addModifier(1, &quot;20+ damage&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFallsInto(entity, coords, psr,</b>
&nbsp;                            true));
&nbsp;                }
&nbsp;                // Update this entity.
&nbsp;                // ASSUMPTION: this is the correct thing to do.
<b class="nc">&nbsp;                entityUpdate(entity.getId());</b>
&nbsp;
<b class="nc">&nbsp;            } // Handle the next entity.</b>
&nbsp;
<b class="nc">&nbsp;        } // End have-entities-here.</b>
&nbsp;
&nbsp;        else {
&nbsp;            // Update the building.
<b class="nc">&nbsp;            bldg.setCurrentCF(0, coords);</b>
<b class="nc">&nbsp;            bldg.setPhaseCF(0, coords);</b>
<b class="nc">&nbsp;            send(createCollapseBuildingPacket(coords));</b>
<b class="nc">&nbsp;            game.getBoard().collapseBuilding(coords);</b>
&nbsp;        }
&nbsp;        // if more than half of the hexes are gone, collapse all
<b class="nc">&nbsp;        if (bldg.getCollapsedHexCount() &gt; (bldg.getOriginalHexCount() / 2)) {</b>
<b class="nc">&nbsp;            for (Enumeration&lt;Coords&gt; coordsEnum = bldg.getCoords(); coordsEnum</b>
<b class="nc">&nbsp;                    .hasMoreElements();) {</b>
<b class="nc">&nbsp;                coords = coordsEnum.nextElement();</b>
<b class="nc">&nbsp;                collapseBuilding(bldg, game.getPositionMap(), coords, false,</b>
&nbsp;                        vPhaseReport);
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    } // End private void collapseBuilding( Building )</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tell the clients to replace the given building with rubble hexes.
&nbsp;     *
&nbsp;     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; that has collapsed.
&nbsp;     * @return a &lt;code&gt;Packet&lt;/code&gt; for the command.
&nbsp;     */
&nbsp;    private Packet createCollapseBuildingPacket(Coords coords) {
<b class="nc">&nbsp;        Vector&lt;Coords&gt; coordsV = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        coordsV.addElement(coords);</b>
<b class="nc">&nbsp;        return createCollapseBuildingPacket(coordsV);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tell the clients to replace the given building hexes with rubble hexes.
&nbsp;     *
&nbsp;     * @param coords - a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Coords&lt;/code&gt;s that has
&nbsp;     *               collapsed.
&nbsp;     * @return a &lt;code&gt;Packet&lt;/code&gt; for the command.
&nbsp;     */
&nbsp;    private Packet createCollapseBuildingPacket(Vector&lt;Coords&gt; coords) {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_BLDG_COLLAPSE, coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tell the clients to update the CFs of the given buildings.
&nbsp;     *
&nbsp;     * @param buildings - a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s that need to
&nbsp;     *                  be updated.
&nbsp;     * @return a &lt;code&gt;Packet&lt;/code&gt; for the command.
&nbsp;     */
&nbsp;    private Packet createUpdateBuildingPacket(Vector&lt;Building&gt; buildings) {
<b class="nc">&nbsp;        return new Packet(Packet.COMMAND_BLDG_UPDATE, buildings);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply this phase&#39;s damage to all buildings. Buildings may collapse due to
&nbsp;     * damage.
&nbsp;     */
&nbsp;    private void applyBuildingDamage() {
&nbsp;
&nbsp;        // Walk through the buildings in the game.
&nbsp;        // Build the collapse and update vectors as you go.
&nbsp;        // N.B. never, NEVER, collapse buildings while you are walking through
&nbsp;        // the Enumeration from megamek.common.Board#getBuildings.
<b class="nc">&nbsp;        Map&lt;Building, Vector&lt;Coords&gt;&gt; collapse = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Map&lt;Building, Vector&lt;Coords&gt;&gt; update = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Enumeration&lt;Building&gt; buildings = game.getBoard().getBuildings();</b>
<b class="nc">&nbsp;        while (buildings.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Building bldg = buildings.nextElement();</b>
<b class="nc">&nbsp;            Vector&lt;Coords&gt; collapseCoords = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            Vector&lt;Coords&gt; updateCoords = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            Enumeration&lt;Coords&gt; buildingCoords = bldg.getCoords();</b>
<b class="nc">&nbsp;            while (buildingCoords.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Coords coords = buildingCoords.nextElement();</b>
&nbsp;                // If the CF is zero, the building should fall.
<b class="nc">&nbsp;                if (bldg.getCurrentCF(coords) == 0) {</b>
<b class="nc">&nbsp;                    collapseCoords.addElement(coords);</b>
&nbsp;                }
&nbsp;                // If the building took damage this round, update it.
<b class="nc">&nbsp;                else if (bldg.getPhaseCF(coords) != bldg.getCurrentCF(coords)) {</b>
<b class="nc">&nbsp;                    bldg.setPhaseCF(bldg.getCurrentCF(coords), coords);</b>
<b class="nc">&nbsp;                    updateCoords.addElement(coords);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            collapse.put(bldg, collapseCoords);</b>
<b class="nc">&nbsp;            update.put(bldg, updateCoords);</b>
<b class="nc">&nbsp;        } // Handle the next building</b>
&nbsp;
&nbsp;        // If we have any buildings to collapse, collapse them now.
<b class="nc">&nbsp;        if (!collapse.isEmpty()) {</b>
&nbsp;
&nbsp;            // Get the position map of all entities in the game.
<b class="nc">&nbsp;            Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap = game</b>
<b class="nc">&nbsp;                    .getPositionMap();</b>
&nbsp;
&nbsp;            // Walk through the hexes that have collapsed.
<b class="nc">&nbsp;            for (Building bldg : collapse.keySet()) {</b>
<b class="nc">&nbsp;                Vector&lt;Coords&gt; coordsVector = collapse.get(bldg);</b>
<b class="nc">&nbsp;                for (Coords coords : coordsVector) {</b>
<b class="nc">&nbsp;                    Report r = new Report(6460, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(bldg.getName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    collapseBuilding(bldg, positionMap, coords, vPhaseReport);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for buildings which should collapse due to being overloaded now
&nbsp;        // CF is reduced
<b class="nc">&nbsp;        if (!update.isEmpty()) {</b>
<b class="nc">&nbsp;            Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap = game.getPositionMap();</b>
<b class="nc">&nbsp;            for (Building bldg : update.keySet()) {</b>
<b class="nc">&nbsp;                Vector&lt;Coords&gt; updateCoords = update.get(bldg);</b>
<b class="nc">&nbsp;                Vector&lt;Coords&gt; coordsToRemove = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Coords coords : updateCoords) {</b>
<b class="nc">&nbsp;                    if (checkForCollapse(bldg, positionMap, coords, false,</b>
&nbsp;                                         vPhaseReport)) {
<b class="nc">&nbsp;                        coordsToRemove.add(coords);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                updateCoords.removeAll(coordsToRemove);</b>
<b class="nc">&nbsp;                update.put(bldg, updateCoords);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we have any buildings to update, send the message.
<b class="nc">&nbsp;        if (!update.isEmpty()) {</b>
<b class="nc">&nbsp;            sendChangedBuildings(new Vector&lt;&gt;(update.keySet()));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply the given amount of damage to the building. Please note, this
&nbsp;     * method does &lt;b&gt;not&lt;/b&gt; apply any damage to units inside the building,
&nbsp;     * update the clients, or check for the building&#39;s collapse.
&nbsp;     * &lt;p/&gt;
&nbsp;     * A default message will be used to describe why the building took the
&nbsp;     * damage.
&nbsp;     *
&nbsp;     * @param bldg   - the &lt;code&gt;Building&lt;/code&gt; that has been damaged. This value
&nbsp;     *               should not be &lt;code&gt;null&lt;/code&gt;, but no exception will occur.
&nbsp;     * @param damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.
&nbsp;     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; of the building hex to be damaged
&nbsp;     * @return a &lt;code&gt;Report&lt;/code&gt; to be shown to the players.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageBuilding(Building bldg, int damage,
&nbsp;                                         Coords coords) {
<b class="nc">&nbsp;        final String defaultWhy = &quot; absorbs &quot;;</b>
<b class="nc">&nbsp;        return damageBuilding(bldg, damage, defaultWhy, coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply the given amount of damage to the building. Please note, this
&nbsp;     * method does &lt;b&gt;not&lt;/b&gt; apply any damage to units inside the building,
&nbsp;     * update the clients, or check for the building&#39;s collapse.
&nbsp;     *
&nbsp;     * @param bldg   - the &lt;code&gt;Building&lt;/code&gt; that has been damaged. This value
&nbsp;     *               should not be &lt;code&gt;null&lt;/code&gt;, but no exception will occur.
&nbsp;     * @param damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.
&nbsp;     * @param why    - the &lt;code&gt;String&lt;/code&gt; message that describes why the
&nbsp;     *               building took the damage.
&nbsp;     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; of the building hex to be damaged
&nbsp;     * @return a &lt;code&gt;Report&lt;/code&gt; to be shown to the players.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; damageBuilding(Building bldg, int damage, String why, Coords coords) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        Report r = new Report(1210, Report.PUBLIC);</b>
&nbsp;
&nbsp;        // Do nothing if no building or no damage was passed.
<b class="nc">&nbsp;        if ((bldg != null) &amp;&amp; (damage &gt; 0)) {</b>
<b class="nc">&nbsp;            r.messageId = 3435;</b>
<b class="nc">&nbsp;            r.add(bldg.toString());</b>
<b class="nc">&nbsp;            r.add(why);</b>
<b class="nc">&nbsp;            r.add(damage);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            int curArmor = bldg.getArmor(coords);</b>
<b class="nc">&nbsp;            if (curArmor &gt;= damage) {</b>
<b class="nc">&nbsp;                curArmor -= Math.min(curArmor, damage);</b>
<b class="nc">&nbsp;                bldg.setArmor(curArmor, coords);</b>
<b class="nc">&nbsp;                r = new Report(3436, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.indent(0);</b>
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                r.add(curArmor);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.add(damage);</b>
<b class="nc">&nbsp;                if (curArmor &gt; 0) {</b>
<b class="nc">&nbsp;                    bldg.setArmor(0, coords);</b>
<b class="nc">&nbsp;                    damage = damage - curArmor;</b>
<b class="nc">&nbsp;                    r = new Report(3436, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.indent(0);</b>
<b class="nc">&nbsp;                    r.add(curArmor);</b>
<b class="nc">&nbsp;                    r.add(0);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                damage = (int) Math.floor(bldg.getDamageToScale() * damage);</b>
<b class="nc">&nbsp;                if (bldg.getDamageToScale() &lt; 1.0) {</b>
<b class="nc">&nbsp;                    r = new Report(3437, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.indent(0);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bldg.getDamageToScale() &gt; 1.0) {</b>
<b class="nc">&nbsp;                    r = new Report(3438, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.indent(0);</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
&nbsp;                }
<b class="nc">&nbsp;                int curCF = bldg.getCurrentCF(coords);</b>
<b class="nc">&nbsp;                final int startingCF = curCF;</b>
<b class="nc">&nbsp;                curCF -= Math.min(curCF, damage);</b>
<b class="nc">&nbsp;                bldg.setCurrentCF(curCF, coords);</b>
&nbsp;
<b class="nc">&nbsp;                r = new Report(6436, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                String fontColorOpen = curCF &lt;= 0 ? &quot;&lt;font color=&#39;C00000&#39;&gt;&quot; : &quot;&quot;;</b>
<b class="nc">&nbsp;                String fontColorClose = curCF &lt;= 0 ? &quot;&lt;/font&gt;&quot; : &quot;&quot;;</b>
<b class="nc">&nbsp;                r.add(String.format(&quot;%s%s%s&quot;, fontColorOpen, curCF, fontColorClose));</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;
<b class="nc">&nbsp;                final int damageThresh = (int) Math.ceil(bldg.getPhaseCF(coords) / 10.0);</b>
&nbsp;
&nbsp;                // If the CF is zero, the building should fall.
<b class="nc">&nbsp;                if ((curCF == 0) &amp;&amp; (startingCF != 0)) {</b>
<b class="nc">&nbsp;                    if (bldg instanceof FuelTank) {</b>
&nbsp;                        // If this is a fuel tank, we&#39;ll give it its own
&nbsp;                        // message.
<b class="nc">&nbsp;                        r = new Report(3441);</b>
<b class="nc">&nbsp;                        r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                        r.indent(0);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
&nbsp;                        // ...But we ALSO need to blow up everything nearby.
&nbsp;                        // Bwahahahahaha...
<b class="nc">&nbsp;                        r = new Report(3560);</b>
<b class="nc">&nbsp;                        r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                        r.newlines = 1;</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                        Vector&lt;Report&gt; vRep = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                        doExplosion(((FuelTank) bldg).getMagnitude(), 10,</b>
<b class="nc">&nbsp;                                false, bldg.getCoords().nextElement(), true,</b>
&nbsp;                                vRep, null, -1);
<b class="nc">&nbsp;                        Report.indentAll(vRep, 2);</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(vRep);</b>
<b class="nc">&nbsp;                        return vPhaseReport;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (bldg.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                        r = new Report(3442);</b>
<b class="nc">&nbsp;                        r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                        r.indent(0);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(3440);</b>
<b class="nc">&nbsp;                        r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                        r.indent(0);</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((curCF &lt; startingCF) &amp;&amp; (damage &gt; damageThresh)) {</b>
&nbsp;                    // need to check for crits
&nbsp;                    // don&#39;t bother unless we have some gun emplacements
<b class="nc">&nbsp;                    Vector&lt;GunEmplacement&gt; guns = game</b>
<b class="nc">&nbsp;                            .getGunEmplacements(coords);</b>
<b class="nc">&nbsp;                    if (guns.size() &gt; 0) {</b>
<b class="nc">&nbsp;                        vPhaseReport.addAll(criticalGunEmplacement(guns, bldg,</b>
&nbsp;                                coords));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Report.indentAll(vPhaseReport, 2);</b>
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; criticalGunEmplacement(Vector&lt;GunEmplacement&gt; guns, Building bldg,
&nbsp;                                                  Coords coords) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        r = new Report(3800);</b>
<b class="nc">&nbsp;        r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;        r.indent(0);</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
&nbsp;
<b class="nc">&nbsp;        int critRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        if (critRoll &lt; 6) {</b>
<b class="nc">&nbsp;            r = new Report(3805);</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;        } else if (critRoll == 6) {</b>
&nbsp;            // weapon malfunction
&nbsp;            // lets just randomly determine which weapon gets hit
<b class="nc">&nbsp;            Vector&lt;Mounted&gt; wpns = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                for (Mounted wpn : gun.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if (!wpn.isHit() &amp;&amp; !wpn.isJammed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !wpn.jammedThisPhase()) {</b>
<b class="nc">&nbsp;                        wpns.add(wpn);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (wpns.size() &gt; 0) {</b>
<b class="nc">&nbsp;                Mounted weapon = wpns.elementAt(Compute.randomInt(wpns.size()));</b>
<b class="nc">&nbsp;                weapon.setJammed(true);</b>
<b class="nc">&nbsp;                ((GunEmplacement) weapon.getEntity()).addJammedWeapon(weapon);</b>
<b class="nc">&nbsp;                r = new Report(3845);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                r.add(weapon.getDesc());</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                r = new Report(3846);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;        } else if (critRoll == 7) {</b>
&nbsp;            // gunners stunned
<b class="nc">&nbsp;            for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                gun.stunCrew();</b>
<b class="nc">&nbsp;                r = new Report(3810);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (critRoll == 8) {</b>
&nbsp;            // weapon destroyed
&nbsp;            // lets just randomly determine which weapon gets hit
<b class="nc">&nbsp;            Vector&lt;Mounted&gt; wpns = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                for (Mounted wpn : gun.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if (!wpn.isHit()) {</b>
<b class="nc">&nbsp;                        wpns.add(wpn);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (wpns.size() &gt; 0) {</b>
<b class="nc">&nbsp;                Mounted weapon = wpns.elementAt(Compute.randomInt(wpns.size()));</b>
<b class="nc">&nbsp;                weapon.setHit(true);</b>
<b class="nc">&nbsp;                r = new Report(3840);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                r.add(weapon.getDesc());</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                r = new Report(3841);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;        } else if (critRoll == 9) {</b>
&nbsp;            // gunners killed
<b class="nc">&nbsp;            r = new Report(3815);</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                gun.getCrew().setDoomed(true);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (critRoll == 10) {</b>
<b class="nc">&nbsp;            if (Compute.d6() &gt; 3) {</b>
&nbsp;                // turret lock
<b class="nc">&nbsp;                r = new Report(3820);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;                for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                    gun.lockTurret(gun.getLocTurret());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
&nbsp;                // turret jam
<b class="nc">&nbsp;                r = new Report(3825);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
<b class="nc">&nbsp;                for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                    if (gun.isTurretEverJammed(gun.getLocTurret())) {</b>
<b class="nc">&nbsp;                        gun.lockTurret(gun.getLocTurret());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        gun.jamTurret(gun.getLocTurret());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (critRoll == 11) {</b>
<b class="nc">&nbsp;            r = new Report(3830);</b>
<b class="nc">&nbsp;            r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;            r.indent(1);</b>
<b class="nc">&nbsp;            r.add(bldg.getName());</b>
<b class="nc">&nbsp;            int boom = 0;</b>
<b class="nc">&nbsp;            for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                for (Mounted ammo : gun.getAmmo()) {</b>
<b class="nc">&nbsp;                    ammo.setHit(true);</b>
<b class="nc">&nbsp;                    if (ammo.getType().isExplosive(ammo)) {</b>
<b class="nc">&nbsp;                        boom += ammo.getHittableShotsLeft()</b>
<b class="nc">&nbsp;                                * ((AmmoType) ammo.getType())</b>
<b class="nc">&nbsp;                                .getDamagePerShot()</b>
<b class="nc">&nbsp;                                * ((AmmoType) ammo.getType()).getRackSize();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            boom = (int) Math.floor(bldg.getDamageToScale() * boom);</b>
&nbsp;            
<b class="nc">&nbsp;            if (boom == 0) {</b>
<b class="nc">&nbsp;                Report rNoAmmo = new Report(3831);</b>
<b class="nc">&nbsp;                rNoAmmo.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                rNoAmmo.indent(1);</b>
<b class="nc">&nbsp;                vDesc.add(rNoAmmo);</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            r.add(boom);</b>
<b class="nc">&nbsp;            int curCF = bldg.getCurrentCF(coords);</b>
<b class="nc">&nbsp;            curCF -= Math.min(curCF, boom);</b>
<b class="nc">&nbsp;            bldg.setCurrentCF(curCF, coords);</b>
<b class="nc">&nbsp;            r.add(bldg.getCurrentCF(coords));</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;            // If the CF is zero, the building should fall.
<b class="nc">&nbsp;            if ((curCF == 0) &amp;&amp; (bldg.getPhaseCF(coords) != 0)) {</b>
&nbsp;                
&nbsp;                // when a building collapses due to an ammo explosion, we can consider
&nbsp;                // that turret annihilated for the purposes of salvage.
<b class="nc">&nbsp;                for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                    vDesc.addAll(destroyEntity(gun, &quot;ammo explosion&quot;, false, false));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                
<b class="nc">&nbsp;                if (bldg instanceof FuelTank) {</b>
&nbsp;                    // If this is a fuel tank, we&#39;ll give it its own
&nbsp;                    // message.
<b class="nc">&nbsp;                    r = new Report(3441);</b>
<b class="nc">&nbsp;                    r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                    r.indent(0);</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
&nbsp;                    // ...But we ALSO need to blow up everything nearby.
&nbsp;                    // Bwahahahahaha...
<b class="nc">&nbsp;                    r = new Report(3560);</b>
<b class="nc">&nbsp;                    r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                    r.newlines = 1;</b>
<b class="nc">&nbsp;                    vDesc.add(r);</b>
<b class="nc">&nbsp;                    Vector&lt;Report&gt; vRep = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;                    doExplosion(((FuelTank) bldg).getMagnitude(), 10, false,</b>
<b class="nc">&nbsp;                                bldg.getCoords().nextElement(), true, vRep, null,</b>
&nbsp;                                -1);
<b class="nc">&nbsp;                    Report.indentAll(vRep, 2);</b>
<b class="nc">&nbsp;                    vDesc.addAll(vRep);</b>
<b class="nc">&nbsp;                    return vPhaseReport;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bldg.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                    r = new Report(3442);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(3440);</b>
&nbsp;                }
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(0);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (critRoll == 12) {</b>
&nbsp;            // non-weapon equipment is hit
<b class="nc">&nbsp;            Vector&lt;Mounted&gt; equipmentList = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (GunEmplacement gun : guns) {</b>
<b class="nc">&nbsp;                for (Mounted equipment : gun.getMisc()) {</b>
<b class="nc">&nbsp;                    if (!equipment.isHit()) {</b>
<b class="nc">&nbsp;                        equipmentList.add(equipment);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            
<b class="nc">&nbsp;            if (equipmentList.size() &gt; 0) {</b>
<b class="nc">&nbsp;                Mounted equipment = equipmentList.elementAt(Compute.randomInt(equipmentList.size()));</b>
<b class="nc">&nbsp;                equipment.setHit(true);</b>
<b class="nc">&nbsp;                r = new Report(3840);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                r.add(equipment.getDesc());</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                r = new Report(3835);</b>
<b class="nc">&nbsp;                r.type = Report.PUBLIC;</b>
<b class="nc">&nbsp;                r.indent(1);</b>
&nbsp;            }
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void sendChangedBuildings(Vector&lt;Building&gt; buildings) {
<b class="nc">&nbsp;        send(createUpdateBuildingPacket(buildings));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receives an packet to unload entity is stranded on immobile transports,
&nbsp;     * and queue all valid requests for execution. If all players that have
&nbsp;     * stranded entities have answered, executes the pending requests and end
&nbsp;     * the current turn.
&nbsp;     */
&nbsp;    private void receiveUnloadStranded(Packet packet, int connId) {
&nbsp;        GameTurn.UnloadStrandedTurn turn;
<b class="nc">&nbsp;        final IPlayer player = game.getPlayer(connId);</b>
<b class="nc">&nbsp;        int[] entityIds = (int[]) packet.getObject(0);</b>
&nbsp;        Vector&lt;IPlayer&gt; declared;
&nbsp;        IPlayer other;
&nbsp;        Enumeration&lt;EntityAction&gt; pending;
&nbsp;        UnloadStrandedAction action;
&nbsp;        Entity entity;
&nbsp;
&nbsp;        // Is this the right phase?
<b class="nc">&nbsp;        if (game.getPhase() != IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got unload stranded packet in wrong phase&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Are we in an &quot;unload stranded entities&quot; turn?
<b class="nc">&nbsp;        if (game.getTurn() instanceof GameTurn.UnloadStrandedTurn) {</b>
<b class="nc">&nbsp;            turn = (GameTurn.UnloadStrandedTurn) game.getTurn();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got unload stranded packet out of sequence&quot;);</b>
<b class="nc">&nbsp;            sendServerChat(player.getName() + &quot; should not be sending &#39;unload stranded entity&#39; packets at this time.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Can this player act right now?
<b class="nc">&nbsp;        if (!turn.isValid(connId, game)) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Server got unload stranded packet from invalid player&quot;);</b>
<b class="nc">&nbsp;            sendServerChat(player.getName() + &quot; should not be sending &#39;unload stranded entity&#39; packets.&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Did the player already send an &#39;unload&#39; request?
&nbsp;        // N.B. we&#39;re also building the list of players who
&nbsp;        // have declared their &quot;unload stranded&quot; actions.
<b class="nc">&nbsp;        declared = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        pending = game.getActions();</b>
<b class="nc">&nbsp;        while (pending.hasMoreElements()) {</b>
<b class="nc">&nbsp;            action = (UnloadStrandedAction) pending.nextElement();</b>
<b class="nc">&nbsp;            if (action.getPlayerId() == connId) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Server got multiple unload stranded packets from player&quot;);</b>
<b class="nc">&nbsp;                sendServerChat(player.getName() + &quot; should not send multiple &#39;unload stranded entity&#39; packets.&quot;);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // This player is not from the current connection.
&nbsp;            // Record this player to determine if this turn is done.
<b class="nc">&nbsp;            other = game.getPlayer(action.getPlayerId());</b>
<b class="nc">&nbsp;            if (!declared.contains(other)) {</b>
<b class="nc">&nbsp;                declared.addElement(other);</b>
&nbsp;            }
&nbsp;        } // Handle the next &quot;unload stranded&quot; action.
&nbsp;
&nbsp;        // Make sure the player selected at least *one* valid entity ID.
<b class="nc">&nbsp;        boolean foundValid = false;</b>
<b class="nc">&nbsp;        for (int index = 0; (null != entityIds) &amp;&amp; (index &lt; entityIds.length); index++) {</b>
<b class="nc">&nbsp;            entity = game.getEntity(entityIds[index]);</b>
<b class="nc">&nbsp;            if (!game.getTurn().isValid(connId, entity, game)) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Server got unload stranded packet for invalid entity&quot;);</b>
<b class="nc">&nbsp;                StringBuilder message = new StringBuilder();</b>
<b class="nc">&nbsp;                message.append(player.getName()).append(&quot; can not unload stranded entity &quot;);</b>
<b class="nc">&nbsp;                if (null == entity) {</b>
<b class="nc">&nbsp;                    message.append(&#39;#&#39;).append(entityIds[index]);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    message.append(entity.getDisplayName());</b>
&nbsp;                }
<b class="nc">&nbsp;                message.append(&quot; at this time.&quot;);</b>
<b class="nc">&nbsp;                sendServerChat(message.toString());</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                foundValid = true;</b>
<b class="nc">&nbsp;                game.addAction(new UnloadStrandedAction(connId, entityIds[index]));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Did the player choose not to unload any valid stranded entity?
<b class="nc">&nbsp;        if (!foundValid) {</b>
<b class="nc">&nbsp;            game.addAction(new UnloadStrandedAction(connId, Entity.NONE));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Either way, the connection&#39;s player has now declared.
<b class="nc">&nbsp;        declared.addElement(player);</b>
&nbsp;
&nbsp;        // Are all players who are unloading entities done? Walk
&nbsp;        // through the turn&#39;s stranded entities, and look to see
&nbsp;        // if their player has finished their turn.
<b class="nc">&nbsp;        entityIds = turn.getEntityIds();</b>
<b class="nc">&nbsp;        for (int entityId : entityIds) {</b>
<b class="nc">&nbsp;            entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;            other = entity.getOwner();</b>
<b class="nc">&nbsp;            if (!declared.contains(other)) {</b>
&nbsp;                // At least one player still needs to declare.
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // All players have declared whether they&#39;re unloading stranded units.
&nbsp;        // Walk the list of pending actions and unload the entities.
<b class="nc">&nbsp;        pending = game.getActions();</b>
<b class="nc">&nbsp;        while (pending.hasMoreElements()) {</b>
<b class="nc">&nbsp;            action = (UnloadStrandedAction) pending.nextElement();</b>
&nbsp;
&nbsp;            // Some players don&#39;t want to unload any stranded units.
<b class="nc">&nbsp;            if (Entity.NONE != action.getEntityId()) {</b>
<b class="nc">&nbsp;                entity = game.getEntity(action.getEntityId());</b>
<b class="nc">&nbsp;                if (null == entity) {</b>
&nbsp;                    // After all this, we couldn&#39;t find the entity!!!
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Server could not find stranded entity #&quot;</b>
<b class="nc">&nbsp;                            + action.getEntityId() + &quot; to unload!!!&quot;);</b>
&nbsp;                } else {
&nbsp;                    // Unload the entity. Get the unit&#39;s transporter.
<b class="nc">&nbsp;                    Entity transporter = game</b>
<b class="nc">&nbsp;                            .getEntity(entity.getTransportId());</b>
<b class="nc">&nbsp;                    unloadUnit(transporter, entity, transporter.getPosition(),</b>
<b class="nc">&nbsp;                               transporter.getFacing(), transporter.getElevation());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;        } // Handle the next pending unload action
&nbsp;
&nbsp;        // Clear the list of pending units and move to the next turn.
<b class="nc">&nbsp;        game.resetActions();</b>
<b class="nc">&nbsp;        changeToNextTurn(connId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * For all current artillery attacks in the air from this entity with this
&nbsp;     * weapon, clear the list of spotters. Needed because firing another round
&nbsp;     * before first lands voids spotting.
&nbsp;     *
&nbsp;     * @param entityID the &lt;code&gt;int&lt;/code&gt; id of the entity
&nbsp;     * @param weaponID the &lt;code&gt;int&lt;/code&gt; id of the weapon
&nbsp;     */
&nbsp;    private void clearArtillerySpotters(int entityID, int weaponID) {
<b class="nc">&nbsp;        for (Enumeration&lt;AttackHandler&gt; i = game.getAttacks(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            WeaponHandler wh = (WeaponHandler) i.nextElement();</b>
<b class="nc">&nbsp;            if ((wh.waa instanceof ArtilleryAttackAction)</b>
<b class="nc">&nbsp;                &amp;&amp; (wh.waa.getEntityId() == entityID)</b>
<b class="nc">&nbsp;                &amp;&amp; (wh.waa.getWeaponId() == weaponID)) {</b>
<b class="nc">&nbsp;                ArtilleryAttackAction aaa = (ArtilleryAttackAction) wh.waa;</b>
<b class="nc">&nbsp;                aaa.setSpotterIds(null);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Credits a Kill for an entity, if the target got killed.
&nbsp;     *
&nbsp;     * @param target   The &lt;code&gt;Entity&lt;/code&gt; that got killed.
&nbsp;     * @param attacker The &lt;code&gt;Entity&lt;/code&gt; that did the killing.
&nbsp;     */
&nbsp;    public void creditKill(Entity target, Entity attacker) {
&nbsp;        // Kills should be credited for each individual fighter, instead of the
&nbsp;        // squadron
<b class="nc">&nbsp;        if (target instanceof FighterSquadron) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // If a squadron scores a kill, assign it randomly to one of the member fighters
<b class="nc">&nbsp;        if (attacker instanceof FighterSquadron) {</b>
<b class="nc">&nbsp;            Entity killer = attacker.getLoadedUnits().get(Compute.randomInt(attacker.getLoadedUnits().size()));</b>
<b class="nc">&nbsp;            if (killer != null) {</b>
<b class="nc">&nbsp;                attacker = killer;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((target.isDoomed() || target.getCrew().isDoomed())</b>
<b class="nc">&nbsp;            &amp;&amp; !target.getGaveKillCredit() &amp;&amp; (attacker != null)) {</b>
<b class="nc">&nbsp;            attacker.addKill(target);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * pre-treats a physical attack
&nbsp;     *
&nbsp;     * @param aaa The &lt;code&gt;AbstractAttackAction&lt;/code&gt; of the physical attack
&nbsp;     *            to pre-treat
&nbsp;     * @return The &lt;code&gt;PhysicalResult&lt;/code&gt; of that action, including
&nbsp;     * possible damage.
&nbsp;     */
&nbsp;    private PhysicalResult preTreatPhysicalAttack(AbstractAttackAction aaa) {
<b class="nc">&nbsp;        final Entity ae = game.getEntity(aaa.getEntityId());</b>
<b class="nc">&nbsp;        int damage = 0;</b>
<b class="nc">&nbsp;        PhysicalResult pr = new PhysicalResult();</b>
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
<b class="nc">&nbsp;        pr.roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        pr.aaa = aaa;</b>
<b class="nc">&nbsp;        if (aaa instanceof BrushOffAttackAction) {</b>
<b class="nc">&nbsp;            BrushOffAttackAction baa = (BrushOffAttackAction) aaa;</b>
<b class="nc">&nbsp;            int arm = baa.getArm();</b>
<b class="nc">&nbsp;            baa.setArm(BrushOffAttackAction.LEFT);</b>
<b class="nc">&nbsp;            toHit = BrushOffAttackAction.toHit(game, aaa.getEntityId(),</b>
<b class="nc">&nbsp;                    aaa.getTarget(game), BrushOffAttackAction.LEFT);</b>
<b class="nc">&nbsp;            baa.setArm(BrushOffAttackAction.RIGHT);</b>
<b class="nc">&nbsp;            pr.toHitRight = BrushOffAttackAction.toHit(game, aaa.getEntityId(),</b>
<b class="nc">&nbsp;                    aaa.getTarget(game), BrushOffAttackAction.RIGHT);</b>
<b class="nc">&nbsp;            damage = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.LEFT);</b>
<b class="nc">&nbsp;            pr.damageRight = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.RIGHT);</b>
<b class="nc">&nbsp;            baa.setArm(arm);</b>
<b class="nc">&nbsp;            pr.rollRight = Compute.d6(2);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ChargeAttackAction) {</b>
<b class="nc">&nbsp;            ChargeAttackAction caa = (ChargeAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = caa.toHit(game);</b>
<b class="nc">&nbsp;            if (caa.getTarget(game) instanceof Entity) {</b>
<b class="nc">&nbsp;                Entity target = (Entity) caa.getTarget(game);</b>
<b class="nc">&nbsp;                damage = ChargeAttackAction.getDamageFor(ae, target,</b>
<b class="nc">&nbsp;                        game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CHARGE_DAMAGE),</b>
<b class="nc">&nbsp;                        toHit.getMoS());</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                damage = ChargeAttackAction.getDamageFor(ae);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (aaa instanceof AirmechRamAttackAction) {</b>
<b class="nc">&nbsp;            AirmechRamAttackAction raa = (AirmechRamAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = raa.toHit(game);</b>
<b class="nc">&nbsp;            damage = AirmechRamAttackAction.getDamageFor(ae);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ClubAttackAction) {</b>
<b class="nc">&nbsp;            ClubAttackAction caa = (ClubAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = caa.toHit(game);</b>
<b class="nc">&nbsp;            damage = ClubAttackAction.getDamageFor(ae, caa.getClub(),</b>
<b class="nc">&nbsp;                    (caa.getTarget(game) instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(caa.getTarget(game) instanceof BattleArmor),</b>
<b class="nc">&nbsp;                    caa.isZweihandering());</b>
<b class="nc">&nbsp;            if (caa.getTargetType() == Targetable.TYPE_BUILDING) {</b>
<b class="nc">&nbsp;                EquipmentType clubType = caa.getClub().getType();</b>
<b class="nc">&nbsp;                if (clubType.hasSubType(MiscType.S_BACKHOE)</b>
<b class="nc">&nbsp;                        || clubType.hasSubType(MiscType.S_CHAINSAW)</b>
<b class="nc">&nbsp;                        || clubType.hasSubType(MiscType.S_MINING_DRILL)</b>
<b class="nc">&nbsp;                        || clubType.hasSubType(MiscType.S_PILE_DRIVER)) {</b>
<b class="nc">&nbsp;                    damage += Compute.d6(1);</b>
<b class="nc">&nbsp;                } else if (clubType.hasSubType(MiscType.S_DUAL_SAW)) {</b>
<b class="nc">&nbsp;                    damage += Compute.d6(2);</b>
<b class="nc">&nbsp;                } else if (clubType.hasSubType(MiscType.S_ROCK_CUTTER)) {</b>
<b class="nc">&nbsp;                    damage += Compute.d6(3);</b>
&nbsp;                }
<b class="nc">&nbsp;                else if (clubType.hasSubType(MiscType.S_WRECKING_BALL)) {</b>
<b class="nc">&nbsp;                    damage += Compute.d6(4);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (aaa instanceof DfaAttackAction) {</b>
<b class="nc">&nbsp;            DfaAttackAction daa = (DfaAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = daa.toHit(game);</b>
<b class="nc">&nbsp;            damage = DfaAttackAction.getDamageFor(ae,</b>
<b class="nc">&nbsp;                    (daa.getTarget(game) instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(daa.getTarget(game) instanceof BattleArmor));</b>
<b class="nc">&nbsp;        } else if (aaa instanceof KickAttackAction) {</b>
<b class="nc">&nbsp;            KickAttackAction kaa = (KickAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = kaa.toHit(game);</b>
<b class="nc">&nbsp;            damage = KickAttackAction.getDamageFor(ae, kaa.getLeg(),</b>
<b class="nc">&nbsp;                    (kaa.getTarget(game) instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(kaa.getTarget(game) instanceof BattleArmor));</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ProtomechPhysicalAttackAction) {</b>
<b class="nc">&nbsp;            ProtomechPhysicalAttackAction paa = (ProtomechPhysicalAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = paa.toHit(game);</b>
<b class="nc">&nbsp;            damage = ProtomechPhysicalAttackAction.getDamageFor(ae, paa.getTarget(game));</b>
<b class="nc">&nbsp;        } else if (aaa instanceof PunchAttackAction) {</b>
<b class="nc">&nbsp;            PunchAttackAction paa = (PunchAttackAction) aaa;</b>
<b class="nc">&nbsp;            int arm = paa.getArm();</b>
&nbsp;            int damageRight;
<b class="nc">&nbsp;            paa.setArm(PunchAttackAction.LEFT);</b>
<b class="nc">&nbsp;            toHit = paa.toHit(game);</b>
<b class="nc">&nbsp;            paa.setArm(PunchAttackAction.RIGHT);</b>
<b class="nc">&nbsp;            ToHitData toHitRight = paa.toHit(game);</b>
<b class="nc">&nbsp;            damage = PunchAttackAction.getDamageFor(ae, PunchAttackAction.LEFT,</b>
<b class="nc">&nbsp;                    (paa.getTarget(game) instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(paa.getTarget(game) instanceof BattleArmor),</b>
<b class="nc">&nbsp;                    paa.isZweihandering());</b>
<b class="nc">&nbsp;            damageRight = PunchAttackAction.getDamageFor(ae, PunchAttackAction.RIGHT,</b>
<b class="nc">&nbsp;                    (paa.getTarget(game) instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(paa.getTarget(game) instanceof BattleArmor),</b>
<b class="nc">&nbsp;                    paa.isZweihandering());</b>
<b class="nc">&nbsp;            paa.setArm(arm);</b>
&nbsp;            // If we&#39;re punching while prone (at a Tank,
&nbsp;            // duh), then we can only use one arm.
<b class="nc">&nbsp;            if (ae.isProne()) {</b>
<b class="nc">&nbsp;                double oddsLeft = Compute.oddsAbove(toHit.getValue(),</b>
<b class="nc">&nbsp;                        ae.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING));</b>
<b class="nc">&nbsp;                double oddsRight = Compute.oddsAbove(toHitRight.getValue(),</b>
<b class="nc">&nbsp;                        ae.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING));</b>
&nbsp;                // Use the best attack.
<b class="nc">&nbsp;                if ((oddsLeft * damage) &gt; (oddsRight * damageRight)) {</b>
<b class="nc">&nbsp;                    paa.setArm(PunchAttackAction.LEFT);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    paa.setArm(PunchAttackAction.RIGHT);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            pr.damageRight = damageRight;</b>
<b class="nc">&nbsp;            pr.toHitRight = toHitRight;</b>
<b class="nc">&nbsp;            pr.rollRight = Compute.d6(2);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof PushAttackAction) {</b>
<b class="nc">&nbsp;            PushAttackAction paa = (PushAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = paa.toHit(game);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof TripAttackAction) {</b>
<b class="nc">&nbsp;            TripAttackAction paa = (TripAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = paa.toHit(game);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof LayExplosivesAttackAction) {</b>
<b class="nc">&nbsp;            LayExplosivesAttackAction leaa = (LayExplosivesAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = leaa.toHit(game);</b>
<b class="nc">&nbsp;            damage = LayExplosivesAttackAction.getDamageFor(ae);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ThrashAttackAction) {</b>
<b class="nc">&nbsp;            ThrashAttackAction taa = (ThrashAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = taa.toHit(game);</b>
<b class="nc">&nbsp;            damage = ThrashAttackAction.getDamageFor(ae);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof JumpJetAttackAction) {</b>
<b class="nc">&nbsp;            JumpJetAttackAction jaa = (JumpJetAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = jaa.toHit(game);</b>
<b class="nc">&nbsp;            if (jaa.getLeg() == JumpJetAttackAction.BOTH) {</b>
<b class="nc">&nbsp;                damage = JumpJetAttackAction.getDamageFor(ae, JumpJetAttackAction.LEFT);</b>
<b class="nc">&nbsp;                pr.damageRight = JumpJetAttackAction.getDamageFor(ae, JumpJetAttackAction.LEFT);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                damage = JumpJetAttackAction.getDamageFor(ae, jaa.getLeg());</b>
<b class="nc">&nbsp;                pr.damageRight = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            ae.heatBuildup += (damage + pr.damageRight) / 3;</b>
<b class="nc">&nbsp;        } else if (aaa instanceof GrappleAttackAction) {</b>
<b class="nc">&nbsp;            GrappleAttackAction taa = (GrappleAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = taa.toHit(game);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof BreakGrappleAttackAction) {</b>
<b class="nc">&nbsp;            BreakGrappleAttackAction taa = (BreakGrappleAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = taa.toHit(game);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof RamAttackAction) {</b>
<b class="nc">&nbsp;            RamAttackAction raa = (RamAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = raa.toHit(game);</b>
<b class="nc">&nbsp;            damage = RamAttackAction.getDamageFor((IAero) ae, (Entity) aaa.getTarget(game));</b>
<b class="nc">&nbsp;        } else if (aaa instanceof TeleMissileAttackAction) {</b>
<b class="nc">&nbsp;            TeleMissileAttackAction taa = (TeleMissileAttackAction) aaa;</b>
<b class="nc">&nbsp;            assignTeleMissileAMS(taa);</b>
<b class="nc">&nbsp;            taa.calcCounterAV(game, taa.getTarget(game));</b>
<b class="nc">&nbsp;            toHit = taa.toHit(game);</b>
<b class="nc">&nbsp;            damage = TeleMissileAttackAction.getDamageFor(ae);</b>
<b class="nc">&nbsp;        } else if (aaa instanceof BAVibroClawAttackAction) {</b>
<b class="nc">&nbsp;            BAVibroClawAttackAction bvca = (BAVibroClawAttackAction) aaa;</b>
<b class="nc">&nbsp;            toHit = bvca.toHit(game);</b>
<b class="nc">&nbsp;            damage = BAVibroClawAttackAction.getDamageFor(ae);</b>
&nbsp;        }
<b class="nc">&nbsp;        pr.toHit = toHit;</b>
<b class="nc">&nbsp;        pr.damage = damage;</b>
<b class="nc">&nbsp;        return pr;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolve a Physical Attack
&nbsp;     *
&nbsp;     * @param pr  The &lt;code&gt;PhysicalResult&lt;/code&gt; of the physical attack
&nbsp;     * @param cen The &lt;code&gt;int&lt;/code&gt; Entity Id of the entity whose physical
&nbsp;     *            attack was last resolved
&nbsp;     */
&nbsp;    private void resolvePhysicalAttack(PhysicalResult pr, int cen) {
<b class="nc">&nbsp;        AbstractAttackAction aaa = pr.aaa;</b>
<b class="nc">&nbsp;        if (aaa instanceof PunchAttackAction) {</b>
<b class="nc">&nbsp;            PunchAttackAction paa = (PunchAttackAction) aaa;</b>
<b class="nc">&nbsp;            if (paa.getArm() == PunchAttackAction.BOTH) {</b>
<b class="nc">&nbsp;                paa.setArm(PunchAttackAction.LEFT);</b>
<b class="nc">&nbsp;                pr.aaa = paa;</b>
<b class="nc">&nbsp;                resolvePunchAttack(pr, cen);</b>
<b class="nc">&nbsp;                cen = paa.getEntityId();</b>
<b class="nc">&nbsp;                paa.setArm(PunchAttackAction.RIGHT);</b>
<b class="nc">&nbsp;                pr.aaa = paa;</b>
<b class="nc">&nbsp;                resolvePunchAttack(pr, cen);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                resolvePunchAttack(pr, cen);</b>
<b class="nc">&nbsp;                cen = paa.getEntityId();</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (aaa instanceof KickAttackAction) {</b>
<b class="nc">&nbsp;            resolveKickAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof BrushOffAttackAction) {</b>
<b class="nc">&nbsp;            BrushOffAttackAction baa = (BrushOffAttackAction) aaa;</b>
<b class="nc">&nbsp;            if (baa.getArm() == BrushOffAttackAction.BOTH) {</b>
<b class="nc">&nbsp;                baa.setArm(BrushOffAttackAction.LEFT);</b>
<b class="nc">&nbsp;                pr.aaa = baa;</b>
<b class="nc">&nbsp;                resolveBrushOffAttack(pr, cen);</b>
<b class="nc">&nbsp;                cen = baa.getEntityId();</b>
<b class="nc">&nbsp;                baa.setArm(BrushOffAttackAction.RIGHT);</b>
<b class="nc">&nbsp;                pr.aaa = baa;</b>
<b class="nc">&nbsp;                resolveBrushOffAttack(pr, cen);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                resolveBrushOffAttack(pr, cen);</b>
<b class="nc">&nbsp;                cen = baa.getEntityId();</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (aaa instanceof ThrashAttackAction) {</b>
<b class="nc">&nbsp;            resolveThrashAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ProtomechPhysicalAttackAction) {</b>
<b class="nc">&nbsp;            resolveProtoAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ClubAttackAction) {</b>
<b class="nc">&nbsp;            resolveClubAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof PushAttackAction) {</b>
<b class="nc">&nbsp;            resolvePushAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof ChargeAttackAction) {</b>
<b class="nc">&nbsp;            resolveChargeAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof AirmechRamAttackAction) {</b>
<b class="nc">&nbsp;            resolveAirmechRamAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof DfaAttackAction) {</b>
<b class="nc">&nbsp;            resolveDfaAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof LayExplosivesAttackAction) {</b>
<b class="nc">&nbsp;            resolveLayExplosivesAttack(pr);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof TripAttackAction) {</b>
<b class="nc">&nbsp;            resolveTripAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof JumpJetAttackAction) {</b>
<b class="nc">&nbsp;            resolveJumpJetAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof GrappleAttackAction) {</b>
<b class="nc">&nbsp;            resolveGrappleAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof BreakGrappleAttackAction) {</b>
<b class="nc">&nbsp;            resolveBreakGrappleAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof RamAttackAction) {</b>
<b class="nc">&nbsp;            resolveRamAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof TeleMissileAttackAction) {</b>
<b class="nc">&nbsp;            resolveTeleMissileAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
<b class="nc">&nbsp;        } else if (aaa instanceof BAVibroClawAttackAction) {</b>
<b class="nc">&nbsp;            resolveBAVibroClawAttack(pr, cen);</b>
<b class="nc">&nbsp;            cen = aaa.getEntityId();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Unknown attack action declared.&quot;);</b>
&nbsp;        }
&nbsp;        // Not all targets are Entities.
<b class="nc">&nbsp;        Targetable target = game.getTarget(aaa.getTargetType(), aaa.getTargetId());</b>
<b class="nc">&nbsp;        if (target instanceof Entity) {</b>
<b class="nc">&nbsp;            Entity targetEntity = (Entity) target;</b>
<b class="nc">&nbsp;            targetEntity.setStruck(true);</b>
<b class="nc">&nbsp;            targetEntity.addAttackedByThisTurn(target.getTargetId());</b>
<b class="nc">&nbsp;            creditKill(targetEntity, game.getEntity(cen));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add any extreme gravity PSRs the entity gets due to its movement
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            The &lt;code&gt;Entity&lt;/code&gt; to check.
&nbsp;     * @param step
&nbsp;     *            The last &lt;code&gt;MoveStep&lt;/code&gt; of this entity
&nbsp;     * @param moveType
&nbsp;     *            The movement type for the MovePath the supplied MoveStep comes
&nbsp;     *            from. This generally comes from the last step in the move
&nbsp;     *            path.
&nbsp;     * @param curPos
&nbsp;     *            The current &lt;code&gt;Coords&lt;/code&gt; of this entity
&nbsp;     * @param cachedMaxMPExpenditure
&nbsp;     *            Server checks run/jump MP at start of move, as appropriate,
&nbsp;     *            caches to avoid mid-move change in MP causing erroneous grav
&nbsp;     *            check
&nbsp;     */
&nbsp;    private void checkExtremeGravityMovement(Entity entity, MoveStep step,
&nbsp;                                             EntityMovementType moveType, Coords curPos,
&nbsp;                                             int cachedMaxMPExpenditure) {
&nbsp;        PilotingRollData rollTarget;
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().getGravity() != 1) {</b>
<b class="nc">&nbsp;            if ((entity instanceof Mech) || (entity instanceof Tank)) {</b>
<b class="nc">&nbsp;                if ((moveType == EntityMovementType.MOVE_WALK)</b>
&nbsp;                        || (moveType == EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                        || (moveType == EntityMovementType.MOVE_RUN)
&nbsp;                        || (moveType == EntityMovementType.MOVE_SPRINT)
&nbsp;                        || (moveType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                        || (moveType == EntityMovementType.MOVE_VTOL_SPRINT)) {
<b class="nc">&nbsp;                    int limit = cachedMaxMPExpenditure;</b>
<b class="nc">&nbsp;                    if (step.isOnlyPavement() &amp;&amp; entity.isEligibleForPavementBonus()) {</b>
<b class="nc">&nbsp;                        limit++;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (step.getMpUsed() &gt; limit) {</b>
&nbsp;                        // We moved too fast, let&#39;s make PSR to see if we get
&nbsp;                        // damage
<b class="nc">&nbsp;                        game.addExtremeGravityPSR(entity.checkMovedTooFast(</b>
&nbsp;                                step, moveType));
&nbsp;                    }
<b class="nc">&nbsp;                } else if (moveType == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().debug(&quot;Gravity move check jump: &quot; </b>
<b class="nc">&nbsp;                            + step.getMpUsed() + &quot;/&quot; + cachedMaxMPExpenditure);</b>
<b class="nc">&nbsp;                    int origWalkMP = entity.getWalkMP(false, false);</b>
<b class="nc">&nbsp;                    int gravWalkMP = entity.getWalkMP();</b>
<b class="nc">&nbsp;                    if (step.getMpUsed() &gt; cachedMaxMPExpenditure) {</b>
&nbsp;                        // Jumped too far, make PSR to see if we get damaged
<b class="nc">&nbsp;                        game.addExtremeGravityPSR(entity.checkMovedTooFast(</b>
&nbsp;                                step, moveType));
<b class="nc">&nbsp;                    } else if ((game.getPlanetaryConditions().getGravity() &gt; 1)</b>
&nbsp;                            &amp;&amp; ((origWalkMP - gravWalkMP) &gt; 0)) {
&nbsp;                        // jumping in high g is bad for your legs
&nbsp;                        // Damage dealt = 1 pt for each MP lost due to gravity
&nbsp;                        // Ignore this if no damage would be dealt
<b class="nc">&nbsp;                        rollTarget = entity.getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;                        entity.addPilotingModifierForTerrain(rollTarget, step);</b>
<b class="nc">&nbsp;                        int gravMod = game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                .getGravityPilotPenalty();</b>
<b class="nc">&nbsp;                        if ((gravMod != 0) &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                            rollTarget.addModifier(gravMod, game</b>
<b class="nc">&nbsp;                                    .getPlanetaryConditions().getGravity()</b>
&nbsp;                                    + &quot;G gravity&quot;);
&nbsp;                        }
<b class="nc">&nbsp;                        rollTarget.append(new PilotingRollData(entity.getId(),</b>
&nbsp;                                0, &quot;jumped in high gravity&quot;));
<b class="nc">&nbsp;                        game.addExtremeGravityPSR(rollTarget);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Damage the inner structure of a mech&#39;s leg / a tank&#39;s front. This only
&nbsp;     * happens when the Entity fails an extreme Gravity PSR.
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; to damage.
&nbsp;     * @param damage The &lt;code&gt;int&lt;/code&gt; amount of damage.
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; doExtremeGravityDamage(Entity entity, int damage) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
&nbsp;        HitData hit;
<b class="nc">&nbsp;        if (entity instanceof BipedMech) {</b>
<b class="nc">&nbsp;            for (int i = 6; i &lt;= 7; i++) {</b>
<b class="nc">&nbsp;                hit = new HitData(i);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageEntity(entity, hit, damage, false,</b>
&nbsp;                        DamageType.NONE, true));
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof QuadMech) {</b>
<b class="nc">&nbsp;            for (int i = 4; i &lt;= 7; i++) {</b>
<b class="nc">&nbsp;                hit = new HitData(i);</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(damageEntity(entity, hit, damage, false,</b>
&nbsp;                        DamageType.NONE, true));
&nbsp;            }
<b class="nc">&nbsp;        } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            hit = new HitData(Tank.LOC_FRONT);</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(damageEntity(entity, hit, damage, false,</b>
&nbsp;                    DamageType.NONE, true));
<b class="nc">&nbsp;            vPhaseReport.addAll(vehicleMotiveDamage((Tank)entity, 0));</b>
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Eject an Entity.
&nbsp;     *
&nbsp;     * @param entity    The &lt;code&gt;Entity&lt;/code&gt; to eject.
&nbsp;     * @param autoEject The &lt;code&gt;boolean&lt;/code&gt; state of the entity&#39;s auto- ejection
&nbsp;     *                  system
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the game log.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; ejectEntity(Entity entity, boolean autoEject) {
<b class="nc">&nbsp;        return ejectEntity(entity, autoEject, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Eject an Entity.
&nbsp;     *
&nbsp;     * @param entity            The &lt;code&gt;Entity&lt;/code&gt; to eject.
&nbsp;     * @param autoEject         The &lt;code&gt;boolean&lt;/code&gt; state of the entity&#39;s auto- ejection
&nbsp;     *                          system
&nbsp;     * @param skin_of_the_teeth Perform a skin of the teeth ejection
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the game log.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; ejectEntity(Entity entity, boolean autoEject,
&nbsp;                                      boolean skin_of_the_teeth) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // An entity can only eject it&#39;s crew once.
<b class="nc">&nbsp;        if (entity.getCrew().isEjected()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the crew are already dead, don&#39;t bother
<b class="nc">&nbsp;        if (entity.isCarcass()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mek and fighter pilots may get hurt during ejection,
&nbsp;        // and run around the board afterwards.
<b class="nc">&nbsp;        if (entity instanceof Mech || entity.isFighter()) {</b>
<b class="nc">&nbsp;            int facing = entity.getFacing();</b>
<b class="nc">&nbsp;            Coords targetCoords = (null != entity.getPosition())</b>
<b class="nc">&nbsp;                ? entity.getPosition().translated((facing + 3) % 6) : null;</b>
<b class="nc">&nbsp;            if (entity.isSpaceborne() &amp;&amp; entity.getPosition() != null) {</b>
&nbsp;                //Pilots in space should eject into the fighter&#39;s hex, not behind it
<b class="nc">&nbsp;                targetCoords = entity.getPosition();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (autoEject) {</b>
<b class="nc">&nbsp;                r = new Report(6395);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // okay, print the info
<b class="nc">&nbsp;            PilotingRollData rollTarget = getEjectModifiers(game, entity,</b>
<b class="nc">&nbsp;                    entity.getCrew().getCurrentPilotIndex(), autoEject);</b>
<b class="nc">&nbsp;            r = new Report(2180);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(rollTarget.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            for (int crewPos = 0; crewPos &lt; entity.getCrew().getSlotCount(); crewPos++) {</b>
<b class="nc">&nbsp;                if (entity.getCrew().isMissing(crewPos)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                rollTarget = getEjectModifiers(game, entity, crewPos,</b>
&nbsp;                        autoEject);
&nbsp;                // roll
<b class="nc">&nbsp;                final int diceRoll = entity.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;                if (entity.getCrew().getSlotCount() &gt; 1) {</b>
<b class="nc">&nbsp;                    r = new Report(2193);</b>
<b class="nc">&nbsp;                    r.add(entity.getCrew().getNameAndRole(crewPos));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r = new Report(2190);</b>
&nbsp;                }
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.add(rollTarget.getValueAsString());</b>
<b class="nc">&nbsp;                r.add(rollTarget.getDesc());</b>
<b class="nc">&nbsp;                r.add(diceRoll);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                if (diceRoll &lt; rollTarget.getValue()) {</b>
<b class="nc">&nbsp;                    r.choose(false);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                    if ((rollTarget.getValue() - diceRoll) &gt; 1) {</b>
&nbsp;                        // Pilots take damage based on ejection roll MoF
<b class="nc">&nbsp;                        int damage = (rollTarget.getValue() - diceRoll);</b>
<b class="nc">&nbsp;                        if (entity instanceof Mech) {</b>
&nbsp;                            // MechWarriors only take 1 damage per 2 points of MoF
<b class="nc">&nbsp;                            damage /= 2;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (entity.hasQuirk(OptionsConstants.QUIRK_NEG_DIFFICULT_EJECT)) {</b>
<b class="nc">&nbsp;                            damage++;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        vDesc.addAll(damageCrew(entity, damage, crewPos));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // If this is a skin of the teeth ejection...
<b class="nc">&nbsp;                    if (skin_of_the_teeth &amp;&amp; (entity.getCrew().getHits(crewPos) &lt; 6)) {</b>
<b class="nc">&nbsp;                        Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                        vDesc.addAll(damageCrew(entity, 6 - entity.getCrew()</b>
<b class="nc">&nbsp;                                                                .getHits(crewPos)));</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    r.choose(true);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // create the MechWarrior in any case, for campaign tracking
<b class="nc">&nbsp;            MechWarrior pilot = new MechWarrior(entity);</b>
<b class="nc">&nbsp;            pilot.setDeployed(true);</b>
<b class="nc">&nbsp;            pilot.setId(getFreeEntityId());</b>
<b class="nc">&nbsp;            pilot.setLanded(false);</b>
<b class="nc">&nbsp;            if (entity.isSpaceborne()) {</b>
&nbsp;                //In space, ejected pilots retain the heading and velocity of the unit they eject from
<b class="nc">&nbsp;                pilot.setVectors(entity.getVectors());</b>
<b class="nc">&nbsp;                pilot.setFacing(entity.getFacing());</b>
<b class="nc">&nbsp;                pilot.setCurrentVelocity(entity.getVelocity());</b>
&nbsp;                //If the pilot ejects, he should no longer be accelerating
<b class="nc">&nbsp;                pilot.setNextVelocity(entity.getVelocity());</b>
<b class="nc">&nbsp;            } else if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                pilot.setAltitude(entity.getAltitude());</b>
&nbsp;            }
&nbsp;            //Pilot flight suits are vacuum-rated. MechWarriors wear shorts...
<b class="nc">&nbsp;            pilot.setSpaceSuit(entity.isAero());</b>
<b class="nc">&nbsp;            game.addEntity(pilot);</b>
<b class="nc">&nbsp;            send(createAddEntityPacket(pilot.getId()));</b>
&nbsp;            // make him not get a move this turn
<b class="nc">&nbsp;            pilot.setDone(true);</b>
<b class="nc">&nbsp;            int living = 0;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; entity.getCrew().getSlotCount(); i++) {</b>
<b class="nc">&nbsp;                if (!entity.getCrew().isDead(i) &amp;&amp; entity.getCrew().getHits(i) &lt; Crew.DEATH) {</b>
<b class="nc">&nbsp;                    living++;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            pilot.setInternal(living, MechWarrior.LOC_INFANTRY);</b>
<b class="nc">&nbsp;            if (entity.getCrew().isDead() || entity.getCrew().getHits() &gt;= Crew.DEATH) {</b>
<b class="nc">&nbsp;                pilot.setDoomed(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (entity.getCrew().isDoomed()) {</b>
<b class="nc">&nbsp;                vDesc.addAll(destroyEntity(pilot, &quot;deadly ejection&quot;, false,</b>
&nbsp;                                           false));
&nbsp;            } else {
&nbsp;                // Add the pilot as an infantry unit on the battlefield.
<b class="nc">&nbsp;                if (game.getBoard().contains(targetCoords)) {</b>
<b class="nc">&nbsp;                    pilot.setPosition(targetCoords);</b>
&nbsp;                    // report safe ejection
<b class="nc">&nbsp;                    r = new Report(6400);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;                    // Update the entity
<b class="nc">&nbsp;                    entityUpdate(pilot.getId());</b>
&nbsp;                    // check if the pilot lands in a minefield
<b class="nc">&nbsp;                    if (!entity.isAirborne()) {</b>
<b class="nc">&nbsp;                        vDesc.addAll(doEntityDisplacementMinefieldCheck(pilot,</b>
<b class="nc">&nbsp;                                entity.getPosition(), targetCoords,</b>
<b class="nc">&nbsp;                                entity.getElevation()));</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // ejects safely
<b class="nc">&nbsp;                    r = new Report(6410);</b>
<b class="nc">&nbsp;                    r.subject = entity.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    game.removeEntity(pilot.getId(),</b>
&nbsp;                                      IEntityRemovalConditions.REMOVE_IN_RETREAT);
<b class="nc">&nbsp;                    send(createRemoveEntityPacket(pilot.getId(),</b>
&nbsp;                                                  IEntityRemovalConditions.REMOVE_IN_RETREAT));
&nbsp;                    // }
&nbsp;                }
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)</b>
&nbsp;                        // Don&#39;t create a pilot entity on low-atmospheric maps
<b class="nc">&nbsp;                        || game.getBoard().inAtmosphere()) {</b>
<b class="nc">&nbsp;                    game.removeEntity(pilot.getId(),</b>
&nbsp;                                      IEntityRemovalConditions.REMOVE_IN_RETREAT);
<b class="nc">&nbsp;                    send(createRemoveEntityPacket(pilot.getId(),</b>
&nbsp;                                                  IEntityRemovalConditions.REMOVE_IN_RETREAT));
&nbsp;                }
&nbsp;
&nbsp;                // If this is a skin of the teeth ejection...
<b class="nc">&nbsp;                if (skin_of_the_teeth &amp;&amp; (pilot.getCrew().getHits() &lt; 5)) {</b>
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                    vDesc.addAll(damageCrew(pilot, 5 - pilot.getCrew()</b>
<b class="nc">&nbsp;                                                            .getHits()));</b>
&nbsp;                }
&nbsp;            } // Crew safely ejects.
&nbsp;
&nbsp;            // ejection damages the cockpit
&nbsp;            // kind of irrelevant in stand-alone games, but important for MekHQ
<b class="nc">&nbsp;            if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                Mech mech = (Mech) entity;</b>
&nbsp;                // in case of mechs with &#39;full head ejection&#39;, the head is treated as blown off
<b class="nc">&nbsp;                if (mech.hasFullHeadEject()) {</b>
<b class="nc">&nbsp;                    entity.destroyLocation(Mech.LOC_HEAD, true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    for (CriticalSlot slot : (mech.getCockpit())) {</b>
<b class="nc">&nbsp;                        slot.setDestroyed(true);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }            
<b class="nc">&nbsp;        } // End entity-is-Mek or fighter</b>
<b class="nc">&nbsp;        else if (game.getBoard().contains(entity.getPosition())</b>
&nbsp;                 &amp;&amp; (entity instanceof Tank)) {
<b class="nc">&nbsp;            EjectedCrew crew = new EjectedCrew(entity);</b>
&nbsp;            // Need to set game manually; since game.addEntity not called yet
&nbsp;            // Don&#39;t want to do this yet, as Entity may not be added
<b class="nc">&nbsp;            crew.setGame(game);</b>
<b class="nc">&nbsp;            crew.setDeployed(true);</b>
<b class="nc">&nbsp;            crew.setId(getFreeEntityId());</b>
&nbsp;            // Make them not get a move this turn
<b class="nc">&nbsp;            crew.setDone(true);</b>
&nbsp;            // Place on board
&nbsp;            // Vehicles don&#39;t have ejection systems, so crew must abandon into
&nbsp;            // a legal hex
<b class="nc">&nbsp;            Coords legalPosition = null;</b>
<b class="nc">&nbsp;            if (!crew.isLocationProhibited(entity.getPosition())) {</b>
<b class="nc">&nbsp;                legalPosition = entity.getPosition();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                for (int dir = 0; (dir &lt; 6) &amp;&amp; (legalPosition == null); dir++) {</b>
<b class="nc">&nbsp;                    Coords adjCoords = entity.getPosition().translated(dir);</b>
<b class="nc">&nbsp;                    if (!crew.isLocationProhibited(adjCoords)) {</b>
<b class="nc">&nbsp;                        legalPosition = adjCoords;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // Cannot abandon if there is no legal hex. This shouldn&#39;t have been allowed
<b class="nc">&nbsp;            if (legalPosition == null) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(&quot;Vehicle crews cannot abandon if there is no legal hex!&quot;);</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
<b class="nc">&nbsp;            crew.setPosition(legalPosition);</b>
&nbsp;            // Add Entity to game
<b class="nc">&nbsp;            game.addEntity(crew);</b>
&nbsp;            // Tell clients about new entity
<b class="nc">&nbsp;            send(createAddEntityPacket(crew.getId()));</b>
&nbsp;            // Sent entity info to clients
<b class="nc">&nbsp;            entityUpdate(crew.getId());</b>
&nbsp;            // Check if the crew lands in a minefield
<b class="nc">&nbsp;            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew,</b>
<b class="nc">&nbsp;                    entity.getPosition(), entity.getPosition(),</b>
<b class="nc">&nbsp;                    entity.getElevation()));</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {</b>
<b class="nc">&nbsp;                game.removeEntity(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));</b>
&nbsp;            }
&nbsp;        } //End ground vehicles
&nbsp;
&nbsp;        // Mark the entity&#39;s crew as &quot;ejected&quot;.
<b class="nc">&nbsp;        entity.getCrew().setEjected(true);</b>
<b class="nc">&nbsp;        if (entity instanceof VTOL) {</b>
<b class="nc">&nbsp;            vDesc.addAll(crashVTOLorWiGE((VTOL) entity));</b>
&nbsp;        }
<b class="nc">&nbsp;        vDesc.addAll(destroyEntity(entity, &quot;ejection&quot;, true, true));</b>
&nbsp;
&nbsp;        // only remove the unit that ejected manually
<b class="nc">&nbsp;        if (!autoEject) {</b>
<b class="nc">&nbsp;            game.removeEntity(entity.getId(),</b>
&nbsp;                    IEntityRemovalConditions.REMOVE_EJECTED);
<b class="nc">&nbsp;            send(createRemoveEntityPacket(entity.getId(),</b>
&nbsp;                    IEntityRemovalConditions.REMOVE_EJECTED));
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Abandon a spacecraft (large or small).
&nbsp;     *
&nbsp;     * @param entity  The &lt;code&gt;Aero&lt;/code&gt; to eject.
&nbsp;     * @param inSpace Is this ship spaceborne?
&nbsp;     * @param airborne Is this ship in atmospheric flight?
&nbsp;     * @param pos The coords of this ejection. Needed when abandoning a grounded ship
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the gamelog.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; ejectSpacecraft(Aero entity, boolean inSpace, boolean airborne, Coords pos) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;Report&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // An entity can only eject it&#39;s crew once.
<b class="nc">&nbsp;        if (entity.getCrew().isEjected()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the crew are already dead, don&#39;t bother
<b class="nc">&nbsp;        if (entity.isCarcass()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Try to launch some escape pods and lifeboats, if any are left
<b class="nc">&nbsp;        if ((inSpace &amp;&amp; (entity.getPodsLeft() &gt; 0 || entity.getLifeBoatsLeft() &gt; 0))</b>
<b class="nc">&nbsp;                || (airborne &amp;&amp; entity.getPodsLeft() &gt; 0)) {</b>
&nbsp;            // Report the ejection
<b class="nc">&nbsp;            PilotingRollData rollTarget = getEjectModifiers(game, entity,</b>
<b class="nc">&nbsp;                    entity.getCrew().getCurrentPilotIndex(), false);</b>
<b class="nc">&nbsp;            r = new Report(2180);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(rollTarget.getLastPlainDesc(), true);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;            int MOS = (roll - Math.max(2, rollTarget.getValue()));</b>
&nbsp;            //Report the roll
<b class="nc">&nbsp;            r = new Report(2190);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(rollTarget.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(rollTarget.getDesc());</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.choose(roll &gt;= rollTarget.getValue());</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;            //Per SO p27, you get a certain number of escape pods away per turn per 100k tons of ship
<b class="nc">&nbsp;            int escapeMultiplier = (int) (entity.getWeight() / 100000);</b>
&nbsp;            //Set up the maximum number that CAN launch
<b class="nc">&nbsp;            int toLaunch = 0;</b>
<b class="nc">&nbsp;            if (roll &lt; rollTarget.getValue()) {</b>
<b class="nc">&nbsp;                toLaunch = 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toLaunch = (1 + MOS) * Math.max(1, escapeMultiplier);</b>
&nbsp;            }
&nbsp;            //And now modify it based on what the unit actually has TO launch
<b class="nc">&nbsp;            int launchCounter = toLaunch;</b>
<b class="nc">&nbsp;            int totalLaunched = 0;</b>
<b class="nc">&nbsp;            boolean isPod = false;</b>
<b class="nc">&nbsp;            while (launchCounter &gt; 0) {</b>
<b class="nc">&nbsp;                int launched = 0;</b>
<b class="nc">&nbsp;                if (entity.getPodsLeft() &gt; 0 &amp;&amp; (airborne || entity.getPodsLeft() &gt;= entity.getLifeBoatsLeft())) {</b>
&nbsp;                    //Entity has more escape pods than lifeboats (or equal numbers)
<b class="nc">&nbsp;                    launched = Math.min(launchCounter, entity.getPodsLeft());</b>
<b class="nc">&nbsp;                    entity.setLaunchedEscapePods(entity.getLaunchedEscapePods() + launched);</b>
<b class="nc">&nbsp;                    totalLaunched += launched;</b>
<b class="nc">&nbsp;                    launchCounter -= launched;</b>
<b class="nc">&nbsp;                    isPod = true;</b>
<b class="nc">&nbsp;                } else if (inSpace &amp;&amp; entity.getLifeBoatsLeft() &gt; 0 &amp;&amp; (entity.getLifeBoatsLeft() &gt; entity.getPodsLeft())) {</b>
&nbsp;                    //Entity has more lifeboats left
<b class="nc">&nbsp;                    launched = Math.min(launchCounter, entity.getLifeBoatsLeft());</b>
<b class="nc">&nbsp;                    entity.setLaunchedLifeBoats(entity.getLaunchedLifeBoats() + launched);</b>
<b class="nc">&nbsp;                    totalLaunched += launched;</b>
<b class="nc">&nbsp;                    launchCounter -= launched;</b>
&nbsp;                } else {
&nbsp;                    //We&#39;ve run out of both. End the loop
&nbsp;                    break;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            int nEscaped = Math.min((entity.getCrew().getCurrentSize() + entity.getNPassenger()), (totalLaunched * 6));</b>
&nbsp;            //Report how many pods launched and how many escaped
<b class="nc">&nbsp;            if (totalLaunched &gt; 0) {</b>
<b class="nc">&nbsp;                r = new Report(6401);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.add(totalLaunched);</b>
<b class="nc">&nbsp;                r.add(nEscaped);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            EscapePods pods = new EscapePods(entity,totalLaunched,isPod);</b>
<b class="nc">&nbsp;            entity.addEscapeCraft(pods.getExternalIdAsString());</b>
&nbsp;            //Update the personnel numbers
&nbsp;            
&nbsp;            //If there are passengers aboard, get them out first
<b class="nc">&nbsp;            if (entity.getNPassenger() &gt; 0) {</b>
<b class="nc">&nbsp;                int change = Math.min(entity.getNPassenger(), nEscaped);</b>
<b class="nc">&nbsp;                entity.setNPassenger(Math.max(entity.getNPassenger() - nEscaped, 0));</b>
<b class="nc">&nbsp;                pods.addPassengers(entity.getExternalIdAsString(), change);</b>
<b class="nc">&nbsp;                nEscaped -= change;</b>
&nbsp;            }
&nbsp;            //Now get the crew out with such space as is left
<b class="nc">&nbsp;            if (nEscaped &gt; 0) {</b>
<b class="nc">&nbsp;                entity.setNCrew(entity.getNCrew() - nEscaped);</b>
<b class="nc">&nbsp;                entity.getCrew().setCurrentSize(Math.max(0, entity.getCrew().getCurrentSize() - nEscaped));</b>
<b class="nc">&nbsp;                pods.addNOtherCrew(entity.getExternalIdAsString(), nEscaped);</b>
&nbsp;                //*Damage* the host ship&#39;s crew to account for the people that left
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(entity,entity.getCrew().calculateHits()));</b>
<b class="nc">&nbsp;                if (entity.getCrew().getHits() &gt;= Crew.DEATH) {</b>
&nbsp;                    //Then we&#39;ve finished ejecting
<b class="nc">&nbsp;                    entity.getCrew().setEjected(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Need to set game manually; since game.addEntity not called yet
&nbsp;            // Don&#39;t want to do this yet, as Entity may not be added
<b class="nc">&nbsp;            pods.setPosition(entity.getPosition());</b>
<b class="nc">&nbsp;            pods.setGame(game);</b>
<b class="nc">&nbsp;            pods.setDeployed(true);</b>
<b class="nc">&nbsp;            pods.setId(getFreeEntityId());</b>
&nbsp;            //Escape craft retain the heading and velocity of the unit they eject from
<b class="nc">&nbsp;            pods.setVectors(entity.getVectors());</b>
<b class="nc">&nbsp;            pods.setFacing(entity.getFacing());</b>
<b class="nc">&nbsp;            pods.setCurrentVelocity(entity.getCurrentVelocity());</b>
&nbsp;            //If the crew ejects, they should no longer be accelerating
<b class="nc">&nbsp;            pods.setNextVelocity(entity.getVelocity());</b>
<b class="nc">&nbsp;            if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                pods.setAltitude(entity.getAltitude());</b>
&nbsp;            }
&nbsp;            // Add Entity to game
<b class="nc">&nbsp;            game.addEntity(pods);</b>
&nbsp;            // No movement this turn
<b class="nc">&nbsp;            pods.setDone(true);</b>
&nbsp;            // Tell clients about new entity
<b class="nc">&nbsp;            send(createAddEntityPacket(pods.getId()));</b>
&nbsp;            // Sent entity info to clients
<b class="nc">&nbsp;            entityUpdate(pods.getId());</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {</b>
<b class="nc">&nbsp;                game.removeEntity(pods.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(pods.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));</b>
&nbsp;            }
<b class="nc">&nbsp;        } // End Escape Pod/Lifeboat Ejection</b>
&nbsp;        else {
<b class="nc">&nbsp;            if (airborne) {</b>
&nbsp;                // Can&#39;t abandon in atmosphere with no escape pods
<b class="nc">&nbsp;                r = new Report(6402);</b>
<b class="nc">&nbsp;                r.subject = entity.getId();</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Eject up to 50 spacesuited crewmen out the nearest airlock!
&nbsp;            // This only works in space or on the ground
<b class="nc">&nbsp;            int nEscaped = Math.min(entity.getNPassenger() + entity.getCrew().getCurrentSize(), 50);</b>
<b class="nc">&nbsp;            EjectedCrew crew = new EjectedCrew(entity, nEscaped);</b>
<b class="nc">&nbsp;            entity.addEscapeCraft(crew.getExternalIdAsString());</b>
&nbsp;            
&nbsp;            //Report the escape
<b class="nc">&nbsp;            r = new Report(6403);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(nEscaped);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;
&nbsp;            //If there are passengers aboard, get them out first
<b class="nc">&nbsp;            if (entity.getNPassenger() &gt; 0) {</b>
<b class="nc">&nbsp;                int change = Math.min(entity.getNPassenger(), nEscaped);</b>
<b class="nc">&nbsp;                entity.setNPassenger(Math.max(entity.getNPassenger() - nEscaped, 0));</b>
<b class="nc">&nbsp;                crew.addPassengers(entity.getExternalIdAsString(), change);</b>
<b class="nc">&nbsp;                nEscaped -= change;</b>
&nbsp;            }
&nbsp;            //Now get the crew out with such airlock space as is left
<b class="nc">&nbsp;            if (nEscaped &gt; 0) {</b>
<b class="nc">&nbsp;                entity.setNCrew(entity.getNCrew() - nEscaped);</b>
<b class="nc">&nbsp;                entity.getCrew().setCurrentSize(Math.max(0, entity.getCrew().getCurrentSize() - nEscaped));</b>
<b class="nc">&nbsp;                crew.addNOtherCrew(entity.getExternalIdAsString(), nEscaped);</b>
&nbsp;                //*Damage* the host ship&#39;s crew to account for the people that left
<b class="nc">&nbsp;                vDesc.addAll(damageCrew(entity,entity.getCrew().calculateHits()));</b>
<b class="nc">&nbsp;                if (entity.getCrew().getHits() &gt;= Crew.DEATH) {</b>
&nbsp;                    //Then we&#39;ve finished ejecting
<b class="nc">&nbsp;                    entity.getCrew().setEjected(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Need to set game manually; since game.addEntity not called yet
&nbsp;            // Don&#39;t want to do this yet, as Entity may not be added
<b class="nc">&nbsp;            crew.setGame(game);</b>
<b class="nc">&nbsp;            crew.setDeployed(true);</b>
<b class="nc">&nbsp;            crew.setId(getFreeEntityId());</b>
<b class="nc">&nbsp;            if (inSpace) {</b>
&nbsp;                //In space, ejected pilots retain the heading and velocity of the unit they eject from
<b class="nc">&nbsp;                crew.setVectors(entity.getVectors());</b>
<b class="nc">&nbsp;                crew.setFacing(entity.getFacing());</b>
<b class="nc">&nbsp;                crew.setCurrentVelocity(entity.getVelocity());</b>
&nbsp;                //If the crew ejects, they should no longer be accelerating
<b class="nc">&nbsp;                crew.setNextVelocity(entity.getVelocity());</b>
&nbsp;                // We&#39;re going to be nice and assume a ship has enough spacesuits for everyone aboard...
<b class="nc">&nbsp;                crew.setSpaceSuit(true);</b>
<b class="nc">&nbsp;                crew.setPosition(entity.getPosition());</b>
&nbsp;            } else {
&nbsp;                // On the ground, crew must abandon into a legal hex
<b class="nc">&nbsp;                Coords legalPosition = null;</b>
&nbsp;                //Small Craft can just abandon into the hex they occupy
<b class="nc">&nbsp;                if (!entity.isLargeCraft() &amp;&amp; !crew.isLocationProhibited(entity.getPosition())) {</b>
<b class="nc">&nbsp;                    legalPosition = entity.getPosition();</b>
&nbsp;                } else {
&nbsp;                    //Use the passed in coords. We already calculated whether they&#39;re legal or not
<b class="nc">&nbsp;                    legalPosition = pos;</b>
&nbsp;                }
&nbsp;                // Cannot abandon if there is no legal hex.  This shoudln&#39;t have
&nbsp;                // been allowed
<b class="nc">&nbsp;                if (legalPosition == null) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().error(&quot;Spacecraft crews cannot abandon if there is no legal hex!&quot;);</b>
<b class="nc">&nbsp;                    return vDesc;</b>
&nbsp;                }
<b class="nc">&nbsp;                crew.setPosition(legalPosition);</b>
&nbsp;            }
&nbsp;            // Add Entity to game
<b class="nc">&nbsp;            game.addEntity(crew);</b>
&nbsp;            // No movement this turn
<b class="nc">&nbsp;            crew.setDone(true);</b>
&nbsp;            // Tell clients about new entity
<b class="nc">&nbsp;            send(createAddEntityPacket(crew.getId()));</b>
&nbsp;            // Sent entity info to clients
<b class="nc">&nbsp;            entityUpdate(crew.getId());</b>
&nbsp;            // Check if the crew lands in a minefield
<b class="nc">&nbsp;            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew,</b>
<b class="nc">&nbsp;                    entity.getPosition(), entity.getPosition(),</b>
<b class="nc">&nbsp;                    entity.getElevation()));</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {</b>
<b class="nc">&nbsp;                game.removeEntity(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // If we get here, end movement and return the report
<b class="nc">&nbsp;        entity.setDone(true);</b>
<b class="nc">&nbsp;        entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static PilotingRollData getEjectModifiers(IGame game,
&nbsp;            Entity entity, int crewPos, boolean autoEject) {
<b class="nc">&nbsp;        int facing = entity.getFacing();</b>
<b class="nc">&nbsp;        if (entity.isPartOfFighterSquadron()) {</b>
&nbsp;            // Because the components of a squadron have no position and will pass the next test
<b class="nc">&nbsp;            Entity squadron = game.getEntity(entity.getTransportId());</b>
<b class="nc">&nbsp;            return getEjectModifiers(game, entity, crewPos, autoEject, squadron.getPosition(),</b>
&nbsp;                    &quot;ejecting&quot;);
&nbsp;        }
<b class="nc">&nbsp;        if(null == entity.getPosition()) {</b>
&nbsp;            // Off-board unit?
<b class="nc">&nbsp;            return new PilotingRollData(entity.getId(), entity.getCrew().getPiloting(), &quot;ejecting&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        Coords targetCoords = entity.getPosition().translated((facing + 3) % 6);</b>
<b class="nc">&nbsp;        return getEjectModifiers(game, entity, crewPos, autoEject, targetCoords,</b>
&nbsp;                &quot;ejecting&quot;);
&nbsp;    }
&nbsp;
&nbsp;    public static PilotingRollData getEjectModifiers(IGame game, Entity entity, int crewPos,
&nbsp;            boolean autoEject, Coords targetCoords, String desc) {
<b class="nc">&nbsp;        PilotingRollData rollTarget = new PilotingRollData(entity.getId(),</b>
<b class="nc">&nbsp;                entity.getCrew().getPiloting(crewPos), desc);</b>
&nbsp;        // Per SO p26, fighters can eject as per TO rules on 196 with some exceptions
<b class="nc">&nbsp;        if (entity.isProne()) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(5, &quot;Mech is prone&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity.getCrew().isUnconscious(crewPos)) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(3, &quot;pilot unconscious&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (autoEject) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(1, &quot;automatic ejection&quot;);</b>
&nbsp;        }
&nbsp;        // Per SO p27, Large Craft roll too, to see how many escape pods launch successfully
<b class="nc">&nbsp;        if ((entity.isAero() &amp;&amp; ((IAero)entity).isOutControl())</b>
<b class="nc">&nbsp;                || (entity.isPartOfFighterSquadron() &amp;&amp; ((IAero)game.getEntity(entity.getTransportId())).isOutControl())) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(5, &quot;Out of Control&quot;);</b>
&nbsp;        }
&nbsp;        // A decreased large craft crew makes it harder to eject large numbers of pods
<b class="nc">&nbsp;        if (entity.isLargeCraft() &amp;&amp; entity.getCrew().getHits() &gt; 0) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(entity.getCrew().getHits(), &quot;Crew hits&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((entity instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getInternal(Mech.LOC_HEAD) &lt; entity</b>
<b class="nc">&nbsp;                        .getOInternal(Mech.LOC_HEAD))) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(</b>
<b class="nc">&nbsp;                    entity.getOInternal(Mech.LOC_HEAD)</b>
<b class="nc">&nbsp;                            - entity.getInternal(Mech.LOC_HEAD),</b>
&nbsp;                    &quot;Head Internal Structure Damage&quot;);
&nbsp;        }
<b class="nc">&nbsp;        IHex targetHex = game.getBoard().getHex(targetCoords);</b>
&nbsp;        //Terrain modifiers should only apply if the unit is on the ground...
<b class="nc">&nbsp;        if (!entity.isSpaceborne() &amp;&amp; !entity.isAirborne()) {</b>
<b class="nc">&nbsp;            if (targetHex != null) {</b>
<b class="nc">&nbsp;                if ((targetHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;                        &amp;&amp; !targetHex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(-1, &quot;landing in water&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.containsTerrain(Terrains.ROUGH)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(0, &quot;landing in rough&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.containsTerrain(Terrains.RUBBLE)) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(0, &quot;landing in rubble&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.WOODS) == 1) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(2, &quot;landing in light woods&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.WOODS) == 2) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(3, &quot;landing in heavy woods&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.WOODS) == 3) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(4, &quot;landing in ultra heavy woods&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 1) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(3, &quot;landing in light jungle&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 2) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(5, &quot;landing in heavy jungle&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 3) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(7, &quot;landing in ultra heavy jungle&quot;);</b>
<b class="nc">&nbsp;                } else if (targetHex.terrainLevel(Terrains.BLDG_ELEV) &gt; 0) {</b>
<b class="nc">&nbsp;                    rollTarget.addModifier(</b>
<b class="nc">&nbsp;                            targetHex.terrainLevel(Terrains.BLDG_ELEV),</b>
&nbsp;                            &quot;landing in a building&quot;);
&nbsp;                } else {
<b class="nc">&nbsp;                    rollTarget.addModifier(-2, &quot;landing in clear terrain&quot;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                rollTarget.addModifier(-2, &quot;landing off the board&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!entity.isSpaceborne()) {</b>
&nbsp;            //At present, the UI lets you set these atmospheric conditions for a space battle, but it shouldn&#39;t
&nbsp;            //That&#39;s a fix for another day, probably when I get around to space terrain and &#39;weather&#39;
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().getGravity() == 0) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(3, &quot;Zero-G&quot;);</b>
<b class="nc">&nbsp;            } else if (game.getPlanetaryConditions().getGravity() &lt; .8) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(2, &quot;Low-G&quot;);</b>
<b class="nc">&nbsp;            } else if (game.getPlanetaryConditions().getGravity() &gt; 1.2) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(2, &quot;High-G&quot;);</b>
&nbsp;            }
&nbsp;        
&nbsp;            //Vacuum shouldn&#39;t apply to ASF ejection since they&#39;re designed for it, but the rules don&#39;t specify
&nbsp;            //High and low pressures make more sense to apply to all
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_VACUUM) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(3, &quot;Vacuum&quot;);</b>
<b class="nc">&nbsp;            } else if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_VHIGH) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(2, &quot;Very High Atmosphere Pressure&quot;);</b>
<b class="nc">&nbsp;            } else if (game.getPlanetaryConditions().getAtmosphere() == PlanetaryConditions.ATMO_TRACE) {</b>
<b class="nc">&nbsp;                rollTarget.addModifier(2, &quot;Trace atmosphere&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW)</b>
<b class="nc">&nbsp;                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_ICE_STORM)</b>
<b class="nc">&nbsp;                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_DOWNPOUR)</b>
<b class="nc">&nbsp;                || (game.getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_STRONG_GALE)) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(2, &quot;Bad Weather&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getPlanetaryConditions().getWindStrength() &gt;= PlanetaryConditions.WI_STORM)</b>
<b class="nc">&nbsp;                || (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_BLIZZARD)</b>
<b class="nc">&nbsp;                || ((game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW) &amp;&amp; (game</b>
<b class="nc">&nbsp;                        .getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_STRONG_GALE))) {</b>
<b class="nc">&nbsp;            rollTarget.addModifier(3, &quot;Really Bad Weather&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return rollTarget;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new Ballistic Infantry unit at the end of the movement phase
&nbsp;     */
&nbsp;    public void resolveCallSupport() {
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if ((e instanceof Infantry) &amp;&amp; ((Infantry) e).getIsCallingSupport()) {</b>
&nbsp;
&nbsp;                // Now lets create a new foot platoon
<b class="nc">&nbsp;                Infantry guerrilla = new Infantry();</b>
<b class="nc">&nbsp;                guerrilla.setChassis(&quot;Insurgents&quot;);</b>
<b class="nc">&nbsp;                guerrilla.setModel(&quot;(Rifle)&quot;);</b>
<b class="nc">&nbsp;                guerrilla.setSquadN(4);</b>
<b class="nc">&nbsp;                guerrilla.setSquadSize(7);</b>
<b class="nc">&nbsp;                guerrilla.autoSetInternal();</b>
<b class="nc">&nbsp;                guerrilla.getCrew().setGunnery(5, 0);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    guerrilla.addEquipment(EquipmentType.get(EquipmentTypeLookup.INFANTRY_ASSAULT_RIFLE),</b>
&nbsp;                            Infantry.LOC_INFANTRY);
<b class="nc">&nbsp;                    guerrilla.setPrimaryWeapon((InfantryWeapon) InfantryWeapon</b>
<b class="nc">&nbsp;                            .get(EquipmentTypeLookup.INFANTRY_ASSAULT_RIFLE));</b>
<b class="nc">&nbsp;                } catch (Exception ex) {</b>
<b class="nc">&nbsp;                    ex.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                guerrilla.setDeployed(true);</b>
<b class="nc">&nbsp;                guerrilla.setDone(true);</b>
<b class="nc">&nbsp;                guerrilla.setId(getFreeEntityId());</b>
<b class="nc">&nbsp;                guerrilla.setOwner(e.getOwner());</b>
<b class="nc">&nbsp;                game.addEntity(guerrilla);</b>
&nbsp;
&nbsp;                // Add the infantry unit on the battlefield. Should spawn within 3 hexes
&nbsp;                // First get coords then loop over some targets
<b class="nc">&nbsp;                Coords tmpCoords = e.getPosition();</b>
<b class="nc">&nbsp;                Coords targetCoords = null;</b>
<b class="nc">&nbsp;                while (!game.getBoard().contains(targetCoords)) {</b>
<b class="nc">&nbsp;                    targetCoords = Compute.scatter(tmpCoords, (Compute.d6(1) / 2));</b>
<b class="nc">&nbsp;                    if (game.getBoard().contains(targetCoords)) {</b>
<b class="nc">&nbsp;                        guerrilla.setPosition(targetCoords);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                send(createAddEntityPacket(guerrilla.getId()));</b>
<b class="nc">&nbsp;                ((Infantry) e).setIsCallingSupport(false);</b>
&nbsp;                /*
&nbsp;                // Update the entity
&nbsp;                entityUpdate(guerrilla.getId());
&nbsp;                Report r = new Report(5535, Report.PUBLIC);
&nbsp;                r.subject = e.getId();
&nbsp;                r.addDesc(e);
&nbsp;                addReport(r);*/
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Abandon an Entity.
&nbsp;     *
&nbsp;     * @param entity The &lt;code&gt;Entity&lt;/code&gt; to abandon.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the game log.
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; abandonEntity(Entity entity) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
&nbsp;
&nbsp;        // An entity can only eject it&#39;s crew once.
<b class="nc">&nbsp;        if (entity.getCrew().isEjected()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.getCrew().isDoomed() || entity.getCrew().isDead()) {</b>
<b class="nc">&nbsp;            return vDesc;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Coords targetCoords = entity.getPosition();</b>
&nbsp;
<b class="nc">&nbsp;        if (entity instanceof Mech || (entity.isAero() &amp;&amp; !entity.isAirborne())) {</b>
&nbsp;            // okay, print the info
<b class="nc">&nbsp;            r = new Report(2027);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(entity.getCrew().getName());</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
&nbsp;            // Don&#39;t make ill-equipped pilots abandon into vacuum
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().isVacuum() &amp;&amp; !entity.isAero()) {</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
&nbsp;
&nbsp;            // create the MechWarrior in any case, for campaign tracking
<b class="nc">&nbsp;            MechWarrior pilot = new MechWarrior(entity);</b>
<b class="nc">&nbsp;            pilot.getCrew().setUnconscious(entity.getCrew().isUnconscious());</b>
<b class="nc">&nbsp;            pilot.setDeployed(true);</b>
<b class="nc">&nbsp;            pilot.setId(getFreeEntityId());</b>
&nbsp;            //Pilot flight suits are vacuum-rated. MechWarriors wear shorts...
<b class="nc">&nbsp;            pilot.setSpaceSuit(entity.isAero());</b>
<b class="nc">&nbsp;            if (entity.isSpaceborne()) {</b>
&nbsp;                //In space, ejected pilots retain the heading and velocity of the unit they eject from
<b class="nc">&nbsp;                pilot.setVectors(entity.getVectors());</b>
<b class="nc">&nbsp;                pilot.setFacing(entity.getFacing());</b>
<b class="nc">&nbsp;                pilot.setCurrentVelocity(entity.getVelocity());</b>
&nbsp;                //If the pilot ejects, he should no longer be accelerating
<b class="nc">&nbsp;                pilot.setNextVelocity(entity.getVelocity());</b>
&nbsp;            }
<b class="nc">&nbsp;            game.addEntity(pilot);</b>
<b class="nc">&nbsp;            send(createAddEntityPacket(pilot.getId()));</b>
&nbsp;            // make him not get a move this turn
<b class="nc">&nbsp;            pilot.setDone(true);</b>
&nbsp;            // Add the pilot as an infantry unit on the battlefield.
<b class="nc">&nbsp;            if (game.getBoard().contains(targetCoords)) {</b>
<b class="nc">&nbsp;                pilot.setPosition(targetCoords);</b>
&nbsp;            }
<b class="nc">&nbsp;            pilot.setCommander(entity.isCommander());</b>
&nbsp;            // Update the entity
<b class="nc">&nbsp;            entityUpdate(pilot.getId());</b>
&nbsp;            // check if the pilot lands in a minefield
<b class="nc">&nbsp;            vDesc.addAll(doEntityDisplacementMinefieldCheck(pilot, entity.getPosition(),</b>
<b class="nc">&nbsp;                    targetCoords, entity.getElevation()));</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {</b>
<b class="nc">&nbsp;                game.removeEntity(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(pilot.getId(),</b>
&nbsp;                        IEntityRemovalConditions.REMOVE_IN_RETREAT));
&nbsp;            }
<b class="nc">&nbsp;        } // End entity-is-Mek or Aero</b>
<b class="nc">&nbsp;        else if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLES_CAN_EJECT)</b>
&nbsp;                 &amp;&amp; (entity instanceof Tank)) {
&nbsp;            // Don&#39;t make them abandon into vacuum
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().isVacuum()) {</b>
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            }
<b class="nc">&nbsp;            EjectedCrew crew = new EjectedCrew(entity);</b>
<b class="nc">&nbsp;            crew.setDeployed(true);</b>
<b class="nc">&nbsp;            crew.setId(getFreeEntityId());</b>
<b class="nc">&nbsp;            game.addEntity(crew);</b>
<b class="nc">&nbsp;            send(createAddEntityPacket(crew.getId()));</b>
&nbsp;            // Make them not get a move this turn
<b class="nc">&nbsp;            crew.setDone(true);</b>
&nbsp;            // Place on board
<b class="nc">&nbsp;            if(game.getBoard().contains(entity.getPosition())) {</b>
<b class="nc">&nbsp;                crew.setPosition(entity.getPosition());</b>
&nbsp;            }
&nbsp;            // Update the entity
<b class="nc">&nbsp;            entityUpdate(crew.getId());</b>
&nbsp;            // Check if the crew lands in a minefield
<b class="nc">&nbsp;            vDesc.addAll(doEntityDisplacementMinefieldCheck(crew, entity.getPosition(),</b>
<b class="nc">&nbsp;                    entity.getPosition(), entity.getElevation()));</b>
<b class="nc">&nbsp;            if(game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_EJECTED_PILOTS_FLEE)) {</b>
<b class="nc">&nbsp;                game.removeEntity(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;                send(createRemoveEntityPacket(crew.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Mark the entity&#39;s crew as &quot;ejected&quot;.
<b class="nc">&nbsp;        entity.getCrew().setEjected(true);</b>
&nbsp;
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if ejected MechWarriors are eligible to be picked up, and if so,
&nbsp;     * captures them or picks them up
&nbsp;     */
&nbsp;    private void resolveMechWarriorPickUp() {
&nbsp;        Report r;
&nbsp;
&nbsp;        // fetch all mechWarriors that are not picked up
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; mechWarriors = game.getSelectedEntities(entity -&gt; {</b>
<b class="nc">&nbsp;                    if (entity instanceof MechWarrior) {</b>
<b class="nc">&nbsp;                        MechWarrior mw = (MechWarrior) entity;</b>
<b class="nc">&nbsp;                        return (mw.getPickedUpById() == Entity.NONE)</b>
<b class="nc">&nbsp;                                &amp;&amp; !mw.isDoomed()</b>
<b class="nc">&nbsp;                                &amp;&amp; (mw.getTransportId() == Entity.NONE);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                });
&nbsp;        // loop through them, check if they are in a hex occupied by another
&nbsp;        // unit
<b class="nc">&nbsp;        while (mechWarriors.hasNext()) {</b>
<b class="nc">&nbsp;            boolean pickedUp = false;</b>
<b class="nc">&nbsp;            MechWarrior e = (MechWarrior) mechWarriors.next();</b>
&nbsp;            // Check for owner entities first...
<b class="nc">&nbsp;            for (Entity pe : game.getEntitiesVector(e.getPosition())) {</b>
<b class="nc">&nbsp;                if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()</b>
<b class="nc">&nbsp;                        || (pe.isAirborne() &amp;&amp; !pe.isSpaceborne())</b>
<b class="nc">&nbsp;                        || (pe.getElevation() != e.getElevation())</b>
<b class="nc">&nbsp;                        || (pe.getOwnerId() != e.getOwnerId())</b>
<b class="nc">&nbsp;                        || (pe.getId() == e.getId())) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (pe instanceof MechWarrior) {</b>
&nbsp;                    // MWs have a beer together
<b class="nc">&nbsp;                    r = new Report(6415, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(pe.getDisplayName());</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Pick up the unit.
<b class="nc">&nbsp;                pe.pickUp(e);</b>
&nbsp;                // The picked unit is being carried by the loader.
<b class="nc">&nbsp;                e.setPickedUpById(pe.getId());</b>
<b class="nc">&nbsp;                e.setPickedUpByExternalId(pe.getExternalIdAsString());</b>
<b class="nc">&nbsp;                pickedUp = true;</b>
<b class="nc">&nbsp;                r = new Report(6420, Report.PUBLIC);</b>
<b class="nc">&nbsp;                r.add(e.getDisplayName());</b>
<b class="nc">&nbsp;                r.addDesc(pe);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            // Check for allied entities next...
<b class="nc">&nbsp;            if (!pickedUp) {</b>
<b class="nc">&nbsp;                for (Entity pe : game.getEntitiesVector(e.getPosition())) {</b>
<b class="nc">&nbsp;                    if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()</b>
<b class="nc">&nbsp;                            || (pe.isAirborne() &amp;&amp; !pe.isSpaceborne())</b>
<b class="nc">&nbsp;                            || (pe.getElevation() != e.getElevation())</b>
<b class="nc">&nbsp;                            || (pe.getOwnerId() == e.getOwnerId()) || (pe.getId() == e.getId())</b>
<b class="nc">&nbsp;                            || (pe.getOwner().getTeam() == IPlayer.TEAM_NONE)</b>
<b class="nc">&nbsp;                            || (pe.getOwner().getTeam() != e.getOwner().getTeam())) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (pe instanceof MechWarrior) {</b>
&nbsp;                        // MWs have a beer together
<b class="nc">&nbsp;                        r = new Report(6415, Report.PUBLIC);</b>
<b class="nc">&nbsp;                        r.add(pe.getDisplayName());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Pick up the unit.
<b class="nc">&nbsp;                    pe.pickUp(e);</b>
&nbsp;                    // The picked unit is being carried by the loader.
<b class="nc">&nbsp;                    e.setPickedUpById(pe.getId());</b>
<b class="nc">&nbsp;                    e.setPickedUpByExternalId(pe.getExternalIdAsString());</b>
<b class="nc">&nbsp;                    pickedUp = true;</b>
<b class="nc">&nbsp;                    r = new Report(6420, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(e.getDisplayName());</b>
<b class="nc">&nbsp;                    r.addDesc(pe);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Now check for anyone else...
<b class="nc">&nbsp;            if (!pickedUp) {</b>
<b class="nc">&nbsp;                Iterator&lt;Entity&gt; pickupEnemyEntities = game.getEnemyEntities(e.getPosition(), e);</b>
<b class="nc">&nbsp;                while (pickupEnemyEntities.hasNext()) {</b>
<b class="nc">&nbsp;                    Entity pe = pickupEnemyEntities.next();</b>
<b class="nc">&nbsp;                    if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()</b>
<b class="nc">&nbsp;                            || pe.isAirborne() || (pe.getElevation() != e.getElevation())) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (pe instanceof MechWarrior) {</b>
&nbsp;                        // MWs have a beer together
<b class="nc">&nbsp;                        r = new Report(6415, Report.PUBLIC);</b>
<b class="nc">&nbsp;                        r.add(pe.getDisplayName());</b>
<b class="nc">&nbsp;                        addReport(r);</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Capture the unit.
<b class="nc">&nbsp;                    pe.pickUp(e);</b>
&nbsp;                    // The captured unit is being carried by the loader.
<b class="nc">&nbsp;                    e.setCaptured(true);</b>
<b class="nc">&nbsp;                    e.setPickedUpById(pe.getId());</b>
<b class="nc">&nbsp;                    e.setPickedUpByExternalId(pe.getExternalIdAsString());</b>
<b class="nc">&nbsp;                    pickedUp = true;</b>
<b class="nc">&nbsp;                    r = new Report(6420, Report.PUBLIC);</b>
<b class="nc">&nbsp;                    r.add(e.getDisplayName());</b>
<b class="nc">&nbsp;                    r.addDesc(pe);</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (pickedUp) {</b>
&nbsp;                // Remove the picked-up unit from the screen.
<b class="nc">&nbsp;                e.setPosition(null);</b>
&nbsp;                // Update the loaded unit.
<b class="nc">&nbsp;                entityUpdate(e.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * destroy all wheeled and tracked Tanks that got displaced into water
&nbsp;     */
&nbsp;    private void resolveSinkVees() {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; sinkableTanks = game.getSelectedEntities(entity -&gt; {</b>
<b class="nc">&nbsp;                    if (entity.isOffBoard() || (entity.getPosition() == null)</b>
&nbsp;                            || !(entity instanceof Tank)) {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final IHex hex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;                    final boolean onBridge = (hex.terrainLevel(Terrains.BRIDGE) &gt; 0)</b>
<b class="nc">&nbsp;                            &amp;&amp; (entity.getElevation() == hex.terrainLevel(Terrains.BRIDGE_ELEV));</b>
<b class="nc">&nbsp;                    return ((entity.getMovementMode() == EntityMovementMode.TRACKED)</b>
<b class="nc">&nbsp;                            || (entity.getMovementMode() == EntityMovementMode.WHEELED)</b>
<b class="nc">&nbsp;                            || ((entity.getMovementMode() == EntityMovementMode.HOVER)))</b>
<b class="nc">&nbsp;                            &amp;&amp; entity.isImmobile() &amp;&amp; (hex.terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;                            &amp;&amp; !onBridge &amp;&amp; !(entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS))</b>
<b class="nc">&nbsp;                            &amp;&amp; !(entity.hasWorkingMisc(MiscType.F_FLOTATION_HULL));</b>
&nbsp;                });
<b class="nc">&nbsp;        while (sinkableTanks.hasNext()) {</b>
<b class="nc">&nbsp;            Entity e = sinkableTanks.next();</b>
<b class="nc">&nbsp;            addReport(destroyEntity(e, &quot;a watery grave&quot;, false));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * let all Entities make their &quot;break-free-of-swamp-stickyness&quot; PSR
&nbsp;     */
&nbsp;    private void doTryUnstuck() {
<b class="nc">&nbsp;        if (game.getPhase() != IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; stuckEntities = game.getSelectedEntities(Entity::isStuck);</b>
&nbsp;        PilotingRollData rollTarget;
<b class="nc">&nbsp;        while (stuckEntities.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = stuckEntities.next();</b>
<b class="nc">&nbsp;            if (entity.getPosition() == null) {</b>
<b class="nc">&nbsp;                if (entity.isDeployed()) {</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().info(&quot;Entity #&quot; + entity.getId() + &quot; does not know its position.&quot;);</b>
&nbsp;                } else { // If the Entity isn&#39;t deployed, then something goofy
&nbsp;                    // happened.  We&#39;ll just unstuck the Entity
<b class="nc">&nbsp;                    entity.setStuck(false);</b>
<b class="nc">&nbsp;                    MegaMek.getLogger().info(&quot;Entity #&quot; + entity.getId() + &quot; was stuck in a swamp, but not deployed. Stuck state reset&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            rollTarget = entity.getBasePilotingRoll();</b>
<b class="nc">&nbsp;            entity.addPilotingModifierForTerrain(rollTarget);</b>
&nbsp;            // apart from swamp &amp; liquid magma, -1 modifier
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;            hex.getUnstuckModifier(entity.getElevation(), rollTarget);</b>
&nbsp;            // okay, print the info
<b class="nc">&nbsp;            r = new Report(2340);</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            addReport(r);</b>
&nbsp;
&nbsp;            // roll
<b class="nc">&nbsp;            final int diceRoll = entity.getCrew().rollPilotingSkill();</b>
<b class="nc">&nbsp;            r = new Report(2190);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(rollTarget.getValueAsString());</b>
<b class="nc">&nbsp;            r.add(rollTarget.getDesc());</b>
<b class="nc">&nbsp;            r.add(diceRoll);</b>
<b class="nc">&nbsp;            if (diceRoll &lt; rollTarget.getValue()) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                entity.setStuck(false);</b>
<b class="nc">&nbsp;                entity.setCanUnstickByJumping(false);</b>
<b class="nc">&nbsp;                entity.setElevation(0);</b>
<b class="nc">&nbsp;                entityUpdate(entity.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Remove all iNarc pods from all vehicles that did not move and shoot this
&nbsp;     * round NOTE: this is not quite what the rules say, the player should be
&nbsp;     * able to choose whether or not to remove all iNarc Pods that are attached.
&nbsp;     */
&nbsp;    private void resolveVeeINarcPodRemoval() {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; vees = game.getSelectedEntities(</b>
<b class="nc">&nbsp;                entity -&gt; (entity instanceof Tank) &amp;&amp; (entity.mpUsed == 0));</b>
&nbsp;        boolean canSwipePods;
<b class="nc">&nbsp;        while (vees.hasNext()) {</b>
<b class="nc">&nbsp;            canSwipePods = true;</b>
<b class="nc">&nbsp;            Entity entity = vees.next();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt;= 5; i++) {</b>
<b class="nc">&nbsp;                if (entity.weaponFiredFrom(i)) {</b>
<b class="nc">&nbsp;                    canSwipePods = false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (((Tank) entity).getStunnedTurns() &gt; 0) {</b>
<b class="nc">&nbsp;                canSwipePods = false;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (canSwipePods &amp;&amp; entity.hasINarcPodsAttached()</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getCrew().isActive()) {</b>
<b class="nc">&nbsp;                entity.removeAllINarcPods();</b>
<b class="nc">&nbsp;                Report r = new Report(2345);</b>
<b class="nc">&nbsp;                r.addDesc(entity);</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * //See note above where knownDeadEntities variable is declared private
&nbsp;     * void deadEntitiesCleanup() { Entity en = null; for(Enumeration k =
&nbsp;     * game.getGraveyardEntities(); k.hasMoreElements(); en = (Entity)
&nbsp;     * k.nextElement()) { if (en != null) { if (!knownDeadEntities.contains(en))
&nbsp;     * { knownDeadEntities.add(en); } } } }
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * remove Ice in the hex that&#39;s at the passed coords, and let entities fall
&nbsp;     * into water below it, if there is water
&nbsp;     *
&nbsp;     * @param c the &lt;code&gt;Coords&lt;/code&gt; of the hex where ice should be removed
&nbsp;     * @return a &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; for the phase report
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolveIceBroken(Coords c) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        hex.removeTerrain(Terrains.ICE);</b>
<b class="nc">&nbsp;        sendChangedHex(c);</b>
&nbsp;        // if there is water below the ice
<b class="nc">&nbsp;        if (hex.terrainLevel(Terrains.WATER) &gt; 0) {</b>
&nbsp;            // drop entities on the surface into the water
<b class="nc">&nbsp;            for (Entity e : game.getEntitiesVector(c)) {</b>
&nbsp;                // If the unit is on the surface, and is no longer allowed in
&nbsp;                // the hex
<b class="nc">&nbsp;                boolean isHoverOrWiGE = (e.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                        || (e.getMovementMode() == EntityMovementMode.WIGE);</b>
<b class="nc">&nbsp;                if ((e.getElevation() == 0)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(hex.containsTerrain(Terrains.BLDG_ELEV, 0))</b>
<b class="nc">&nbsp;                        &amp;&amp; !(isHoverOrWiGE &amp;&amp; (e.getRunMP() &gt;= 0))</b>
<b class="nc">&nbsp;                        &amp;&amp; (e.getMovementMode() != EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                        &amp;&amp; !e.hasUMU()</b>
<b class="nc">&nbsp;                        &amp;&amp; !(e instanceof QuadVee &amp;&amp; e.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)) {</b>
<b class="nc">&nbsp;                    vPhaseReport.addAll(doEntityFallsInto(e, c,</b>
&nbsp;                            new PilotingRollData(TargetRoll.AUTOMATIC_FAIL),
&nbsp;                            true));
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * melt any snow or ice in a hex, including checking for the effects of
&nbsp;     * breaking through ice
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; meltIceAndSnow(Coords c, int entityId) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        r = new Report(3069);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.subject = entityId;</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.SNOW)) {</b>
<b class="nc">&nbsp;            hex.removeTerrain(Terrains.SNOW);</b>
<b class="nc">&nbsp;            sendChangedHex(c);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;            vDesc.addAll(resolveIceBroken(c));</b>
&nbsp;        }
&nbsp;        // if we were not in water, then add mud
<b class="nc">&nbsp;        if (!hex.containsTerrain(Terrains.MUD)</b>
<b class="nc">&nbsp;            &amp;&amp; !hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                    Terrains.MUD, 1));
<b class="nc">&nbsp;            sendChangedHex(c);</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * check to see if a swamp hex becomes quicksand
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; checkQuickSand(Coords c) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        if (hex.terrainLevel(Terrains.SWAMP) == 1) {</b>
<b class="nc">&nbsp;            if (Compute.d6(2) == 12) {</b>
&nbsp;                // better find a rope
<b class="nc">&nbsp;                hex.removeTerrain(Terrains.SWAMP);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SWAMP, 2));</b>
<b class="nc">&nbsp;                sendChangedHex(c);</b>
<b class="nc">&nbsp;                r = new Report(2440);</b>
<b class="nc">&nbsp;                r.indent(1);</b>
<b class="nc">&nbsp;                vDesc.add(r);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * check for vehicle fire, according to the MaxTech rules
&nbsp;     *
&nbsp;     * @param tank    the &lt;code&gt;Tank&lt;/code&gt; to be checked
&nbsp;     * @param inferno a &lt;code&gt;boolean&lt;/code&gt; parameter whether or not this check is
&nbsp;     *                because of inferno fire
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; checkForVehicleFire(Tank tank, boolean inferno) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        int boomRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;        int penalty = 0;</b>
<b class="nc">&nbsp;        switch (tank.getMovementMode()) {</b>
&nbsp;            case HOVER:
<b class="nc">&nbsp;                penalty = 4;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case VTOL:
&nbsp;            case WHEELED:
<b class="nc">&nbsp;                penalty = 2;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        if (inferno) {</b>
<b class="nc">&nbsp;            boomRoll = 12;</b>
&nbsp;        }
<b class="nc">&nbsp;        Report r = new Report(5250);</b>
<b class="nc">&nbsp;        r.subject = tank.getId();</b>
<b class="nc">&nbsp;        r.addDesc(tank);</b>
<b class="nc">&nbsp;        r.add(8 - penalty);</b>
<b class="nc">&nbsp;        r.add(boomRoll);</b>
<b class="nc">&nbsp;        if ((boomRoll + penalty) &lt; 8) {</b>
&nbsp;            // phew!
<b class="nc">&nbsp;            r.choose(true);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;        } else {
&nbsp;            // eek
<b class="nc">&nbsp;            if (!inferno) {</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((boomRoll + penalty) &lt; 10) {</b>
<b class="nc">&nbsp;                addReport(vehicleMotiveDamage(tank, penalty - 1));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                vPhaseReport.addAll(resolveVehicleFire(tank, false));</b>
<b class="nc">&nbsp;                if ((boomRoll + penalty) &gt;= 12) {</b>
<b class="nc">&nbsp;                    r = new Report(5255);</b>
<b class="nc">&nbsp;                    r.subject = tank.getId();</b>
<b class="nc">&nbsp;                    r.indent(3);</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    tank.setOnFire(inferno);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; resolveVehicleFire(Tank tank, boolean existingStatus) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        if (existingStatus &amp;&amp; !tank.isOnFire()) {</b>
<b class="nc">&nbsp;            return vPhaseReport;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; tank.locations(); i++) {</b>
<b class="nc">&nbsp;            if ((i == Tank.LOC_BODY) || ((tank instanceof VTOL) &amp;&amp; (i == VTOL.LOC_ROTOR))) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (existingStatus &amp;&amp; !tank.isLocationBurning(i)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            HitData hit = new HitData(i);</b>
<b class="nc">&nbsp;            int damage = Compute.d6(1);</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(damageEntity(tank, hit, damage));</b>
<b class="nc">&nbsp;            if ((damage == 1) &amp;&amp; existingStatus) {</b>
<b class="nc">&nbsp;                tank.extinguishLocation(i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Report&gt; vehicleMotiveDamage(Tank te, int modifier) {
<b class="nc">&nbsp;        return vehicleMotiveDamage(te, modifier, false, -1, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Report&gt; vehicleMotiveDamage(Tank te, int modifier, boolean noRoll,
&nbsp;                                               int damageType) {
<b class="nc">&nbsp;        return vehicleMotiveDamage(te, modifier, noRoll, damageType, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * do vehicle movement damage
&nbsp;     *
&nbsp;     * @param te         the Tank to damage
&nbsp;     * @param modifier   the modifier to the roll
&nbsp;     * @param noRoll     don&#39;t roll, immediately deal damage
&nbsp;     * @param damageType the type to deal (1 = minor, 2 = moderate, 3 = heavy
&nbsp;     * @param jumpDamage is this a movement damage roll from using vehicular JJs
&nbsp;     * @return a &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing what to add to the turn log
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; vehicleMotiveDamage(Tank te, int modifier, boolean noRoll,
&nbsp;                                               int damageType, boolean jumpDamage) {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vDesc = new Vector&lt;&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        switch (te.getMovementMode()) {</b>
&nbsp;            case HOVER:
&nbsp;            case HYDROFOIL:
<b class="nc">&nbsp;                if (jumpDamage) {</b>
<b class="nc">&nbsp;                    modifier -= 1;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    modifier += 3;</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WHEELED:
<b class="nc">&nbsp;                if (jumpDamage) {</b>
<b class="nc">&nbsp;                    modifier += 1;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    modifier += 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WIGE:
<b class="nc">&nbsp;                if (jumpDamage) {</b>
<b class="nc">&nbsp;                    modifier -= 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    modifier += 4;</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case TRACKED:
<b class="nc">&nbsp;                if (jumpDamage) {</b>
<b class="nc">&nbsp;                    modifier += 2;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case VTOL:
&nbsp;                // VTOL don&#39;t roll, auto -1 MP as long as the rotor location
&nbsp;                // still exists (otherwise don&#39;t bother reporting).
<b class="nc">&nbsp;                if (!(te.isLocationBad(VTOL.LOC_ROTOR) || te.isLocationDoomed(VTOL.LOC_ROTOR))) {</b>
<b class="nc">&nbsp;                    te.setMotiveDamage(te.getMotiveDamage() + 1);</b>
<b class="nc">&nbsp;                    if (te.getOriginalWalkMP() &gt; te.getMotiveDamage()) {</b>
<b class="nc">&nbsp;                        r = new Report(6660);</b>
<b class="nc">&nbsp;                        r.indent(3);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(6670);</b>
<b class="nc">&nbsp;                        r.subject = te.getId();</b>
<b class="nc">&nbsp;                        vDesc.add(r);</b>
<b class="nc">&nbsp;                        te.immobilize();</b>
&nbsp;                        // Being reduced to 0 MP by rotor damage forces a
&nbsp;                        // landing
&nbsp;                        // like an engine hit...
<b class="nc">&nbsp;                        if (te.isAirborneVTOLorWIGE()</b>
&nbsp;                            // ...but don&#39;t bother to resolve that if we&#39;re
&nbsp;                            // already otherwise destroyed.
<b class="nc">&nbsp;                            &amp;&amp; !(te.isDestroyed() || te.isDoomed())) {</b>
<b class="nc">&nbsp;                            vDesc.addAll(forceLandVTOLorWiGE(te));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                // This completes our handling of VTOLs; the rest of the method
&nbsp;                // doesn&#39;t need to worry about them anymore.
<b class="nc">&nbsp;                return vDesc;</b>
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
&nbsp;        // Apply vehicle effectiveness...except for jumps.
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_VEHICLE_EFFECTIVE)</b>
&nbsp;                &amp;&amp; !jumpDamage) {
<b class="nc">&nbsp;            modifier = Math.max(modifier - 1, 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (te.hasWorkingMisc(MiscType.F_ARMORED_MOTIVE_SYSTEM)) {</b>
<b class="nc">&nbsp;            modifier -= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        int roll = Compute.d6(2) + modifier;</b>
<b class="nc">&nbsp;        r = new Report(6306);</b>
<b class="nc">&nbsp;        r.subject = te.getId();</b>
<b class="nc">&nbsp;        r.newlines = 0;</b>
<b class="nc">&nbsp;        r.indent(3);</b>
<b class="nc">&nbsp;        vDesc.add(r);</b>
<b class="nc">&nbsp;        if (!noRoll) {</b>
<b class="nc">&nbsp;            r = new Report(6310);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            r = new Report(3340);</b>
<b class="nc">&nbsp;            r.add(modifier);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((noRoll &amp;&amp; (damageType == 0)) || (!noRoll &amp;&amp; (roll &lt;= 5))) {</b>
&nbsp;            // no effect
<b class="nc">&nbsp;            r = new Report(6005);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;        } else if ((noRoll &amp;&amp; (damageType == 1)) || (!noRoll &amp;&amp; (roll &lt;= 7))) {</b>
&nbsp;            // minor damage
<b class="nc">&nbsp;            r = new Report(6470);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            te.addMovementDamage(1);</b>
<b class="nc">&nbsp;        } else if ((noRoll &amp;&amp; (damageType == 2)) || (!noRoll &amp;&amp; (roll &lt;= 9))) {</b>
&nbsp;            // moderate damage
<b class="nc">&nbsp;            r = new Report(6471);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            te.addMovementDamage(2);</b>
<b class="nc">&nbsp;        } else if ((noRoll &amp;&amp; (damageType == 3)) || (!noRoll &amp;&amp; (roll &lt;= 11))) {</b>
&nbsp;            // heavy damage
<b class="nc">&nbsp;            r = new Report(6472);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            te.addMovementDamage(3);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(6473);</b>
<b class="nc">&nbsp;            r.subject = te.getId();</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            vDesc.add(r);</b>
<b class="nc">&nbsp;            te.addMovementDamage(4);</b>
&nbsp;        }
&nbsp;        // These checks should perhaps be moved to Tank.applyDamage(), but I&#39;m
&nbsp;        // unsure how to *report* any outcomes from there. Note that these treat
&nbsp;        // being reduced to 0 MP and being actually immobilized as the same thing,
&nbsp;        // which for these particular purposes may or may not be the intent of
&nbsp;        // the rules in all cases.
&nbsp;        // Immobile hovercraft on water sink...
<b class="nc">&nbsp;        if (((te.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                || ((te.getMovementMode() == EntityMovementMode.WIGE) &amp;&amp; (te.getElevation() == 0)))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isMovementHitPending() || (te.getWalkMP() &lt;= 0))</b>
&nbsp;                // HACK: Have to check for *pending* hit here and below.
<b class="nc">&nbsp;                &amp;&amp; (game.getBoard().getHex(te.getPosition()).terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; !game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;            vDesc.addAll(destroyEntity(te, &quot;a watery grave&quot;, false));</b>
&nbsp;        }
&nbsp;        // ...while immobile WiGEs crash.
<b class="nc">&nbsp;        if (((te.getMovementMode() == EntityMovementMode.WIGE) &amp;&amp; (te.isAirborneVTOLorWIGE()))</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isMovementHitPending() || (te.getWalkMP() &lt;= 0))) {</b>
&nbsp;            // report problem: add tab
<b class="nc">&nbsp;            vDesc.addAll(crashVTOLorWiGE(te));</b>
&nbsp;        }
<b class="nc">&nbsp;        return vDesc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a whole lotta Reports to the players report queues as well as the
&nbsp;     * Master report queue vPhaseReport.
&nbsp;     */
&nbsp;    private void addReport(Vector&lt;Report&gt; reports) {
<b class="nc">&nbsp;        vPhaseReport.addAll(reports);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add a whole lotta Reports to the players report queues as well as the
&nbsp;     * Master report queue vPhaseReport, indenting each report by the passed
&nbsp;     * value.
&nbsp;     */
&nbsp;    private void addReport(Vector&lt;Report&gt; reports, int indents) {
<b class="nc">&nbsp;        for (Report r : reports) {</b>
<b class="nc">&nbsp;            r.indent(indents);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add a single report to the report queue of all players and the master
&nbsp;     * vPhaseReport queue
&nbsp;     */
&nbsp;    private void addReport(Report report) {
<b class="nc">&nbsp;        vPhaseReport.addElement(report);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * New Round has started clear everyone&#39;s report queue
&nbsp;     */
&nbsp;    private void clearReports() {
<b class="nc">&nbsp;        vPhaseReport.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * make sure all the new lines that were added to the old vPhaseReport get
&nbsp;     * added to all of the players filters
&nbsp;     */
&nbsp;    private void addNewLines() {
<b class="nc">&nbsp;        Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * resolve the landing of an assault drop
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; for which to resolve it
&nbsp;     */
&nbsp;    public void doAssaultDrop(Entity entity) {
&nbsp;        //resolve according to SO p.22
&nbsp;
<b class="nc">&nbsp;        Report r = new Report(2380);</b>
&nbsp;
&nbsp;        // whatever else happens, this entity is on the ground now
<b class="nc">&nbsp;        entity.setAltitude(0);</b>
&nbsp;
&nbsp;        PilotingRollData psr;
&nbsp;        // LAMs that convert to fighter mode on the landing turn are processed as crashes
<b class="nc">&nbsp;        if ((entity instanceof LandAirMech)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getConversionMode() == LandAirMech.CONV_MODE_FIGHTER)) {</b>
<b class="nc">&nbsp;            addReport(processCrash(entity, 0, entity.getPosition()));</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((entity instanceof Protomech) || (entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            psr = new PilotingRollData(entity.getId(), 5, &quot;landing assault drop&quot;);</b>
<b class="nc">&nbsp;        } else if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            psr = new PilotingRollData(entity.getId(), 4, &quot;landing assault drop&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            psr = entity.getBasePilotingRoll();</b>
&nbsp;        }
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
&nbsp;        // check for a safe landing
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;        r.subject = entity.getId();</b>
<b class="nc">&nbsp;        r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;        r.add(psr.getValueAsString());</b>
<b class="nc">&nbsp;        r.add(roll);</b>
<b class="nc">&nbsp;        r.newlines = 1;</b>
<b class="nc">&nbsp;        r.choose(roll &gt;= psr.getValue());</b>
<b class="nc">&nbsp;        addReport(r);</b>
&nbsp;
&nbsp;        // if we are on an atmospheric map or the entity is off the map for some reason
<b class="nc">&nbsp;        if (game.getBoard().inAtmosphere() || entity.getPosition() == null) {</b>
&nbsp;            // then just remove the entity
&nbsp;            // TODO : for this and when the unit scatters off the board, we should really still
&nbsp;            // TODO : apply damage before we remove, but this causes all kinds of problems for
&nbsp;            // TODO : doEntityFallsInto and related methods which expect a coord on the board
&nbsp;            // TODO : - need to make those more robust
<b class="nc">&nbsp;            r = new Report(2388);</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(entity.getDisplayName(), true);</b>
<b class="nc">&nbsp;            game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (roll &lt; psr.getValue()) {</b>
<b class="nc">&nbsp;            int fallHeight = psr.getValue() - roll;</b>
&nbsp;
&nbsp;            // if you fail by more than 7, you automatically fail
<b class="nc">&nbsp;            if (fallHeight &gt; 7) {</b>
<b class="nc">&nbsp;                addReport(destroyEntity(entity, &quot;failed assault drop&quot;, false, false));</b>
<b class="nc">&nbsp;                entityUpdate(entity.getId());</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // determine where we really land
<b class="nc">&nbsp;            Coords c = Compute.scatterAssaultDrop(entity.getPosition(), fallHeight);</b>
<b class="nc">&nbsp;            int distance = entity.getPosition().distance(c);</b>
<b class="nc">&nbsp;            r = new Report(2385);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.add(distance);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            if (!game.getBoard().contains(c)) {</b>
<b class="nc">&nbsp;                r = new Report(2386);</b>
<b class="nc">&nbsp;                addReport(r);</b>
<b class="nc">&nbsp;                game.removeEntity(entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(2387);</b>
<b class="nc">&nbsp;                r.add(c.getBoardNum());</b>
<b class="nc">&nbsp;                addReport(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            entity.setPosition(c);</b>
&nbsp;
&nbsp;            // do fall damage from accidental fall
&nbsp;            //set elevation to fall height above ground or building roof
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;            int bldgElev = hex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                    ? hex.terrainLevel(Terrains.BLDG_ELEV) : 0;</b>
<b class="nc">&nbsp;            entity.setElevation(fallHeight + bldgElev);</b>
<b class="nc">&nbsp;            if ((entity instanceof Infantry) &amp;&amp; !(entity instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                HitData hit = new HitData(Infantry.LOC_INFANTRY);</b>
<b class="nc">&nbsp;                addReport(damageEntity(entity, hit, 1));</b>
&nbsp;                // LAMs that convert to fighter mode on the landing turn are processed as crashes regardless of roll
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                addReport(doEntityFallsInto(entity, c, psr, true));</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // set entity to expected elevation
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(entity.getPosition());</b>
<b class="nc">&nbsp;            int bldgElev = hex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                    ? hex.terrainLevel(Terrains.BLDG_ELEV) : 0;</b>
<b class="nc">&nbsp;            entity.setElevation(bldgElev);</b>
&nbsp;
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(entity.getPosition());</b>
<b class="nc">&nbsp;            if (bldg != null) {</b>
&nbsp;                // whoops we step on the roof
<b class="nc">&nbsp;                checkBuildingCollapseWhileMoving(bldg, entity, entity.getPosition());</b>
&nbsp;            }
&nbsp;
&nbsp;            // finally, check for any stacking violations
<b class="nc">&nbsp;            Entity violated = Compute.stackingViolation(game, entity, entity.getPosition(), null);</b>
<b class="nc">&nbsp;            if (violated != null) {</b>
&nbsp;                // StratOps explicitly says that this is not treated as an accident
&nbsp;                // fall from above
&nbsp;                // so we just need to displace the violating unit
&nbsp;                // check to see if the violating unit is a DropShip and if so, then
&nbsp;                // displace the unit dropping instead
<b class="nc">&nbsp;                if (violated instanceof Dropship) {</b>
<b class="nc">&nbsp;                    violated = entity;</b>
&nbsp;                }
<b class="nc">&nbsp;                Coords targetDest = Compute.getValidDisplacement(game, violated.getId(),</b>
<b class="nc">&nbsp;                        violated.getPosition(), Compute.d6() - 1);</b>
<b class="nc">&nbsp;                if (null != targetDest) {</b>
<b class="nc">&nbsp;                    doEntityDisplacement(violated, violated.getPosition(), targetDest, null);</b>
<b class="nc">&nbsp;                    entityUpdate(violated.getId());</b>
&nbsp;                } else {
&nbsp;                    // ack! automatic death! Tanks
&nbsp;                    // suffer an ammo/power plant hit.
&nbsp;                    // TODO : a Mech suffers a Head Blown Off crit.
<b class="nc">&nbsp;                    vPhaseReport.addAll(destroyEntity(entity, &quot;impossible displacement&quot;,</b>
&nbsp;                            entity instanceof Mech, entity instanceof Mech));
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * resolve assault drops for all entities
&nbsp;     */
&nbsp;    void doAllAssaultDrops() {
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.isAssaultDropInProgress()) {</b>
<b class="nc">&nbsp;                doAssaultDrop(e);</b>
<b class="nc">&nbsp;                e.setLandedAssaultDrop();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * do damage from magma
&nbsp;     *
&nbsp;     * @param en       the affected &lt;code&gt;Entity&lt;/code&gt;
&nbsp;     * @param eruption &lt;code&gt;boolean&lt;/code&gt; indicating whether or not this is because
&nbsp;     *                 of an eruption
&nbsp;     */
&nbsp;    void doMagmaDamage(Entity en, boolean eruption) {
<b class="nc">&nbsp;        if ((((en.getMovementMode() == EntityMovementMode.VTOL) &amp;&amp; (en.getElevation() &gt; 0))</b>
<b class="nc">&nbsp;                || (en.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                || ((en.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (en.getOriginalWalkMP() &gt; 0) &amp;&amp; !eruption)) &amp;&amp; !en.isImmobile()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        Report r;
<b class="nc">&nbsp;        boolean isMech = en instanceof Mech;</b>
<b class="nc">&nbsp;        if (isMech) {</b>
<b class="nc">&nbsp;            r = new Report(2405);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(2400);</b>
&nbsp;        }
<b class="nc">&nbsp;        r.addDesc(en);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        if (isMech) {</b>
&nbsp;            HitData h;
<b class="nc">&nbsp;            for (int i = 0; i &lt; en.locations(); i++) {</b>
<b class="nc">&nbsp;                if (eruption || en.locationIsLeg(i) || en.isProne()) {</b>
<b class="nc">&nbsp;                    h = new HitData(i);</b>
<b class="nc">&nbsp;                    addReport(damageEntity(en, h, Compute.d6(2)));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            addReport(destroyEntity(en, &quot;fell into magma&quot;, false, false));</b>
&nbsp;        }
<b class="nc">&nbsp;        addNewLines();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * sink any entities in quicksand in the current hex
&nbsp;     */
&nbsp;    public void doSinkEntity(Entity en) {
&nbsp;        Report r;
<b class="nc">&nbsp;        r = new Report(2445);</b>
<b class="nc">&nbsp;        r.addDesc(en);</b>
<b class="nc">&nbsp;        r.subject = en.getId();</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;        en.setElevation(en.getElevation() - 1);</b>
&nbsp;        // if this means the entity is below the ground, then bye-bye!
<b class="nc">&nbsp;        if (Math.abs(en.getElevation()) &gt; en.getHeight()) {</b>
<b class="nc">&nbsp;            addReport(destroyEntity(en, &quot;quicksand&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deal area saturation damage to an individual hex
&nbsp;     *
&nbsp;     * @param coords         The hex being hit
&nbsp;     * @param attackSource   The location the attack came from. For hit table resolution
&nbsp;     * @param damage         Amount of damage to deal to each entity
&nbsp;     * @param ammo           The ammo type being used
&nbsp;     * @param subjectId      Subject for reports
&nbsp;     * @param killer         Who should be credited with kills
&nbsp;     * @param exclude        Entity that should take no damage (used for homing splash)
&nbsp;     * @param flak           Flak, hits flying units only, instead of flyers being immune
&nbsp;     * @param altitude       Absolute altitude for flak attack
&nbsp;     * @param vPhaseReport   The Vector of Reports for the phase report
&nbsp;     * @param asfFlak        Is this flak against ASF?
&nbsp;     * @param alreadyHit     a vector of unit ids for units that have already been hit that
&nbsp;     *                       will be ignored
&nbsp;     * @param variableDamage if true, treat damage as the number of six-sided dice to roll
&nbsp;     */
&nbsp;    public Vector&lt;Integer&gt; artilleryDamageHex(Coords coords,
&nbsp;            Coords attackSource, int damage, AmmoType ammo, int subjectId,
&nbsp;            Entity killer, Entity exclude, boolean flak, int altitude,
&nbsp;            Vector&lt;Report&gt; vPhaseReport, boolean asfFlak,
&nbsp;            Vector&lt;Integer&gt; alreadyHit, boolean variableDamage) {
&nbsp;
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            return alreadyHit; // not on board.</b>
&nbsp;        }
&nbsp;
&nbsp;        Report r;
&nbsp;
&nbsp;        // Non-flak artillery damages terrain
<b class="nc">&nbsp;        if (!flak) {</b>
&nbsp;            // Report that damage applied to terrain, if there&#39;s TF to damage
<b class="nc">&nbsp;            IHex h = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;            if ((h != null) &amp;&amp; h.hasTerrainfactor()) {</b>
<b class="nc">&nbsp;                r = new Report(3384);</b>
<b class="nc">&nbsp;                r.indent(2);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;                r.add(damage * 2);</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            }
&nbsp;            // Update hex and report any changes
<b class="nc">&nbsp;            Vector&lt;Report&gt; newReports = tryClearHex(coords, damage * 2, subjectId);</b>
<b class="nc">&nbsp;            for (Report nr : newReports) {</b>
<b class="nc">&nbsp;                nr.indent(3);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(newReports);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        boolean isFuelAirBomb = </b>
&nbsp;                ammo != null &amp;&amp;
<b class="nc">&nbsp;                (BombType.getBombTypeFromInternalName(ammo.getInternalName()) == BombType.B_FAE_SMALL ||</b>
<b class="nc">&nbsp;                BombType.getBombTypeFromInternalName(ammo.getInternalName()) == BombType.B_FAE_LARGE);</b>
&nbsp;        
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(coords);</b>
<b class="nc">&nbsp;        int bldgAbsorbs = 0;</b>
<b class="nc">&nbsp;        if ((bldg != null)</b>
<b class="nc">&nbsp;                &amp;&amp; !(flak &amp;&amp; (((altitude &gt; hex.terrainLevel(Terrains.BLDG_ELEV))</b>
<b class="nc">&nbsp;                || (altitude &gt; hex.terrainLevel(Terrains.BRIDGE_ELEV)))))) {</b>
<b class="nc">&nbsp;            bldgAbsorbs = bldg.getAbsorbtion(coords);</b>
<b class="nc">&nbsp;            if (!((ammo != null) &amp;&amp; (ammo.getMunitionType() == AmmoType.M_FLECHETTE))) {</b>
<b class="nc">&nbsp;                int actualDamage = damage;</b>
&nbsp;                
<b class="nc">&nbsp;                if(isFuelAirBomb) {</b>
&nbsp;                    // light buildings take 1.5x damage from fuel-air bombs
<b class="nc">&nbsp;                    if(bldg.getType() == Building.LIGHT) {</b>
<b class="nc">&nbsp;                        actualDamage = (int) Math.ceil(actualDamage * 1.5);</b>
&nbsp;                        
<b class="nc">&nbsp;                        r = new Report(9991);</b>
<b class="nc">&nbsp;                        r.indent(1);</b>
<b class="nc">&nbsp;                        r.subject = killer.getId();</b>
<b class="nc">&nbsp;                        r.newlines = 1;</b>
<b class="nc">&nbsp;                        vPhaseReport.addElement(r);</b>
&nbsp;                    } 
&nbsp;
&nbsp;                    // armored and &quot;castle brian&quot; buildings take .5 damage from fuel-air bombs
&nbsp;                    // but I have no idea how to determine if a building is a castle or a brian
&nbsp;                    // note that being armored and being &quot;light&quot; are not mutually exclusive
<b class="nc">&nbsp;                    if(bldg.getArmor(coords) &gt; 0) {</b>
<b class="nc">&nbsp;                        actualDamage = (int) Math.floor(actualDamage * .5);</b>
&nbsp;                        
<b class="nc">&nbsp;                        r = new Report(9992);</b>
<b class="nc">&nbsp;                        r.indent(1);</b>
<b class="nc">&nbsp;                        r.subject = killer.getId();</b>
<b class="nc">&nbsp;                        r.newlines = 1;</b>
<b class="nc">&nbsp;                        vPhaseReport.addElement(r);</b>
&nbsp;                    }
&nbsp;                }             
&nbsp;                
&nbsp;                
&nbsp;                // damage the building
<b class="nc">&nbsp;                Vector&lt;Report&gt; buildingReport = damageBuilding(bldg, actualDamage, coords);</b>
<b class="nc">&nbsp;                for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                    report.subject = subjectId;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(buildingReport);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (flak &amp;&amp; ((altitude &lt;= 0)</b>
<b class="nc">&nbsp;                || (altitude &lt;= hex.terrainLevel(Terrains.BLDG_ELEV))</b>
<b class="nc">&nbsp;                || (altitude == hex.terrainLevel(Terrains.BRIDGE_ELEV)))) {</b>
&nbsp;            // Flak in this hex would only hit landed units
<b class="nc">&nbsp;            return alreadyHit;</b>
&nbsp;        }
&nbsp;
&nbsp;        // get units in hex
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector(coords)) {  </b>
&nbsp;            // Check: is entity excluded?
<b class="nc">&nbsp;            if ((entity == exclude) || alreadyHit.contains(entity.getId())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                alreadyHit.add(entity.getId());</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            AreaEffectHelper.artilleryDamageEntity(entity, damage, bldg, bldgAbsorbs, </b>
&nbsp;                    variableDamage, asfFlak, flak, altitude,
&nbsp;                    attackSource, ammo, coords, isFuelAirBomb,
&nbsp;                    killer, hex, subjectId, vPhaseReport, this);
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return alreadyHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * deal area saturation damage to the map, used for artillery
&nbsp;     *
&nbsp;     * @param centre       The hex on which damage is centred
&nbsp;     * @param attackSource The position the attack came from
&nbsp;     * @param ammo         The ammo type doing the damage
&nbsp;     * @param subjectId    Subject for reports
&nbsp;     * @param killer       Who should be credited with kills
&nbsp;     * @param flak         Flak, hits flying units only, instead of flyers being immune
&nbsp;     * @param altitude     Absolute altitude for flak attack
&nbsp;     * @param mineClear    Does this clear mines?
&nbsp;     * @param vPhaseReport The Vector of Reports for the phase report
&nbsp;     * @param asfFlak      Is this flak against ASF?
&nbsp;     * @param attackingBA  How many BA suits are in the squad if this is a BA Tube arty
&nbsp;     *                     attack, -1 otherwise
&nbsp;     */
&nbsp;    public void artilleryDamageArea(Coords centre, Coords attackSource,
&nbsp;            AmmoType ammo, int subjectId, Entity killer, boolean flak,
&nbsp;            int altitude, boolean mineClear, Vector&lt;Report&gt; vPhaseReport,
&nbsp;            boolean asfFlak, int attackingBA) {
<b class="nc">&nbsp;        DamageFalloff damageFalloff = AreaEffectHelper.calculateDamageFallOff(ammo, attackingBA, mineClear);</b>
&nbsp;        
<b class="nc">&nbsp;        int damage = damageFalloff.damage;</b>
<b class="nc">&nbsp;        int falloff = damageFalloff.falloff;</b>
<b class="nc">&nbsp;        if(damageFalloff.clusterMunitionsFlag) {</b>
<b class="nc">&nbsp;            attackSource = centre;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        artilleryDamageArea(centre, attackSource, ammo, subjectId, killer,</b>
&nbsp;                damage, falloff, flak, altitude, vPhaseReport, asfFlak);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Deals area-saturation damage to an area of the board. Used for artillery,
&nbsp;     * bombs, or anything else with linear decrease in damage
&nbsp;     *
&nbsp;     * @param centre
&nbsp;     *            The hex on which damage is centred
&nbsp;     * @param attackSource
&nbsp;     *            The position the attack came from
&nbsp;     * @param ammo
&nbsp;     *            The ammo type doing the damage
&nbsp;     * @param subjectId
&nbsp;     *            Subject for reports
&nbsp;     * @param killer
&nbsp;     *            Who should be credited with kills
&nbsp;     * @param damage
&nbsp;     *            Damage at ground zero
&nbsp;     * @param falloff
&nbsp;     *            Reduction in damage for each hex of distance
&nbsp;     * @param flak
&nbsp;     *            Flak, hits flying units only, instead of flyers being immune
&nbsp;     * @param altitude
&nbsp;     *            Absolute altitude for flak attack
&nbsp;     * @param vPhaseReport
&nbsp;     *            The Vector of Reports for the phase report
&nbsp;     * @param asfFlak
&nbsp;     *            Is this flak against ASF?
&nbsp;     */
&nbsp;    public void artilleryDamageArea(Coords centre, Coords attackSource, AmmoType ammo, int subjectId,
&nbsp;                                    Entity killer, int damage, int falloff, boolean flak, int altitude,
&nbsp;                                    Vector&lt;Report&gt; vPhaseReport, boolean asfFlak) {
<b class="nc">&nbsp;        Vector&lt;Integer&gt; alreadyHit = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int ring = 0; damage &gt; 0; ring++, damage -= falloff) {</b>
<b class="nc">&nbsp;            List&lt;Coords&gt; hexes = centre.allAtDistance(ring);</b>
<b class="nc">&nbsp;            for (Coords c : hexes) {</b>
<b class="nc">&nbsp;                alreadyHit = artilleryDamageHex(c, attackSource, damage, ammo,</b>
&nbsp;                        subjectId, killer, null, flak, altitude, vPhaseReport,
&nbsp;                        asfFlak, alreadyHit, false);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            attackSource = centre; // all splash comes from ground zero</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void deliverBombDamage(Coords centre, int type, int subjectId, Entity killer,
&nbsp;                                  Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        int range = 0;</b>
<b class="nc">&nbsp;        int damage = 10;</b>
<b class="nc">&nbsp;        if (type == BombType.B_CLUSTER) {</b>
<b class="nc">&nbsp;            range = 1;</b>
<b class="nc">&nbsp;            damage = 5;</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Integer&gt; alreadyHit = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        alreadyHit = artilleryDamageHex(centre, centre, damage, null,</b>
&nbsp;                subjectId, killer, null, false, 0, vPhaseReport, false,
&nbsp;                alreadyHit, false);
<b class="nc">&nbsp;        if (range &gt; 0) {</b>
<b class="nc">&nbsp;            List&lt;Coords&gt; hexes = centre.allAtDistance(range);</b>
<b class="nc">&nbsp;            for (Coords c : hexes) {</b>
<b class="nc">&nbsp;                alreadyHit = artilleryDamageHex(c, centre, damage, null,</b>
&nbsp;                        subjectId, killer, null, false, 0, vPhaseReport, false,
&nbsp;                        alreadyHit, false);
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * deliver inferno bomb
&nbsp;     *
&nbsp;     * @param coords    the &lt;code&gt;Coords&lt;/code&gt; where to deliver
&nbsp;     * @param ae        the attacking &lt;code&gt;entity&lt;code&gt;
&nbsp;     * @param subjectId the &lt;code&gt;int&lt;/code&gt; id of the target
&nbsp;     */
&nbsp;    public void deliverBombInferno(Coords coords, Entity ae, int subjectId,
&nbsp;                                   Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        IHex h = game.getBoard().getHex(coords);</b>
&nbsp;        Report r;
&nbsp;        // Unless there is a fire in the hex already, start one.
<b class="nc">&nbsp;        if (h.terrainLevel(Terrains.FIRE) &lt; Terrains.FIRE_LVL_INFERNO_BOMB) {</b>
<b class="nc">&nbsp;            ignite(coords, Terrains.FIRE_LVL_INFERNO_BOMB, vPhaseReport);</b>
&nbsp;        }
&nbsp;        // possibly melt ice and snow
<b class="nc">&nbsp;        if (h.containsTerrain(Terrains.ICE) || h.containsTerrain(Terrains.SNOW)) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(meltIceAndSnow(coords, subjectId));</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity entity : game.getEntitiesVector(coords)) {</b>
<b class="nc">&nbsp;            if (entity.isAirborne() || entity.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // TacOps, p. 359 - treat as if hit by 5 inferno missiles
<b class="nc">&nbsp;            r = new Report(6696);</b>
<b class="nc">&nbsp;            r.indent(3);</b>
<b class="nc">&nbsp;            r.add(entity.getDisplayName());</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                Report.addNewline(vPhaseReport);</b>
&nbsp;            }
<b class="nc">&nbsp;            Vector&lt;Report&gt; vDamageReport = deliverInfernoMissiles(ae, entity, 5);</b>
<b class="nc">&nbsp;            Report.indentAll(vDamageReport, 2);</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(vDamageReport);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolve any Infantry units which are fortifying hexes
&nbsp;     */
&nbsp;    void resolveFortify() {
&nbsp;        Report r;
<b class="nc">&nbsp;        for (Entity ent : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (ent instanceof Infantry) {</b>
<b class="nc">&nbsp;                Infantry inf = (Infantry) ent;</b>
<b class="nc">&nbsp;                int dig = inf.getDugIn();</b>
<b class="nc">&nbsp;                if (dig == Infantry.DUG_IN_WORKING) {</b>
<b class="nc">&nbsp;                    r = new Report(5300);</b>
<b class="nc">&nbsp;                    r.addDesc(inf);</b>
<b class="nc">&nbsp;                    r.subject = inf.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
<b class="nc">&nbsp;                } else if (dig == Infantry.DUG_IN_FORTIFYING2) {</b>
<b class="nc">&nbsp;                    Coords c = inf.getPosition();</b>
<b class="nc">&nbsp;                    r = new Report(5305);</b>
<b class="nc">&nbsp;                    r.addDesc(inf);</b>
<b class="nc">&nbsp;                    r.add(c.getBoardNum());</b>
<b class="nc">&nbsp;                    r.subject = inf.getId();</b>
<b class="nc">&nbsp;                    addReport(r);</b>
&nbsp;                    // fortification complete - add to map
<b class="nc">&nbsp;                    IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;                    hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                            Terrains.FORTIFIED, 1));
<b class="nc">&nbsp;                    sendChangedHex(c);</b>
&nbsp;                    // Clear the dig in for any units in same hex, since they
&nbsp;                    // get it for free by fort
<b class="nc">&nbsp;                    for (Entity ent2 : game.getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                        if (ent2 instanceof Infantry) {</b>
<b class="nc">&nbsp;                            Infantry inf2 = (Infantry) ent;</b>
<b class="nc">&nbsp;                            inf2.setDugIn(Infantry.DUG_IN_NONE);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check if spikes get broken in the given location
&nbsp;     *
&nbsp;     * @param e   The {@link Entity} to check
&nbsp;     * @param loc The location index
&nbsp;     * @return    A report showing the results of the roll
&nbsp;     */
&nbsp;    private Report checkBreakSpikes(Entity e, int loc) {
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (roll &lt; 9) {</b>
<b class="nc">&nbsp;            r = new Report(4445);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.subject = e.getId();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r = new Report(4440);</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            r.subject = e.getId();</b>
<b class="nc">&nbsp;            for (Mounted m : e.getMisc()) {</b>
<b class="nc">&nbsp;                if (m.getType().hasFlag(MiscType.F_SPIKES)</b>
<b class="nc">&nbsp;                        &amp;&amp; (m.getLocation() == loc)) {</b>
<b class="nc">&nbsp;                    m.setHit(true);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return a &lt;code&gt;String&lt;/code&gt; representing the hostname
&nbsp;     */
&nbsp;    public String getHost() {
&nbsp;        try {
<b class="nc">&nbsp;            return InetAddress.getLocalHost().getHostName();</b>
<b class="nc">&nbsp;        } catch (UnknownHostException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; this server is listening on
&nbsp;     */
&nbsp;    public int getPort() {
<b class="nc">&nbsp;        return serverSocket.getLocalPort();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loops through all the attacks the game has. Checks if they care about
&nbsp;     * current phase, if so, runs them, and removes them if they don&#39;t want to
&nbsp;     * stay. TODO : Refactor the new entity announcement out of here.
&nbsp;     */
&nbsp;    private void handleAttacks() {
<b class="nc">&nbsp;        handleAttacks(false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void handleAttacks(boolean pointblankShot) {
&nbsp;        Report r;
<b class="nc">&nbsp;        int lastAttackerId = -1;</b>
&nbsp;        Vector&lt;AttackHandler&gt; currentAttacks, keptAttacks;
<b class="nc">&nbsp;        currentAttacks = game.getAttacksVector();</b>
<b class="nc">&nbsp;        keptAttacks = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; handleAttackReports = new Vector&lt;&gt;();</b>
&nbsp;        // first, do any TAGs, so homing arty will have TAG
<b class="nc">&nbsp;        for (AttackHandler ah : currentAttacks) {</b>
<b class="nc">&nbsp;            if (!(ah instanceof TAGHandler)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ah.cares(game.getPhase())) {</b>
<b class="nc">&nbsp;                int aId = ah.getAttackerId();</b>
<b class="nc">&nbsp;                if ((aId != lastAttackerId) &amp;&amp; !ah.announcedEntityFiring()) {</b>
&nbsp;                    // report who is firing
<b class="nc">&nbsp;                    if (pointblankShot) {</b>
<b class="nc">&nbsp;                        r = new Report(3102);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(3100);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.subject = aId;</b>
<b class="nc">&nbsp;                    Entity ae = game.getEntity(aId);</b>
<b class="nc">&nbsp;                    r.addDesc(ae);</b>
<b class="nc">&nbsp;                    handleAttackReports.addElement(r);</b>
<b class="nc">&nbsp;                    ah.setAnnouncedEntityFiring(true);</b>
<b class="nc">&nbsp;                    lastAttackerId = aId;</b>
&nbsp;                }
<b class="nc">&nbsp;                boolean keep = ah.handle(game.getPhase(), handleAttackReports);</b>
<b class="nc">&nbsp;                if (keep) {</b>
<b class="nc">&nbsp;                    keptAttacks.add(ah);</b>
&nbsp;                }
<b class="nc">&nbsp;                Report.addNewline(handleAttackReports);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // now resolve everything but TAG
<b class="nc">&nbsp;        for (AttackHandler ah : currentAttacks) {</b>
<b class="nc">&nbsp;            if (ah instanceof TAGHandler) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ah.cares(game.getPhase())) {</b>
<b class="nc">&nbsp;                int aId = ah.getAttackerId();</b>
<b class="nc">&nbsp;                if ((aId != lastAttackerId) &amp;&amp; !ah.announcedEntityFiring()) {</b>
&nbsp;                    // if this is a new attacker then resolve any
&nbsp;                    // standard-to-cap damage
&nbsp;                    // from previous
<b class="nc">&nbsp;                    handleAttackReports.addAll(checkFatalThresholds(aId,</b>
&nbsp;                            lastAttackerId));
&nbsp;                    // report who is firing
<b class="nc">&nbsp;                    if (pointblankShot) {</b>
<b class="nc">&nbsp;                        r = new Report(3102);</b>
<b class="nc">&nbsp;                    } else if (ah.isStrafing()) {</b>
<b class="nc">&nbsp;                        r = new Report(3101);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        r = new Report(3100);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.subject = aId;</b>
<b class="nc">&nbsp;                    Entity ae = game.getEntity(aId);</b>
&nbsp;                    // for arty, attacker may be dead, or fled, so check out-of-
&nbsp;                    // game entities
<b class="nc">&nbsp;                    if (ae == null) {</b>
<b class="nc">&nbsp;                        ae = game.getOutOfGameEntity(aId);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    r.addDesc(ae);</b>
<b class="nc">&nbsp;                    handleAttackReports.addElement(r);</b>
<b class="nc">&nbsp;                    ah.setAnnouncedEntityFiring(true);</b>
<b class="nc">&nbsp;                    lastAttackerId = aId;</b>
&nbsp;                }
<b class="nc">&nbsp;                boolean keep = ah.handle(game.getPhase(), handleAttackReports);</b>
<b class="nc">&nbsp;                if (keep) {</b>
<b class="nc">&nbsp;                    keptAttacks.add(ah);</b>
&nbsp;                }
<b class="nc">&nbsp;                Report.addNewline(handleAttackReports);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                keptAttacks.add(ah);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // resolve standard to capital one more time
<b class="nc">&nbsp;        handleAttackReports.addAll(checkFatalThresholds(lastAttackerId,</b>
&nbsp;                lastAttackerId));
<b class="nc">&nbsp;        if (handleAttackReports.size() &gt; 0) {</b>
<b class="nc">&nbsp;            Report.addNewline(handleAttackReports);</b>
&nbsp;        }
<b class="nc">&nbsp;        addReport(handleAttackReports);</b>
&nbsp;        // HACK, but anything else seems to run into weird problems.
<b class="nc">&nbsp;        game.setAttacksVector(keptAttacks);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return the current server instance
&nbsp;     */
&nbsp;    public static Server getServerInstance() {
<b class="fc">&nbsp;        return serverInstance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * create a &lt;code&gt;SmokeCloud&lt;/code&gt; object and add it to the server list
&nbsp;     *
&nbsp;     * @param coords   the location to create the smoke
&nbsp;     * @param level    1=Light 2=Heavy Smoke 3:light LI smoke 4: Heavy LI smoke
&nbsp;     * @param duration How long the smoke will last.
&nbsp;     */
&nbsp;    public void createSmoke(Coords coords, int level, int duration) {
<b class="nc">&nbsp;        SmokeCloud cloud = new SmokeCloud(coords, level, duration);</b>
<b class="nc">&nbsp;        game.addSmokeCloud(cloud);</b>
<b class="nc">&nbsp;        sendSmokeCloudAdded(cloud);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * create a &lt;code&gt;SmokeCloud&lt;/code&gt; object and add it to the server list
&nbsp;     *
&nbsp;     * @param coords   the location to create the smoke
&nbsp;     * @param level    1=Light 2=Heavy Smoke 3:light LI smoke 4: Heavy LI smoke
&nbsp;     * @param duration duration How long the smoke will last.
&nbsp;     */
&nbsp;    public void createSmoke(ArrayList&lt;Coords&gt; coords, int level, int duration) {
<b class="nc">&nbsp;        SmokeCloud cloud = new SmokeCloud(coords, level, duration);</b>
<b class="nc">&nbsp;        game.addSmokeCloud(cloud);</b>
<b class="nc">&nbsp;        sendSmokeCloudAdded(cloud);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Update the map with a new set of coords.
&nbsp;     *
&nbsp;     * @param newCoords the location to move the smoke to
&nbsp;     */
&nbsp;    public void updateSmoke(SmokeCloud cloud, ArrayList&lt;Coords&gt; newCoords) {
<b class="nc">&nbsp;        removeSmokeTerrain(cloud);</b>
<b class="nc">&nbsp;        cloud.getCoordsList().clear();</b>
<b class="nc">&nbsp;        cloud.getCoordsList().addAll(newCoords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * remove a cloud from the map
&nbsp;     *
&nbsp;     * @param cloud the location to remove the smoke from
&nbsp;     */
&nbsp;    public void removeSmokeTerrain(SmokeCloud cloud) {
<b class="nc">&nbsp;        for (Coords coords : cloud.getCoordsList()) {</b>
<b class="nc">&nbsp;            IHex nextHex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;            if ((nextHex != null) &amp;&amp; nextHex.containsTerrain(Terrains.SMOKE)) {</b>
<b class="nc">&nbsp;                nextHex.removeTerrain(Terrains.SMOKE);</b>
<b class="nc">&nbsp;                sendChangedHex(coords);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public List&lt;SmokeCloud&gt; getSmokeCloudList() {
<b class="nc">&nbsp;        return game.getSmokeCloudList();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if blowing sand caused damage to airborne VTOL/WIGEs
&nbsp;     */
&nbsp;    private Vector&lt;Report&gt; resolveBlowingSandDamage() {
<b class="nc">&nbsp;        Vector&lt;Report&gt; vFullReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        vFullReport.add(new Report(5002, Report.PUBLIC));</b>
<b class="nc">&nbsp;        int damage_bonus = Math.max(0, game.getPlanetaryConditions().getWindStrength()</b>
&nbsp;                - PlanetaryConditions.WI_MOD_GALE);
&nbsp;        // cycle through each team and damage 1d6 airborne VTOL/WiGE
<b class="nc">&nbsp;        for (Enumeration&lt;Team&gt; loop = game.getTeams(); loop.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            Team team = loop.nextElement();</b>
<b class="nc">&nbsp;            Vector&lt;Integer&gt; airborne = team.getAirborneVTOL();</b>
<b class="nc">&nbsp;            if (airborne.size() &gt; 0) {</b>
&nbsp;                // how many units are affected
<b class="nc">&nbsp;                int unitsAffected = Math.min(Compute.d6(), airborne.size());</b>
<b class="nc">&nbsp;                while ((unitsAffected &gt; 0) &amp;&amp; (airborne.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                    int loc = Compute.randomInt(airborne.size());</b>
<b class="nc">&nbsp;                    Entity en = game.getEntity(airborne.get(loc));</b>
<b class="nc">&nbsp;                    int damage = Math.max(1, Compute.d6() / 2) + damage_bonus;</b>
<b class="nc">&nbsp;                    while (damage &gt; 0) {</b>
<b class="nc">&nbsp;                        HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_RANDOM);</b>
<b class="nc">&nbsp;                        vFullReport.addAll(damageEntity(en, hit, 1));</b>
<b class="nc">&nbsp;                        damage--;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    unitsAffected--;</b>
<b class="nc">&nbsp;                    airborne.remove(loc);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;        return vFullReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * let an entity lay a mine
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; that should lay a mine
&nbsp;     * @param mineId an &lt;code&gt;int&lt;/code&gt; pointing to the mine
&nbsp;     */
&nbsp;    private void layMine(Entity entity, int mineId, Coords coords) {
<b class="nc">&nbsp;        Mounted mine = entity.getEquipment(mineId);</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        if (!mine.isMissing()) {</b>
<b class="nc">&nbsp;            int reportId = 0;</b>
<b class="nc">&nbsp;            switch (mine.getMineType()) {</b>
&nbsp;                case Mounted.MINE_CONVENTIONAL:
<b class="nc">&nbsp;                    deliverThunderMinefield(coords, entity.getOwnerId(), 10,</b>
<b class="nc">&nbsp;                            entity.getId());</b>
<b class="nc">&nbsp;                    reportId = 3500;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case Mounted.MINE_VIBRABOMB:
<b class="nc">&nbsp;                    deliverThunderVibraMinefield(coords, entity.getOwnerId(), 10,</b>
<b class="nc">&nbsp;                            mine.getVibraSetting(), entity.getId());</b>
<b class="nc">&nbsp;                    reportId = 3505;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case Mounted.MINE_ACTIVE:
<b class="nc">&nbsp;                    deliverThunderActiveMinefield(coords, entity.getOwnerId(), 10,</b>
<b class="nc">&nbsp;                            entity.getId());</b>
<b class="nc">&nbsp;                    reportId = 3510;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case Mounted.MINE_INFERNO:
<b class="nc">&nbsp;                    deliverThunderInfernoMinefield(coords, entity.getOwnerId(), 10,</b>
<b class="nc">&nbsp;                            entity.getId());</b>
<b class="nc">&nbsp;                    reportId = 3515;</b>
&nbsp;                    break;
&nbsp;                // TODO : command-detonated mines
&nbsp;                // case 2:
&nbsp;            }
<b class="nc">&nbsp;            mine.setShotsLeft(mine.getUsableShotsLeft() - 1);</b>
<b class="nc">&nbsp;            if (mine.getUsableShotsLeft() &lt;= 0) {</b>
<b class="nc">&nbsp;                mine.setMissing(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            r = new Report(reportId);</b>
<b class="nc">&nbsp;            r.subject = entity.getId();</b>
<b class="nc">&nbsp;            r.addDesc(entity);</b>
<b class="nc">&nbsp;            r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;            addReport(r);</b>
<b class="nc">&nbsp;            entity.setLayingMines(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void reportRoll(Roll roll) {
<b class="nc">&nbsp;        Report r = new Report(1230);</b>
<b class="nc">&nbsp;        r.add(roll.getReport());</b>
<b class="nc">&nbsp;        addReport(r);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void registerWithServerBrowser(boolean register, String urlString) {
&nbsp;        try {
<b class="nc">&nbsp;            URL url = new URL(urlString);</b>
<b class="nc">&nbsp;            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</b>
<b class="nc">&nbsp;            conn.setDoOutput(true);</b>
<b class="nc">&nbsp;            conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</b>
<b class="nc">&nbsp;            DataOutputStream printout = new DataOutputStream(</b>
<b class="nc">&nbsp;                    conn.getOutputStream());</b>
&nbsp;            String content;
<b class="nc">&nbsp;            content = &quot;port=&quot;</b>
<b class="nc">&nbsp;                      + URLEncoder.encode(</b>
<b class="nc">&nbsp;                              Integer.toString(serverSocket.getLocalPort()), &quot;UTF-8&quot;);</b>
<b class="nc">&nbsp;            if (register) {</b>
<b class="nc">&nbsp;                for (IConnection iconn : connections) {</b>
<b class="nc">&nbsp;                    content += &quot;&amp;players[]=&quot; + (getPlayer(iconn.getId()).getName());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if ((game.getPhase() != Phase.PHASE_LOUNGE)</b>
<b class="nc">&nbsp;                        &amp;&amp; (game.getPhase() != Phase.PHASE_UNKNOWN)) {</b>
<b class="nc">&nbsp;                    content += &quot;&amp;close=yes&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                content += &quot;&amp;version=&quot; + MegaMek.VERSION;</b>
<b class="nc">&nbsp;                if (isPassworded()) {</b>
<b class="nc">&nbsp;                    content += &quot;&amp;pw=yes&quot;;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                content += &quot;&amp;delete=yes&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (serverAccessKey != null) {</b>
<b class="nc">&nbsp;                content += &quot;&amp;key=&quot; + serverAccessKey;</b>
&nbsp;            }
<b class="nc">&nbsp;            printout.writeBytes(content);</b>
<b class="nc">&nbsp;            printout.flush();</b>
<b class="nc">&nbsp;            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));</b>
&nbsp;            String line;
<b class="nc">&nbsp;            if (conn.getResponseCode() == 200) {</b>
<b class="nc">&nbsp;                while ((line = rd.readLine()) != null) {</b>
<b class="nc">&nbsp;                    if (serverAccessKey == null) {</b>
<b class="nc">&nbsp;                        serverAccessKey = line;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            rd.close();</b>
<b class="nc">&nbsp;            printout.close();</b>
<b class="nc">&nbsp;        } catch (Exception ignored) {</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Set&lt;Coords&gt; getHexUpdateSet() {
<b class="nc">&nbsp;        return hexUpdateSet;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
