


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > BasicPathRanker</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot.princess</a>
</div>

<h1>Coverage Summary for Class: BasicPathRanker (megamek.client.bot.princess)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BasicPathRanker</td>
<td class="coverageStat">
  <span class="percent">
    64.1%
  </span>
  <span class="absValue">
    (25/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (388/561)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BasicPathRanker$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$FiringPhysicalDamage</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$09WEqagv</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$8Xdfx10k</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$Ag11Vsp7</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$BCNF4nP2</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$cRXenOqH</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$csZpH5uW</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$fmni7az9</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$fROQALSX</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$FyPGKZn7</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$H1GIPMqb</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$HtSbVPVt</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$IVwA8unY</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$JLA5hcfO</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$k6jWhxDv</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$kc36c6Rj</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$l6iYkpXD</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$lsrKKgTQ</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$N0c4izrz</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$N4wcoVeJ</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$nrXhUevY</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$NT80hYXs</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$OEmIrHZx</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$OwDC4XQY</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$ox6EFwTH</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$PH06w5fy</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$PwYBGLg4</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$qJmje2m7</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$RSaW9nHi</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$rSPJSWxT</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$uAoJSwYJ</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$V0Qnifcm</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$vCrxUAaE</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$WElWksbC</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$xvD25uig</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$ykVDRiqz</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$Z4pU0NEL</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$ZOgyJsPQ</td>
  </tr>
  <tr>
    <td class="name">BasicPathRanker$MockitoMock$106225749$auxiliary$ZzdVhb4d</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    63.4%
  </span>
  <span class="absValue">
    (26/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.1%
  </span>
  <span class="absValue">
    (389/563)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000-2011 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.client.bot.princess;
&nbsp;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.text.DecimalFormatSymbols;
&nbsp;import java.text.NumberFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;
&nbsp;import megamek.client.bot.princess.BotGeometry.ConvexBoardArea;
&nbsp;import megamek.client.bot.princess.BotGeometry.CoordFacingCombo;
&nbsp;import megamek.client.bot.princess.BotGeometry.HexLine;
&nbsp;import megamek.client.bot.princess.UnitBehavior.BehaviorType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.BipedMech;
&nbsp;import megamek.common.BuildingTarget;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementMode;
&nbsp;import megamek.common.EntityMovementType;
&nbsp;import megamek.common.IBoard;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.LosEffects;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MechWarrior;
&nbsp;import megamek.common.MiscType;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MoveStep;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.QuadMech;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.TripodMech;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;
&nbsp;/**
&nbsp; * A very &quot;basic&quot; pathranker
&nbsp; */
&nbsp;public class BasicPathRanker extends PathRanker implements IPathRanker {
&nbsp;
&nbsp;    // this is a value used to indicate how much we value the unit being at its destination
<b class="fc">&nbsp;    private final int ARRIVED_AT_DESTINATION_FACTOR = 250;</b>
&nbsp;    
&nbsp;    // this is a value used to indicate how much we dis-value the unit being destroyed as a result of
&nbsp;    // what it&#39;s doing
<b class="fc">&nbsp;    private final int UNIT_DESTRUCTION_FACTOR = 1000;</b>
&nbsp;    
<b class="fc">&nbsp;    protected final DecimalFormat LOG_DECIMAL =</b>
<b class="fc">&nbsp;            new DecimalFormat(&quot;0.00&quot;, DecimalFormatSymbols.getInstance());</b>
<b class="fc">&nbsp;    private final NumberFormat LOG_INT = NumberFormat.getIntegerInstance();</b>
<b class="fc">&nbsp;    protected final NumberFormat LOG_PERCENT = NumberFormat.getPercentInstance();</b>
&nbsp;
&nbsp;    private PathEnumerator pathEnumerator;
&nbsp;
&nbsp;    // the best damage enemies could expect were I not here. Used to determine 
&nbsp;    // whether they will target me.
&nbsp;    private Map&lt;Integer, Double&gt; bestDamageByEnemies;
&nbsp;    
&nbsp;    public BasicPathRanker(Princess owningPrincess) {
<b class="fc">&nbsp;        super(owningPrincess);</b>
&nbsp;        
<b class="fc">&nbsp;        bestDamageByEnemies = new TreeMap&lt;&gt;();</b>
&nbsp;        
<b class="fc">&nbsp;        getOwner().getLogger().debug(&quot;Using &quot; + getOwner().getBehaviorSettings().getDescription()</b>
&nbsp;                        + &quot; behavior&quot;);
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    FireControl getFireControl(Entity entity) {
<b class="fc">&nbsp;        return getOwner().getFireControl(entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    void setPathEnumerator(PathEnumerator pathEnumerator) {
<b class="nc">&nbsp;        this.pathEnumerator = pathEnumerator;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    PathEnumerator getPathEnumerator() {
<b class="nc">&nbsp;        return pathEnumerator;</b>
&nbsp;    }
&nbsp;
&nbsp;    Map&lt;Integer, Double&gt; getBestDamageByEnemies() {
<b class="fc">&nbsp;        return bestDamageByEnemies;</b>
&nbsp;    }
&nbsp;
&nbsp;    Coords getClosestCoordsTo(int unitId, Coords location) {
<b class="nc">&nbsp;        ConvexBoardArea box = pathEnumerator.getUnitMovableAreas().get(unitId);</b>
<b class="nc">&nbsp;        if (box == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return box.getClosestCoordsTo(location);</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean isInMyLoS(Entity unit, HexLine leftBounds, HexLine rightBounds) {
<b class="nc">&nbsp;        return (leftBounds.judgeArea(pathEnumerator.getUnitMovableAreas().get(unit.getId())) &gt; 0)</b>
<b class="nc">&nbsp;               &amp;&amp; (rightBounds.judgeArea(pathEnumerator.getUnitMovableAreas().get(unit.getId())) &lt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    double getMaxDamageAtRange(FireControl fireControl, Entity shooter,
&nbsp;                               int range, boolean useExtremeRange,
&nbsp;                               boolean useLOSRange) {
<b class="nc">&nbsp;        return fireControl.getMaxDamageAtRange(shooter, range, useExtremeRange,</b>
&nbsp;                                               useLOSRange);
&nbsp;    }
&nbsp;
&nbsp;    boolean canFlankAndKick(Entity enemy, Coords behind, Coords leftFlank,
&nbsp;                            Coords rightFlank, int myFacing) {
<b class="nc">&nbsp;        Set&lt;CoordFacingCombo&gt; enemyFacingSet =</b>
<b class="nc">&nbsp;                pathEnumerator.getUnitPotentialLocations().get(enemy.getId());</b>
<b class="nc">&nbsp;        if (enemyFacingSet == null) {</b>
<b class="nc">&nbsp;            getOwner().getLogger().warning(&quot;no facing set for &quot; + enemy.getDisplayName());</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(behind, myFacing))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(behind, (myFacing + 1) % 6))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(behind, (myFacing + 5) % 6))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(leftFlank, myFacing))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(leftFlank, (myFacing + 4) % 6))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(leftFlank, (myFacing + 5) % 6))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(rightFlank, myFacing))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(rightFlank, (myFacing + 1) % 6))</b>
<b class="nc">&nbsp;               || enemyFacingSet.contains(CoordFacingCombo.createCoordFacingCombo(rightFlank, (myFacing + 2) % 6));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Guesses a number of things about an enemy that has not yet moved
&nbsp;     * TODO estimated damage is sloppy.  Improve for missile attacks, gun skill, and range
&nbsp;     */
&nbsp;    EntityEvaluationResponse evaluateUnmovedEnemy(Entity enemy, MovePath path,
&nbsp;                                                  boolean useExtremeRange,
&nbsp;                                                  boolean useLOSRange) {
&nbsp;        //some preliminary calculations
<b class="fc">&nbsp;        final double damageDiscount = 0.25;</b>
<b class="fc">&nbsp;        EntityEvaluationResponse returnResponse =</b>
&nbsp;                new EntityEvaluationResponse();
&nbsp;
&nbsp;        //Airborne aeros on ground maps always move after other units, and would require an 
&nbsp;        // entirely different evaluation
&nbsp;        //TODO (low priority) implement a way to see if I can dodge aero units
<b class="fc">&nbsp;        if (enemy.isAirborneAeroOnGroundMap()) {</b>
<b class="fc">&nbsp;            return returnResponse;</b>
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        Coords finalCoords = path.getFinalCoords();</b>
<b class="fc">&nbsp;        int myFacing = path.getFinalFacing();</b>
<b class="fc">&nbsp;        Coords behind = finalCoords.translated((myFacing + 3) % 6);</b>
<b class="fc">&nbsp;        Coords leftFlank = finalCoords.translated((myFacing + 2) % 6);</b>
<b class="fc">&nbsp;        Coords rightFlank = finalCoords.translated((myFacing + 4) % 6);</b>
<b class="fc">&nbsp;        Coords closest = getClosestCoordsTo(enemy.getId(), finalCoords);</b>
<b class="fc">&nbsp;        if (closest == null) {</b>
<b class="nc">&nbsp;            return returnResponse;</b>
&nbsp;        }
<b class="fc">&nbsp;        int range = closest.distance(finalCoords);</b>
&nbsp;
&nbsp;        // I would prefer if the enemy must end its move in my line of fire 
&nbsp;        // if so, I can guess that I may do some damage to it (cover 
&nbsp;        // notwithstanding).  At the very least, I can force the enemy to 
&nbsp;        // take cover on its move.
&nbsp;        HexLine leftBounds;
&nbsp;        HexLine rightBounds;
<b class="fc">&nbsp;        if (path.getEntity().canChangeSecondaryFacing()) {</b>
<b class="fc">&nbsp;            leftBounds = new HexLine(behind, (myFacing + 2) % 6);</b>
<b class="fc">&nbsp;            rightBounds = new HexLine(behind, (myFacing + 4) % 6);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            leftBounds = new HexLine(behind, (myFacing + 1) % 6);</b>
<b class="nc">&nbsp;            rightBounds = new HexLine(behind, (myFacing + 5) % 6);</b>
&nbsp;        }
<b class="fc">&nbsp;        boolean inMyLos = isInMyLoS(enemy, leftBounds, rightBounds);</b>
<b class="fc">&nbsp;        if (inMyLos) {</b>
<b class="fc">&nbsp;            returnResponse.addToMyEstimatedDamage(</b>
<b class="fc">&nbsp;                    getMaxDamageAtRange(getFireControl(path.getEntity()),</b>
<b class="fc">&nbsp;                                        path.getEntity(),</b>
&nbsp;                                        range,
&nbsp;                                        useExtremeRange,
&nbsp;                                        useLOSRange) * damageDiscount);
&nbsp;        }
&nbsp;
&nbsp;        //in general if an enemy can end its position in range, it can hit me
<b class="fc">&nbsp;        returnResponse.addToEstimatedEnemyDamage(</b>
<b class="fc">&nbsp;                getMaxDamageAtRange(getFireControl(enemy),</b>
&nbsp;                                    enemy,
&nbsp;                                    range,
&nbsp;                                    useExtremeRange,
&nbsp;                                    useLOSRange)
&nbsp;                                                 * damageDiscount);
&nbsp;
&nbsp;        //It is especially embarrassing if the enemy can move behind or flank me and then kick me
<b class="fc">&nbsp;        if (canFlankAndKick(enemy, behind, leftFlank, rightFlank, myFacing)) {</b>
<b class="fc">&nbsp;            returnResponse.addToEstimatedEnemyDamage(</b>
<b class="fc">&nbsp;                    Math.ceil(enemy.getWeight() / 5.0) *</b>
&nbsp;                    damageDiscount);
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        return returnResponse;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected List&lt;TargetRoll&gt; getPSRList(MovePath path) {
<b class="nc">&nbsp;        return super.getPSRList(path);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double getMovePathSuccessProbability(MovePath movePath,
&nbsp;                                                StringBuilder msg) {
<b class="fc">&nbsp;        return super.getMovePathSuccessProbability(movePath, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private double calculateFallMod(double successProbability,
&nbsp;                                    StringBuilder formula) {
<b class="fc">&nbsp;        double pilotingFailure = (1 - successProbability);</b>
<b class="fc">&nbsp;        double fallShame = getOwner().getBehaviorSettings().getFallShameValue();</b>
<b class="fc">&nbsp;        double fallMod = pilotingFailure * (pilotingFailure == 1 ? -UNIT_DESTRUCTION_FACTOR : fallShame);</b>
<b class="fc">&nbsp;        formula.append(&quot;fall mod [&quot;).append(LOG_DECIMAL.format(fallMod)).append(&quot; = &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(pilotingFailure)).append(&quot; * &quot;).append(LOG_DECIMAL.format(fallShame))</b>
<b class="fc">&nbsp;               .append(&quot;]&quot;);</b>
<b class="fc">&nbsp;        return fallMod;</b>
&nbsp;    }
&nbsp;
&nbsp;    double calculateDamagePotential(Entity enemy,
&nbsp;                                    EntityState shooterState,
&nbsp;                                    MovePath path,
&nbsp;                                    EntityState targetState,
&nbsp;                                    int distance,
&nbsp;                                    IGame game) {
&nbsp;
&nbsp;        // If they don&#39;t have the range, they can&#39;t do damage.
<b class="fc">&nbsp;        int maxRange = getOwner().getMaxWeaponRange(enemy, path.getEntity().isAirborne());</b>
<b class="fc">&nbsp;        if (distance &gt; maxRange) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        //  If they don&#39;t have LoS, they can&#39;t do damage.
<b class="fc">&nbsp;        LosEffects losEffects = </b>
<b class="fc">&nbsp;                LosEffects.calculateLos(game, enemy.getId(), path.getEntity(), shooterState.getPosition(), targetState.getPosition(), false);</b>
&nbsp;        
<b class="fc">&nbsp;        if (!losEffects.canSee()) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        Targetable actualTarget = path.getEntity();</b>
&nbsp;        
&nbsp;        // if the target is infantry protected by a building, we have to fire at the building instead. 
<b class="fc">&nbsp;        if(losEffects.infantryProtected()) {</b>
<b class="nc">&nbsp;            actualTarget = new BuildingTarget(targetState.getPosition(), game.getBoard(), false);</b>
<b class="nc">&nbsp;            targetState = new EntityState(actualTarget);            </b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int maxHeat = (enemy.getHeatCapacity() - enemy.heat) + (enemy.isAero() ? 0 : 5);</b>
<b class="fc">&nbsp;        FiringPlanCalculationParameters guess =</b>
&nbsp;                new FiringPlanCalculationParameters.Builder()
<b class="fc">&nbsp;                        .buildGuess(enemy,</b>
&nbsp;                                    shooterState,
&nbsp;                                    actualTarget,
&nbsp;                                    targetState,
&nbsp;                                    maxHeat,
&nbsp;                                    null);
<b class="fc">&nbsp;        return getFireControl(path.getEntity()).determineBestFiringPlan(guess).getUtility();</b>
&nbsp;    }
&nbsp;
&nbsp;    double calculateKickDamagePotential(Entity enemy, MovePath path,
&nbsp;                                        IGame game) {
&nbsp;
<b class="nc">&nbsp;        if (!(enemy instanceof Mech)) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if they can kick me, and probably hit, they probably will.
<b class="nc">&nbsp;        PhysicalInfo theirKick = new PhysicalInfo(enemy, null,</b>
<b class="nc">&nbsp;                path.getEntity(), new EntityState(path),</b>
<b class="nc">&nbsp;                PhysicalAttackType.RIGHT_KICK, game, getOwner(), true);</b>
&nbsp;
<b class="nc">&nbsp;        if (theirKick.getProbabilityToHit() &lt;= 0.5) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return theirKick.getExpectedDamageOnHit() * theirKick.getProbabilityToHit();</b>
&nbsp;    }
&nbsp;
&nbsp;    double calculateMyDamagePotential(MovePath path, Entity enemy,
&nbsp;                                      int distance, IGame game) {
<b class="fc">&nbsp;        Entity me = path.getEntity();</b>
&nbsp;
&nbsp;        // If I don&#39;t have range, I can&#39;t do damage.
&nbsp;        // exception: I might, if I&#39;m an aero on a ground map attacking a ground unit because aero unit ranges are a &quot;special case&quot;
<b class="fc">&nbsp;        boolean aeroAttackingGroundUnitOnGroundMap = me.isAirborne() &amp;&amp; !enemy.isAero() &amp;&amp; game.getBoard().onGround();</b>
&nbsp;
<b class="fc">&nbsp;        int maxRange = getOwner().getMaxWeaponRange(me, enemy.isAirborne());</b>
<b class="fc">&nbsp;        if (distance &gt; maxRange &amp;&amp; !aeroAttackingGroundUnitOnGroundMap) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If I don&#39;t have LoS, I can&#39;t do damage.  ToDo: Account for indirect fire.
<b class="fc">&nbsp;        LosEffects losEffects = </b>
<b class="fc">&nbsp;                LosEffects.calculateLos(game, me.getId(), enemy, path.getFinalCoords(), enemy.getPosition(), false);</b>
<b class="fc">&nbsp;        if (!losEffects.canSee()) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If I am an infantry unit that cannot both move and fire, and I am 
&nbsp;        // moving, I can&#39;t do damage.
<b class="fc">&nbsp;        boolean isZeroMpInfantry =</b>
<b class="nc">&nbsp;                me instanceof Infantry &amp;&amp; (me.getWalkMP() == 0);</b>
<b class="fc">&nbsp;        if (isZeroMpInfantry &amp;&amp; path.getMpUsed() &gt; 0) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        FiringPlan myFiringPlan;
&nbsp;        // we&#39;re only going to do air to ground attack plans if we&#39;re an airborne aero attacking a ground unit
<b class="fc">&nbsp;        if (aeroAttackingGroundUnitOnGroundMap) {</b>
<b class="nc">&nbsp;            myFiringPlan = getFireControl(path.getEntity()).guessFullAirToGroundPlan(me, enemy,</b>
&nbsp;                                                                     new EntityState(enemy), path, game, false);
&nbsp;        } else {
<b class="fc">&nbsp;            FiringPlanCalculationParameters guess =</b>
&nbsp;                    new FiringPlanCalculationParameters.Builder()
<b class="fc">&nbsp;                            .buildGuess(path.getEntity(),</b>
&nbsp;                                        new EntityState(path),
&nbsp;                                        enemy,
&nbsp;                                        null,
<b class="fc">&nbsp;                                        getFireControl(me).calcHeatTolerance(me, me.isAero()),</b>
&nbsp;                                        null);
<b class="fc">&nbsp;            myFiringPlan = getFireControl(me).determineBestFiringPlan(guess);</b>
&nbsp;        }
<b class="fc">&nbsp;        return myFiringPlan.getUtility();</b>
&nbsp;    }
&nbsp;
&nbsp;    double calculateMyKickDamagePotential(MovePath path, Entity enemy,
&nbsp;                                          IGame game) {
<b class="nc">&nbsp;        if (!(path.getEntity() instanceof Mech)) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PhysicalInfo myKick = new PhysicalInfo(path.getEntity(),</b>
&nbsp;                new EntityState(path), enemy, null,
<b class="nc">&nbsp;                PhysicalAttackType.RIGHT_KICK, game, getOwner(), true);</b>
<b class="nc">&nbsp;        if (myKick.getProbabilityToHit() &lt;= 0.5) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return myKick.getExpectedDamageOnHit() * myKick.getProbabilityToHit();</b>
&nbsp;    }
&nbsp;
&nbsp;    EntityEvaluationResponse evaluateMovedEnemy(Entity enemy, MovePath path,
&nbsp;                                                IGame game) {
&nbsp;
<b class="fc">&nbsp;        EntityEvaluationResponse returnResponse = new EntityEvaluationResponse();</b>
&nbsp;
<b class="fc">&nbsp;        int distance = enemy.getPosition().distance(path.getFinalCoords());</b>
&nbsp;        
&nbsp;        // How much damage can they do to me?
<b class="fc">&nbsp;        double theirDamagePotential = calculateDamagePotential(enemy,</b>
&nbsp;                                                               new EntityState(enemy),
&nbsp;                                                               path,
&nbsp;                                                               new EntityState(path),
&nbsp;                                                               distance,
&nbsp;                                                               game);
&nbsp;
&nbsp;        // if they can kick me, and probably hit, they probably will.
<b class="fc">&nbsp;        if (distance &lt;= 1) {</b>
<b class="fc">&nbsp;            theirDamagePotential += calculateKickDamagePotential(enemy, path,</b>
&nbsp;                                                                 game);
&nbsp;        }
<b class="fc">&nbsp;        returnResponse.setEstimatedEnemyDamage(theirDamagePotential);</b>
&nbsp;
&nbsp;        // How much damage can I do to them?
<b class="fc">&nbsp;        returnResponse.setMyEstimatedDamage(calculateMyDamagePotential(path,</b>
&nbsp;                                                                       enemy,
&nbsp;                                                                       distance,
&nbsp;                                                                       game));
&nbsp;       
&nbsp;        // How much physical damage can I do to them?
<b class="fc">&nbsp;        if (distance &lt;= 1) {</b>
<b class="fc">&nbsp;            returnResponse.setMyEstimatedPhysicalDamage(</b>
<b class="fc">&nbsp;                    calculateMyKickDamagePotential(path, enemy, game));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnResponse;</b>
&nbsp;    }
&nbsp;
&nbsp;    // The further I am from a target, the lower this path ranks (weighted by 
&nbsp;    // Hyper Aggression.
&nbsp;    protected double calculateAggressionMod(Entity movingUnit, MovePath path,
&nbsp;                                          IGame game, StringBuilder formula) {
<b class="fc">&nbsp;        double distToEnemy = distanceToClosestEnemy(movingUnit,</b>
<b class="fc">&nbsp;                                                    path.getFinalCoords(),</b>
&nbsp;                                                    game);
<b class="fc">&nbsp;        if ((distToEnemy == 0) &amp;&amp; !(movingUnit instanceof Infantry)) {</b>
<b class="nc">&nbsp;            distToEnemy = 2;</b>
&nbsp;        }
<b class="fc">&nbsp;        double aggression = getOwner().getBehaviorSettings()</b>
<b class="fc">&nbsp;                                      .getHyperAggressionValue();</b>
<b class="fc">&nbsp;        double aggressionMod = distToEnemy * aggression;</b>
<b class="fc">&nbsp;        formula.append(&quot; - aggressionMod [&quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(aggressionMod)).append(&quot; = &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(distToEnemy)).append(&quot; * &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(aggression)).append(&quot;]&quot;);</b>
<b class="fc">&nbsp;        return aggressionMod;</b>
&nbsp;    }
&nbsp;
&nbsp;    // The further I am from my teammates, the lower this path ranks (weighted 
&nbsp;    // by Herd Mentality).
&nbsp;    protected double calculateHerdingMod(Coords friendsCoords, MovePath path,
&nbsp;                                       StringBuilder formula) {
<b class="fc">&nbsp;        if (friendsCoords == null) {</b>
<b class="fc">&nbsp;            formula.append(&quot; - herdingMod [0 no friends]&quot;);</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        double distanceToAllies = friendsCoords.distance(path.getFinalCoords());</b>
<b class="fc">&nbsp;        double herding = getOwner().getBehaviorSettings()</b>
<b class="fc">&nbsp;                                   .getHerdMentalityValue();</b>
<b class="fc">&nbsp;        double herdingMod = distanceToAllies * herding;</b>
<b class="fc">&nbsp;        formula.append(&quot; - herdingMod [&quot;).append(LOG_DECIMAL.format(herdingMod))</b>
<b class="fc">&nbsp;               .append(&quot; = &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(distanceToAllies)).append(&quot; * &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(herding))</b>
<b class="fc">&nbsp;               .append(&quot;]&quot;);</b>
<b class="fc">&nbsp;        return herdingMod;</b>
&nbsp;    }
&nbsp;
&nbsp;    // todo account for damaged locations and face those away from enemy.
&nbsp;    private double calculateFacingMod(Entity movingUnit, IGame game,
&nbsp;                                      final MovePath path,
&nbsp;                                      StringBuilder formula) {
&nbsp;
<b class="fc">&nbsp;        Targetable closest = findClosestEnemy(movingUnit, movingUnit.getPosition(),</b>
&nbsp;                                          game, false);
<b class="fc">&nbsp;        Coords toFace = closest == null ?</b>
<b class="fc">&nbsp;                        game.getBoard().getCenter() :</b>
<b class="nc">&nbsp;                        closest.getPosition();</b>
<b class="fc">&nbsp;        int desiredFacing = (toFace.direction(movingUnit.getPosition()) + 3) % 6;</b>
<b class="fc">&nbsp;        int currentFacing = path.getFinalFacing();</b>
&nbsp;        int facingDiff;
<b class="fc">&nbsp;        if (currentFacing == desiredFacing) {</b>
<b class="fc">&nbsp;            facingDiff = 0;</b>
<b class="fc">&nbsp;        } else if ((currentFacing == ((desiredFacing + 1) % 6))</b>
&nbsp;                   || (currentFacing == ((desiredFacing + 5) % 6))) {
<b class="fc">&nbsp;            facingDiff = 1;</b>
<b class="fc">&nbsp;        } else if ((currentFacing == ((desiredFacing + 2) % 6))</b>
&nbsp;                   || (currentFacing == ((desiredFacing + 4) % 6))) {
<b class="fc">&nbsp;            facingDiff = 2;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            facingDiff = 3;</b>
&nbsp;        }
<b class="fc">&nbsp;        double facingMod = Math.max(0.0, 50 * (facingDiff - 1));</b>
<b class="fc">&nbsp;        formula.append(&quot; - facingMod [&quot;).append(LOG_DECIMAL.format(facingMod))</b>
<b class="fc">&nbsp;               .append(&quot; = max(&quot;)</b>
<b class="fc">&nbsp;               .append(LOG_INT.format(0)).append(&quot;, &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_INT.format(50)).append(&quot; * {&quot;)</b>
<b class="fc">&nbsp;               .append(LOG_INT.format(facingDiff)).append(&quot; - &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_INT.format(1)).append(&quot;})]&quot;);</b>
<b class="fc">&nbsp;        return facingMod;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If intentionally attempting to reach some board edge, favor paths that take me closer to it.
&nbsp;     */
&nbsp;    protected double calculateSelfPreservationMod(Entity movingUnit,
&nbsp;                                                MovePath path,
&nbsp;                                                IGame game,
&nbsp;                                                StringBuilder formula) {
<b class="fc">&nbsp;        BehaviorType behaviorType = getOwner().getUnitBehaviorTracker().getBehaviorType(movingUnit, getOwner()); </b>
&nbsp;        
<b class="fc">&nbsp;        if (behaviorType == BehaviorType.ForcedWithdrawal ||</b>
&nbsp;                behaviorType == BehaviorType.MoveToDestination) {
<b class="nc">&nbsp;            int newDistanceToHome = distanceToHomeEdge(path.getFinalCoords(),</b>
<b class="nc">&nbsp;                                                       getOwner().getHomeEdge(movingUnit),</b>
&nbsp;                                                       game);
<b class="nc">&nbsp;            double selfPreservation = getOwner().getBehaviorSettings()</b>
<b class="nc">&nbsp;                                                .getSelfPreservationValue();</b>
&nbsp;            
<b class="nc">&nbsp;            double selfPreservationMod = 0;</b>
&nbsp;            
&nbsp;            // normally, we favor being closer to the edge we&#39;re trying to get to
<b class="nc">&nbsp;            if (newDistanceToHome &gt; 0) {</b>
<b class="nc">&nbsp;                selfPreservationMod = newDistanceToHome * selfPreservation;</b>
&nbsp;            // if this path gets us to the edge, we value it considerably more than we do paths that don&#39;t get us there    
&nbsp;            } else {
<b class="nc">&nbsp;                selfPreservationMod = -ARRIVED_AT_DESTINATION_FACTOR;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            formula.append(&quot; - selfPreservationMod [&quot;)</b>
<b class="nc">&nbsp;                   .append(LOG_DECIMAL.format(selfPreservationMod))</b>
<b class="nc">&nbsp;                   .append(&quot; = &quot;).append(LOG_DECIMAL.format(newDistanceToHome))</b>
<b class="nc">&nbsp;                   .append(&quot; * &quot;)</b>
<b class="nc">&nbsp;                   .append(LOG_DECIMAL.format(selfPreservation)).append(&quot;]&quot;);</b>
<b class="nc">&nbsp;            return selfPreservationMod;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 0.0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Tells me whether this path will result in me flying to a location
&nbsp;     * from which there is absolutely no way to remain on the board the following turn.
&nbsp;     * 
&nbsp;     * Not applicable for ground units, so the default behavior is to return 0.
&nbsp;     */
&nbsp;    protected double calculateOffBoardMod(MovePath path) {
<b class="fc">&nbsp;        return 0.0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A path ranking
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected RankedPath rankPath(MovePath path, IGame game, int maxRange,
&nbsp;                               double fallTolerance, int distanceHome,
&nbsp;                               List&lt;Entity&gt; enemies, Coords friendsCoords) {
<b class="fc">&nbsp;        Entity movingUnit = path.getEntity();</b>
<b class="fc">&nbsp;        StringBuilder formula = new StringBuilder(&quot;Calculation: {&quot;);</b>
&nbsp;
&nbsp;        // Copy the path to avoid inadvertent changes.
<b class="fc">&nbsp;        MovePath pathCopy = path.clone();</b>
&nbsp;
&nbsp;        // Worry about failed piloting rolls (weighted by Fall Shame).
<b class="fc">&nbsp;        double successProbability = getMovePathSuccessProbability(pathCopy,</b>
&nbsp;                                                                  formula);
<b class="fc">&nbsp;        double utility = -calculateFallMod(successProbability, formula);</b>
&nbsp;
&nbsp;        // look at all of my enemies          
<b class="fc">&nbsp;        FiringPhysicalDamage damageEstimate = new FiringPhysicalDamage();</b>
&nbsp;        
<b class="fc">&nbsp;        double expectedDamageTaken = checkPathForHazards(pathCopy,</b>
&nbsp;                                                         movingUnit,
&nbsp;                                                         game);
<b class="fc">&nbsp;        boolean extremeRange = game.getOptions()</b>
<b class="fc">&nbsp;                                   .booleanOption(</b>
&nbsp;                                           OptionsConstants.ADVCOMBAT_TACOPS_RANGE);
<b class="fc">&nbsp;        boolean losRange = game.getOptions()</b>
<b class="fc">&nbsp;                               .booleanOption(</b>
&nbsp;                                       OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE);
<b class="fc">&nbsp;        for (Entity enemy : enemies) {</b>
&nbsp;
&nbsp;            // Skip ejected pilots.
<b class="fc">&nbsp;            if (enemy instanceof MechWarrior) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Skip units not actually on the board.
<b class="fc">&nbsp;            if (enemy.isOffBoard() || (enemy.getPosition() == null)</b>
<b class="fc">&nbsp;                || !game.getBoard().contains(enemy.getPosition())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            //skip broken enemies
<b class="fc">&nbsp;            if (getOwner().getHonorUtil().isEnemyBroken(enemy.getId(),</b>
<b class="fc">&nbsp;                    enemy.getOwnerId(), getOwner().getForcedWithdrawal())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            EntityEvaluationResponse eval;
&nbsp;
<b class="fc">&nbsp;            if (evaluateAsMoved(enemy)) { //For units that have already moved</b>
<b class="fc">&nbsp;                eval = evaluateMovedEnemy(enemy, pathCopy, game);</b>
&nbsp;            } else { //for units that have not moved this round
<b class="fc">&nbsp;                eval = evaluateUnmovedEnemy(enemy, path, extremeRange,</b>
&nbsp;                                            losRange);
&nbsp;            }
<b class="fc">&nbsp;            if (damageEstimate.firingDamage &lt; eval.getMyEstimatedDamage()) {</b>
<b class="fc">&nbsp;                damageEstimate.firingDamage = eval.getMyEstimatedDamage();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (damageEstimate.physicalDamage &lt; eval.getMyEstimatedPhysicalDamage()) {</b>
<b class="fc">&nbsp;                damageEstimate.physicalDamage = eval.getMyEstimatedPhysicalDamage();</b>
&nbsp;            }
<b class="fc">&nbsp;            expectedDamageTaken += eval.getEstimatedEnemyDamage();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // if we&#39;re not in the air, we may get hit by friendly artillery
<b class="fc">&nbsp;        if(!path.getEntity().isAirborne() &amp;&amp; !path.getEntity().isAirborneVTOLorWIGE()) {</b>
<b class="fc">&nbsp;            double friendlyArtilleryDamage = 0;</b>
<b class="fc">&nbsp;            Map&lt;Coords, Double&gt; artyDamage = getOwner().getPathRankerState().getIncomingFriendlyArtilleryDamage();</b>
&nbsp;            
<b class="fc">&nbsp;            if(!artyDamage.containsKey(path.getFinalCoords())) {</b>
<b class="fc">&nbsp;                friendlyArtilleryDamage = ArtilleryTargetingControl.evaluateIncomingArtilleryDamage(path.getFinalCoords(), getOwner());</b>
<b class="fc">&nbsp;                artyDamage.put(path.getFinalCoords(), friendlyArtilleryDamage);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                friendlyArtilleryDamage = artyDamage.get(path.getFinalCoords());</b>
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            expectedDamageTaken += friendlyArtilleryDamage;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        calcDamageToStrategicTargets(pathCopy, game, getOwner().getFireControlState(), damageEstimate);</b>
&nbsp;
&nbsp;        // If I cannot kick because I am a clan unit and &quot;No physical 
&nbsp;        // attacks for the clans&quot;
&nbsp;        // is enabled, set maximum physical damage for this path to zero.
<b class="fc">&nbsp;        if (game.getOptions()</b>
<b class="fc">&nbsp;                .booleanOption(OptionsConstants.ALLOWED_NO_CLAN_PHYSICAL) &amp;&amp;</b>
<b class="nc">&nbsp;            path.getEntity().isClan()) {</b>
<b class="nc">&nbsp;            damageEstimate.physicalDamage = 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // I can kick a different target than I shoot, so add physical to 
&nbsp;        // total damage after I&#39;ve looked at all enemies
<b class="fc">&nbsp;        double maximumDamageDone = damageEstimate.firingDamage + damageEstimate.physicalDamage;</b>
&nbsp;
&nbsp;        // My bravery modifier is based on my chance of getting to the 
&nbsp;        // firing position (successProbability), how much damage I can do 
&nbsp;        // (weighted by bravery), less the damage I might take.
<b class="fc">&nbsp;        double braveryValue =</b>
<b class="fc">&nbsp;                getOwner().getBehaviorSettings().getBraveryValue();</b>
<b class="fc">&nbsp;        double braveryMod = successProbability *</b>
&nbsp;                            ((maximumDamageDone *
&nbsp;                              braveryValue) -
&nbsp;                             expectedDamageTaken);
<b class="fc">&nbsp;        formula.append(&quot; + braveryMod [&quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(braveryMod)).append(&quot; = &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_PERCENT.format(successProbability))</b>
<b class="fc">&nbsp;               .append(&quot; * ((&quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(maximumDamageDone)).append(&quot; * &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(braveryValue)).append(&quot;) - &quot;)</b>
<b class="fc">&nbsp;               .append(LOG_DECIMAL.format(expectedDamageTaken)).append(&quot;]&quot;);</b>
<b class="fc">&nbsp;        utility += braveryMod;</b>
&nbsp;
&nbsp;        // the only critters not subject to aggression and herding mods are
&nbsp;        // airborne aeros on ground maps, as they move incredibly fast
<b class="fc">&nbsp;        if (!path.getEntity().isAirborneAeroOnGroundMap()) {</b>
&nbsp;            // The further I am from a target, the lower this path ranks 
&nbsp;            // (weighted by Aggression slider).
<b class="fc">&nbsp;            utility -= calculateAggressionMod(movingUnit, pathCopy, game,</b>
&nbsp;                                              formula);
&nbsp;
&nbsp;            // The further I am from my teammates, the lower this path 
&nbsp;            // ranks (weighted by Herd Mentality).
<b class="fc">&nbsp;            utility -= calculateHerdingMod(friendsCoords, pathCopy, formula);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Try to face the enemy.
<b class="fc">&nbsp;        double facingMod = calculateFacingMod(movingUnit, game, pathCopy,</b>
&nbsp;                                              formula);
<b class="fc">&nbsp;        if (facingMod == -10000) {</b>
<b class="nc">&nbsp;            return new RankedPath(facingMod, pathCopy, formula.toString());</b>
&nbsp;        }
<b class="fc">&nbsp;        utility -= facingMod;</b>
&nbsp;        
&nbsp;        // If I need to flee the board, I want to get closer to my home edge.
<b class="fc">&nbsp;        utility -= calculateSelfPreservationMod(movingUnit, pathCopy, game, formula);</b>
&nbsp;        
&nbsp;        // if we&#39;re an aircraft, we want to de-value paths that will force us off the board
&nbsp;        // on the subsequent turn.
<b class="fc">&nbsp;        utility -= utility * calculateOffBoardMod(pathCopy);</b>
&nbsp;
<b class="fc">&nbsp;        RankedPath rankedPath = new RankedPath(utility, pathCopy, formula.toString());</b>
<b class="fc">&nbsp;        rankedPath.setExpectedDamage(maximumDamageDone);</b>
<b class="fc">&nbsp;        return rankedPath;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Worker function that determines if a given enemy entity should be evaluated as if it has moved.
&nbsp;     */
&nbsp;    protected boolean evaluateAsMoved(Entity enemy) {
&nbsp;        // Aerospace units on ground maps can go pretty much anywhere they want, so it&#39;s
&nbsp;        // somewhat pointless to try to predict their movement.
<b class="fc">&nbsp;        return !enemy.isSelectableThisTurn() || enemy.isImmobile() || enemy.isAirborneAeroOnGroundMap();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculate who all other units would shoot at if I weren&#39;t around
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void initUnitTurn(Entity unit, IGame game) {
<b class="nc">&nbsp;        bestDamageByEnemies.clear();</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; enemies = getOwner().getEnemyEntities();</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; friends = getOwner().getFriendEntities();</b>
<b class="nc">&nbsp;        for (Entity e : enemies) {</b>
<b class="nc">&nbsp;            double max_damage = 0;</b>
<b class="nc">&nbsp;            for (Entity f : friends) {</b>
<b class="nc">&nbsp;                FiringPlanCalculationParameters guess =</b>
&nbsp;                        new FiringPlanCalculationParameters.Builder()
<b class="nc">&nbsp;                                .buildGuess(e,</b>
&nbsp;                                            null,
&nbsp;                                            f,
&nbsp;                                            null,
<b class="nc">&nbsp;                                            (e.getHeatCapacity() - e.getHeat()) + 5,</b>
&nbsp;                                            null);
<b class="nc">&nbsp;                double damage = getFireControl(f).determineBestFiringPlan(guess)</b>
<b class="nc">&nbsp;                                           .getExpectedDamage();</b>
<b class="nc">&nbsp;                if (damage &gt; max_damage) {</b>
<b class="nc">&nbsp;                    max_damage = damage;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            bestDamageByEnemies.put(e.getId(), max_damage);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    protected void calcDamageToStrategicTargets(MovePath path, IGame game, 
&nbsp;            FireControlState fireControlState, FiringPhysicalDamage damageStructure) {
&nbsp;                
<b class="fc">&nbsp;        for (int i = 0; i &lt; fireControlState.getAdditionalTargets().size(); i++) {</b>
<b class="nc">&nbsp;            Targetable target = fireControlState.getAdditionalTargets().get(i);</b>
&nbsp;            
<b class="nc">&nbsp;            if (target.isOffBoard() || (target.getPosition() == null)</b>
<b class="nc">&nbsp;                || !game.getBoard().contains(target.getPosition())) {</b>
<b class="nc">&nbsp;                continue; // Skip targets not actually on the board.</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            FiringPlanCalculationParameters guess =</b>
&nbsp;                    new FiringPlanCalculationParameters.Builder()
<b class="nc">&nbsp;                            .buildGuess(path.getEntity(),</b>
&nbsp;                                        new EntityState(path),
&nbsp;                                        target,
&nbsp;                                        null,
&nbsp;                                        Entity.DOES_NOT_TRACK_HEAT,
&nbsp;                                        null);
<b class="nc">&nbsp;            FiringPlan myFiringPlan = getFireControl(path.getEntity()).determineBestFiringPlan(guess);</b>
&nbsp;            
<b class="nc">&nbsp;            double myDamagePotential = myFiringPlan.getUtility();</b>
<b class="nc">&nbsp;            if (myDamagePotential &gt; damageStructure.firingDamage) {</b>
<b class="nc">&nbsp;                damageStructure.firingDamage = myDamagePotential;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (path.getEntity() instanceof Mech) {</b>
<b class="nc">&nbsp;                PhysicalInfo myKick = new PhysicalInfo(</b>
<b class="nc">&nbsp;                        path.getEntity(), new EntityState(path), target,</b>
&nbsp;                        null,
<b class="nc">&nbsp;                        PhysicalAttackType.RIGHT_KICK, game, getOwner(),</b>
&nbsp;                        true);
<b class="nc">&nbsp;                double expectedKickDamage =</b>
<b class="nc">&nbsp;                        myKick.getExpectedDamageOnHit() *</b>
<b class="nc">&nbsp;                        myKick.getProbabilityToHit();</b>
<b class="nc">&nbsp;                if (expectedKickDamage &gt; damageStructure.physicalDamage) {</b>
<b class="nc">&nbsp;                    damageStructure.physicalDamage = expectedKickDamage;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Gives the distance to the closest enemy unit, or -1 if none exist.
&nbsp;     * The reason being that the closest enemy unit may be 0 away.
&nbsp;     *
&nbsp;     * @param me       Entity who has enemies
&nbsp;     * @param position Coords from which the closest enemy is found
&nbsp;     * @param game     IGame that we&#39;re playing
&nbsp;     */
&nbsp;    public double distanceToClosestEnemy(Entity me, Coords position, IGame game) {
<b class="nc">&nbsp;        Targetable closest = findClosestEnemy(me, position, game);</b>
<b class="nc">&nbsp;        if (closest == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return closest.getPosition().distance(position);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gives the distance to the closest edge
&nbsp;     */
&nbsp;    int distanceToClosestEdge(Coords position, IGame game) {
<b class="nc">&nbsp;       int width = game.getBoard().getWidth();</b>
<b class="nc">&nbsp;        int height = game.getBoard().getHeight();</b>
<b class="nc">&nbsp;        int minimum = position.getX();</b>
<b class="nc">&nbsp;        if ((width - position.getX()) &lt; minimum) {</b>
<b class="nc">&nbsp;            minimum = position.getX();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (position.getY() &lt; minimum) {</b>
<b class="nc">&nbsp;            minimum = position.getY();</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((height - position.getY()) &lt; minimum) {</b>
<b class="nc">&nbsp;            minimum = height - position.getY();</b>
&nbsp;        }
<b class="nc">&nbsp;        return minimum;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns distance to the unit&#39;s home edge.
&nbsp;     * Gives the distance to the closest edge
&nbsp;     *
&nbsp;     * @param position Final coordinates of the proposed move.
&nbsp;     * @param homeEdge Unit&#39;s home edge.
&nbsp;     * @param game     The {@link IGame} currently in play.
&nbsp;     * @return The distance to the unit&#39;s home edge.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int distanceToHomeEdge(Coords position, CardinalEdge homeEdge, IGame game) {
<b class="nc">&nbsp;        int width = game.getBoard().getWidth();</b>
<b class="nc">&nbsp;        int height = game.getBoard().getHeight();</b>
&nbsp;
&nbsp;        int distance;
<b class="nc">&nbsp;        switch (homeEdge) {</b>
&nbsp;            case NORTH: {
<b class="nc">&nbsp;                distance = position.getY();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            case SOUTH: {
<b class="nc">&nbsp;                distance = height - position.getY() - 1;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            case WEST: {
<b class="nc">&nbsp;                distance = position.getX();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            case EAST: {
<b class="nc">&nbsp;                distance = width - position.getX() - 1;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            default: {
<b class="nc">&nbsp;                getOwner().getLogger().warning(&quot;Invalid home edge.  Defaulting to NORTH.&quot;);</b>
<b class="nc">&nbsp;                distance = position.getY();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return distance;</b>
&nbsp;    }
&nbsp;
&nbsp;    double checkPathForHazards(MovePath path, Entity movingUnit, IGame game) {
<b class="fc">&nbsp;        StringBuilder logMsg = new StringBuilder(&quot;Checking Path (&quot;)</b>
<b class="fc">&nbsp;                .append(path.toString()).append(&quot;) for hazards.&quot;);</b>
&nbsp;
&nbsp;        try {
&nbsp;            // If we&#39;re flying or swimming, we don&#39;t care about ground hazards.
<b class="fc">&nbsp;            if (EntityMovementType.MOVE_FLYING.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_OVER_THRUST.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_SAFE_THRUST.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_VTOL_WALK.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_VTOL_RUN.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_VTOL_SPRINT.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_SUBMARINE_WALK.equals(path.getLastStepMovementType()) ||</b>
<b class="fc">&nbsp;                EntityMovementType.MOVE_SUBMARINE_RUN.equals(path.getLastStepMovementType())) {</b>
&nbsp;
<b class="fc">&nbsp;                logMsg.append(&quot;\n\tMove Type (&quot;).append(path.getLastStepMovementType().toString())</b>
<b class="fc">&nbsp;                      .append(&quot;) ignores ground hazards.&quot;);</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If we&#39;re jumping, we only care about where we land.
<b class="fc">&nbsp;            if (path.isJumping()) {</b>
<b class="fc">&nbsp;                logMsg.append(&quot;\n\tJumping&quot;);</b>
<b class="fc">&nbsp;                Coords endCoords = path.getFinalCoords();</b>
<b class="fc">&nbsp;                IHex endHex = game.getBoard().getHex(endCoords);</b>
<b class="fc">&nbsp;                return checkHexForHazards(endHex, movingUnit, true,</b>
<b class="fc">&nbsp;                                          path.getLastStep(), true,</b>
<b class="fc">&nbsp;                                          path, game.getBoard(), logMsg);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            double totalHazard = 0;</b>
<b class="fc">&nbsp;            Coords previousCoords = null;</b>
<b class="fc">&nbsp;            MoveStep lastStep = path.getLastStep();</b>
<b class="fc">&nbsp;            for (MoveStep step : path.getStepVector()) {</b>
<b class="fc">&nbsp;                Coords coords = step.getPosition();</b>
<b class="fc">&nbsp;                if ((coords == null) || coords.equals(previousCoords)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                IHex hex = game.getBoard().getHex(coords);</b>
<b class="fc">&nbsp;                totalHazard += checkHexForHazards(hex, movingUnit,</b>
<b class="fc">&nbsp;                                                  lastStep.equals(step), step,</b>
&nbsp;                                                  false, path,
<b class="fc">&nbsp;                                                  game.getBoard(), logMsg);</b>
<b class="fc">&nbsp;                previousCoords = coords;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return totalHazard;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            getOwner().getLogger().debug(logMsg.toString());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private double checkHexForHazards(IHex hex, Entity movingUnit,
&nbsp;                                      boolean endHex, MoveStep step,
&nbsp;                                      boolean jumpLanding,
&nbsp;                                      MovePath movePath, IBoard board,
&nbsp;                                      StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tHex &quot;).append(hex.getCoords().toFriendlyString());</b>
&nbsp;
<b class="fc">&nbsp;        final List&lt;Integer&gt; HAZARDS =</b>
<b class="fc">&nbsp;                new ArrayList&lt;&gt;(Arrays.asList(Terrains.FIRE,</b>
<b class="fc">&nbsp;                                              Terrains.MAGMA,</b>
<b class="fc">&nbsp;                                              Terrains.ICE,</b>
<b class="fc">&nbsp;                                              Terrains.WATER,</b>
<b class="fc">&nbsp;                                              Terrains.BUILDING,</b>
<b class="fc">&nbsp;                                              Terrains.BRIDGE));</b>
&nbsp;
<b class="fc">&nbsp;        int[] terrainTypes = hex.getTerrainTypes();</b>
<b class="fc">&nbsp;        Set&lt;Integer&gt; hazards = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (int type : terrainTypes) {</b>
<b class="fc">&nbsp;            if (HAZARDS.contains(type)) {</b>
<b class="fc">&nbsp;                hazards.add(type);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // No hazards were found, so nothing to worry about.
<b class="fc">&nbsp;        if (hazards.isEmpty()) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot; has no hazards.&quot;);</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Calculate hazard value by terrain type.
<b class="fc">&nbsp;        double hazardValue = 0;</b>
<b class="fc">&nbsp;        for (int hazard : hazards) {</b>
<b class="fc">&nbsp;            switch (hazard) {</b>
&nbsp;                case Terrains.FIRE:
<b class="fc">&nbsp;                    hazardValue += calcFireHazard(movingUnit, endHex, logMsg);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case Terrains.MAGMA:
<b class="fc">&nbsp;                    hazardValue += calcMagmaHazard(hex, endHex, movingUnit,</b>
&nbsp;                                                   jumpLanding, step, logMsg);
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case Terrains.ICE:
<b class="fc">&nbsp;                    hazardValue += calcIceHazard(movingUnit, hex, step,</b>
&nbsp;                                                 jumpLanding, logMsg);
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case Terrains.WATER:
<b class="fc">&nbsp;                    if (!hazards.contains(Terrains.ICE)) {</b>
<b class="nc">&nbsp;                        hazardValue += calcWaterHazard(movingUnit, hex, step,</b>
&nbsp;                                                       logMsg);
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Terrains.BUILDING:
<b class="fc">&nbsp;                    hazardValue += calcBuildingHazard(step, movingUnit, jumpLanding, board, logMsg);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case Terrains.BRIDGE:
<b class="nc">&nbsp;                    hazardValue += calcBridgeHazard(movingUnit, hex, step, jumpLanding, board, logMsg);</b>
&nbsp;                    break;
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tTotal Hazard = &quot;)</b>
<b class="fc">&nbsp;              .append(LOG_DECIMAL.format(hazardValue));</b>
&nbsp;
<b class="fc">&nbsp;        return hazardValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Building collapse and basements are handled in PathRanker.validatePaths.
&nbsp;    private double calcBuildingHazard(MoveStep step, Entity movingUnit,
&nbsp;                                      boolean jumpLanding, IBoard board,
&nbsp;                                      StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tCalculating building hazard:  &quot;);</b>
&nbsp;
&nbsp;        // Protos, BA and Infantry move through buildings freely.
<b class="fc">&nbsp;        if (movingUnit instanceof Protomech || movingUnit instanceof Infantry) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;Safe for infantry and protos.&quot;);</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Jumping onto a building is handled in PathRanker validatePaths.
<b class="fc">&nbsp;        if (jumpLanding) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the odds of failing the piloting roll while moving through the building.
<b class="fc">&nbsp;        double odds = (1.0 - (Compute.oddsAbove(movingUnit.getCrew()</b>
<b class="fc">&nbsp;                                                          .getPiloting()) / 100));</b>
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tChance to fail piloting roll: &quot;)</b>
<b class="fc">&nbsp;              .append(LOG_PERCENT.format(odds));</b>
&nbsp;
&nbsp;        // Hazard is based on potential damage taken.
<b class="fc">&nbsp;        double dmg = board.getBuildingAt(step.getPosition())</b>
<b class="fc">&nbsp;                          .getCurrentCF(step.getPosition()) / 10D;</b>
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tPotential building damage: &quot;)</b>
<b class="fc">&nbsp;              .append(LOG_DECIMAL.format(dmg));</b>
&nbsp;
<b class="fc">&nbsp;        double hazard = dmg * odds;</b>
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tHazard value (&quot;)</b>
<b class="fc">&nbsp;              .append(LOG_DECIMAL.format(hazard)).append(&quot;).&quot;);</b>
<b class="fc">&nbsp;        return hazard;</b>
&nbsp;    }
&nbsp;    
&nbsp;    private double calcBridgeHazard(Entity movingUnit, IHex hex, MoveStep step, boolean jumpLanding, IBoard board, StringBuilder logMsg) {
<b class="nc">&nbsp;        logMsg.append(&quot;\n\tCalculating bridge hazard:  &quot;);</b>
&nbsp;        
&nbsp;        // if we are going to BWONGGG into a bridge from below, then it&#39;s treated as a building.
&nbsp;        // Otherwise, bridge collapse checks have already been handled in validatePaths
<b class="nc">&nbsp;        int bridgeElevation = hex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;        if ((bridgeElevation &gt; step.getElevation()) &amp;&amp;</b>
<b class="nc">&nbsp;                (bridgeElevation &lt;= (step.getElevation() + movingUnit.getHeight()))) {</b>
<b class="nc">&nbsp;            return calcBuildingHazard(step, movingUnit, jumpLanding, board, logMsg);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double calcIceHazard(Entity movingUnit, IHex hex, MoveStep step,
&nbsp;                                 boolean jumpLanding,
&nbsp;                                 StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tCalculating ice hazard:  &quot;);</b>
&nbsp;
&nbsp;        // Hover units are above the surface.
<b class="fc">&nbsp;        if (EntityMovementMode.HOVER == movingUnit.getMovementMode() ||</b>
<b class="fc">&nbsp;            EntityMovementMode.WIGE == movingUnit.getMovementMode()) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Hovering above ice (0).&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If there is no water under the ice, don&#39;t worry about breaking 
&nbsp;        // through.
<b class="fc">&nbsp;        if (hex.depth() &lt; 1) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;No water under ice (0).&quot;);</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Hazard is based on chance to break through to the water underneath.
<b class="fc">&nbsp;        double breakthroughMod = jumpLanding ? 0.5 : 0.1667;</b>
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tChance to break through ice: &quot;)</b>
<b class="fc">&nbsp;              .append(LOG_PERCENT.format(breakthroughMod));</b>
&nbsp;
<b class="fc">&nbsp;        double hazard = calcWaterHazard(movingUnit, hex, step, logMsg) *</b>
&nbsp;                        breakthroughMod;
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tHazard value (&quot;)</b>
<b class="fc">&nbsp;              .append(LOG_DECIMAL.format(hazard)).append(&quot;).&quot;);</b>
<b class="fc">&nbsp;        return hazard;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double calcWaterHazard(Entity movingUnit, IHex hex, MoveStep step,
&nbsp;                                   StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tCalculating water hazard:  &quot;);</b>
&nbsp;
&nbsp;        // Puddles don&#39;t count.
<b class="fc">&nbsp;        if (hex.depth() == 0) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Puddles don&#39;t count (0).&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Hover units are above the surface.
<b class="fc">&nbsp;        if (EntityMovementMode.HOVER == movingUnit.getMovementMode() ||</b>
<b class="fc">&nbsp;            EntityMovementMode.WIGE == movingUnit.getMovementMode() ||</b>
<b class="fc">&nbsp;            EntityMovementMode.NAVAL == movingUnit.getMovementMode()) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Hovering or swimming above water (0).&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Amphibious units are safe (kind of the point).
<b class="fc">&nbsp;        if (movingUnit.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS) ||</b>
<b class="fc">&nbsp;            movingUnit.hasWorkingMisc(MiscType.F_AMPHIBIOUS)) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Amphibious unit (0).&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we are crossing a bridge, then we&#39;ll be fine. Trust me.
&nbsp;        // 1. Determine bridge elevation
&nbsp;        // 2. If unit elevation is equal to bridge elevation, skip.
<b class="fc">&nbsp;        if(hex.containsTerrain(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;            int bridgeElevation = hex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
<b class="nc">&nbsp;            if(bridgeElevation == step.getElevation()) {</b>
<b class="nc">&nbsp;                logMsg.append(&quot;Unit (0) crossing bridge.&quot;);</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Most other units are automatically destroyed.
<b class="fc">&nbsp;        if (!(movingUnit instanceof Mech || movingUnit instanceof Protomech ||</b>
&nbsp;              movingUnit instanceof BattleArmor)) {
<b class="fc">&nbsp;            logMsg.append(&quot;Ill drown (1000).&quot;);</b>
<b class="fc">&nbsp;            return UNIT_DESTRUCTION_FACTOR;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Unsealed unit will drown.
<b class="fc">&nbsp;        if (movingUnit instanceof Mech &amp;&amp; ((Mech) movingUnit).isIndustrial()) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Industrial mechs drown too (1000).&quot;);</b>
<b class="nc">&nbsp;            return UNIT_DESTRUCTION_FACTOR;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Find the submerged locations.
<b class="fc">&nbsp;        Set&lt;Integer&gt; submergedLocations = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (int loc = 0; loc &lt; movingUnit.locations(); loc++) {</b>
<b class="fc">&nbsp;            if (Mech.LOC_CLEG == loc &amp;&amp; !(movingUnit instanceof TripodMech)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if ((hex.depth() &gt;= 2) || step.isProne() ||</b>
&nbsp;                !(movingUnit instanceof Mech)) {
<b class="fc">&nbsp;                submergedLocations.add(loc);</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (Mech.LOC_RLEG == loc || Mech.LOC_LLEG == loc ||</b>
&nbsp;                Mech.LOC_CLEG == loc) {
<b class="fc">&nbsp;                submergedLocations.add(loc);</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if ((movingUnit instanceof QuadMech) &amp;&amp; (Mech.LOC_RARM == loc ||</b>
&nbsp;                                                     Mech.LOC_LARM == loc)) {
<b class="nc">&nbsp;                submergedLocations.add(loc);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tSubmerged locations: &quot;)</b>
<b class="fc">&nbsp;              .append(submergedLocations.size());</b>
&nbsp;
<b class="fc">&nbsp;        int hazardValue = 0;</b>
<b class="fc">&nbsp;        for (int loc : submergedLocations) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;\n\t\t\tLocation &quot;).append(loc).append(&quot; is &quot;);</b>
&nbsp;
&nbsp;            // Only locations withou armor can breach in movement phase.
<b class="fc">&nbsp;            if (movingUnit.getArmor(loc) &gt; 0) {</b>
<b class="fc">&nbsp;                logMsg.append(&quot; not breached (0).&quot;);</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Mechs or Protomechs having a head or torso breach is deadly.  
&nbsp;            // For other units, any breach is deadly.
&nbsp;            //noinspection ConstantConditions
<b class="fc">&nbsp;            if (Mech.LOC_HEAD == loc ||</b>
&nbsp;                Mech.LOC_CT == loc ||
&nbsp;                Protomech.LOC_HEAD == loc ||
&nbsp;                Protomech.LOC_TORSO == loc ||
&nbsp;                (!(movingUnit instanceof Mech) &amp;&amp;
&nbsp;                 !(movingUnit instanceof Protomech))) {
<b class="fc">&nbsp;                logMsg.append(&quot; breached and critical (1000).&quot;);</b>
<b class="fc">&nbsp;                return UNIT_DESTRUCTION_FACTOR;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Add 50 points per potential breach location.
<b class="fc">&nbsp;            logMsg.append(&quot; breached (50).&quot;);</b>
<b class="fc">&nbsp;            hazardValue += 50;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return hazardValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double calcFireHazard(Entity movingUnit, boolean endHex,
&nbsp;                                  StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tCalculating fire hazard:  &quot;);</b>
&nbsp;
<b class="fc">&nbsp;        double hazardValue = 0;</b>
&nbsp;
&nbsp;        // Fireproof BA ignores fire.
<b class="fc">&nbsp;        if ((movingUnit instanceof BattleArmor) &amp;&amp;</b>
<b class="fc">&nbsp;            ((BattleArmor) movingUnit).isFireResistant()) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;Ignored by fire resistant armor (0).&quot;);</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Tanks risk critical hits.
<b class="fc">&nbsp;        if (movingUnit instanceof Tank) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;Possible crit on tank (25).&quot;);</b>
<b class="fc">&nbsp;            return 25;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Protomechs risk location destruction.
<b class="fc">&nbsp;        if (movingUnit instanceof Protomech) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;Possible location destruction (50).&quot;);</b>
<b class="fc">&nbsp;            return 50;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Infantry and BA risk total destruction.
<b class="fc">&nbsp;        if (movingUnit instanceof Infantry) {</b>
<b class="nc">&nbsp;            logMsg.append((&quot;Possible unit destruction (1000).&quot;));</b>
<b class="nc">&nbsp;            return UNIT_DESTRUCTION_FACTOR;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If this unit tracks heat, add the heat gain to the hazard value.
<b class="fc">&nbsp;        if (movingUnit.getHeatCapacity() != Entity.DOES_NOT_TRACK_HEAT) {</b>
<b class="fc">&nbsp;            hazardValue += endHex ? 5 : 2;</b>
<b class="fc">&nbsp;            logMsg.append(&quot;Heat gain (&quot;).append(hazardValue).append(&quot;).&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return hazardValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double calcMagmaHazard(IHex hex, boolean endHex, Entity movingUnit,
&nbsp;                                   boolean jumpLanding, MoveStep step,
&nbsp;                                   StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tCalculating magma hazard:  &quot;);</b>
&nbsp;
&nbsp;        // Hovers are unaffected.
<b class="fc">&nbsp;        if (EntityMovementMode.HOVER == movingUnit.getMovementMode() ||</b>
<b class="fc">&nbsp;            EntityMovementMode.WIGE == movingUnit.getMovementMode()) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Hovering above magma (0).&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        double hazardValue = 0;</b>
<b class="fc">&nbsp;        int magmaLevel = hex.terrainLevel(Terrains.MAGMA);</b>
&nbsp;
&nbsp;        // Liquid magma.
<b class="fc">&nbsp;        if (magmaLevel == 2) {</b>
<b class="fc">&nbsp;            return calcLavaHazard(endHex, movingUnit, step, logMsg);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            double breakThroughMod = jumpLanding ? 0.5 : 0.1667;</b>
<b class="fc">&nbsp;            logMsg.append(&quot;\n\t\tChance to break through crust = &quot;)</b>
<b class="fc">&nbsp;                  .append(LOG_PERCENT.format(breakThroughMod));</b>
&nbsp;
&nbsp;            // Factor in the chance to break through.
<b class="fc">&nbsp;            double lavalHazard = calcLavaHazard(endHex, movingUnit, step,</b>
&nbsp;                                                logMsg) * breakThroughMod;
<b class="fc">&nbsp;            logMsg.append(&quot;\n\t\t\tLava hazard (&quot;)</b>
<b class="fc">&nbsp;                  .append(LOG_DECIMAL.format(lavalHazard)).append(&quot;).&quot;);</b>
<b class="fc">&nbsp;            hazardValue += lavalHazard;</b>
&nbsp;
&nbsp;            // Factor in heat.
<b class="fc">&nbsp;            if (movingUnit.getHeatCapacity() != Entity.DOES_NOT_TRACK_HEAT) {</b>
<b class="fc">&nbsp;                double heatMod = (endHex ? 5 : 2) * (1 - breakThroughMod);</b>
<b class="fc">&nbsp;                hazardValue += heatMod;</b>
<b class="fc">&nbsp;                logMsg.append(&quot;\n\t\tHeat gain (&quot;)</b>
<b class="fc">&nbsp;                      .append(LOG_DECIMAL.format(heatMod)).append(&quot;).&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return hazardValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double calcLavaHazard(boolean endHex, Entity movingUnit,
&nbsp;                                  MoveStep step, StringBuilder logMsg) {
<b class="fc">&nbsp;        logMsg.append(&quot;\n\tCalculating laval hazard:  &quot;);</b>
&nbsp;
&nbsp;
&nbsp;        // Hovers are unaffected.
<b class="fc">&nbsp;        if (EntityMovementMode.HOVER == movingUnit.getMovementMode() ||</b>
<b class="fc">&nbsp;            EntityMovementMode.WIGE == movingUnit.getMovementMode()) {</b>
<b class="nc">&nbsp;            logMsg.append(&quot;Hovering above lava (0).&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Non-mech units auto-destroyed.
<b class="fc">&nbsp;        if (!(movingUnit instanceof Mech)) {</b>
<b class="fc">&nbsp;            logMsg.append(&quot;Non-mech instant destruction (1000).&quot;);</b>
<b class="fc">&nbsp;            return UNIT_DESTRUCTION_FACTOR;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        double hazardValue = 0;</b>
&nbsp;
&nbsp;        // Factor in heat.
<b class="fc">&nbsp;        double heat = endHex ? 10.0 : 5.0;</b>
<b class="fc">&nbsp;        hazardValue += heat;</b>
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tHeat gain (&quot;).append(heat)</b>
<b class="fc">&nbsp;              .append(LOG_DECIMAL.format(heat)).append(&quot;).&quot;);</b>
&nbsp;
&nbsp;        // Factor in potential damage.
&nbsp;        double dmg;
<b class="fc">&nbsp;        logMsg.append(&quot;\n\t\tDamage to &quot;);</b>
<b class="fc">&nbsp;        if (step.isProne()) {</b>
<b class="fc">&nbsp;            dmg = 7 * movingUnit.locations();</b>
<b class="fc">&nbsp;            logMsg.append(&quot;everything [prone] (&quot;);</b>
<b class="fc">&nbsp;        } else if (movingUnit instanceof BipedMech) {</b>
<b class="fc">&nbsp;            dmg = 14;</b>
<b class="fc">&nbsp;            logMsg.append(&quot;legs (&quot;);</b>
<b class="nc">&nbsp;        } else if (movingUnit instanceof TripodMech) {</b>
<b class="nc">&nbsp;            dmg = 21;</b>
<b class="nc">&nbsp;            logMsg.append(&quot;legs (&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            dmg = 28;</b>
<b class="nc">&nbsp;            logMsg.append(&quot;legs (&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        logMsg.append(LOG_DECIMAL.format(dmg)).append(&quot;).&quot;);</b>
<b class="fc">&nbsp;        hazardValue += dmg;</b>
&nbsp;
<b class="fc">&nbsp;        return hazardValue;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Simple data structure that holds a separate firing and physical damage number.
&nbsp;     *
&nbsp;     */
<b class="fc">&nbsp;    protected class FiringPhysicalDamage {</b>
&nbsp;        public double firingDamage;
&nbsp;        public double physicalDamage;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
