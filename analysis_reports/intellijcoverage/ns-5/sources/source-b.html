


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FireControl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot.princess</a>
</div>

<h1>Coverage Summary for Class: FireControl (megamek.client.bot.princess)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FireControl</td>
<td class="coverageStat">
  <span class="percent">
    55.2%
  </span>
  <span class="absValue">
    (37/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63%
  </span>
  <span class="absValue">
    (882/1401)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FireControl$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FireControl$FireControlType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$1Wfac5lU</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$22dnXUGw</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$2os6wW3b</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$58sk0XeM</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$68sj3uSR</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$6eOiw9Rf</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$6kmCOCkh</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$9xnD89Xk</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$aBdQrthg</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$aGvY1iTW</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$Bt9zxGNI</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$bTRv8FqV</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$C4DIJSZU</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$CYI2SZq3</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$deiBIqsq</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$depeb8ia</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$dIYUrHxp</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$fMPA60yA</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$Fy3VJHVg</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$gAn7wPa8</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$HEbeaN2u</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$hHAxTu2G</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$Jk70QQg7</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$JoLNRuKP</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$kf3XUOPa</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$kQ9xJbSk</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$l3d4HJhG</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$lx363V3p</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$mafc2klr</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$MmIFye07</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$mNXJoLfU</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$MVqo2Qkc</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$NewUJsR0</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$OBdETWfk</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$QMG8lWTi</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$qrZp2ml7</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$SLXlxoTm</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$SXLacrsh</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$TAixmyBT</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$TehFrxlN</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$UdLCCScF</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$uOJsdNXy</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$UvAo9j4t</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$VCtcmgmb</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$VrdWzytE</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$VtUP5Y0h</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$wNtAY2Oc</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$xYVzVxdw</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$ZIBMgmJU</td>
  </tr>
  <tr>
    <td class="name">FireControl$MockitoMock$1640641589$auxiliary$zl5rgznP</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    55.1%
  </span>
  <span class="absValue">
    (38/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63%
  </span>
  <span class="absValue">
    (886/1406)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000-2011 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.client.bot.princess;
&nbsp;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.text.NumberFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.BombType;
&nbsp;import megamek.common.BuildingTarget;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Dropship;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementType;
&nbsp;import megamek.common.EntityWeightClass;
&nbsp;import megamek.common.EquipmentType;
&nbsp;import megamek.common.FixedWingSupport;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.HexTarget;
&nbsp;import megamek.common.IAero;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.ILocationExposureStatus;
&nbsp;import megamek.common.INarcPod;
&nbsp;import megamek.common.IPlayer;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.LargeSupportTank;
&nbsp;import megamek.common.LosEffects;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MechWarrior;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MoveStep;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.RangeType;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.TargetRollModifier;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.VTOL;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.RepairWeaponMalfunctionAction;
&nbsp;import megamek.common.actions.SearchlightAttackAction;
&nbsp;import megamek.common.actions.SpotAction;
&nbsp;import megamek.common.actions.UnjamTurretAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.annotations.StaticWrapper;
&nbsp;import megamek.common.logging.LogLevel;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.AeroGroundPathFinder;
&nbsp;import megamek.common.weapons.StopSwarmAttack;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.infantry.InfantryWeapon;
&nbsp;import megamek.common.weapons.missiles.ATMWeapon;
&nbsp;import megamek.common.weapons.missiles.MMLWeapon;
&nbsp;
&nbsp;/**
&nbsp; * FireControl selects which weapons a unit wants to fire and at whom Pay
&nbsp; * attention to the difference between &quot;guess&quot; and &quot;get&quot;. Guess will be much
&nbsp; * faster, but inaccurate
&nbsp; */
&nbsp;public class FireControl {
&nbsp;
&nbsp;    protected static final double DAMAGE_UTILITY = 1.0;
&nbsp;    protected static final double CRITICAL_UTILITY = 10.0;
&nbsp;    protected static final double KILL_UTILITY = 50.0;
&nbsp;    protected static final double OVERHEAT_DISUTILITY = 5.0;
&nbsp;    protected static final double OVERHEAT_DISUTILITY_AERO = 50.0; // Aeros *really* don&#39;t want to overheat.
&nbsp;    protected static final double EJECTED_PILOT_DISUTILITY = 1000.0;
&nbsp;    protected static final double CIVILIAN_TARGET_DISUTILITY = 250.0;
&nbsp;    protected static final double TARGET_HP_FRACTION_DEALT_UTILITY = -30.0;
&nbsp;
&nbsp;    private static final double TARGET_POTENTIAL_DAMAGE_UTILITY = 1.0;
&nbsp;    static final double COMMANDER_UTILITY = 0.5;
&nbsp;    static final double SUB_COMMANDER_UTILITY = 0.25;
&nbsp;    static final double STRATEGIC_TARGET_UTILITY = 0.5;
&nbsp;    static final double PRIORITY_TARGET_UTILITY = 0.25;
&nbsp;
&nbsp;    static final String TH_WOODS = &quot;woods&quot;;
&nbsp;    static final String TH_SMOKE = &quot;smoke&quot;;
&nbsp;    static final String TH_PHY_BASE = &quot;base&quot;;
&nbsp;    static final String TH_GUNNERY = &quot;gunnery skill&quot;;
&nbsp;    static final String TH_SENSORS = &quot;attacker sensors damaged&quot;;
&nbsp;    static final String TH_MINIMUM_RANGE = &quot;Minimum Range&quot;;
&nbsp;    static final String TH_HEAT = &quot;heat&quot;;
&nbsp;    static final String TH_WEAPON_MOD = &quot;weapon to-hit&quot;;
&nbsp;    static final String TH_AMMO_MOD = &quot;ammunition to-hit modifier&quot;;
<b class="fc">&nbsp;    static final TargetRollModifier TH_ATT_PRONE = new TargetRollModifier(2, &quot;attacker prone&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_IMMOBILE = new TargetRollModifier(-4, &quot;target immobile&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_SKID = new TargetRollModifier(2, &quot;target skidded&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_NO_MOVE = new TargetRollModifier(1, &quot;target didn&#39;t move&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_SPRINT = new TargetRollModifier(-1, &quot;target sprinted&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_AERO_NOE_ADJ = new TargetRollModifier(1,</b>
&nbsp;                                                                                           &quot;NOE aero adjacent flight &quot; +
&nbsp;                                                                                           &quot;path&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_AERO_NOE = new TargetRollModifier(3,</b>
&nbsp;                                                                                       &quot;NOE aero non-adjacent flight &quot; +
&nbsp;                                                                                       &quot;path&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_PRONE_RANGE = new TargetRollModifier(1,</b>
&nbsp;                                                                                &quot;target prone and at range&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_PRONE_ADJ = new TargetRollModifier(-2,</b>
&nbsp;                                                                              &quot;target prone and adjacent&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_BA = new TargetRollModifier(1, &quot;battle armor target&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_MW = new TargetRollModifier(2, &quot;ejected mechwarrior target&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_INF = new TargetRollModifier(1, &quot;infantry target&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_ANTI_AIR = new TargetRollModifier(-2, &quot;anti-aircraft quirk&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_INDUSTRIAL =</b>
&nbsp;            new TargetRollModifier(1, &quot;industrial cockpit without advanced fire control&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PRIMATIVE_INDUSTRIAL =</b>
&nbsp;            new TargetRollModifier(2, &quot;primitive industrial cockpit without advanced fire control&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_SUPER = new TargetRollModifier(-1, &quot;superheavy target&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_GROUND_DS = new TargetRollModifier(-4, &quot;grounded dropship target&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TAR_LOW_PROFILE = new TargetRollModifier(1,</b>
&nbsp;                                                                                          &quot;narrow/low profile target&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_NOT_MECH =</b>
&nbsp;            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;non-mechs don&#39;t make physical attacks&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_TOO_FAR = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                            &quot;target not adjacent&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_NULL_POSITION = new TargetRollModifier(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                                                              &quot;null position&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_RNG_TOO_FAR = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                            &quot;target beyond max range&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_NOT_IN_ARC = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                               &quot;target not in arc&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_TOO_MUCH_ELEVATION =</b>
&nbsp;            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;target elevation not in range&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_TAR_PRONE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                                &quot;can&#39;t punch while prone&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_TAR_INF = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                              &quot;can&#39;t punch infantry&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_NO_ARM = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                             &quot;Your arm&#39;s off!&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_NO_SHOULDER = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                                  &quot;shoulder destroyed&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_UPPER_ARM = new TargetRollModifier(2,</b>
&nbsp;                                                                                          &quot;upper arm actuator &quot; +
&nbsp;                                                                                          &quot;destroyed&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_LOWER_ARM = new TargetRollModifier(2,</b>
&nbsp;                                                                                          &quot;lower arm actuator missing&quot; +
&nbsp;                                                                                          &quot; or destroyed&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_HAND = new TargetRollModifier(1,</b>
&nbsp;                                                                                     &quot;hand actuator missing or &quot; +
&nbsp;                                                                                     &quot;destroyed&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_PRONE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                            &quot;can&#39;t kick while prone&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_INF = new TargetRollModifier(3, &quot;kicking infantry&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_INF_RNG = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                                        &quot;Infantry too far away&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_HIP = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                          &quot;can&#39;t kick with broken hip&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_UPPER_LEG = new TargetRollModifier(2,</b>
&nbsp;                                                                                          &quot;upper leg actuator &quot; +
&nbsp;                                                                                          &quot;destroyed&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_LOWER_LEG = new TargetRollModifier(2,</b>
&nbsp;                                                                                          &quot;lower leg actuator &quot; +
&nbsp;                                                                                          &quot;destroyed&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_K_FOOT = new TargetRollModifier(1, &quot;foot actuator destroyed&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_LIGHT = new TargetRollModifier(-2, &quot;weight class attack modifier&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_MEDIUM = new TargetRollModifier(-1,</b>
&nbsp;                                                                                     &quot;weight class attack modifier&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_SUPER = new TargetRollModifier(1, &quot;superheavy attacker&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_EASY_PILOT = new TargetRollModifier(-1, &quot;easy to pilot quirk&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_PHY_P_NO_ARMS_QUIRK = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                                              &quot;no/minimal arms quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_WEAP_CANNOT_FIRE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                                 &quot;weapon cannot fire&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_WEAP_NO_AMMO = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                             &quot;ammo is gone&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_WEAP_PRONE_ARMLESS =</b>
&nbsp;            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;prone and missing an arm&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_WEAP_ARM_PROP = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                              &quot;using arm as prop&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_WEAP_PRONE_LEG = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                               &quot;prone leg weapon&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_WEAPON_NO_ARC = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                              &quot;not in arc&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_INF_ZERO_RNG =</b>
&nbsp;            new TargetRollModifier(TargetRoll.AUTOMATIC_FAIL, &quot;noninfantry shooting with zero range&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_STOP_SWARM_INVALID = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                                   &quot;not swarming a Mek&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_SWARM_STOPPED = new TargetRollModifier(TargetRoll.AUTOMATIC_SUCCESS,</b>
&nbsp;                                                                              &quot;stops swarming&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_OUT_OF_RANGE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                                                             &quot;out of range&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_SHORT_RANGE = new TargetRollModifier(0, &quot;Short Range&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_MEDIUM_RANGE = new TargetRollModifier(2, &quot;Medium Range&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_LONG_RANGE = new TargetRollModifier(4, &quot;Long Range&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_EXTREME_RANGE = new TargetRollModifier(6, &quot;Extreme Range&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_TARGETTING_COMP = new TargetRollModifier(-1, &quot;targeting computer&quot;);</b>
<b class="fc">&nbsp;    static final TargetRollModifier TH_IMP_TARG_SHORT =</b>
&nbsp;            new TargetRollModifier(-1, &quot;improved targetting (short) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_IMP_TARG_MEDIUM =</b>
&nbsp;            new TargetRollModifier(-1, &quot;improved targetting (medium) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_IMP_TARG_LONG =</b>
&nbsp;            new TargetRollModifier(-1, &quot;improved targetting (long) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_VAR_RNG_TARG_SHORT_AT_SHORT =</b>
&nbsp;            new TargetRollModifier(-1, &quot;variable range targetting (short) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_VAR_RNG_TARG_SHORT_AT_LONG =</b>
&nbsp;            new TargetRollModifier(1, &quot;variable range targetting (short) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_VAR_RNG_TARG_LONG_AT_LONG =</b>
&nbsp;            new TargetRollModifier(-1, &quot;variable range targetting (long) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_VAR_RNG_TARG_LONG_AT_SHORT =</b>
&nbsp;            new TargetRollModifier(1, &quot;variable range targetting (long) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_POOR_TARG_SHORT =</b>
&nbsp;            new TargetRollModifier(1, &quot;poor targetting (short) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_POOR_TARG_MEDIUM =</b>
&nbsp;            new TargetRollModifier(1, &quot;poor targetting (medium) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_POOR_TARG_LONG =</b>
&nbsp;            new TargetRollModifier(1, &quot;poor targetting (long) quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_ACCURATE_WEAP =</b>
&nbsp;            new TargetRollModifier(-1, &quot;accurate weapon quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_INACCURATE_WEAP =</b>
&nbsp;            new TargetRollModifier(1, &quot;inaccurate weapon quirk&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_RNG_LARGE =</b>
&nbsp;            new TargetRollModifier(-1, &quot;target large vehicle or superheavy mech&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_AIR_STRIKE_PATH =</b>
&nbsp;            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;target not under flight path&quot;);
<b class="fc">&nbsp;    static final TargetRollModifier TH_AIR_STRIKE = new TargetRollModifier(2, &quot;strike attack&quot;);</b>
<b class="fc">&nbsp;    private static final TargetRollModifier TH_STABLE_WEAP =</b>
&nbsp;            new TargetRollModifier(1, &quot;stabilized weapon quirk&quot;);
<b class="fc">&nbsp;    private static final TargetRollModifier TH_PHY_LARGE = new TargetRollModifier(-2, &quot;target large vehicle&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The possible fire control types.
&nbsp;     * If you&#39;re adding a new one, add it here then make sure to add it to Princess.InitializeFireControls
&nbsp;     */
<b class="fc">&nbsp;    public enum FireControlType {</b>
<b class="fc">&nbsp;        Basic, </b>
<b class="fc">&nbsp;        Infantry,</b>
<b class="fc">&nbsp;        MultiTarget</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected final Princess owner;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor
&nbsp;     *
&nbsp;     * @param owningPrincess The {@link Princess} bot that utilizes this this class for computing firing solutions.
&nbsp;     */
<b class="fc">&nbsp;    public FireControl(final Princess owningPrincess) {</b>
<b class="fc">&nbsp;        owner = owningPrincess;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the movement modifier calculated by {@link Compute#getAttackerMovementModifier(IGame, int,
&nbsp;     * EntityMovementType)}.
&nbsp;     *
&nbsp;     * @param game            The {@link IGame} being played.
&nbsp;     * @param shooterId       The ID of the unit doing the shooting.
&nbsp;     * @param shooterMoveType The {@link EntityMovementType} of the unit doing the shooting.
&nbsp;     * @return The attacker movement modifier as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    @StaticWrapper()
&nbsp;    protected ToHitData getAttackerMovementModifier(final IGame game,
&nbsp;                                                    final int shooterId,
&nbsp;                                                    final EntityMovementType shooterMoveType) {
<b class="nc">&nbsp;        return Compute.getAttackerMovementModifier(game, shooterId, shooterMoveType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link Coords} computed by 
&nbsp;     * {@link Compute#getClosestFlightPath(int, Coords, Entity)}.
&nbsp;     *
&nbsp;     * @param shooterPosition The shooter&#39;s position.
&nbsp;     * @param targetAero      The aero unit being attacked.
&nbsp;     * @return The {@link Coords} from the target&#39;s flight path closest to the shooter.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    Coords getNearestPointInFlightPath(final Coords shooterPosition,
&nbsp;                                       final IAero targetAero) {
<b class="nc">&nbsp;        return Compute.getClosestFlightPath(-1, shooterPosition, (Entity)targetAero);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the movement modifier calculated by {@link Compute#getTargetMovementModifier(int, boolean, boolean,
&nbsp;     * IGame)}
&nbsp;     *
&nbsp;     * @param hexesMoved The number of hexes the target unit moved.
&nbsp;     * @param jumping    Set TRUE if the target jumped.
&nbsp;     * @param vtol       Set TRUE if the target is a {@link VTOL}.
&nbsp;     * @param game       The {@link IGame} being played.
&nbsp;     * @return The target movement modifier as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    @StaticWrapper()
&nbsp;    protected ToHitData getTargetMovementModifier(final int hexesMoved,
&nbsp;                                                  final boolean jumping,
&nbsp;                                                  final boolean vtol,
&nbsp;                                                  final IGame game) {
<b class="nc">&nbsp;        return Compute.getTargetMovementModifier(hexesMoved, jumping, vtol, game);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the toHit modifier common to both weapon and physical attacks
&nbsp;     *
&nbsp;     * @param shooter      The unit doing the shooting.
&nbsp;     * @param shooterState The state of the unit doing the shooting.
&nbsp;     * @param target       Who is being shot at.
&nbsp;     * @param targetState  The state of the target.
&nbsp;     * @param distance     Distance between shooter and target.
&nbsp;     * @param game         The game being played.  @return The estimated to hit modifiers.
&nbsp;     */
&nbsp;    ToHitData guessToHitModifierHelperForAnyAttack(final Entity shooter,
&nbsp;                                                   @Nullable EntityState shooterState,
&nbsp;                                                   final Targetable target,
&nbsp;                                                   @Nullable EntityState targetState,
&nbsp;                                                   final int distance,
&nbsp;                                                   final IGame game) {
&nbsp;
<b class="fc">&nbsp;        if (null == shooterState) {</b>
<b class="nc">&nbsp;            shooterState = new EntityState(shooter);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null == targetState) {</b>
<b class="nc">&nbsp;            targetState = new EntityState(target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t shoot if one of us is not on the board.
&nbsp;        // todo exception for off-board artillery.
<b class="fc">&nbsp;        if ((null == shooterState.getPosition()) || (null == targetState.getPosition())) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_NULL_POSITION);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the target in range at all?
<b class="fc">&nbsp;        final int maxRange = owner.getMaxWeaponRange(shooter, target.isAirborne());</b>
<b class="fc">&nbsp;        if (distance &gt; maxRange) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_RNG_TOO_FAR);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final ToHitData toHitData = new ToHitData();</b>
&nbsp;
&nbsp;        // If people are moving or lying down, there are consequences
<b class="fc">&nbsp;        toHitData.append(getAttackerMovementModifier(game, shooter.getId(), shooterState.getMovementType()));</b>
&nbsp;
&nbsp;        // Ground units attacking airborne aeros.
<b class="fc">&nbsp;        if (!shooterState.isAero() &amp;&amp; targetState.isAirborneAero()) {</b>
<b class="fc">&nbsp;            final IAero targetAero = (IAero) target;</b>
<b class="fc">&nbsp;            if (((Entity)targetAero).isNOE()) {</b>
<b class="fc">&nbsp;                final Coords closestInFlightPath = getNearestPointInFlightPath(shooterState.getPosition(), targetAero);</b>
<b class="fc">&nbsp;                final int aeroDistance = closestInFlightPath.distance(shooterState.getPosition());</b>
<b class="fc">&nbsp;                if (1 &gt;= aeroDistance) {</b>
<b class="fc">&nbsp;                    toHitData.addModifier(TH_TAR_AERO_NOE_ADJ);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    toHitData.addModifier(TH_TAR_AERO_NOE);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            toHitData.append(getTargetMovementModifier(targetState.getHexesMoved(), targetState.isJumping(),</b>
&nbsp;                                                       target instanceof VTOL, game));
&nbsp;        }
<b class="fc">&nbsp;        if (shooterState.isProne()) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_ATT_PRONE);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (targetState.isImmobile() &amp;&amp; !target.isHexBeingBombed()) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_IMMOBILE);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_STANDING_STILL)</b>
<b class="fc">&nbsp;            &amp;&amp; (EntityMovementType.MOVE_NONE == targetState.getMovementType())</b>
<b class="fc">&nbsp;            &amp;&amp; !targetState.isImmobile()</b>
&nbsp;            &amp;&amp; !((target instanceof Infantry) || (target instanceof VTOL) ||
&nbsp;                 (target instanceof GunEmplacement))) {
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_NO_MOVE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // did the target sprint?
<b class="fc">&nbsp;        if (EntityMovementType.MOVE_SPRINT == targetState.getMovementType()</b>
<b class="fc">&nbsp;            || EntityMovementType.MOVE_VTOL_SPRINT == targetState.getMovementType()) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_SPRINT);</b>
&nbsp;        }
&nbsp;
&nbsp;        // terrain modifiers, since &quot;compute&quot; won&#39;t let me do these remotely
<b class="fc">&nbsp;        final IHex targetHex = game.getBoard().getHex(targetState.getPosition());</b>
<b class="fc">&nbsp;        int woodsLevel = targetHex.terrainLevel(Terrains.WOODS);</b>
<b class="fc">&nbsp;        if (targetHex.terrainLevel(Terrains.JUNGLE) &gt; woodsLevel) {</b>
<b class="fc">&nbsp;            woodsLevel = targetHex.terrainLevel(Terrains.JUNGLE);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (1 &lt;= woodsLevel) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(woodsLevel, TH_WOODS);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final int smokeLevel = targetHex.terrainLevel(Terrains.SMOKE);</b>
<b class="fc">&nbsp;        if (1 &lt;= smokeLevel) {</b>
&nbsp;            // Smoke level doesn&#39;t necessary correspond to the to-hit modifier
&nbsp;            // even levels are light smoke, odd are heavy smoke
<b class="nc">&nbsp;            toHitData.addModifier((smokeLevel % 2) + 1, TH_SMOKE);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (targetState.isProne() &amp;&amp; (1 &lt; distance)) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_PRONE_RANGE);</b>
<b class="fc">&nbsp;        } else if (targetState.isProne() &amp;&amp; (1 == distance)) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_PRONE_ADJ);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (EntityMovementType.MOVE_SKID == targetState.getMovementType()) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_SKID);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final boolean isShooterInfantry = (shooter instanceof Infantry);</b>
<b class="fc">&nbsp;        if (!isShooterInfantry) {</b>
<b class="fc">&nbsp;            if (target instanceof BattleArmor) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_TAR_BA);</b>
<b class="fc">&nbsp;            } else if (target instanceof MechWarrior) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_TAR_MW);</b>
<b class="fc">&nbsp;            } else if (target instanceof Infantry) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_TAR_INF);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_ANTI_AIR) &amp;&amp;</b>
<b class="fc">&nbsp;            (target.isAirborne() || target.isAirborneVTOLorWIGE())) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_ANTI_AIR);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (shooter instanceof Mech) {</b>
<b class="fc">&nbsp;            final Mech shooterMech = (Mech) shooter;</b>
<b class="fc">&nbsp;            if (Mech.COCKPIT_INDUSTRIAL == shooterMech.getCockpitType()) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_INDUSTRIAL);</b>
<b class="fc">&nbsp;            } else if (Mech.COCKPIT_PRIMITIVE_INDUSTRIAL == shooterMech.getCockpitType()) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PRIMATIVE_INDUSTRIAL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (target instanceof Mech) {</b>
<b class="fc">&nbsp;            final Mech targetMech = (Mech) target;</b>
<b class="fc">&nbsp;            if (Mech.COCKPIT_SUPERHEAVY == targetMech.getCockpitType() ||</b>
<b class="fc">&nbsp;                Mech.COCKPIT_SUPERHEAVY_TRIPOD == targetMech.getCockpitType()) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_TAR_SUPER);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if ((target instanceof Dropship) &amp;&amp; !target.isAirborne()) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_TAR_GROUND_DS);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return toHitData;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes a rather poor guess as to what the to hit modifier will be with a physical attack.
&nbsp;     *
&nbsp;     * @param shooter      The unit doing the attacking.
&nbsp;     * @param shooterState The state of the unit doing the attacking.
&nbsp;     * @param target       Who is being attacked.
&nbsp;     * @param targetState  The state of the target.
&nbsp;     * @param attackType   The tyep of physical attack being made.
&nbsp;     * @param game         The game being played.
&nbsp;     * @return The estimated to hit modifiers.
&nbsp;     */
&nbsp;    ToHitData guessToHitModifierPhysical(final Entity shooter,
&nbsp;                                         @Nullable EntityState shooterState,
&nbsp;                                         final Targetable target,
&nbsp;                                         @Nullable EntityState targetState,
&nbsp;                                         final PhysicalAttackType attackType,
&nbsp;                                         final IGame game) {
&nbsp;
&nbsp;        // todo weapons, frenzy (pg 144) &amp; vehicle charges.
&nbsp;        // todo heat mods to piloting?
&nbsp;
<b class="fc">&nbsp;        if (!(shooter instanceof Mech)) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_PHY_NOT_MECH);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (null == shooterState) {</b>
<b class="nc">&nbsp;            shooterState = new EntityState(shooter);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null == targetState) {</b>
<b class="nc">&nbsp;            targetState = new EntityState(target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // We can hit someone who isn&#39;t standing right next to us.
<b class="fc">&nbsp;        final int distance = shooterState.getPosition().distance(targetState.getPosition());</b>
<b class="fc">&nbsp;        if (1 &lt; distance) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_PHY_TOO_FAR);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the general to hit modifiers.
<b class="fc">&nbsp;        final ToHitData toHitData = new ToHitData();</b>
<b class="fc">&nbsp;        toHitData.append(guessToHitModifierHelperForAnyAttack(shooter, shooterState, target, targetState, distance,</b>
&nbsp;                                                              game));
<b class="fc">&nbsp;        if (TargetRoll.IMPOSSIBLE == toHitData.getValue() || TargetRoll.AUTOMATIC_FAIL == toHitData.getValue()) {</b>
<b class="nc">&nbsp;            return toHitData;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check if target is within arc
&nbsp;        final int arc;
<b class="fc">&nbsp;        if (PhysicalAttackType.LEFT_PUNCH == attackType) {</b>
<b class="fc">&nbsp;            arc = Compute.ARC_LEFTARM;</b>
<b class="fc">&nbsp;        } else if (PhysicalAttackType.RIGHT_PUNCH == attackType) {</b>
<b class="fc">&nbsp;            arc = Compute.ARC_RIGHTARM;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            arc = Compute.ARC_FORWARD; // assume kick</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!isInArc(shooterState.getPosition(), shooterState.getSecondaryFacing(), targetState.getPosition(), arc)) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_PHY_NOT_IN_ARC);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check elevation difference.
<b class="fc">&nbsp;        final IHex attackerHex = game.getBoard().getHex(shooterState.getPosition());</b>
<b class="fc">&nbsp;        final IHex targetHex = game.getBoard().getHex(targetState.getPosition());</b>
<b class="fc">&nbsp;        final int attackerElevation = shooter.getElevation() + attackerHex.getLevel();</b>
<b class="fc">&nbsp;        final int attackerHeight = shooter.relHeight() + attackerHex.getLevel();</b>
<b class="fc">&nbsp;        final int targetElevation = target.getElevation() + targetHex.getLevel();</b>
<b class="fc">&nbsp;        final int targetHeight = targetElevation + target.getHeight();</b>
<b class="fc">&nbsp;        if (attackType.isPunch()) {</b>
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_NO_ARMS)) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_P_NO_ARMS_QUIRK);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if ((attackerHeight &lt; targetElevation) || (attackerHeight &gt; targetHeight)) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_TOO_MUCH_ELEVATION);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (shooterState.isProne()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_P_TAR_PRONE);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (target instanceof Infantry) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_P_TAR_INF);</b>
&nbsp;            }
<b class="fc">&nbsp;            final int armLocation = PhysicalAttackType.RIGHT_PUNCH == attackType ? Mech.LOC_RARM : Mech.LOC_LARM;</b>
<b class="fc">&nbsp;            if (shooter.isLocationBad(armLocation)) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_P_NO_ARM);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_SHOULDER, armLocation)) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_P_NO_SHOULDER);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Base to hit chance.
<b class="fc">&nbsp;            toHitData.addModifier(shooter.getCrew().getPiloting(), TH_PHY_BASE);</b>
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_UPPER_ARM, armLocation)) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_P_UPPER_ARM);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_LOWER_ARM, armLocation)) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_P_LOWER_ARM);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_HAND, armLocation)) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_P_HAND);</b>
&nbsp;            }
<b class="fc">&nbsp;        } else { // assuming kick</b>
&nbsp;
<b class="fc">&nbsp;            if (shooterState.isProne()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_K_PRONE);</b>
&nbsp;            }
<b class="fc">&nbsp;            if ((attackerElevation &lt; targetElevation) || (attackerElevation &gt; targetHeight)) {</b>
<b class="nc">&nbsp;                return new ToHitData(TH_PHY_TOO_MUCH_ELEVATION);</b>
&nbsp;            }
<b class="fc">&nbsp;            if ((shooter).hasHipCrit()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_PHY_K_HIP);</b>
&nbsp;            }
<b class="fc">&nbsp;            final int legLocation = PhysicalAttackType.RIGHT_KICK == attackType ? Mech.LOC_RLEG : Mech.LOC_LLEG;</b>
&nbsp;
&nbsp;            // Base to hit chance.
<b class="fc">&nbsp;            toHitData.addModifier(shooter.getCrew().getPiloting() - 2, TH_PHY_BASE);</b>
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_UPPER_LEG, legLocation)) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_K_UPPER_LEG);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_LOWER_LEG, legLocation)) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_K_LOWER_LEG);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_FOOT, legLocation)) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_K_FOOT);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (target instanceof Infantry) {</b>
<b class="fc">&nbsp;                if (0 == distance) {</b>
<b class="fc">&nbsp;                    toHitData.addModifier(TH_PHY_K_INF);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new ToHitData(TH_PHY_K_INF_RNG);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_PHYSICAL_ATTACK_PSR)) {</b>
<b class="fc">&nbsp;            if (EntityWeightClass.WEIGHT_LIGHT == shooter.getWeightClass()) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_LIGHT);</b>
<b class="fc">&nbsp;            } else if (EntityWeightClass.WEIGHT_MEDIUM == shooter.getWeightClass()) {</b>
<b class="fc">&nbsp;                toHitData.addModifier(TH_PHY_MEDIUM);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if ((target instanceof LargeSupportTank) || (target instanceof FixedWingSupport) ||</b>
<b class="nc">&nbsp;            (target instanceof Dropship &amp;&amp; target.isAirborne())) {</b>
<b class="nc">&nbsp;            toHitData.addModifier(TH_PHY_LARGE);</b>
&nbsp;        }
<b class="fc">&nbsp;        final Mech shooterMech = (Mech) shooter;</b>
<b class="fc">&nbsp;        if (Mech.COCKPIT_SUPERHEAVY == shooterMech.getCockpitType() ||</b>
<b class="fc">&nbsp;            Mech.COCKPIT_SUPERHEAVY_TRIPOD == shooterMech.getCockpitType()) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_PHY_SUPER);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT) &amp;&amp; (3 &lt; shooter.getCrew().getPiloting())) {</b>
<b class="fc">&nbsp;            toHitData.addModifier(TH_PHY_EASY_PILOT);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return toHitData;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of {@link Compute#isInArc(Coords, int, Targetable, int)}.
&nbsp;     *
&nbsp;     * @param shooterPosition The current {@link Coords} of the shooter.
&nbsp;     * @param shooterFacing   The shooter&#39;s current facing.
&nbsp;     * @param targetPosition  The current {@link Coords} of the target.
&nbsp;     * @param weaponArc       The arc of the weapon being fired.
&nbsp;     * @return TRUE if the target falls within the weapon&#39;s firing arc.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    protected boolean isInArc(final Coords shooterPosition,
&nbsp;                              final int shooterFacing,
&nbsp;                              final Coords targetPosition,
&nbsp;                              final int weaponArc) {
<b class="nc">&nbsp;        return Compute.isInArc(shooterPosition, shooterFacing, targetPosition, weaponArc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of {@link LosEffects#calculateLos(IGame, int, Targetable, Coords, Coords, boolean)}.
&nbsp;     *
&nbsp;     * @param game            The {@link IGame} being played.
&nbsp;     * @param shooterId       The id of the shooting unit.
&nbsp;     * @param target          The unit being shot at as a {@link Targetable} object.
&nbsp;     * @param shooterPosition The current {@link Coords} of the shooter.
&nbsp;     * @param targetPosition  The current {@link Coords} of the target.
&nbsp;     * @param spotting        Set TRUE if the shooter is simply spotting for indrect fire.
&nbsp;     * @return The resulting {@link LosEffects}.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    LosEffects getLosEffects(final IGame game,
&nbsp;                             final int shooterId,
&nbsp;                             final Targetable target,
&nbsp;                             final Coords shooterPosition,
&nbsp;                             final Coords targetPosition,
&nbsp;                             final boolean spotting) {
<b class="nc">&nbsp;        return LosEffects.calculateLos(game, shooterId, target, shooterPosition, targetPosition, spotting);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of {@link Compute#getSwarmMekBaseToHit(Entity, Entity, IGame)}.
&nbsp;     *
&nbsp;     * @param attacker The attacking {@link Entity}.
&nbsp;     * @param defender The target of the attack.
&nbsp;     * @param game     The game being played.
&nbsp;     * @return The to hit modifiers as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    private ToHitData getSwarmMekBaseToHit(final Entity attacker,
&nbsp;                                           final Entity defender,
&nbsp;                                           final IGame game) {
<b class="nc">&nbsp;        return Compute.getSwarmMekBaseToHit(attacker, defender, game);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of {@link Compute#getLegAttackBaseToHit(Entity, Entity, IGame)}.
&nbsp;     *
&nbsp;     * @param attacker The attacking {@link Entity}.
&nbsp;     * @param defender The target of the attack.
&nbsp;     * @param game     The game being played.
&nbsp;     * @return The to hit modifiers as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    private ToHitData getLegAttackBaseToHit(final Entity attacker,
&nbsp;                                            final Entity defender,
&nbsp;                                            final IGame game) {
<b class="nc">&nbsp;        return Compute.getLegAttackBaseToHit(attacker, defender, game);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of {@link Compute#getInfantryRangeMods(int, InfantryWeapon, InfantryWeapon, boolean)}.
&nbsp;     *
&nbsp;     * @param distance The distance to the target.
&nbsp;     * @param weapon   The {@link InfantryWeapon} being fired.
&nbsp;     * @return The to hit modifiers as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    private ToHitData getInfantryRangeMods(final int distance,
&nbsp;                                           final InfantryWeapon weapon,
&nbsp;                                           final InfantryWeapon secondary,
&nbsp;                                           final boolean underwater) {
<b class="nc">&nbsp;        return Compute.getInfantryRangeMods(distance, weapon, secondary, underwater);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of {@link Compute#getDamageWeaponMods(Entity, Mounted)}.
&nbsp;     *
&nbsp;     * @param attacker The attacking {@link Entity}.
&nbsp;     * @param weapon   The {@link Mounted} weapon being fired.
&nbsp;     * @return The to hit modifiers as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    @StaticWrapper
&nbsp;    private ToHitData getDamageWeaponMods(final Entity attacker,
&nbsp;                                          final Mounted weapon) {
<b class="fc">&nbsp;        return Compute.getDamageWeaponMods(attacker, weapon);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isLargeTarget(final Targetable target) {
<b class="fc">&nbsp;        if ((target instanceof LargeSupportTank) || (target instanceof FixedWingSupport) ||</b>
<b class="nc">&nbsp;            (target instanceof Dropship &amp;&amp; target.isAirborne())) {</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!(target instanceof Mech)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final Mech targetMech = (Mech) target;</b>
<b class="fc">&nbsp;        return (Mech.COCKPIT_SUPERHEAVY == targetMech.getCockpitType()) ||</b>
<b class="fc">&nbsp;               (Mech.COCKPIT_SUPERHEAVY_TRIPOD == targetMech.getCockpitType());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes an educated guess as to the to hit modifier with a weapon attack.
&nbsp;     * Does not actually place unit into desired position, because that is
&nbsp;     * exceptionally slow. Most of this is copied from WeaponAttack.
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The {@link Entity} doing the shooting.
&nbsp;     * @param shooterState
&nbsp;     *            The {@link EntityState} of the unit doing the shooting.
&nbsp;     * @param target
&nbsp;     *            The {@link Targetable} being shot at.
&nbsp;     * @param targetState
&nbsp;     *            The {@link EntityState} of the unit being shot at.
&nbsp;     * @param weapon
&nbsp;     *            The weapon being fired as a {@link Mounted} object.
&nbsp;     * @param game
&nbsp;     *            The {@link IGame being played.}
&nbsp;     * @return The to hit modifiers for the given weapon firing at the given
&nbsp;     *         target as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    ToHitData guessToHitModifierForWeapon(final Entity shooter,
&nbsp;                                          @Nullable EntityState shooterState,
&nbsp;                                          final Targetable target,
&nbsp;                                          @Nullable EntityState targetState,
&nbsp;                                          final Mounted weapon,
&nbsp;                                          final IGame game) {
&nbsp;
<b class="fc">&nbsp;        if (null == shooterState) {</b>
<b class="nc">&nbsp;            shooterState = new EntityState(shooter);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null == targetState) {</b>
<b class="nc">&nbsp;            targetState = new EntityState(target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // First check if the shot is impossible
<b class="fc">&nbsp;        if (!weapon.canFire()) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_WEAP_CANNOT_FIRE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Make sure we have ammo.
<b class="fc">&nbsp;        final WeaponType weaponType = (WeaponType) weapon.getType();</b>
<b class="fc">&nbsp;        if (AmmoType.T_NA != weaponType.getAmmoType()) {</b>
<b class="fc">&nbsp;            if (null == weapon.getLinked()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_NO_AMMO);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (0 == weapon.getLinked().getUsableShotsLeft()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_NO_AMMO);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (shooterState.isProne()) {</b>
&nbsp;            // Cannot fire if we cannot at least prop ourselves up.
<b class="fc">&nbsp;            if (shooter.isLocationBad(Mech.LOC_LARM) &amp;&amp; shooter.isLocationBad(Mech.LOC_RARM)) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_PRONE_ARMLESS);</b>
&nbsp;            }
&nbsp;            // Cannot fire weapons mounted in the propping arm.
<b class="fc">&nbsp;            if ((Mech.LOC_LARM == weapon.getLocation() || Mech.LOC_RARM == weapon.getLocation())</b>
<b class="fc">&nbsp;                &amp;&amp; shooter.isLocationBad(weapon.getLocation())) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_ARM_PROP);</b>
&nbsp;            }
&nbsp;            // Cannot fire leg-mounted weapons while prone.)
<b class="fc">&nbsp;            if ((Mech.LOC_LLEG == weapon.getLocation()) || (Mech.LOC_RLEG == weapon.getLocation())) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_PRONE_LEG);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Check if torso twists affect weapon
<b class="fc">&nbsp;        int shooterFacing = shooterState.getFacing();</b>
<b class="fc">&nbsp;        if (shooter.isSecondaryArcWeapon(shooter.getEquipmentNum(weapon))) {</b>
<b class="nc">&nbsp;            shooterFacing = shooterState.getSecondaryFacing();</b>
&nbsp;        }
<b class="fc">&nbsp;        final boolean inArc = isInArc(shooterState.getPosition(), shooterFacing, targetState.getPosition(),</b>
<b class="fc">&nbsp;                                      shooter.getWeaponArc(shooter.getEquipmentNum(weapon)));</b>
<b class="fc">&nbsp;        if (!inArc) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_WEAPON_NO_ARC);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check range.
<b class="fc">&nbsp;        int distance = shooterState.getPosition().distance(targetState.getPosition());</b>
&nbsp;
&nbsp;        // Ground units attacking airborne aero considerations.
<b class="fc">&nbsp;        if (targetState.isAirborneAero() &amp;&amp; !shooterState.isAero()) {</b>
&nbsp;
&nbsp;            // If the aero is attacking me, there is no range.
<b class="fc">&nbsp;            if (target.getTargetId() == shooter.getId()) {</b>
<b class="fc">&nbsp;                distance = 0;</b>
&nbsp;            } else {
&nbsp;                // Take into account altitude.
<b class="fc">&nbsp;                distance += 2 * target.getAltitude();</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        int range = RangeType.rangeBracket(distance, weaponType.getRanges(weapon),</b>
<b class="fc">&nbsp;                                           game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE),</b>
<b class="fc">&nbsp;                                           game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE));</b>
<b class="fc">&nbsp;        if (RangeType.RANGE_OUT == range) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_OUT_OF_RANGE);</b>
<b class="fc">&nbsp;        } else if ((RangeType.RANGE_MINIMUM == range) &amp;&amp; targetState.isAirborneAero()) {</b>
<b class="fc">&nbsp;            range = RangeType.RANGE_SHORT;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Cannot shoot at 0 range infantry unless shooter is also infantry.
<b class="fc">&nbsp;        final boolean isShooterInfantry = (shooter instanceof Infantry);</b>
<b class="fc">&nbsp;        if ((0 == distance) &amp;&amp; (!isShooterInfantry) &amp;&amp; !(weaponType instanceof StopSwarmAttack) &amp;&amp;</b>
<b class="fc">&nbsp;            !targetState.isAirborneAero()) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_INF_ZERO_RNG);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Handle stopping a swarm attack.
<b class="fc">&nbsp;        if (weaponType instanceof StopSwarmAttack) {</b>
<b class="fc">&nbsp;            if (Entity.NONE == shooter.getSwarmTargetId()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_STOP_SWARM_INVALID);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return new ToHitData(TH_SWARM_STOPPED);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Get the mods that apply to all attacks.
<b class="fc">&nbsp;        final ToHitData baseMods = guessToHitModifierHelperForAnyAttack(shooter,</b>
&nbsp;                                                                        shooterState,
&nbsp;                                                                        target,
&nbsp;                                                                        targetState,
&nbsp;                                                                        distance,
&nbsp;                                                                        game);
<b class="fc">&nbsp;        if (TargetRoll.IMPOSSIBLE == baseMods.getValue() || TargetRoll.AUTOMATIC_FAIL == baseMods.getValue()) {</b>
<b class="nc">&nbsp;            return baseMods;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Base to hit is gunnery skill
<b class="fc">&nbsp;        final ToHitData toHit = new ToHitData(shooter.getCrew().getGunnery(), TH_GUNNERY);</b>
<b class="fc">&nbsp;        toHit.append(baseMods);</b>
&nbsp;
&nbsp;        // There is kindly already a class that will calculate line of sight for me
&nbsp;        // todo take into account spotting for indirect fire.
<b class="fc">&nbsp;        final LosEffects losEffects = getLosEffects(game, shooter.getId(), target, shooterState.getPosition(),</b>
<b class="fc">&nbsp;                                                    targetState.getPosition(), false);</b>
&nbsp;
&nbsp;        // water is a separate los effect
<b class="fc">&nbsp;        final IHex targetHex = game.getBoard().getHex(targetState.getPosition());</b>
<b class="fc">&nbsp;        Entity targetEntity = null;</b>
<b class="fc">&nbsp;        if (target instanceof Entity) {</b>
<b class="fc">&nbsp;            targetEntity = (Entity) target;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null != targetEntity) {</b>
<b class="fc">&nbsp;            if (targetHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                &amp;&amp; (1 == targetHex.terrainLevel(Terrains.WATER))</b>
<b class="nc">&nbsp;                &amp;&amp; (0 &lt; targetEntity.height())) {</b>
<b class="nc">&nbsp;                losEffects.setTargetCover(losEffects.getTargetCover() | LosEffects.COVER_HORIZONTAL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Can we still hit after taking into account LoS?
<b class="fc">&nbsp;        toHit.append(losEffects.losModifiers(game));</b>
<b class="fc">&nbsp;        if ((TargetRoll.IMPOSSIBLE == toHit.getValue()) || (TargetRoll.AUTOMATIC_FAIL == toHit.getValue())) {</b>
<b class="nc">&nbsp;            return toHit; // you can&#39;t hit what you can&#39;t see</b>
&nbsp;        }
&nbsp;
&nbsp;        // Handle sensor damage.  Mek sensor damage is handled under general damage mods.
<b class="fc">&nbsp;        if (shooter instanceof Tank) {</b>
<b class="fc">&nbsp;            final int sensors = ((Tank) shooter).getSensorHits();</b>
<b class="fc">&nbsp;            if (0 &lt; sensors) {</b>
<b class="fc">&nbsp;                toHit.addModifier(sensors, TH_SENSORS);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Handle mechs being swarmed.
<b class="fc">&nbsp;        if (targetEntity instanceof Mech) {</b>
<b class="fc">&nbsp;            if (Infantry.SWARM_MEK.equals(weaponType.getInternalName())) {</b>
<b class="nc">&nbsp;                toHit.append(getSwarmMekBaseToHit(shooter, targetEntity, game));</b>
&nbsp;            }
<b class="fc">&nbsp;            if (Infantry.LEG_ATTACK.equals(weapon.getType().getInternalName())) {</b>
<b class="nc">&nbsp;                toHit.append(getLegAttackBaseToHit(shooter, targetEntity, game));</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if ((TargetRoll.IMPOSSIBLE == toHit.getValue()) || (TargetRoll.AUTOMATIC_FAIL == toHit.getValue())) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now deal with range effects
<b class="fc">&nbsp;        if (!weaponType.hasFlag(WeaponType.F_INFANTRY)) {</b>
<b class="fc">&nbsp;            if (RangeType.RANGE_SHORT == range) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_SHORT_RANGE);</b>
<b class="fc">&nbsp;            } else if (RangeType.RANGE_MEDIUM == range) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_MEDIUM_RANGE);</b>
<b class="fc">&nbsp;            } else if (RangeType.RANGE_LONG == range) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_LONG_RANGE);</b>
<b class="fc">&nbsp;            } else if (RangeType.RANGE_EXTREME == range) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_EXTREME_RANGE);</b>
<b class="fc">&nbsp;            } else if (RangeType.RANGE_MINIMUM == range) {</b>
<b class="fc">&nbsp;                toHit.addModifier((weaponType.getMinimumRange() - distance) + 1, TH_MINIMUM_RANGE);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            toHit.append(getInfantryRangeMods(distance, (InfantryWeapon) weapon.getType(),</b>
<b class="nc">&nbsp;                                              isShooterInfantry ? ((Infantry) shooter).getSecondaryWeapon() : null,</b>
<b class="nc">&nbsp;                                              ILocationExposureStatus.WET == shooter.getLocationStatus(weapon.getLocation())));</b>
&nbsp;        }
&nbsp;
&nbsp;        // let us not forget about heat
<b class="fc">&nbsp;        if (0 != shooter.getHeatFiringModifier()) {</b>
<b class="fc">&nbsp;            toHit.addModifier(shooter.getHeatFiringModifier(), TH_HEAT);</b>
&nbsp;        }
&nbsp;
&nbsp;        // and damage
<b class="fc">&nbsp;        toHit.append(getDamageWeaponMods(shooter, weapon));</b>
&nbsp;
&nbsp;        // weapon mods
<b class="fc">&nbsp;        if (0 != weaponType.getToHitModifier()) {</b>
<b class="fc">&nbsp;            toHit.addModifier(weaponType.getToHitModifier(), TH_WEAPON_MOD);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Target size.
<b class="fc">&nbsp;        if (isLargeTarget(target)) {</b>
<b class="fc">&nbsp;            toHit.addModifier(TH_RNG_LARGE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // ammo mods
<b class="fc">&nbsp;        if (AmmoType.T_NA != weaponType.getAmmoType()</b>
<b class="fc">&nbsp;            &amp;&amp; (null != weapon.getLinked())</b>
<b class="fc">&nbsp;            &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) weapon.getLinked().getType();</b>
<b class="fc">&nbsp;            if ((null != ammoType) &amp;&amp; (0 != ammoType.getToHitModifier())) {</b>
<b class="fc">&nbsp;                toHit.addModifier(ammoType.getToHitModifier(), TH_AMMO_MOD);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // targeting computer
<b class="fc">&nbsp;        if (shooter.hasTargComp() &amp;&amp; weaponType.hasFlag(WeaponType.F_DIRECT_FIRE)) {</b>
<b class="fc">&nbsp;            toHit.addModifier(TH_TARGETTING_COMP);</b>
&nbsp;        }
&nbsp;
&nbsp;        // shooter quirks
<b class="fc">&nbsp;        if (RangeType.RANGE_SHORT == range) {</b>
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_S)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_IMP_TARG_SHORT);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_VAR_RNG_TARG_SHORT_AT_SHORT);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_VAR_RNG_TARG_LONG_AT_SHORT);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_S)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_POOR_TARG_SHORT);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (RangeType.RANGE_MEDIUM == range) {</b>
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_M)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_IMP_TARG_MEDIUM);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_M)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_POOR_TARG_MEDIUM);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (RangeType.RANGE_LONG == range) {</b>
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_L)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_IMP_TARG_LONG);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_VAR_RNG_TARG_SHORT_AT_LONG);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_VAR_RNG_TARG_LONG_AT_LONG);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_L)) {</b>
<b class="fc">&nbsp;                toHit.addModifier(TH_POOR_TARG_LONG);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // weapon quirks
<b class="fc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_POS_ACCURATE)) {</b>
<b class="fc">&nbsp;            toHit.addModifier(TH_ACCURATE_WEAP);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_NEG_INACCURATE)) {</b>
<b class="fc">&nbsp;            toHit.addModifier(TH_INACCURATE_WEAP);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_POS_STABLE_WEAPON) &amp;&amp; (EntityMovementType.MOVE_RUN == shooter.moved)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(TH_STABLE_WEAP);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes an educated guess as to the to hit modifier by an aerospace unit
&nbsp;     * flying on a ground map doing a strike attack on a unit
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The {@link Entity} doing the shooting.
&nbsp;     * @param shooterState
&nbsp;     *            The {@link EntityState} of the unit doing the shooting.
&nbsp;     * @param target
&nbsp;     *            The {@link megamek.common.Targetable} being shot at.
&nbsp;     * @param targetState
&nbsp;     *            The {@link megamek.client.bot.princess.EntityState} of the
&nbsp;     *            unit being shot at.
&nbsp;     * @param flightPath
&nbsp;     *            The path the shooter is taking.
&nbsp;     * @param weapon
&nbsp;     *            The weapon being fired as a {@link megamek.common.Mounted}
&nbsp;     *            object.
&nbsp;     * @param game
&nbsp;     *            The {@link megamek.common.IGame being played.}
&nbsp;     * @param assumeUnderFlightPlan
&nbsp;     *            Set TRUE to assume that the target falls under the given
&nbsp;     *            flight path.
&nbsp;     * @return The to hit modifiers for the given weapon firing at the given
&nbsp;     *         target as a {@link ToHitData} object.
&nbsp;     */
&nbsp;    ToHitData guessAirToGroundStrikeToHitModifier(final Entity shooter,
&nbsp;                                                  @Nullable EntityState shooterState,
&nbsp;                                                  final Targetable target,
&nbsp;                                                  @Nullable EntityState targetState,
&nbsp;                                                  final MovePath flightPath,
&nbsp;                                                  final Mounted weapon,
&nbsp;                                                  final IGame game,
&nbsp;                                                  final boolean assumeUnderFlightPlan) {
&nbsp;
<b class="fc">&nbsp;        if (null == targetState) {</b>
<b class="nc">&nbsp;            targetState = new EntityState(target);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null == shooterState) {</b>
<b class="nc">&nbsp;            shooterState = new EntityState(shooter);</b>
&nbsp;        }
&nbsp;
&nbsp;        // first check if the shot is impossible
<b class="fc">&nbsp;        if (!weapon.canFire()) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_WEAP_CANNOT_FIRE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the weapon loaded?
<b class="fc">&nbsp;        if (AmmoType.T_NA != ((WeaponType) weapon.getType()).ammoType) {</b>
<b class="fc">&nbsp;            if (null == weapon.getLinked()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_NO_AMMO);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (0 == weapon.getLinked().getUsableShotsLeft()) {</b>
<b class="fc">&nbsp;                return new ToHitData(TH_WEAP_NO_AMMO);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check if target is even under our path
<b class="fc">&nbsp;        if (!assumeUnderFlightPlan &amp;&amp; !isTargetUnderFlightPath(flightPath, targetState)) {</b>
<b class="fc">&nbsp;            return new ToHitData(TH_AIR_STRIKE_PATH);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Base to hit is gunnery skill
<b class="fc">&nbsp;        final ToHitData tohit = new ToHitData(shooter.getCrew().getGunnery(), TH_GUNNERY);</b>
&nbsp;
&nbsp;        // Get general modifiers.
<b class="fc">&nbsp;        tohit.append(guessToHitModifierHelperForAnyAttack(shooter, shooterState, target, targetState, 0, game));</b>
&nbsp;
&nbsp;        // Additional penalty due to strike attack
<b class="fc">&nbsp;        tohit.addModifier(TH_AIR_STRIKE);</b>
&nbsp;
<b class="fc">&nbsp;        return tohit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a target lies under a move path, to see if an aero unit can attack it.
&nbsp;     *
&nbsp;     * @param flightPath  move path to check
&nbsp;     * @param targetState used for targets position
&nbsp;     * @return TRUE if the target is under the path.
&nbsp;     */
&nbsp;    boolean isTargetUnderFlightPath(final MovePath flightPath,
&nbsp;                                    final EntityState targetState) {
&nbsp;
<b class="fc">&nbsp;        final Coords targetCoords = targetState.getPosition();</b>
<b class="fc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; step = flightPath.getSteps(); step.hasMoreElements(); ) {</b>
<b class="fc">&nbsp;            final Coords stepCoords = step.nextElement().getPosition();</b>
<b class="fc">&nbsp;            if (targetCoords.equals(stepCoords)) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Mostly for debugging, this returns a non-null string that describes how
&nbsp;     * the guess has failed to be perfectly accurate. or null if perfectly
&nbsp;     * accurate
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param target
&nbsp;     *            The unit being shot at.
&nbsp;     * @param weapon
&nbsp;     *            The weapon being fired.
&nbsp;     * @param game
&nbsp;     *            The game being played.
&nbsp;     * @return A description of the differences or NULL if there are none.
&nbsp;     */
&nbsp;    private String checkGuess(final Entity shooter,
&nbsp;                              final Targetable target,
&nbsp;                              final Mounted weapon,
&nbsp;                              final IGame game) {
&nbsp;
&nbsp;        // This really should only be done for debugging purposes.  Regular play should avoid the overhead.
<b class="nc">&nbsp;        if (!LogLevel.DEBUG.equals(owner.getVerbosity())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Don&#39;t bother checking these as the guesses are minimal (or non-existant).
<b class="nc">&nbsp;        if (shooter.isAero() || (null == shooter.getPosition()) || (null == target.getPosition())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String ret = &quot;&quot;;</b>
<b class="nc">&nbsp;        final WeaponFireInfo guessInfo = new WeaponFireInfo(shooter,</b>
&nbsp;                                                            new EntityState(shooter),
&nbsp;                                                            target,
&nbsp;                                                            null,
&nbsp;                                                            weapon,
&nbsp;                                                            game,
&nbsp;                                                            true,
&nbsp;                                                            owner);
<b class="nc">&nbsp;        final WeaponFireInfo accurateInfo = new WeaponFireInfo(shooter, target, weapon, game, false, owner);</b>
&nbsp;
<b class="nc">&nbsp;        if (guessInfo.getToHit().getValue() != accurateInfo.getToHit().getValue()) {</b>
<b class="nc">&nbsp;            ret += &quot;Incorrect To Hit prediction, weapon &quot; + weapon.getName() + &quot; (&quot; + shooter.getChassis() + &quot; vs &quot; +</b>
<b class="nc">&nbsp;                   target.getDisplayName() + &quot;)&quot; + &quot;:\n&quot;;</b>
<b class="nc">&nbsp;            ret += &quot; Guess: &quot; + Integer.toString(guessInfo.getToHit().getValue()) + &quot; &quot; +</b>
<b class="nc">&nbsp;                   guessInfo.getToHit().getDesc() + &quot;\n&quot;;</b>
<b class="nc">&nbsp;            ret += &quot; Real:  &quot; + Integer.toString(accurateInfo.getToHit().getValue()) + &quot; &quot; +</b>
<b class="nc">&nbsp;                   accurateInfo.getToHit().getDesc() + &quot;\n&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Mostly for debugging, this returns a non-null string that describes how
&nbsp;     * the guess on a physical attack failed to be perfectly accurate, or null
&nbsp;     * if accurate
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param target
&nbsp;     *            The unit being shot at.
&nbsp;     * @param attackType
&nbsp;     *            The attack being made.
&nbsp;     * @param game
&nbsp;     *            The game being played.
&nbsp;     * @return A description of the differences or NULL if there are none.
&nbsp;     */
&nbsp;    private String checkGuessPhysical(final Entity shooter,
&nbsp;                                      final Targetable target,
&nbsp;                                      final PhysicalAttackType attackType,
&nbsp;                                      final IGame game) {
&nbsp;
&nbsp;        // This really should only be done for debugging purposes. Regular play
&nbsp;        // should avoid the overhead.
<b class="nc">&nbsp;        if (!LogLevel.DEBUG.equals(owner.getVerbosity())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // only mechs can do physicals
<b class="nc">&nbsp;        if (!(shooter instanceof Mech)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String ret = &quot;&quot;;</b>
<b class="nc">&nbsp;        if (null == shooter.getPosition()) {</b>
<b class="nc">&nbsp;            return &quot;Shooter has NULL coordinates!&quot;;</b>
<b class="nc">&nbsp;        } else if (null == target.getPosition()) {</b>
<b class="nc">&nbsp;            return &quot;Target has NULL coordinates!&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final PhysicalInfo guessInfo = new PhysicalInfo(shooter, null, target, null, attackType, game, owner, true);</b>
<b class="nc">&nbsp;        final PhysicalInfo accurateInfo = new PhysicalInfo(shooter, target, attackType, game, owner, false);</b>
<b class="nc">&nbsp;        if (guessInfo.getHitData().getValue() != accurateInfo.getHitData().getValue()) {</b>
<b class="nc">&nbsp;            ret += &quot;Incorrect To Hit prediction, physical attack &quot; + attackType.name() + &quot;:\n&quot;;</b>
<b class="nc">&nbsp;            ret += &quot; Guess: &quot; + Integer.toString(guessInfo.getHitData().getValue()) + &quot; &quot; + guessInfo.getHitData()</b>
<b class="nc">&nbsp;                                                                                                     .getDesc() +</b>
&nbsp;                   &quot;\n&quot;;
<b class="nc">&nbsp;            ret += &quot; Real:  &quot; + Integer.toString(accurateInfo.getHitData().getValue()) + &quot; &quot; +</b>
<b class="nc">&nbsp;                   accurateInfo.getHitData().getDesc() + &quot;\n&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Mostly for debugging, this returns a non-null string that describes how
&nbsp;     * any possible guess has failed to be perfectly accurate. or null if
&nbsp;     * perfect
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param game
&nbsp;     *            The game being played.
&nbsp;     * @return A description of the differences or NULL if there are none.
&nbsp;     */
&nbsp;    String checkAllGuesses(final Entity shooter,
&nbsp;                           final IGame game) {
&nbsp;
&nbsp;        // This really should only be done for debugging purposes.  Regular play should avoid the overhead.
<b class="nc">&nbsp;        if (!LogLevel.DEBUG.equals(owner.getVerbosity())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final StringBuilder ret = new StringBuilder();</b>
<b class="nc">&nbsp;        final List&lt;Targetable&gt; enemies = getTargetableEnemyEntities(shooter, game, owner.getFireControlState());</b>
<b class="nc">&nbsp;        for (final Targetable enemy : enemies) {</b>
<b class="nc">&nbsp;            for (final Mounted weapon : shooter.getWeaponList()) {</b>
<b class="nc">&nbsp;                final String shootingCheck = checkGuess(shooter, enemy, weapon, game);</b>
<b class="nc">&nbsp;                if (null != shootingCheck) {</b>
<b class="nc">&nbsp;                    ret.append(shootingCheck);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            String physicalCheck;
<b class="nc">&nbsp;            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.RIGHT_KICK, game);</b>
<b class="nc">&nbsp;            if (null != physicalCheck) {</b>
<b class="nc">&nbsp;                ret.append(physicalCheck);</b>
&nbsp;            }
<b class="nc">&nbsp;            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.LEFT_KICK, game);</b>
<b class="nc">&nbsp;            if (null != physicalCheck) {</b>
<b class="nc">&nbsp;                ret.append(physicalCheck);</b>
&nbsp;            }
<b class="nc">&nbsp;            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.RIGHT_PUNCH, game);</b>
<b class="nc">&nbsp;            if (null != physicalCheck) {</b>
<b class="nc">&nbsp;                ret.append(physicalCheck);</b>
&nbsp;            }
<b class="nc">&nbsp;            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.LEFT_PUNCH, game);</b>
<b class="nc">&nbsp;            if (null != physicalCheck) {</b>
<b class="nc">&nbsp;                ret.append(physicalCheck);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return ret.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * calculates the &#39;utility&#39; of a firing plan. override this function if you
&nbsp;     * have a better idea about what firing plans are good
&nbsp;     *
&nbsp;     * @param firingPlan
&nbsp;     *            The {@link FiringPlan} to be calculated.
&nbsp;     * @param overheatTolerance
&nbsp;     *            How much overheat we&#39;re willing to forgive.
&nbsp;     * @param shooterIsAero
&nbsp;     *            Set TRUE if the shooter is an Aero unit. Overheating Aeros
&nbsp;     *            take stiffer penalties.
&nbsp;     */
&nbsp;    void calculateUtility(final FiringPlan firingPlan,
&nbsp;                          final int overheatTolerance,
&nbsp;                          final boolean shooterIsAero) {
<b class="fc">&nbsp;        int overheat = 0;</b>
<b class="fc">&nbsp;        if (firingPlan.getHeat() &gt; overheatTolerance) {</b>
<b class="fc">&nbsp;            overheat = firingPlan.getHeat() - overheatTolerance;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        double modifier = 1;</b>
<b class="fc">&nbsp;        modifier += calcCommandUtility(firingPlan.getTarget());</b>
<b class="fc">&nbsp;        modifier += calcStrategicBuildingTargetUtility(firingPlan.getTarget());</b>
<b class="fc">&nbsp;        modifier += calcPriorityUnitTargetUtility(firingPlan.getTarget());</b>
&nbsp;
<b class="fc">&nbsp;        double expectedDamage = firingPlan.getExpectedDamage();</b>
<b class="fc">&nbsp;        double utility = 0;</b>
<b class="fc">&nbsp;        utility += DAMAGE_UTILITY * expectedDamage;</b>
<b class="fc">&nbsp;        utility += CRITICAL_UTILITY * firingPlan.getExpectedCriticals();</b>
<b class="fc">&nbsp;        utility += KILL_UTILITY * firingPlan.getKillProbability();</b>
&nbsp;        // Multiply the combined damage/crit/kill utility for a target by a log-scaled factor based on the target&#39;s damage potential.
<b class="fc">&nbsp;        utility *= calcTargetPotentialDamageMultiplier(firingPlan.getTarget());</b>
<b class="fc">&nbsp;        utility += TARGET_HP_FRACTION_DEALT_UTILITY * calcDamageAllocationUtility(firingPlan.getTarget(), expectedDamage);</b>
<b class="fc">&nbsp;        utility -= calcCivilianTargetDisutility(firingPlan.getTarget());</b>
<b class="fc">&nbsp;        utility *= modifier;</b>
<b class="fc">&nbsp;        utility -= (shooterIsAero ? OVERHEAT_DISUTILITY_AERO : OVERHEAT_DISUTILITY) * overheat;</b>
<b class="fc">&nbsp;        utility -= (firingPlan.getTarget() instanceof MechWarrior) ? EJECTED_PILOT_DISUTILITY : 0;</b>
<b class="fc">&nbsp;        firingPlan.setUtility(utility);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected double calcStrategicBuildingTargetUtility(final Targetable target) {
<b class="fc">&nbsp;        if (!(target instanceof BuildingTarget)) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final DecimalFormat coordsFormat = new DecimalFormat(&quot;00&quot;);</b>
<b class="fc">&nbsp;        final Coords targetCoords = target.getPosition();</b>
<b class="fc">&nbsp;        final String coords = coordsFormat.format(targetCoords.getX() + 1) + coordsFormat.format(targetCoords.getY() + 1);</b>
<b class="fc">&nbsp;        if (owner.getBehaviorSettings().getStrategicBuildingTargets().contains(coords)) {</b>
<b class="fc">&nbsp;            return STRATEGIC_TARGET_UTILITY;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected double calcPriorityUnitTargetUtility(final Targetable target) {
<b class="fc">&nbsp;        if (!(target instanceof Entity)) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final int id = ((Entity) target).getId();</b>
<b class="fc">&nbsp;        if (owner.getPriorityUnitTargets().contains(id)) {</b>
<b class="fc">&nbsp;            return PRIORITY_TARGET_UTILITY;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected double calcCivilianTargetDisutility(final Targetable target) {
<b class="fc">&nbsp;        if (!(target instanceof Entity)) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        final Entity entity = (Entity) target;</b>
<b class="fc">&nbsp;        if (entity.isMilitary()) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (owner.getPriorityUnitTargets().contains(entity.getId())) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (owner.getHonorUtil().isEnemyDishonored(entity.getOwnerId())) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        return CIVILIAN_TARGET_DISUTILITY;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected double calcCommandUtility(final Targetable target) {
<b class="fc">&nbsp;        if (!(target instanceof Entity)) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final Entity entity = (Entity) target;</b>
<b class="fc">&nbsp;        if (isCommander(entity)) {</b>
<b class="fc">&nbsp;            return COMMANDER_UTILITY;</b>
<b class="fc">&nbsp;        } else if (isSubCommander(entity)) {</b>
<b class="fc">&nbsp;            return SUB_COMMANDER_UTILITY;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean isCommander(final Entity entity) {
<b class="nc">&nbsp;        if (owner.getFireControlState().commanderCached(entity)) {</b>
<b class="nc">&nbsp;            return owner.getFireControlState().isCommander(entity);</b>
&nbsp;        } 
&nbsp;
<b class="nc">&nbsp;        owner.getFireControlState().setCommander(entity, </b>
<b class="nc">&nbsp;                entity.isCommander() || entity.hasC3M() || entity.hasC3i() || entity.hasC3MM() ||</b>
<b class="nc">&nbsp;                (owner.getHighestEnemyInitiativeId() == entity.getId()));</b>
&nbsp;            
<b class="nc">&nbsp;        return owner.getFireControlState().isCommander(entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean isSubCommander(final Entity entity) {
<b class="nc">&nbsp;        if (owner.getFireControlState().subCommanderCached(entity)) {</b>
<b class="nc">&nbsp;            return owner.getFireControlState().isSubCommander(entity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int initBonus = entity.getHQIniBonus() + entity.getQuirkIniBonus();</b>
<b class="nc">&nbsp;        owner.getFireControlState().setSubCommander(entity, </b>
<b class="nc">&nbsp;                entity.hasC3() || entity.hasTAG() || entity.hasBoostedC3() || entity.hasNovaCEWS() ||</b>
<b class="nc">&nbsp;               entity.isUsingSpotlight() || entity.hasBAP() || entity.hasActiveECM() || entity.hasActiveECCM() ||</b>
<b class="nc">&nbsp;               entity.hasQuirk(OptionsConstants.QUIRK_POS_IMPROVED_SENSORS) || entity.hasEiCockpit() ||</b>
&nbsp;               (0 &lt; initBonus));
&nbsp;            
<b class="nc">&nbsp;        return owner.getFireControlState().isSubCommander(entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the utility value for doing the given amount of damage to the
&nbsp;     * given target, taking into account damage already applied to this unit by
&nbsp;     * other units belonging to this player(not including allied players!) This
&nbsp;     * utility term is intended to function as a penalty for overkilling targets
&nbsp;     * with fire from multiple units. As such, below certain(high) thresholds,
&nbsp;     * the term does nothing. Only when doing &gt;50% of a target&#39;s HP this round
&nbsp;     * is a weight against this FiringPlan applied. In theory, since this term
&nbsp;     * scales linearly independently of the numeric damage dealt to a target,
&nbsp;     * this term will have a larger effect on low-damage units and a smaller
&nbsp;     * effect on high-damage units, which is probably okay for now(since really
&nbsp;     * high damage units tend to overkill as a matter of course more often). In
&nbsp;     * practice, this utility term results in Princess concentrating her fire
&nbsp;     * enough to reliably kill/cripple targets without falling into serious
&nbsp;     * overkill.
&nbsp;     */
&nbsp;    double calcDamageAllocationUtility(final Targetable target,
&nbsp;                                       final double expectedDamage) {
&nbsp;
<b class="nc">&nbsp;        final double existingDamage = owner.getDamageAlreadyAssigned(target);</b>
<b class="nc">&nbsp;        final int targetHP = Compute.getTargetTotalHP(owner.getGame(), target);</b>
<b class="nc">&nbsp;        final double damageFraction = (existingDamage + expectedDamage) / ((double) targetHP);</b>
<b class="nc">&nbsp;        final double previousDamageFraction = existingDamage / ((double) targetHP);</b>
&nbsp;
&nbsp;        //Do not shoot at units we already expect to deal more than their total HP of damage to!
<b class="nc">&nbsp;        if (1.0 &lt;= previousDamageFraction) {</b>
<b class="nc">&nbsp;            return 100; </b>
&nbsp;
&nbsp;            // In cases that are not generally overkill(less than 50% of the
&nbsp;            // target&#39;s total HP in damage), target as normal(don&#39;t want to
&nbsp;            // spread damage in these cases).
&nbsp;            // Also want to disregard damage allocation weighting if the target
&nbsp;            // is a building or infantry/BA(as they don&#39;t die until you do 100%
&nbsp;            // damage to them normally).
<b class="nc">&nbsp;        } else if (0.5 &gt; damageFraction</b>
<b class="nc">&nbsp;                   || Targetable.TYPE_BUILDING == target.getTargetType()</b>
<b class="nc">&nbsp;                   || Targetable.TYPE_HEX_CLEAR == target.getTargetType()</b>
<b class="nc">&nbsp;                   || owner.getGame().getEntity(target.getTargetId()) instanceof Infantry</b>
<b class="nc">&nbsp;                   || owner.getGame().getEntity(target.getTargetId()) instanceof BattleArmor) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        //In the remaining case(0.5&lt;=damage), return the fraction of target HP dealt as the penalty scaling factor(multiplied by the weight value to produce a penalty).
<b class="nc">&nbsp;        return damageFraction;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the potential damage that the target could theoretically
&nbsp;     * deliver as a measure of it&#39;s potential &quot;threat&quot; to any allied unit on the
&nbsp;     * board, thus prioritizing highly damaging enemies over less damaging ones.
&nbsp;     * For now, this works by simply getting the max damage of the target at
&nbsp;     * range=1, ignoring to-hit, heat, etc.
&nbsp;     */
&nbsp;    private double calcTargetPotentialDamage(final Targetable target) {
<b class="fc">&nbsp;        if (!(target instanceof Entity)) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        final Entity entity = (Entity) target;</b>
<b class="fc">&nbsp;        return getMaxDamageAtRange(entity,1,false,false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the logarithmic scaling factor for target damage potential in
&nbsp;     * the utility equation, using the target&#39;s potential damage, the weight
&nbsp;     * value TARGET_POTENTIAL_DAMAGE_UTILITY, and Princess&#39;s self-preservation
&nbsp;     * value. This is mostly here to not clutter up the utility calculation
&nbsp;     * method with all this extra math.
&nbsp;     */
&nbsp;    protected double calcTargetPotentialDamageMultiplier(final Targetable target) {
<b class="fc">&nbsp;        final double target_damage = calcTargetPotentialDamage(target);</b>
<b class="fc">&nbsp;        if (0.0 == target_damage) { // Do not calculate for zero damage units.</b>
<b class="fc">&nbsp;            return 1.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        final double self_preservation = owner.getBehaviorSettings().getSelfPreservationValue();</b>
<b class="nc">&nbsp;        final double max_self_preservation = owner.getBehaviorSettings()</b>
<b class="nc">&nbsp;                                                  .getSelfPreservationValue(10); // the preservation value of the highest index, i.e. the max value.</b>
<b class="nc">&nbsp;        final double preservation_scaling_factor = max_self_preservation / self_preservation; // Because the variance in log value for large numbers is smaller, we need to make a big self-preservation value become a small multiplicative factor, and vice versa.</b>
<b class="nc">&nbsp;        return Math.log10(TARGET_POTENTIAL_DAMAGE_UTILITY * preservation_scaling_factor * target_damage + 10); // Add 10 to make the multiplier scale from 1 upwards(1 being a target that does 0 damage)).</b>
&nbsp;    }
&nbsp;        
&nbsp;    /**
&nbsp;     * calculates the &#39;utility&#39; of a physical action.
&nbsp;     *
&nbsp;     * @param physicalInfo The {@link PhysicalInfo} to be calculated.
&nbsp;     */
&nbsp;    void calculateUtility(final PhysicalInfo physicalInfo) {
&nbsp;
&nbsp;        // If we can&#39;t hit, there&#39;s no point.
<b class="fc">&nbsp;        if (0.0 &gt;= physicalInfo.getProbabilityToHit()) {</b>
<b class="fc">&nbsp;            physicalInfo.setUtility(-10000);</b>
<b class="fc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        double utility = DAMAGE_UTILITY * physicalInfo.getExpectedDamage();</b>
<b class="fc">&nbsp;        utility += CRITICAL_UTILITY * physicalInfo.getExpectedCriticals();</b>
<b class="fc">&nbsp;        utility += KILL_UTILITY * physicalInfo.getKillProbability();</b>
<b class="fc">&nbsp;        utility *= calcTargetPotentialDamageMultiplier(physicalInfo.getTarget());</b>
<b class="fc">&nbsp;        utility -= (physicalInfo.getTarget() instanceof MechWarrior) ? EJECTED_PILOT_DISUTILITY : 0;</b>
<b class="fc">&nbsp;        utility += calcCommandUtility(physicalInfo.getTarget());</b>
<b class="fc">&nbsp;        utility += calcStrategicBuildingTargetUtility(physicalInfo.getTarget());</b>
<b class="fc">&nbsp;        utility += calcPriorityUnitTargetUtility(physicalInfo.getTarget());</b>
<b class="fc">&nbsp;        utility -= calcCivilianTargetDisutility(physicalInfo.getTarget());</b>
&nbsp;
<b class="fc">&nbsp;        physicalInfo.setUtility(utility);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link WeaponFireInfo} object containing data about firing
&nbsp;     * the given weapon at the given target.
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param shooterState
&nbsp;     *            The current state of the shooter.
&nbsp;     * @param target
&nbsp;     *            The target being fired on.
&nbsp;     * @param targetState
&nbsp;     *            The current state of the target.
&nbsp;     * @param weapon
&nbsp;     *            The weapon being fired.
&nbsp;     * @param game
&nbsp;     *            The game being played.
&nbsp;     * @param guessToHit
&nbsp;     *            Set TRUE to estimate the odds to hit rather than doing the
&nbsp;     *            full calculation.
&nbsp;     * @return The resulting {@link WeaponFireInfo}.
&nbsp;     */
&nbsp;    WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
&nbsp;                                       final EntityState shooterState,
&nbsp;                                       final Targetable target,
&nbsp;                                       final EntityState targetState,
&nbsp;                                       final Mounted weapon,
&nbsp;                                       final IGame game,
&nbsp;                                       final boolean guessToHit) {
<b class="nc">&nbsp;        return new WeaponFireInfo(shooter, shooterState, target, targetState,</b>
&nbsp;                weapon, game, guessToHit, owner);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link WeaponFireInfo} object containing data about firing the given weapon at the given target.
&nbsp;     *
&nbsp;     * @param shooter               The unit doing the shooting.
&nbsp;     * @param flightPath            The path the unit flies over this turn.
&nbsp;     * @param target                The target being fired on.
&nbsp;     * @param targetState           The current state of the target.
&nbsp;     * @param weapon                The weapon being fired.
&nbsp;     * @param game                  The game being played.
&nbsp;     * @param assumeUnderFlightPath Set TRUE to assume the target is under the flight path and avoid doing the full
&nbsp;     *                              calculation.
&nbsp;     * @param guessToHit            Set TRUE to estimate the odds to hit rather than doing the full calculation.
&nbsp;     * @return The resulting {@link WeaponFireInfo}.
&nbsp;     */
&nbsp;    WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
&nbsp;                                       final MovePath flightPath,
&nbsp;                                       final Targetable target,
&nbsp;                                       final EntityState targetState,
&nbsp;                                       final Mounted weapon,
&nbsp;                                       final IGame game,
&nbsp;                                       final boolean assumeUnderFlightPath,
&nbsp;                                       final boolean guessToHit) {
<b class="nc">&nbsp;        return new WeaponFireInfo(shooter, flightPath, target, targetState,</b>
&nbsp;                weapon, game, assumeUnderFlightPath, guessToHit, owner, new int[0]);
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Creates a new {@link WeaponFireInfo} object containing data about firing the given weapon at the given target.
&nbsp;     *
&nbsp;     * @param shooter               The unit doing the shooting.
&nbsp;     * @param flightPath            The path the unit flies over this turn.
&nbsp;     * @param target                The target being fired on.
&nbsp;     * @param targetState           The current state of the target.
&nbsp;     * @param weapon                The weapon being fired.
&nbsp;     * @param game                  The game being played.
&nbsp;     * @param assumeUnderFlightPath Set TRUE to assume the target is under the flight path and avoid doing the full
&nbsp;     *                              calculation.
&nbsp;     * @param guessToHit            Set TRUE to estimate the odds to hit rather than doing the full calculation.
&nbsp;     * @param bombPayload           The bomb payload, as described in WeaponAttackAction.setBombPayload
&nbsp;     * @return The resulting {@link WeaponFireInfo}.
&nbsp;     */
&nbsp;    private WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
&nbsp;                                               final MovePath flightPath,
&nbsp;                                               final Targetable target,
&nbsp;                                               @SuppressWarnings(&quot;SameParameterValue&quot;) final EntityState targetState,
&nbsp;                                               final Mounted weapon,
&nbsp;                                               final IGame game,
&nbsp;                                               final boolean assumeUnderFlightPath,
&nbsp;                                               final boolean guessToHit,
&nbsp;                                               final int[] bombPayload) {
<b class="nc">&nbsp;        return new WeaponFireInfo(shooter, flightPath, target, targetState,</b>
&nbsp;                weapon, game, assumeUnderFlightPath, guessToHit, owner, bombPayload);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link WeaponFireInfo} object containing data about firing the given weapon at the given target.
&nbsp;     *
&nbsp;     * @param shooter    The unit doing the shooting.
&nbsp;     * @param target     The target being fired on.
&nbsp;     * @param weapon     The weapon being fired.
&nbsp;     * @param game       The game being played.
&nbsp;     * @param guessToHit Set TRUE to estimate the odds to hit rather than doing the full calculation.
&nbsp;     * @return The resulting {@link WeaponFireInfo}.
&nbsp;     */
&nbsp;    WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
&nbsp;                                       final Targetable target,
&nbsp;                                       final Mounted weapon,
&nbsp;                                       final IGame game,
&nbsp;                                       final boolean guessToHit) {
<b class="nc">&nbsp;        return new WeaponFireInfo(shooter, target, weapon, game, guessToHit, owner);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a firing plan that fires all weapons with nonzero to hit value at
&nbsp;     * a target ignoring heat, and using best guess from different states. Does
&nbsp;     * not change facing.
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param shooterState
&nbsp;     *            The current state of the shooter.
&nbsp;     * @param target
&nbsp;     *            The unit being fired on.
&nbsp;     * @param targetState
&nbsp;     *            The current state of the target.
&nbsp;     * @param game
&nbsp;     *            The game being played.
&nbsp;     * @return The {@link FiringPlan} containing all weapons to be fired.
&nbsp;     */
&nbsp;    FiringPlan guessFullFiringPlan(final Entity shooter,
&nbsp;                                   @Nullable EntityState shooterState,
&nbsp;                                   final Targetable target,
&nbsp;                                   @Nullable EntityState targetState,
&nbsp;                                   final IGame game) {
<b class="fc">&nbsp;        if (null == shooterState) {</b>
<b class="nc">&nbsp;            shooterState = new EntityState(shooter);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null == targetState) {</b>
<b class="nc">&nbsp;            targetState = new EntityState(target);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final FiringPlan myPlan = new FiringPlan(target);</b>
&nbsp;
&nbsp;        // Shooting isn&#39;t possible if one of us isn&#39;t on the board.
<b class="fc">&nbsp;        if ((null == shooter.getPosition()) || shooter.isOffBoard() ||</b>
<b class="fc">&nbsp;            !game.getBoard().contains(shooter.getPosition())) {</b>
<b class="fc">&nbsp;            owner.getLogger().error(&quot;Shooter&#39;s position is NULL/Off Board!&quot;);</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        }
<b class="fc">&nbsp;        if ((null == target.getPosition()) || target.isOffBoard() || !game.getBoard().contains(target.getPosition())) {</b>
<b class="fc">&nbsp;            owner.getLogger().error(&quot;Target&#39;s position is NULL/Off Board!&quot;);</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        }
&nbsp;
&nbsp;        // cycle through my weapons
<b class="fc">&nbsp;        for (final Mounted weapon : shooter.getWeaponList()) {</b>
&nbsp;        	// respect restriction on manual AMS firing.
<b class="fc">&nbsp;        	if(!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_MANUAL_AMS) &amp;&amp;</b>
<b class="nc">&nbsp;        			weapon.getType().hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;        		continue;</b>
&nbsp;        	}
&nbsp;        	
<b class="fc">&nbsp;            final WeaponFireInfo shoot = buildWeaponFireInfo(shooter,</b>
&nbsp;                                                             shooterState,
&nbsp;                                                             target,
&nbsp;                                                             targetState,
&nbsp;                                                             weapon,
&nbsp;                                                             game,
&nbsp;                                                             true);
&nbsp;
<b class="fc">&nbsp;            if (0 &lt; shoot.getProbabilityToHit()) {</b>
<b class="fc">&nbsp;                myPlan.add(shoot);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Rank how useful this plan is.
<b class="fc">&nbsp;        calculateUtility(myPlan, calcHeatTolerance(shooter, null), shooterState.isAero());</b>
&nbsp;        
&nbsp;        // if we&#39;re in a position to drop bombs because we&#39;re an aircraft on a ground map, then
&nbsp;        // the &quot;alpha strike&quot; may be a bombing plan.
<b class="fc">&nbsp;        if(shooter.isAirborneAeroOnGroundMap()) {</b>
<b class="nc">&nbsp;            final FiringPlan bombingPlan = this.getDiveBombPlan(shooter, null, target, game, shooter.passedOver(target), true);</b>
<b class="nc">&nbsp;            calculateUtility(bombingPlan, Entity.DOES_NOT_TRACK_HEAT, true); // bomb drops never cause heat</b>
&nbsp;            
<b class="nc">&nbsp;            if(bombingPlan.getUtility() &gt; myPlan.getUtility()) {</b>
<b class="nc">&nbsp;                return bombingPlan;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        return myPlan;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a firing plan that fires all weapons with nonzero to hit value in a air to ground strike
&nbsp;     *
&nbsp;     * @param shooter               The unit doing the shooting.
&nbsp;     * @param target                The unit being fired on.
&nbsp;     * @param targetState           The current state of the target.
&nbsp;     * @param flightPath            The path the shooter is flying over.
&nbsp;     * @param game                  The game being played.
&nbsp;     * @param assumeUnderFlightPath Set TRUE to automatically assume the target will be under the flight path rather
&nbsp;     *                              than going through the full calculation.
&nbsp;     * @return The {@link FiringPlan} containing all weapons to be fired.
&nbsp;     */
&nbsp;    FiringPlan guessFullAirToGroundPlan(final Entity shooter,
&nbsp;                                        final Targetable target,
&nbsp;                                        @Nullable EntityState targetState,
&nbsp;                                        final MovePath flightPath,
&nbsp;                                        final IGame game,
&nbsp;                                        final boolean assumeUnderFlightPath) {
<b class="fc">&nbsp;        if (null == targetState) {</b>
<b class="nc">&nbsp;            targetState = new EntityState(target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Must fly over the target to hit it.
<b class="fc">&nbsp;        if (!assumeUnderFlightPath &amp;&amp; !isTargetUnderFlightPath(flightPath, targetState)) {</b>
<b class="nc">&nbsp;            return new FiringPlan(target);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final FiringPlan myPlan = new FiringPlan(target);</b>
&nbsp;
&nbsp;        // Shooting isn&#39;t possible if one of us isn&#39;t on the board.
<b class="fc">&nbsp;        if ((null == shooter.getPosition()) || shooter.isOffBoard() ||</b>
<b class="fc">&nbsp;            !game.getBoard().contains(shooter.getPosition())) {</b>
<b class="fc">&nbsp;            owner.getLogger().error(&quot;Shooter&#39;s position is NULL/Off Board!&quot;);</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if ((null == target.getPosition()) || target.isOffBoard() || !game.getBoard().contains(target.getPosition())) {</b>
<b class="fc">&nbsp;            owner.getLogger().error(&quot;Target&#39;s position is NULL/Off Board!&quot;);</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if we have no bombs on board, we can&#39;t attack from down here
<b class="fc">&nbsp;        if (AeroGroundPathFinder.NAP_OF_THE_EARTH &gt;= flightPath.getFinalAltitude() &amp;&amp;</b>
<b class="nc">&nbsp;            0 == shooter.getBombs(BombType.F_GROUND_BOMB).size()) {</b>
<b class="nc">&nbsp;            owner.getLogger().error(&quot;Shooter will crash if striking at altitude 1!&quot;);</b>
<b class="nc">&nbsp;            return myPlan;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (AeroGroundPathFinder.OPTIMAL_STRIKE_ALTITUDE &lt; flightPath.getFinalAltitude()) {</b>
<b class="nc">&nbsp;            owner.getLogger().error(&quot;Shooter&#39;s altitude is too high!&quot;);</b>
<b class="nc">&nbsp;            return myPlan;</b>
&nbsp;        }
&nbsp;
&nbsp;        // cycle through my weapons
<b class="fc">&nbsp;        for (final Mounted weapon : shooter.getWeaponList()) {</b>
&nbsp;            // bombing attacks have to be carried out separately from other weapon attacks, so we handle them in a special case
<b class="fc">&nbsp;            if(weapon.isGroundBomb()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            final WeaponFireInfo shoot = buildWeaponFireInfo(shooter,</b>
&nbsp;                                                             flightPath,
&nbsp;                                                             target,
&nbsp;                                                             targetState,
&nbsp;                                                             weapon,
&nbsp;                                                             game,
&nbsp;                                                             true,
&nbsp;                                                             true);
&nbsp;
&nbsp;            // for now, just fire weapons that will do damage until we get to heat capacity
<b class="fc">&nbsp;            if (0 &lt; shoot.getProbabilityToHit() &amp;&amp;</b>
<b class="fc">&nbsp;                myPlan.getHeat() + shoot.getHeat() + shooter.getHeat() &lt;= shooter.getHeatCapacity() &amp;&amp;</b>
<b class="fc">&nbsp;                0 &lt; shoot.getExpectedDamage()) {</b>
<b class="fc">&nbsp;                myPlan.add(shoot);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // if we are here, we have already confirmed the target is under the flight path and are guessing
<b class="fc">&nbsp;        final FiringPlan bombPlan = getDiveBombPlan(shooter, flightPath, target, game, true, true);</b>
<b class="fc">&nbsp;        calculateUtility(bombPlan, Entity.DOES_NOT_TRACK_HEAT, shooter.isAero()); // bombs don&#39;t generate heat so don&#39;t bother with this calculation</b>
&nbsp;        
&nbsp;        // Rank how useful this plan is.
<b class="fc">&nbsp;        calculateUtility(myPlan, calcHeatTolerance(shooter, null), shooter.isAero());</b>
&nbsp;        
<b class="fc">&nbsp;        if(myPlan.getUtility() &gt;= bombPlan.getUtility()) {</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return bombPlan;</b>
&nbsp;        }
&nbsp;    }
&nbsp;   
&nbsp;    /**
&nbsp;     * Creates a firing plan that fires dive bombs, dropping all bombs on the given target
&nbsp;     *
&nbsp;     * @param shooter               The unit doing the shooting.
&nbsp;     * @param target                The unit being fired on.
&nbsp;     * @param game                  The game being played.
&nbsp;     * @param passedOverTarget      Set TRUE to automatically assume the target will be under the flight path rather
&nbsp;     *                              than going through the full calculation.
&nbsp;     * @param guess                 Whether we&#39;re just thinking about this firing plan or about to                              
&nbsp;     * @return The {@link FiringPlan} containing all bombs on target, if the shooter is capable of dropping bombs.
&nbsp;     */
&nbsp;    private FiringPlan getDiveBombPlan(final Entity shooter,
&nbsp;                                      final MovePath flighPath,
&nbsp;                                      final Targetable target,
&nbsp;                                       final IGame game,
&nbsp;                                      final boolean passedOverTarget,
&nbsp;                                      final boolean guess) {
<b class="fc">&nbsp;        final FiringPlan diveBombPlan = new FiringPlan(target);</b>
<b class="fc">&nbsp;        final HexTarget hexToBomb = new HexTarget(target.getPosition(), game.getBoard(), </b>
<b class="fc">&nbsp;                shooter.isAero() ? Targetable.TYPE_HEX_AERO_BOMB : Targetable.TYPE_HEX_BOMB);</b>
&nbsp;
&nbsp;        // things that cause us to avoid calculating a bomb plan:
&nbsp;        // not having any bombs (in the first place)
<b class="fc">&nbsp;        final Iterator&lt;Mounted&gt; weaponIter = shooter.getWeapons();</b>
<b class="fc">&nbsp;        if (null == weaponIter) {</b>
<b class="fc">&nbsp;            return diveBombPlan;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // not having any bombs (due to expenditure/damage)
<b class="nc">&nbsp;        if(shooter.getBombs(BombType.F_GROUND_BOMB).size() == 0) {</b>
<b class="nc">&nbsp;            return diveBombPlan;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (weaponIter.hasNext()) {</b>
<b class="nc">&nbsp;            final Mounted weapon = weaponIter.next();</b>
<b class="nc">&nbsp;            if(weapon.getType().hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
<b class="nc">&nbsp;                final int[] bombPayload = new int[BombType.B_NUM];</b>
&nbsp;                // load up all droppable bombs, yeah baby! Mix thunder bombs and infernos &#39;cause why the hell not.
&nbsp;                // seriously, though, TODO: more intelligent bomb drops
<b class="nc">&nbsp;                for (final Mounted bomb : shooter.getBombs(BombType.F_GROUND_BOMB)) {</b>
<b class="nc">&nbsp;                    bombPayload[((BombType) bomb.getType()).getBombType()]++;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                final WeaponFireInfo diveBomb = buildWeaponFireInfo(shooter,</b>
&nbsp;                                                                    flighPath,
&nbsp;                                                                    hexToBomb,
&nbsp;                                                                    null,
&nbsp;                                                                    weapon,
&nbsp;                                                                    game,
&nbsp;                                                                    passedOverTarget,
&nbsp;                                                                    guess,
&nbsp;                                                                    bombPayload);
<b class="nc">&nbsp;                diveBombPlan.add(diveBomb);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return diveBombPlan;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a firing plan that fires all weapons with nonzero to hit value at a target ignoring heat, and using
&nbsp;     * actual game rules from different states
&nbsp;     *
&nbsp;     * @param shooter The unit doing the shooting.
&nbsp;     * @param target  The unit being fired on.
&nbsp;     * @param game    The game being played.
&nbsp;     * @return The {@link FiringPlan} containing all weapons to be fired.
&nbsp;     */
&nbsp;    FiringPlan getFullFiringPlan(final Entity shooter,
&nbsp;                                 final Targetable target,
&nbsp;                                 final Map&lt;Mounted, Double&gt; ammoConservation,
&nbsp;                                 final IGame game) {
<b class="fc">&nbsp;        final NumberFormat DECF = new DecimalFormat(&quot;0.000&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        final FiringPlan myPlan = new FiringPlan(target);</b>
&nbsp;
&nbsp;        // Shooting isn&#39;t possible if one of us isn&#39;t on the board.
<b class="fc">&nbsp;        if ((null == shooter.getPosition()) || shooter.isOffBoard() ||</b>
<b class="fc">&nbsp;            !game.getBoard().contains(shooter.getPosition())) {</b>
<b class="fc">&nbsp;            owner.getLogger().error(&quot;Shooter&#39;s position is NULL/Off Board!&quot;);</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        }
<b class="fc">&nbsp;        if ((null == target.getPosition()) || target.isOffBoard() || !game.getBoard().contains(target.getPosition())) {</b>
<b class="fc">&nbsp;            owner.getLogger().error(&quot;Target&#39;s position is NULL/Off Board!&quot;);</b>
<b class="fc">&nbsp;            return myPlan;</b>
&nbsp;        }
&nbsp;
&nbsp;        // cycle through my weapons
<b class="fc">&nbsp;        for (final Mounted weapon : shooter.getWeaponList()) {</b>
&nbsp;        	// respect restriction on manual AMS firing.
<b class="fc">&nbsp;        	if(!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_MANUAL_AMS) &amp;&amp;</b>
<b class="nc">&nbsp;        			weapon.getType().hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;        		continue;</b>
&nbsp;        	}
&nbsp;        	
<b class="fc">&nbsp;        	final double toHitThreshold = ammoConservation.get(weapon);</b>
<b class="fc">&nbsp;            WeaponFireInfo shoot = buildWeaponFireInfo(shooter, target, weapon, game, false);</b>
&nbsp;            
&nbsp;            // if we&#39;re below the threshold, try switching missile modes
<b class="fc">&nbsp;            if (shoot.getProbabilityToHit() &lt;= toHitThreshold) {</b>
&nbsp;                
<b class="fc">&nbsp;                int updatedMissileMode = switchMissileMode(weapon);</b>
&nbsp;                
<b class="fc">&nbsp;                if (updatedMissileMode &gt; -1) {</b>
<b class="nc">&nbsp;                    shoot = buildWeaponFireInfo(shooter, target, weapon, game, false);</b>
<b class="nc">&nbsp;                    shoot.setUpdatedFiringMode(updatedMissileMode);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            if ((shoot.getProbabilityToHit() &gt; toHitThreshold)) {</b>
<b class="fc">&nbsp;                myPlan.add(shoot);</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }            
&nbsp;            
<b class="fc">&nbsp;            owner.getLogger().debug(&quot;\nTo Hit Chance (&quot; + DECF.format(shoot.getProbabilityToHit()) </b>
<b class="fc">&nbsp;                      + &quot;) for &quot; + weapon.getName() +</b>
<b class="fc">&nbsp;                      &quot; is less than threshold (&quot; + DECF.format(toHitThreshold) + &quot;)&quot;);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Rank how useful this plan is.
<b class="fc">&nbsp;        calculateUtility(myPlan, calcHeatTolerance(shooter, null), shooter.isAero());</b>
&nbsp;        
<b class="fc">&nbsp;        if(shooter.isAero()) {</b>
<b class="nc">&nbsp;            final FiringPlan bombingPlan = this.getDiveBombPlan(shooter, null, target, game, shooter.passedOver(target), false);</b>
<b class="nc">&nbsp;            calculateUtility(bombingPlan, Entity.DOES_NOT_TRACK_HEAT, true); // bomb drops never cause heat</b>
&nbsp;            
&nbsp;            // if the bombing plan actually involves doing something
<b class="nc">&nbsp;            if((bombingPlan.size() &gt; 0) &amp;&amp; </b>
<b class="nc">&nbsp;                    (bombingPlan.getUtility() &gt; myPlan.getUtility())) {</b>
<b class="nc">&nbsp;                return bombingPlan;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        return myPlan;</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected int calcHeatTolerance(final Entity entity,
&nbsp;                                  @Nullable Boolean isAero) {
&nbsp;
&nbsp;        // If the unit doesn&#39;t track heat, we won&#39;t worry about it.
<b class="fc">&nbsp;        if (Entity.DOES_NOT_TRACK_HEAT == entity.getHeatCapacity()) {</b>
<b class="nc">&nbsp;            return Entity.DOES_NOT_TRACK_HEAT;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int baseTolerance = entity.getHeatCapacity() - entity.getHeat();</b>
&nbsp;
&nbsp;        // if we&#39;ve got a combat computer, we get an automatic
<b class="fc">&nbsp;        if(entity.hasQuirk(OptionsConstants.QUIRK_POS_COMBAT_COMPUTER)) {</b>
<b class="nc">&nbsp;            baseTolerance += 4;</b>
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        if (null == isAero) {</b>
<b class="fc">&nbsp;            isAero = entity.isAero();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Aeros *really* don&#39;t want to overheat.
<b class="fc">&nbsp;        if (isAero) {</b>
<b class="nc">&nbsp;            return baseTolerance;</b>
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        return baseTolerance + 5; // todo add Heat Tolerance to Behavior Settings.</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an array that gives the &#39;best&#39; firing plan (the maximum utility)
&nbsp;     * under the heat of the index
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param alphaStrike
&nbsp;     *            The alpha strike plan.
&nbsp;     * @return An array of all the resulting firing plans.
&nbsp;     */
&nbsp;    FiringPlan[] calcFiringPlansUnderHeat(final Entity shooter,
&nbsp;                                          final FiringPlan alphaStrike) {
&nbsp;
&nbsp;        // can&#39;t be lower than zero heat
<b class="fc">&nbsp;        int maxHeat = alphaStrike.getHeat();</b>
<b class="fc">&nbsp;        if (0 &gt; maxHeat) {</b>
<b class="nc">&nbsp;            maxHeat = 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final Targetable target = alphaStrike.getTarget();</b>
&nbsp;
<b class="fc">&nbsp;        final boolean isAero = shooter.isAero();</b>
<b class="fc">&nbsp;        final int heatTolerance = calcHeatTolerance(shooter, isAero);</b>
&nbsp;
&nbsp;        // How many plans do I need to compute?
&nbsp;        final FiringPlan[] bestPlans;
<b class="fc">&nbsp;        if (shooter instanceof Infantry) {</b>
<b class="nc">&nbsp;            bestPlans = new FiringPlan[maxHeat + 4];</b>
&nbsp;        } else {
<b class="fc">&nbsp;            bestPlans = new FiringPlan[maxHeat + 1];</b>
&nbsp;        }
&nbsp;
&nbsp;        // First plan is a plan that fires only heatless weapons.
&nbsp;        // The remaining plans will build at least some heat.
&nbsp;        // we include arm flip information into the regular heat plans, but infantry don&#39;t flip arms so we don&#39;t bother.
<b class="fc">&nbsp;        bestPlans[0] = new FiringPlan(target, alphaStrike.getFlipArms());</b>
<b class="fc">&nbsp;        final FiringPlan nonZeroHeatOptions = new FiringPlan(target);</b>
<b class="fc">&nbsp;        final FiringPlan swarmAttack = new FiringPlan(target);</b>
<b class="fc">&nbsp;        final FiringPlan legAttack = new FiringPlan(target);</b>
<b class="fc">&nbsp;        final FiringPlan fieldGuns = new FiringPlan(target);</b>
<b class="fc">&nbsp;        double fieldGunMassAlreadyFired = 0.0; //We need to track the tonnage of field guns being fired, because trying to fire more than the current possible total(# of men left) results in nothing being fired.</b>
<b class="fc">&nbsp;        for (final WeaponFireInfo weaponFireInfo : alphaStrike) {</b>
&nbsp;
&nbsp;            //Leg and swarm attacks can&#39;t be mixed with any other attacks, so we have to consider each of those separately.
<b class="fc">&nbsp;            if (shooter instanceof Infantry) {</b>
<b class="nc">&nbsp;                if ((weaponFireInfo.getWeapon().getType()).getInternalName().equals(Infantry.LEG_ATTACK)) {</b>
<b class="nc">&nbsp;                    legAttack.add(weaponFireInfo);</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                } else if ((weaponFireInfo.getWeapon().getType()).getInternalName().equals(Infantry.SWARM_MEK)) {</b>
<b class="nc">&nbsp;                    swarmAttack.add(weaponFireInfo);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // We probably shouldn&#39;t consider stopping swarm attacks, since Princess isn&#39;t smart enough to recognize the rare situations when this is a good idea(e.g. planning to put lots of allied fire on the swarm target next turn, target is likely to explode and ammo explosion splash damage is on, etc).
<b class="nc">&nbsp;                else if ((weaponFireInfo.getWeapon().getType()) instanceof StopSwarmAttack) {</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                } else if (!(shooter instanceof BattleArmor) &amp;&amp; Infantry.LOC_FIELD_GUNS == weaponFireInfo.getWeapon()</b>
<b class="nc">&nbsp;                                                                                                         .getLocation()) {</b>
<b class="nc">&nbsp;                    final double fieldGunMass = weaponFireInfo.getWeapon().getTonnage();</b>
&nbsp;                    //Only fire field guns up until we no longer have the men to fire more, since going over that limit results in nothing firing.
&nbsp;                    //In theory we could adapt the heat system to handle this(with tonnage as heat and shooting strength as heat capacity, no heat tolerance).
&nbsp;                    //This would behave much better for units with mixed type field guns, but given that those are rare, this should serve for now.
<b class="nc">&nbsp;                    if(fieldGunMassAlreadyFired + fieldGunMass &lt;= ((Infantry)shooter).getShootingStrength()) {</b>
<b class="nc">&nbsp;                        fieldGuns.add(weaponFireInfo);</b>
<b class="nc">&nbsp;                        fieldGunMassAlreadyFired += fieldGunMass;</b>
&nbsp;                    }
&nbsp;                    continue;
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (0 == weaponFireInfo.getHeat()) {</b>
<b class="fc">&nbsp;                bestPlans[0].add(weaponFireInfo);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                nonZeroHeatOptions.add(weaponFireInfo);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        calculateUtility(bestPlans[0], heatTolerance, isAero);</b>
&nbsp;        
<b class="fc">&nbsp;        if (shooter instanceof Infantry) {</b>
<b class="nc">&nbsp;            calculateUtility(swarmAttack, heatTolerance, isAero);</b>
<b class="nc">&nbsp;            calculateUtility(legAttack, heatTolerance, isAero);         </b>
<b class="nc">&nbsp;            calculateUtility(fieldGuns, heatTolerance, isAero);</b>
&nbsp;            //Add these plans to the end of the list.
<b class="nc">&nbsp;            bestPlans[maxHeat + 1] = swarmAttack;</b>
<b class="nc">&nbsp;            bestPlans[maxHeat + 2] = legAttack;</b>
<b class="nc">&nbsp;            bestPlans[maxHeat + 3] = fieldGuns;</b>
&nbsp;        }
&nbsp;
&nbsp;        // build up heat table
<b class="fc">&nbsp;        for (int heatLevel = 1; heatLevel &lt;= maxHeat; heatLevel++) {</b>
<b class="fc">&nbsp;            bestPlans[heatLevel] = new FiringPlan(target);</b>
&nbsp;
&nbsp;            // Include all the firing options that exist at the last heat level.
<b class="fc">&nbsp;            bestPlans[heatLevel].addAll(bestPlans[heatLevel - 1]);</b>
<b class="fc">&nbsp;            calculateUtility(bestPlans[heatLevel], heatTolerance, isAero);</b>
&nbsp;
<b class="fc">&nbsp;            for (final WeaponFireInfo weaponFireInfo : nonZeroHeatOptions) {</b>
&nbsp;
<b class="fc">&nbsp;                final int leftoverHeatCapacity = heatLevel - weaponFireInfo.getHeat();</b>
&nbsp;
&nbsp;                // If this attack produces heat and is not already included in the plan, check its utility.
<b class="fc">&nbsp;                if ((0 &lt;= leftoverHeatCapacity) &amp;&amp;</b>
<b class="fc">&nbsp;                    !bestPlans[leftoverHeatCapacity].containsWeapon(weaponFireInfo.getWeapon())) {</b>
&nbsp;
&nbsp;                    // make sure to pass along arm flip state from the alpha strike, if any
<b class="fc">&nbsp;                    final FiringPlan testPlan = new FiringPlan(target, alphaStrike.getFlipArms());</b>
<b class="fc">&nbsp;                    testPlan.addAll(bestPlans[heatLevel - weaponFireInfo.getHeat()]);</b>
<b class="fc">&nbsp;                    testPlan.add(weaponFireInfo);</b>
<b class="fc">&nbsp;                    calculateUtility(testPlan, heatTolerance, isAero);</b>
&nbsp;
&nbsp;                    // If this plan has a higher utility, add it.
<b class="fc">&nbsp;                    if (testPlan.getUtility() &gt; bestPlans[heatLevel].getUtility()) {</b>
<b class="fc">&nbsp;                        bestPlans[heatLevel] = testPlan;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if we are an aero blasting away at ground targets, another good option for a heatless plan is to bomb the crap out of the enemy
&nbsp;        //bombs cannot be mixed with other attack types, so we calculate it separately and overwrite the 0-heat plan if it&#39;s better
&nbsp;        //currently, this will probably result in the aero blowing its bomb load as soon as it passes over an enemy
&nbsp;        //dropping everything it has, including specialized munitions such as thunder bombs and infernos
<b class="fc">&nbsp;        if (shooter.isAirborne() &amp;&amp; 0 &lt; shooter.getBombs(BombType.F_GROUND_BOMB).size()) {</b>
<b class="nc">&nbsp;            final FiringPlan diveBombPlan = this.getDiveBombPlan(shooter, null, target,</b>
<b class="nc">&nbsp;                                                                 shooter.getGame(), shooter.passedOver(target), false);</b>
&nbsp;            
<b class="nc">&nbsp;            calculateUtility(diveBombPlan, Entity.DOES_NOT_TRACK_HEAT, true);</b>
<b class="nc">&nbsp;            if(diveBombPlan.getUtility() &gt; bestPlans[0].getUtility()) {</b>
<b class="nc">&nbsp;                bestPlans[0] = diveBombPlan;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        return bestPlans;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Gets the &#39;best&#39; firing plan, using heat as a disutility. No twisting is
&nbsp;     * done
&nbsp;     * 
&nbsp;     * @param shooter The unit doing the shooting.
&nbsp;     * 
&nbsp;     * @param target The unit being shot at.
&nbsp;     * 
&nbsp;     * @param game The game currently being played.
&nbsp;     * 
&nbsp;     * @return the &#39;best&#39; firing plan, using heat as a disutility.
&nbsp;     */
&nbsp;    FiringPlan getBestFiringPlan(final Entity shooter,
&nbsp;                                 final Targetable target,
&nbsp;                                 final IGame game,
&nbsp;                                 final Map&lt;Mounted, Double&gt; ammoConservation) {
&nbsp;
&nbsp;        // Start with an alpha strike.
<b class="fc">&nbsp;        FiringPlan alphaStrike = getFullFiringPlan(shooter, target,</b>
&nbsp;                                                    ammoConservation, game);
&nbsp;        
<b class="fc">&nbsp;        if(shooter.canFlipArms()) {</b>
<b class="nc">&nbsp;            shooter.setArmsFlipped(true, false);</b>
<b class="nc">&nbsp;            FiringPlan betaStrike = getFullFiringPlan(shooter, target, ammoConservation, game);</b>
<b class="nc">&nbsp;            betaStrike.setFlipArms(true);</b>
<b class="nc">&nbsp;            if(betaStrike.getUtility() &gt; alphaStrike.getUtility()) {</b>
<b class="nc">&nbsp;                alphaStrike = betaStrike;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            shooter.setArmsFlipped(false, false);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Although they don&#39;t track heat, infantry/BA do need to make tradeoffs
&nbsp;        // between firing different weapons, because swarm/leg attacks are
&nbsp;        // mutually exclusive with normal firing, so we treat them similarly to
&nbsp;        // heat-tracking units.
&nbsp;        
&nbsp;        // conventional fighters can drop bombs
<b class="fc">&nbsp;        if (Entity.DOES_NOT_TRACK_HEAT == shooter.getHeatCapacity()</b>
<b class="nc">&nbsp;            &amp;&amp; ((shooter.getEntityType() &amp; Entity.ETYPE_INFANTRY) == 0)) {</b>
<b class="nc">&nbsp;            return alphaStrike; // No need to worry about heat if the unit</b>
&nbsp;                                // doesn&#39;t track it.
&nbsp;        }
&nbsp;
&nbsp;        // Get all the best plans that generate less heat than an alpha strike.
<b class="fc">&nbsp;        final FiringPlan[] allPlans = calcFiringPlansUnderHeat(shooter, alphaStrike);</b>
&nbsp;
&nbsp;        // Determine the best plan taking into account our heat tolerance.
<b class="fc">&nbsp;        return getBestFiringPlanUnderHeat(target, shooter, allPlans);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Guesses the &#39;best&#39; firing plan under a certain heat No twisting is done
&nbsp;     *
&nbsp;     * @param shooter
&nbsp;     *            The unit doing the shooting.
&nbsp;     * @param shooterState
&nbsp;     *            The current state of the shooting unit.
&nbsp;     * @param target
&nbsp;     *            The unit being shot at.
&nbsp;     * @param targetState
&nbsp;     *            The current state of the target unit.
&nbsp;     * @param maxHeat
&nbsp;     *            How much heat we&#39;re willing to tolerate.
&nbsp;     * @param game
&nbsp;     *            The game currently being played.
&nbsp;     * @return the &#39;best&#39; firing plan under a certain heat.
&nbsp;     */
&nbsp;    protected FiringPlan guessBestFiringPlanUnderHeat(final Entity shooter,
&nbsp;                                                    @Nullable final EntityState shooterState,
&nbsp;                                                    final Targetable target,
&nbsp;                                                    @Nullable final EntityState targetState,
&nbsp;                                                    int maxHeat,
&nbsp;                                                    final IGame game) {
&nbsp;
&nbsp;        // can&#39;t have less than zero heat
<b class="nc">&nbsp;        if (0 &gt; maxHeat) {</b>
<b class="nc">&nbsp;            maxHeat = 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Start with an alpha strike. If it falls under our heat limit, use it.
<b class="nc">&nbsp;        FiringPlan alphaStrike = guessFullFiringPlan(shooter, shooterState,</b>
&nbsp;                                                       target, targetState, game);
&nbsp;        
<b class="nc">&nbsp;        if(shooter.canFlipArms()) {</b>
<b class="nc">&nbsp;            shooter.setArmsFlipped(true, false);</b>
<b class="nc">&nbsp;            FiringPlan betaStrike = guessFullFiringPlan(shooter, shooterState,</b>
&nbsp;                                                        target, targetState, game);
<b class="nc">&nbsp;            betaStrike.setFlipArms(true);</b>
<b class="nc">&nbsp;            if(betaStrike.getUtility() &gt; alphaStrike.getUtility()) {</b>
<b class="nc">&nbsp;                alphaStrike = betaStrike;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            shooter.setArmsFlipped(false, false);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Infantry and BA may have alternative options, so we need to consider
&nbsp;        // different firing options.
<b class="nc">&nbsp;        if (alphaStrike.getHeat() &lt;= maxHeat &amp;&amp; !(shooter instanceof Infantry)) {</b>
<b class="nc">&nbsp;            return alphaStrike;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the best firing plan that falls under our heat limit.
&nbsp;        // Now emulates the logic from getBestFiringPlanUnderHeat, rather than sorting the firing plans low to high then picking the lowest one
<b class="nc">&nbsp;        final FiringPlan[] heatPlans = calcFiringPlansUnderHeat(shooter, alphaStrike);</b>
<b class="nc">&nbsp;        FiringPlan bestPlan = new FiringPlan(target);</b>
&nbsp;        
<b class="nc">&nbsp;        for (final FiringPlan firingPlan : heatPlans) {</b>
<b class="nc">&nbsp;            if ((bestPlan.getUtility() &lt; firingPlan.getUtility())) {</b>
<b class="nc">&nbsp;                bestPlan = firingPlan;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return bestPlan;</b>
&nbsp;    }
&nbsp;
&nbsp;    private FiringPlan getBestFiringPlanUnderHeat(final Targetable target,
&nbsp;                                                  final Entity shooter,
&nbsp;                                                  final FiringPlan[] allPlans) {
&nbsp;
&nbsp;        // Determine the best plan taking into account our heat tolerance.
<b class="fc">&nbsp;        FiringPlan bestPlan = new FiringPlan(target);</b>
<b class="fc">&nbsp;        final boolean isAero = shooter.isAero();</b>
<b class="fc">&nbsp;        final int heatTolerance = calcHeatTolerance(shooter, isAero);</b>
<b class="fc">&nbsp;        calculateUtility(bestPlan, heatTolerance, isAero);</b>
<b class="fc">&nbsp;        for (final FiringPlan firingPlan : allPlans) {</b>
<b class="fc">&nbsp;            calculateUtility(firingPlan, heatTolerance, isAero);</b>
<b class="fc">&nbsp;            if ((bestPlan.getUtility() &lt; firingPlan.getUtility())) {</b>
<b class="fc">&nbsp;                bestPlan = firingPlan;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return bestPlan;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Figures out the best firing plan
&nbsp;     *
&nbsp;     * @param params - the appropriate firing plan calculation parameters
&nbsp;     * @return the &#39;best&#39; firing plan - uses heat as disutility and includes the possibility of twisting
&nbsp;     */
&nbsp;    FiringPlan determineBestFiringPlan(final FiringPlanCalculationParameters params) {
&nbsp;        // unpack parameters for easier reference
<b class="nc">&nbsp;        final Entity shooter = params.getShooter();</b>
<b class="nc">&nbsp;        final Targetable target = params.getTarget();</b>
<b class="nc">&nbsp;        final EntityState shooterState = params.getShooterState();</b>
<b class="nc">&nbsp;        final EntityState targetState = params.getTargetState();</b>
<b class="nc">&nbsp;        final int maxHeat = params.getMaxHeat();</b>
<b class="nc">&nbsp;        final Map&lt;Mounted, Double&gt; ammoConservation = params.getAmmoConservation();</b>
&nbsp;
&nbsp;        // Get the best plan without any twists.
<b class="nc">&nbsp;        FiringPlan noTwistPlan = null;</b>
&nbsp;        
<b class="nc">&nbsp;        switch(params.getCalculationType()) {</b>
&nbsp;            case GET:
<b class="nc">&nbsp;                noTwistPlan = getBestFiringPlan(shooter, target, owner.getGame(), ammoConservation);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case GUESS:
<b class="nc">&nbsp;                noTwistPlan = guessBestFiringPlanUnderHeat(shooter,</b>
&nbsp;                                                           shooterState,
&nbsp;                                                           target,
&nbsp;                                                           targetState,
&nbsp;                                                           maxHeat,
<b class="nc">&nbsp;                                                           owner.getGame());</b>
&nbsp;                break;
&nbsp;        }
&nbsp;        
&nbsp;        // If we can&#39;t change facing, we&#39;re done.
<b class="nc">&nbsp;        if (!params.getShooter().canChangeSecondaryFacing()) {</b>
<b class="nc">&nbsp;            return noTwistPlan;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Keep track of our original facing so we can go back to it.
<b class="nc">&nbsp;        final int originalFacing = shooter.getSecondaryFacing();</b>
&nbsp;
<b class="nc">&nbsp;        final List&lt;Integer&gt; validFacingChanges = getValidFacingChanges(shooter);</b>
&nbsp;        
&nbsp;        // Now, we loop through all possible facings. If one facing produces a better plan 
&nbsp;        // than what we currently have as the best plan then use that. Start with &quot;no twist&quot; as default.
<b class="nc">&nbsp;        FiringPlan bestFiringPlan = noTwistPlan;</b>
<b class="nc">&nbsp;        for (final int currentTwist : validFacingChanges) {</b>
<b class="nc">&nbsp;            shooter.setSecondaryFacing(correctFacing(originalFacing + currentTwist), false);</b>
&nbsp;
<b class="nc">&nbsp;            FiringPlan twistPlan = null;</b>
<b class="nc">&nbsp;            switch (params.getCalculationType()) {</b>
&nbsp;                case GET:
<b class="nc">&nbsp;                    twistPlan = getBestFiringPlan(shooter, target, owner.getGame(), ammoConservation);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case GUESS:
<b class="nc">&nbsp;                    twistPlan = guessBestFiringPlanUnderHeat(shooter,</b>
&nbsp;                                                             shooterState,
&nbsp;                                                             target,
&nbsp;                                                             targetState,
&nbsp;                                                             maxHeat,
<b class="nc">&nbsp;                                                             owner.getGame());</b>
&nbsp;            }
<b class="nc">&nbsp;            twistPlan.setTwist(currentTwist);</b>
&nbsp;
<b class="nc">&nbsp;            if (twistPlan.getUtility() &gt; bestFiringPlan.getUtility()) {</b>
<b class="nc">&nbsp;                bestFiringPlan = twistPlan;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Back to where we started.
<b class="nc">&nbsp;        shooter.setSecondaryFacing(originalFacing, false);</b>
&nbsp;
<b class="nc">&nbsp;        return bestFiringPlan;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the given entity can use indirect fire as in LRMs.
&nbsp;     */
&nbsp;    public boolean entityCanIndirectFireMissile(FireControlState fireControlState, Entity shooter) {
&nbsp;    	// cache the results of our computation
<b class="nc">&nbsp;    	if(fireControlState.getEntityIDFStates().containsKey(shooter.getId())) {</b>
<b class="nc">&nbsp;    		return fireControlState.getEntityIDFStates().get(shooter.getId());</b>
&nbsp;    	}
&nbsp;    	
&nbsp;    	// airborne aerospace units cannot use indirect fire
<b class="nc">&nbsp;    	if(shooter.isAirborne()) {</b>
<b class="nc">&nbsp;    	    fireControlState.getEntityIDFStates().put(shooter.getId(), false);</b>
<b class="nc">&nbsp;    	    return false;</b>
&nbsp;    	}
&nbsp;    	
<b class="nc">&nbsp;        for(Mounted weapon : shooter.getWeaponList()) {</b>
<b class="nc">&nbsp;        	if(weapon.getType().hasModeType(Weapon.MODE_MISSILE_INDIRECT)) {</b>
<b class="nc">&nbsp;        		fireControlState.getEntityIDFStates().put(shooter.getId(), true);</b>
<b class="nc">&nbsp;        		return true;</b>
&nbsp;        	}
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        fireControlState.getEntityIDFStates().put(shooter.getId(), false);</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Determines if the given entity (potentially employing a given firing plan)
&nbsp;     * can/should spot. If yes, then return a spot action.
&nbsp;     * @param plan
&nbsp;     * @param spotter
&nbsp;     * @return
&nbsp;     */
&nbsp;    public SpotAction getSpotAction(FiringPlan plan, Entity spotter, FireControlState fireControlState) {
&nbsp;    	// logic applies as follows:
&nbsp;    	// if I am disqualified from spotting, don&#39;t spot
&nbsp;    	// disqualifiers are:
&nbsp;    	// 		legally can&#39;t spot
&nbsp;    	//		am firing and don&#39;t have a command console to mitigate the spotting penalty
&nbsp;    	// otherwise, attempt to spot the closest enemy
<b class="nc">&nbsp;    	if(spotter.isSpotting() || !spotter.canSpot() || spotter.isNarcedBy(INarcPod.HAYWIRE) || </b>
<b class="nc">&nbsp;    			(plan != null) &amp;&amp; (plan.getExpectedDamage() &gt; 0) &amp;&amp; </b>
<b class="nc">&nbsp;    			!spotter.getCrew().hasActiveCommandConsole()) {</b>
<b class="nc">&nbsp;    		return null;</b>
&nbsp;    	}
&nbsp;    	
<b class="nc">&nbsp;    	List&lt;Targetable&gt; enemyTargets = getAllTargetableEnemyEntities(</b>
<b class="nc">&nbsp;    			spotter.getOwner(), spotter.getGame(), fireControlState);</b>
<b class="nc">&nbsp;    	List&lt;Targetable&gt; closestTargets = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	int shortestDistance = Integer.MAX_VALUE;</b>
&nbsp;    	
&nbsp;    	// loop through all enemy targets, pick a random one out of the closest.
&nbsp;    	// future revision: pick one that&#39;s the least evasive
<b class="nc">&nbsp;    	for(Targetable target : enemyTargets) {</b>
<b class="nc">&nbsp;    		LosEffects effects = LosEffects.calculateLos(spotter.getGame(), spotter.getId(), target);</b>
&nbsp;            
&nbsp;            // if we&#39;re in LOS
<b class="nc">&nbsp;    		if (effects.canSee()) {</b>
<b class="nc">&nbsp;    			int targetDistance = spotter.getPosition().distance(target.getPosition());</b>
<b class="nc">&nbsp;    			if(targetDistance &lt; shortestDistance) {</b>
<b class="nc">&nbsp;    				shortestDistance = targetDistance;</b>
<b class="nc">&nbsp;    				closestTargets.clear();</b>
<b class="nc">&nbsp;    				closestTargets.add(target);</b>
<b class="nc">&nbsp;    			} else if (targetDistance == shortestDistance) {</b>
<b class="nc">&nbsp;    				closestTargets.add(target);</b>
&nbsp;    			}
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
&nbsp;    	
&nbsp;    	// if we found one or more targets, pick at random from the closest ones.
&nbsp;    	// otherwise, we still can&#39;t spot
<b class="nc">&nbsp;    	if(closestTargets.size() &gt; 0) {</b>
<b class="nc">&nbsp;	    	Targetable target = closestTargets.get(Compute.randomInt(closestTargets.size()));</b>
<b class="nc">&nbsp;	    	return new SpotAction(spotter.getId(), target.getTargetId());</b>
&nbsp;    	}
&nbsp;    	
<b class="nc">&nbsp;    	return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Gets all the entities that are potential targets
&nbsp;     *
&nbsp;     * @param shooter The unit doing the shooting.
&nbsp;     * @param game    The game being played.
&nbsp;     * @return A list of potential targets.
&nbsp;     */
&nbsp;    protected List&lt;Targetable&gt; getTargetableEnemyEntities(final Entity shooter,
&nbsp;                                                        final IGame game,
&nbsp;                                                        final FireControlState fireControlState) {
<b class="nc">&nbsp;        final List&lt;Targetable&gt; targetableEnemyList = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        boolean shooterHasIDF = entityCanIndirectFireMissile(fireControlState, shooter);</b>
&nbsp;        
&nbsp;        // Go through every enemy unit 
<b class="nc">&nbsp;        for (final Entity entity : owner.getEnemyEntities()) {</b>
&nbsp;
&nbsp;            // If they are my enemy and we can either see them or have IDF capability
<b class="nc">&nbsp;            if (entity.isTargetable()) {</b>
&nbsp;
<b class="nc">&nbsp;                final LosEffects effects =</b>
<b class="nc">&nbsp;                        LosEffects.calculateLos(game, shooter.getId(), entity);</b>
&nbsp;                
&nbsp;                // if we&#39;re in LOS or we have IDF capability
<b class="nc">&nbsp;                if (effects.canSee() || shooterHasIDF) {</b>
<b class="nc">&nbsp;                    targetableEnemyList.add(entity);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Add in potential building targets and the like.
<b class="nc">&nbsp;        targetableEnemyList.addAll(fireControlState.getAdditionalTargets());</b>
&nbsp;
<b class="nc">&nbsp;        return targetableEnemyList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Variation on getTargetableEnemyEntities.
&nbsp;     * Returns all possible enemy targets, regardless of LOS status.
&nbsp;     * @param player The player from whose perspective enemies are determined.
&nbsp;     * @param game    The game being played.
&nbsp;     * @return A list of potential targets.
&nbsp;     */
&nbsp;    static List&lt;Targetable&gt; getAllTargetableEnemyEntities(final IPlayer player, final IGame game, final FireControlState fireControlState) {
<b class="nc">&nbsp;        final List&lt;Targetable&gt; targetableEnemyList = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;        // Go through every unit in the game.
<b class="nc">&nbsp;        for (final Entity entity : game.getEntitiesVector()) {</b>
&nbsp;
&nbsp;            // If they are my enemy and on the board, they&#39;re a target.
<b class="nc">&nbsp;            if (entity.getOwner().isEnemyOf(player)</b>
<b class="nc">&nbsp;                &amp;&amp; (null != entity.getPosition())</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isOffBoard()</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isTargetable()</b>
<b class="nc">&nbsp;                &amp;&amp; (null != entity.getCrew()) &amp;&amp; !entity.getCrew().isDead()) {</b>
<b class="nc">&nbsp;                targetableEnemyList.add(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Add in potential building targets and the like.
<b class="nc">&nbsp;        targetableEnemyList.addAll(fireControlState.getAdditionalTargets());</b>
&nbsp;
<b class="nc">&nbsp;        return targetableEnemyList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This is it. Calculate the &#39;best&#39; possible firing plan for this entity.
&nbsp;     * Overload this function if you think you can do better.
&nbsp;     *
&nbsp;     * @param shooter The unit doing the shooting.
&nbsp;     * @param game    The game being played.
&nbsp;     * @return The best firing plan according to our calculations.
&nbsp;     */
&nbsp;    FiringPlan getBestFiringPlan(final Entity shooter,
&nbsp;                                 final IHonorUtil honorUtil,
&nbsp;                                 final IGame game,
&nbsp;                                 final Map&lt;Mounted, Double&gt; ammoConservation) {
<b class="nc">&nbsp;        FiringPlan bestPlan = null;</b>
&nbsp;
&nbsp;        // Get a list of potential targets.
<b class="nc">&nbsp;        final List&lt;Targetable&gt; enemies = getTargetableEnemyEntities(shooter, game, owner.getFireControlState());</b>
&nbsp;
&nbsp;        // Loop through each enemy and find the best plan for attacking them.
<b class="nc">&nbsp;        for (final Targetable enemy : enemies) {</b>
&nbsp;
<b class="nc">&nbsp;            final boolean priorityTarget = owner.getPriorityUnitTargets().contains(enemy.getTargetId());</b>
&nbsp;
&nbsp;            // Skip retreating enemies so long as they haven&#39;t fired on me while retreating.
<b class="nc">&nbsp;            final int playerId = (enemy instanceof Entity) ? ((Entity) enemy).getOwnerId() : -1;</b>
<b class="nc">&nbsp;            if (!priorityTarget &amp;&amp; honorUtil.isEnemyBroken(enemy.getTargetId(), playerId,</b>
<b class="nc">&nbsp;                                                           owner.getForcedWithdrawal())) {</b>
<b class="nc">&nbsp;                owner.getLogger().info(enemy.getDisplayName() + &quot; is broken - ignoring&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final FiringPlanCalculationParameters parameters =</b>
<b class="nc">&nbsp;                    new FiringPlanCalculationParameters.Builder().buildExact(shooter,</b>
&nbsp;                                                                             enemy,
&nbsp;                                                                             ammoConservation);
<b class="nc">&nbsp;            final FiringPlan plan = determineBestFiringPlan(parameters);</b>
&nbsp;            
<b class="nc">&nbsp;            owner.getLogger().info(shooter.getDisplayName() + &quot; at &quot; + enemy</b>
<b class="nc">&nbsp;                    .getDisplayName() + &quot; - Best Firing Plan: &quot; + plan.getDebugDescription(true));</b>
<b class="nc">&nbsp;            if ((null == bestPlan) || (plan.getUtility() &gt; bestPlan.getUtility())) {</b>
<b class="nc">&nbsp;                bestPlan = plan;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // Return the best overall plan.
<b class="nc">&nbsp;        return bestPlan;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the maximum damage a unit can do at a given range.  Chance to hit is not a factor.
&nbsp;     *
&nbsp;     * @param shooter         The firing unit.
&nbsp;     * @param range           The range to be checked.
&nbsp;     * @param useExtremeRange Is the extreme range optional rule in effect?
&nbsp;     * @return The most damage done at that range.
&nbsp;     */
&nbsp;    // todo: cluster and other variable damage.
&nbsp;    public static double getMaxDamageAtRange(final Entity shooter,
&nbsp;                               final int range,
&nbsp;                               final boolean useExtremeRange,
&nbsp;                               final boolean useLOSRange) {
<b class="fc">&nbsp;        double maxDamage = 0;</b>
&nbsp;
&nbsp;        // cycle through my weapons
<b class="fc">&nbsp;        for (final Mounted weapon : shooter.getWeaponList()) {</b>
<b class="nc">&nbsp;            final WeaponType weaponType = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;            final int bracket = RangeType.rangeBracket(range,</b>
<b class="nc">&nbsp;                                                       weaponType.getRanges(weapon),</b>
&nbsp;                                                       useExtremeRange,
&nbsp;                                                       useLOSRange);
&nbsp;            // if the weapon has been disabled or is out of ammo, don&#39;t count it
<b class="nc">&nbsp;            if(weapon.isCrippled()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            int weaponDamage = weaponType.getDamage();</b>
&nbsp;            
&nbsp;            // just a ball park estimate of missile and/or other cluster damage
&nbsp;            // only a little over half of a cluster will generally hit
&nbsp;            // but some cluster munitions do more than 1 point of damage per individual hit
&nbsp;            // still better than just discounting them completely.
<b class="nc">&nbsp;            if(weaponDamage == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="nc">&nbsp;                weaponDamage = weaponType.getRackSize();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if ((RangeType.RANGE_OUT != bracket) &amp;&amp; (0 &lt; weaponDamage)) {</b>
<b class="nc">&nbsp;                maxDamage += weaponDamage;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return maxDamage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * makes sure facing falls between 0 and 5 This function likely already exists somewhere else
&nbsp;     *
&nbsp;     * @param facing The facing to be corrected.
&nbsp;     * @return The properly adjusted facing.
&nbsp;     */
&nbsp;    public static int correctFacing(int facing) {
<b class="nc">&nbsp;        while (0 &gt; facing) {</b>
<b class="nc">&nbsp;            facing += 6;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (5 &lt; facing) {</b>
<b class="nc">&nbsp;            facing = facing % 6;</b>
&nbsp;        }
<b class="nc">&nbsp;        return facing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure ammo is loaded for each weapon
&nbsp;     */
&nbsp;    void loadAmmo(final Entity shooter,
&nbsp;                  final FiringPlan plan) {
<b class="nc">&nbsp;        if (null == shooter) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (null == plan) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Loading ammo for all my weapons.
<b class="nc">&nbsp;        for (final WeaponFireInfo info : plan) {</b>
<b class="nc">&nbsp;            final Mounted currentWeapon = info.getWeapon();</b>
<b class="nc">&nbsp;            if (null == currentWeapon) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final WeaponType weaponType = (WeaponType) currentWeapon.getType();</b>
&nbsp;
&nbsp;            // Skip weapons that don&#39;t use ammo.
<b class="nc">&nbsp;            if (AmmoType.T_NA == weaponType.getAmmoType()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final Mounted mountedAmmo = getPreferredAmmo(shooter, info.getTarget(), currentWeapon);</b>
&nbsp;            // if we found preferred ammo but can&#39;t apply it to the weapon, log it and continue.
<b class="nc">&nbsp;            if ((null != mountedAmmo) &amp;&amp; !shooter.loadWeapon(currentWeapon, mountedAmmo)) {</b>
<b class="nc">&nbsp;                owner.getLogger().warning(shooter.getDisplayName() + &quot; tried to load &quot; </b>
<b class="nc">&nbsp;                          + currentWeapon.getName() + &quot; with ammo &quot; +</b>
<b class="nc">&nbsp;                          mountedAmmo.getDesc() + &quot; but failed somehow.&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            // if we didn&#39;t find preferred ammo after all, continue
<b class="nc">&nbsp;            } else if (mountedAmmo == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final WeaponAttackAction action = info.getAction();</b>
<b class="nc">&nbsp;            action.setAmmoId(shooter.getEquipmentNum(mountedAmmo));</b>
<b class="nc">&nbsp;            action.setAmmoCarrier(mountedAmmo.getEntity().getId());</b>
<b class="nc">&nbsp;            info.setAction(action);</b>
<b class="nc">&nbsp;            owner.sendAmmoChange(info.getShooter().getId(), shooter.getEquipmentNum(currentWeapon),</b>
<b class="nc">&nbsp;                                 shooter.getEquipmentNum(mountedAmmo));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    Mounted getClusterAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                           final WeaponType weaponType,
&nbsp;                           final int range) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()) {</b>
&nbsp;                // MMLs have additional considerations.
&nbsp;                // There are no &quot;cluster&quot; missile munitions at this point in time.  Code is included in case
&nbsp;                // they are added to the game at some later date.
<b class="fc">&nbsp;                if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="fc">&nbsp;                    returnAmmo = ammo;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    mmlLrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null == mmlSrm) {</b>
<b class="nc">&nbsp;                    mmlSrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null != mmlLrm) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="nc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="nc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="nc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="nc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getPreferredAmmo(final Entity shooter,
&nbsp;                             final Targetable target,
&nbsp;                             final Mounted weapon) {
<b class="fc">&nbsp;        final StringBuilder msg = new StringBuilder(&quot;Getting ammo for &quot;).append(weapon.getType().getShortName())</b>
<b class="fc">&nbsp;                                                                        .append(&quot; firing at &quot;)</b>
<b class="fc">&nbsp;                                                                        .append(target.getDisplayName</b>
<b class="fc">&nbsp;                        ());</b>
<b class="fc">&nbsp;        Entity targetEntity = null;</b>
<b class="fc">&nbsp;        Mounted preferredAmmo = null;</b>
<b class="fc">&nbsp;        WeaponType weaponType = (WeaponType) weapon.getType();</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            boolean fireResistant = false;</b>
<b class="fc">&nbsp;            if (target instanceof Entity) {</b>
<b class="fc">&nbsp;                targetEntity = (Entity) target;</b>
<b class="fc">&nbsp;                final int armorType = targetEntity.getArmorType(0);</b>
<b class="fc">&nbsp;                if (targetEntity instanceof Mech) {</b>
<b class="fc">&nbsp;                    targetEntity.getArmorType(1);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (EquipmentType.T_ARMOR_BA_FIRE_RESIST == armorType</b>
&nbsp;                    || EquipmentType.T_ARMOR_HEAT_DISSIPATING == armorType) {
<b class="fc">&nbsp;                    fireResistant = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Find the ammo that is valid for this weapon.
<b class="fc">&nbsp;            final List&lt;Mounted&gt; ammo = shooter.getAmmo();</b>
<b class="fc">&nbsp;            final List&lt;Mounted&gt; validAmmo = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (final Mounted a : ammo) {</b>
<b class="fc">&nbsp;                if (AmmoType.isAmmoValid(a, weaponType) &amp;&amp; AmmoType.canSwitchToAmmo(weapon, (AmmoType) a.getType())) {</b>
<b class="fc">&nbsp;                    validAmmo.add(a);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            // If no valid ammo was found, return nothing.
<b class="fc">&nbsp;            if (validAmmo.isEmpty()) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="fc">&nbsp;            msg.append(&quot;\n\tFound &quot;).append(validAmmo.size()).append(&quot; units of valid ammo.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            final int range = shooter.getPosition().distance(target.getPosition());</b>
<b class="fc">&nbsp;            msg.append(&quot;\n\tRange to target is &quot;).append(range);</b>
&nbsp;
&nbsp;            // AMS only uses 1 type of ammo.
<b class="fc">&nbsp;            if (weaponType.hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;                return validAmmo.get(0);</b>
&nbsp;            }
&nbsp;
&nbsp;            // ATMs
<b class="fc">&nbsp;            if (weaponType instanceof ATMWeapon) {</b>
<b class="fc">&nbsp;                return getAtmAmmo(validAmmo, range, new EntityState(target), fireResistant);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Target is a building.
<b class="fc">&nbsp;            if (target instanceof BuildingTarget) {</b>
<b class="fc">&nbsp;                msg.append(&quot;\n\tTarget is a building... &quot;);</b>
<b class="fc">&nbsp;                preferredAmmo = getIncendiaryAmmo(validAmmo, weaponType, range);</b>
<b class="fc">&nbsp;                if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                    msg.append(&quot;Burn It Down!&quot;);</b>
<b class="fc">&nbsp;                    return preferredAmmo;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Entity targets.
<b class="fc">&nbsp;            } else if (null != targetEntity) {</b>
&nbsp;                // Airborne targets
<b class="fc">&nbsp;                if (targetEntity.isAirborne() || (targetEntity instanceof VTOL)) {</b>
<b class="fc">&nbsp;                    msg.append(&quot;\n\tTarget is airborne... &quot;);</b>
<b class="fc">&nbsp;                    preferredAmmo = getAntiAirAmmo(validAmmo, weaponType, range);</b>
<b class="fc">&nbsp;                    if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                        msg.append(&quot;Shoot It Down!&quot;);</b>
<b class="fc">&nbsp;                        return preferredAmmo;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Battle Armor, Tanks and Protos, oh my!
<b class="fc">&nbsp;                if ((targetEntity instanceof BattleArmor)</b>
&nbsp;                    || (targetEntity instanceof Tank)
&nbsp;                    || (targetEntity instanceof Protomech)) {
<b class="fc">&nbsp;                    msg.append(&quot;\n\tTarget is BA/Proto/Tank... &quot;);</b>
<b class="fc">&nbsp;                    preferredAmmo = getAntiVeeAmmo(validAmmo, weaponType, range, fireResistant);</b>
<b class="fc">&nbsp;                    if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                        msg.append(&quot;We have ways of dealing with that.&quot;);</b>
<b class="fc">&nbsp;                        return preferredAmmo;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // PBI
<b class="fc">&nbsp;                if (targetEntity instanceof Infantry) {</b>
<b class="fc">&nbsp;                    msg.append(&quot;\n\tTarget is infantry... &quot;);</b>
<b class="fc">&nbsp;                    preferredAmmo = getAntiInfantryAmmo(validAmmo, weaponType, range);</b>
<b class="fc">&nbsp;                    if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                        msg.append(&quot;They squish nicely.&quot;);</b>
<b class="fc">&nbsp;                        return preferredAmmo;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // On his last legs
<b class="fc">&nbsp;                if (Entity.DMG_HEAVY &lt;= targetEntity.getDamageLevel()) {</b>
<b class="fc">&nbsp;                    msg.append(&quot;\n\tTarget is heavily damaged... &quot;);</b>
<b class="fc">&nbsp;                    preferredAmmo = getClusterAmmo(validAmmo, weaponType, range);</b>
<b class="fc">&nbsp;                    if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                        msg.append(&quot;Let&#39;s find a soft spot.&quot;);</b>
<b class="fc">&nbsp;                        return preferredAmmo;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // He&#39;s running hot.
<b class="fc">&nbsp;                if (9 &lt;= targetEntity.getHeat() &amp;&amp; !fireResistant) {</b>
<b class="fc">&nbsp;                    msg.append(&quot;\n\tTarget is at &quot;).append(targetEntity.getHeat()).append(&quot; heat... &quot;);</b>
<b class="fc">&nbsp;                    preferredAmmo = getHeatAmmo(validAmmo, weaponType, range);</b>
<b class="fc">&nbsp;                    if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                        msg.append(&quot;Let&#39;s heat him up more.&quot;);</b>
<b class="fc">&nbsp;                        return preferredAmmo;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Everything else.
<b class="fc">&nbsp;                msg.append(&quot;\n\tTarget is a hard target... &quot;);</b>
<b class="fc">&nbsp;                preferredAmmo = getHardTargetAmmo(validAmmo, weaponType, range);</b>
<b class="fc">&nbsp;                if (null != preferredAmmo) {</b>
<b class="fc">&nbsp;                    msg.append(&quot;Fill him with holes!&quot;);</b>
<b class="fc">&nbsp;                    return preferredAmmo;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If we&#39;ve gotten this far, no specialized ammo has been loaded
<b class="nc">&nbsp;            if (weaponType instanceof MMLWeapon) {</b>
<b class="nc">&nbsp;                msg.append(&quot;\n\tLoading MML Ammo.&quot;);</b>
<b class="nc">&nbsp;                preferredAmmo = getGeneralMmlAmmo(validAmmo, range);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg.append(&quot;\n\tLoading first available ammo.&quot;);</b>
<b class="nc">&nbsp;                preferredAmmo = validAmmo.get(0);</b>
&nbsp;            }
<b class="nc">&nbsp;            return preferredAmmo;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            msg.append(&quot;\n\tReturning: &quot;).append(null == preferredAmmo ? &quot;null&quot; : preferredAmmo.getDesc());</b>
<b class="fc">&nbsp;            owner.getLogger().debug(msg.toString());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getGeneralMmlAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                              final int range) {
&nbsp;        final Mounted returnAmmo;
&nbsp;
&nbsp;        // Get the LRM and SRM bins if we have them.
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType type = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if ((null == mmlLrm) &amp;&amp; type.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="fc">&nbsp;                mmlLrm = ammo;</b>
<b class="fc">&nbsp;            } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;                mmlSrm = ammo;</b>
&nbsp;            } else //noinspection ConstantConditions
<b class="nc">&nbsp;                if ((null != mmlSrm) &amp;&amp; (null != mmlLrm)) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Out of SRM range.
<b class="fc">&nbsp;        if (9 &lt; range) {</b>
<b class="fc">&nbsp;            returnAmmo = mmlLrm;</b>
&nbsp;
&nbsp;            // LRMs have better chance to hit if we have them.
<b class="fc">&nbsp;        } else if (5 &lt; range) {</b>
<b class="fc">&nbsp;            returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;
&nbsp;            // If we only have LRMs left.
<b class="fc">&nbsp;        } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;            returnAmmo = mmlLrm;</b>
&nbsp;
&nbsp;            // Left with SRMS.
&nbsp;        } else {
<b class="fc">&nbsp;            returnAmmo = mmlSrm;</b>
&nbsp;        }
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getAtmAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                       final int range,
&nbsp;                       final EntityState target,
&nbsp;                       final boolean fireResistant) {
&nbsp;        Mounted returnAmmo;
&nbsp;
&nbsp;        // Get the Hi-Ex, Ex-Range and Standard ammo bins if we have them.
<b class="fc">&nbsp;        Mounted heAmmo = null;</b>
<b class="fc">&nbsp;        Mounted erAmmo = null;</b>
<b class="fc">&nbsp;        Mounted stAmmo = null;</b>
<b class="fc">&nbsp;        Mounted infernoAmmo = null;</b>
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType type = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if ((null == heAmmo) &amp;&amp; (AmmoType.M_HIGH_EXPLOSIVE == type.getMunitionType())) {</b>
<b class="fc">&nbsp;                heAmmo = ammo;</b>
<b class="fc">&nbsp;            } else if ((null == erAmmo) &amp;&amp; (AmmoType.M_EXTENDED_RANGE == type.getMunitionType())) {</b>
<b class="fc">&nbsp;                erAmmo = ammo;</b>
<b class="fc">&nbsp;            } else if ((null == stAmmo) &amp;&amp; (AmmoType.M_STANDARD == type.getMunitionType())) {</b>
<b class="fc">&nbsp;                stAmmo = ammo;</b>
<b class="fc">&nbsp;            } else if ((null == infernoAmmo) &amp;&amp; (AmmoType.M_IATM_IIW == type.getMunitionType())) {</b>
<b class="fc">&nbsp;                infernoAmmo = ammo;</b>
<b class="fc">&nbsp;            } else if ((null != heAmmo) &amp;&amp; (null != erAmmo) &amp;&amp; (null != stAmmo) &amp;&amp; (null != infernoAmmo)) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Beyond 15 hexes is ER Ammo only range.
<b class="fc">&nbsp;        if (15 &lt; range) {</b>
<b class="fc">&nbsp;            returnAmmo = erAmmo;</b>
&nbsp;            // ER Ammo has a better chance to hit past 10 hexes.
<b class="fc">&nbsp;        } else if (10 &lt; range) {</b>
<b class="fc">&nbsp;            returnAmmo = (null == erAmmo ? stAmmo : erAmmo);</b>
&nbsp;            // At 7-10 hexes, go with Standard, then ER then HE due to hit odds.
<b class="fc">&nbsp;        } else if (6 &lt; range) {</b>
<b class="fc">&nbsp;            if (null != stAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = stAmmo;</b>
<b class="fc">&nbsp;            } else if (null != erAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = erAmmo;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                returnAmmo = heAmmo;</b>
&nbsp;            }
&nbsp;            // Six hexes is at min for ER, and medium for both ST &amp; HE.
<b class="fc">&nbsp;        } else if (6 == range) {</b>
<b class="fc">&nbsp;            if (null != heAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = heAmmo;</b>
<b class="fc">&nbsp;            } else if (null != stAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = stAmmo;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                returnAmmo = erAmmo;</b>
&nbsp;            }
&nbsp;            // 4-5 hexes is medium for HE, short for ST and well within min for ER.
<b class="fc">&nbsp;        } else if (3 &lt; range) {</b>
<b class="fc">&nbsp;            if (null != stAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = stAmmo;</b>
<b class="fc">&nbsp;            } else if (null != heAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = heAmmo;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                returnAmmo = erAmmo;</b>
&nbsp;            }
&nbsp;            // Short range for HE.
&nbsp;        } else {
<b class="fc">&nbsp;            if (null != heAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = heAmmo;</b>
<b class="fc">&nbsp;            } else if (null != stAmmo) {</b>
<b class="fc">&nbsp;                returnAmmo = stAmmo;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                returnAmmo = erAmmo;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if ((returnAmmo == stAmmo) &amp;&amp; (null != infernoAmmo)</b>
<b class="fc">&nbsp;            &amp;&amp; ((9 &lt;= target.getHeat()) || target.isBuilding())</b>
&nbsp;            &amp;&amp; !fireResistant) {
<b class="fc">&nbsp;            returnAmmo = infernoAmmo;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getAntiVeeAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                           final WeaponType weaponType,
&nbsp;                           final int range,
&nbsp;                           final boolean fireResistant) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || (AmmoType.M_INFERNO == ammoType.getMunitionType() &amp;&amp; !fireResistant)</b>
<b class="fc">&nbsp;                || (AmmoType.M_INFERNO_IV == ammoType.getMunitionType() &amp;&amp; !fireResistant)) {</b>
&nbsp;
&nbsp;                // MMLs have additional considerations.
<b class="fc">&nbsp;                if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="fc">&nbsp;                    returnAmmo = ammo;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    mmlLrm = ammo;</b>
<b class="fc">&nbsp;                } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;                    mmlSrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null != mmlLrm) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="fc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="fc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="fc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="fc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getAntiInfantryAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                                final WeaponType weaponType,
&nbsp;                                final int range) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_FLECHETTE == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FRAGMENTATION == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_CLUSTER == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()) {</b>
&nbsp;
&nbsp;                // MMLs have additional considerations.
<b class="fc">&nbsp;                if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="fc">&nbsp;                    returnAmmo = ammo;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="fc">&nbsp;                    mmlLrm = ammo;</b>
<b class="fc">&nbsp;                } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;                    mmlSrm = ammo;</b>
&nbsp;                } else //noinspection ConstantConditions
<b class="nc">&nbsp;                    if ((null != mmlLrm) &amp;&amp; (null != mmlSrm)) {</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="fc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="fc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="fc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="fc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Mounted getHeatAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                                final WeaponType weaponType,
&nbsp;                                final int range) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_INFERNO == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()) {</b>
&nbsp;
&nbsp;                // MMLs have additional considerations.
<b class="fc">&nbsp;                if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="nc">&nbsp;                    returnAmmo = ammo;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    mmlLrm = ammo;</b>
<b class="fc">&nbsp;                } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;                    mmlSrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null != mmlLrm) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="fc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="nc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="fc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="nc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getIncendiaryAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                              final WeaponType weaponType,
&nbsp;                              final int range) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_INCENDIARY == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INCENDIARY_LRM == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INCENDIARY_AC == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()) {</b>
&nbsp;
&nbsp;                // MMLs have additional considerations.
<b class="fc">&nbsp;                if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="fc">&nbsp;                    returnAmmo = ammo;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    mmlLrm = ammo;</b>
<b class="fc">&nbsp;                } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;                    mmlSrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null != mmlLrm) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="fc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="fc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="fc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="fc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getHardTargetAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                              final WeaponType weaponType,
&nbsp;                              final int range) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_ANTI_FLAME_FOAM == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_CHAFF == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_COOLANT == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_ECM == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FASCAM == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FLAK == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FLARE == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FLECHETTE == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FRAGMENTATION == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_HAYWIRE == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INCENDIARY == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INCENDIARY_AC == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INCENDIARY_LRM == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_LASER_INHIB == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_OIL_SLICK == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_NEMESIS == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_PAINT_OBSCURANT == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_SMOKE == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_SMOKE_WARHEAD == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_THUNDER == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_THUNDER_ACTIVE == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_THUNDER_AUGMENTED == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_THUNDER_INFERNO == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_THUNDER_VIBRABOMB == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_TORPEDO == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_VIBRABOMB_IV == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_WATER == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_ANTI_TSM == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_CORROSIVE == ammoType.getMunitionType()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // MMLs have additional considerations.
<b class="fc">&nbsp;            if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="fc">&nbsp;                returnAmmo = ammo;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;            if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="fc">&nbsp;                mmlLrm = ammo;</b>
<b class="fc">&nbsp;            } else if (null == mmlSrm) {</b>
<b class="fc">&nbsp;                mmlSrm = ammo;</b>
&nbsp;            } else //noinspection ConstantConditions
<b class="nc">&nbsp;                if ((null != mmlLrm) &amp;&amp; (null != mmlSrm)) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="fc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="fc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="fc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="fc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mounted getAntiAirAmmo(final List&lt;Mounted&gt; ammoList,
&nbsp;                           final WeaponType weaponType,
&nbsp;                           final int range) {
<b class="fc">&nbsp;        Mounted returnAmmo = null;</b>
<b class="fc">&nbsp;        Mounted mmlLrm = null;</b>
<b class="fc">&nbsp;        Mounted mmlSrm = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Mounted ammo : ammoList) {</b>
<b class="fc">&nbsp;            final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="fc">&nbsp;            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()</b>
<b class="fc">&nbsp;                || AmmoType.M_FLAK == ammoType.getMunitionType()) {</b>
&nbsp;
&nbsp;                // MMLs have additional considerations.
&nbsp;                // There are no &quot;flak&quot; or &quot;cluster&quot; missile munitions at this point in time.  Code is included in case
&nbsp;                // they are added to the game at some later date.
<b class="fc">&nbsp;                if (!(weaponType instanceof MMLWeapon)) {</b>
<b class="fc">&nbsp;                    returnAmmo = ammo;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                    mmlLrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null == mmlSrm) {</b>
<b class="nc">&nbsp;                    mmlSrm = ammo;</b>
<b class="nc">&nbsp;                } else if (null != mmlLrm) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // MML ammo depends on range.
<b class="fc">&nbsp;        if (weaponType instanceof MMLWeapon) {</b>
<b class="nc">&nbsp;            if (9 &lt; range) { // Out of SRM range</b>
<b class="nc">&nbsp;                returnAmmo = mmlLrm;</b>
<b class="nc">&nbsp;            } else if (6 &lt; range) { // SRM long range.</b>
<b class="nc">&nbsp;                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return returnAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Helper method that figures out the valid facing changes for the given shooter
&nbsp;    public static List&lt;Integer&gt; getValidFacingChanges(final Entity shooter) {
&nbsp;        // figure out all valid twists or turret turns
&nbsp;        // mechs can turn:
&nbsp;        //		one left, one right unless he has &quot;no torso twist&quot; quirk or is on the ground
&nbsp;        //		two left, two right if he has &quot;extended torso twist&quot; quirk
&nbsp;        // vehicles and turrets can turn any direction unless he has no turret
<b class="nc">&nbsp;        final List&lt;Integer&gt; validFacingChanges = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        if (((Entity.ETYPE_MECH &amp; shooter.getEntityType()) &gt; 0)</b>
<b class="nc">&nbsp;            &amp;&amp; !shooter.hasQuirk(OptionsConstants.QUIRK_NEG_NO_TWIST)</b>
<b class="nc">&nbsp;            &amp;&amp; !shooter.hasFallen()) {</b>
<b class="nc">&nbsp;            validFacingChanges.add(1);</b>
<b class="nc">&nbsp;            validFacingChanges.add(-1);</b>
&nbsp;
<b class="nc">&nbsp;            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_EXT_TWIST)) {</b>
<b class="nc">&nbsp;                validFacingChanges.add(2);</b>
<b class="nc">&nbsp;                validFacingChanges.add(-2);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if ((shooter instanceof Tank</b>
<b class="nc">&nbsp;                   &amp;&amp; !((Tank) shooter).hasNoTurret()) || (shooter instanceof Infantry)) {</b>
<b class="nc">&nbsp;            validFacingChanges.add(1);</b>
<b class="nc">&nbsp;            validFacingChanges.add(-1);</b>
<b class="nc">&nbsp;            validFacingChanges.add(2);</b>
<b class="nc">&nbsp;            validFacingChanges.add(-2);</b>
<b class="nc">&nbsp;            validFacingChanges.add(3);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return validFacingChanges;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * This function evaluates whether or not a unit should spend its time
&nbsp;     * unjamming weapons instead of firing, and returns the appropriate firing plan if that&#39;s the case.
&nbsp;     * @param shooter Entity being considered.
&nbsp;     * @return Unjam action plan, if we conclude that we should spend time unjamming weapons.
&nbsp;     */
&nbsp;    public Vector&lt;EntityAction&gt; getUnjamWeaponPlan(Entity shooter) {
<b class="nc">&nbsp;        int maxJammedDamage = 0;</b>
<b class="nc">&nbsp;        int maxDamageWeaponID = -1;</b>
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; unjamVector = new Vector&lt;&gt;();</b>
&nbsp;        
&nbsp;        // apparently, only tank type units can unjam weapons/clear turrets
<b class="nc">&nbsp;        if(!shooter.hasETypeFlag(Entity.ETYPE_TANK)) {</b>
<b class="nc">&nbsp;            return unjamVector;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Tank tankShooter = (Tank) shooter;</b>
&nbsp;        
&nbsp;        // can&#39;t unjam if crew is stunned. Skip the rest of the logic to save time. 
<b class="nc">&nbsp;        if(tankShooter.getStunnedTurns() &gt; 0) {</b>
<b class="nc">&nbsp;            return unjamVector;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // step 1: loop through all the unit&#39;s jammed weapons to determine the biggest one
<b class="nc">&nbsp;        for(Mounted mounted : tankShooter.getJammedWeapons()) {</b>
<b class="nc">&nbsp;            int weaponDamage = ((WeaponType) mounted.getType()).getDamage();</b>
<b class="nc">&nbsp;            if(weaponDamage == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="nc">&nbsp;                weaponDamage = ((WeaponType) mounted.getType()).getRackSize();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if(weaponDamage &gt; maxJammedDamage) {</b>
<b class="nc">&nbsp;                    maxDamageWeaponID = shooter.getEquipmentNum(mounted);</b>
<b class="nc">&nbsp;                    maxJammedDamage = weaponDamage;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;                
&nbsp;        // if any of the unit&#39;s weapons are jammed, unjam the biggest one.
&nbsp;        // we can only unjam one per turn.
<b class="nc">&nbsp;        if(maxDamageWeaponID &gt;= 0) {</b>
<b class="nc">&nbsp;            RepairWeaponMalfunctionAction rwma = new RepairWeaponMalfunctionAction(</b>
<b class="nc">&nbsp;                    shooter.getId(), maxDamageWeaponID);</b>
&nbsp;            
<b class="nc">&nbsp;            unjamVector.add(rwma);</b>
&nbsp;        // if the unit has a jammed turret, attempt to clear it
<b class="nc">&nbsp;        } else if(tankShooter.canClearTurret()) {</b>
<b class="nc">&nbsp;            UnjamTurretAction uta = new UnjamTurretAction(shooter.getId());</b>
<b class="nc">&nbsp;            unjamVector.add(uta);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return unjamVector;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given a firing plan, calculate the best target to light up with a searchlight
&nbsp;     */
&nbsp;    public SearchlightAttackAction getSearchLightAction(Entity shooter, FiringPlan plan) {
&nbsp;        // no search light if it&#39;s not on, unit doesn&#39;t have one, or is hidden
<b class="nc">&nbsp;        if(!shooter.isUsingSpotlight() || !shooter.hasSpotlight() || shooter.isHidden()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // assemble set of targets we&#39;re planning on shooting
<b class="nc">&nbsp;        Set&lt;Coords&gt; planTargets = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        if(plan != null) {</b>
<b class="nc">&nbsp;            for(WeaponFireInfo wfi : plan) {</b>
<b class="nc">&nbsp;                planTargets.add(wfi.getTarget().getPosition());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        List&lt;SearchlightAttackAction&gt; searchlights = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (EntityAction action : shooter.getGame().getActionsVector()) {</b>
<b class="nc">&nbsp;            if (action instanceof SearchlightAttackAction) {</b>
<b class="nc">&nbsp;                searchlights.add((SearchlightAttackAction) action);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // for each potential target on the board, draw a line between &quot;shooter&quot; and target
&nbsp;        // and assign it a score. Score is determined by:
&nbsp;        // # hostiles lit up - # friendlies lit up + # targets lit up
<b class="nc">&nbsp;        Targetable bestTarget = null;</b>
<b class="nc">&nbsp;        int bestTargetScore = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for(Targetable target : getTargetableEnemyEntities(shooter, shooter.getGame(), owner.getFireControlState())) {</b>
<b class="nc">&nbsp;            int score = 0;</b>
&nbsp;            
<b class="nc">&nbsp;            for(Coords intervening : Coords.intervening(shooter.getPosition(), target.getPosition())) {</b>
&nbsp;                // if it&#39;s already lit up, don&#39;t count it 
<b class="nc">&nbsp;                if(shooter.getGame().isPositionIlluminated(intervening) &gt; 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                for(Entity ent : shooter.getGame().getEntitiesVector(intervening, true)) {</b>
&nbsp;                    // don&#39;t count ourselves, or the target if it&#39;s already lit itself up
&nbsp;                    // or the target if it will be lit up by a previously declared search light
<b class="nc">&nbsp;                    if((ent.getId() == shooter.getId()) || ent.isIlluminated()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        boolean willbeIlluminated = false;</b>
&nbsp;                        
<b class="nc">&nbsp;                        for(SearchlightAttackAction searchlight : searchlights) {</b>
<b class="nc">&nbsp;                            if(searchlight.willIlluminate(shooter.getGame(), ent)) {</b>
<b class="nc">&nbsp;                                willbeIlluminated = true;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                        
<b class="nc">&nbsp;                        if(willbeIlluminated) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if(ent.isEnemyOf(shooter)) {</b>
<b class="nc">&nbsp;                        score++;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        score--;</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if(planTargets.contains(intervening)) {</b>
<b class="nc">&nbsp;                        score++;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            
&nbsp;            // don&#39;t bother considering impossible searchlight actions
<b class="nc">&nbsp;            if(score &gt; bestTargetScore &amp;&amp; SearchlightAttackAction.isPossible(shooter.getGame(), shooter.getId(), target, null)) {</b>
<b class="nc">&nbsp;                bestTargetScore = score;</b>
<b class="nc">&nbsp;                bestTarget = target;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        if(bestTarget != null) {</b>
<b class="nc">&nbsp;            SearchlightAttackAction slaa = new SearchlightAttackAction(shooter.getId(), bestTarget.getTargetType(), bestTarget.getTargetId());</b>
<b class="nc">&nbsp;            return slaa;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Attempts to switch the current weapon&#39;s firing mode between direct and indirect
&nbsp;     * or vice versa. Returns -1 if the mode switch fails, or the weapon mode index if it succeeds.
&nbsp;     * @return Mode switch result.
&nbsp;     */
&nbsp;    private int switchMissileMode(Mounted weapon) {
&nbsp;        // check that we&#39;re operating a missile weapon that can switch direct/indirect modes
&nbsp;        // don&#39;t bother checking non-missile weapons
<b class="fc">&nbsp;        if (weapon.getType().hasFlag(Weapon.F_MISSILE) &amp;&amp;</b>
<b class="nc">&nbsp;                weapon.getType().hasModeType(Weapon.MODE_MISSILE_INDIRECT)) {</b>
&nbsp;            
&nbsp;            // if we are able to switch the weapon to indirect fire mode, do so and try again
<b class="nc">&nbsp;            if (!weapon.curMode().equals(Weapon.MODE_MISSILE_INDIRECT)) {</b>
<b class="nc">&nbsp;                return weapon.setMode(Weapon.MODE_MISSILE_INDIRECT);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return weapon.setMode(&quot;&quot;);</b>
&nbsp;            }
&nbsp;        }       
&nbsp;        
<b class="fc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
