


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Precognition</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot.princess</a>
</div>

<h1>Coverage Summary for Class: Precognition (megamek.client.bot.princess)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Precognition</td>
<td class="coverageStat">
  <span class="percent">
    27.9%
  </span>
  <span class="absValue">
    (12/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10.7%
  </span>
  <span class="absValue">
    (49/457)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Precognition$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    28.3%
  </span>
  <span class="absValue">
    (13/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10.8%
  </span>
  <span class="absValue">
    (50/464)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000-2011 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.client.bot.princess;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.ConcurrentLinkedQueue;
&nbsp;import java.util.concurrent.ConcurrentSkipListSet;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;
&nbsp;import megamek.client.bot.princess.BotGeometry.CoordFacingCombo;
&nbsp;import megamek.common.Board;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.ComputeECM;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.ECMInfo;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.Flare;
&nbsp;import megamek.common.Game;
&nbsp;import megamek.common.GameTurn;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.IPlayer;
&nbsp;import megamek.common.Minefield;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.PlanetaryConditions;
&nbsp;import megamek.common.Report;
&nbsp;import megamek.common.SpecialHexDisplay;
&nbsp;import megamek.common.TagInfo;
&nbsp;import megamek.common.UnitLocation;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.ClubAttackAction;
&nbsp;import megamek.common.actions.DodgeAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.FlipArmsAction;
&nbsp;import megamek.common.actions.TorsoTwistAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.event.GameBoardChangeEvent;
&nbsp;import megamek.common.event.GameCFREvent;
&nbsp;import megamek.common.event.GameEntityChangeEvent;
&nbsp;import megamek.common.event.GameEvent;
&nbsp;import megamek.common.event.GameListenerAdapter;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.event.GamePlayerChatEvent;
&nbsp;import megamek.common.event.GameSettingsChangeEvent;
&nbsp;import megamek.common.event.GameVictoryEvent;
&nbsp;import megamek.common.net.Packet;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;import megamek.server.SmokeCloud;
&nbsp;
&nbsp;/**
&nbsp; * unit_potential_locations keeps track of all the potential coordinates and
&nbsp; * facings a unit could reach It tries to keep all the calculations up to date,
&nbsp; * and do most of the work when the opponent is moving
&nbsp; */
<b class="fc">&nbsp;public class Precognition implements Runnable {</b>
&nbsp;
&nbsp;    private final Princess owner;
&nbsp;    
&nbsp;    /**
&nbsp;     *  Precognition&#39;s version of the game, which should mirror the game in
&nbsp;     *  Princess, but should not be the same reference.  If Precognition and
&nbsp;     *  Princess share the same game reference, than this will cause concurrency
&nbsp;     *  issues. 
&nbsp;     */
&nbsp;    private IGame game;
<b class="fc">&nbsp;    private final ReentrantLock GAME_LOCK = new ReentrantLock();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Computing ECMInfo requires iterating over all Entities in the Game and 
&nbsp;     * this can be an expensive operation, so it&#39;s cheaper to use cache it and
&nbsp;     * re-use the cache.
&nbsp;     */
&nbsp;    private List&lt;ECMInfo&gt; ecmInfo;
&nbsp;        
&nbsp;    private PathEnumerator pathEnumerator;
<b class="fc">&nbsp;    private final ReentrantReadWriteLock PATH_ENUMERATOR_LOCK = new ReentrantReadWriteLock();</b>
&nbsp;
&nbsp;
&nbsp;    // units who&#39;s path I need to update
<b class="fc">&nbsp;    private final ConcurrentSkipListSet&lt;Integer&gt; dirtyUnits = new ConcurrentSkipListSet&lt;&gt;();</b>
&nbsp;
&nbsp;    // events that may affect which units are dirty
<b class="fc">&nbsp;    private final ConcurrentLinkedQueue&lt;GameEvent&gt; eventsToProcess = new ConcurrentLinkedQueue&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private final AtomicBoolean waitWhenDone = new AtomicBoolean(false); // used for pausing</b>
<b class="fc">&nbsp;    private final AtomicBoolean waiting = new AtomicBoolean(false);</b>
<b class="fc">&nbsp;    private final AtomicBoolean done = new AtomicBoolean(false);</b>
&nbsp;
<b class="fc">&nbsp;    public Precognition(Princess owner) {</b>
<b class="fc">&nbsp;        this.owner = owner;</b>
<b class="fc">&nbsp;        this.game = new Game();</b>
<b class="fc">&nbsp;        getGame().addGameListener(new GameListenerAdapter() {</b>
&nbsp;            @Override
&nbsp;            public void gameEntityChange(GameEntityChangeEvent changeEvent) {
<b class="nc">&nbsp;                getEventsToProcess().add(changeEvent);</b>
<b class="nc">&nbsp;                wakeUp();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void gamePhaseChange(GamePhaseChangeEvent changeEvent) {
<b class="nc">&nbsp;                getEventsToProcess().add(changeEvent);</b>
<b class="nc">&nbsp;                wakeUp();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        });
<b class="fc">&nbsp;        setPathEnumerator(new PathEnumerator(owner, getGame()));</b>
&nbsp;        // Initialize ECM Info, especially important if Princess added mid-game
<b class="fc">&nbsp;        ecmInfo = ComputeECM.computeAllEntitiesECMInfo(</b>
<b class="fc">&nbsp;                getGame().getEntitiesVector());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Pared down version of Client.handlePacket; essentially it&#39;s only looking
&nbsp;     * for packets that update Game.  This ensures that Precognition&#39;s Game
&nbsp;     * instance stays up-to-date with Princess&#39;s instance of Game.
&nbsp;     * @param c The packet to be handled.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    void handlePacket(Packet c) {
<b class="nc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            getOwner().getLogger().warning(&quot;Client: got null packet&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // Game isn&#39;t thread safe; other threads shouldn&#39;t use  game while
&nbsp;        // it may be being updated
<b class="nc">&nbsp;        GAME_LOCK.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;        switch (c.getCommand()) {</b>
&nbsp;            case Packet.COMMAND_PLAYER_UPDATE:
<b class="nc">&nbsp;                receivePlayerInfo(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_PLAYER_READY:
<b class="nc">&nbsp;                getPlayer(c.getIntValue(0)).setDone(c.getBooleanValue(1));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_PLAYER_ADD:
<b class="nc">&nbsp;                receivePlayerInfo(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_PLAYER_REMOVE:
<b class="nc">&nbsp;                getGame().removePlayer(c.getIntValue(0));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CHAT:
<b class="nc">&nbsp;                getGame().processGameEvent(new GamePlayerChatEvent(this, null, </b>
<b class="nc">&nbsp;                        (String) c.getObject(0)));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_ADD:
<b class="nc">&nbsp;                receiveEntityAdd(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_UPDATE:
<b class="nc">&nbsp;                receiveEntityUpdate(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_REMOVE:
<b class="nc">&nbsp;                receiveEntityRemove(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR:
<b class="nc">&nbsp;                receiveEntityVisibilityIndicator(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_MINEFIELDS:
<b class="nc">&nbsp;                receiveSendingMinefields(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_ILLUM_HEXES:
<b class="nc">&nbsp;                receiveIlluminatedHexes(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CLEAR_ILLUM_HEXES:
<b class="nc">&nbsp;                getGame().clearIlluminatedPositions();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_UPDATE_MINEFIELDS:
<b class="nc">&nbsp;                receiveUpdateMinefields(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_DEPLOY_MINEFIELDS:
<b class="nc">&nbsp;                receiveDeployMinefields(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_REVEAL_MINEFIELD:
<b class="nc">&nbsp;                receiveRevealMinefield(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_REMOVE_MINEFIELD:
<b class="nc">&nbsp;                receiveRemoveMinefield(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ADD_SMOKE_CLOUD:
<b class="nc">&nbsp;                SmokeCloud cloud = (SmokeCloud) c.getObject(0);</b>
<b class="nc">&nbsp;                getGame().addSmokeCloud(cloud);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CHANGE_HEX:
<b class="nc">&nbsp;                getGame().getBoard().setHex((Coords) c.getObject(0),</b>
<b class="nc">&nbsp;                                       (IHex) c.getObject(1));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CHANGE_HEXES:
<b class="nc">&nbsp;                List&lt;Coords&gt; coords = new ArrayList&lt;&gt;(</b>
<b class="nc">&nbsp;                        (Set&lt;Coords&gt;) c.getObject(0));</b>
<b class="nc">&nbsp;                List&lt;IHex&gt; hexes = new ArrayList&lt;&gt;(</b>
<b class="nc">&nbsp;                        (Set&lt;IHex&gt;) c.getObject(1));</b>
<b class="nc">&nbsp;                getGame().getBoard().setHexes(coords, hexes);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_BLDG_UPDATE:
<b class="nc">&nbsp;                receiveBuildingUpdate(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_BLDG_COLLAPSE:
<b class="nc">&nbsp;                receiveBuildingCollapse(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_PHASE_CHANGE:
<b class="nc">&nbsp;                getGame().setPhase((IGame.Phase) c.getObject(0));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_TURN:
<b class="nc">&nbsp;                getGame().setTurnIndex(c.getIntValue(0), c.getIntValue(1));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ROUND_UPDATE:
<b class="nc">&nbsp;                getGame().setRoundCount(c.getIntValue(0));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_TURNS:
<b class="nc">&nbsp;                receiveTurns(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_BOARD:
<b class="nc">&nbsp;                receiveBoard(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_ENTITIES:
<b class="nc">&nbsp;                receiveEntities(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_REPORTS:
&nbsp;            case Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS:
<b class="nc">&nbsp;                getGame().addReports((Vector&lt;Report&gt;) c.getObject(0));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_REPORTS_ALL:
<b class="nc">&nbsp;                Vector&lt;Vector&lt;Report&gt;&gt; allReports = (Vector&lt;Vector&lt;Report&gt;&gt;) c</b>
<b class="nc">&nbsp;                        .getObject(0);</b>
<b class="nc">&nbsp;                getGame().setAllReports(allReports);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_ATTACK:
<b class="nc">&nbsp;                receiveAttack(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_GAME_SETTINGS:
<b class="nc">&nbsp;                getGame().setOptions((GameOptions) c.getObject(0));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_PLANETARY_CONDITIONS:
<b class="nc">&nbsp;                getGame().setPlanetaryConditions((PlanetaryConditions) c</b>
<b class="nc">&nbsp;                        .getObject(0));</b>
<b class="nc">&nbsp;                getGame().processGameEvent(new GameSettingsChangeEvent(this));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_TAGINFO:
<b class="nc">&nbsp;                Vector&lt;TagInfo&gt; vti = (Vector&lt;TagInfo&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;                for (TagInfo ti : vti) {</b>
<b class="nc">&nbsp;                    getGame().addTagInfo(ti);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_RESET_TAGINFO:
<b class="nc">&nbsp;                getGame().resetTagInfo();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_ARTILLERYATTACKS:
<b class="nc">&nbsp;                Vector&lt;ArtilleryAttackAction&gt; v = (Vector&lt;ArtilleryAttackAction&gt;) c</b>
<b class="nc">&nbsp;                        .getObject(0);</b>
<b class="nc">&nbsp;                getGame().setArtilleryVector(v);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_FLARES:
<b class="nc">&nbsp;                Vector&lt;Flare&gt; v2 = (Vector&lt;Flare&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;                getGame().setFlares(v2);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_SENDING_SPECIAL_HEX_DISPLAY:
<b class="nc">&nbsp;                getGame().getBoard().setSpecialHexDisplayTable(</b>
&nbsp;                        (Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt;) c
<b class="nc">&nbsp;                                .getObject(0));</b>
<b class="nc">&nbsp;                getGame().processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE:
<b class="nc">&nbsp;                receiveEntityNovaNetworkModeChange(c);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CLIENT_FEEDBACK_REQUEST:
<b class="nc">&nbsp;                int cfrType = (int) c.getData()[0];</b>
<b class="nc">&nbsp;                GameCFREvent cfrEvt = new GameCFREvent(this, cfrType);</b>
<b class="nc">&nbsp;                switch (cfrType) {</b>
&nbsp;                    case (Packet.COMMAND_CFR_DOMINO_EFFECT):
<b class="nc">&nbsp;                        cfrEvt.setEntityId((int) c.getData()[1]);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case Packet.COMMAND_CFR_AMS_ASSIGN:
<b class="nc">&nbsp;                        cfrEvt.setEntityId((int) c.getData()[1]);</b>
<b class="nc">&nbsp;                        cfrEvt.setAmsEquipNum((int) c.getData()[2]);</b>
<b class="nc">&nbsp;                        cfrEvt.setWAAs((List&lt;WeaponAttackAction&gt;) c.getData()[3]);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case Packet.COMMAND_CFR_APDS_ASSIGN:
<b class="nc">&nbsp;                        cfrEvt.setEntityId((int) c.getData()[1]);</b>
<b class="nc">&nbsp;                        cfrEvt.setApdsDists((List&lt;Integer&gt;) c.getData()[2]);</b>
<b class="nc">&nbsp;                        cfrEvt.setWAAs((List&lt;WeaponAttackAction&gt;) c.getData()[3]);</b>
&nbsp;                        break;
&nbsp;                }
<b class="nc">&nbsp;                getGame().processGameEvent(cfrEvt);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_GAME_VICTORY_EVENT:
<b class="nc">&nbsp;                GameVictoryEvent gve = new GameVictoryEvent(this, getGame());</b>
<b class="nc">&nbsp;                getGame().processGameEvent(gve);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;        } finally {
<b class="nc">&nbsp;            GAME_LOCK.unlock();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void pause() {
<b class="nc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            getWaitWhenDone().set(true);</b>
<b class="nc">&nbsp;            while (!getWaiting().get() &amp;&amp; !getDone().get()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    Thread.sleep(100);</b>
<b class="nc">&nbsp;                } catch (InterruptedException ignored) {</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    synchronized void unPause() {
<b class="nc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            getWaitWhenDone().set(false);</b>
<b class="nc">&nbsp;            notifyAll();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tells the thread there&#39;s something to do Note, you can&#39;t just call
&nbsp;     * notifyAll in the event listener because it doesn&#39;t have the thread
&nbsp;     * something something.
&nbsp;     */
&nbsp;    private synchronized void wakeUp() {
<b class="nc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            notifyAll();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean isEntityOnMap(final Entity entity) {
<b class="nc">&nbsp;        return entity.isDeployed() &amp;&amp; !entity.isOffBoard();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure pathEnumerator has up to date information about other units
&nbsp;     * locations call this right before making a move. automatically pauses.
&nbsp;     */
&nbsp;    void ensureUpToDate() {
<b class="nc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            pause();</b>
<b class="nc">&nbsp;            for (Entity entity : getGame().getEntitiesVector()) {</b>
&nbsp;                // If Precog is done, just exit
<b class="nc">&nbsp;                if (getDone().get()) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!isEntityOnMap(entity)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (((!getPathEnumerator().getLastKnownLocations().containsKey(entity.getId()))</b>
<b class="nc">&nbsp;                     || (!getPathEnumerator().getLastKnownLocations().get(entity.getId())</b>
<b class="nc">&nbsp;                                             .equals(CoordFacingCombo.createCoordFacingCombo(entity))))) {</b>
&nbsp;                    // System.err.println(&quot;entity &quot;+entity.getDisplayName()+&quot; not where I left it&quot;);
&nbsp;                    // if(pathEnumerator.last_known_location.containsKey(entity.getId()))
&nbsp;                    // System.err.println(&quot;  I thought it was at &quot;+pathEnumerator.last_known_location.get(entity
&nbsp;                    // .getId()).coords+&quot; but its actually at &quot;+entity.getPosition());
&nbsp;                    // else
&nbsp;                    // System.err.println(&quot;  I had no idea where it was&quot;);
<b class="nc">&nbsp;                    dirtifyUnit(entity.getId());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            while (!getDirtyUnits().isEmpty()) {</b>
&nbsp;                // If Precog is done, just exit
<b class="nc">&nbsp;                if (getDone().get()) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                Integer entityId = getDirtyUnits().pollFirst();</b>
<b class="nc">&nbsp;                Entity entity = getGame().getEntity(entityId);</b>
<b class="nc">&nbsp;                if (entity != null) {</b>
<b class="nc">&nbsp;                    getOwner().getLogger().debug(&quot;recalculating paths for &quot; + entity.getDisplayName());</b>
<b class="nc">&nbsp;                    getPathEnumerator().recalculateMovesFor(entity);</b>
<b class="nc">&nbsp;                    getOwner().getLogger().debug(&quot;finished recalculating paths for &quot; + entity.getDisplayName());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void run() {
<b class="fc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
&nbsp;            // todo There&#39;s probably a better way to handle this than a loop that only exits on an error.
&nbsp;            //noinspection InfiniteLoopStatement
<b class="fc">&nbsp;            while (!getDone().get()) {</b>
<b class="fc">&nbsp;                if (!getEventsToProcess().isEmpty()) {</b>
<b class="nc">&nbsp;                    processGameEvents();</b>
<b class="nc">&nbsp;                    ecmInfo = ComputeECM.computeAllEntitiesECMInfo(</b>
<b class="nc">&nbsp;                            getGame().getEntitiesVector());</b>
<b class="fc">&nbsp;                } else if (!getDirtyUnits().isEmpty()) {</b>
<b class="nc">&nbsp;                    Entity entity = getGame().getEntity(getDirtyUnits().pollFirst());</b>
<b class="nc">&nbsp;                    if ((entity != null) &amp;&amp; isEntityOnMap(entity)) {</b>
<b class="nc">&nbsp;                        unPause();</b>
<b class="nc">&nbsp;                        getOwner().getLogger().debug(&quot;recalculating paths for &quot; + entity.getDisplayName());</b>
<b class="nc">&nbsp;                        getPathEnumerator().recalculateMovesFor(entity);</b>
<b class="nc">&nbsp;                        getOwner().getLogger().debug(&quot;finished recalculating paths for &quot; + entity.getDisplayName());</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (getWaitWhenDone().get()) {</b>
<b class="nc">&nbsp;                    waitForUnpause(); // paused for a reason</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    waitForUnpause(); // idling because there&#39;s nothing to do</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    void signalDone() {
<b class="nc">&nbsp;        getDone().set(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Waits until the thread is not paused, and there&#39;s indication that it has
&nbsp;     * something to do
&nbsp;     */
&nbsp;    private synchronized void waitForUnpause() {
<b class="fc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            while (!getDone().get() &amp;&amp;</b>
<b class="fc">&nbsp;                   (getWaitWhenDone().get() ||</b>
<b class="fc">&nbsp;                    (getEventsToProcess().isEmpty() &amp;&amp;</b>
<b class="fc">&nbsp;                     getDirtyUnits().isEmpty()))) {</b>
<b class="fc">&nbsp;                getOwner().getLogger().debug(&quot;waitWhenDone = &quot; + getWaitWhenDone() +</b>
<b class="fc">&nbsp;                               &quot; :: eventsToProcess = &quot; + getEventsToProcess().size() +</b>
<b class="fc">&nbsp;                               &quot; :: dirtyUnits = &quot; + getDirtyUnits().size());</b>
<b class="fc">&nbsp;                getWaiting().set(true);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    wait();</b>
<b class="nc">&nbsp;                } catch (InterruptedException ignored) {</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                // System.err.println(&quot;checking WAIT conditions&quot;);
&nbsp;            }
<b class="nc">&nbsp;            getWaiting().set(false);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Process game events that have happened since the thread last checked i.e.
&nbsp;     * if a unit has moved, my precaculated paths are no longer valid
&nbsp;     */
&nbsp;    private void processGameEvents() {
<b class="nc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;
&nbsp;        // We don&#39;t want Game to change while this is happening
<b class="nc">&nbsp;        GAME_LOCK.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            LinkedList&lt;GameEvent&gt; eventsToProcessIterator = new LinkedList&lt;&gt;(getEventsToProcess());</b>
<b class="nc">&nbsp;            int numEvents = eventsToProcessIterator.size();</b>
<b class="nc">&nbsp;            for (int count = 0; count &lt; numEvents; count++) {</b>
<b class="nc">&nbsp;                getOwner().getLogger().debug(&quot;Processing event &quot; + (count + 1) + &quot; out of &quot; + numEvents);</b>
<b class="nc">&nbsp;                GameEvent event = eventsToProcessIterator.get(count);</b>
<b class="nc">&nbsp;                if (event == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                getOwner().getLogger().debug(&quot;Processing &quot; + event.toString());</b>
<b class="nc">&nbsp;                getEventsToProcess().remove(event);</b>
<b class="nc">&nbsp;                if (event instanceof GameEntityChangeEvent) {</b>
&nbsp;                    // Ignore entity changes that don&#39;t happen during movement
<b class="nc">&nbsp;                    if (getGame().getPhase() != IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    GameEntityChangeEvent changeEvent = (GameEntityChangeEvent) event;</b>
<b class="nc">&nbsp;                    if (changeEvent.getEntity() == null) {</b>
<b class="nc">&nbsp;                        continue; // just to be safe</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Entity entity = getGame().getEntity(changeEvent.getEntity().getId());</b>
<b class="nc">&nbsp;                    if (entity == null) {</b>
<b class="nc">&nbsp;                        continue; // not sure how this can happen, but just to be</b>
&nbsp;                        // safe
&nbsp;                    }
&nbsp;                    // a lot of odd entity changes are send during the firing phase,
&nbsp;                    // none of which are relevant
<b class="nc">&nbsp;                    if (getGame().getPhase() == IGame.Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Coords position = entity.getPosition();</b>
<b class="nc">&nbsp;                    if (position == null) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (position.equals(getPathEnumerator().getLastKnownCoords(entity.getId()))) {</b>
<b class="nc">&nbsp;                        continue; // no sense in updating a unit if it hasn&#39;t moved</b>
&nbsp;                    }
<b class="nc">&nbsp;                    getOwner().getLogger().debug(&quot;Received entity change event for &quot;</b>
<b class="nc">&nbsp;                                    + changeEvent.getEntity().getDisplayName()</b>
<b class="nc">&nbsp;                                    + &quot; (ID &quot; + entity.getId() + &quot;)&quot;);</b>
<b class="nc">&nbsp;                    Integer entityId = changeEvent.getEntity().getId();</b>
<b class="nc">&nbsp;                    dirtifyUnit(entityId);</b>
&nbsp;
<b class="nc">&nbsp;                } else if (event instanceof GamePhaseChangeEvent) {</b>
<b class="nc">&nbsp;                    GamePhaseChangeEvent phaseChange = (GamePhaseChangeEvent) event;</b>
<b class="nc">&nbsp;                    getOwner().getLogger().debug(&quot;Phase change detected: &quot; + phaseChange.getNewPhase().name());</b>
&nbsp;                    // this marks when I can all I can start recalculating paths.
&nbsp;                    // All units are dirty
<b class="nc">&nbsp;                    if (phaseChange.getNewPhase() == IGame.Phase.PHASE_MOVEMENT) {</b>
<b class="nc">&nbsp;                        getPathEnumerator().clear();</b>
<b class="nc">&nbsp;                        for (Entity entity : getGame().getEntitiesVector()) {</b>
<b class="nc">&nbsp;                            if (entity.isActive() &amp;&amp; entity.isDeployed() &amp;&amp; entity.getPosition() != null) {</b>
<b class="nc">&nbsp;                                getDirtyUnits().add(entity.getId());</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            getOwner().getLogger().debug(&quot;Events still to process: &quot; + getEventsToProcess().size());</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            GAME_LOCK.unlock();</b>
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called when a unit has moved and should be put on the dirty list, as well
&nbsp;     * as any units who&#39;s moves contain that unit
&nbsp;     */
&nbsp;    private void dirtifyUnit(int id) {
<b class="nc">&nbsp;        getOwner().getLogger().methodBegin();</b>
&nbsp;        // Prevent Game from changing while processing
<b class="nc">&nbsp;        GAME_LOCK.lock();</b>
&nbsp;        try {
&nbsp;            // first of all, if a unit has been removed, remove it from the list and
&nbsp;            // stop
<b class="nc">&nbsp;            if (getGame().getEntity(id) == null) {</b>
<b class="nc">&nbsp;                getPathEnumerator().getLastKnownLocations().remove(id);</b>
<b class="nc">&nbsp;                getPathEnumerator().getUnitMovableAreas().remove(id);</b>
<b class="nc">&nbsp;                getPathEnumerator().getUnitPaths().remove(id);</b>
<b class="nc">&nbsp;                getPathEnumerator().getUnitPotentialLocations().remove(id);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // if a unit has moved or deployed, then it becomes dirty, and any units
&nbsp;            // with its initial or final position
&nbsp;            // in their list become dirty
<b class="nc">&nbsp;            if (!getGame().getEntity(id).isAero()) {</b>
<b class="nc">&nbsp;                TreeSet&lt;Integer&gt; toDirty = new TreeSet&lt;&gt;(</b>
<b class="nc">&nbsp;                        getPathEnumerator().getEntitiesWithLocation(</b>
<b class="nc">&nbsp;                                getGame().getEntity(id).getPosition(), true));</b>
<b class="nc">&nbsp;                if (getPathEnumerator().getLastKnownLocations()</b>
<b class="nc">&nbsp;                        .containsKey(id)) {</b>
<b class="nc">&nbsp;                    if ((getGame().getEntity(id) != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; getGame().getEntity(id).isSelectableThisTurn()) {</b>
<b class="nc">&nbsp;                        toDirty.addAll(getPathEnumerator()</b>
<b class="nc">&nbsp;                                .getEntitiesWithLocation(getPathEnumerator()</b>
<b class="nc">&nbsp;                                        .getLastKnownLocations().get(id)</b>
<b class="nc">&nbsp;                                        .getCoords(), true));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // no need to dirty units that aren&#39;t selectable this turn
<b class="nc">&nbsp;                List&lt;Integer&gt; toRemove = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Integer index : toDirty) {</b>
<b class="nc">&nbsp;                    if ((getGame().getEntity(index) == null) || (!getGame()</b>
<b class="nc">&nbsp;                            .getEntity(index).isSelectableThisTurn())</b>
<b class="nc">&nbsp;                            &amp;&amp; (getGame()</b>
<b class="nc">&nbsp;                                    .getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</b>
<b class="nc">&nbsp;                        toRemove.add(index);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (Integer i : toRemove) {</b>
<b class="nc">&nbsp;                    toDirty.remove(i);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (toDirty.size() != 0) {</b>
<b class="nc">&nbsp;                    StringBuilder msg = new StringBuilder(&quot;The following units have become dirty&quot;);</b>
<b class="nc">&nbsp;                    if (getGame().getEntity(id) != null) {</b>
<b class="nc">&nbsp;                        msg.append(&quot; as a result of a nearby move of &quot;)</b>
<b class="nc">&nbsp;                           .append(getGame().getEntity(id).getDisplayName());</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    Iterator&lt;Integer&gt; dirtyIterator = toDirty.descendingIterator();</b>
<b class="nc">&nbsp;                    while (dirtyIterator.hasNext()) {</b>
<b class="nc">&nbsp;                        Integer i = dirtyIterator.next();</b>
<b class="nc">&nbsp;                        Entity e = getGame().getEntity(i);</b>
<b class="nc">&nbsp;                        if (e != null) {</b>
<b class="nc">&nbsp;                            msg.append(&quot;\n  &quot;).append(e.getDisplayName());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    getOwner().getLogger().debug(msg.toString());</b>
&nbsp;                }
<b class="nc">&nbsp;                getDirtyUnits().addAll(toDirty);</b>
&nbsp;            }
<b class="nc">&nbsp;            Entity entity = getGame().getEntity(id);</b>
<b class="nc">&nbsp;            if ((entity != null) &amp;&amp; (entity.isSelectableThisTurn()) ||</b>
<b class="nc">&nbsp;                (getGame().getPhase() != IGame.Phase.PHASE_MOVEMENT)) {</b>
<b class="nc">&nbsp;                getDirtyUnits().add(id);</b>
<b class="nc">&nbsp;            } else if (entity != null) {</b>
<b class="nc">&nbsp;                getPathEnumerator().getLastKnownLocations().put(id,</b>
<b class="nc">&nbsp;                        CoordFacingCombo.createCoordFacingCombo(entity));</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            GAME_LOCK.unlock();</b>
<b class="nc">&nbsp;            getOwner().getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    PathEnumerator getPathEnumerator() {
<b class="nc">&nbsp;        PATH_ENUMERATOR_LOCK.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK read locked.&quot;);</b>
<b class="nc">&nbsp;            return pathEnumerator;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            PATH_ENUMERATOR_LOCK.readLock().unlock();</b>
<b class="nc">&nbsp;            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK read unlocked.&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setPathEnumerator(PathEnumerator pathEnumerator) {
<b class="fc">&nbsp;        PATH_ENUMERATOR_LOCK.writeLock().lock();</b>
&nbsp;        try {
<b class="fc">&nbsp;            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK write locked.&quot;);</b>
<b class="fc">&nbsp;            this.pathEnumerator = pathEnumerator;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK write unlocked.&quot;);</b>
<b class="fc">&nbsp;            PATH_ENUMERATOR_LOCK.writeLock().unlock();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public List&lt;ECMInfo&gt; getECMInfo() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(ecmInfo);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ConcurrentSkipListSet&lt;Integer&gt; getDirtyUnits() {
<b class="fc">&nbsp;        return dirtyUnits;</b>
&nbsp;    }
&nbsp;
&nbsp;    private ConcurrentLinkedQueue&lt;GameEvent&gt; getEventsToProcess() {
<b class="fc">&nbsp;        return eventsToProcess;</b>
&nbsp;    }
&nbsp;
&nbsp;    private AtomicBoolean getWaitWhenDone() {
<b class="fc">&nbsp;        return waitWhenDone;</b>
&nbsp;    }
&nbsp;
&nbsp;    private AtomicBoolean getWaiting() {
<b class="fc">&nbsp;        return waiting;</b>
&nbsp;    }
&nbsp;
&nbsp;    private AtomicBoolean getDone() {
<b class="fc">&nbsp;        return done;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Princess getOwner() {
<b class="fc">&nbsp;        return owner;</b>
&nbsp;    }
&nbsp;
&nbsp;    void resetGame() {
<b class="nc">&nbsp;        GAME_LOCK.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            getOwner().getLogger().debug(&quot;GAME_LOCK write locked.&quot;);</b>
<b class="nc">&nbsp;            game.reset();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            GAME_LOCK.unlock();</b>
<b class="nc">&nbsp;            getOwner().getLogger().debug(&quot;GAME_LOCK write unlocked.&quot;);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private IGame getGame() {
<b class="fc">&nbsp;        GAME_LOCK.lock();</b>
&nbsp;        try {
<b class="fc">&nbsp;            getOwner().getLogger().debug(&quot;GAME_LOCK read locked.&quot;);</b>
<b class="fc">&nbsp;            return game;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            GAME_LOCK.unlock();</b>
<b class="fc">&nbsp;            getOwner().getLogger().debug(&quot;GAME_LOCK read unlocked.&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;   
&nbsp;    /**
&nbsp;     * Returns the individual player assigned the index parameter.
&nbsp;     */
&nbsp;    protected IPlayer getPlayer(int idx) {
<b class="nc">&nbsp;        return getGame().getPlayer(idx);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Receives player information from the message packet.
&nbsp;     */
&nbsp;    private void receivePlayerInfo(Packet c) {
<b class="nc">&nbsp;        int pindex = c.getIntValue(0);</b>
<b class="nc">&nbsp;        IPlayer newPlayer = (IPlayer) c.getObject(1);</b>
<b class="nc">&nbsp;        if (getPlayer(newPlayer.getId()) == null) {</b>
<b class="nc">&nbsp;            getGame().addPlayer(pindex, newPlayer);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            getGame().setPlayer(pindex, newPlayer);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the turn list from the data in the packet
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveTurns(Packet packet) {
<b class="nc">&nbsp;        getGame().setTurnVector((List&lt;GameTurn&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the board from the data in the net command.
&nbsp;     */
&nbsp;    private void receiveBoard(Packet c) {
<b class="nc">&nbsp;        Board newBoard = (Board) c.getObject(0);</b>
<b class="nc">&nbsp;        getGame().setBoard(newBoard);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the entities from the data in the net command.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveEntities(Packet c) {
<b class="nc">&nbsp;        List&lt;Entity&gt; newEntities = (List&lt;Entity&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; newOutOfGame = (List&lt;Entity&gt;) c.getObject(1);</b>
&nbsp;
&nbsp;        // Replace the entities in the game.
<b class="nc">&nbsp;        getGame().setEntitiesVector(newEntities);</b>
<b class="nc">&nbsp;        if (newOutOfGame != null) {</b>
<b class="nc">&nbsp;            getGame().setOutOfGameEntitiesVector(newOutOfGame);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads entity update data from the data in the net command.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveEntityUpdate(Packet c) {
<b class="nc">&nbsp;        int eindex = c.getIntValue(0);</b>
<b class="nc">&nbsp;        Entity entity = (Entity) c.getObject(1);</b>
<b class="nc">&nbsp;        Vector&lt;UnitLocation&gt; movePath = (Vector&lt;UnitLocation&gt;) c.getObject(2);</b>
&nbsp;        // Replace this entity in the game.
<b class="nc">&nbsp;        getGame().setEntity(eindex, entity, movePath);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void receiveEntityAdd(Packet packet) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Integer&gt; entityIds = (List&lt;Integer&gt;) packet.getObject(0);</b>
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Entity&gt; entities = (List&lt;Entity&gt;) packet.getObject(1);</b>
&nbsp;
<b class="nc">&nbsp;        assert (entityIds.size() == entities.size());</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entityIds.size(); i++) {</b>
<b class="nc">&nbsp;            assert (entityIds.get(i) == entities.get(i).getId());</b>
&nbsp;        }
<b class="nc">&nbsp;        getGame().addEntities(entities);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void receiveEntityRemove(Packet packet) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Integer&gt; entityIds = (List&lt;Integer&gt;) packet.getObject(0);</b>
<b class="nc">&nbsp;        int condition = packet.getIntValue(1);</b>
&nbsp;        // Move the unit to its final resting place.
<b class="nc">&nbsp;        getGame().removeEntities(entityIds, condition);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveEntityVisibilityIndicator(Packet packet) {
<b class="nc">&nbsp;        Entity e = getGame().getEntity(packet.getIntValue(0));</b>
<b class="nc">&nbsp;        if (e != null) { // we may not have this entity due to double blind</b>
<b class="nc">&nbsp;            e.setEverSeenByEnemy(packet.getBooleanValue(1));</b>
<b class="nc">&nbsp;            e.setVisibleToEnemy(packet.getBooleanValue(2));</b>
<b class="nc">&nbsp;            e.setDetectedByEnemy(packet.getBooleanValue(3));</b>
<b class="nc">&nbsp;            e.setWhoCanSee((Vector&lt;IPlayer&gt;)packet.getObject(4));</b>
<b class="nc">&nbsp;            e.setWhoCanDetect((Vector&lt;IPlayer&gt;)packet.getObject(5));</b>
&nbsp;            // this next call is only needed sometimes, but we&#39;ll just
&nbsp;            // call it everytime
<b class="nc">&nbsp;            getGame().processGameEvent(new GameEntityChangeEvent(this, e));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveDeployMinefields(Packet packet) {
<b class="nc">&nbsp;        getGame().addMinefields((Vector&lt;Minefield&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveSendingMinefields(Packet packet) {
<b class="nc">&nbsp;        getGame().setMinefields((Vector&lt;Minefield&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveIlluminatedHexes(Packet p) {
<b class="nc">&nbsp;        getGame().setIlluminatedPositions((HashSet&lt;Coords&gt;) p.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void receiveRevealMinefield(Packet packet) {
<b class="nc">&nbsp;        getGame().addMinefield((Minefield) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void receiveRemoveMinefield(Packet packet) {
<b class="nc">&nbsp;        getGame().removeMinefield((Minefield) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveUpdateMinefields(Packet packet) {
&nbsp;        // only update information if you know about the minefield
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; newMines = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Minefield mf : (Vector&lt;Minefield&gt;) packet.getObject(0)) {</b>
<b class="nc">&nbsp;            if (getOwner().getLocalPlayer().containsMinefield(mf)) {</b>
<b class="nc">&nbsp;                newMines.add(mf);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (newMines.size() &gt; 0) {</b>
<b class="nc">&nbsp;            getGame().resetMinefieldDensity(newMines);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveBuildingUpdate(Packet packet) {
<b class="nc">&nbsp;        getGame().getBoard().updateBuildings((Vector&lt;Building&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveBuildingCollapse(Packet packet) {
<b class="nc">&nbsp;        getGame().getBoard().collapseBuilding((Vector&lt;Coords&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads entity firing data from the data in the net command
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void receiveAttack(Packet c) {
<b class="nc">&nbsp;        List&lt;EntityAction&gt; vector = (List&lt;EntityAction&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;        int charge = c.getIntValue(1);</b>
<b class="nc">&nbsp;        boolean addAction = true;</b>
<b class="nc">&nbsp;        for (EntityAction ea : vector) {</b>
<b class="nc">&nbsp;            int entityId = ea.getEntityId();</b>
<b class="nc">&nbsp;            if ((ea instanceof TorsoTwistAction) &amp;&amp; getGame().hasEntity(entityId)) {</b>
<b class="nc">&nbsp;                TorsoTwistAction tta = (TorsoTwistAction) ea;</b>
<b class="nc">&nbsp;                Entity entity = getGame().getEntity(entityId);</b>
<b class="nc">&nbsp;                entity.setSecondaryFacing(tta.getFacing());</b>
<b class="nc">&nbsp;            } else if ((ea instanceof FlipArmsAction)</b>
<b class="nc">&nbsp;                    &amp;&amp; getGame().hasEntity(entityId)) {</b>
<b class="nc">&nbsp;                FlipArmsAction faa = (FlipArmsAction) ea;</b>
<b class="nc">&nbsp;                Entity entity = getGame().getEntity(entityId);</b>
<b class="nc">&nbsp;                entity.setArmsFlipped(faa.getIsFlipped());</b>
<b class="nc">&nbsp;            } else if ((ea instanceof DodgeAction) &amp;&amp; getGame().hasEntity(entityId)) {</b>
<b class="nc">&nbsp;                Entity entity = getGame().getEntity(entityId);</b>
<b class="nc">&nbsp;                entity.dodging = true;</b>
<b class="nc">&nbsp;                addAction = false;</b>
<b class="nc">&nbsp;            } else if (ea instanceof AttackAction) {</b>
&nbsp;                // The equipment type of a club needs to be restored.
<b class="nc">&nbsp;                if (ea instanceof ClubAttackAction) {</b>
<b class="nc">&nbsp;                    ClubAttackAction caa = (ClubAttackAction) ea;</b>
<b class="nc">&nbsp;                    Mounted club = caa.getClub();</b>
<b class="nc">&nbsp;                    club.restore();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (addAction) {</b>
&nbsp;                // track in the appropriate list
<b class="nc">&nbsp;                if (charge == 0) {</b>
<b class="nc">&nbsp;                    getGame().addAction(ea);</b>
<b class="nc">&nbsp;                } else if ((charge == 1) &amp;&amp; (ea instanceof AttackAction)) {</b>
<b class="nc">&nbsp;                    getGame().addCharge((AttackAction) ea);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * receive and process an entity nova network mode change packet
&nbsp;     *
&nbsp;     * @param c The packet containing the change.
&nbsp;     */
&nbsp;    private void receiveEntityNovaNetworkModeChange(Packet c) {
&nbsp;        try {
<b class="nc">&nbsp;            int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;            String networkID = c.getObject(1).toString();</b>
<b class="nc">&nbsp;            Entity e = getGame().getEntity(entityId);</b>
<b class="nc">&nbsp;            if (e != null) {</b>
<b class="nc">&nbsp;                e.setNewRoundNovaNetworkString(networkID);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            getOwner().getLogger().error(ex);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
