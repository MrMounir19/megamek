


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Princess</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.bot.princess</a>
</div>

<h1>Coverage Summary for Class: Princess (megamek.client.bot.princess)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Princess</td>
<td class="coverageStat">
  <span class="percent">
    20.9%
  </span>
  <span class="absValue">
    (19/91)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.1%
  </span>
  <span class="absValue">
    (199/945)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Princess$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$0aaDVBAq</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$0JS8Hw89</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$0w4AvRkf</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$1hxHNRpL</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$1M4QBnPm</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$32WSnK1K</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$3dZe0kg5</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$4vyqDL8U</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$5oyQx4RN</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$5raUnmS5</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$5TvlSrh3</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$5viLFCxT</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$6FAzEZh2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$6FSc2Vo5</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$6MWOmYHd</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$752KxOU4</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$7RezrY50</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$8p0fXYnK</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$9A9zxdg2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$9bFhE2tL</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$9hGpVUIL</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$9jJGlAdk</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$9zFVMIEp</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$aaVajBPO</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$aelXzInX</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$aFAe17di</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ArmqsdKD</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$B9ztdqFK</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$BlQPENrF</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$BnzvYhyB</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$BQbV4PZA</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$C1fYIowH</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$c1mQG7Tj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$C6opSHDw</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$cJDkLqGy</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ClbSWWzu</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$cnGPCIwp</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$cpp1mlUw</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$CqNWubSO</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$D70Fn64m</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$D9To2smt</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$DH3JAxDS</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Dj5ut9dS</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$dK34FQmt</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$DKpHbTdO</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$dOzKecSH</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$dVHeEUJz</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$dYpQujTC</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$e191H0m2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Ed3336Ps</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$eQTpmZwC</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$EV7UfCuf</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$EVqtk3zj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$F6Oet7nQ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$FDv7pd5K</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$fGisfU47</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$FLb6yvx8</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$FLdmHZ8H</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$fPdqznZj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$fs0QxwUW</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$GdhKN0Cv</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$GkVm1Ela</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$gLo7F0eH</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$GQ8RofT4</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$gSEO7g9l</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$gsoMotz4</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$H6k9wreQ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$hKvXeur6</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$hOzfJjbS</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$hpC91ovX</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$hPwmYCpp</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$hvKDxbit</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$hW0qACpK</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$inclzmyv</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$IyU3TyYS</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$J5cQuoN7</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$J8S0sh4I</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$JaVPrlbt</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$JbwcHwfU</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$je0DCZCi</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$JE3tjvVk</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$JwlL5Ts1</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$kBFB5EeL</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$kbNAStWg</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$kgB4LbNh</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$khXDgk3j</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Ki7KK7Gu</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$KTB8PfQ2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Ku1zL7eC</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$KZ5znDDC</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$l0GIiXqS</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$lk1BxE9l</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$lq4oCaGW</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$lTpnYaRo</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$luoMP9Fs</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$LYlJGiHJ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$mH5QmNB3</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$mJ8wDtyH</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$MjkbTMV2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$MKo4HMmT</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Mv9aIcUb</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$MwWFC31a</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$N1n6NEuj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$N4Bt3rOF</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$NAiarNsC</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$nd4a2JOd</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ndmAZoNa</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$NPLKbEBK</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$NuterArU</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$nY7wKMzc</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$o026UweP</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$O8ebLDfj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$oaJ7nap9</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$odHxxe8u</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ODuwhDvI</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$oIKidzM2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$oq1H6c62</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$p7Dso3Z2</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$pAHOIOgd</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$PdMAU93V</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$pEBpYM5Q</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$PHaCSHBI</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$q0o2cTUz</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Q7zZU6hW</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$qhi8LhZk</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$QHJRq9Hu</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$QhOrbQSl</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$QJKjVGmh</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$QsrfGnCb</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$R6YCThaA</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$rCYHSMRq</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$RPhAiTwp</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$RZ92H0B7</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$S92OWsdG</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$SmA25JRj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$sN6MdmCa</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$tPKPDyLP</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$TrPwvSsV</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$TtlsL0XW</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$tTxPGA4E</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$txB8bwQT</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$tYuNjLCl</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ufaNUjQz</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$UoaDsKld</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$uU0B45Ut</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$uUbh255Q</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$uVFEqwlI</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$UZ1tTacR</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$v6hMacFi</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$VaJDyn4W</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$vd2tIi78</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$VgdqA8rw</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$VIW1G9LJ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$VmsbLLZo</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$VRhVMTn0</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$vwsJjyYZ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$vXvknmc7</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$W9BtgNBs</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$WFRcSFFN</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$wiALAK0C</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$wjZYwj4u</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$wlROCdIM</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$wOo2xijQ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$wv6Zq1EE</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$WZKF42U7</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$x0gjC3uW</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$X2giSfwv</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$x86p77Ix</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$xa5I8ILO</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$xCkxaIFQ</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$XHdLN6Vf</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$xivu0Z79</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$xJSPdE7W</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$XpSiilGj</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$XZDRb4z1</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$Y7TdLmR4</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$yatGzhZg</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$YfvcXgP1</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$YoDDk6WB</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$YOSm026S</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$YRdLH67a</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$yW7Bcqly</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$zCh3gWzs</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$zcWRLWTO</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ZLWsdTh8</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ZoZvTrs9</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ZSKySok6</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$ZZczc9O4</td>
  </tr>
  <tr>
    <td class="name">Princess$MockitoMock$1295369243$auxiliary$zZGgo2Vo</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    20.7%
  </span>
  <span class="absValue">
    (19/92)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21%
  </span>
  <span class="absValue">
    (199/946)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000-2011 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.client.bot.princess;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.text.NumberFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;
&nbsp;import megamek.client.bot.BotClient;
&nbsp;import megamek.client.bot.ChatProcessor;
&nbsp;import megamek.client.bot.PhysicalCalculator;
&nbsp;import megamek.client.bot.PhysicalOption;
&nbsp;import megamek.client.bot.princess.FireControl.FireControlType;
&nbsp;import megamek.client.bot.princess.PathRanker.PathRankerType;
&nbsp;import megamek.client.bot.princess.UnitBehavior.BehaviorType;
&nbsp;import megamek.client.ui.SharedUtility;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.BuildingTarget;
&nbsp;import megamek.common.BulldozerMovePath;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.EjectedCrew;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.HexTarget;
&nbsp;import megamek.common.IAero;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.LosEffects;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MechWarrior;
&nbsp;import megamek.common.Minefield;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.MovePath;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.SearchlightAttackAction;
&nbsp;import megamek.common.MoveStep;
&nbsp;import megamek.common.PilotingRollData;
&nbsp;import megamek.common.PlanetaryConditions;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.Transporter;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.containers.PlayerIDandList;
&nbsp;import megamek.common.event.GameCFREvent;
&nbsp;import megamek.common.event.GamePlayerChatEvent;
&nbsp;import megamek.common.logging.LogLevel;
&nbsp;import megamek.common.logging.DefaultMmLogger;
&nbsp;import megamek.common.logging.MMLogger;
&nbsp;import megamek.common.net.Packet;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.BoardClusterTracker;
&nbsp;import megamek.common.pathfinder.PathDecorator;
&nbsp;import megamek.common.util.BoardUtilities;
&nbsp;import megamek.common.util.StringUtil;
&nbsp;import megamek.common.weapons.AmmoWeapon;
&nbsp;
&nbsp;public class Princess extends BotClient {
&nbsp;
&nbsp;    private static final String LOGGING_CATEGORY = &quot;megamek.client.bot.princess&quot;;
&nbsp;
&nbsp;    private static final char PLUS = &#39;+&#39;;
&nbsp;    private static final char MINUS = &#39;-&#39;;
&nbsp;
<b class="fc">&nbsp;    private final IHonorUtil honorUtil = new HonorUtil();</b>
&nbsp;
<b class="fc">&nbsp;    private boolean initialized = false;</b>
&nbsp;   
&nbsp;    // path rankers and fire controls, organized by their explicitly given types to avoid confusion
&nbsp;    private HashMap&lt;PathRankerType, IPathRanker&gt; pathRankers;
&nbsp;    private HashMap&lt;FireControlType, FireControl&gt; fireControls;
&nbsp;    private UnitBehavior unitBehaviorTracker;
&nbsp;    private FireControlState fireControlState;
&nbsp;    private PathRankerState pathRankerState;
&nbsp;    private ArtilleryTargetingControl atc;
&nbsp;    
<b class="fc">&nbsp;    private Integer spinupThreshold = null;</b>
&nbsp;    
&nbsp;    private BehaviorSettings behaviorSettings;
<b class="fc">&nbsp;    private double moveEvaluationTimeEstimate = 0;</b>
&nbsp;    private final Precognition precognition;
&nbsp;    private final Thread precogThread;
&nbsp;    /**
&nbsp;     * Mapping to hold the damage allocated to each targetable, stored by ID.
&nbsp;     * Used to allocate damage more intelligently and avoid overkill.
&nbsp;     */
<b class="fc">&nbsp;    private final ConcurrentHashMap&lt;Integer, Double&gt; damageMap = new ConcurrentHashMap&lt;&gt;(); </b>
<b class="fc">&nbsp;    private final Set&lt;Coords&gt; strategicBuildingTargets = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    private boolean fallBack = false;</b>
<b class="fc">&nbsp;    private final ChatProcessor chatProcessor = new ChatProcessor();</b>
<b class="fc">&nbsp;    private boolean fleeBoard = false;</b>
<b class="fc">&nbsp;    private final IMoralUtil moralUtil = new MoralUtil(getLogger());</b>
<b class="fc">&nbsp;    private final Set&lt;Integer&gt; attackedWhileFleeing = Collections.newSetFromMap(new ConcurrentHashMap&lt;Integer, Boolean&gt;());</b>
<b class="fc">&nbsp;    private final Set&lt;Integer&gt; crippledUnits = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    private MMLogger logger = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor - initializes a new instance of the Princess bot.
&nbsp;     * @param name The display name.
&nbsp;     * @param host The host address to which to connect.
&nbsp;     * @param port The port on the host where to connect.
&nbsp;     * @param verbosity The verbosity of the bot&#39;s reporting and logging.
&nbsp;     */
&nbsp;    public Princess(final String name,
&nbsp;                    final String host,
&nbsp;                    final int port,
&nbsp;                    final LogLevel verbosity) {
<b class="fc">&nbsp;        super(name, host, port);</b>
<b class="fc">&nbsp;        getLogger().setLogLevel(LOGGING_CATEGORY, verbosity);</b>
<b class="fc">&nbsp;        setBehaviorSettings(BehaviorSettingsFactory.getInstance(getLogger())</b>
&nbsp;                                    .DEFAULT_BEHAVIOR);
&nbsp;        
<b class="fc">&nbsp;        fireControlState = new FireControlState();</b>
<b class="fc">&nbsp;        pathRankerState = new PathRankerState();</b>
&nbsp;        
&nbsp;        // Start-up precog now, so that it can instantiate its game instance,
&nbsp;        // and it will stay up-to date.
<b class="fc">&nbsp;        precognition = new Precognition(this);</b>
<b class="fc">&nbsp;        precogThread = new Thread(precognition, &quot;Princess-precognition (&quot;</b>
<b class="fc">&nbsp;                + getName() + &quot;)&quot;);</b>
<b class="fc">&nbsp;        precogThread.start();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MMLogger getLogger() {
<b class="fc">&nbsp;        if (null == logger) {</b>
<b class="fc">&nbsp;            logger = DefaultMmLogger.getInstance();</b>
&nbsp;        }
<b class="fc">&nbsp;        return logger;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use to set a fake logger during unit testing.
&nbsp;     *
&nbsp;     * @param logger The logger to be used.
&nbsp;     */
&nbsp;    void setLogger(final MMLogger logger) {
<b class="nc">&nbsp;        if (null == logger) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        this.logger = logger;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setVerbosity(final LogLevel level) {
<b class="fc">&nbsp;        getBehaviorSettings().setVerbosity(level);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public LogLevel getVerbosity() {
<b class="fc">&nbsp;        return getBehaviorSettings().getVerbosity();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Lazy-loading accessor for the artillery targeting control.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public ArtilleryTargetingControl getArtilleryTargetingControl() {
<b class="nc">&nbsp;        if(atc == null) {</b>
<b class="nc">&nbsp;            atc = new ArtilleryTargetingControl();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return atc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the appropriate path ranker instance given an entity
&nbsp;     * Uses the entity&#39;s EType flags to figure out which one to return
&nbsp;     * Returns BasicPathRanker by default.
&nbsp;     * @param entity The entity whose ETYPE to check
&nbsp;     * @return Path ranker instance
&nbsp;     */
&nbsp;    IPathRanker getPathRanker(Entity entity) {
<b class="nc">&nbsp;        if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {</b>
<b class="nc">&nbsp;            return pathRankers.get(PathRankerType.Infantry);</b>
<b class="nc">&nbsp;        } else if (entity.isAero() &amp;&amp; game.useVectorMove()) {</b>
<b class="nc">&nbsp;            return pathRankers.get(PathRankerType.NewtonianAerospace);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return pathRankers.get(PathRankerType.Basic);</b>
&nbsp;    }
&nbsp;    
&nbsp;    IPathRanker getPathRanker(PathRankerType pathRankerType) {
<b class="nc">&nbsp;        return pathRankers.get(pathRankerType);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean getFallBack() {
<b class="fc">&nbsp;        return fallBack;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean getFleeBoard() {
<b class="nc">&nbsp;        return fleeBoard;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Picks a tag target based on the data contained within the given GameCFREvent
&nbsp;     * Expects the event to have some tag targets and tag target types.
&nbsp;     */
&nbsp;    protected int pickTagTarget(GameCFREvent evt) {
<b class="nc">&nbsp;        List&lt;Integer&gt; TAGTargets = evt.getTAGTargets();</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; TAGTargetTypes = evt.getTAGTargetTypes();</b>
<b class="nc">&nbsp;        Map&lt;Coords, Integer&gt; tagTargetHexes = new HashMap&lt;&gt;(); // maps coordinates to target index</b>
&nbsp;        
&nbsp;        // Algorithm:
&nbsp;        // get a list of the hexes being tagged
&nbsp;        // figure out how much damage a hit to each of the tagged hexes will do (relatively)
&nbsp;        // pick the one which will result in the best damage
&nbsp;        
&nbsp;        // get list of targetable hexes
<b class="nc">&nbsp;        for (int tagIndex = 0; tagIndex &lt; TAGTargets.size(); tagIndex++) {</b>
<b class="nc">&nbsp;            int nType = TAGTargetTypes.get(tagIndex);</b>
<b class="nc">&nbsp;            Targetable tgt = getGame().getTarget(nType, TAGTargets.get(tagIndex));</b>
<b class="nc">&nbsp;            if (tgt != null &amp;&amp; !tagTargetHexes.containsKey(tgt.getPosition())) {</b>
<b class="nc">&nbsp;                tagTargetHexes.put(tgt.getPosition(), tagIndex);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity arbitraryEntity = getArbitraryEntity();</b>
<b class="nc">&nbsp;        if(arbitraryEntity == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        double maxDamage = -Double.MAX_VALUE;</b>
<b class="nc">&nbsp;        Coords maxDamageHex = null;</b>
&nbsp;        
&nbsp;        // invoke ArtilleryTargetingControl.calculateDamageValue
<b class="nc">&nbsp;        for(Coords targetHex : tagTargetHexes.keySet()) {</b>
&nbsp;            // a note on parameters:
&nbsp;            // we don&#39;t care about exact damage value since we&#39;re just comparing them relative to one another
&nbsp;            //  note: technically we should, 
&nbsp;            // we don&#39;t care about specific firing entity, we just want one on our side
&nbsp;            //      since we only use it to determine friendlyness 
<b class="nc">&nbsp;            double currentDamage = getArtilleryTargetingControl().calculateDamageValue(10, targetHex, arbitraryEntity, game, this);</b>
<b class="nc">&nbsp;            if(currentDamage &gt; maxDamage) {</b>
<b class="nc">&nbsp;                maxDamage = currentDamage;</b>
<b class="nc">&nbsp;                maxDamageHex = targetHex;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        if(maxDamageHex != null) {</b>
<b class="nc">&nbsp;            return tagTargetHexes.get(maxDamageHex);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    boolean getForcedWithdrawal() {
<b class="nc">&nbsp;        return getBehaviorSettings().isForcedWithdrawal();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setFleeBoard(final boolean fleeBoard, final String reason) {
<b class="fc">&nbsp;        getLogger().debug(&quot;Setting Flee Board &quot; + fleeBoard + &quot; because: &quot; + reason);</b>
&nbsp;
<b class="fc">&nbsp;        this.fleeBoard = fleeBoard;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public FireControlState getFireControlState() {
<b class="nc">&nbsp;        return fireControlState;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public PathRankerState getPathRankerState() {
<b class="nc">&nbsp;        return pathRankerState;</b>
&nbsp;    }
&nbsp;    
&nbsp;    Precognition getPrecognition() {
<b class="nc">&nbsp;        return precognition;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getMaxWeaponRange(Entity entity) {
<b class="nc">&nbsp;        return getMaxWeaponRange(entity, false);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Retrieves maximum weapon range for the given entity.
&nbsp;     * Cached version of entity.getMaxWeaponRange() 
&nbsp;     * @param entity Entity we&#39;re checking
&nbsp;     * @param airborneTarget Whether the potential target is in the air, only relevant for
&nbsp;     *          aircraft shooting at other aircraft on ground maps.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getMaxWeaponRange(Entity entity, boolean airborneTarget) {
<b class="nc">&nbsp;        return getFireControlState().getWeaponRanges(airborneTarget).</b>
<b class="nc">&nbsp;            computeIfAbsent(entity.getId(), ent -&gt; entity.getMaxWeaponRange(airborneTarget));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setFallBack(final boolean fallBack,
&nbsp;                            final String reason) {
<b class="fc">&nbsp;        getLogger().debug(&quot;Setting Fall Back &quot; + fallBack + &quot; because: &quot; + reason);</b>
<b class="fc">&nbsp;        this.fallBack = fallBack;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setBehaviorSettings(final BehaviorSettings behaviorSettings) {
<b class="fc">&nbsp;        getLogger().info(&quot;New behavior settings for &quot; + getName() +</b>
<b class="fc">&nbsp;            &quot;\n&quot; + behaviorSettings.toLog());</b>
&nbsp;        try {
<b class="fc">&nbsp;            this.behaviorSettings = behaviorSettings.getCopy();</b>
<b class="nc">&nbsp;        } catch (final PrincessException e) {</b>
<b class="nc">&nbsp;            getLogger().error(e);</b>
<b class="nc">&nbsp;            return;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        getStrategicBuildingTargets().clear();</b>
<b class="fc">&nbsp;        setFallBack(behaviorSettings.shouldGoHome(),</b>
&nbsp;                    &quot;Fall Back Configuration.&quot;);
<b class="fc">&nbsp;        setFleeBoard(behaviorSettings.shouldAutoFlee(),</b>
&nbsp;                     &quot;Flee Board Configuration.&quot;);
<b class="fc">&nbsp;        if (getFallBack()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (final String targetCoords : behaviorSettings.getStrategicBuildingTargets()) {</b>
<b class="nc">&nbsp;            if (!StringUtil.isPositiveInteger(targetCoords) ||</b>
<b class="nc">&nbsp;                (4 != targetCoords.length())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final String x = targetCoords.substring(0, 2);</b>
<b class="nc">&nbsp;            final String y = targetCoords.replaceFirst(x, &quot;&quot;);</b>
&nbsp;            // Need to subtract 1, since we are given a Hex number string, 
&nbsp;            // which is Coords X+1Y+1 
<b class="nc">&nbsp;            final Coords coords = new Coords(Integer.parseInt(x) - 1,</b>
<b class="nc">&nbsp;                                       Integer.parseInt(y) - 1);</b>
<b class="nc">&nbsp;            getStrategicBuildingTargets().add(coords);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="fc">&nbsp;        spinupThreshold = null;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the appropriate instance of a FireControl object for the given entity.
&nbsp;     * @param entity The entity in question.
&nbsp;     * @return Instance of FireControl
&nbsp;     */
&nbsp;    FireControl getFireControl(Entity entity) {
<b class="nc">&nbsp;        if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {</b>
<b class="nc">&nbsp;            return fireControls.get(FireControlType.Infantry);</b>
&nbsp;        // some entities can shoot at multiple targets without undergoing too much penalty
&nbsp;        // so let&#39;s get them doing that.
<b class="nc">&nbsp;        } else if(entity.getCrew().getCrewType().getMaxPrimaryTargets() &gt; 1 ||</b>
<b class="nc">&nbsp;                entity.hasQuirk(OptionsConstants.QUIRK_POS_MULTI_TRAC) ||</b>
<b class="nc">&nbsp;                entity.hasAbility(OptionsConstants.GUNNERY_MULTI_TASKER) ||</b>
<b class="nc">&nbsp;                entity.getCrew().getCrewType().getMaxPrimaryTargets() &lt; 0) {</b>
<b class="nc">&nbsp;            return fireControls.get(FireControlType.MultiTarget);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return fireControls.get(FireControlType.Basic);</b>
&nbsp;    }
&nbsp;    
&nbsp;    FireControl getFireControl(FireControlType fireControlType) {
<b class="nc">&nbsp;        return fireControls.get(fireControlType);        </b>
&nbsp;    }
&nbsp;    
&nbsp;    public UnitBehavior getUnitBehaviorTracker() {
<b class="nc">&nbsp;        return unitBehaviorTracker;</b>
&nbsp;    }
&nbsp;
&nbsp;    double getDamageAlreadyAssigned(final Targetable target) {
<b class="nc">&nbsp;        final Integer targetId = target.getTargetId();</b>
<b class="nc">&nbsp;        if(damageMap.containsKey(targetId)) {</b>
<b class="nc">&nbsp;            return damageMap.get(targetId);</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0.0; // If we have no entry, return zero</b>
&nbsp;    }
&nbsp;
&nbsp;    public BehaviorSettings getBehaviorSettings() {
<b class="fc">&nbsp;        return behaviorSettings;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;Coords&gt; getStrategicBuildingTargets() {
<b class="fc">&nbsp;        return strategicBuildingTargets;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addStrategicBuildingTarget(final Coords coords) {
<b class="fc">&nbsp;        if (null == coords) {</b>
<b class="nc">&nbsp;            throw new NullPointerException(&quot;Coords is null.&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!getGame().getBoard().contains(coords)) {</b>
<b class="nc">&nbsp;            getLogger().warning(&quot;Board does not contain &quot; + coords.toFriendlyString());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="fc">&nbsp;        getStrategicBuildingTargets().add(coords);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Set&lt;Integer&gt; getPriorityUnitTargets() {
<b class="nc">&nbsp;        return getBehaviorSettings().getPriorityUnitTargets();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Targetable getAppropriateTarget(Coords strategicTarget) {
<b class="nc">&nbsp;        if (null == game.getBoard().getBuildingAt(strategicTarget)) {</b>
<b class="nc">&nbsp;            return new HexTarget(strategicTarget, Targetable.TYPE_HEX_CLEAR);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new BuildingTarget(strategicTarget, game.getBoard(), false);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected Vector&lt;Coords&gt; calculateArtyAutoHitHexes() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
&nbsp;            // currently returns no artillery hit spots
&nbsp;            // make an empty list
<b class="nc">&nbsp;            final PlayerIDandList&lt;Coords&gt; artyAutoHitHexes = new PlayerIDandList&lt;&gt;();</b>
&nbsp;            // attach my player id to it
<b class="nc">&nbsp;            artyAutoHitHexes.setPlayerID(getLocalPlayer().getId());</b>
<b class="nc">&nbsp;            return artyAutoHitHexes;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    protected void initTargeting() {
<b class="nc">&nbsp;        getArtilleryTargetingControl().initializeForTargetingPhase();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected void calculateDeployment() {
&nbsp;        // get the first unit
<b class="nc">&nbsp;        final int entityNum = game.getFirstDeployableEntityNum(game.getTurnForPlayer(localPlayerNumber));</b>
<b class="nc">&nbsp;        if (getLogger().getLogLevel(LOGGING_CATEGORY).toInt() &gt; LogLevel.WARNING.toInt()) {</b>
<b class="nc">&nbsp;            sendChat(&quot;deploying unit &quot; + getEntity(entityNum).getChassis(), LogLevel.INFO);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we are using forced withdrawal, and the entity being considered is crippled
&nbsp;        // we will opt to not re-deploy the entity
<b class="nc">&nbsp;        if (getForcedWithdrawal() &amp;&amp; getEntity(entityNum).isCrippled()) {</b>
<b class="nc">&nbsp;            getLogger().info(&quot;Declining to deploy crippled unit: &quot;</b>
<b class="nc">&nbsp;                    + getEntity(entityNum).getChassis() + &quot;. Removing unit.&quot;);</b>
<b class="nc">&nbsp;            sendDeleteEntity(entityNum);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // get a list of all coordinates to which we can deploy
<b class="nc">&nbsp;        final List&lt;Coords&gt; startingCoords = getStartingCoordsArray(game.getEntity(entityNum));</b>
<b class="nc">&nbsp;        if (0 == startingCoords.size()) {</b>
<b class="nc">&nbsp;            getLogger().error(&quot;No valid locations to deploy &quot; + getEntity(entityNum).getDisplayName());</b>
&nbsp;        }
&nbsp;
&nbsp;        // get the coordinates I can deploy on
<b class="nc">&nbsp;        final Coords deployCoords = getFirstValidCoords(getEntity(entityNum), startingCoords);</b>
<b class="nc">&nbsp;        if (null == deployCoords) {</b>
&nbsp;            // if I cannot deploy anywhere, then I get rid of the entity instead so that we may go about our business                
<b class="nc">&nbsp;            getLogger().error(&quot;getCoordsAround gave no location for &quot;</b>
<b class="nc">&nbsp;                    + getEntity(entityNum).getChassis() + &quot;. Removing unit.&quot;);</b>
&nbsp;            
<b class="nc">&nbsp;            sendDeleteEntity(entityNum);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // first coordinate that it is legal to put this unit on now find 
&nbsp;        // some sort of reasonable facing. If there are deployed enemies, 
&nbsp;        // face them
&nbsp;        
&nbsp;        // specifically, face the last deployed enemy.
<b class="nc">&nbsp;        int decentFacing = -1;</b>
<b class="nc">&nbsp;        for (final Entity e : getEnemyEntities()) {</b>
<b class="nc">&nbsp;            if (e.isDeployed() &amp;&amp; !e.isOffBoard()) {</b>
<b class="nc">&nbsp;                decentFacing = deployCoords.direction(e.getPosition());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // if I haven&#39;t found a decent facing, then at least face towards 
&nbsp;        // the center of the board
<b class="nc">&nbsp;        if (-1 == decentFacing) {</b>
<b class="nc">&nbsp;            final Coords center = new Coords(game.getBoard().getWidth() / 2,</b>
<b class="nc">&nbsp;                                       game.getBoard().getHeight() / 2);</b>
<b class="nc">&nbsp;            decentFacing = deployCoords.direction(center);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Entity deployEntity = game.getEntity(entityNum);</b>
<b class="nc">&nbsp;        final IHex deployHex = game.getBoard().getHex(deployCoords);</b>
&nbsp;
<b class="nc">&nbsp;        int deployElevation = getDeployElevation(deployEntity, deployHex);</b>
&nbsp;
&nbsp;        // Compensate for hex elevation where != 0...
<b class="nc">&nbsp;        deployElevation -= deployHex.getLevel();</b>
<b class="nc">&nbsp;        deploy(entityNum, deployCoords, decentFacing, deployElevation);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculate the deployment elevation for the given entity.
&nbsp;     * Gun Emplacements should deploy on the rooftop of the building for maximum visibility.
&nbsp;     */
&nbsp;    private int getDeployElevation(Entity deployEntity, IHex deployHex) {
&nbsp;        // Entity.elevationOccupied performs a null check on IHex
<b class="nc">&nbsp;        if (deployEntity instanceof GunEmplacement) {</b>
<b class="nc">&nbsp;           return deployEntity.elevationOccupied(deployHex) + deployHex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return deployEntity.elevationOccupied(deployHex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first set of valid deployment coordinates for the given unit out of the given deployment coordinates.
&nbsp;     * It&#39;s possible to return null, which indicates that there are no valid hexes for the given unit to deploy into.
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    @Override
&nbsp;    protected Coords getFirstValidCoords(final Entity deployedUnit,
&nbsp;                                         final List&lt;Coords&gt; possibleDeployCoords) {
<b class="nc">&nbsp;        if (Entity.ETYPE_GUN_EMPLACEMENT == (deployedUnit.getEntityType() &amp; Entity.ETYPE_GUN_EMPLACEMENT)) {</b>
<b class="nc">&nbsp;            final List&lt;Coords&gt; validCoords = calculateTurretDeploymentLocations((GunEmplacement) deployedUnit,</b>
&nbsp;                                                                                possibleDeployCoords);
<b class="nc">&nbsp;            if (0 &lt; validCoords.size()) {            </b>
<b class="nc">&nbsp;                return validCoords.get(0);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        else if(getGame().useVectorMove()) {</b>
<b class="nc">&nbsp;            return calculateAdvancedAerospaceDeploymentCoords(deployedUnit, possibleDeployCoords);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return super.getFirstValidCoords(deployedUnit, possibleDeployCoords);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Function that calculates deployment coordinates 
&nbsp;     * @param deployedUnit The unit being considered for deployment
&nbsp;     * @param possibleDeployCoords The coordinates being considered for deployment
&nbsp;     * @return The first valid deployment coordinates.
&nbsp;     */
&nbsp;    private Coords calculateAdvancedAerospaceDeploymentCoords(final Entity deployedUnit,
&nbsp;                                                                    final List&lt;Coords&gt; possibleDeployCoords) {
<b class="nc">&nbsp;        for(Coords coords : possibleDeployCoords) {</b>
<b class="nc">&nbsp;            if(!NewtonianAerospacePathRanker.willFlyOffBoard(deployedUnit, coords)) {</b>
<b class="nc">&nbsp;                return coords;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // if we can&#39;t find any good deployment coordinates, deploy anyway to the first available one
&nbsp;        // and maybe eventually we&#39;ll slow down enough that we can deploy without immediately flying off
<b class="nc">&nbsp;        if(possibleDeployCoords.size() &gt; 0) {</b>
<b class="nc">&nbsp;            return possibleDeployCoords.get(0);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function that calculates the possible locations where a given gun emplacement can be deployed
&nbsp;     * @param deployedUnit The unit to check
&nbsp;     * @param possibleDeployCoords The list of possible deployment coordinates
&nbsp;     */
&nbsp;    private List&lt;Coords&gt; calculateTurretDeploymentLocations(final GunEmplacement deployedUnit,
&nbsp;                                                            final List&lt;Coords&gt; possibleDeployCoords) {
&nbsp;        // algorithm:
&nbsp;        // get all hexes in deployment zone with buildings
&nbsp;        // for each building, if deploying on the roof does not cause a stacking violation, add it to the list
&nbsp;        // sort the list in decreasing order based on CF then height
<b class="nc">&nbsp;        final List&lt;Coords&gt; turretDeploymentLocations = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (final Coords coords : possibleDeployCoords) {</b>
<b class="nc">&nbsp;            final Building building = game.getBoard().getBuildingAt(coords);</b>
<b class="nc">&nbsp;            final IHex hex = game.getBoard().getHex(coords);</b>
&nbsp;
<b class="nc">&nbsp;            if (null != building) {</b>
<b class="nc">&nbsp;                final int buildingHeight = hex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;                
&nbsp;                // check stacking violation at the roof level
<b class="nc">&nbsp;                final Entity violation = Compute.stackingViolation(game,</b>
&nbsp;                                                                   deployedUnit,
&nbsp;                                                                   coords,
&nbsp;                                                                   buildingHeight,
&nbsp;                                                                   coords,
&nbsp;                                                                   null);
&nbsp;                // Ignore coords that could cause a stacking violation
<b class="nc">&nbsp;                if (null == violation) {</b>
<b class="nc">&nbsp;                    turretDeploymentLocations.add(coords);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        turretDeploymentLocations.sort((arg0, arg1) -&gt; calculateTurretDeploymentValue(arg1) - calculateTurretDeploymentValue(</b>
&nbsp;                arg0));        
<b class="nc">&nbsp;        return turretDeploymentLocations;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function that calculates the &quot;utility&quot; of placing a turret at the given coords
&nbsp;     * @param coords The location of the building being considered.
&nbsp;     * @return An &quot;arbitrary&quot; utility number
&nbsp;     */
&nbsp;    private int calculateTurretDeploymentValue(final Coords coords) {
&nbsp;        // algorithm: a building is valued by the following formula:
&nbsp;        //      (CF + height * 2) / # turrets placed on the roof
&nbsp;        //      This way, we will generally favor unpopulated higher CF buildings, 
&nbsp;        //      but have some wiggle room in case of a really tall high CF building
<b class="nc">&nbsp;        final Building building = game.getBoard().getBuildingAt(coords);</b>
<b class="nc">&nbsp;        final IHex hex = game.getBoard().getHex(coords);</b>
<b class="nc">&nbsp;        final int turretCount = 1 + game.getGunEmplacements(coords).size();</b>
&nbsp;
<b class="nc">&nbsp;        return (building.getCurrentCF(coords) + hex.terrainLevel(Terrains.BLDG_ELEV) * 2) / turretCount;</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    protected void calculateFiringTurn() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
&nbsp;            // get the first entity that can act this turn make sure weapons 
&nbsp;            // are loaded
<b class="nc">&nbsp;            final Entity shooter = getEntityToFire(fireControlState);</b>
&nbsp;
&nbsp;            // Forego firing if 
&nbsp;            // a) hidden, 
&nbsp;            // b) under &quot;peaceful&quot; forced withdrawal, 
&nbsp;            // c) majority firepower is jammed 
&nbsp;            // d) best firing plan comes up as crap (no expected damage/null)
&nbsp;            //
&nbsp;            // If foregoing firing, unjam highest-damage weapons first, then turret
&nbsp;            
<b class="nc">&nbsp;            boolean skipFiring = false;</b>
&nbsp;            
&nbsp;            // If my unit is forced to withdraw, don&#39;t fire unless I&#39;ve been fired on.
<b class="nc">&nbsp;            if (getForcedWithdrawal() &amp;&amp; shooter.isCrippled()) {</b>
<b class="nc">&nbsp;                final StringBuilder msg = new StringBuilder(shooter.getDisplayName())</b>
<b class="nc">&nbsp;                        .append(&quot; is crippled and withdrawing.&quot;);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (attackedWhileFleeing.contains(shooter.getId())) {</b>
<b class="nc">&nbsp;                        msg.append(&quot;\n\tBut I was fired on, so I will return fire.&quot;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        msg.append(&quot;\n\tI will not fire so long as I&#39;m not fired on.&quot;);</b>
<b class="nc">&nbsp;                        skipFiring = true;</b>
&nbsp;                    }
&nbsp;                } finally {
<b class="nc">&nbsp;                    getLogger().info(msg.toString());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if(shooter.isHidden()) {</b>
<b class="nc">&nbsp;                skipFiring = true;</b>
<b class="nc">&nbsp;                getLogger().info(&quot;Hidden unit skips firing.&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // calculating a firing plan is somewhat expensive, so 
&nbsp;            // we skip this step if we have already decided not to fire due to being hidden or under &quot;peaceful forced withdrawal&quot;
<b class="nc">&nbsp;            if(!skipFiring) {</b>
&nbsp;                // Set up ammo conservation.
<b class="nc">&nbsp;                final Map&lt;Mounted, Double&gt; ammoConservation = calcAmmoConservation(shooter);</b>
&nbsp;    
&nbsp;                // entity that can act this turn make sure weapons are loaded
<b class="nc">&nbsp;                final FiringPlan plan = getFireControl(shooter).getBestFiringPlan(shooter,</b>
<b class="nc">&nbsp;                                                                      getHonorUtil(),</b>
&nbsp;                                                                      game,
&nbsp;                                                                      ammoConservation);
<b class="nc">&nbsp;                if ((null != plan) &amp;&amp; (plan.getExpectedDamage() &gt; 0)) {</b>
<b class="nc">&nbsp;                    getFireControl(shooter).loadAmmo(shooter, plan);</b>
<b class="nc">&nbsp;                    plan.sortPlan();</b>
&nbsp;    
<b class="nc">&nbsp;                    getLogger().info(shooter.getDisplayName() + &quot; - Best Firing Plan: &quot; +</b>
<b class="nc">&nbsp;                        plan.getDebugDescription(LogLevel.DEBUG == getVerbosity()));</b>
&nbsp;    
&nbsp;                    // Add expected damage from the chosen FiringPlan to the 
&nbsp;                    // damageMap for the target enemy.
&nbsp;                    // while we&#39;re looping through all the shots anyway, send any firing mode changes
<b class="nc">&nbsp;                    for(WeaponFireInfo shot : plan) {</b>
<b class="nc">&nbsp;                        Integer targetId = shot.getTarget().getTargetId();</b>
<b class="nc">&nbsp;                        double existingTargetDamage = damageMap.getOrDefault(targetId, 0.0);</b>
<b class="nc">&nbsp;                        double newDamage = existingTargetDamage + shot.getExpectedDamage();</b>
<b class="nc">&nbsp;                        damageMap.put(targetId, newDamage);</b>
&nbsp;                        
<b class="nc">&nbsp;                        if(shot.getUpdatedFiringMode() != null) {</b>
<b class="nc">&nbsp;                        	super.sendModeChange(shooter.getId(), shooter.getEquipmentNum(shot.getWeapon()), shot.getUpdatedFiringMode());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;    
&nbsp;                    // tell the game I want to fire
<b class="nc">&nbsp;                    Vector&lt;EntityAction&gt; actions = new Vector&lt;&gt;();</b>
&nbsp;                    
&nbsp;                    // if using search light, it needs to go before the other actions so we can light up what we&#39;re shooting at
<b class="nc">&nbsp;                    SearchlightAttackAction searchLightAction = getFireControl(shooter).getSearchLightAction(shooter, plan);</b>
<b class="nc">&nbsp;                    if(searchLightAction != null) {</b>
<b class="nc">&nbsp;                        actions.add(searchLightAction);</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    actions.addAll(plan.getEntityActionVector());</b>
&nbsp;                    
<b class="nc">&nbsp;                    EntityAction spotAction = getFireControl(shooter).getSpotAction(plan, shooter, fireControlState);</b>
<b class="nc">&nbsp;                	if(spotAction != null) {</b>
<b class="nc">&nbsp;                		actions.add(spotAction);</b>
&nbsp;                	}
&nbsp;                    
<b class="nc">&nbsp;                    sendAttackData(shooter.getId(), actions);</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    getLogger().info(&quot;No best firing plan for &quot; + shooter.getDisplayName());</b>
<b class="nc">&nbsp;                    skipFiring = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // if I have decided to skip firing, let&#39;s consider unjamming some weapons or turrets anyway
<b class="nc">&nbsp;            if(skipFiring) {</b>
<b class="nc">&nbsp;                Vector&lt;EntityAction&gt; unjamPlan = getFireControl(shooter).getUnjamWeaponPlan(shooter);</b>
&nbsp;                
<b class="nc">&nbsp;                if(unjamPlan.size() == 0) {</b>
<b class="nc">&nbsp;                	EntityAction spotAction = getFireControl(shooter).getSpotAction(null, shooter, fireControlState);</b>
<b class="nc">&nbsp;                	if(spotAction != null) {</b>
<b class="nc">&nbsp;                		unjamPlan.add(spotAction);</b>
&nbsp;                	}
&nbsp;                	
<b class="nc">&nbsp;                	SearchlightAttackAction searchLightAction = getFireControl(shooter).getSearchLightAction(shooter, null);</b>
<b class="nc">&nbsp;                    if(searchLightAction != null) {</b>
<b class="nc">&nbsp;                        unjamPlan.add(searchLightAction);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                sendAttackData(shooter.getId(), unjamPlan);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculates the targeting/offboard turn
&nbsp;     * This includes firing TAG and non-direct-fire artillery
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected void calculateTargetingOffBoardTurn() {
<b class="nc">&nbsp;        Entity entityToFire = getGame().getFirstEntity(getMyTurn());</b>
<b class="nc">&nbsp;        FiringPlan firingPlan = getArtilleryTargetingControl().calculateIndirectArtilleryPlan(entityToFire, getGame(), this);</b>
&nbsp;        
<b class="nc">&nbsp;        sendAttackData(entityToFire.getId(), firingPlan.getEntityActionVector());</b>
<b class="nc">&nbsp;        sendDone(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    private Map&lt;Mounted, Double&gt; calcAmmoConservation(final Entity shooter) {
<b class="nc">&nbsp;        final double aggroFactor =</b>
<b class="nc">&nbsp;                (10 - getBehaviorSettings().getHyperAggressionIndex()) * 2;</b>
<b class="nc">&nbsp;        final StringBuilder msg =</b>
&nbsp;                new StringBuilder(&quot;\nCalculating ammo conservation for &quot;)
<b class="nc">&nbsp;                        .append(shooter.getDisplayName());</b>
<b class="nc">&nbsp;        msg.append(&quot;\nAggression Factor = &quot;).append(aggroFactor);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            final Map&lt;AmmoType, Integer&gt; ammoCounts = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            msg.append(&quot;\nPooling Ammo:&quot;);</b>
<b class="nc">&nbsp;            for (final Mounted ammo : shooter.getAmmo()) {</b>
<b class="nc">&nbsp;                final AmmoType ammoType = (AmmoType) ammo.getType();</b>
<b class="nc">&nbsp;                msg.append(&quot;\n\t&quot;).append(ammoType);</b>
<b class="nc">&nbsp;                if (ammoCounts.containsKey(ammoType)) {</b>
<b class="nc">&nbsp;                    ammoCounts.put(ammoType, ammoCounts.get(ammoType) +</b>
<b class="nc">&nbsp;                                             ammo.getUsableShotsLeft());</b>
<b class="nc">&nbsp;                    msg.append(&quot; + &quot;).append(ammo.getUsableShotsLeft())</b>
<b class="nc">&nbsp;                       .append(&quot; = &quot;).append(ammoCounts.get(ammoType));</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                ammoCounts.put(ammoType, ammo.getUsableShotsLeft());</b>
<b class="nc">&nbsp;                msg.append(&quot; + &quot;).append(ammo.getUsableShotsLeft())</b>
<b class="nc">&nbsp;                   .append(&quot; = &quot;).append(ammoCounts.get(ammoType));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            final Map&lt;Mounted, Double&gt; ammoConservation = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            msg.append(&quot;\nCalculating conservation for each weapon&quot;);</b>
<b class="nc">&nbsp;            for (final Mounted weapon : shooter.getWeaponList()) {</b>
<b class="nc">&nbsp;                final WeaponType weaponType = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;                msg.append(&quot;\n\t&quot;).append(weaponType);</b>
<b class="nc">&nbsp;                if (!(weaponType instanceof AmmoWeapon)) {</b>
<b class="nc">&nbsp;                    ammoConservation.put(weapon, 0.0);</b>
<b class="nc">&nbsp;                    msg.append(&quot; doesn&#39;t use ammo.&quot;);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int ammoCount = 0;</b>
<b class="nc">&nbsp;                for (final AmmoType ammoType : ammoCounts.keySet()) {</b>
<b class="nc">&nbsp;                    if (!AmmoType.isAmmoValid(ammoType, weaponType)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    ammoCount += ammoCounts.get(ammoType);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                msg.append(&quot; has &quot;).append(ammoCount).append(&quot; shots left&quot;);</b>
<b class="nc">&nbsp;                final double toHitThreshold =</b>
<b class="nc">&nbsp;                        Math.max(0.0, 1 - (ammoCount / aggroFactor));</b>
<b class="nc">&nbsp;                msg.append(&quot;; To Hit Threshold = &quot;)</b>
<b class="nc">&nbsp;                   .append(new DecimalFormat(&quot;0.000&quot;)</b>
<b class="nc">&nbsp;                                   .format(toHitThreshold));</b>
<b class="nc">&nbsp;                ammoConservation.put(weapon, toHitThreshold);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return ammoConservation;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().debug(msg.toString());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Worker method that calculates a point blank shot action vector given a firing entity ID and a target ID.
&nbsp;     * 
&nbsp;     * @param firingEntityID the ID of the entity taking the point blank shot
&nbsp;     * @param targetID the ID of the entity being shot at potentially
&nbsp;     */
&nbsp;    protected Vector&lt;EntityAction&gt; calculatePointBlankShot(int firingEntityID, int targetID) {
<b class="nc">&nbsp;        Entity shooter = getGame().getEntity(firingEntityID);</b>
<b class="nc">&nbsp;        Targetable target = getGame().getEntity(targetID); </b>
&nbsp;        
<b class="nc">&nbsp;        final FiringPlanCalculationParameters fccp = </b>
<b class="nc">&nbsp;                new FiringPlanCalculationParameters.Builder().buildExact(shooter, target, calcAmmoConservation(shooter));</b>
<b class="nc">&nbsp;        FiringPlan plan = getFireControl(shooter).determineBestFiringPlan(fccp); </b>
<b class="nc">&nbsp;        getFireControl(shooter).loadAmmo(shooter, plan);</b>
<b class="nc">&nbsp;        plan.sortPlan();</b>
&nbsp;
<b class="nc">&nbsp;        return plan.getEntityActionVector();</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    protected Vector&lt;Minefield&gt; calculateMinefieldDeployment() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
&nbsp;            // currently returns no minefields
&nbsp;            // make an empty vector
<b class="nc">&nbsp;            return new Vector&lt;&gt;();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the move index for the given unit.
&nbsp;     * In general, faster units and units closer to the enemy should move before others.
&nbsp;     * Additional modifiers for being prone, stealthed, unit type and so on are also factored in.
&nbsp;     *
&nbsp;     * @param entity The unit to be indexed.
&nbsp;     * @return The movement index of this unit.  May be positive or negative.  Higher index values should move first.
&nbsp;     */
&nbsp;    double calculateMoveIndex(final Entity entity,
&nbsp;                              final StringBuilder msg) {
&nbsp;
<b class="fc">&nbsp;        final double PRIORITY_PRONE = 1.1;</b>
<b class="fc">&nbsp;        final double PRIORITY_TANK = 1.5;</b>
<b class="fc">&nbsp;        final double PRIORITY_BA = 2;</b>
<b class="fc">&nbsp;        final double PRIORITY_INF = 3;</b>
<b class="fc">&nbsp;        final double PRIORITY_FALLBACK = 2;</b>
<b class="fc">&nbsp;        final double PRIORITY_COMMANDER = 0.5;</b>
<b class="fc">&nbsp;        final double PRIORITY_CIVILIAN = 5;</b>
<b class="fc">&nbsp;        final double PRIORITY_STEALTH = 1.0 / 3;</b>
&nbsp;
<b class="fc">&nbsp;        msg.append(&quot;\n\tCalculating move index for &quot;)</b>
<b class="fc">&nbsp;           .append(entity.getDisplayName());</b>
<b class="fc">&nbsp;        final StringBuilder modifiers = new StringBuilder();</b>
<b class="fc">&nbsp;        final NumberFormat numberFormat = DecimalFormat.getInstance();</b>
<b class="fc">&nbsp;        double total = 0;</b>
&nbsp;        try {
&nbsp;            // Find out how fast this unit can move.
<b class="fc">&nbsp;            int fastestMove = entity.getRunMP(true, false,</b>
&nbsp;                                              false);
<b class="fc">&nbsp;            if (entity.getJumpMP(true) &gt; fastestMove) {</b>
<b class="fc">&nbsp;                fastestMove = entity.getJumpMP(true);</b>
&nbsp;            }
<b class="fc">&nbsp;            msg.append(&quot;\n\t\tFastest Move = &quot;).append(fastestMove);</b>
&nbsp;
&nbsp;            // Get the distance to the nearest enemy.
<b class="fc">&nbsp;            final double distance = getPathRanker(entity).distanceToClosestEnemy(entity, entity.getPosition(), game);</b>
&nbsp;            
<b class="fc">&nbsp;            msg.append(&quot;\n\t\tDistance to Nearest Enemy: &quot;)</b>
<b class="fc">&nbsp;               .append(numberFormat.format(distance));</b>
&nbsp;
&nbsp;            // Get the ratio of distance to speed.
&nbsp;            // Faster units that are closer to the enemy should move later.
<b class="fc">&nbsp;            if (0 == fastestMove) {</b>
&nbsp;                // This unit should have already moved due to the isImmobilized 
&nbsp;                // check.
<b class="nc">&nbsp;                total = distance * 2;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                total = distance / fastestMove;</b>
&nbsp;            }
<b class="fc">&nbsp;            msg.append(&quot;\n\t\tDistance to Move Ratio (dist / move): &quot;)</b>
<b class="fc">&nbsp;               .append(numberFormat.format(total));</b>
&nbsp;
&nbsp;            // Prone enemies move sooner.
<b class="fc">&nbsp;            if (entity.isProne()) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_PRONE;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx1.1 (Is Prone)&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // If all else is equal, Infantry before Battle Armor before Tanks 
&nbsp;            // before Mechs.
<b class="fc">&nbsp;            if (entity instanceof BattleArmor) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_BA;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx2.0 (is BA)&quot;);</b>
<b class="fc">&nbsp;            } else if (entity instanceof Infantry) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_INF;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx3.0 (is Inf)&quot;);</b>
<b class="fc">&nbsp;            } else if (entity instanceof Tank) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_TANK;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx1.5 (is Tank)&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Fleeing entities should move before those not fleeing.
<b class="fc">&nbsp;            if (isFallingBack(entity)) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_FALLBACK;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx2.0 (is Fleeing)&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Move commanders after other units.
<b class="fc">&nbsp;            if (entity.isCommander()) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_COMMANDER;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx0.5 (is Commander)&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Move civilian units before military.
<b class="fc">&nbsp;            if (!entity.isMilitary()) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_CIVILIAN;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx5.0 (is Civilian)&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Move stealthy units later.
<b class="fc">&nbsp;            if (entity.isStealthActive() || entity.isStealthOn() ||</b>
<b class="fc">&nbsp;                entity.isVoidSigActive() || entity.isVoidSigOn()) {</b>
<b class="fc">&nbsp;                total *= PRIORITY_STEALTH;</b>
<b class="fc">&nbsp;                modifiers.append(&quot;\tx1/3 (is Stealthed)&quot;);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return total;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            msg.append(&quot;\n\t\tModifiers:&quot;).append(modifiers);</b>
<b class="fc">&nbsp;            msg.append(&quot;\n\t\tTotal = &quot;).append(numberFormat.format(total));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets an entity eligible to fire from a list contained in the fire control state.
&nbsp;     */
&nbsp;    Entity getEntityToFire(FireControlState fireControlState) {
<b class="nc">&nbsp;    	if(fireControlState.getOrderedFiringEntities().size() == 0) {</b>
<b class="nc">&nbsp;    		initFiringEntities(fireControlState);</b>
&nbsp;    	}
&nbsp;    	
&nbsp;    	//if, even after initializing entities, we have no valid entities
&nbsp;    	//we&#39;ll let the game determine 
<b class="nc">&nbsp;    	if(fireControlState.getOrderedFiringEntities().size() == 0) {</b>
<b class="nc">&nbsp;    	    return game.getFirstEntity(getMyTurn());</b>
&nbsp;    	}
&nbsp;    	
<b class="nc">&nbsp;    	Entity entityToReturn = fireControlState.getOrderedFiringEntities().getFirst();</b>
<b class="nc">&nbsp;    	fireControlState.getOrderedFiringEntities().removeFirst();</b>
<b class="nc">&nbsp;    	return entityToReturn;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Sorts firing entities to ensure that entities that can do indirect fire go after
&nbsp;     * entities that cannot, so that IDF units go after spotting units.
&nbsp;     */
&nbsp;    private void initFiringEntities(FireControlState fireControlState) {
<b class="nc">&nbsp;    	List&lt;Entity&gt; myEntities = game.getPlayerEntities(this.getLocalPlayer(), true);</b>
<b class="nc">&nbsp;    	fireControlState.clearOrderedFiringEntities();</b>
&nbsp;    	
<b class="nc">&nbsp;    	for(Entity entity : myEntities) {</b>
&nbsp;    	    // if you can&#39;t fire, you can&#39;t fire.
<b class="nc">&nbsp;    		if(!getMyTurn().isValidEntity(entity, game)) {</b>
<b class="nc">&nbsp;    			continue;</b>
&nbsp;    		}
&nbsp;    		
<b class="nc">&nbsp;    		if(getFireControl(entity).entityCanIndirectFireMissile(fireControlState, entity)) {</b>
<b class="nc">&nbsp;    			fireControlState.getOrderedFiringEntities().addLast(entity);</b>
&nbsp;    		} else {
<b class="nc">&nbsp;    			fireControlState.getOrderedFiringEntities().addFirst(entity);</b>
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Loops through the list of entities controlled by this Princess instance 
&nbsp;     * and decides which should be moved first.
&nbsp;     * Immobile units and ejected mechwarriors/crews will be moved first.  
&nbsp;     * After that, each unit is given an index// This unit should have already 
&nbsp;     * moved due to the isImmobilized check. via the 
&nbsp;     * {@link #calculateMoveIndex(Entity, StringBuilder)} method.  The highest 
&nbsp;     * index value is moved first.
&nbsp;     *
&nbsp;     * @return The entity that should be moved next.
&nbsp;     */
&nbsp;    Entity getEntityToMove() {
&nbsp;
&nbsp;        // first move useless units: immobile units, ejected mechwarrior, etc
<b class="fc">&nbsp;        Entity movingEntity = null;</b>
<b class="fc">&nbsp;        final List&lt;Entity&gt; myEntities = getEntitiesOwned();</b>
<b class="fc">&nbsp;        double highestIndex = -Double.MAX_VALUE;</b>
<b class="fc">&nbsp;        final StringBuilder msg = new StringBuilder(&quot;Deciding who to move next.&quot;);</b>
<b class="fc">&nbsp;        for (final Entity entity : myEntities) {</b>
<b class="fc">&nbsp;            msg.append(&quot;\n\tUnit &quot;).append(entity.getDisplayName());</b>
&nbsp;            
<b class="fc">&nbsp;            if(entity.isDone()) {</b>
<b class="nc">&nbsp;                msg.append(&quot;has already moved this phase&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            if ((entity.isOffBoard() </b>
<b class="fc">&nbsp;                    || (null == entity.getPosition())</b>
<b class="fc">&nbsp;                    || entity.isUnloadedThisTurn()</b>
<b class="fc">&nbsp;                    || !getGame().getTurn().isValidEntity(entity, getGame()))</b>
<b class="fc">&nbsp;                            &amp;&amp; !getGame().isPhaseSimultaneous()){</b>
<b class="fc">&nbsp;                msg.append(&quot;cannot be moved.&quot;);</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Move immobile units &amp; ejected mechwarriors immediately.
<b class="fc">&nbsp;            if (isImmobilized(entity) &amp;&amp; !(entity instanceof Infantry)) {</b>
<b class="fc">&nbsp;                msg.append(&quot;is immobile.&quot;);</b>
<b class="fc">&nbsp;                movingEntity = entity;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            if (entity instanceof MechWarrior) {</b>
<b class="fc">&nbsp;                msg.append(&quot;is ejected crew.&quot;);</b>
<b class="fc">&nbsp;                movingEntity = entity;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // can&#39;t do anything with out-of-control aeros, so use them as init sinks
<b class="fc">&nbsp;            if(entity.isAero() &amp;&amp; ((IAero) entity).isOutControlTotal()) {</b>
<b class="nc">&nbsp;                msg.append(&quot;is out-of-control aero.&quot;);</b>
<b class="nc">&nbsp;                movingEntity = entity;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If I only have 1 unit, no need to calculate an index.
<b class="fc">&nbsp;            if (1 == myEntities.size()) {</b>
<b class="nc">&nbsp;                msg.append(&quot;is my only unit.&quot;);</b>
<b class="nc">&nbsp;                movingEntity = entity;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // We will move the entity with the highest index.
<b class="fc">&nbsp;            final double moveIndex = calculateMoveIndex(entity, msg);</b>
<b class="fc">&nbsp;            msg.append(&quot;\n\thas index &quot;).append(moveIndex).append(&quot; vs &quot;)</b>
<b class="fc">&nbsp;               .append(highestIndex);</b>
<b class="fc">&nbsp;            if (moveIndex &gt;= highestIndex) {</b>
<b class="fc">&nbsp;                highestIndex = moveIndex;</b>
<b class="fc">&nbsp;                movingEntity = entity;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        final LogLevel level = (null == movingEntity ? LogLevel.WARNING :</b>
<b class="fc">&nbsp;                                LogLevel.DEBUG);</b>
<b class="fc">&nbsp;        getLogger().log(level, msg.toString(), null);</b>
&nbsp;
<b class="fc">&nbsp;        return movingEntity;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected MovePath calculateMoveTurn() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            return continueMovementFor(getEntityToMove());</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected PhysicalOption calculatePhysicalTurn() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            initialize();</b>
&nbsp;            // get the first entity that can act this turn
<b class="nc">&nbsp;            final Entity attacker = game.getFirstEntity(getMyTurn());</b>
&nbsp;
&nbsp;            // If my unit is forced to withdraw, don&#39;t attack unless I&#39;ve been 
&nbsp;            // attacked.
<b class="nc">&nbsp;            if (getForcedWithdrawal() &amp;&amp; attacker.isCrippled()) {</b>
<b class="nc">&nbsp;                final StringBuilder msg =</b>
<b class="nc">&nbsp;                        new StringBuilder(attacker.getDisplayName())</b>
<b class="nc">&nbsp;                                .append(&quot; is crippled and withdrawing.&quot;);</b>
<b class="nc">&nbsp;                if (attackedWhileFleeing.contains(attacker.getId())) {</b>
<b class="nc">&nbsp;                    msg.append(&quot;\n\tBut I was fired on, so I will hit back.&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    msg.append(&quot;\n\tI will not attack so long as I&#39;m not fired on.&quot;);</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                getLogger().info(msg.toString());</b>
&nbsp;            }
&nbsp;
&nbsp;            // the original bot&#39;s physical options seem superior
<b class="nc">&nbsp;            PhysicalOption bestPhysical = PhysicalCalculator.getBestPhysical(attacker, game);</b>
<b class="nc">&nbsp;            return bestPhysical;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean wantsToFallBack(final Entity entity) {
<b class="fc">&nbsp;        return (entity.isCrippled() &amp;&amp; getForcedWithdrawal()) || getFallBack();</b>
&nbsp;    }
&nbsp;
&nbsp;    IMoralUtil getMoralUtil() {
<b class="nc">&nbsp;        return moralUtil;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Logic to determine if this entity is &quot;falling back&quot; for any reason
&nbsp;     * @param entity The entity to check.
&nbsp;     * @return Whether or not the entity is falling back.
&nbsp;     */
&nbsp;    boolean isFallingBack(final Entity entity) {
<b class="fc">&nbsp;        return (getBehaviorSettings().getDestinationEdge() != CardinalEdge.NEAREST_OR_NONE) ||</b>
<b class="fc">&nbsp;                (getBehaviorSettings().isForcedWithdrawal() &amp;&amp; entity.isCrippled(true));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Logic to determine if this entity is in a state where it can shoot due to being attacked while fleeing.
&nbsp;     * @param entity Entity to check.
&nbsp;     * @return Whether or not this entity can shoot while falling back.
&nbsp;     */
&nbsp;    boolean canShootWhileFallingBack(Entity entity) {
<b class="nc">&nbsp;        return attackedWhileFleeing.contains(entity.getId());</b>
&nbsp;    }
&nbsp;    
&nbsp;    boolean mustFleeBoard(final Entity entity) {
<b class="fc">&nbsp;        if (!isFallingBack(entity)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!entity.canFlee()) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (0 &lt; getPathRanker(entity).distanceToHomeEdge(entity.getPosition(),</b>
<b class="fc">&nbsp;                                                   getHomeEdge(entity), getGame())) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        //noinspection RedundantIfStatement
<b class="fc">&nbsp;        if (!getFleeBoard() &amp;&amp; !(entity.isCrippled() &amp;&amp; getForcedWithdrawal())) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean isImmobilized(final Entity mover) {
<b class="fc">&nbsp;        if (mover.isImmobile() &amp;&amp; !mover.isShutDown()) {</b>
<b class="fc">&nbsp;            getLogger().info(&quot;Is truly immobile.&quot;);</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (1 &gt; mover.getRunMP()) {</b>
<b class="fc">&nbsp;            getLogger().info(&quot;Has 0 movement.&quot;);</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!(mover instanceof Mech)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final Mech mech = (Mech) mover;</b>
<b class="fc">&nbsp;        if (!mech.isProne() &amp;&amp; !mech.isStuck() &amp;&amp; !mech.isStalled()) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final MovePath movePath = new MovePath(getGame(), mover);</b>
&nbsp;
&nbsp;        // For a normal fall-shame setting (index 5), our threshold should be 
&nbsp;        // a 10+ piloting roll.
&nbsp;        final int threshold;
<b class="fc">&nbsp;        switch (getBehaviorSettings().getFallShameIndex()) {</b>
&nbsp;            case 10:
<b class="nc">&nbsp;                threshold = 7;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 9:
<b class="nc">&nbsp;                threshold = 8;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 8:
&nbsp;            case 7:
<b class="nc">&nbsp;                threshold = 9;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 6:
&nbsp;            case 5:
<b class="fc">&nbsp;                threshold = 10;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case 4:
<b class="nc">&nbsp;                threshold = 11;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                threshold = 12;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                threshold = 13; // Actually impossible.</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we&#39;re prone, see if we have a chance of getting up.
<b class="fc">&nbsp;        if (mech.isProne()) {</b>
<b class="fc">&nbsp;            if (mech.cannotStandUpFromHullDown()) {</b>
<b class="fc">&nbsp;                getLogger().info(&quot;Cannot stand up.&quot;);</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            final MovePath.MoveStepType type = (getBooleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_CAREFUL_STAND) ?</b>
<b class="nc">&nbsp;                                                MovePath.MoveStepType.CAREFUL_STAND :</b>
<b class="fc">&nbsp;                                                MovePath.MoveStepType.GET_UP);</b>
<b class="fc">&nbsp;            final MoveStep getUp = new MoveStep(movePath, type);</b>
&nbsp;
&nbsp;            // If our odds to get up are equal to or worse than the threshold, 
&nbsp;            // consider ourselves immobile.
<b class="fc">&nbsp;            final PilotingRollData target = mech.checkGetUp(getUp,</b>
<b class="fc">&nbsp;                                                            movePath.getLastStepMovementType());</b>
<b class="fc">&nbsp;            getLogger().info(&quot;Need to roll &quot; + target.getValue() +</b>
&nbsp;                &quot; to stand and our tolerance is &quot; + threshold);
<b class="fc">&nbsp;            return (target.getValue() &gt;= threshold);</b>
&nbsp;        }
&nbsp;
&nbsp;        // How likely are we to get unstuck.
<b class="fc">&nbsp;        final MovePath.MoveStepType type = MovePath.MoveStepType.FORWARDS;</b>
<b class="fc">&nbsp;        final MoveStep walk = new MoveStep(movePath, type);</b>
<b class="fc">&nbsp;        final IHex hex = getHex(mech.getPosition());</b>
<b class="fc">&nbsp;        final PilotingRollData target = mech.checkBogDown(walk,</b>
<b class="fc">&nbsp;                                                          movePath.getLastStepMovementType(), hex,</b>
<b class="fc">&nbsp;                                                          mech.getPriorPosition(), mech.getPosition(), hex.getLevel(),</b>
&nbsp;                                                          false);
<b class="fc">&nbsp;        getLogger().info(&quot;Need to roll &quot; + target.getValue() +</b>
&nbsp;            &quot; to get unstuck and our tolerance is &quot; + threshold);
<b class="fc">&nbsp;        return (target.getValue() &gt;= threshold);</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean getBooleanOption(final String name) {
<b class="nc">&nbsp;        return getGame().getOptions().booleanOption(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected IHex getHex(final Coords coords) {
<b class="nc">&nbsp;        return getBoard().getHex(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected MovePath continueMovementFor(final Entity entity) {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
<b class="nc">&nbsp;        if (null == entity) {</b>
<b class="nc">&nbsp;            throw new NullPointerException(&quot;Entity is null.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
&nbsp;            // figure out who moved last, and who&#39;s move lists need to be 
&nbsp;            // updated
&nbsp;
&nbsp;            // moves this entity during movement phase
<b class="nc">&nbsp;            getLogger().debug(&quot;Moving &quot; + entity.getDisplayName() + &quot; (ID &quot; + entity.getId() + &quot;)&quot;);</b>
<b class="nc">&nbsp;            getPrecognition().ensureUpToDate();</b>
&nbsp;
<b class="nc">&nbsp;            if (isFallingBack(entity)) {</b>
<b class="nc">&nbsp;                String msg = entity.getDisplayName();</b>
<b class="nc">&nbsp;                if (getFallBack()) {</b>
<b class="nc">&nbsp;                    msg += &quot; is falling back.&quot;;</b>
<b class="nc">&nbsp;                } else if (entity.isCrippled()) {</b>
<b class="nc">&nbsp;                    msg += &quot; is crippled and withdrawing.&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                getLogger().debug(msg);</b>
<b class="nc">&nbsp;                sendChat(msg, LogLevel.WARNING);</b>
&nbsp;
&nbsp;                // If this entity is falling back, able to flee the board, on 
&nbsp;                // its home edge, and must flee, do so.
<b class="nc">&nbsp;                if (mustFleeBoard(entity)) {</b>
<b class="nc">&nbsp;                    final MovePath mp = new MovePath(game, entity);</b>
<b class="nc">&nbsp;                    mp.addStep(MovePath.MoveStepType.FLEE);</b>
<b class="nc">&nbsp;                    return mp;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If we want to flee, but cannot, eject the crew.
<b class="nc">&nbsp;                if (isImmobilized(entity) &amp;&amp; entity.isEjectionPossible()) {</b>
<b class="nc">&nbsp;                    msg = entity.getDisplayName() +</b>
&nbsp;                          &quot; is immobile.  Abandoning unit.&quot;;
<b class="nc">&nbsp;                    getLogger().info(msg);</b>
<b class="nc">&nbsp;                    sendChat(msg, LogLevel.WARNING);</b>
<b class="nc">&nbsp;                    final MovePath mp = new MovePath(game, entity);</b>
<b class="nc">&nbsp;                    mp.addStep(MovePath.MoveStepType.EJECT);</b>
<b class="nc">&nbsp;                    return mp;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final List&lt;MovePath&gt; paths = getMovePathsAndSetNecessaryTargets(entity, false);</b>
&nbsp;
<b class="nc">&nbsp;            if (null == paths) {</b>
<b class="nc">&nbsp;                getLogger().warning(&quot;No valid paths found.&quot;);</b>
<b class="nc">&nbsp;                return performPathPostProcessing(new MovePath(game, entity), 0);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final double thisTimeEstimate =</b>
<b class="nc">&nbsp;                    (paths.size() * moveEvaluationTimeEstimate) / 1e3;</b>
<b class="nc">&nbsp;            if (getVerbosity().willLog(LogLevel.INFO)) {</b>
<b class="nc">&nbsp;                String timeestimate = &quot;unknown.&quot;;</b>
<b class="nc">&nbsp;                if (0 != thisTimeEstimate) {</b>
<b class="nc">&nbsp;                    timeestimate = Integer.toString((int) thisTimeEstimate)</b>
&nbsp;                                   + &quot; seconds&quot;;
&nbsp;                }
<b class="nc">&nbsp;                final String message = &quot;Moving &quot; + entity.getChassis() + &quot;. &quot;</b>
<b class="nc">&nbsp;                                       + Long.toString(paths.size())</b>
&nbsp;                                       + &quot; paths to consider.  Estimated time to completion: &quot;
&nbsp;                                       + timeestimate;
<b class="nc">&nbsp;                sendChat(message, LogLevel.INFO);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final long startTime = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            getPathRanker(entity).initUnitTurn(entity, getGame());</b>
<b class="nc">&nbsp;            final double fallTolerance =</b>
<b class="nc">&nbsp;                    getBehaviorSettings().getFallShameIndex() / 10d;</b>
<b class="nc">&nbsp;            final int startingHomeDistance = getPathRanker(entity).distanceToHomeEdge(</b>
<b class="nc">&nbsp;                    entity.getPosition(),</b>
<b class="nc">&nbsp;                    getBehaviorSettings().getDestinationEdge(),</b>
<b class="nc">&nbsp;                    getGame());</b>
&nbsp;                       
<b class="nc">&nbsp;            final List&lt;RankedPath&gt; rankedpaths = getPathRanker(entity).rankPaths(paths,</b>
<b class="nc">&nbsp;                                                    getGame(),</b>
<b class="nc">&nbsp;                                                    getMaxWeaponRange(entity),</b>
&nbsp;                                                    fallTolerance,
&nbsp;                                                    startingHomeDistance,
<b class="nc">&nbsp;                                                    getEnemyEntities(),</b>
<b class="nc">&nbsp;                                                    getFriendEntities());</b>
&nbsp;            
<b class="nc">&nbsp;            final long stop_time = System.currentTimeMillis();</b>
&nbsp;
&nbsp;            // update path evaluation time estimate
<b class="nc">&nbsp;            final double updatedEstimate =</b>
<b class="nc">&nbsp;                    ((double) (stop_time - startTime)) / ((double) paths.size());</b>
<b class="nc">&nbsp;            if (0 == moveEvaluationTimeEstimate) {</b>
<b class="nc">&nbsp;                moveEvaluationTimeEstimate = updatedEstimate;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            moveEvaluationTimeEstimate = 0.5 * (updatedEstimate + moveEvaluationTimeEstimate);</b>
&nbsp;            
<b class="nc">&nbsp;            if (0 == rankedpaths.size()) {</b>
<b class="nc">&nbsp;                return performPathPostProcessing(new MovePath(game, entity), 0);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            getLogger().debug(&quot;Path ranking took &quot; + Long.toString(stop_time - startTime) + &quot; millis&quot;);</b>
&nbsp;            
<b class="nc">&nbsp;            final RankedPath bestpath = getPathRanker(entity).getBestPath(rankedpaths);</b>
<b class="nc">&nbsp;            getLogger().info(&quot;Best Path: &quot; + bestpath.getPath() + &quot;  Rank: &quot; + bestpath.getRank());</b>
&nbsp;            
<b class="nc">&nbsp;            return performPathPostProcessing(bestpath);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            precognition.unPause();</b>
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void initFiring() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            initialize();</b>
&nbsp;
&nbsp;            // ----Debugging: print out any errors made in guessing to hit
&nbsp;            // values-----
<b class="nc">&nbsp;            final List&lt;Entity&gt; ents = game.getEntitiesVector();</b>
<b class="nc">&nbsp;            for (final Entity ent : ents) {</b>
<b class="nc">&nbsp;                final String errors = getFireControl(ent).checkAllGuesses(ent, game);</b>
<b class="nc">&nbsp;                if (!StringUtil.isNullOrEmpty(errors)) {</b>
<b class="nc">&nbsp;                    getLogger().warning(errors);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // -----------------------------------------------------------------------
&nbsp;
&nbsp;            // Pick up on any infantry/BA in buildings post-movement and shoot
&nbsp;            // their buildings, similar to the turret check
&nbsp;            // pre-movement(infantry can move so we only set target buildings
&nbsp;            // after they do).
<b class="nc">&nbsp;            final Enumeration&lt;Building&gt; buildings = game.getBoard().getBuildings();</b>
<b class="nc">&nbsp;            while (buildings.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Building bldg = buildings.nextElement();</b>
<b class="nc">&nbsp;                final Enumeration&lt;Coords&gt; bldgCoords = bldg.getCoords();</b>
<b class="nc">&nbsp;                while (bldgCoords.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    final Coords coords = bldgCoords.nextElement();</b>
<b class="nc">&nbsp;                    for (final Entity entity : game.getEntitiesVector(coords)) {</b>
<b class="nc">&nbsp;                        final BuildingTarget bt = new BuildingTarget(coords,</b>
<b class="nc">&nbsp;                                                                     game.getBoard(), false);</b>
&nbsp;                        // Want to target buildings with hostile infantry/BA
&nbsp;                        // inside them, since there&#39;s no other way to attack
&nbsp;                        // them.
<b class="nc">&nbsp;                        if (isEnemyInfantry(entity, coords)</b>
<b class="nc">&nbsp;                                &amp;&amp; Compute.isInBuilding(game, entity)</b>
<b class="nc">&nbsp;                                &amp;&amp; !entity.isHidden()) {</b>
<b class="nc">&nbsp;                            fireControlState.getAdditionalTargets().add(bt);</b>
<b class="nc">&nbsp;                            sendChat(&quot;Building in Hex &quot;</b>
<b class="nc">&nbsp;                                     + coords.toFriendlyString()</b>
&nbsp;                                     + &quot; designated target due to&quot;
&nbsp;                                     + &quot; infantry inside building.&quot;, LogLevel.INFO);
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //Next, collect the ID&#39;s of each potential target and store them in 
&nbsp;            // the damageMap for allocating damage during firing.
&nbsp;
&nbsp;            //Reset the map generated during the movement phase- The available 
&nbsp;            // targets may have changed during that time(ejections, enemies 
&nbsp;            // fleeing, etc).
<b class="nc">&nbsp;            damageMap.clear();</b>
&nbsp;            //Now add an ID for each possible target.
<b class="nc">&nbsp;            final List&lt;Targetable&gt; potentialTargets =</b>
<b class="nc">&nbsp;                    FireControl.getAllTargetableEnemyEntities(getLocalPlayer(),</b>
<b class="nc">&nbsp;                                                              getGame(),</b>
<b class="nc">&nbsp;                                                              getFireControlState());</b>
<b class="nc">&nbsp;            for (final Targetable target : potentialTargets) {</b>
<b class="nc">&nbsp;                damageMap.put(target.getTargetId(), 0d);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            getFireControlState().clearTransientData();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Function with side effects. Retrieves the move path collection we want
&nbsp;     * the entity to consider. Sometimes it&#39;s the standard &quot;circle&quot;, sometimes it&#39;s pruned long-range movement paths
&nbsp;     */
&nbsp;    public List&lt;MovePath&gt; getMovePathsAndSetNecessaryTargets(Entity mover, boolean forceMoveToContact) {
&nbsp;        // if the mover can&#39;t move, then there&#39;s nothing for us to do here, let&#39;s cut out.
<b class="nc">&nbsp;        if(mover.isImmobile()) {</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        BehaviorType behavior = forceMoveToContact ? BehaviorType.MoveToContact : unitBehaviorTracker.getBehaviorType(mover, this);</b>
&nbsp;        // during the movement phase, it is technically necessary to clear this data between each unit
&nbsp;        // as the state of the board may have changed due to crashes etc. 
&nbsp;        // generating movable clusters is a relatively cheap operation, so it&#39;s not a big deal
<b class="nc">&nbsp;        getClusterTracker().clearMovableAreas();</b>
<b class="nc">&nbsp;        getClusterTracker().updateMovableAreas(mover);</b>
&nbsp;        
&nbsp;        // basic idea: 
&nbsp;        // if we&#39;re &quot;in battle&quot;, just use the standard set of move paths
&nbsp;        // if we&#39;re trying to get somewhere
&nbsp;        //  - sort all long range paths by &quot;mp cost&quot; (actual MP + how long it&#39;ll take to do terrain leveling)
&nbsp;        //  - set the first terrain/building as &#39;strategic target&#39; if the shortest path requires terrain leveling
&nbsp;        //  - if the first strategic target is in LOS at the pruned end of the shortest path,  
&nbsp;        //      then we actually return the paths for &quot;engaged&quot; behavior
&nbsp;        //  - if we&#39;re unable to get where we&#39;re going, use standard set of move paths
&nbsp;        
<b class="nc">&nbsp;        switch(behavior) {</b>
&nbsp;        case Engaged:
<b class="nc">&nbsp;            return getPrecognition().getPathEnumerator()</b>
<b class="nc">&nbsp;                    .getUnitPaths()</b>
<b class="nc">&nbsp;                    .get(mover.getId());</b>
&nbsp;        case MoveToDestination:
&nbsp;        case MoveToContact:
&nbsp;        case ForcedWithdrawal:
&nbsp;        default:
<b class="nc">&nbsp;            List&lt;BulldozerMovePath&gt; bulldozerPaths = getPrecognition().getPathEnumerator().</b>
<b class="nc">&nbsp;                getLongRangePaths().get(mover.getId());</b>
&nbsp;            
&nbsp;            // for whatever reason (most likely it&#39;s wheeled), there are no long-range paths for this unit, 
&nbsp;            // so just have it mill around in place as usual. Also set the behavior to &quot;no path to destination&quot;
&nbsp;            // so it doesn&#39;t hump the walls due to &quot;self preservation mods&quot;
<b class="nc">&nbsp;            if ((bulldozerPaths == null) || (bulldozerPaths.size() == 0)) {</b>
&nbsp;                
<b class="nc">&nbsp;                if (!mover.isAirborne()) {</b>
<b class="nc">&nbsp;                    getUnitBehaviorTracker().overrideBehaviorType(mover, BehaviorType.NoPathToDestination);</b>
&nbsp;                }
<b class="nc">&nbsp;                return getPrecognition().getPathEnumerator()</b>
<b class="nc">&nbsp;                        .getUnitPaths()</b>
<b class="nc">&nbsp;                        .get(mover.getId());</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            Collections.sort(bulldozerPaths, new BulldozerMovePath.MPCostComparator());</b>
&nbsp;            
&nbsp;            // if the quickest route needs some terrain adjustments, let&#39;s get working on that
<b class="nc">&nbsp;            Targetable levelingTarget = null;</b>
&nbsp;            
<b class="nc">&nbsp;            if (bulldozerPaths.get(0).needsLeveling()) {</b>
<b class="nc">&nbsp;                levelingTarget = getAppropriateTarget(bulldozerPaths.get(0).getCoordsToLevel().get(0));</b>
<b class="nc">&nbsp;                getFireControlState().getAdditionalTargets().add(levelingTarget);</b>
<b class="nc">&nbsp;                sendChat(&quot;Hex &quot; + levelingTarget.getPosition().toFriendlyString() + &quot; impedes route to destination, targeting for clearing.&quot;, </b>
&nbsp;                        LogLevel.INFO);
&nbsp;            }
&nbsp;            
&nbsp;            // if any of the long range paths, pruned, are within LOS of leveling coordinates, then we&#39;re actually
&nbsp;            // just going to go back to the standard unit paths
<b class="nc">&nbsp;            List&lt;MovePath&gt; prunedPaths = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (BulldozerMovePath movePath : bulldozerPaths) {</b>
<b class="nc">&nbsp;                BulldozerMovePath prunedPath = movePath.clone();</b>
<b class="nc">&nbsp;                prunedPath.clipToPossible();</b>
&nbsp;                
<b class="nc">&nbsp;                if(levelingTarget != null) {</b>
<b class="nc">&nbsp;                    LosEffects los = LosEffects.calculateLos(game, mover.getId(), levelingTarget, </b>
<b class="nc">&nbsp;                            prunedPath.getFinalCoords(), levelingTarget.getPosition(), false);</b>
&nbsp;                    
&nbsp;                    // break out of this loop, we can get to the thing we&#39;re trying to level this turn, so let&#39;s
&nbsp;                    // use normal movement routines to move into optimal position to blow it up
&nbsp;                    // Also set the behavior to &quot;engaged&quot;
&nbsp;                    // so it doesn&#39;t hump walls due to &quot;self preservation mods&quot;
<b class="nc">&nbsp;                    if(los.canSee()) {</b>
&nbsp;                        // if we&#39;ve explicitly forced &#39;move to contact&#39; behavior, don&#39;t flip back to &#39;engaged&#39;
<b class="nc">&nbsp;                        if(!forceMoveToContact) {</b>
<b class="nc">&nbsp;                            getUnitBehaviorTracker().overrideBehaviorType(mover, BehaviorType.Engaged);</b>
&nbsp;                        }
&nbsp;                        
<b class="nc">&nbsp;                        return getPrecognition().getPathEnumerator()</b>
<b class="nc">&nbsp;                                .getUnitPaths()</b>
<b class="nc">&nbsp;                                .get(mover.getId());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                
&nbsp;                // add the pruned path to the list of paths we&#39;ll be returning
<b class="nc">&nbsp;                prunedPaths.add(prunedPath);</b>
&nbsp;                
&nbsp;                // also return some paths that go a little slower than max speed
&nbsp;                // in case the faster path would force an unwanted PSR or MASC check 
<b class="nc">&nbsp;                for(MovePath childBMP : PathDecorator.decoratePath(prunedPath)) {</b>
<b class="nc">&nbsp;                    prunedPaths.add(childBMP);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            
<b class="nc">&nbsp;            return prunedPaths;</b>
&nbsp;        }
&nbsp;        
&nbsp;    }
&nbsp;
&nbsp;    private void checkForDishonoredEnemies() {
<b class="nc">&nbsp;        final StringBuilder msg = new StringBuilder(&quot;Checking for dishonored enemies.&quot;);</b>
&nbsp;
&nbsp;        try {
&nbsp;            // If the Forced Withdrawal rule is not turned on, then it&#39;s a 
&nbsp;            // fight to the death anyway.
<b class="nc">&nbsp;            if (!getForcedWithdrawal()) {</b>
<b class="nc">&nbsp;                msg.append(&quot;\n\tForced withdrawal turned off.&quot;);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (final Entity mine : getEntitiesOwned()) {</b>
&nbsp;
&nbsp;                // Who just attacked me?
<b class="nc">&nbsp;                final Collection&lt;Integer&gt; attackedBy = mine.getAttackedByThisTurn();</b>
<b class="nc">&nbsp;                if (attackedBy.isEmpty()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Is my unit trying to withdraw as per forced withdrawal rules?
&nbsp;                // shortcut: we already check for forced withdrawal above, so need to do that here
<b class="nc">&nbsp;                final boolean fleeing = crippledUnits.contains(mine.getId()); </b>
&nbsp;
<b class="nc">&nbsp;                for (final int id : attackedBy) {</b>
<b class="nc">&nbsp;                    final Entity entity = getGame().getEntity(id);</b>
<b class="nc">&nbsp;                    if (null == entity) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (getHonorUtil().isEnemyBroken(entity.getTargetId(),</b>
<b class="nc">&nbsp;                                                     entity.getOwnerId(),</b>
<b class="nc">&nbsp;                                                     getForcedWithdrawal()) ||</b>
<b class="nc">&nbsp;                        !entity.isMilitary()) {</b>
&nbsp;                        // If he&#39;d just continued running, I would have let him 
&nbsp;                        // go, but the bastard shot at me!
<b class="nc">&nbsp;                        msg.append(&quot;\n\t&quot;)</b>
<b class="nc">&nbsp;                           .append(entity.getDisplayName())</b>
<b class="nc">&nbsp;                           .append(&quot;dishonored himself by attacking me even though he is &quot;);</b>
<b class="nc">&nbsp;                        if (!entity.isMilitary()) {</b>
<b class="nc">&nbsp;                            msg.append(&quot;a civilian.&quot;);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            msg.append(&quot;fleeing.&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        getHonorUtil().setEnemyDishonored(entity.getOwnerId());</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // He shot me while I was running away!
<b class="nc">&nbsp;                    if (fleeing) {</b>
<b class="nc">&nbsp;                        msg.append(&quot;\n\t&quot;)</b>
<b class="nc">&nbsp;                           .append(entity.getDisplayName())</b>
<b class="nc">&nbsp;                           .append(&quot;dishonored himself by attacking a fleeing unit (&quot;)</b>
<b class="nc">&nbsp;                           .append(mine.getDisplayName())</b>
<b class="nc">&nbsp;                           .append(&quot;).&quot;);</b>
<b class="nc">&nbsp;                        getHonorUtil().setEnemyDishonored(entity.getOwnerId());</b>
<b class="nc">&nbsp;                        attackedWhileFleeing.add(mine.getId());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().info(msg.toString());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void checkForBrokenEnemies() {
&nbsp;
&nbsp;        // If the Forced Withdrawal rule is not turned on, then it&#39;s a fight 
&nbsp;        // to the death anyway.
<b class="nc">&nbsp;        if (!getForcedWithdrawal()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (final Entity entity : getEnemyEntities()) {</b>
<b class="nc">&nbsp;            getHonorUtil().checkEnemyBroken(entity, getForcedWithdrawal());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /** Update the various state trackers for a specific entity.
&nbsp;     * Useful to call when receiving an entity update packet */
&nbsp;    public void updateEntityState(Entity entity) {
<b class="nc">&nbsp;        if(entity.getOwner().isEnemyOf(getLocalPlayer())) {</b>
&nbsp;            // currently just the honor util, and only update it for hostile units
<b class="nc">&nbsp;            getHonorUtil().checkEnemyBroken(entity, getForcedWithdrawal());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected void initMovement() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            initialize();</b>
<b class="nc">&nbsp;            checkMoral();</b>
<b class="nc">&nbsp;            unitBehaviorTracker.clear();</b>
&nbsp;
&nbsp;            // reset strategic targets
<b class="nc">&nbsp;            fireControlState.setAdditionalTargets(new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;            for (final Coords strategicTarget : getStrategicBuildingTargets()) {</b>
<b class="nc">&nbsp;                if (null == game.getBoard().getBuildingAt(strategicTarget)) {</b>
<b class="nc">&nbsp;                    fireControlState.getAdditionalTargets().add(</b>
<b class="nc">&nbsp;                            getAppropriateTarget(strategicTarget));</b>
<b class="nc">&nbsp;                    sendChat(&quot;No building to target in Hex &quot; +</b>
<b class="nc">&nbsp;                             strategicTarget.toFriendlyString() +</b>
&nbsp;                             &quot;, targeting for clearing.&quot;, LogLevel.INFO);
&nbsp;                } else {
<b class="nc">&nbsp;                    fireControlState.getAdditionalTargets().add(</b>
<b class="nc">&nbsp;                            getAppropriateTarget(strategicTarget));</b>
<b class="nc">&nbsp;                    sendChat(&quot;Building in Hex &quot; +</b>
<b class="nc">&nbsp;                             strategicTarget.toFriendlyString() +</b>
&nbsp;                             &quot; designated strategic target.&quot;, LogLevel.INFO);
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Pick up on any turrets and shoot their buildings as well.
<b class="nc">&nbsp;            final Enumeration&lt;Building&gt; buildings = game.getBoard().getBuildings();</b>
<b class="nc">&nbsp;            while (buildings.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Building bldg = buildings.nextElement();</b>
<b class="nc">&nbsp;                final Enumeration&lt;Coords&gt; bldgCoords = bldg.getCoords();</b>
<b class="nc">&nbsp;                while (bldgCoords.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    final Coords coords = bldgCoords.nextElement();</b>
<b class="nc">&nbsp;                    for (final Entity entity : game.getEntitiesVector(coords,</b>
&nbsp;                                                                      true)) {
<b class="nc">&nbsp;                        final Targetable bt = getAppropriateTarget(coords);</b>
&nbsp;                        
<b class="nc">&nbsp;                        if (isEnemyGunEmplacement(entity, coords)) {</b>
<b class="nc">&nbsp;                            fireControlState.getAdditionalTargets().add(bt);</b>
<b class="nc">&nbsp;                            sendChat(&quot;Building in Hex &quot; +</b>
<b class="nc">&nbsp;                                     coords.toFriendlyString()</b>
&nbsp;                                     + &quot; designated target due to Gun Emplacement.&quot;, LogLevel.INFO);
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            //Next, collect the ID&#39;s of each potential target and store them in 
&nbsp;            // the damageMap for allocating damage during movement.
&nbsp;            //Right now, this doesn&#39;t get filled because I can&#39;t find where 
&nbsp;            // FiringPlans for potential move paths are calculated(pretty sure 
&nbsp;            // they are, though). This needs to be fixed at some point.
&nbsp;
&nbsp;            //Reset last round&#39;s damageMap
<b class="nc">&nbsp;            damageMap.clear();</b>
&nbsp;            //Now add an ID for each possible target.
<b class="nc">&nbsp;            final List&lt;Targetable&gt; potentialTargets =</b>
<b class="nc">&nbsp;                    FireControl.getAllTargetableEnemyEntities(getLocalPlayer(),</b>
<b class="nc">&nbsp;                                                              getGame(),</b>
&nbsp;                                                              fireControlState);
<b class="nc">&nbsp;            for (final Targetable target : potentialTargets) {</b>
<b class="nc">&nbsp;                damageMap.put(target.getTargetId(), 0d);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public IGame getGame() {
<b class="nc">&nbsp;        return game;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void initialize() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            if (initialized) {</b>
<b class="nc">&nbsp;                return; // no need to initialize twice</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            checkForDishonoredEnemies();</b>
<b class="nc">&nbsp;            checkForBrokenEnemies();</b>
<b class="nc">&nbsp;            refreshCrippledUnits();</b>
&nbsp;            
<b class="nc">&nbsp;            initializePathRankers();</b>
<b class="nc">&nbsp;            fireControlState = new FireControlState();</b>
<b class="nc">&nbsp;            pathRankerState = new PathRankerState();</b>
<b class="nc">&nbsp;            unitBehaviorTracker = new UnitBehavior();</b>
<b class="nc">&nbsp;            boardClusterTracker = new BoardClusterTracker();</b>
&nbsp;
&nbsp;            // Pick up any turrets and add their buildings to the strategic 
&nbsp;            // targets list.
<b class="nc">&nbsp;            final Enumeration&lt;Building&gt; buildings = getGame().getBoard()</b>
<b class="nc">&nbsp;                                                             .getBuildings();</b>
<b class="nc">&nbsp;            while (buildings.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Building bldg = buildings.nextElement();</b>
<b class="nc">&nbsp;                final Enumeration&lt;Coords&gt; bldgCoords = bldg.getCoords();</b>
<b class="nc">&nbsp;                while (bldgCoords.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    final Coords coords = bldgCoords.nextElement();</b>
<b class="nc">&nbsp;                    for (final Entity entity : game.getEntitiesVector(coords,</b>
&nbsp;                                                                      true)) {
<b class="nc">&nbsp;                        if (isEnemyGunEmplacement(entity, coords)) {</b>
<b class="nc">&nbsp;                            getStrategicBuildingTargets().add(coords);</b>
<b class="nc">&nbsp;                            sendChat(&quot;Building in Hex &quot; +</b>
<b class="nc">&nbsp;                                     coords.toFriendlyString() +</b>
&nbsp;                                     &quot; designated target due to Gun Emplacement.&quot;, LogLevel.INFO);
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            initialized = true;</b>
<b class="nc">&nbsp;            BotGeometry.debugSelfTest(this);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            getLogger().methodEnd();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Initialize the fire controls.
&nbsp;     */
&nbsp;    public void initializeFireControls() {
<b class="nc">&nbsp;        fireControls = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        FireControl fireControl = new FireControl(this);</b>
<b class="nc">&nbsp;        fireControls.put(FireControlType.Basic, fireControl);</b>
&nbsp;        
<b class="nc">&nbsp;        InfantryFireControl infantryFireControl = new InfantryFireControl(this);</b>
<b class="nc">&nbsp;        fireControls.put(FireControlType.Infantry, infantryFireControl);</b>
&nbsp;        
<b class="nc">&nbsp;        MultiTargetFireControl multiTargetFireControl = new MultiTargetFireControl(this);</b>
<b class="nc">&nbsp;        fireControls.put(FireControlType.MultiTarget, multiTargetFireControl);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initialize the possible path rankers.
&nbsp;     * Has a dependency on the fire controls being initialized.
&nbsp;     */
&nbsp;    public void initializePathRankers() {
<b class="nc">&nbsp;        initializeFireControls();</b>
&nbsp;        
<b class="nc">&nbsp;        pathRankers = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        BasicPathRanker basicPathRanker = new BasicPathRanker(this);</b>
<b class="nc">&nbsp;        basicPathRanker.setPathEnumerator(precognition.getPathEnumerator());</b>
<b class="nc">&nbsp;        pathRankers.put(PathRankerType.Basic, basicPathRanker);</b>
&nbsp;        
<b class="nc">&nbsp;        InfantryPathRanker infantryPathRanker = new InfantryPathRanker(this);</b>
<b class="nc">&nbsp;        infantryPathRanker.setPathEnumerator(precognition.getPathEnumerator());</b>
<b class="nc">&nbsp;        pathRankers.put(PathRankerType.Infantry, infantryPathRanker);</b>
&nbsp;        
<b class="nc">&nbsp;        NewtonianAerospacePathRanker newtonianAerospacePathRanker = new NewtonianAerospacePathRanker(this);</b>
<b class="nc">&nbsp;        newtonianAerospacePathRanker.setPathEnumerator(precognition.getPathEnumerator());</b>
<b class="nc">&nbsp;        pathRankers.put(PathRankerType.NewtonianAerospace, newtonianAerospacePathRanker);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Load the list of units considered crippled at the time the bot was loaded or the beginning of the turn,
&nbsp;     * whichever is the more recent.
&nbsp;     */
&nbsp;    public void refreshCrippledUnits() {
&nbsp;        // if we&#39;re not following &#39;forced withdrawal&#39; rules, there&#39;s no need for this
<b class="nc">&nbsp;        if(!getForcedWithdrawal()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // this approach is a little bit inefficient, but the running time is only O(n) where n is the number
&nbsp;        // of princess owned units, so it shouldn&#39;t be a big deal. 
<b class="nc">&nbsp;        crippledUnits.clear();</b>
&nbsp;        
<b class="nc">&nbsp;        for(Entity e : this.getEntitiesOwned()) {</b>
<b class="nc">&nbsp;            if(e.isCrippled(true)) {</b>
<b class="nc">&nbsp;                crippledUnits.add(e.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    private boolean isEnemyGunEmplacement(final Entity entity,
&nbsp;                                          final Coords coords) {
&nbsp;        // crippled gun turrets aren&#39;t worth shooting at, even if we&#39;re fighting to the death
<b class="nc">&nbsp;        return entity.hasETypeFlag(Entity.ETYPE_GUN_EMPLACEMENT)</b>
<b class="nc">&nbsp;               &amp;&amp; entity.getOwner().isEnemyOf(getLocalPlayer())</b>
<b class="nc">&nbsp;               &amp;&amp; !getStrategicBuildingTargets().contains(coords)</b>
<b class="nc">&nbsp;               &amp;&amp; !entity.isCrippled();</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isEnemyInfantry(final Entity entity,
&nbsp;                                    final Coords coords) {
&nbsp;        // crippled infantry aren&#39;t worth shooting at, even if we&#39;re fighting to the death
<b class="nc">&nbsp;        return entity.hasETypeFlag(Entity.ETYPE_INFANTRY) &amp;&amp; !entity.hasETypeFlag(Entity.ETYPE_MECHWARRIOR)</b>
<b class="nc">&nbsp;               &amp;&amp; entity.getOwner().isEnemyOf(getLocalPlayer())</b>
<b class="nc">&nbsp;               &amp;&amp; !getStrategicBuildingTargets().contains(coords)</b>
<b class="nc">&nbsp;               &amp;&amp; !entity.isCrippled();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public synchronized void die() {
<b class="nc">&nbsp;        super.die();</b>
<b class="nc">&nbsp;        if (null != precognition) {</b>
<b class="nc">&nbsp;            precognition.signalDone();</b>
<b class="nc">&nbsp;            precogThread.interrupt();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    protected void processChat(final GamePlayerChatEvent ge) {
<b class="nc">&nbsp;        chatProcessor.processChat(ge, this);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    CardinalEdge getHomeEdge(Entity entity) {
&nbsp;        // if I am crippled and using forced withdrawal rules, my home edge is the &quot;retreat&quot; edge        
<b class="nc">&nbsp;        if(entity.isCrippled(true) &amp;&amp; getBehaviorSettings().isForcedWithdrawal()) {</b>
<b class="nc">&nbsp;            if(getBehaviorSettings().getRetreatEdge() == CardinalEdge.NEAREST_OR_NONE) {</b>
<b class="nc">&nbsp;                return BoardUtilities.getClosestEdge(entity);                </b>
&nbsp;            } else {
<b class="nc">&nbsp;                return getBehaviorSettings().getRetreatEdge();</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // otherwise, return the destination edge
<b class="nc">&nbsp;        return getBehaviorSettings().getDestinationEdge();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int calculateAdjustment(final String ticks) {
&nbsp;        
<b class="fc">&nbsp;        int adjustment = 0;</b>
<b class="fc">&nbsp;        if (StringUtil.isNullOrEmpty(ticks)) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        for (final char tick : ticks.toCharArray()) {</b>
<b class="fc">&nbsp;            if (PLUS == tick) {</b>
<b class="fc">&nbsp;                adjustment++;</b>
<b class="fc">&nbsp;            } else if (MINUS == tick) {</b>
<b class="fc">&nbsp;                adjustment--;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                getLogger().warning(&quot;Invalid tick: &#39;&quot; + tick + &quot;&#39;.&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return adjustment;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void checkMoral() {
<b class="nc">&nbsp;        moralUtil.checkMoral(behaviorSettings.isForcedWithdrawal(),</b>
<b class="nc">&nbsp;                             behaviorSettings.getBraveryIndex(),</b>
<b class="nc">&nbsp;                             behaviorSettings.getSelfPreservationIndex(),</b>
<b class="nc">&nbsp;                             getLocalPlayer(),</b>
&nbsp;                             game);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    IHonorUtil getHonorUtil() {
<b class="nc">&nbsp;        return honorUtil;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Lazy-loaded calculation of the &quot;to-hit target number&quot; threshold for
&nbsp;     * spinning up a rapid fire autocannon.
&nbsp;     */
&nbsp;    public int getSpinupThreshold() {
<b class="nc">&nbsp;        if(spinupThreshold == null) {</b>
&nbsp;    	// we start spinning up the cannon at 11+ TN at highest aggression levels
&nbsp;        // dropping it down to 6+ TN at the lower aggression levels
<b class="nc">&nbsp;        	spinupThreshold = Math.min(11, Math.max(getBehaviorSettings().getHyperAggressionIndex() + 2, 6));</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return spinupThreshold;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void resetSpinupThreshold() {
<b class="fc">&nbsp;    	spinupThreshold = null;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void endOfTurnProcessing() {
<b class="nc">&nbsp;        getLogger().methodBegin();</b>
<b class="nc">&nbsp;        checkForDishonoredEnemies();</b>
<b class="nc">&nbsp;        checkForBrokenEnemies();</b>
&nbsp;        // refreshCrippledUnits should happen after checkForDishonoredEnemies, since checkForDishoneredEnemies
&nbsp;        // wants to examine the units that were considered crippled at the *beginning* of the turn and were attacked.
<b class="nc">&nbsp;        refreshCrippledUnits();</b>
<b class="nc">&nbsp;        getLogger().methodEnd();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void handlePacket(final Packet c) {
<b class="nc">&nbsp;        final StringBuilder msg = new StringBuilder(&quot;Received packet, cmd: &quot;</b>
<b class="nc">&nbsp;                                                    + c.getCommand());</b>
&nbsp;        try {
<b class="nc">&nbsp;            super.handlePacket(c);</b>
<b class="nc">&nbsp;            getPrecognition().handlePacket(c);</b>
&nbsp;        }
&nbsp;        finally {
<b class="nc">&nbsp;            getLogger().trace(msg.toString());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * sends a load game file to the server
&nbsp;     */
&nbsp;    public void sendLoadGame(final File f) {
<b class="nc">&nbsp;        precognition.resetGame();</b>
<b class="nc">&nbsp;        super.sendLoadGame(f);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    protected void disconnected() {
<b class="nc">&nbsp;        if (null != precognition) {</b>
<b class="nc">&nbsp;            precognition.signalDone();</b>
<b class="nc">&nbsp;            precogThread.interrupt();</b>
&nbsp;        }
<b class="nc">&nbsp;        super.disconnected();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    int getHighestEnemyInitiativeId() {
<b class="nc">&nbsp;        int highestEnemyInitiativeBonus = -1;</b>
<b class="nc">&nbsp;        int highestEnemyInitiativeId = -1;</b>
<b class="nc">&nbsp;        for (final Entity entity : getEnemyEntities()) {</b>
<b class="nc">&nbsp;            final int initBonus = entity.getHQIniBonus() +</b>
<b class="nc">&nbsp;                                  entity.getQuirkIniBonus();</b>
<b class="nc">&nbsp;            if (initBonus &gt; highestEnemyInitiativeBonus) {</b>
<b class="nc">&nbsp;                highestEnemyInitiativeBonus = initBonus;</b>
<b class="nc">&nbsp;                highestEnemyInitiativeId = entity.getId();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return highestEnemyInitiativeId;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function to perform some modifications to a given path.
&nbsp;     * Intended to happen after we pick the best path. 
&nbsp;     * @param path The ranked path to process
&nbsp;     * @return Altered move path
&nbsp;     */
&nbsp;    private MovePath performPathPostProcessing(final RankedPath path) {
<b class="nc">&nbsp;        return performPathPostProcessing(path.getPath(), path.getExpectedDamage());</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function to perform some modifications to a given path.
&nbsp;     * @param path The move path to process
&nbsp;     * @param expectedDamage The damage expected to be done by the unit as a result of the path
&nbsp;     * @return Altered move path
&nbsp;     */
&nbsp;    private MovePath performPathPostProcessing(MovePath path, double expectedDamage) {
<b class="nc">&nbsp;        MovePath retval = path;</b>
<b class="nc">&nbsp;        evadeIfNotFiring(retval, expectedDamage &gt;= 0);</b>
<b class="nc">&nbsp;        turnOnSearchLight(retval, expectedDamage &gt;= 0);</b>
<b class="nc">&nbsp;        unloadTransportedInfantry(retval);</b>
<b class="nc">&nbsp;        unjamRAC(retval);</b>
&nbsp;        
&nbsp;        // if we are using vector movement, there&#39;s a whole bunch of post-processing that happens to
&nbsp;        // aircraft flight paths when a player does it, so we apply it here.
<b class="nc">&nbsp;        if(path.getEntity().isAero() || (path.getEntity() instanceof EjectedCrew &amp;&amp; path.getEntity().isSpaceborne())) {</b>
<b class="nc">&nbsp;            retval = SharedUtility.moveAero(retval, null);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return retval;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function that appends an unjam RAC command to the end of a qualifying path.
&nbsp;     * @param path The path to process.
&nbsp;     */
&nbsp;    private void unjamRAC(MovePath path) { 
<b class="nc">&nbsp;        if(path.getEntity().canUnjamRAC() &amp;&amp; </b>
<b class="nc">&nbsp;                (path.getMpUsed() &lt;= path.getEntity().getWalkMP()) &amp;&amp;</b>
<b class="nc">&nbsp;                !path.isJumping()) {</b>
<b class="nc">&nbsp;            path.addStep(MoveStepType.UNJAM_RAC);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function that insinuates an &quot;evade&quot; step for aircraft that will not be shooting.
&nbsp;     * @param path The path to process
&nbsp;     */
&nbsp;    private void evadeIfNotFiring(MovePath path, boolean possibleToInflictDamage) {
<b class="nc">&nbsp;        Entity pathEntity = path.getEntity();</b>
&nbsp;        
&nbsp;        // we cannot evade if we are out of control
<b class="nc">&nbsp;        if(pathEntity.isAero() &amp;&amp; pathEntity.isAirborne() &amp;&amp; ((IAero) pathEntity).isOutControlTotal()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if we&#39;re an airborne aircraft
&nbsp;        // and we&#39;re not going to do any damage anyway
&nbsp;        // and we can do so without causing a PSR
&nbsp;        // then evade
<b class="nc">&nbsp;        if(pathEntity.isAirborne() &amp;&amp;</b>
&nbsp;           !possibleToInflictDamage &amp;&amp;
<b class="nc">&nbsp;           (path.getMpUsed() &lt;= AeroPathUtil.calculateMaxSafeThrust((IAero) path.getEntity()) - 2)) {</b>
<b class="nc">&nbsp;            path.addStep(MoveStepType.EVADE);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Turn on the searchlight if we expect to be shooting at something and it&#39;s dark out
&nbsp;     * @param path Path being considered
&nbsp;     * @param possibleToInflictDamage Whether we expect to be shooting at something.
&nbsp;     */
&nbsp;    private void turnOnSearchLight(MovePath path, boolean possibleToInflictDamage) {
<b class="nc">&nbsp;        Entity pathEntity = path.getEntity();</b>
<b class="nc">&nbsp;        if(possibleToInflictDamage &amp;&amp;</b>
<b class="nc">&nbsp;                pathEntity.hasSpotlight() &amp;&amp; </b>
<b class="nc">&nbsp;                !pathEntity.isUsingSpotlight() &amp;&amp;</b>
<b class="nc">&nbsp;                (path.getGame().getPlanetaryConditions().getLight() &gt;= PlanetaryConditions.L_FULL_MOON)) {</b>
<b class="nc">&nbsp;            path.addStep(MoveStepType.SEARCHLIGHT);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function that adds an &quot;unload&quot; step for units that are transporting infantry
&nbsp;     * if the conditions for unloading are favorable.
&nbsp;     * 
&nbsp;     * Infantry unloading logic is different from, for example, hot-dropping mechs or launching aerospace fighters,
&nbsp;     * so we handle it separately.
&nbsp;     * @param path The path to modify
&nbsp;     */
&nbsp;    private void unloadTransportedInfantry(MovePath path) {
&nbsp;        // if my objective is to cross the board, even though it&#39;s tempting, I won&#39;t be leaving the infantry
&nbsp;        // behind. They&#39;re not that good at screening against high speed pursuit anyway.
<b class="nc">&nbsp;        if(getBehaviorSettings().shouldGoHome()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity movingEntity = path.getEntity();</b>
<b class="nc">&nbsp;        Coords pathEndpoint = path.getFinalCoords();</b>
<b class="nc">&nbsp;        Targetable closestEnemy = getPathRanker(movingEntity).findClosestEnemy(movingEntity, pathEndpoint, getGame(), false);</b>
&nbsp;
&nbsp;        // if there are no enemies on the board, then we&#39;re not unloading anything.
&nbsp;        // infantry can&#39;t clear hexes, so let&#39;s not use th
<b class="nc">&nbsp;        if((null == closestEnemy) || (closestEnemy.getTargetType() == Targetable.TYPE_HEX_CLEAR)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        int distanceToClosestEnemy = pathEndpoint.distance(closestEnemy.getPosition());</b>
&nbsp;        
&nbsp;        // loop through all entities carried by the current entity
<b class="nc">&nbsp;        for(Transporter transport : movingEntity.getTransports()) {</b>
<b class="nc">&nbsp;            for(Entity loadedEntity : transport.getLoadedUnits()) {</b>
&nbsp;                // there&#39;s really no good reason for Princess to disconnect trailers.
&nbsp;                // Let&#39;s skip those for now. We don&#39;t want to create a bogus &#39;unload&#39; step for them anyhow.
<b class="nc">&nbsp;                if (loadedEntity.isTrailer() &amp;&amp; loadedEntity.getTowedBy() != Entity.NONE) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // favorable conditions include: 
&nbsp;                // - the loaded entity should be able to enter the current terrain
&nbsp;                // - the loaded entity should be within max weapons range + movement range of an enemy
&nbsp;                // - unloading the loaded entity cannot violate stacking limits
&nbsp;                // - only one unit 
&nbsp;                
&nbsp;                // this condition is a simple check that we&#39;re not unloading infantry into deep space
&nbsp;                // or into lava or some other such nonsense
<b class="nc">&nbsp;                boolean unloadFatal = loadedEntity.isBoardProhibited(getGame().getBoard().getType()) ||</b>
<b class="nc">&nbsp;                        loadedEntity.isLocationProhibited(pathEndpoint);</b>
&nbsp;                
&nbsp;                // Unloading a unit may sometimes cause a stacking violation, take that into account when planning
<b class="nc">&nbsp;                boolean unloadIllegal = Compute.stackingViolation(getGame(), loadedEntity, pathEndpoint, movingEntity) != null;</b>
&nbsp;                
&nbsp;                // this is a primitive condition that checks whether we&#39;re within &quot;engagement range&quot; of an enemy
&nbsp;                // where &quot;engagement range&quot; is defined as the maximum range of our weapons plus our walking movement
<b class="nc">&nbsp;                boolean inEngagementRange = loadedEntity.getWalkMP() + getMaxWeaponRange(loadedEntity) &gt;= distanceToClosestEnemy;</b>
&nbsp;                
<b class="nc">&nbsp;                if(!unloadFatal &amp;&amp; !unloadIllegal &amp;&amp; inEngagementRange) {</b>
<b class="nc">&nbsp;                    path.addStep(MoveStepType.UNLOAD, loadedEntity, pathEndpoint);</b>
<b class="nc">&nbsp;                    return; // we can only unload one infantry unit per hex per turn, so once we&#39;ve unloaded, we&#39;re done. </b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public void sendChat(final String message,
&nbsp;                         final LogLevel logLevel) {
<b class="nc">&nbsp;        if (getVerbosity().willLog(logLevel)) {</b>
<b class="nc">&nbsp;            super.sendChat(message);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Override for the &#39;receive entity update&#39; handler
&nbsp;     * Updates internal state in addition to base client functionality
&nbsp;     */
&nbsp;    @Override    
&nbsp;    public void receiveEntityUpdate(Packet c) {
<b class="nc">&nbsp;        super.receiveEntityUpdate(c);</b>
<b class="nc">&nbsp;        Entity entity = (Entity) c.getObject(1);</b>
<b class="nc">&nbsp;        updateEntityState(entity);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
