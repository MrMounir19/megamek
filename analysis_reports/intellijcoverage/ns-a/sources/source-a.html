


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FormationType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ratgenerator</a>
</div>

<h1>Coverage Summary for Class: FormationType (megamek.client.ratgenerator)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FormationType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/165)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1149)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FormationType$Constraint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormationType$CountConstraint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormationType$GroupingConstraint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormationType$MaxCountConstraint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormationType$MaxPercentConstraint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormationType$PercentConstraint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/191)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1191)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * 
&nbsp; */
&nbsp;package megamek.client.ratgenerator;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.IntSummaryStatistics;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.function.BiFunction;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.EntityMovementMode;
&nbsp;import megamek.common.EntityWeightClass;
&nbsp;import megamek.common.EquipmentMode;
&nbsp;import megamek.common.EquipmentType;
&nbsp;import megamek.common.MechSummary;
&nbsp;import megamek.common.MiscType;
&nbsp;import megamek.common.UnitRole;
&nbsp;import megamek.common.UnitRoleHandler;
&nbsp;import megamek.common.UnitType;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.weapons.artillery.ArtilleryWeapon;
&nbsp;import megamek.common.weapons.autocannons.ACWeapon;
&nbsp;import megamek.common.weapons.autocannons.LBXACWeapon;
&nbsp;import megamek.common.weapons.autocannons.UACWeapon;
&nbsp;import megamek.common.weapons.lrms.LRMWeapon;
&nbsp;import megamek.common.weapons.srms.SRMWeapon;
&nbsp;import megamek.common.weapons.tag.TAGWeapon;
&nbsp;
&nbsp;/**
&nbsp; * Campaign Operations rules for force generation.
&nbsp; * 
&nbsp; * @author Neoancient
&nbsp; *
&nbsp; */
&nbsp;public class FormationType {
&nbsp;    
&nbsp;    public static final int FLAG_MEK = 1 &lt;&lt; UnitType.MEK;
&nbsp;    public static final int FLAG_TANK = 1 &lt;&lt; UnitType.TANK;
&nbsp;    public static final int FLAG_BATTLE_ARMOR = 1 &lt;&lt; UnitType.BATTLE_ARMOR;
&nbsp;    public static final int FLAG_INFANTRY = 1 &lt;&lt; UnitType.INFANTRY;
&nbsp;    public static final int FLAG_PROTOMEK = 1 &lt;&lt; UnitType.PROTOMEK;
&nbsp;    public static final int FLAG_VTOL = 1 &lt;&lt; UnitType.VTOL;
&nbsp;    public static final int FLAG_NAVAL = 1 &lt;&lt; UnitType.NAVAL;
&nbsp;    
&nbsp;    public static final int FLAG_CONV_FIGHTER = 1 &lt;&lt; UnitType.CONV_FIGHTER;
&nbsp;    public static final int FLAG_AERO = 1 &lt;&lt; UnitType.AERO;
&nbsp;    public static final int FLAG_SMALL_CRAFT = 1 &lt;&lt; UnitType.SMALL_CRAFT;
&nbsp;    public static final int FLAG_DROPSHIP = 1 &lt;&lt; UnitType.DROPSHIP;
&nbsp;
&nbsp;    public static final int FLAG_GROUND = FLAG_MEK | FLAG_TANK | FLAG_BATTLE_ARMOR | FLAG_INFANTRY
&nbsp;            | FLAG_PROTOMEK | FLAG_VTOL | FLAG_NAVAL;
&nbsp;    public static final int FLAG_GROUND_NO_LIGHT = FLAG_MEK | FLAG_TANK | FLAG_BATTLE_ARMOR
&nbsp;            | FLAG_PROTOMEK | FLAG_NAVAL;
&nbsp;    public static final int FLAG_FIGHTER = FLAG_CONV_FIGHTER | FLAG_AERO;
&nbsp;    public static final int FLAG_AIR = FLAG_CONV_FIGHTER | FLAG_AERO | FLAG_SMALL_CRAFT
&nbsp;            | FLAG_DROPSHIP;
&nbsp;    public static final int FLAG_VEHICLE = FLAG_TANK | FLAG_NAVAL | FLAG_VTOL;
&nbsp;    public static final int FLAG_ALL = FLAG_GROUND | FLAG_AIR;
&nbsp;    
<b class="nc">&nbsp;    private static HashMap&lt;String,FormationType&gt; allFormationTypes = null;</b>
&nbsp;    public static FormationType getFormationType(String key) {
<b class="nc">&nbsp;        if (allFormationTypes == null) {</b>
<b class="nc">&nbsp;            createFormationTypes();</b>
&nbsp;        }
<b class="nc">&nbsp;        return allFormationTypes.get(key);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public static Collection&lt;FormationType&gt; getAllFormations() {
<b class="nc">&nbsp;        if (allFormationTypes == null) {</b>
<b class="nc">&nbsp;            createFormationTypes();</b>
&nbsp;        }
<b class="nc">&nbsp;        return allFormationTypes.values();</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected FormationType(String name) {
<b class="nc">&nbsp;        this(name, name);</b>
&nbsp;    }
&nbsp;    
<b class="nc">&nbsp;    protected FormationType(String name, String category) {</b>
<b class="nc">&nbsp;        this.name = name;</b>
<b class="nc">&nbsp;        this.category = category;</b>
&nbsp;    }
&nbsp;    
<b class="nc">&nbsp;    private String name = &quot;Support&quot;;</b>
<b class="nc">&nbsp;    private String category = null;</b>
<b class="nc">&nbsp;    private int allowedUnitTypes = FLAG_GROUND;</b>
&nbsp;    // Some formation types allow units not normally generated for general combat roles (e.g. artillery, cargo)  
<b class="nc">&nbsp;    private EnumSet&lt;MissionRole&gt; missionRoles = EnumSet.noneOf(MissionRole.class);</b>
&nbsp;    // If all units in the force have this role, other constraints can be ignored.
<b class="nc">&nbsp;    private UnitRole idealRole = UnitRole.UNDETERMINED;</b>
<b class="nc">&nbsp;    private String exclusiveFaction = null;</b>
&nbsp;    
<b class="nc">&nbsp;    private int minWeightClass = 0;</b>
<b class="nc">&nbsp;    private int maxWeightClass = EntityWeightClass.WEIGHT_COLOSSAL;</b>
&nbsp;    // Used as a filter when generating units
<b class="nc">&nbsp;    private Predicate&lt;MechSummary&gt; mainCriteria = ms -&gt; true;</b>
&nbsp;    // Additional criteria that have to be fulfilled by a portion of the force
<b class="nc">&nbsp;    private List&lt;Constraint&gt; otherCriteria = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private GroupingConstraint groupingCriteria = null;</b>
&nbsp;    
&nbsp;    // Provide values for the various criteria for reporting purposes
<b class="nc">&nbsp;    private String mainDescription = null;</b>
<b class="nc">&nbsp;    private Map&lt;String,Function&lt;MechSummary,?&gt;&gt; reportMetrics = new HashMap&lt;&gt;();</b>
&nbsp;    
&nbsp;    public String getName() {
<b class="nc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public String getCategory() {
<b class="nc">&nbsp;        return category;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getAllowedUnitTypes() {
<b class="nc">&nbsp;        return allowedUnitTypes;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public boolean isAllowedUnitType(int ut) {
<b class="nc">&nbsp;        return (allowedUnitTypes &amp; (1 &lt;&lt; ut)) != 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public boolean isGround() {
<b class="nc">&nbsp;        return (allowedUnitTypes &amp; FLAG_AERO) == 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public UnitRole getIdealRole() {
<b class="nc">&nbsp;        return idealRole;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public String getExclusiveFaction() {
<b class="nc">&nbsp;        return exclusiveFaction;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public String getNameWithFaction() {
<b class="nc">&nbsp;        return exclusiveFaction == null? name : name + &quot; (&quot; + exclusiveFaction + &quot;)&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMinWeightClass() {
<b class="nc">&nbsp;        return minWeightClass;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMaxWeightClass() {
<b class="nc">&nbsp;        return maxWeightClass;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Set&lt;MissionRole&gt; getMissionRoles() {
<b class="nc">&nbsp;        return missionRoles;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Predicate&lt;MechSummary&gt; getMainCriteria() {
<b class="nc">&nbsp;        return mainCriteria;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public String getMainDescription() {
<b class="nc">&nbsp;        return mainDescription;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Iterator&lt;Constraint&gt; getOtherCriteria() {
<b class="nc">&nbsp;        return otherCriteria.iterator();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getOtherCriteriaCount() {
<b class="nc">&nbsp;        return otherCriteria.size();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Constraint getConstraint(int index) {
<b class="nc">&nbsp;        return otherCriteria.get(index);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public GroupingConstraint getGroupingCriteria() {
<b class="nc">&nbsp;        return groupingCriteria;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getReportMetricsSize() {
<b class="nc">&nbsp;        return reportMetrics.size();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Iterator&lt;String&gt; getReportMetricKeys() {
<b class="nc">&nbsp;        return reportMetrics.keySet().iterator();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Function&lt;MechSummary,?&gt; getReportMetric(String key) {
<b class="nc">&nbsp;        return reportMetrics.get(key);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static Set&lt;MissionRole&gt; getMissionRoles(MechSummary ms) {
<b class="nc">&nbsp;        ModelRecord mRec = RATGenerator.getInstance().getModelRecord(ms.getName());</b>
<b class="nc">&nbsp;        return mRec == null? EnumSet.noneOf(MissionRole.class) : mRec.getRoles();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static IntSummaryStatistics damageAtRangeStats(MechSummary ms, int range) {
<b class="nc">&nbsp;        List&lt;Integer&gt; retVal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; ms.getEquipmentNames().size(); i++) {</b>
<b class="nc">&nbsp;            if (EquipmentType.get(ms.getEquipmentNames().get(i)) instanceof WeaponType) {</b>
<b class="nc">&nbsp;                final WeaponType weapon = (WeaponType)EquipmentType.get(ms.getEquipmentNames().get(i));</b>
<b class="nc">&nbsp;                if (weapon.getLongRange() &lt; range) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                int damage = 0;</b>
<b class="nc">&nbsp;                if (weapon.getAmmoType() != AmmoType.T_NA) {</b>
<b class="nc">&nbsp;                    Optional&lt;EquipmentType&gt; ammo = ms.getEquipmentNames().stream()</b>
<b class="nc">&nbsp;                        .map(name -&gt; EquipmentType.get(name))</b>
<b class="nc">&nbsp;                        .filter(eq -&gt; eq instanceof AmmoType</b>
<b class="nc">&nbsp;                                &amp;&amp; ((AmmoType)eq).getAmmoType() == weapon.getAmmoType()</b>
<b class="nc">&nbsp;                                &amp;&amp; ((AmmoType)eq).getRackSize() == weapon.getRackSize())</b>
<b class="nc">&nbsp;                        .findFirst();</b>
<b class="nc">&nbsp;                    if (ammo.isPresent()) {</b>
<b class="nc">&nbsp;                        damage = ((AmmoType)ammo.get()).getDamagePerShot()</b>
<b class="nc">&nbsp;                                * Math.max(1, ((AmmoType)ammo.get()).getRackSize());</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    damage = weapon.getDamage(range);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                    for (int j = 0; j &lt; ms.getEquipmentQuantities().get(i); j++) {</b>
<b class="nc">&nbsp;                        retVal.add(damage);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return retVal.stream().mapToInt(Integer::intValue).summaryStatistics();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static long getDamageAtRange(MechSummary ms, int range) {
<b class="nc">&nbsp;        return Math.max(0, damageAtRangeStats(ms, range).getSum());</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static long getSingleWeaponDamageAtRange(MechSummary ms, int range) {
<b class="nc">&nbsp;        return Math.max(0, damageAtRangeStats(ms, range).getMax());</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static int getNetworkMask(MechSummary ms) {
<b class="nc">&nbsp;        ModelRecord mRec = RATGenerator.getInstance().getModelRecord(ms.getName());</b>
<b class="nc">&nbsp;        return mRec == null? ModelRecord.NETWORK_NONE : mRec.getNetworkMask();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public List&lt;MechSummary&gt; generateFormation(UnitTable.Parameters params, int numUnits,
&nbsp;            int networkMask, boolean bestEffort) {
<b class="nc">&nbsp;        List&lt;UnitTable.Parameters&gt; p = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        p.add(params);</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; n = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        n.add(numUnits);</b>
<b class="nc">&nbsp;        return generateFormation(p, n, networkMask, bestEffort, -1, -1);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public List&lt;MechSummary&gt; generateFormation(List&lt;UnitTable.Parameters&gt; params, List&lt;Integer&gt; numUnits,
&nbsp;            int networkMask, boolean bestEffort) {
<b class="nc">&nbsp;        return generateFormation(params, numUnits, networkMask, bestEffort, -1, -1);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public List&lt;MechSummary&gt; generateFormation(List&lt;UnitTable.Parameters&gt; params, List&lt;Integer&gt; numUnits,
&nbsp;            int networkMask, boolean bestEffort, int groupSize, int nGroups) {
<b class="nc">&nbsp;        if (params.size() != numUnits.size() || params.isEmpty()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Formation parameter list and numUnit list must have the same number of elements.&quot;);</b>
&nbsp;        }
&nbsp;        final GroupingConstraint useGrouping;
<b class="nc">&nbsp;        if (null == groupingCriteria) {</b>
<b class="nc">&nbsp;            useGrouping = null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            useGrouping = groupingCriteria.copy();</b>
<b class="nc">&nbsp;            if (groupSize &gt; 0) {</b>
<b class="nc">&nbsp;                useGrouping.groupSize = groupSize;</b>
<b class="nc">&nbsp;                useGrouping.numGroups = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (nGroups &gt; 0) {</b>
<b class="nc">&nbsp;                useGrouping.numGroups =  nGroups;</b>
<b class="nc">&nbsp;                useGrouping.groupSize = 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        List&lt;Integer&gt; wcs = IntStream.rangeClosed(minWeightClass,</b>
<b class="nc">&nbsp;                Math.min(maxWeightClass, EntityWeightClass.WEIGHT_SUPER_HEAVY))</b>
<b class="nc">&nbsp;                .mapToObj(Integer::valueOf)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; airWcs = wcs.stream().filter(wc -&gt; wc &lt; EntityWeightClass.WEIGHT_ASSAULT)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList()); </b>
<b class="nc">&nbsp;        params.forEach(p -&gt; {</b>
<b class="nc">&nbsp;            p.getRoles().addAll(missionRoles);</b>
<b class="nc">&nbsp;            p.setWeightClasses(p.getUnitType() &lt; UnitType.CONV_FIGHTER ? wcs : airWcs);</b>
&nbsp;        });
<b class="nc">&nbsp;        List&lt;UnitTable&gt; tables = params.stream().map(UnitTable::findTable).collect(Collectors.toList());</b>
&nbsp;        //If there are any parameter sets that cannot generate a table, return an empty list. 
<b class="nc">&nbsp;        if (!tables.stream().allMatch(UnitTable::hasUnits) &amp;&amp; !bestEffort) {</b>
<b class="nc">&nbsp;            return new ArrayList&lt;&gt;();</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* Check whether we have vees or infantry that do not have the movement mode(s) set. If so,
&nbsp;         * we will attempt to conform them to a single type. Any that are set are ignored;
&nbsp;         * there is no attempt to conform to mode already in the force. If they are intended
&nbsp;         * to conform, they ought to be set.
&nbsp;         */
<b class="nc">&nbsp;        List&lt;Integer&gt; undeterminedVees = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; undeterminedInfantry = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; params.size(); i++) {</b>
<b class="nc">&nbsp;            if (params.get(i).getMovementModes().isEmpty()) {</b>
<b class="nc">&nbsp;                if (params.get(i).getUnitType() == UnitType.TANK) {</b>
<b class="nc">&nbsp;                    undeterminedVees.add(i);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (params.get(i).getUnitType() == UnitType.INFANTRY) {</b>
<b class="nc">&nbsp;                    undeterminedInfantry.add(i);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        /* Look at the table for each group of parameters and determine the motive type
&nbsp;         * ratio, then weight those values according to the number of units using those
&nbsp;         * parameters.
&nbsp;         */
<b class="nc">&nbsp;        Map&lt;String,Integer&gt; veeMap = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Map&lt;String,Integer&gt; infMap = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; undeterminedVees.size(); i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; tables.get(i).getNumEntries(); j++) {</b>
<b class="nc">&nbsp;                if (tables.get(i).getMechSummary(j) != null) {</b>
<b class="nc">&nbsp;                    veeMap.merge(tables.get(i).getMechSummary(j).getUnitSubType(),</b>
<b class="nc">&nbsp;                            tables.get(i).getEntryWeight(j) * numUnits.get(i), Integer::sum);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; undeterminedInfantry.size(); i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; tables.get(i).getNumEntries(); j++) {</b>
<b class="nc">&nbsp;                if (tables.get(i).getMechSummary(j) != null) {</b>
<b class="nc">&nbsp;                    infMap.merge(tables.get(i).getMechSummary(j).getUnitSubType(),</b>
<b class="nc">&nbsp;                            tables.get(i).getEntryWeight(j) * numUnits.get(i), Integer::sum);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        /* Order modes in a way that those modes that are better represented are more likely to
&nbsp;         * be attempted first.
&nbsp;         */
<b class="nc">&nbsp;        List&lt;String&gt; veeModeAttemptOrder = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;String&gt; infModeAttemptOrder = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        while (!veeMap.isEmpty()) {</b>
<b class="nc">&nbsp;            int total = veeMap.values().stream().mapToInt(Integer::intValue).sum();</b>
<b class="nc">&nbsp;            int r = Compute.randomInt(total);</b>
<b class="nc">&nbsp;            String mode = &quot;Tracked&quot;;</b>
<b class="nc">&nbsp;            for (String m : veeMap.keySet()) {</b>
<b class="nc">&nbsp;                if (r &lt; veeMap.get(m)) {</b>
<b class="nc">&nbsp;                    mode = m;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r -= veeMap.get(m);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            veeModeAttemptOrder.add(mode);</b>
<b class="nc">&nbsp;            veeMap.remove(mode);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        while (!infMap.isEmpty()) {</b>
<b class="nc">&nbsp;            int total = infMap.values().stream().mapToInt(Integer::intValue).sum();</b>
<b class="nc">&nbsp;            int r = Compute.randomInt(total);</b>
<b class="nc">&nbsp;            String mode = &quot;Leg&quot;;</b>
<b class="nc">&nbsp;            for (String m : infMap.keySet()) {</b>
<b class="nc">&nbsp;                if (r &lt; infMap.get(m)) {</b>
<b class="nc">&nbsp;                    mode = m;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r -= infMap.get(m);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            infModeAttemptOrder.add(mode);</b>
<b class="nc">&nbsp;            infMap.remove(mode);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /* if there are no units of a given type, we want to make sure we have at least one iteration */
<b class="nc">&nbsp;        if (veeModeAttemptOrder.isEmpty() &amp;&amp; !infModeAttemptOrder.isEmpty()) {</b>
<b class="nc">&nbsp;            veeModeAttemptOrder.add(&quot;Tracked&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (infModeAttemptOrder.isEmpty() &amp;&amp; !veeModeAttemptOrder.isEmpty()) {</b>
<b class="nc">&nbsp;            infModeAttemptOrder.add(&quot;Leg&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (String veeMode : veeModeAttemptOrder) {</b>
<b class="nc">&nbsp;            for (String infMode : infModeAttemptOrder) {</b>
<b class="nc">&nbsp;                List&lt;UnitTable.Parameters&gt; tempParams = params.stream().map(UnitTable.Parameters::copy)</b>
<b class="nc">&nbsp;                        .collect(Collectors.toList());</b>
<b class="nc">&nbsp;                for (int index : undeterminedVees) {</b>
<b class="nc">&nbsp;                    tempParams.get(index).getMovementModes().add(EntityMovementMode.getMode(veeMode));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (int index : undeterminedInfantry) {</b>
<b class="nc">&nbsp;                    tempParams.get(index).getMovementModes().add(EntityMovementMode.getMode(infMode));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                List&lt;MechSummary&gt; list = generateFormation(tempParams, numUnits, networkMask, false);</b>
<b class="nc">&nbsp;                if (!list.isEmpty()) {</b>
<b class="nc">&nbsp;                    return list;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        /* If we cannot meet all criteria with a specific motive type, try without respect to motive type */
&nbsp;        
<b class="nc">&nbsp;        int cUnits = (int)numUnits.stream().mapToInt(Integer::intValue).sum();</b>
&nbsp;
&nbsp;        /* Simple case: all units have the same requirements. */
<b class="nc">&nbsp;        if (otherCriteria.isEmpty() &amp;&amp; useGrouping == null</b>
&nbsp;                &amp;&amp; networkMask == ModelRecord.NETWORK_NONE) {
<b class="nc">&nbsp;            List&lt;MechSummary&gt; retVal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; params.size(); i++) {</b>
<b class="nc">&nbsp;                retVal.addAll(tables.get(i).generateUnits(numUnits.get(i),</b>
<b class="nc">&nbsp;                        ms -&gt; mainCriteria.test(ms)));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (retVal.size() &lt; cUnits) {</b>
<b class="nc">&nbsp;                List&lt;MechSummary&gt; matchRole = tryIdealRole(params, numUnits);</b>
<b class="nc">&nbsp;                if (matchRole != null) {</b>
<b class="nc">&nbsp;                    return matchRole;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return retVal;</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* Simple case: single set of parameters and single additional criterion. */
<b class="nc">&nbsp;        if (params.size() == 1 &amp;&amp; otherCriteria.size() == 1 &amp;&amp; useGrouping == null</b>
&nbsp;                &amp;&amp; networkMask == ModelRecord.NETWORK_NONE) {
<b class="nc">&nbsp;            List&lt;MechSummary&gt; retVal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            retVal.addAll(tables.get(0).generateUnits(otherCriteria.get(0).getMinimum(numUnits.get(0)),</b>
<b class="nc">&nbsp;                    ms -&gt; mainCriteria.test(ms) &amp;&amp; otherCriteria.get(0).criterion.test(ms)));</b>
<b class="nc">&nbsp;            if (retVal.size() &lt; otherCriteria.get(0).getMinimum(numUnits.get(0))) {</b>
<b class="nc">&nbsp;                List&lt;MechSummary&gt; onRole = tryIdealRole(params, numUnits);</b>
<b class="nc">&nbsp;                if (onRole != null) {</b>
<b class="nc">&nbsp;                    return onRole;</b>
<b class="nc">&nbsp;                } else if (!bestEffort) {</b>
<b class="nc">&nbsp;                    return new ArrayList&lt;&gt;();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (retVal.size() &gt;= otherCriteria.get(0).getMinimum(numUnits.get(0)) || bestEffort) {</b>
<b class="nc">&nbsp;                retVal.addAll(tables.get(0).generateUnits(numUnits.get(0) - retVal.size(),</b>
<b class="nc">&nbsp;                        ms -&gt; mainCriteria.test(ms)));</b>
&nbsp;            }
<b class="nc">&nbsp;            return retVal;</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* If a network is indicated, we decide which units are part of the network (usually
&nbsp;         * all, but not necessarily) and which combination to use, then assign one of them
&nbsp;         * to the master role if any. A company command lance has two configuration options:
&nbsp;         * a unit with two masters, or two master and two slaves.
&nbsp;         */
<b class="nc">&nbsp;        int numNetworked = 0;</b>
<b class="nc">&nbsp;        int numMasters = 0;</b>
<b class="nc">&nbsp;        int altNumMasters = 0;</b>
<b class="nc">&nbsp;        int masterType = ModelRecord.NETWORK_NONE;</b>
<b class="nc">&nbsp;        int slaveType = ModelRecord.NETWORK_NONE;</b>
<b class="nc">&nbsp;        int validNetworkUnits = FLAG_MEK | FLAG_VEHICLE | FLAG_BATTLE_ARMOR;</b>
&nbsp;        
<b class="nc">&nbsp;        if ((networkMask &amp; ModelRecord.NETWORK_C3_MASTER) != 0) {</b>
<b class="nc">&nbsp;            numNetworked = 4;</b>
<b class="nc">&nbsp;            numMasters = 1;</b>
<b class="nc">&nbsp;            masterType = networkMask | (networkMask &amp; ModelRecord.NETWORK_BOOSTED);</b>
<b class="nc">&nbsp;            slaveType = ModelRecord.NETWORK_C3_SLAVE | (networkMask &amp; ModelRecord.NETWORK_BOOSTED);</b>
<b class="nc">&nbsp;            if ((networkMask &amp; ModelRecord.NETWORK_COMPANY_COMMAND) != 0) {</b>
<b class="nc">&nbsp;                altNumMasters = 2;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if ((networkMask &amp; ModelRecord.NETWORK_C3I) != 0) {</b>
<b class="nc">&nbsp;            numNetworked = 6;</b>
<b class="nc">&nbsp;            numMasters = 0;</b>
<b class="nc">&nbsp;            slaveType = ModelRecord.NETWORK_C3I;</b>
&nbsp;            /* This mask is also used for naval C3 */
<b class="nc">&nbsp;            validNetworkUnits |= FLAG_SMALL_CRAFT | FLAG_DROPSHIP;</b>
<b class="nc">&nbsp;        } else if ((networkMask &amp; ModelRecord.NETWORK_NOVA) != 0) {</b>
<b class="nc">&nbsp;            numNetworked = 3;</b>
<b class="nc">&nbsp;            numMasters = 0;</b>
<b class="nc">&nbsp;            slaveType = ModelRecord.NETWORK_NOVA;</b>
&nbsp;        }
<b class="nc">&nbsp;        int networkEligible = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; params.size(); i++) {</b>
<b class="nc">&nbsp;        	if ((validNetworkUnits &amp; (1 &lt;&lt; params.get(i).getUnitType())) != 0) {</b>
<b class="nc">&nbsp;        		networkEligible += numUnits.get(i);</b>
&nbsp;        	}
&nbsp;        }
<b class="nc">&nbsp;        if (numNetworked &gt; networkEligible) {</b>
<b class="nc">&nbsp;        	numNetworked = networkEligible;</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* General case:
&nbsp;         * Select randomly from all unique combinations of the various criteria. Each combination
&nbsp;         * is represented by a Map&lt;Integer,Integer in which the various criteria are encoded as the keys
&nbsp;         * and the value mapped to the index is the number of units that must fulfill those criteria.
&nbsp;         * The lowest order bits map to otherCriteria, one bit for each constraint. These are built
&nbsp;         * by shifting left for each new one added, so the one at index 0 is the leftmost bit of this
&nbsp;         * section. A 1 indicates that the number of units at that index must meet the constraint, while
&nbsp;         * a 0 means the constraint is not tested, and a unit may or may not fulfill it.
&nbsp;         * Example: if otherCriteria.size() == 3, then the value of combinations[6] is the number of
&nbsp;         * units that must meet the first two constraints (110), while combinations[7] must meet all
&nbsp;         * three and combinations[0] need not meet any.
&nbsp;         * 
&nbsp;         * The next three bits indicate C3 network requirements. The lowest order is the number that
&nbsp;         * must have a C3 slave, C3i, NC3, or Nova, depending on the value of networkMask. The middle bit
&nbsp;         * is the number of required C3 masters, and the highest bit is the number of dual-C3M units.
&nbsp;         * Note that only one of these three bits can be set; while a unit can have a C3M and a C3S,
&nbsp;         * only one can fulfill its role in the network.
&nbsp;         * 
&nbsp;         *  The highest order section is the unit type. Each element of the params list has one
&nbsp;         *  bit, beginning with the lowest order bit at index 0. As with networks, only one 
&nbsp;         *  bit in this section can be set.
&nbsp;         */
&nbsp;        
&nbsp;        do {
&nbsp;	        List&lt;Map&lt;Integer,Integer&gt;&gt; combinations;
&nbsp;	        /* We can get here with an empty otherCriteria if there is a groupingConstraint,
&nbsp;	         * which is the case with the Order formation.
&nbsp;	         */
<b class="nc">&nbsp;	        if (otherCriteria.isEmpty()) {</b>
<b class="nc">&nbsp;	        	Map&lt;Integer,Integer&gt; combo = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;	        	combo.put(0, cUnits);</b>
<b class="nc">&nbsp;	        	combinations = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;	        	combinations.add(combo);</b>
<b class="nc">&nbsp;	        } else {</b>
<b class="nc">&nbsp;	        	combinations = findCombinations(cUnits);</b>
&nbsp;	        }
&nbsp;	        //Group units by param index so they can be returned in the order requested.
<b class="nc">&nbsp;	        Map&lt;Integer,List&lt;MechSummary&gt;&gt; list = new TreeMap&lt;&gt;();</b>
<b class="nc">&nbsp;	        final int POS_C3S = 0;</b>
<b class="nc">&nbsp;	        final int POS_C3M = 1;</b>
<b class="nc">&nbsp;	        final int POS_C3MM = 2;</b>
<b class="nc">&nbsp;	        final int POS_C3_NUM = 3;</b>
<b class="nc">&nbsp;	        while (combinations.size() &gt; 0) {</b>
<b class="nc">&nbsp;	        	int index = Compute.randomInt(combinations.size());</b>
<b class="nc">&nbsp;	        	Map&lt;Integer,Integer&gt; baseCombo = combinations.get(index);</b>
&nbsp;	
<b class="nc">&nbsp;	        	int[] networkGroups = new int[POS_C3_NUM];</b>
<b class="nc">&nbsp;	        	networkGroups[POS_C3S] = Math.max(0, numNetworked - numMasters);</b>
<b class="nc">&nbsp;	        	if ((networkMask &amp; ModelRecord.NETWORK_COMPANY_COMMAND) == 0) {</b>
<b class="nc">&nbsp;	        		networkGroups[POS_C3M] = Math.max(0, numMasters);</b>
&nbsp;	        	} else {
<b class="nc">&nbsp;	        		networkGroups[POS_C3MM] = Math.max(0, numMasters);</b>
&nbsp;	        	}
<b class="nc">&nbsp;	        	List&lt;Map&lt;Integer,Integer&gt;&gt; networkGroupings = findGroups(baseCombo, networkGroups,</b>
<b class="nc">&nbsp;	        			otherCriteria.size());</b>
<b class="nc">&nbsp;	        	if (altNumMasters &gt; 0) {</b>
<b class="nc">&nbsp;	        		networkGroups[POS_C3S] = Math.max(0, numNetworked - altNumMasters);</b>
<b class="nc">&nbsp;	        		networkGroups[POS_C3M] = Math.max(0, altNumMasters);</b>
<b class="nc">&nbsp;	        		networkGroups[POS_C3MM] = 0;</b>
<b class="nc">&nbsp;	            	networkGroupings.addAll(findGroups(baseCombo, networkGroups, otherCriteria.size()));</b>
&nbsp;	        	}
<b class="nc">&nbsp;	        	while (networkGroupings.size() &gt; 0) {</b>
<b class="nc">&nbsp;	        		list.clear();</b>
<b class="nc">&nbsp;	        		int networkIndex = Compute.randomInt(networkGroupings.size());</b>
<b class="nc">&nbsp;	        		Map&lt;Integer,Integer&gt; combo = networkGroupings.get(networkIndex);</b>
&nbsp;	
<b class="nc">&nbsp;	        		int[] unitsPerGroup = new int[params.size()];</b>
<b class="nc">&nbsp;	        		for (int i = 0; i &lt; numUnits.size(); i++) {</b>
<b class="nc">&nbsp;	        			unitsPerGroup[i] = numUnits.get(i);</b>
&nbsp;	        		}
<b class="nc">&nbsp;	        		List&lt;Map&lt;Integer,Integer&gt;&gt; unitTypeGroupings = findGroups(combo, unitsPerGroup,</b>
<b class="nc">&nbsp;	        				otherCriteria.size() + POS_C3_NUM);</b>
<b class="nc">&nbsp;	        		while (unitTypeGroupings.size() &gt; 0) {</b>
<b class="nc">&nbsp;	        			list.clear();</b>
<b class="nc">&nbsp;	        			int utIndex = Compute.randomInt(unitTypeGroupings.size());</b>
<b class="nc">&nbsp;	        			combo = unitTypeGroupings.get(utIndex);</b>
&nbsp;	
<b class="nc">&nbsp;	        			if (useGrouping != null</b>
<b class="nc">&nbsp;	        					&amp;&amp; params.stream().anyMatch(p -&gt; useGrouping.appliesTo(p.getUnitType()))) {</b>
&nbsp;	        				/* Create a temporary map that only includes units that have a grouping criterion */
<b class="nc">&nbsp;	        				Map&lt;Integer,Integer&gt; groupedUnits = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;	        				for (int p = 0; p &lt; params.size(); p++) {</b>
<b class="nc">&nbsp;	        					if (useGrouping.appliesTo(params.get(p).getUnitType())) {</b>
<b class="nc">&nbsp;	        						for (Integer i : combo.keySet()) {</b>
<b class="nc">&nbsp;	        							if ((i &amp; (1 &lt;&lt; (p + otherCriteria.size() + POS_C3_NUM))) != 0) {</b>
<b class="nc">&nbsp;	        								groupedUnits.merge(i, combo.get(i), Integer::sum);</b>
&nbsp;	        							}
<b class="nc">&nbsp;	        						}</b>
&nbsp;	    						}
&nbsp;	    					}
<b class="nc">&nbsp;	    					List&lt;List&lt;Map&lt;Integer,Integer&gt;&gt;&gt; groups = findMatchedGroups(groupedUnits, useGrouping);</b>
&nbsp;	
<b class="nc">&nbsp;	    					while (groups.size() &gt; 0) {</b>
<b class="nc">&nbsp;	    						int gIndex = Compute.randomInt(groups.size());</b>
<b class="nc">&nbsp;	    						list.clear();</b>
<b class="nc">&nbsp;    							Map&lt;Integer,List&lt;MechSummary&gt;&gt; found = new TreeMap&lt;&gt;();</b>
<b class="nc">&nbsp;	    						Map&lt;Integer,Integer&gt; workingCombo = new HashMap&lt;&gt;(combo);</b>
<b class="nc">&nbsp;	    						for (Map&lt;Integer,Integer&gt; g : groups.get(gIndex)) {</b>
&nbsp;	    							/* The first unit selected may lead to a dead end, if the constraints
&nbsp;	    							 * for the other group members cannot be met in a unit that matches the
&nbsp;	    							 * base. To deal with this we make a second attempt if necessary
&nbsp;	    							 * subjecting all members of the group to all constraints assigned
&nbsp;	    							 * to any group member. */
<b class="nc">&nbsp;	    							int extraCriteria = 0;</b>
<b class="nc">&nbsp;	    							int attempts = 0;</b>
<b class="nc">&nbsp;	    							while (attempts &lt; 2) {</b>
<b class="nc">&nbsp;	    								found.clear();</b>
<b class="nc">&nbsp;		    							MechSummary base = null;</b>
<b class="nc">&nbsp;		    							for (int i : combo.keySet()) {</b>
<b class="nc">&nbsp;		    								if (g.containsKey(i)) {</b>
&nbsp;		    									// Decode unit type
<b class="nc">&nbsp;		    									int tableIndex = 0;</b>
<b class="nc">&nbsp;		    									if (params.size() &gt; 0) {</b>
<b class="nc">&nbsp;		    										int tmp = i &gt;&gt; (otherCriteria.size() + POS_C3_NUM);</b>
<b class="nc">&nbsp;		    										while (tmp != 0 &amp;&amp; (tmp &amp; 1) == 0) {</b>
<b class="nc">&nbsp;		    											tableIndex++;</b>
<b class="nc">&nbsp;		    											tmp &gt;&gt;= 1;</b>
&nbsp;		    										}
&nbsp;		    									}
<b class="nc">&nbsp;		    									final Predicate&lt;MechSummary&gt; filter = getFilterFromIndex(i | extraCriteria,</b>
&nbsp;		    											slaveType, masterType);
<b class="nc">&nbsp;		    									for (int j = 0; j &lt; g.get(i); j++) {</b>
<b class="nc">&nbsp;		    										if (base == null) {</b>
<b class="nc">&nbsp;		    											base = tables.get(tableIndex).generateUnit(ms -&gt; filter.test(ms));</b>
<b class="nc">&nbsp;		    											if (base != null) {</b>
<b class="nc">&nbsp;                                                            found.putIfAbsent(tableIndex, new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;                                                            found.get(tableIndex).add(base);</b>
&nbsp;		    											}
&nbsp;		    										} else {
<b class="nc">&nbsp;		    											final MechSummary b = base;</b>
<b class="nc">&nbsp;		    											MechSummary unit = tables.get(tableIndex).generateUnit(ms -&gt; filter.test(ms)</b>
<b class="nc">&nbsp;		    													&amp;&amp; useGrouping.matches(ms, b));</b>
<b class="nc">&nbsp;		    											if (unit != null) {</b>
<b class="nc">&nbsp;		    											    found.putIfAbsent(tableIndex, new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;                                                            found.get(tableIndex).add(unit);</b>
&nbsp;		    											}
&nbsp;		    										}
&nbsp;		    									}
&nbsp;		    								}
<b class="nc">&nbsp;		    							}</b>
<b class="nc">&nbsp;		    							if (found.values().stream().mapToInt(List::size).sum()</b>
<b class="nc">&nbsp;		    							        &lt; g.values().stream().mapToInt(Integer::intValue).sum()) {</b>
<b class="nc">&nbsp;		    								found.clear();</b>
<b class="nc">&nbsp;		    								base = null;</b>
<b class="nc">&nbsp;		    								int mask = (1 &lt;&lt; otherCriteria.size()) - 1;</b>
<b class="nc">&nbsp;		    								extraCriteria = 0;</b>
<b class="nc">&nbsp;		    								for (int k : g.keySet()) {</b>
<b class="nc">&nbsp;		    									extraCriteria |= k &amp; mask;</b>
<b class="nc">&nbsp;		    								}</b>
<b class="nc">&nbsp;		    								attempts++;</b>
&nbsp;		    							} else {
&nbsp;		    								break;
&nbsp;		    							}
<b class="nc">&nbsp;	    							}</b>
<b class="nc">&nbsp;	    							for (Map.Entry&lt;Integer, List&lt;MechSummary&gt;&gt; e : found.entrySet()) {</b>
<b class="nc">&nbsp;	    							    list.putIfAbsent(e.getKey(), new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;	    							    list.get(e.getKey()).addAll(e.getValue());</b>
<b class="nc">&nbsp;	    							}</b>
<b class="nc">&nbsp;		    						for (Integer k : g.keySet()) {</b>
<b class="nc">&nbsp;		    							workingCombo.merge(k, -g.get(k), Integer::sum);</b>
<b class="nc">&nbsp;		    						}</b>
<b class="nc">&nbsp;	    						}</b>
<b class="nc">&nbsp;	    						for (int i : workingCombo.keySet()) {</b>
<b class="nc">&nbsp;	    							if (workingCombo.get(i) &gt; 0) {</b>
&nbsp;	    								// Decode unit type
<b class="nc">&nbsp;	    								int tableIndex = 0;</b>
<b class="nc">&nbsp;	    								if (params.size() &gt; 0) {</b>
<b class="nc">&nbsp;											int tmp = i &gt;&gt; (otherCriteria.size() + POS_C3_NUM);</b>
<b class="nc">&nbsp;	        								while (tmp != 0 &amp;&amp; (tmp &amp; 1) == 0) {</b>
<b class="nc">&nbsp;	        									tableIndex++;</b>
<b class="nc">&nbsp;	        									tmp &gt;&gt;= 1;</b>
&nbsp;	        								}
&nbsp;	    								}
<b class="nc">&nbsp;	    								final Predicate&lt;MechSummary&gt; filter = getFilterFromIndex(i, slaveType, masterType);</b>
<b class="nc">&nbsp;	    								for (int j = 0; j &lt; workingCombo.get(i); j++) {</b>
<b class="nc">&nbsp;	    									MechSummary unit = tables.get(tableIndex).generateUnit(ms -&gt; filter.test(ms));</b>
<b class="nc">&nbsp;	    									if (unit != null) {</b>
<b class="nc">&nbsp;	    									    list.putIfAbsent(tableIndex, new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;	    										list.get(tableIndex).add(unit);</b>
&nbsp;	    									}
&nbsp;	    								}
&nbsp;	    							}
<b class="nc">&nbsp;	    						}</b>
<b class="nc">&nbsp;	    						List&lt;MechSummary&gt; retVal = list.values().stream()</b>
<b class="nc">&nbsp;	    						        .flatMap(l -&gt; l.stream()).collect(Collectors.toList());</b>
<b class="nc">&nbsp;	    						if (retVal.size() &lt; cUnits) {</b>
<b class="nc">&nbsp;	    							groups.remove(gIndex);</b>
&nbsp;	    						} else {
<b class="nc">&nbsp;	    							return retVal;</b>
&nbsp;	    						}
<b class="nc">&nbsp;	    					}</b>
<b class="nc">&nbsp;	    				} else {</b>
<b class="nc">&nbsp;	    					for (int i : combo.keySet()) {</b>
&nbsp;    							// Decode unit type
<b class="nc">&nbsp;    							int tableIndex = 0;</b>
<b class="nc">&nbsp;    							if (params.size() &gt; 0) {</b>
<b class="nc">&nbsp;									int tmp = i &gt;&gt; (otherCriteria.size() + POS_C3_NUM);</b>
<b class="nc">&nbsp;    								while (tmp != 0 &amp;&amp; (tmp &amp; 1) == 0) {</b>
<b class="nc">&nbsp;    									tableIndex++;</b>
<b class="nc">&nbsp;    									tmp &gt;&gt;= 1;</b>
&nbsp;    								}
&nbsp;    							}
<b class="nc">&nbsp;    							final Predicate&lt;MechSummary&gt;filter = getFilterFromIndex(i, slaveType, masterType);</b>
<b class="nc">&nbsp;    							for (int j = 0; j &lt; combo.get(i); j++) {</b>
<b class="nc">&nbsp;    								MechSummary unit = tables.get(tableIndex).generateUnit(ms -&gt; filter.test(ms));</b>
<b class="nc">&nbsp;    								if (unit != null) {</b>
<b class="nc">&nbsp;    								    list.putIfAbsent(tableIndex, new ArrayList&lt;&gt;());</b>
<b class="nc">&nbsp;    									list.get(tableIndex).add(unit);</b>
&nbsp;    								}
&nbsp;    							}
<b class="nc">&nbsp;	    					}</b>
&nbsp;	    				}
<b class="nc">&nbsp;                        List&lt;MechSummary&gt; retVal = list.values().stream()</b>
<b class="nc">&nbsp;                                .flatMap(l -&gt; l.stream()).collect(Collectors.toList());</b>
<b class="nc">&nbsp;                        if (retVal.size() &lt; cUnits) {</b>
<b class="nc">&nbsp;                            unitTypeGroupings.remove(utIndex);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return retVal;</b>
&nbsp;                        }
<b class="nc">&nbsp;	    			}</b>
<b class="nc">&nbsp;                    List&lt;MechSummary&gt; retVal = list.values().stream()</b>
<b class="nc">&nbsp;                            .flatMap(l -&gt; l.stream()).collect(Collectors.toList());</b>
<b class="nc">&nbsp;                    if (retVal.size() &lt; cUnits) {</b>
<b class="nc">&nbsp;						networkGroupings.remove(networkIndex);</b>
&nbsp;					} else {
<b class="nc">&nbsp;						return retVal;</b>
&nbsp;					}
<b class="nc">&nbsp;	    		}</b>
<b class="nc">&nbsp;	    		combinations.remove(index);</b>
<b class="nc">&nbsp;	        }</b>
<b class="nc">&nbsp;	        numNetworked--;</b>
<b class="nc">&nbsp;        } while (numNetworked &gt;= 0);        </b>
&nbsp;        
<b class="nc">&nbsp;        List&lt;MechSummary&gt; onRole = tryIdealRole(params, numUnits);</b>
<b class="nc">&nbsp;        if (onRole != null) {</b>
<b class="nc">&nbsp;            return onRole;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private Predicate&lt;MechSummary&gt; getFilterFromIndex(int index, int slaveType, int masterType) {
<b class="nc">&nbsp;    	Predicate&lt;MechSummary&gt; retVal = mainCriteria;</b>
<b class="nc">&nbsp;    	int mask = 1 &lt;&lt; (otherCriteria.size() - 1);</b>
<b class="nc">&nbsp;    	for (Constraint c : otherCriteria) {</b>
<b class="nc">&nbsp;    		if ((index &amp; mask) != 0) {</b>
<b class="nc">&nbsp;    			retVal = retVal.and(c.criterion);</b>
&nbsp;    		}
<b class="nc">&nbsp;    		mask &gt;&gt;= 1;</b>
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    	mask = 1 &lt;&lt; otherCriteria.size();</b>
<b class="nc">&nbsp;    	if (slaveType &gt; 0 &amp;&amp; (mask &amp; index) != 0) {</b>
<b class="nc">&nbsp;    		retVal = retVal.and(ms -&gt; (getNetworkMask(ms) &amp; slaveType) != 0);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	mask &lt;&lt;= 1;</b>
<b class="nc">&nbsp;	    if (masterType &gt; 0 &amp;&amp; (mask &amp; index) != 0) {</b>
<b class="nc">&nbsp;	    	retVal = retVal.and(ms -&gt; (getNetworkMask(ms) &amp; masterType) != 0);</b>
&nbsp;	    }
<b class="nc">&nbsp;	    mask &lt;&lt;= 1;</b>
<b class="nc">&nbsp;	    if (masterType &gt; 0 &amp;&amp; (mask &amp; index) != 0) {</b>
<b class="nc">&nbsp;	    	retVal = retVal.and(ms -&gt; (getNetworkMask(ms)</b>
&nbsp;	    			&amp; (masterType | ModelRecord.NETWORK_COMPANY_COMMAND)) != 0);
&nbsp;	    }
<b class="nc">&nbsp;    	return retVal;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Attempts to build unit entirely on ideal role. Returns null if unsuccessful.
&nbsp;     */
&nbsp;    private List&lt;MechSummary&gt; tryIdealRole(List&lt;UnitTable.Parameters&gt; params, List&lt;Integer&gt; numUnits) {
<b class="nc">&nbsp;        if (idealRole.equals(UnitRole.UNDETERMINED)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;UnitTable.Parameters&gt; tmpParams = params.stream()</b>
<b class="nc">&nbsp;                .map(p -&gt; p.copy()).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        tmpParams.forEach(p -&gt; p.getWeightClasses().clear());</b>
<b class="nc">&nbsp;        List&lt;MechSummary&gt; retVal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; tmpParams.size(); i++) {</b>
<b class="nc">&nbsp;            UnitTable t = UnitTable.findTable(tmpParams.get(i));</b>
<b class="nc">&nbsp;            List&lt;MechSummary&gt; units = t.generateUnits(numUnits.get(i),</b>
<b class="nc">&nbsp;                    ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(idealRole));</b>
<b class="nc">&nbsp;            if (units.size() &lt; numUnits.get(i)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds all unique distributions of constraints among the units that fulfills the minimum
&nbsp;     * number for each constraint. The map keys indicate a combination of constraints, with the
&nbsp;     * highest order bit being the first constraint in the list, and the value mapped to that key being
&nbsp;     * the number of units that must meet the constraint.
&nbsp;     */
&nbsp;    private List&lt;Map&lt;Integer,Integer&gt;&gt; findCombinations(int numUnits) {
&nbsp;    	/* This list is remade with each additional constraint, building on the previous values */
<b class="nc">&nbsp;    	List&lt;Map&lt;Integer,Integer&gt;&gt; frequencies = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    	for (Constraint c : otherCriteria) {</b>
<b class="nc">&nbsp;    		int req = c.getMinimum(numUnits);</b>
&nbsp;    		/* If this is the first pass, we simply need to initialize the frequencies list */
<b class="nc">&nbsp;    		if (frequencies.isEmpty()) {</b>
<b class="nc">&nbsp;    			Map&lt;Integer,Integer&gt; freq = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    			freq.put(0, numUnits - req);</b>
<b class="nc">&nbsp;    			freq.put(1, req);</b>
<b class="nc">&nbsp;    			frequencies.add(freq);</b>
<b class="nc">&nbsp;    		} else {</b>
&nbsp;    			/* Create a new list to hold the values built off the previous one */
<b class="nc">&nbsp;    			List&lt;Map&lt;Integer,Integer&gt;&gt; newFrequencies = new ArrayList&lt;&gt;();</b>
&nbsp;    			/* Iterate through all the values from the previous pass and extend them */
<b class="nc">&nbsp;    			for (Map&lt;Integer,Integer&gt; freq : frequencies) {</b>
&nbsp;    				/* We need to be able to access the keys by position */
<b class="nc">&nbsp;    				List&lt;Integer&gt; keyList = new ArrayList&lt;&gt;(freq.keySet());</b>
&nbsp;    				/* For each position, note how many total slots there are in later positions */
<b class="nc">&nbsp;    				int[] remaining = new int[freq.size()];</b>
<b class="nc">&nbsp;    				int rem = 0;</b>
<b class="nc">&nbsp;    				for (int i = keyList.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;    					rem += freq.get(keyList.get(i));</b>
<b class="nc">&nbsp;    					remaining[i] = rem;</b>
&nbsp;    				}
<b class="nc">&nbsp;    				int index = 0;</b>
<b class="nc">&nbsp;    				int toAllocate = req;</b>
&nbsp;    				/* current holds the number of units at each index of the previous iteration
&nbsp;    				 * that will meet the current constraint */
<b class="nc">&nbsp;    				int[] current = new int[keyList.size()];</b>
<b class="nc">&nbsp;    				outer: while (remaining[index] &gt;= toAllocate) {</b>
<b class="nc">&nbsp;    					current[index] = Math.min(freq.get(keyList.get(index)), toAllocate);</b>
<b class="nc">&nbsp;    					toAllocate -= current[index];</b>
<b class="nc">&nbsp;    					index++;</b>
<b class="nc">&nbsp;    					if (index == keyList.size()) {</b>
<b class="nc">&nbsp;    						if (c.isPairedWithPrevious()) {</b>
<b class="nc">&nbsp;    							Map&lt;Integer,Integer&gt; prevValues = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    							for (int i : freq.keySet()) {</b>
<b class="nc">&nbsp;    								prevValues.put(i &lt;&lt; 1, freq.get(i));</b>
<b class="nc">&nbsp;    							}</b>
<b class="nc">&nbsp;    							newFrequencies.add(prevValues);</b>
&nbsp;    						}
<b class="nc">&nbsp;    						Map&lt;Integer,Integer&gt; result = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    						for (int i = 0; i &lt; current.length; i++) {</b>
<b class="nc">&nbsp;    							int key = keyList.get(i);</b>
<b class="nc">&nbsp;    							if (c.isPairedWithPrevious()) {</b>
<b class="nc">&nbsp;    								key &amp;= ~1;</b>
&nbsp;    							}
<b class="nc">&nbsp;    							if (freq.get(keyList.get(i)) &gt; current[i]) {</b>
<b class="nc">&nbsp;    								result.merge(key &lt;&lt; 1, freq.get(keyList.get(i)) - current[i], Integer::sum);</b>
&nbsp;    							}
<b class="nc">&nbsp;    							if (current[i] &gt; 0) {</b>
<b class="nc">&nbsp;    								result.merge((key &lt;&lt; 1) + 1, current[i], Integer::sum);</b>
&nbsp;    							}
&nbsp;    						}
<b class="nc">&nbsp;    						newFrequencies.add(result);</b>
<b class="nc">&nbsp;    						index--;</b>
&nbsp;    						/* Keep backing up until we find one we can decrease or we reach the beginning.
&nbsp;    						 * We can decrease if the current value is &gt; 0 and the remaining slots are
&nbsp;    						 * big enough to hold toAllocate + 1.
&nbsp;    						 */
<b class="nc">&nbsp;    						while (index &gt;= 0) {</b>
<b class="nc">&nbsp;    							if (current[index] == 0 || index + 1 == current.length</b>
&nbsp;    									|| remaining[index + 1] &lt;= toAllocate
&nbsp;    									) {
<b class="nc">&nbsp;        							toAllocate += current[index];</b>
<b class="nc">&nbsp;        							index--;    								</b>
&nbsp;    							} else {
<b class="nc">&nbsp;    								current[index]--;</b>
<b class="nc">&nbsp;    								toAllocate++;</b>
<b class="nc">&nbsp;    								index++;</b>
<b class="nc">&nbsp;    								continue outer;</b>
&nbsp;    							}
&nbsp;    						}
&nbsp;    						break outer;
&nbsp;    					}
&nbsp;    				}
<b class="nc">&nbsp;    			}</b>
<b class="nc">&nbsp;	    		frequencies = newFrequencies;</b>
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    	return frequencies;</b>
&nbsp;    }    
&nbsp;    
&nbsp;    /**
&nbsp;     * Finds all possible ways to distribute criteria beyond the general formation criteria in
&nbsp;     * which the groups are mutually exclusive; that is, a unit can only qualify for one
&nbsp;     * of the criteria in the set. This is used for mixed unit types and C3 networks. While a single
&nbsp;     * unit could fulfill the requirements for speed and weight class, it could not function
&nbsp;     * as both a C3 slave and a C3 master or be both a Mek and a Tank.
&nbsp;     *  
&nbsp;     * @param combination	The current criteria distribution as generated by &lt;code&gt;findCombinations&lt;/code&gt;
&nbsp;     * @param itemsPerGroup	Array with length equal to number of groups and each value indicates
&nbsp;     * 						the number of units in that group.
&nbsp;     * @return	A map the same format as &lt;code&gt;combination&lt;/code&gt; in which higher order bits
&nbsp;     * 			in the key indicate a group. For example: in a formation with two criteria, 
&nbsp;	 *			&lt;code&gt;combination.length&lt;/code&gt; == 2^2. If there are three additional groups,
&nbsp;	 *			the return value will be 2 ^ (2+3). The value mapped to 11 (== 01011) will be the
&nbsp;	 *			number of units that are in the second group and fulfill both formation criteria.
&nbsp;     */
&nbsp;    private List&lt;Map&lt;Integer,Integer&gt;&gt; findGroups(Map&lt;Integer,Integer&gt; combination, int[] itemsPerGroup, int indexBits) {
<b class="nc">&nbsp;    	List&lt;Integer&gt; keyList = new ArrayList&lt;&gt;(combination.keySet());</b>
&nbsp;    	
<b class="nc">&nbsp;    	List&lt;int[][]&gt; list = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	int[][] initialVal = new int[1][keyList.size()];</b>
<b class="nc">&nbsp;    	list.add(initialVal);</b>
&nbsp;    	
&nbsp;    	/* Compute distribution for each group sequentially, building on previously calculated
&nbsp;    	 * distributions for each successive group. */
<b class="nc">&nbsp;    	for (int group = 0; group &lt; itemsPerGroup.length; group++) {</b>
&nbsp;    		/* Create a new list that we will fill out by copying the current values and adding
&nbsp;    		 * the next group calculated during this iteration. */
<b class="nc">&nbsp;    		List&lt;int[][]&gt; newList = new ArrayList&lt;&gt;();</b>
&nbsp;    		/* Cycle through all previous combinations and add all combinations for current group */
<b class="nc">&nbsp;    		for (int[][] prev : list) {</b>
&nbsp;    			/* Initialize array with the number of units at each position that have already been
&nbsp;    			 * assigned to groups. */
<b class="nc">&nbsp;    			int[] total = new int[keyList.size()];</b>
<b class="nc">&nbsp;    			for (int g = 0; g &lt; prev.length; g++) {</b>
<b class="nc">&nbsp;    				for (int p = 0; p &lt; prev[g].length; p++) {</b>
<b class="nc">&nbsp;    					total[p] += prev[g][p];</b>
&nbsp;    				}
&nbsp;    			}
&nbsp;    			/* Create an array to track attempted distribution of the current group */
<b class="nc">&nbsp;    			int[] dist = new int[keyList.size()];</b>
<b class="nc">&nbsp;    			dist[0] = itemsPerGroup[group];</b>
&nbsp;    			/* Shift values through the array until they are all in the final position */
<b class="nc">&nbsp;    			while (dist[dist.length - 1] &lt;= itemsPerGroup[group]) {</b>
&nbsp;    				/* Test whether there is room for the current distribution, and if so add it to
&nbsp;    				 * the list */
<b class="nc">&nbsp;    				boolean hasRoom = true;</b>
<b class="nc">&nbsp;    				for (int i = 0; i &lt; dist.length; i++) {</b>
<b class="nc">&nbsp;    					if (total[i] + dist[i] &gt; combination.get(keyList.get(i))) {</b>
<b class="nc">&nbsp;    						hasRoom = false;</b>
<b class="nc">&nbsp;    						break;</b>
&nbsp;    					}
&nbsp;    				}
<b class="nc">&nbsp;    				if (hasRoom) {</b>
<b class="nc">&nbsp;    					int[][] newVal = new int[group + 1][];</b>
<b class="nc">&nbsp;    					for (int j = 0; j &lt; group; j++) {</b>
<b class="nc">&nbsp;    						newVal[j] = prev[j];</b>
&nbsp;    					}
<b class="nc">&nbsp;    					newVal[group] = new int[dist.length];</b>
<b class="nc">&nbsp;    					System.arraycopy(dist, 0, newVal[group], 0, dist.length);</b>
<b class="nc">&nbsp;    					newList.add(newVal);</b>
&nbsp;    				}
&nbsp;    				/* Shift the values in the current distribution. Find the value &gt; 0 closest to the
&nbsp;    				 * end (not counting the final position), decrease it by 1, and set the value in
&nbsp;    				 * the next position to 1 plus whatever was in the tail position (which becomes 0
&nbsp;    				 * prior to incrementing */
<b class="nc">&nbsp;    				if (dist[dist.length - 1] == itemsPerGroup[group]) {</b>
<b class="nc">&nbsp;    					break;</b>
&nbsp;    				}
<b class="nc">&nbsp;    				int tail = dist[dist.length - 1];</b>
<b class="nc">&nbsp;    				dist[dist.length - 1] = 0;</b>
<b class="nc">&nbsp;    				for (int i = dist.length - 2; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;    					if (dist[i] &gt; 0) {</b>
<b class="nc">&nbsp;    						dist[i]--;</b>
<b class="nc">&nbsp;    						dist[i + 1] = tail + 1;</b>
<b class="nc">&nbsp;    						break;</b>
&nbsp;    					}
&nbsp;    				}
<b class="nc">&nbsp;    			}</b>
<b class="nc">&nbsp;	    	}</b>
&nbsp;    		/* Replace the old list with one from this iteration */
<b class="nc">&nbsp;        	list = newList;</b>
&nbsp;    	}
&nbsp;    	/* Use generated distributions to produce a new combination list */
<b class="nc">&nbsp;    	List&lt;Map&lt;Integer,Integer&gt;&gt; retVal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	for (int[][] val : list) {</b>
<b class="nc">&nbsp;    		Map&lt;Integer,Integer&gt; newVal = new LinkedHashMap&lt;&gt;(combination);</b>
<b class="nc">&nbsp;    		for (int g = 0; g &lt; val.length; g++) {</b>
<b class="nc">&nbsp;    			for (int i = 0; i &lt; val[g].length; i++) {</b>
<b class="nc">&nbsp;    				if (val[g][i] &gt; 0) {</b>
<b class="nc">&nbsp;    					newVal.put((1 &lt;&lt; (g + indexBits)) + keyList.get(i), val[g][i]);</b>
<b class="nc">&nbsp;    					newVal.merge(keyList.get(i), - val[g][i], Integer::sum);</b>
<b class="nc">&nbsp;    					if (newVal.get(keyList.get(i)) &lt;= 0) {</b>
<b class="nc">&nbsp;    						newVal.remove(keyList.get(i));</b>
&nbsp;    					}
&nbsp;    				}
&nbsp;    			}
&nbsp;    		}
<b class="nc">&nbsp;    		retVal.add(newVal);</b>
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    	return retVal;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Special case version of &lt;code&gt;findGroups&lt;/code&gt; for matched units (such as paired ASFs).
&nbsp;     * Because each group has identical criteria the number of possible results can be reduced.
&nbsp;     *  
&nbsp;     * @param combination	The current criteria distribution as generated by &lt;code&gt;findCombinations&lt;/code&gt;
&nbsp;     * @return	A list of possible groupings. Each entry is a list of size() equal to numGroups.
&nbsp;     * 			The entry for each group is a map of the same format as &lt;code&gt;combination&lt;/code&gt;. 
&nbsp;     */
&nbsp;    private List&lt;List&lt;Map&lt;Integer,Integer&gt;&gt;&gt; findMatchedGroups(Map&lt;Integer,Integer&gt; combination,
&nbsp;            GroupingConstraint groupingCriteria) {
<b class="nc">&nbsp;    	int numUnits = combination.values().stream().mapToInt(Integer::intValue).sum();</b>
<b class="nc">&nbsp;        int size = Math.min(groupingCriteria.getGroupSize(), numUnits);</b>
<b class="nc">&nbsp;    	int numGroups = Math.max(groupingCriteria.getNumGroups(), 1);</b>
<b class="nc">&nbsp;    	if (groupingCriteria.getGroupSize() == 0 &amp;&amp; groupingCriteria.getNumGroups() &gt; 0) {</b>
<b class="nc">&nbsp;    	    numGroups = groupingCriteria.getNumGroups();</b>
<b class="nc">&nbsp;    	    size = Math.max(1, numUnits / numGroups);</b>
<b class="nc">&nbsp;    	} else if (groupingCriteria.getNumGroups() == 0 &amp;&amp; groupingCriteria.getGroupSize() &gt; 0) {</b>
<b class="nc">&nbsp;            size = groupingCriteria.getGroupSize();</b>
<b class="nc">&nbsp;            numGroups = Math.max(1, numUnits / size);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	List&lt;Integer&gt; keyList = new ArrayList&lt;&gt;(combination.keySet());</b>
&nbsp;    	
<b class="nc">&nbsp;    	List&lt;int[][]&gt; list = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	int[][] initialVal = new int[1][keyList.size()];</b>
<b class="nc">&nbsp;    	list.add(initialVal);</b>
&nbsp;    	
&nbsp;    	/* Compute distribution for each group sequentially, building on previously calculated
&nbsp;    	 * distributions for each successive group. */
<b class="nc">&nbsp;    	for (int group = 0; group &lt; numGroups; group++) {</b>
&nbsp;    		/* Create a new list that we will fill out by copying the current values and adding
&nbsp;    		 * the next group calculated during this iteration. */
<b class="nc">&nbsp;    		List&lt;int[][]&gt; newList = new ArrayList&lt;&gt;();</b>
&nbsp;    		/* Cycle through all previous combinations and add all combinations for current group */
<b class="nc">&nbsp;    		for (int[][] prev : list) {</b>
&nbsp;    			/* Initialize array with the number of units at each position that have already been
&nbsp;    			 * assigned to groups. */
<b class="nc">&nbsp;    			int[] total = new int[keyList.size()];</b>
<b class="nc">&nbsp;    			for (int g = 0; g &lt; prev.length; g++) {</b>
<b class="nc">&nbsp;    				for (int p = 0; p &lt; prev[g].length; p++) {</b>
<b class="nc">&nbsp;    					total[p] += prev[g][p];</b>
&nbsp;    				}
&nbsp;    			}
&nbsp;    			/* Find the starting position for the current group. We don&#39;t want to start earlier
&nbsp;    			 * that the first position that has been assigned to a group; that will be a permutation
&nbsp;    			 * of a result that has already been calculated. */
&nbsp;
<b class="nc">&nbsp;    			int startPos = -1;</b>
<b class="nc">&nbsp;    			for (int i = 0; i &lt; total.length; i++) {</b>
<b class="nc">&nbsp;    				if (total[i] &gt; 0) {</b>
<b class="nc">&nbsp;    					startPos = i;</b>
<b class="nc">&nbsp;    					break;</b>
&nbsp;    				}
&nbsp;    			}
<b class="nc">&nbsp;    			startPos = Math.max(0, startPos);</b>
&nbsp;    			
&nbsp;    			/* Create an array to track attempted distribution of the current group */
<b class="nc">&nbsp;    			int[] dist = new int[keyList.size()];</b>
<b class="nc">&nbsp;    			dist[startPos] = size;</b>
&nbsp;    			/* Shift values through the array until they are all in the final position */
<b class="nc">&nbsp;    			while (dist[dist.length - 1] &lt;= size) {</b>
&nbsp;    				/* Test whether there is room for the current distribution, and if so add it to
&nbsp;    				 * the list */
<b class="nc">&nbsp;    				boolean hasRoom = true;</b>
<b class="nc">&nbsp;    				for (int i = 0; i &lt; dist.length; i++) {</b>
<b class="nc">&nbsp;    					if (total[i] + dist[i] &gt; combination.get(keyList.get(i))) {</b>
<b class="nc">&nbsp;    						hasRoom = false;</b>
<b class="nc">&nbsp;    						break;</b>
&nbsp;    					}
&nbsp;    				}
<b class="nc">&nbsp;    				if (hasRoom) {</b>
<b class="nc">&nbsp;    					int[][] newVal = new int[group + 1][];</b>
<b class="nc">&nbsp;    					for (int j = 0; j &lt; group; j++) {</b>
<b class="nc">&nbsp;    						newVal[j] = prev[j];</b>
&nbsp;    					}
<b class="nc">&nbsp;    					newVal[group] = new int[dist.length];</b>
<b class="nc">&nbsp;    					System.arraycopy(dist, 0, newVal[group], 0, dist.length);</b>
<b class="nc">&nbsp;    					newList.add(newVal);</b>
&nbsp;    				}
&nbsp;    				/* Shift the values in the current distribution. Find the value &gt; 0 closest to the
&nbsp;    				 * end (not counting the final position), decrease it by 1, and set the value in
&nbsp;    				 * the next position to 1 plus whatever was in the tail position (which becomes 0
&nbsp;    				 * prior to incrementing */
<b class="nc">&nbsp;    				if (dist[dist.length - 1] == size) {</b>
<b class="nc">&nbsp;    					break;</b>
&nbsp;    				}
<b class="nc">&nbsp;    				int tail = dist[dist.length - 1];</b>
<b class="nc">&nbsp;    				dist[dist.length - 1] = 0;</b>
<b class="nc">&nbsp;    				for (int i = dist.length - 2; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;    					if (dist[i] &gt; 0) {</b>
<b class="nc">&nbsp;    						dist[i]--;</b>
<b class="nc">&nbsp;    						dist[i + 1] = tail + 1;</b>
<b class="nc">&nbsp;    						break;</b>
&nbsp;    					}
&nbsp;    				}
<b class="nc">&nbsp;    			}</b>
<b class="nc">&nbsp;	    	}</b>
&nbsp;    		/* Replace the old list with one from this iteration */
<b class="nc">&nbsp;        	list = newList;</b>
&nbsp;    	}
<b class="nc">&nbsp;    	List&lt;List&lt;Map&lt;Integer,Integer&gt;&gt;&gt; retVal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	for (int[][] grouping : list) {</b>
<b class="nc">&nbsp;    		List&lt;Map&lt;Integer,Integer&gt;&gt; newGrouping = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    		for (int g = 0; g &lt; grouping.length; g++) {</b>
<b class="nc">&nbsp;    			Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    			for (int p = 0; p &lt; grouping[g].length; p++) {</b>
<b class="nc">&nbsp;    				map.put(keyList.get(p), grouping[g][p]);</b>
&nbsp;    			}
<b class="nc">&nbsp;    			newGrouping.add(map);</b>
&nbsp;    		}
<b class="nc">&nbsp;    		retVal.add(newGrouping);</b>
<b class="nc">&nbsp;    	}</b>
&nbsp;    	
<b class="nc">&nbsp;    	return retVal;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Tests whether a list of units qualifies for the formation type. Note that unit roles are
&nbsp;     * not available for all units.
&nbsp;     * @param units	A list of units to test
&nbsp;     * @return		Whether the list of units meets the qualifications for this formation.
&nbsp;     */
&nbsp;    public boolean qualifies(List&lt;MechSummary&gt; units) {
<b class="nc">&nbsp;    	if (units.stream().anyMatch(ms -&gt; !isAllowedUnitType(ModelRecord.parseUnitType(ms.getUnitType())))) {</b>
<b class="nc">&nbsp;    		return false;</b>
&nbsp;    	}
<b class="nc">&nbsp;    	if (!idealRole.equals(UnitRole.UNDETERMINED)) {</b>
<b class="nc">&nbsp;    		if (units.stream().allMatch(ms -&gt; idealRole.equals(UnitRoleHandler.getRoleFor(ms)))) {</b>
<b class="nc">&nbsp;    			return true;</b>
&nbsp;    		}
&nbsp;    	}
<b class="nc">&nbsp;    	for (MechSummary ms : units) {</b>
<b class="nc">&nbsp;    		if (!mainCriteria.test(ms)</b>
<b class="nc">&nbsp;    				|| ms.getWeightClass() &lt; minWeightClass</b>
<b class="nc">&nbsp;    				|| ms.getWeightClass() &gt; maxWeightClass) {</b>
<b class="nc">&nbsp;    			return false;</b>
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    	for (int i = 0; i &lt; otherCriteria.size(); i++) {</b>
<b class="nc">&nbsp;    		final Constraint c = otherCriteria.get(i);</b>
<b class="nc">&nbsp;    		if (c.isPairedWithPrevious()) {</b>
<b class="nc">&nbsp;    			continue;</b>
&nbsp;    		}
<b class="nc">&nbsp;			long matches = units.stream().filter(ms -&gt; c.matches(ms)).count();</b>
<b class="nc">&nbsp;			if (matches &lt; c.getMinimum(units.size())) {</b>
<b class="nc">&nbsp;				if (c.isPairedWithNext() &amp;&amp; i + 1 &lt; otherCriteria.size()) {</b>
<b class="nc">&nbsp;					i++;</b>
&nbsp;				} else {
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			}
&nbsp;    	}
<b class="nc">&nbsp;		if (groupingCriteria != null) {</b>
&nbsp;			/* First group by chassis, then test whether each group fulfills the requirement.
&nbsp;			 * If not, regroup by name. */
<b class="nc">&nbsp;			List&lt;MechSummary&gt; groupedUnits = units.stream()</b>
<b class="nc">&nbsp;					.filter(ms -&gt; groupingCriteria.appliesTo(ModelRecord.parseUnitType(ms.getUnitType())))</b>
<b class="nc">&nbsp;					.collect(Collectors.toList());</b>
<b class="nc">&nbsp;			if (groupedUnits.size() &gt; 0) {</b>
<b class="nc">&nbsp;				Map&lt;String,List&lt;MechSummary&gt;&gt; groups = groupedUnits.stream()</b>
<b class="nc">&nbsp;						.collect(Collectors.groupingBy(ms -&gt; ms.getChassis()));</b>
<b class="nc">&nbsp;				GROUP_LOOP: for (List&lt;MechSummary&gt; group : groups.values()) {</b>
<b class="nc">&nbsp;					for (int i = 0; i &lt; group.size() - 1; i++) {</b>
<b class="nc">&nbsp;						for (int j = i + 1; j &lt; group.size(); j++) {</b>
<b class="nc">&nbsp;							if (!groupingCriteria.matches(group.get(i), group.get(j))) {</b>
<b class="nc">&nbsp;								groups = groupedUnits.stream()</b>
<b class="nc">&nbsp;										.collect(Collectors.groupingBy(ms -&gt; ms.getName()));</b>
<b class="nc">&nbsp;								break GROUP_LOOP;</b>
&nbsp;							}
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				int groupSize = Math.min(groupingCriteria.getGroupSize(), groupedUnits.size());</b>
<b class="nc">&nbsp;		    	int numGroups = Math.min(groupingCriteria.getNumGroups(), groupedUnits.size() / groupSize);</b>
&nbsp;		    	/* Allow for the possibility that two or more groups may be identical */
<b class="nc">&nbsp;		    	int groupCount = 0;</b>
<b class="nc">&nbsp;		    	for (List&lt;MechSummary&gt; g : groups.values()) {</b>
<b class="nc">&nbsp;		    		groupCount += g.size() / groupSize;</b>
<b class="nc">&nbsp;		    	}</b>
<b class="nc">&nbsp;		    	return groupCount &gt;= numGroups;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return true;    	</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Tests whether a list of units qualifies for the formation type. Note that unit roles are
&nbsp;     * not available for all units.
&nbsp;     * @param units	A list of units to test
&nbsp;     * @return		Whether the list of units meets the qualifications for this formation.
&nbsp;     */
&nbsp;    public String qualificationReport(List&lt;MechSummary&gt; units) {
<b class="nc">&nbsp;    	List&lt;MechSummary&gt; wrongUnits = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	List&lt;MechSummary&gt; ideal = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	List&lt;MechSummary&gt; weight = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	List&lt;MechSummary&gt; main = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	List&lt;List&lt;MechSummary&gt;&gt; other = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    	for (int i = 0; i &lt; otherCriteria.size(); i++) {</b>
<b class="nc">&nbsp;    		other.add(new ArrayList&lt;&gt;());</b>
&nbsp;    	}
&nbsp;    			
<b class="nc">&nbsp;    	for (MechSummary ms : units) {</b>
<b class="nc">&nbsp;    		if (!isAllowedUnitType(ModelRecord.parseUnitType(ms.getUnitType()))) {</b>
<b class="nc">&nbsp;    			wrongUnits.add(ms);</b>
&nbsp;    		}
<b class="nc">&nbsp;    		if (!idealRole.equals(UnitRole.UNDETERMINED)</b>
<b class="nc">&nbsp;    				&amp;&amp; idealRole.equals(UnitRoleHandler.getRoleFor(ms))) {</b>
<b class="nc">&nbsp;    			ideal.add(ms);</b>
&nbsp;    		}
<b class="nc">&nbsp;    		if (ms.getWeightClass() &gt;= minWeightClass</b>
<b class="nc">&nbsp;    				&amp;&amp; ms.getWeightClass() &lt;= maxWeightClass) {</b>
<b class="nc">&nbsp;    			weight.add(ms);</b>
&nbsp;    		}
<b class="nc">&nbsp;    		if (mainCriteria.test(ms)) {</b>
<b class="nc">&nbsp;    			main.add(ms);</b>
&nbsp;    		}
<b class="nc">&nbsp;    		for (int i = 0; i &lt; otherCriteria.size(); i++) {</b>
<b class="nc">&nbsp;    			if (otherCriteria.get(i).matches(ms)) {</b>
<b class="nc">&nbsp;    				other.get(i).add(ms);</b>
&nbsp;    			}
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    	StringBuilder sb = new StringBuilder(&quot;&lt;html&gt;&quot;);</b>
<b class="nc">&nbsp;    	if (wrongUnits.size() &gt; 0) {</b>
<b class="nc">&nbsp;    		sb.append(&quot;&lt;font color=&#39;red&#39;&gt;Wrong unit type:&lt;/font&gt;\n\t&quot;);</b>
<b class="nc">&nbsp;    		sb.append(wrongUnits.stream().map(ms -&gt; ms.getName()).collect(Collectors.joining(&quot;\n\t&quot;)))</b>
<b class="nc">&nbsp;    			.append(&quot;&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	sb.append(&quot;Unit Roles:&lt;br/&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);</b>
<b class="nc">&nbsp;    	sb.append(units.stream().map(ms -&gt; ms.getName() + &quot;: &quot; + UnitRoleHandler.getRoleFor(ms))</b>
<b class="nc">&nbsp;    		.collect(Collectors.joining(&quot;&lt;br/&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;))).append(&quot;&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
<b class="nc">&nbsp;    	if (!idealRole.equals(UnitRole.UNDETERMINED)) {</b>
<b class="nc">&nbsp;    		sb.append(&quot;Ideal role: &quot;).append(idealRole.toString()).append(&quot;&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	if (weight.size() &lt; units.size()) {</b>
<b class="nc">&nbsp;    		sb.append(&quot;&lt;font color=&#39;red&#39;&gt;&quot;);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	sb.append(&quot;Weight class &quot;)</b>
<b class="nc">&nbsp;    		.append(EntityWeightClass.getClassName(Math.max(minWeightClass, EntityWeightClass.WEIGHT_LIGHT)))</b>
<b class="nc">&nbsp;    		.append(&quot;-&quot;)</b>
<b class="nc">&nbsp;    		.append(EntityWeightClass.getClassName(Math.min(maxWeightClass, EntityWeightClass.WEIGHT_ASSAULT)))</b>
<b class="nc">&nbsp;    		.append(&quot;&lt;br/&gt;\n&quot;);</b>
<b class="nc">&nbsp;    	if (weight.size() &lt; units.size()) {</b>
<b class="nc">&nbsp;    		sb.append(&quot;&lt;/font&gt;&quot;);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	if (weight.size() &gt; 0) {</b>
<b class="nc">&nbsp;    		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;).append(weight.stream().map(ms -&gt; ms.getName() + &quot;: &quot;</b>
<b class="nc">&nbsp;    				+ EntityWeightClass.getClassName(ms.getWeightClass()))</b>
<b class="nc">&nbsp;    				.collect(Collectors.joining(&quot;&lt;br/&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;))).append(&quot;&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;    	} else {
<b class="nc">&nbsp;    		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;None&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	if (mainDescription != null) {</b>
<b class="nc">&nbsp;        	if (main.size() &lt; units.size()) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&lt;font color=&#39;red&#39;&gt;&quot;);</b>
&nbsp;        	}
<b class="nc">&nbsp;        	sb.append(mainDescription).append(&quot; (&quot;).append(units.size()).append(&quot;)&lt;br/&gt;\n&quot;);</b>
<b class="nc">&nbsp;        	if (main.size() &lt; units.size()) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&lt;/font&gt;&quot;);</b>
&nbsp;        	}
<b class="nc">&nbsp;        	if (main.size() &gt; 0) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;).append(&quot;\t&quot;).append(main.stream().map(ms -&gt; ms.getName())</b>
<b class="nc">&nbsp;        				.collect(Collectors.joining(&quot;&lt;br/&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;))).append(&quot;&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;        	} else {
<b class="nc">&nbsp;        		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;None&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;        	}
&nbsp;    	}
<b class="nc">&nbsp;    	for (int i = 0; i &lt; otherCriteria.size(); i++) {</b>
<b class="nc">&nbsp;    		boolean isShort = false;</b>
<b class="nc">&nbsp;    		if (other.get(i).size() &lt; otherCriteria.get(i).getMinimum(units.size())) {</b>
<b class="nc">&nbsp;    			if (otherCriteria.get(i).isPairedWithNext()) {</b>
<b class="nc">&nbsp;    				isShort = i + 1 &lt; otherCriteria.size()</b>
<b class="nc">&nbsp;    						&amp;&amp; other.get(i + 1).size() &lt; otherCriteria.get(i + 1).getMinimum(units.size());</b>
<b class="nc">&nbsp;    			} else if (otherCriteria.get(i).isPairedWithPrevious()) {</b>
<b class="nc">&nbsp;    				isShort = i - 1 &gt; 0</b>
<b class="nc">&nbsp;    						&amp;&amp; other.get(i - 1).size() &lt; otherCriteria.get(i - 1).getMinimum(units.size());</b>
&nbsp;    			} else {
<b class="nc">&nbsp;    				isShort = true;</b>
&nbsp;    			}
&nbsp;    		}
<b class="nc">&nbsp;        	if (isShort) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&lt;font color=&#39;red&#39;&gt;&quot;);</b>
&nbsp;        	}
<b class="nc">&nbsp;        	if (otherCriteria.get(i).isPairedWithPrevious()) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&lt;b&gt;or&lt;/b&gt; &quot;);</b>
&nbsp;        	}
<b class="nc">&nbsp;    		sb.append(otherCriteria.get(i).description).append(&quot; (&quot;)</b>
<b class="nc">&nbsp;    			.append(otherCriteria.get(i).getMinimum(units.size())).append(&quot;)&quot;);</b>
<b class="nc">&nbsp;    		sb.append(&quot;&lt;br /&gt;\n&quot;);</b>
<b class="nc">&nbsp;        	if (isShort) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&lt;/font&gt;&quot;);</b>
&nbsp;        	}
<b class="nc">&nbsp;        	if (other.get(i).size() &gt; 0) {</b>
<b class="nc">&nbsp;        		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;).append(other.get(i).stream().map(ms -&gt; ms.getName())</b>
<b class="nc">&nbsp;        				.collect(Collectors.joining(&quot;&lt;br/&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;))).append(&quot;&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;        	} else {
<b class="nc">&nbsp;        		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;None&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;        	}
&nbsp;    	}
<b class="nc">&nbsp;    	if (groupingCriteria != null) {</b>
<b class="nc">&nbsp;			List&lt;MechSummary&gt; groupedUnits = units.stream()</b>
<b class="nc">&nbsp;					.filter(ms -&gt; groupingCriteria.appliesTo(ModelRecord.parseUnitType(ms.getUnitType())))</b>
<b class="nc">&nbsp;					.collect(Collectors.toList());</b>
<b class="nc">&nbsp;			if (groupedUnits.size() &gt; 0) {</b>
<b class="nc">&nbsp;				Map&lt;String,List&lt;MechSummary&gt;&gt; groups = groupedUnits.stream()</b>
<b class="nc">&nbsp;						.collect(Collectors.groupingBy(ms -&gt; ms.getChassis()));</b>
<b class="nc">&nbsp;				GROUP_LOOP: for (List&lt;MechSummary&gt; group : groups.values()) {</b>
<b class="nc">&nbsp;					for (int i = 0; i &lt; group.size() - 1; i++) {</b>
<b class="nc">&nbsp;						for (int j = i + 1; j &lt; group.size(); j++) {</b>
<b class="nc">&nbsp;							if (!groupingCriteria.matches(group.get(i), group.get(j))) {</b>
<b class="nc">&nbsp;								groups = groupedUnits.stream()</b>
<b class="nc">&nbsp;										.collect(Collectors.groupingBy(ms -&gt; ms.getName()));</b>
<b class="nc">&nbsp;								break GROUP_LOOP;</b>
&nbsp;							}
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				int groupSize = Math.min(groupingCriteria.getGroupSize(), groupedUnits.size());</b>
<b class="nc">&nbsp;		    	int numGroups = Math.min(groupingCriteria.getNumGroups(), groupedUnits.size() / groupSize);</b>
&nbsp;		    	/* Allow for the possibility that two or more groups may be identical */
<b class="nc">&nbsp;		    	int groupCount = 0;</b>
<b class="nc">&nbsp;		    	for (List&lt;MechSummary&gt; g : groups.values()) {</b>
<b class="nc">&nbsp;		    		groupCount += g.size() / groupSize;</b>
<b class="nc">&nbsp;		    	}</b>
<b class="nc">&nbsp;		    	if (groupCount &lt; numGroups) {</b>
<b class="nc">&nbsp;		    		sb.append(&quot;&lt;font color=&#39;red&#39;&gt;&quot;);</b>
&nbsp;		    	}
<b class="nc">&nbsp;		    	sb.append(groupingCriteria.getDescription()).append(&quot; (&quot;).append(numGroups)</b>
<b class="nc">&nbsp;		    		.append(&quot;x&quot;).append(groupSize).append(&quot;)&quot;);</b>
<b class="nc">&nbsp;		    	if (groupCount &lt; numGroups) {</b>
<b class="nc">&nbsp;		    		sb.append(&quot;&lt;/font&gt;&quot;);</b>
&nbsp;		    	}
<b class="nc">&nbsp;		    	sb.append(&quot;&lt;br/&gt;\n&quot;);</b>
<b class="nc">&nbsp;		    	if (groupCount &gt; 0) {</b>
<b class="nc">&nbsp;			    	for (String groupName : groups.keySet()) {</b>
<b class="nc">&nbsp;			    		int size = groups.get(groupName).size();</b>
<b class="nc">&nbsp;			    		while (size &gt;= groupSize) {</b>
<b class="nc">&nbsp;			    			sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;).append(groupName)</b>
<b class="nc">&nbsp;			    				.append(&quot; (&quot;).append(groupSize).append(&quot;)&lt;br/&gt;\n&quot;);</b>
<b class="nc">&nbsp;			    			size -= groupSize;</b>
&nbsp;			    		}
<b class="nc">&nbsp;			    	}</b>
&nbsp;	        	} else {
<b class="nc">&nbsp;	        		sb.append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;None&lt;br/&gt;&lt;br/&gt;\n&quot;);</b>
&nbsp;		    	}
&nbsp;			}
&nbsp;    	}
<b class="nc">&nbsp;    	sb.append(&quot;&lt;/html&gt;&quot;);</b>
<b class="nc">&nbsp;    	return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void createFormationTypes() {
<b class="nc">&nbsp;        allFormationTypes = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        createAntiMekLance();</b>
<b class="nc">&nbsp;        createAssaultLance();</b>
<b class="nc">&nbsp;        createAnvilLance();</b>
<b class="nc">&nbsp;        createFastAssaultLance();</b>
<b class="nc">&nbsp;        createHunterLance();</b>
<b class="nc">&nbsp;        createBattleLance();</b>
<b class="nc">&nbsp;        createLightBattleLance();</b>
<b class="nc">&nbsp;        createMediumBattleLance();</b>
<b class="nc">&nbsp;        createHeavyBattleLance();</b>
<b class="nc">&nbsp;        createRifleLance();</b>
<b class="nc">&nbsp;        createBerserkerLance();</b>
<b class="nc">&nbsp;        createCommandLance();</b>
<b class="nc">&nbsp;        createOrderLance();</b>
<b class="nc">&nbsp;        createVehicleCommandLance();</b>
<b class="nc">&nbsp;        createFireLance();</b>
<b class="nc">&nbsp;        createAntiAirLance();</b>
<b class="nc">&nbsp;        createArtilleryFireLance();</b>
<b class="nc">&nbsp;        createDirectFireLance();</b>
<b class="nc">&nbsp;        createFireSupportLance();</b>
<b class="nc">&nbsp;        createLightFireLance();</b>
<b class="nc">&nbsp;        createPursuitLance();</b>
<b class="nc">&nbsp;        createProbeLance();</b>
<b class="nc">&nbsp;        createSweepLance();</b>
<b class="nc">&nbsp;        createReconLance();</b>
<b class="nc">&nbsp;        createHeavyReconLance();</b>
<b class="nc">&nbsp;        createLightReconLance();</b>
<b class="nc">&nbsp;        createSecurityLance();</b>
<b class="nc">&nbsp;        createStrikerCavalryLance();</b>
<b class="nc">&nbsp;        createHammerLance();</b>
<b class="nc">&nbsp;        createHeavyStrikerCavalryLance();</b>
<b class="nc">&nbsp;        createHordeLance();</b>
<b class="nc">&nbsp;        createLightStrikerCavalryLance();</b>
<b class="nc">&nbsp;        createRangerLance();</b>
<b class="nc">&nbsp;        createUrbanLance();</b>
<b class="nc">&nbsp;        createAerospaceSuperioritySquadron();</b>
<b class="nc">&nbsp;        createEWSquadron();</b>
<b class="nc">&nbsp;        createFireSupportSquadron();</b>
<b class="nc">&nbsp;        createInterceptorSquadron();</b>
<b class="nc">&nbsp;        createStrikeSquadron();</b>
<b class="nc">&nbsp;        createTransportSquadron();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createAntiMekLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Anti-Mek&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_INFANTRY | FLAG_BATTLE_ARMOR;</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createAssaultLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Assault&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.JUGGERNAUT;</b>
<b class="nc">&nbsp;        ft.minWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getTotalArmor() &gt;= 135;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Armor 135+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; getDamageAtRange(ms, 7) &gt;= 25,</b>
&nbsp;                &quot;25 damage at range 7&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(3,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        Constraint c = new CountConstraint(1, ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.JUGGERNAUT),</b>
&nbsp;                &quot;Juggernaut&quot;);
<b class="nc">&nbsp;        c.setPairedWithNext(true);</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(c);</b>
<b class="nc">&nbsp;        c = new CountConstraint(2, ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.SNIPER),</b>
&nbsp;        		&quot;Sniper&quot;);
<b class="nc">&nbsp;        c.setPairedWithPrevious(true);</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(c);</b>
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Armor&quot;, ms -&gt; ms.getTotalArmor());</b>
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 7&quot;, ms -&gt; getDamageAtRange(ms, 7));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createAnvilLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Anvil&quot;, &quot;Assault&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.exclusiveFaction = &quot;FWL&quot;;</b>
<b class="nc">&nbsp;        ft.minWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getTotalArmor() &gt;= 40;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Armor 40+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getEquipmentNames().stream().map(name -&gt; EquipmentType.get(name))</b>
<b class="nc">&nbsp;                    .anyMatch(eq -&gt; eq instanceof ACWeapon</b>
&nbsp;                            || eq instanceof LBXACWeapon
&nbsp;                            || eq instanceof UACWeapon
&nbsp;                            || eq instanceof SRMWeapon
&nbsp;                            || eq instanceof LRMWeapon),
&nbsp;                &quot;AC, SRM, or LRM&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;AC/SRM/LRM&quot;, ms -&gt; ft.otherCriteria.get(0).criterion.test(ms));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createFastAssaultLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Fast Assault&quot;, &quot;Assault&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.minWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getTotalArmor() &gt;= 135</b>
<b class="nc">&nbsp;                &amp;&amp; (ms.getWalkMp() &gt;= 5 || ms.getJumpMp() &gt; 0);</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk 5+ or Jump 1+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; getDamageAtRange(ms, 7) &gt;= 25,</b>
&nbsp;                &quot;Damage 25+ at range 7&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(3,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
&nbsp;        //FIXME: The actual requirement is one juggernaut or two snipers; there needs to be
&nbsp;        // a way to combine constraints with ||.
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.JUGGERNAUT, UnitRole.SNIPER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Juggernaut or Sniper&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 7&quot;, ms -&gt; getDamageAtRange(ms, 7));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createHunterLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Hunter&quot;, &quot;Assault&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.AMBUSHER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.JUGGERNAUT, UnitRole.AMBUSHER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Juggernaut or Ambusher&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;        
&nbsp;    private static void createBattleLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Battle&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.BRAWLER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(3,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.BRAWLER, UnitRole.SNIPER, UnitRole.SKIRMISHER)</b>
<b class="nc">&nbsp;                    .contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                    &quot;Brawler, Sniper, Skirmisher&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_VEHICLE, 2, 2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() == EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                FormationType::checkUnitMatch,
&nbsp;                &quot;Same model, Heavy&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createLightBattleLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Light Battle&quot;, &quot;Battle&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_HEAVY;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() == EntityWeightClass.WEIGHT_LIGHT,</b>
&nbsp;                &quot;Light&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.SCOUT),</b>
&nbsp;                &quot;Scout&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_VEHICLE, 2, 2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() == EntityWeightClass.WEIGHT_LIGHT,</b>
&nbsp;                FormationType::checkUnitMatch, &quot;Same model, Light&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createMediumBattleLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Medium Battle&quot;, &quot;Battle&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_HEAVY;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() == EntityWeightClass.WEIGHT_MEDIUM,</b>
&nbsp;                &quot;Medium&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_VEHICLE, 2, 2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() == EntityWeightClass.WEIGHT_MEDIUM,</b>
&nbsp;                FormationType::checkUnitMatch, &quot;Same model, Medium&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createHeavyBattleLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Heavy Battle&quot;, &quot;Battle&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.minWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_VEHICLE, 2, 2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                FormationType::checkUnitMatch, &quot;Same model, Heavy+&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createRifleLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Rifle&quot;, &quot;Battle&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.exclusiveFaction = &quot;FS&quot;;</b>
<b class="nc">&nbsp;        ft.minWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 4;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 4+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &lt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Medium, Heavy&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getEquipmentNames().stream().map(name -&gt; EquipmentType.get(name))</b>
<b class="nc">&nbsp;                    .anyMatch(eq -&gt; eq instanceof ACWeapon</b>
&nbsp;                            || eq instanceof LBXACWeapon
&nbsp;                            || eq instanceof UACWeapon), //UAC includes RAC
&nbsp;                &quot;AC weapon&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;AC&quot;, ms -&gt; ft.otherCriteria.get(1).criterion.test(ms));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createBerserkerLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Berserker/Close&quot;, &quot;Battle&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_MEK | FLAG_PROTOMEK;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.BRAWLER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(3,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.BRAWLER, UnitRole.SNIPER, UnitRole.SKIRMISHER)</b>
<b class="nc">&nbsp;                    .contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Brawler, Sniper, Skirmisher&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createCommandLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Command&quot;, &quot;Command&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_MEK | FLAG_PROTOMEK;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SNIPER, UnitRole.MISSILE_BOAT, UnitRole.SKIRMISHER,</b>
&nbsp;                        UnitRole.JUGGERNAUT)
<b class="nc">&nbsp;                    .contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Sniper, Missile Boat, Skirmisher, Juggernaught&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.BRAWLER, UnitRole.STRIKER, UnitRole.SCOUT)</b>
<b class="nc">&nbsp;                    .contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Brawler, Striker, Scout&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createOrderLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Order&quot;, &quot;Command&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.exclusiveFaction = &quot;DC&quot;;</b>
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_GROUND, 0, 1,</b>
<b class="nc">&nbsp;                ms -&gt; true, FormationType::checkUnitMatch, &quot;Same model&quot;);</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createVehicleCommandLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Vehicle Command&quot;, &quot;Command&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_TANK | FLAG_VTOL | FLAG_NAVAL;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.BRAWLER, UnitRole.STRIKER, UnitRole.SCOUT)</b>
<b class="nc">&nbsp;                    .contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Brawler, Striker, Scout&quot;));
&nbsp;        /* The description does not state how many pairs there need to be, but the reference to
&nbsp;         * &quot;one of the pairs&quot; implies there need to be at least two.
&nbsp;         */
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_VEHICLE, 2, 2,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SNIPER, UnitRole.MISSILE_BOAT, UnitRole.SKIRMISHER,</b>
&nbsp;                        UnitRole.JUGGERNAUT)
<b class="nc">&nbsp;                    .contains(UnitRoleHandler.getRoleFor(ms)),</b>
<b class="nc">&nbsp;                    (ms0, ms1) -&gt; ms0.getName().equals(ms1.getName()),</b>
&nbsp;                &quot;Same model&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createFireLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Fire&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.MISSILE_BOAT;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SNIPER, UnitRole.MISSILE_BOAT).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Sniper, Missile Boat&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createAntiAirLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Anti-Air&quot;, &quot;Fire&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.missionRoles.add(MissionRole.MIXED_ARTILLERY);</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SNIPER, UnitRole.MISSILE_BOAT).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Sniper, Missile Boat&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
&nbsp;                // should indicate it has anti-aircraft targeting quirk without having to load all entities
<b class="nc">&nbsp;                ms -&gt; getMissionRoles(ms).contains(MissionRole.ANTI_AIRCRAFT) </b>
<b class="nc">&nbsp;                || ms.getEquipmentNames().stream().map(name -&gt; EquipmentType.get(name))</b>
<b class="nc">&nbsp;                    .anyMatch(eq -&gt; eq instanceof ACWeapon</b>
&nbsp;                            || eq instanceof LBXACWeapon
&nbsp;                            || eq instanceof ArtilleryWeapon),
&nbsp;                &quot;Standard AC, LBX, Artillery weapon, Anti-Air targeting quirk&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;AC/LBX/Artillery/AA Quirk&quot;, ms -&gt; ft.otherCriteria.get(1).criterion.test(ms));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createArtilleryFireLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Artillery Fire&quot;, &quot;Fire&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.missionRoles.add(MissionRole.MIXED_ARTILLERY);</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getEquipmentNames().stream().map(name -&gt; EquipmentType.get(name))</b>
<b class="nc">&nbsp;                    .anyMatch(eq -&gt; eq instanceof ArtilleryWeapon),</b>
&nbsp;                &quot;Artillery&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Artillery&quot;, ms -&gt; ft.otherCriteria.get(0).criterion.test(ms));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createDirectFireLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Direct Fire&quot;, &quot;Fire&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; getDamageAtRange(ms, 18) &gt;= 10;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Damage 10 at range 18&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 18&quot;, ms -&gt; getDamageAtRange(ms, 18));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createFireSupportLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Fire Support&quot;, &quot;Fire&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(3, ms -&gt; ms.getEquipmentNames().stream()</b>
<b class="nc">&nbsp;                .map(name -&gt; EquipmentType.get(name))</b>
<b class="nc">&nbsp;                .filter(eq -&gt; eq instanceof WeaponType &amp;&amp; eq.hasModes())</b>
<b class="nc">&nbsp;                .anyMatch(eq -&gt; {</b>
<b class="nc">&nbsp;                    for (Enumeration&lt;EquipmentMode&gt; e = eq.getModes(); e.hasMoreElements();) {</b>
<b class="nc">&nbsp;                        if (e.nextElement().toString().equals(&quot;Indirect&quot;)) {</b>
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }),
&nbsp;                &quot;Indirect fire weapon&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Indirect&quot;, ms -&gt; ft.otherCriteria.get(0).criterion.test(ms));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createLightFireLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Light Fire&quot;, &quot;Fire&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createPursuitLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Pursuit&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWalkMp() &gt;= 6,</b>
&nbsp;                &quot;Walk/Cruise 6+&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; getSingleWeaponDamageAtRange(ms, 15) &gt;= 5,</b>
&nbsp;                &quot;Weapon with damage 5+ at range 15&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 15&quot;, ms -&gt; getSingleWeaponDamageAtRange(ms, 15));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createProbeLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Probe&quot;, &quot;Pursuit&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_HEAVY;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; getDamageAtRange(ms, 9) &gt;= 10;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Damage 10+ at range 9&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.75,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWalkMp() &gt;= 6,</b>
&nbsp;                &quot;Walk/Cruise 6+&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 9&quot;, ms -&gt; getDamageAtRange(ms, 9));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createSweepLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Sweep&quot;, &quot;Pursuit&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 5</b>
<b class="nc">&nbsp;                &amp;&amp; getDamageAtRange(ms, 6) &gt;= 10;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 5+, Damage 10+ at range 6&quot;;</b>
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 6&quot;, ms -&gt; getDamageAtRange(ms, 6));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createReconLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Recon&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.SCOUT;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 5;        </b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 5+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SCOUT, UnitRole.STRIKER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Scout, Striker&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createHeavyReconLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Heavy Recon&quot;, &quot;Recon&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 4;        </b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 4+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWalkMp() &gt;= 5,</b>
&nbsp;                &quot;Walk/Cruise 5+&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.SCOUT),</b>
&nbsp;                &quot;Scout&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createLightReconLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Light Recon&quot;, &quot;Recon&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_LIGHT;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 6</b>
<b class="nc">&nbsp;                &amp;&amp; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.SCOUT);</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 6+, Scout&quot;;</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createSecurityLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Security&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SCOUT, UnitRole.STRIKER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Scout, Striker&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.SNIPER, UnitRole.MISSILE_BOAT).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Sniper, Missile Boat&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new MaxCountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_ASSAULT,</b>
&nbsp;                &quot;Not assault&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createStrikerCavalryLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Striker/Cavalry&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.STRIKER;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_HEAVY;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 5 || ms.getJumpMp() &gt;= 4;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 5+ or Jump 4+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.STRIKER, UnitRole.SKIRMISHER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Striker, Skirmisher&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createHammerLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Hammer&quot;, &quot;Striker/Cavalry&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.exclusiveFaction = &quot;FWL&quot;;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.STRIKER;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 5;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 5+&quot;;</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createHeavyStrikerCavalryLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Heavy Striker/Cavalry&quot;, &quot;Striker/Cavalry&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND_NO_LIGHT;</b>
<b class="nc">&nbsp;        ft.minWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 4;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 4+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(3,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWeightClass() &gt;= EntityWeightClass.WEIGHT_HEAVY,</b>
&nbsp;                &quot;Heavy+&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.STRIKER, UnitRole.SKIRMISHER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Striker, Skirmisher&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(1,</b>
<b class="nc">&nbsp;                ms -&gt; getSingleWeaponDamageAtRange(ms, 18) &gt;= 5,</b>
&nbsp;                &quot;Weapon with damage 5+ at range 18&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 18&quot;, ms -&gt; getSingleWeaponDamageAtRange(ms, 18));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createHordeLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Horde&quot;, &quot;Striker/Cavalry&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_LIGHT;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; getDamageAtRange(ms, 9) &lt;= 10;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Damage &lt;= 10 at range 9&quot;;</b>
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 9&quot;, ms -&gt; getDamageAtRange(ms, 9));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createLightStrikerCavalryLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Light Striker/Cavalry&quot;, &quot;Striker/Cavalry&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_MEDIUM;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; ms.getWalkMp() &gt;= 5;</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Walk/Cruise 5+&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; getSingleWeaponDamageAtRange(ms, 18) &gt;= 5,</b>
&nbsp;                &quot;Weapon with damage 5+ at range 18&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new CountConstraint(2,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.STRIKER, UnitRole.SKIRMISHER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Striker, Skirmisher&quot;));
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Damage @ 18&quot;, ms -&gt; getSingleWeaponDamageAtRange(ms, 18));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createRangerLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Ranger&quot;, &quot;Striker/Cavalry&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.maxWeightClass = EntityWeightClass.WEIGHT_HEAVY;</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createUrbanLance() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Urban&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_GROUND;</b>
<b class="nc">&nbsp;        ft.idealRole = UnitRole.AMBUSHER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getJumpMp() &gt; 0</b>
<b class="nc">&nbsp;                    || ms.getUnitType().equals(UnitType.getTypeName(UnitType.INFANTRY))</b>
<b class="nc">&nbsp;                    || ms.getUnitType().equals(UnitType.getTypeName(UnitType.BATTLE_ARMOR)),</b>
&nbsp;                &quot;Jump 1+ or Infantry/BA&quot;));
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getWalkMp() &lt;= 4,</b>
&nbsp;                &quot;Walk/Cruise &lt;= 4&quot;));
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);        </b>
&nbsp;    }
&nbsp;    
&nbsp;    private static void createAerospaceSuperioritySquadron() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Aerospace Superiority Squadron&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_FIGHTER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.51,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.INTERCEPTOR, UnitRole.FAST_DOGFIGHTER).contains(UnitRoleHandler.getRoleFor(ms)),</b>
&nbsp;                &quot;Interceptor/Fast Dogfighter&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_FIGHTER, 2, 0,</b>
<b class="nc">&nbsp;                ms -&gt; true,</b>
<b class="nc">&nbsp;                (ms0, ms1) -&gt; ms0.getChassis().equals(ms1.getChassis()),</b>
&nbsp;                &quot;Same chassis&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createEWSquadron() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Electronic Warfare Squadron&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_FIGHTER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.51,</b>
<b class="nc">&nbsp;                ms -&gt; ms.getEquipmentNames().stream().map(en -&gt; EquipmentType.get(en))</b>
<b class="nc">&nbsp;                .anyMatch(et -&gt; et instanceof TAGWeapon ||  </b>
&nbsp;                        (et instanceof MiscType &amp;&amp;
<b class="nc">&nbsp;                            (((MiscType)et).hasFlag(MiscType.F_BAP)</b>
<b class="nc">&nbsp;                            || ((MiscType)et).hasFlag(MiscType.F_ECM)))),</b>
&nbsp;                &quot;Probe, ECM, TAG&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_FIGHTER, 2, 0,</b>
<b class="nc">&nbsp;                ms -&gt; true,</b>
<b class="nc">&nbsp;                (ms0, ms1) -&gt; ms0.getChassis().equals(ms1.getChassis()),</b>
&nbsp;                &quot;Same chassis&quot;);
<b class="nc">&nbsp;        ft.reportMetrics.put(&quot;Probe/ECM/TAG&quot;, ms -&gt; ft.otherCriteria.get(0).criterion.test(ms));</b>
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);                </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createFireSupportSquadron() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Fire Support Squadron&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_FIGHTER;</b>
<b class="nc">&nbsp;        ft.mainCriteria = ms -&gt; EnumSet.of(UnitRole.FIRE_SUPPORT,</b>
<b class="nc">&nbsp;                UnitRole.DOGFIGHTER).contains(UnitRoleHandler.getRoleFor(ms));</b>
<b class="nc">&nbsp;        ft.mainDescription = &quot;Fire Support, Dogfighter&quot;;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.FIRE_SUPPORT),</b>
&nbsp;                &quot;Fire Support&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_FIGHTER, 2, 0,</b>
<b class="nc">&nbsp;                ms -&gt; true,</b>
<b class="nc">&nbsp;                (ms0, ms1) -&gt; ms0.getChassis().equals(ms1.getChassis()),</b>
&nbsp;                &quot;Same chassis&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);                </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createInterceptorSquadron() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Interceptor Squadron&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_FIGHTER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.51,</b>
<b class="nc">&nbsp;                ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.INTERCEPTOR),</b>
&nbsp;                &quot;Interceptor&quot;));
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_FIGHTER, 2, 0,</b>
<b class="nc">&nbsp;                ms -&gt; true,</b>
<b class="nc">&nbsp;                (ms0, ms1) -&gt; ms0.getChassis().equals(ms1.getChassis()),</b>
&nbsp;                &quot;Same chassis&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);                </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createStrikeSquadron() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Strike Squadron&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_FIGHTER;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.51,</b>
<b class="nc">&nbsp;                ms -&gt; EnumSet.of(UnitRole.ATTACK_FIGHTER,</b>
<b class="nc">&nbsp;                        UnitRole.DOGFIGHTER).contains(UnitRoleHandler.getRoleFor(ms)), &quot;Attack, Dogfighter&quot;));</b>
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_FIGHTER, 2, 0,</b>
<b class="nc">&nbsp;                ms -&gt; true,</b>
<b class="nc">&nbsp;                (ms0, ms1) -&gt; ms0.getChassis().equals(ms1.getChassis()),</b>
&nbsp;                &quot;Same chassis&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);                </b>
&nbsp;    }
&nbsp;
&nbsp;    private static void createTransportSquadron() {
<b class="nc">&nbsp;        FormationType ft = new FormationType(&quot;Transport Squadron&quot;);</b>
<b class="nc">&nbsp;        ft.allowedUnitTypes = FLAG_FIGHTER | FLAG_SMALL_CRAFT | FLAG_DROPSHIP;</b>
<b class="nc">&nbsp;        ft.otherCriteria.add(new PercentConstraint(0.5,</b>
<b class="nc">&nbsp;                ms -&gt; UnitRoleHandler.getRoleFor(ms).equals(UnitRole.TRANSPORT), &quot;Transport&quot;));</b>
<b class="nc">&nbsp;        ft.groupingCriteria = new GroupingConstraint(FLAG_FIGHTER, 2, Integer.MAX_VALUE,</b>
<b class="nc">&nbsp;                ms -&gt; true,</b>
<b class="nc">&nbsp;                (ms0, ms1) -&gt; ms0.getChassis().equals(ms1.getChassis()),</b>
&nbsp;                &quot;Same chassis&quot;);
<b class="nc">&nbsp;        allFormationTypes.put(ft.name, ft);                </b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function used by some grouping constraints to compare units. Units are considered to match
&nbsp;     * if they are the same model, but omnis can match with different configurations. This is used primarily
&nbsp;     * for ground units; aerospace units match based on chassis.
&nbsp;     * 
&nbsp;     * @param ms0
&nbsp;     * @param ms1
&nbsp;     * @return    Whether the two units are considered the same for grouping considerations.
&nbsp;     */
&nbsp;    private static boolean checkUnitMatch(final MechSummary ms0, final MechSummary ms1) {
<b class="nc">&nbsp;        final ModelRecord mRec = RATGenerator.getInstance().getModelRecord(ms0.getName());</b>
<b class="nc">&nbsp;        if (null != mRec &amp;&amp; mRec.isOmni()) {</b>
<b class="nc">&nbsp;            return ms0.getChassis().equals(ms1.getChassis());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return ms0.getName().equals(ms1.getName());</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * base class for limitations on formation type 
&nbsp;     */
&nbsp;    public static abstract class Constraint {
&nbsp;        Predicate&lt;MechSummary&gt; criterion;
&nbsp;        String description;
&nbsp;        boolean pairedWithNext;
&nbsp;        boolean pairedWithPrevious;
&nbsp;        
<b class="nc">&nbsp;        protected Constraint(Predicate&lt;MechSummary&gt; criterion, String description) {</b>
<b class="nc">&nbsp;            this.criterion = criterion;</b>
<b class="nc">&nbsp;            this.description = description;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public abstract int getMinimum(int unitSize);
&nbsp;        
&nbsp;        public String getDescription() {
<b class="nc">&nbsp;            return description;</b>
&nbsp;        }
&nbsp;        public boolean matches(MechSummary ms) {
<b class="nc">&nbsp;            return criterion.test(ms);</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* In cases where a constraint has multiple possible fulfillments requiring different
&nbsp;         * numbers of units (e.g. Assault requires one juggernaut or two snipers), they must
&nbsp;         * be assigned to separate Constraints consecutively in the list and marked with the
&nbsp;         * appropriate flag.
&nbsp;         */
&nbsp;        public boolean isPairedWithPrevious() {
<b class="nc">&nbsp;        	return pairedWithPrevious;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public void setPairedWithPrevious(boolean paired) {
<b class="nc">&nbsp;        	pairedWithPrevious = paired;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPairedWithNext() {
<b class="nc">&nbsp;        	return pairedWithNext;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public void setPairedWithNext(boolean paired) {
<b class="nc">&nbsp;        	pairedWithNext = paired;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public static class CountConstraint extends Constraint {
&nbsp;        int count;
&nbsp;        
&nbsp;        public CountConstraint(int min, Predicate&lt;MechSummary&gt; criterion, String description) {
<b class="nc">&nbsp;            super(criterion, description);</b>
<b class="nc">&nbsp;            count = min;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public int getMinimum(int unitSize) {
<b class="nc">&nbsp;            return count;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    private static class MaxCountConstraint extends CountConstraint {
&nbsp;        
&nbsp;        public MaxCountConstraint(int max, Predicate&lt;MechSummary&gt; criterion, String description) {
<b class="nc">&nbsp;            super(max, ms -&gt; !criterion.test(ms), description);</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public int getMinimum(int unitSize) {
<b class="nc">&nbsp;            return unitSize - count;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    private static class PercentConstraint extends Constraint {
&nbsp;        double pct;
&nbsp;        
&nbsp;        public PercentConstraint(double min, Predicate&lt;MechSummary&gt; criterion, String description) {
<b class="nc">&nbsp;            super(criterion, description);</b>
<b class="nc">&nbsp;            pct = min;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public int getMinimum(int unitSize) {
<b class="nc">&nbsp;            return (int)Math.ceil(pct * unitSize);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private static class MaxPercentConstraint extends PercentConstraint {
&nbsp;        
&nbsp;        public MaxPercentConstraint(double max, Predicate&lt;MechSummary&gt; criterion,
&nbsp;                String description) {
<b class="nc">&nbsp;            super(max, ms -&gt; !criterion.test(ms), description);</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public int getMinimum(int unitSize) {
<b class="nc">&nbsp;            return unitSize - (int)Math.ceil(pct * unitSize);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;     * Permits additional constraints applied to a specific subset of the units.
&nbsp;     * Used to force pairs (or larger groups) of units that are identical or have the same base
&nbsp;     * chassis.
&nbsp;     */
&nbsp;    public static class GroupingConstraint extends Constraint {
<b class="nc">&nbsp;        int unitTypes = FLAG_ALL;</b>
<b class="nc">&nbsp;        int groupSize = 2;</b>
<b class="nc">&nbsp;        int numGroups = 1;</b>
&nbsp;        BiFunction&lt;MechSummary,MechSummary,Boolean&gt; groupConstraint;
&nbsp;        String description;
&nbsp;        
&nbsp;        public GroupingConstraint(Predicate&lt;MechSummary&gt; generalConstraint,
&nbsp;                BiFunction&lt;MechSummary,MechSummary,Boolean&gt; groupConstraint,
&nbsp;                String description) {
<b class="nc">&nbsp;            super(generalConstraint, description);</b>
<b class="nc">&nbsp;            this.groupConstraint = groupConstraint;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public GroupingConstraint(int unitTypes,
&nbsp;                Predicate&lt;MechSummary&gt; generalConstraint,
&nbsp;                BiFunction&lt;MechSummary,MechSummary,Boolean&gt; groupConstraint,
&nbsp;                String description) {
<b class="nc">&nbsp;            this(generalConstraint, groupConstraint, description);</b>
<b class="nc">&nbsp;            this.unitTypes = unitTypes;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public GroupingConstraint(int unitTypes, int groupSize, int numGroups,
&nbsp;                Predicate&lt;MechSummary&gt; generalConstraint,
&nbsp;                BiFunction&lt;MechSummary,MechSummary,Boolean&gt; groupConstraint,
&nbsp;                String description) {
<b class="nc">&nbsp;            this(generalConstraint, groupConstraint, description);</b>
<b class="nc">&nbsp;            this.unitTypes = unitTypes;</b>
<b class="nc">&nbsp;            this.groupSize = groupSize;</b>
<b class="nc">&nbsp;            this.numGroups = numGroups;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public boolean appliesTo(int unitType) {
<b class="nc">&nbsp;            return ((1 &lt;&lt; unitType) &amp; unitTypes) != 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getNumGroups() {
<b class="nc">&nbsp;            return numGroups;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public int getGroupSize() {
<b class="nc">&nbsp;            return groupSize;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public boolean matches(MechSummary ms) {
<b class="nc">&nbsp;            return criterion == null || criterion.test(ms);</b>
&nbsp;        }
&nbsp;        
&nbsp;        public boolean matches(MechSummary ms1, MechSummary ms2) {
<b class="nc">&nbsp;            return groupConstraint.apply(ms1,  ms2);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getMinimum(int unitSize) {
<b class="nc">&nbsp;            int gs = Math.min(groupSize, unitSize);</b>
<b class="nc">&nbsp;            int ng = numGroups;</b>
<b class="nc">&nbsp;            if (gs &gt; 0) {</b>
<b class="nc">&nbsp;                ng = Math.min(ng, unitSize / gs);</b>
&nbsp;            }
<b class="nc">&nbsp;            return gs * ng;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public boolean hasGeneralCriteria() {
<b class="nc">&nbsp;            return criterion != null;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public GroupingConstraint copy() {
<b class="nc">&nbsp;            return new GroupingConstraint(this.unitTypes, this.groupSize, this.numGroups,</b>
&nbsp;                this.criterion, this.groupConstraint, this.description);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
