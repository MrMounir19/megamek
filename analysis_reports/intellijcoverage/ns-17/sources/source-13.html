


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Building</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: Building (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Building</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/248)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Building$BasementType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Building$DemolitionCharge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$0DM3zIKc</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$2eIlsRnq</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$3nk9pPZd</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$5ACycI3W</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$7DUhZ90u</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$9brMlFhw</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$AfamEQKC</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$cJpeK5PX</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$cPbDpMVk</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$eK5yIU5w</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$FBYQRaWp</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$h8BqV5Wa</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$je8eDbbI</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$Jl7yDCNG</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$jQNTH1sv</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$kpetcq0Y</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$kT3qXjF4</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$lUdHH5ev</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$M9HaFz7e</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$MB9vGycQ</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$MqsBKFjr</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$N08La9TE</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$nfDf6iEd</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$NKMg5QNo</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$nL1cgTTq</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$nTY1tgaO</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$ofs3yVhh</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$Pr65sY8n</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$QCbAgqI0</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$rHLDkXoT</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$tG50SXKM</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$v4Cbte3c</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$Wp8vEgja</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$WpvxIlr2</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$x73W0cwE</td>
  </tr>
  <tr>
    <td class="name">Building$MockitoMock$1348754008$auxiliary$Y6oSv9r6</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/49)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/279)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2000-2002 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2018 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.UUID;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;/**
&nbsp; * This class represents a single, possibly multi-hex building on the board.
&nbsp; *
&nbsp; * @author Suvarov454@sourceforge.net (James A. Damour )
&nbsp; * @version $Revision$
&nbsp; */
&nbsp;public class Building implements Serializable {
&nbsp;    private static final long serialVersionUID = -8236017592012683793L;
&nbsp;
&nbsp;    /**
&nbsp;     * Generic flag for uninitialized values.
&nbsp;     */
&nbsp;    protected static final int UNKNOWN = -1;
&nbsp;    
&nbsp;    // The Building Types
&nbsp;    public static final int LIGHT = 1;
&nbsp;    public static final int MEDIUM = 2;
&nbsp;    public static final int HEAVY = 3;
&nbsp;    public static final int HARDENED = 4;
&nbsp;    public static final int WALL = 5;
&nbsp;    
&nbsp;    /**
&nbsp;     * The Building Type of the building; equal to the terrain elevation of the BUILDING terrain of a hex.
&nbsp;     */
<b class="nc">&nbsp;    private int type = Building.UNKNOWN;</b>
&nbsp;    
&nbsp;    // The Building Classes
&nbsp;    public static final int STANDARD = 0;
&nbsp;    public static final int HANGAR = 1;
&nbsp;    public static final int FORTRESS = 2;
&nbsp;    public static final int GUN_EMPLACEMENT = 3;
&nbsp;    // TODO: leaving out Castles Brian until issues with damage scaling are resolved
&nbsp;    // public static final int CASTLE_BRIAN = 3;
&nbsp;    
&nbsp;    /**
&nbsp;     * The Building Class of the building; equal to the terrain elevation of the BUILDING CLASS terrain of a hex.
&nbsp;     */
<b class="nc">&nbsp;    private int bldgClass = Building.STANDARD;</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * The ID of this building.
&nbsp;     */
<b class="nc">&nbsp;    private int id = Building.UNKNOWN;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The coordinates of every hex of this building.
&nbsp;     */
<b class="nc">&nbsp;    private Vector&lt;Coords&gt; coordinates = new Vector&lt;Coords&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The Basement type of the building.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Coords,BasementType&gt; basement = new HashMap&lt;Coords,BasementType&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private int collapsedHexes = 0;</b>
&nbsp;
<b class="nc">&nbsp;    private int originalHexes = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The current construction factor of the building hexes. Any damage
&nbsp;     * immediately updates this value.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Coords, Integer&gt; currentCF = new HashMap&lt;Coords, Integer&gt;();</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * The construction factor of the building hexes at the start of this attack
&nbsp;     * phase. Damage that is received during the phase is applied at the end of
&nbsp;     * the phase.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Coords, Integer&gt; phaseCF = new HashMap&lt;Coords, Integer&gt;();</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * The current armor of the building hexes.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Coords, Integer&gt; armor = new HashMap&lt;Coords, Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The current state of the basement.
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Coords, Boolean&gt; basementCollapsed = new HashMap&lt;Coords, Boolean&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the building.
&nbsp;     */
<b class="nc">&nbsp;    private String name = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that indicates whether this building is burning
&nbsp;     */
<b class="nc">&nbsp;    private Map&lt;Coords, Boolean&gt; burning = new HashMap&lt;Coords, Boolean&gt;();</b>
&nbsp;
&nbsp;    public class DemolitionCharge implements Serializable {
&nbsp;        /**
&nbsp;         *
&nbsp;         */
&nbsp;        private static final long serialVersionUID = -6655782801564155668L;
&nbsp;        public int damage;
&nbsp;        public int playerId;
&nbsp;        public Coords pos;
&nbsp;        /**
&nbsp;         * A UUID to keep track of the identify of this demolition charge.
&nbsp;         * Since we could have multiple charges in the same building hex, we
&nbsp;         * can&#39;t track identity based upon owner and damage.  Additionally,
&nbsp;         * since we pass objects across the network, we need a mechanism to
&nbsp;         * track identify other than memory address.
&nbsp;         */
<b class="nc">&nbsp;        public UUID uuid = UUID.randomUUID();</b>
&nbsp;
<b class="nc">&nbsp;        public DemolitionCharge(int playerId, int damage, Coords p) {</b>
<b class="nc">&nbsp;            this.damage = damage;</b>
<b class="nc">&nbsp;            this.playerId = playerId;</b>
<b class="nc">&nbsp;            this.pos = p;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return uuid.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="nc">&nbsp;            if (o instanceof DemolitionCharge) {</b>
<b class="nc">&nbsp;                return uuid.equals(((DemolitionCharge)o).uuid);</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private List&lt;DemolitionCharge&gt; demolitionCharges = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Update this building to include the new hex (and all hexes off the new
&nbsp;     * hex, which aren&#39;t already included).
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the new hex.
&nbsp;     * @param board
&nbsp;     *            - the game&#39;s &lt;code&gt;IBoard&lt;/code&gt; object.
&nbsp;     * @exception an
&nbsp;     *                &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown if
&nbsp;     *                the given coordinates do not contain a building, or if the
&nbsp;     *                building covers multiple hexes with different CF.
&nbsp;     */
&nbsp;    protected void include(Coords coords, IBoard board, int structureType) {
&nbsp;
&nbsp;        // If the hex is already in the building, we&#39;ve covered it before.
<b class="nc">&nbsp;        if (isIn(coords)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the nextHex hex.
<b class="nc">&nbsp;        IHex nextHex = board.getHex(coords);</b>
<b class="nc">&nbsp;        if ((null == nextHex) || !(nextHex.containsTerrain(structureType))) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (structureType == Terrains.BUILDING) {</b>
&nbsp;            // Error if the Building Type (Light, Medium...) or Building Class (Standard, Hangar...) is off.
<b class="nc">&nbsp;            if (type != nextHex.terrainLevel(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;The coordinates, &quot;</b>
<b class="nc">&nbsp;                        + coords.getBoardNum()</b>
&nbsp;                        + &quot;, should contain the same type of building as &quot;
<b class="nc">&nbsp;                        + coordinates.elementAt(0).getBoardNum());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (bldgClass != nextHex.terrainLevel(Terrains.BLDG_CLASS)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;The coordinates, &quot;</b>
<b class="nc">&nbsp;                        + coords.getBoardNum()</b>
&nbsp;                        + &quot;, should contain the same class of building as &quot;
<b class="nc">&nbsp;                        + coordinates.elementAt(0).getBoardNum());</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;        // We passed our tests, add the next hex to this building.
<b class="nc">&nbsp;        coordinates.addElement(coords);</b>
<b class="nc">&nbsp;        originalHexes++;</b>
<b class="nc">&nbsp;        currentCF.put(coords, nextHex.terrainLevel(Terrains.BLDG_CF));</b>
<b class="nc">&nbsp;        phaseCF.put(coords, nextHex.terrainLevel(Terrains.BLDG_CF));</b>
<b class="nc">&nbsp;        basement.put(coords, BasementType.getType(nextHex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)));</b>
<b class="nc">&nbsp;        basementCollapsed.put(coords, nextHex.terrainLevel(Terrains.BLDG_BASE_COLLAPSED) == 1);</b>
<b class="nc">&nbsp;        if (structureType == Terrains.BRIDGE) {</b>
<b class="nc">&nbsp;            currentCF.put(coords, nextHex.terrainLevel(Terrains.BRIDGE_CF));</b>
<b class="nc">&nbsp;            phaseCF.put(coords, nextHex.terrainLevel(Terrains.BRIDGE_CF));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (structureType == Terrains.FUEL_TANK) {</b>
<b class="nc">&nbsp;            currentCF.put(coords, nextHex.terrainLevel(Terrains.FUEL_TANK_CF));</b>
<b class="nc">&nbsp;            phaseCF.put(coords, nextHex.terrainLevel(Terrains.FUEL_TANK_CF));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (nextHex.containsTerrain(Terrains.BLDG_ARMOR)) {</b>
<b class="nc">&nbsp;            armor.put(coords, nextHex.terrainLevel(Terrains.BLDG_ARMOR));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            armor.put(coords, 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        burning.put(coords, false);</b>
&nbsp;
&nbsp;        // Walk through the exit directions and
&nbsp;        // identify all hexes in this building.
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
&nbsp;
&nbsp;            // Does the building exit in this direction?
<b class="nc">&nbsp;            if (nextHex.containsTerrainExit(structureType, dir)) {</b>
<b class="nc">&nbsp;                include(coords.translated(dir), board, structureType);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    } // End void protected include( Coords, Board )</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Basement handlers
&nbsp;     */
<b class="nc">&nbsp;    public enum BasementType {</b>
<b class="nc">&nbsp;        UNKNOWN(0,0, Messages.getString(&quot;Building.BasementUnknown&quot;)),</b>
<b class="nc">&nbsp;        NONE(1,0, Messages.getString(&quot;Building.BasementNone&quot;)),</b>
<b class="nc">&nbsp;        TWO_DEEP_FEET(2,2,Messages.getString(&quot;Building.BasementTwoDeepFeet&quot;)),</b>
<b class="nc">&nbsp;        ONE_DEEP_FEET(3,1,Messages.getString(&quot;Building.BasementOneDeepFeet&quot;)),</b>
<b class="nc">&nbsp;        ONE_DEEP_NORMAL(4,1,Messages.getString(&quot;Building.BasementOneDeepNormal&quot;)),</b>
<b class="nc">&nbsp;        ONE_DEEP_NORMALINFONLY(5,1,Messages.getString(&quot;Building.BasementOneDeepNormalInfOnly&quot;)),</b>
<b class="nc">&nbsp;        ONE_DEEP_HEAD(6,1,Messages.getString(&quot;Building.BasementOneDeepHead&quot;)),</b>
<b class="nc">&nbsp;        TWO_DEEP_HEAD(7,2,Messages.getString(&quot;Building.BasementTwoDeepHead&quot;));</b>
&nbsp;
&nbsp;        private int value;
&nbsp;        private int depth;
&nbsp;        private String desc;
&nbsp;
<b class="nc">&nbsp;        BasementType(int type, int depth, String desc) {</b>
<b class="nc">&nbsp;            value = type;</b>
<b class="nc">&nbsp;            this.depth = depth;</b>
<b class="nc">&nbsp;            this.desc = desc;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int getValue() {
<b class="nc">&nbsp;            return value;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getDepth() {
<b class="nc">&nbsp;            return depth;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getDesc() {
<b class="nc">&nbsp;            return desc;</b>
&nbsp;        }
&nbsp;
&nbsp;        public static BasementType getType(int value) {
<b class="nc">&nbsp;            for (BasementType type : BasementType.values()) {</b>
<b class="nc">&nbsp;                if (type.getValue() == value) {</b>
<b class="nc">&nbsp;                    return type;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return UNKNOWN;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a building for the given coordinates from the board&#39;s
&nbsp;     * information. If the building covers multiple hexes, every hex will be
&nbsp;     * included in the building.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of a hex of the building. If the
&nbsp;     *            building covers multiple hexes, this constructor will include
&nbsp;     *            them all in this building automatically.
&nbsp;     * @param board
&nbsp;     *            - the game&#39;s &lt;code&gt;Board&lt;/code&gt; object.
&nbsp;     * @exception an
&nbsp;     *                &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown if
&nbsp;     *                the given coordinates do not contain a building, or if the
&nbsp;     *                building covers multiple hexes with different CFs.
&nbsp;     */
<b class="nc">&nbsp;    public Building(Coords coords, IBoard board, int structureType, BasementType basementType) {</b>
&nbsp;
&nbsp;        // The ID of the building will be deterministic based on the
&nbsp;        // position of its first hex. 9,999 hexes in the Y direction
&nbsp;        // ought to be enough for anyone.
&nbsp;        //
&nbsp;        // ASSUMPTION: this will be unique ID across ALL the building&#39;s
&nbsp;        // hexes for ALL the clients of this board.
<b class="nc">&nbsp;        id = coords.getX() * 10000 + coords.getY();</b>
&nbsp;
&nbsp;        // The building occupies the given coords, at least.
<b class="nc">&nbsp;        coordinates.addElement(coords);</b>
<b class="nc">&nbsp;        originalHexes++;</b>
&nbsp;
<b class="nc">&nbsp;        burning.put(coords, false);</b>
&nbsp;
&nbsp;        // Get the Hex for those coords.
<b class="nc">&nbsp;        IHex startHex = board.getHex(coords);</b>
&nbsp;
&nbsp;        // Read our construction type from the hex.
<b class="nc">&nbsp;        if (!startHex.containsTerrain(structureType)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The coordinates, &quot;</b>
<b class="nc">&nbsp;                    + coords.getBoardNum() + &quot;, do not contain a building.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        type = startHex.terrainLevel(structureType);</b>
<b class="nc">&nbsp;        bldgClass = startHex.terrainLevel(Terrains.BLDG_CLASS);</b>
&nbsp;
&nbsp;        // Insure that we&#39;ve got a good type (and initialize our CF).
<b class="nc">&nbsp;        currentCF.put(coords, getDefaultCF(type));</b>
<b class="nc">&nbsp;        if (currentCF.get(coords) == Building.UNKNOWN) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Unknown construction type: &quot;</b>
&nbsp;                    + type + &quot;.  The board is invalid.&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // Now read the *real* CF, if the board specifies one.
<b class="nc">&nbsp;        if ((structureType == Terrains.BUILDING)</b>
<b class="nc">&nbsp;                &amp;&amp; startHex.containsTerrain(Terrains.BLDG_CF)) {</b>
<b class="nc">&nbsp;            currentCF.put(coords, startHex.terrainLevel(Terrains.BLDG_CF));</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((structureType == Terrains.BRIDGE)</b>
<b class="nc">&nbsp;                &amp;&amp; startHex.containsTerrain(Terrains.BRIDGE_CF)) {</b>
<b class="nc">&nbsp;            currentCF.put(coords, startHex.terrainLevel(Terrains.BRIDGE_CF));</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((structureType == Terrains.FUEL_TANK)</b>
<b class="nc">&nbsp;                &amp;&amp; startHex.containsTerrain(Terrains.FUEL_TANK_CF)) {</b>
<b class="nc">&nbsp;            currentCF.put(coords, startHex.terrainLevel(Terrains.FUEL_TANK_CF));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (startHex.containsTerrain(Terrains.BLDG_ARMOR)) {</b>
<b class="nc">&nbsp;            armor.put(coords, startHex.terrainLevel(Terrains.BLDG_ARMOR));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            armor.put(coords, 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        phaseCF.putAll(currentCF);</b>
&nbsp;
<b class="nc">&nbsp;        basement.put(coords, basementType);</b>
<b class="nc">&nbsp;        basementCollapsed.put(coords, startHex.terrainLevel(Terrains.BLDG_BASE_COLLAPSED) == 1);</b>
&nbsp;
&nbsp;        // Walk through the exit directions and
&nbsp;        // identify all hexes in this building.
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
&nbsp;
&nbsp;            // Does the building exit in this direction?
<b class="nc">&nbsp;            if (startHex.containsTerrainExit(structureType, dir)) {</b>
<b class="nc">&nbsp;                include(coords.translated(dir), board, structureType);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // Set the building&#39;s name.
<b class="nc">&nbsp;        StringBuffer buffer = new StringBuffer();</b>
<b class="nc">&nbsp;        if (structureType == Terrains.FUEL_TANK) {</b>
<b class="nc">&nbsp;            buffer.append(&quot;Fuel Tank #&quot;);</b>
<b class="nc">&nbsp;        } else if (getType() == Building.WALL) {</b>
<b class="nc">&nbsp;            buffer.append(&quot;Wall #&quot;);</b>
<b class="nc">&nbsp;        } else if (structureType == Terrains.BUILDING) {</b>
<b class="nc">&nbsp;            buffer.append(&quot;Building #&quot;);</b>
<b class="nc">&nbsp;        } else if (structureType == Terrains.BRIDGE) {</b>
<b class="nc">&nbsp;            buffer.append(&quot;Bridge #&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            buffer.append(&quot;Structure #&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        buffer.append(id);</b>
<b class="nc">&nbsp;        name = buffer.toString();</b>
&nbsp;
<b class="nc">&nbsp;    } // End public Building( Coords, Board )</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the ID of this building. The same ID applies to all hexes.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of the building.
&nbsp;     */
&nbsp;    public int getId() {
<b class="nc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the building occupies given coordinates. Multi-hex buildings
&nbsp;     * will occupy multiple coordinates. Only one building per hex.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being examined.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the building occupies the coordinates.
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public boolean isIn(Coords coords) {
<b class="nc">&nbsp;        return coordinates.contains(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determins if the coord exist in the currentCF has.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being examined.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the building has CF at the coordinates.
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public boolean hasCFIn(Coords coords) {
<b class="nc">&nbsp;        return currentCF.containsKey(coords);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the coordinates that the building occupies.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the &lt;code&gt;Coord&lt;/code&gt; objects.
&nbsp;     */
&nbsp;    public Enumeration&lt;Coords&gt; getCoords() {
<b class="nc">&nbsp;        return coordinates.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the construction type of the building. This value will be one of the
&nbsp;     * constants, LIGHT, MEDIUM, HEAVY, or HARDENED.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; code of the building&#39;s construction type.
&nbsp;     */
&nbsp;    public int getType() {
<b class="nc">&nbsp;        return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the building class, per TacOps rules.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; code of the building&#39;s classification.
&nbsp;     */
&nbsp;    public int getBldgClass() {
<b class="nc">&nbsp;        return bldgClass;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the building basement, per TacOps rules.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; code of the buildingbasement type.
&nbsp;     */
&nbsp;    public boolean getBasementCollapsed(Coords coords) {
<b class="nc">&nbsp;        return basementCollapsed.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void collapseBasement(Coords coords, IBoard board,
&nbsp;            Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        if ((basement.get(coords) == BasementType.NONE) || (basement.get(coords) == BasementType.ONE_DEEP_NORMALINFONLY)) {</b>
<b class="nc">&nbsp;            System.err.println(&quot;hex has no basement to collapse&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (basementCollapsed.get(coords)) {</b>
<b class="nc">&nbsp;            System.err.println(&quot;hex has basement that already collapsed&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        Report r = new Report(2112, Report.PUBLIC);</b>
<b class="nc">&nbsp;        r.add(getName());</b>
<b class="nc">&nbsp;        r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;        System.err.println(&quot;basement &quot; + basement + &quot;is collapsing, hex:&quot;</b>
<b class="nc">&nbsp;                + coords.toString() + &quot; set terrain!&quot;);</b>
<b class="nc">&nbsp;        board.getHex(coords).addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                Terrains.BLDG_BASE_COLLAPSED, 1));
<b class="nc">&nbsp;        basementCollapsed.put(coords, true);</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Roll what kind of basement this building has
&nbsp;     * @param coords the &lt;code&gt;Coords&lt;/code&gt; of theb building to roll for
&nbsp;     * @param vPhaseReport the &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing the phasereport
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; indicating wether the hex and building was changed or not
&nbsp;     */
&nbsp;    public boolean rollBasement(Coords coords, IBoard board, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        if (basement.get(coords) == BasementType.UNKNOWN) {</b>
<b class="nc">&nbsp;            IHex hex = board.getHex(coords);</b>
<b class="nc">&nbsp;            Report r = new Report(2111, Report.PUBLIC);</b>
<b class="nc">&nbsp;            r.add(getName());</b>
<b class="nc">&nbsp;            r.add(coords.getBoardNum());</b>
<b class="nc">&nbsp;            int basementRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            r.add(basementRoll);</b>
<b class="nc">&nbsp;            if (basementRoll == 2) {</b>
<b class="nc">&nbsp;                basement.put(coords, BasementType.TWO_DEEP_FEET);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
<b class="nc">&nbsp;            } else if (basementRoll == 3) {</b>
<b class="nc">&nbsp;                basement.put(coords, BasementType.ONE_DEEP_FEET);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
<b class="nc">&nbsp;            } else if (basementRoll == 4) {</b>
<b class="nc">&nbsp;                basement.put(coords, BasementType.ONE_DEEP_NORMAL);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
<b class="nc">&nbsp;            } else if (basementRoll == 10) {</b>
<b class="nc">&nbsp;                basement.put(coords, BasementType.ONE_DEEP_NORMAL);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
<b class="nc">&nbsp;            } else if (basementRoll == 11) {</b>
<b class="nc">&nbsp;                basement.put(coords, BasementType.ONE_DEEP_HEAD);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
<b class="nc">&nbsp;            } else if (basementRoll == 12) {</b>
<b class="nc">&nbsp;                basement.put(coords, BasementType.TWO_DEEP_HEAD);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                basement.put(coords, BasementType.NONE);</b>
<b class="nc">&nbsp;                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
<b class="nc">&nbsp;                        Terrains.BLDG_BASEMENT_TYPE, basement.get(coords).getValue()));</b>
&nbsp;            }
<b class="nc">&nbsp;            r.add(BasementType.getType(hex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)).desc);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the current construction factor of the building hex at the passed
&nbsp;     * coords. Any damage immediately updates this value.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&gt; of the hex in question
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; value of the building hex&#39;s current
&nbsp;     *         construction factor. This value will be greater than or equal to
&nbsp;     *         zero.
&nbsp;     */
&nbsp;    public int getCurrentCF(Coords coords) {
<b class="nc">&nbsp;        return currentCF.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the construction factor of the building hex at the passed coords at
&nbsp;     * the start of the current phase. Damage that is received during the phase
&nbsp;     * is applied at the end of the phase.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&gt; of the hex in question
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; value of the building&#39;s construction factor
&nbsp;     *         at the start of this phase. This value will be greater than or
&nbsp;     *         equal to zero.
&nbsp;     */
&nbsp;    public int getPhaseCF(Coords coords) {
<b class="nc">&nbsp;        return phaseCF.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getArmor(Coords coords) {
<b class="nc">&nbsp;        return armor.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the current construction factor of the building hex. Call this method
&nbsp;     * immediately when the building sustains any damage.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&gt; of the hex in question
&nbsp;     * @param cf
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; value of the building hex&#39;s current
&nbsp;     *            construction factor. This value must be greater than or equal
&nbsp;     *            to zero.
&nbsp;     * @exception If
&nbsp;     *                the passed value is less than zero, an
&nbsp;     *                &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
&nbsp;     */
&nbsp;    public void setCurrentCF(int cf, Coords coords) {
<b class="nc">&nbsp;        if (cf &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Invalid value for Construction Factor: &quot; + cf);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        currentCF.put(coords, cf);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set the construction factor of the building hex for the start of the next
&nbsp;     * phase. Call this method at the end of the phase to apply damage sustained
&nbsp;     * by the building during the phase.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&gt; of the hex in question
&nbsp;     * @param cf
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; value of the building&#39;s current
&nbsp;     *            construction factor. This value must be greater than or equal
&nbsp;     *            to zero.
&nbsp;     * @exception If
&nbsp;     *                the passed value is less than zero, an
&nbsp;     *                &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
&nbsp;     */
&nbsp;    public void setPhaseCF(int cf, Coords coords) {
<b class="nc">&nbsp;        if (cf &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Invalid value for Construction Factor: &quot; + cf);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        phaseCF.put(coords, cf);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setArmor(int a, Coords coords) {
<b class="nc">&nbsp;        if (a &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Invalid value for armor: &quot; + a);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        armor.put(coords, a);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the name of this building.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;String&lt;/code&gt; name of this building.
&nbsp;     */
&nbsp;    public String getName() {
<b class="nc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the default construction factor for the given type of building.
&nbsp;     *
&nbsp;     * @param type
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; construction type of the building.
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; default construction factor for that type of
&nbsp;     *         building. If a bad type value is passed, the constant
&nbsp;     *         &lt;code&gt;Building.UNKNOWN&lt;/code&gt; will be returned instead.
&nbsp;     */
&nbsp;    public static int getDefaultCF(int type) {
<b class="nc">&nbsp;        int retval = Building.UNKNOWN;</b>
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case Building.LIGHT:
<b class="nc">&nbsp;                retval = 15;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.MEDIUM:
<b class="nc">&nbsp;                retval = 40;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.HEAVY:
<b class="nc">&nbsp;                retval = 90;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.HARDENED:
&nbsp;            case Building.WALL:
<b class="nc">&nbsp;                retval = 120;</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return retval;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override &lt;code&gt;Object#equals(Object)&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param obj
&nbsp;     *            - the other &lt;code&gt;Object&lt;/code&gt; to compare to this
&nbsp;     *            &lt;code&gt;Building&lt;/code&gt;.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the other object is the same as this
&nbsp;     *         &lt;code&gt;Building&lt;/code&gt;. The value &lt;code&gt;false&lt;/code&gt; will be
&nbsp;     *         returned if the other object is &lt;code&gt;null&lt;/code&gt;, is not a
&nbsp;     *         &lt;code&gt;Buildig&lt;/code&gt;, or if it is not the same as this
&nbsp;     *         &lt;code&gt;Building&lt;/code&gt;.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="nc">&nbsp;        if(this == obj) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if(!(obj instanceof Building)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // True until we&#39;re talking about more than one Board per Game.
<b class="nc">&nbsp;        final Building other = (Building) obj;</b>
<b class="nc">&nbsp;        return (id == other.id);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="nc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get a String for this building.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;
&nbsp;        // Assemble the string in pieces.
<b class="nc">&nbsp;        StringBuffer buf = new StringBuffer();</b>
&nbsp;
&nbsp;        // Add the building type to the buffer.
<b class="nc">&nbsp;        switch (getType()) {</b>
&nbsp;            case Building.LIGHT:
<b class="nc">&nbsp;                buf.append(&quot;Light &quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.MEDIUM:
<b class="nc">&nbsp;                buf.append(&quot;Medium &quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.HEAVY:
<b class="nc">&nbsp;                buf.append(&quot;Heavy &quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.HARDENED:
<b class="nc">&nbsp;                buf.append(&quot;Hardened &quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.WALL:
<b class="nc">&nbsp;                buf.append(&quot;&quot;);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (getBldgClass()) {</b>
&nbsp;            case Building.HANGAR:
<b class="nc">&nbsp;                buf.append(&quot;Hangar &quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.FORTRESS:
<b class="nc">&nbsp;                buf.append(&quot;Fortress &quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.GUN_EMPLACEMENT:
<b class="nc">&nbsp;                buf.append(&quot;Gun Emplacement&quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            // case Building.CASTLE_BRIAN:
&nbsp;            // buf.append(&quot;Castle Brian &quot;);
&nbsp;            // break;
&nbsp;            default:
<b class="nc">&nbsp;                buf.append(&quot;Standard &quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Add the building&#39;s name.
<b class="nc">&nbsp;        buf.append(name);</b>
&nbsp;
&nbsp;        // Return the string.
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this building is on fire.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the building is on fire.
&nbsp;     */
&nbsp;    public boolean isBurning(Coords coords) {
<b class="nc">&nbsp;        return burning.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the flag that indicates that this building is on fire.
&nbsp;     *
&nbsp;     * @param onFire
&nbsp;     *            - a &lt;code&gt;boolean&lt;/code&gt; value that indicates whether this
&nbsp;     *            building is on fire.
&nbsp;     */
&nbsp;    public void setBurning(boolean onFire, Coords coords) {
<b class="nc">&nbsp;        burning.put(coords, onFire);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addDemolitionCharge(int playerId, int damage, Coords pos) {
<b class="nc">&nbsp;        DemolitionCharge charge = new DemolitionCharge(playerId, damage, pos);</b>
<b class="nc">&nbsp;        demolitionCharges.add(charge);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeDemolitionCharge(DemolitionCharge charge) {
<b class="nc">&nbsp;        demolitionCharges.remove(charge);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public List&lt;DemolitionCharge&gt; getDemolitionCharges() {
<b class="nc">&nbsp;        return demolitionCharges;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDemolitionCharges(List&lt;DemolitionCharge&gt; charges) {
<b class="nc">&nbsp;        demolitionCharges = charges;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Remove one building hex from the building
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the hex to be removed
&nbsp;     */
&nbsp;    public void removeHex(Coords coords) {
<b class="nc">&nbsp;        coordinates.remove(coords);</b>
<b class="nc">&nbsp;        currentCF.remove(coords);</b>
<b class="nc">&nbsp;        phaseCF.remove(coords);</b>
<b class="nc">&nbsp;        collapsedHexes++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOriginalHexCount() {
<b class="nc">&nbsp;        return originalHexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getCollapsedHexCount() {
<b class="nc">&nbsp;        return collapsedHexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return the damage scale multiplier for units passing through this
&nbsp;     *         building
&nbsp;     */
&nbsp;    public double getDamageFromScale() {
<b class="nc">&nbsp;        switch (getBldgClass()) {</b>
&nbsp;            case Building.HANGAR:
<b class="nc">&nbsp;                return 0.5;</b>
&nbsp;            case Building.FORTRESS:
&nbsp;            case Building.GUN_EMPLACEMENT:
<b class="nc">&nbsp;                return 2.0;</b>
&nbsp;                // case Building.CASTLE_BRIAN:
&nbsp;                // return 10.0;
&nbsp;            default:
<b class="nc">&nbsp;                return 1.0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return the damage scale multiplier for damage applied to this building
&nbsp;     *         (and occupants)
&nbsp;     */
&nbsp;    public double getDamageToScale() {
<b class="nc">&nbsp;        switch (getBldgClass()) {</b>
&nbsp;            case Building.FORTRESS:
&nbsp;            case Building.GUN_EMPLACEMENT:
<b class="nc">&nbsp;                return 0.5;</b>
&nbsp;                // case Building.CASTLE_BRIAN:
&nbsp;                // return 0.1;
&nbsp;            default:
<b class="nc">&nbsp;                return 1.0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return the amount of damage the building absorbs
&nbsp;     */
&nbsp;    public int getAbsorbtion(Coords pos) {
&nbsp;        // if(getBldgClass() == Building.CASTLE_BRIAN) {
&nbsp;        // return (int) Math.ceil(getPhaseCF(pos));
&nbsp;        // }
<b class="nc">&nbsp;        return (int) Math.ceil(getPhaseCF(pos) / 10.0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the percentage of damage done to the building for attacks against
&nbsp;     * infantry in the building from other units within the building.  TW pg175.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public double getInfDmgFromInside() {
<b class="nc">&nbsp;         switch (getType()) {</b>
&nbsp;            case Building.LIGHT:
&nbsp;            case Building.MEDIUM:
<b class="nc">&nbsp;                return 0.0;</b>
&nbsp;            case Building.HEAVY:
<b class="nc">&nbsp;                return 0.5;</b>
&nbsp;            case Building.HARDENED:
<b class="nc">&nbsp;                return 0.75;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Per page 172 of Total Warfare, this is the fraction of a weapon&#39;s damage that
&nbsp;     * passes through to infantry inside the building.
&nbsp;     * @return Damage fraction.
&nbsp;     */
&nbsp;    public float getDamageReductionFromOutside() {
<b class="nc">&nbsp;        switch (getType()) {</b>
&nbsp;            case Building.LIGHT:
<b class="nc">&nbsp;                return 0.75f;</b>
&nbsp;            case Building.MEDIUM:
<b class="nc">&nbsp;                return 0.5f;</b>
&nbsp;            case Building.HEAVY:
<b class="nc">&nbsp;                return 0.25f;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return 0f;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public BasementType getBasement(Coords coords) {
<b class="nc">&nbsp;        return basement.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setBasement(Coords coords, BasementType basement) {
<b class="nc">&nbsp;        this.basement.put(coords, basement);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setBasementCollapsed(Coords coords, boolean collapsed) {
<b class="nc">&nbsp;        basementCollapsed.put(coords, collapsed);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;
&nbsp;} // End public class Building implements Serializable
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
