


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FighterSquadron</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: FighterSquadron (megamek.common)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FighterSquadron</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/373)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaAero - Copyright (C) 2007 Jay Lawson This program is free software; you
&nbsp; * can redistribute it and/or modify it under the terms of the GNU General
&nbsp; * Public License as published by the Free Software Foundation; either version 2
&nbsp; * of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp; * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp; * details.
&nbsp; */
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.Vector;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;
&nbsp;/**
&nbsp; * @author Jay Lawson Fighter squadrons are basically &quot;containers&quot; for a bunch
&nbsp; *         of fighters.
&nbsp; */
&nbsp;public class FighterSquadron extends Aero {
&nbsp;    private static final long serialVersionUID = 3491212296982370726L;
&nbsp;
&nbsp;    public static final int MAX_SIZE = 6;
&nbsp;    // Value is arbitrary, but StratOps shows up to 10 so we&#39;ll use that as an
&nbsp;    // alternate MAX_SIZE when using
&nbsp;    // the option for larger squadrons
&nbsp;    public static final int ALTERNATE_MAX_SIZE = 10;
&nbsp;
<b class="nc">&nbsp;    private static final Predicate&lt;Entity&gt; ACTIVE_CHECK = ent -&gt; !(ent.isDestroyed() || ent.isDoomed());</b>
&nbsp;    
<b class="nc">&nbsp;    private Vector&lt;Integer&gt; fighters = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;    // fighter squadrons need to keep track of heat capacity apart from their
&nbsp;    // fighters
<b class="nc">&nbsp;    private int heatcap = 0;</b>
<b class="nc">&nbsp;    private int heatcapNoRHS = 0;</b>
&nbsp;
&nbsp;    public FighterSquadron() {
<b class="nc">&nbsp;        super();</b>
<b class="nc">&nbsp;        setChassis(&quot;Squadron&quot;);</b>
<b class="nc">&nbsp;        setModel(&quot;&quot;);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * construct fighter squadron with a specific name
&nbsp;     */
&nbsp;    public FighterSquadron(String name) {
<b class="nc">&nbsp;        super();</b>
<b class="nc">&nbsp;        setChassis(name.trim() + &quot; Squadron&quot;);</b>
<b class="nc">&nbsp;        setModel(&quot;&quot;);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.Aero#getCost(boolean)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double getCost(boolean ignoreAmmo) {
<b class="nc">&nbsp;        return fighters.stream()</b>
<b class="nc">&nbsp;                .mapToDouble(fid -&gt; game.getEntity(fid).getCost(ignoreAmmo))</b>
<b class="nc">&nbsp;                .sum();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * overrides the default {@link Entity#isCapitalFighter()} with true
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isCapitalFighter() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int get0SI() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).get0SI()).min().orElse(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getSI() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getSI()).min().orElse(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getTotalArmor() {
<b class="nc">&nbsp;        return fighters.stream()</b>
<b class="nc">&nbsp;                .mapToInt(fid -&gt; ((IAero)game.getEntity(fid)).getCapArmor())</b>
<b class="nc">&nbsp;                .sum();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getTotalOArmor() {
<b class="nc">&nbsp;        return fighters.stream()</b>
<b class="nc">&nbsp;                .mapToInt(fid -&gt; ((IAero) game.getEntity(fid)).getCap0Armor())</b>
<b class="nc">&nbsp;                .sum();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;     * Per SO, fighter squadrons can&#39;t actually be crippled
&nbsp;     * Individual crippled fighters should be detached and sent home, but it isn&#39;t required by the rules
&nbsp;     * @see megamek.common.Aero#isCrippled()
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isCrippled(boolean checkCrew) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the percent of the armor remaining
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double getArmorRemainingPercent() {
<b class="nc">&nbsp;        if (getTotalOArmor() == 0) {</b>
<b class="nc">&nbsp;            return IArmorState.ARMOR_NA;</b>
&nbsp;        }
<b class="nc">&nbsp;        return ((double) getTotalArmor() / (double) getTotalOArmor());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getWalkMP(boolean gravity, boolean ignoreheat,
&nbsp;            boolean ignoremodulararmor) {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;                .filter(ACTIVE_CHECK)</b>
<b class="nc">&nbsp;                .mapToInt(ent -&gt; ent.getWalkMP(gravity, ignoreheat)).min()</b>
<b class="nc">&nbsp;                .orElse(0);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public int getCurrentThrust() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;                .filter(ACTIVE_CHECK)</b>
<b class="nc">&nbsp;                .mapToInt(ent -&gt; ((IAero) ent).getCurrentThrust()).min()</b>
<b class="nc">&nbsp;                .orElse(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getFuel() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getFuel()).min().orElse(0);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public int getCurrentFuel() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getCurrentFuel()).min().orElse(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Squadrons have an SI for PSR purposes, but don&#39;t take SI damage. This should return 100%.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double getInternalRemainingPercent() {
<b class="nc">&nbsp;        return 1.0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasTargComp() {
<b class="nc">&nbsp;        List&lt;Entity&gt; activeFighters = getActiveSubEntities()</b>
<b class="nc">&nbsp;                .orElse(Collections.emptyList());</b>
<b class="nc">&nbsp;        if (activeFighters.isEmpty()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int nTC = activeFighters.stream()</b>
<b class="nc">&nbsp;                .mapToInt(ent -&gt; ent.hasTargComp() ? 1 : 0).sum();</b>
<b class="nc">&nbsp;        return (nTC * 1.0 / activeFighters.size() &gt;= 0.5);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasActiveECM() {
<b class="nc">&nbsp;        if (!game.getOptions()</b>
<b class="nc">&nbsp;                .booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)</b>
<b class="nc">&nbsp;                || !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            return super.hasActiveECM();</b>
&nbsp;        }
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;                .filter(ACTIVE_CHECK).anyMatch(Entity::hasActiveECM);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do units loaded onto this entity still have active ECM/ECCM/etc.?
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean loadedUnitsHaveActiveECM() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PilotingRollData addEntityBonuses(PilotingRollData prd) {
&nbsp;
&nbsp;        // movement effects
&nbsp;        // some question as to whether &quot;above safe thrust&quot; applies to thrust or
&nbsp;        // velocity
&nbsp;        // I will treat it as thrust until it is resolved
<b class="nc">&nbsp;        if (moved == EntityMovementType.MOVE_OVER_THRUST) {</b>
<b class="nc">&nbsp;            prd.addModifier(+1, &quot;Used more than safe thrust&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        int vel = getCurrentVelocity();</b>
<b class="nc">&nbsp;        int vmod = vel - (2 * getWalkMP());</b>
<b class="nc">&nbsp;        if (!getGame().getBoard().inSpace() &amp;&amp; (vmod &gt; 0)) {</b>
<b class="nc">&nbsp;            prd.addModifier(vmod, &quot;Velocity greater than 2x safe thrust&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // add in atmospheric effects later
<b class="nc">&nbsp;        int atmoCond = game.getPlanetaryConditions().getAtmosphere();</b>
<b class="nc">&nbsp;        if (!(game.getBoard().inSpace() || atmoCond == PlanetaryConditions.ATMO_VACUUM)) {</b>
<b class="nc">&nbsp;            prd.addModifier(+2, &quot;Atmospheric operations&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            prd.addModifier(-1, &quot;fighter/small craft&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // according to personal communication with Welshman, the normal crit
&nbsp;        // penalties are added up across the fighter squadron
<b class="nc">&nbsp;        fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).map(ent -&gt; (IAero)ent).forEachOrdered(</b>
&nbsp;            ent -&gt; {
<b class="nc">&nbsp;                int avihits = ent.getAvionicsHits();</b>
<b class="nc">&nbsp;                if ((avihits &gt; 0) &amp;&amp; (avihits &lt; 3)) {</b>
<b class="nc">&nbsp;                    prd.addModifier(avihits, &quot;Avionics Damage&quot;);</b>
<b class="nc">&nbsp;                } else if (avihits &gt;= 3) {</b>
&nbsp;                    // this should probably be replaced with some kind of AVI_DESTROYED boolean
<b class="nc">&nbsp;                    prd.addModifier(5, &quot;Avionics Destroyed&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // life support (only applicable to non-ASFs)
<b class="nc">&nbsp;                if(!ent.hasLifeSupport()) {</b>
<b class="nc">&nbsp;                    prd.addModifier(2, &quot;No life support&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(((Entity)ent).hasModularArmor()) {</b>
<b class="nc">&nbsp;                    prd.addModifier(1, &quot;Modular Armor&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            });</b>
<b class="nc">&nbsp;        return prd;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getClusterMods() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).filter(ent -&gt; (((IAero)ent).getFCSHits() &lt;= 2))</b>
<b class="nc">&nbsp;            .mapToInt(ent -&gt; ((IAero)ent).getClusterMods()).sum();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int calculateBattleValue(boolean ignoreC3, boolean ignorePilot) {
<b class="nc">&nbsp;        if (useManualBV) {</b>
<b class="nc">&nbsp;            return manualBV;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int bv = 0;</b>
&nbsp;        
&nbsp;        // We&#39;ll just add up the BV of all non-destroyed fighters in the squadron.
<b class="nc">&nbsp;        for (Integer fid : fighters) {</b>
<b class="nc">&nbsp;            final Entity fighter = game.getEntity(fid);</b>
<b class="nc">&nbsp;            if ((null != fighter) &amp;&amp; !fighter.isDoomed() &amp;&amp; !fighter.isDestroyed()) {</b>
<b class="nc">&nbsp;                bv += fighter.calculateBattleValue(ignoreC3, ignorePilot);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return bv;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.Aero#calculateBattleValue()
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int calculateBattleValue() {
<b class="nc">&nbsp;        if (useManualBV) {</b>
<b class="nc">&nbsp;            return manualBV;</b>
&nbsp;        }
<b class="nc">&nbsp;        return calculateBattleValue(false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getHeatSinks() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getHeatSinks()).sum();</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public int getHeatCapacity(boolean includeRadicalHeatSink){
<b class="nc">&nbsp;        if (includeRadicalHeatSink){</b>
<b class="nc">&nbsp;            return heatcap;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return heatcapNoRHS;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void resetHeatCapacity() {
<b class="nc">&nbsp;        List&lt;Entity&gt; activeFighters = fighters.stream()</b>
<b class="nc">&nbsp;                .map(fid -&gt; game.getEntity(fid)).filter(ACTIVE_CHECK)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
<b class="nc">&nbsp;        heatcap = activeFighters.stream()</b>
<b class="nc">&nbsp;                .mapToInt(ent -&gt; ent.getHeatCapacity(true)).sum();</b>
<b class="nc">&nbsp;        heatcapNoRHS = activeFighters.stream()</b>
<b class="nc">&nbsp;                .mapToInt(ent -&gt; ent.getHeatCapacity(false)).sum();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public double getWeight() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK).mapToDouble(ent -&gt; ent.getWeight()).sum();</b>
&nbsp;    }
&nbsp;
&nbsp;    public double getAveWeight() {
<b class="nc">&nbsp;        List&lt;Entity&gt; activeFighters = getActiveSubEntities()</b>
<b class="nc">&nbsp;                .orElse(Collections.emptyList());</b>
<b class="nc">&nbsp;        return activeFighters.isEmpty() ? Double.NaN</b>
<b class="nc">&nbsp;                : (getWeight() / activeFighters.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    /***
&nbsp;     * rather than keeping track of weapons on each fighter, every new round
&nbsp;     * just collect the current weapon groups by cycling through each fighter
&nbsp;     * and then create a new weaponGroupList. This will be trickier in terms of
&nbsp;     * using and keeping track of ammo, which is necessary in case squadron
&nbsp;     * splits, but should work otherwise
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Fighter Squadron units can only get hit in undestroyed fighters.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public HitData rollHitLocation(int table, int side, int aimedLocation, int aimingMode, int cover) {
&nbsp;        // Create a list of the indices of all the active fighters, which serves as the list of valid hit locations
<b class="nc">&nbsp;        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; fighters.size(); i++) {</b>
<b class="nc">&nbsp;            if (ACTIVE_CHECK.test(game.getEntity(fighters.get(i)))) {</b>
<b class="nc">&nbsp;                indices.add(i);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // If this squadron is doomed or is of size 1 then just return the first
&nbsp;        // one
<b class="nc">&nbsp;        if (isDoomed() || indices.isEmpty()) {</b>
<b class="nc">&nbsp;            return new HitData(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Pick a random number between 0 and the number of fighters in the
&nbsp;        // squadron.
<b class="nc">&nbsp;        int hit = indices.get(Compute.randomInt(indices.size()));</b>
<b class="nc">&nbsp;        return new HitData(hit);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public HitData rollHitLocation(int table, int side) {
<b class="nc">&nbsp;        return rollHitLocation(table, side, LOC_NONE, IAimingModes.AIM_MODE_NONE, LosEffects.COVER_NONE);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void newRound(int roundNumber) {
<b class="nc">&nbsp;        super.newRound(roundNumber);</b>
<b class="nc">&nbsp;        updateWeaponGroups();</b>
<b class="nc">&nbsp;        updateSensors();</b>
<b class="nc">&nbsp;        loadAllWeapons();</b>
<b class="nc">&nbsp;        updateSkills();</b>
<b class="nc">&nbsp;        resetHeatCapacity();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Update sensors. Use the active sensor of the first fighter in the squadron that hasn&#39;t taken 3 sensor hits
&nbsp;     * BAPs don&#39;t count as active sensors in space, but they do make detection rolls easier
&nbsp;     */
&nbsp;    public void updateSensors() {
<b class="nc">&nbsp;        if (getActiveSensor() == null) {</b>
<b class="nc">&nbsp;            for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;                Entity entity = game.getEntity(fId);</b>
<b class="nc">&nbsp;                Aero fighter = (Aero) entity;</b>
<b class="nc">&nbsp;                if (fighter.getSensorHits() &gt; 2) {</b>
&nbsp;                    // Sensors destroyed. Check the next fighter
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (fighter.getActiveSensor().isBAP()) {</b>
&nbsp;                    //BAP active. Check the next fighter
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (fighter.getActiveSensor() != null) {</b>
<b class="nc">&nbsp;                    for (Sensor sensor : fighter.getSensors()) {</b>
<b class="nc">&nbsp;                        getSensors().add(sensor);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    setNextSensor(getSensors().firstElement());</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }            
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * instead of trying to track the individual units weapons, just recompile
&nbsp;     * the weapon groups for this squadron each round
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void updateWeaponGroups() {
&nbsp;        // first we need to reset all the weapons in our existing mounts to zero
&nbsp;        // until proven otherwise
<b class="nc">&nbsp;        Set&lt;String&gt; set = weaponGroups.keySet();</b>
<b class="nc">&nbsp;        Iterator&lt;String&gt; iter = set.iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            String key = iter.next();</b>
<b class="nc">&nbsp;            this.getEquipment(weaponGroups.get(key)).setNWeapons(0);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // now collect a hash of all the same weapons in each location by id
<b class="nc">&nbsp;        Map&lt;String, Integer&gt; groups = new HashMap&lt;String, Integer&gt;();</b>
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            Entity entity = game.getEntity(fId);</b>
<b class="nc">&nbsp;            IAero fighter = (IAero) entity;</b>
<b class="nc">&nbsp;            if (fighter.getFCSHits() &gt; 2) {</b>
&nbsp;                // can&#39;t fire with no more FCS
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Mounted mounted : entity.getWeaponGroupList()) {</b>
<b class="nc">&nbsp;                if (mounted.isHit() || mounted.isDestroyed()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                int loc = mounted.getLocation();</b>
<b class="nc">&nbsp;                if (entity instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                    loc = LandAirMech.getAeroLocation(loc);</b>
&nbsp;                }
<b class="nc">&nbsp;                String key = mounted.getType().getInternalName() + &quot;:&quot; + loc;</b>
<b class="nc">&nbsp;                if (null == groups.get(key)) {</b>
<b class="nc">&nbsp;                    groups.put(key, mounted.getNWeapons());</b>
<b class="nc">&nbsp;                } else if (!mounted.getType().hasFlag(WeaponType.F_SPACE_BOMB)) {</b>
<b class="nc">&nbsp;                    groups.put(key, groups.get(key) + mounted.getNWeapons());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // now we just need to traverse the hash and either update our existing
&nbsp;        // equipment or add new ones if there is none
<b class="nc">&nbsp;        Set&lt;String&gt; newSet = groups.keySet();</b>
<b class="nc">&nbsp;        Iterator&lt;String&gt; newIter = newSet.iterator();</b>
<b class="nc">&nbsp;        while (newIter.hasNext()) {</b>
<b class="nc">&nbsp;            String key = newIter.next();</b>
<b class="nc">&nbsp;            if (null != weaponGroups.get(key)) {</b>
&nbsp;                // then this equipment is already loaded, so we just need to
&nbsp;                // correctly update the number of weapons
<b class="nc">&nbsp;                this.getEquipment(weaponGroups.get(key)).setNWeapons(groups.get(key));</b>
&nbsp;            } else {
&nbsp;                // need to add a new weapon
<b class="nc">&nbsp;                String name = key.split(&quot;:&quot;)[0];</b>
<b class="nc">&nbsp;                int loc = Integer.parseInt(key.split(&quot;:&quot;)[1]);</b>
<b class="nc">&nbsp;                EquipmentType etype = EquipmentType.get(name);</b>
&nbsp;                Mounted newmount;
<b class="nc">&nbsp;                if (etype != null) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        newmount = addWeaponGroup(etype, loc);</b>
<b class="nc">&nbsp;                        newmount.setNWeapons(groups.get(key));</b>
<b class="nc">&nbsp;                        weaponGroups.put(key, getEquipmentNum(newmount));</b>
<b class="nc">&nbsp;                    } catch (LocationFullException ex) {</b>
<b class="nc">&nbsp;                        System.out.println(&quot;Unable to compile weapon groups&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        ex.printStackTrace();</b>
<b class="nc">&nbsp;                        return;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (name != &quot;0&quot;) {</b>
<b class="nc">&nbsp;                    addFailedEquipment(name);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // make sure to set all the UACs and RACs to rapid fire
<b class="nc">&nbsp;        setRapidFire();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * When fighters are removed it is necessary to unlink all ammo to the
&nbsp;     * squadron&#39;s weapons and reload it to ensure that ammo from the removed
&nbsp;     * fighter does not remain linked
&nbsp;     */
&nbsp;    // TODO: Evaluate for removal
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void reloadAllWeapons() {
<b class="nc">&nbsp;        for (Mounted weapon : getTotalWeaponList()) {</b>
<b class="nc">&nbsp;            if ((((WeaponType) weapon.getType()).getAmmoType() != AmmoType.T_NA) &amp;&amp; (null != weapon.getLinked())</b>
<b class="nc">&nbsp;                    &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</b>
<b class="nc">&nbsp;                weapon.unlink();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * update the skills for this squadron
&nbsp;     */
&nbsp;    public void updateSkills() {
<b class="nc">&nbsp;        List&lt;Entity&gt; activeFighters = getActiveSubEntities().orElse(Collections.emptyList());</b>
<b class="nc">&nbsp;        if(activeFighters.isEmpty()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pilotingTotal = 0;</b>
<b class="nc">&nbsp;        int gunneryTotal = 0;</b>
<b class="nc">&nbsp;        int gunneryLTotal = 0;</b>
<b class="nc">&nbsp;        int gunneryMTotal = 0;</b>
<b class="nc">&nbsp;        int gunneryBTotal = 0;</b>
<b class="nc">&nbsp;        for(Entity fighter : activeFighters) {</b>
<b class="nc">&nbsp;            pilotingTotal += fighter.getCrew().getPiloting();</b>
<b class="nc">&nbsp;            gunneryTotal += fighter.getCrew().getGunnery();</b>
<b class="nc">&nbsp;            if (fighter.getGame().getOptions().booleanOption(OptionsConstants.RPG_RPG_GUNNERY)) {</b>
<b class="nc">&nbsp;                gunneryLTotal += fighter.getCrew().getGunneryL();</b>
<b class="nc">&nbsp;                gunneryMTotal += fighter.getCrew().getGunneryM();</b>
<b class="nc">&nbsp;                gunneryBTotal += fighter.getCrew().getGunneryB();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                gunneryLTotal = gunneryTotal;</b>
<b class="nc">&nbsp;                gunneryMTotal = gunneryTotal;</b>
<b class="nc">&nbsp;                gunneryBTotal = gunneryTotal;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        getCrew().setPiloting(pilotingTotal / activeFighters.size(), 0);</b>
<b class="nc">&nbsp;        getCrew().setGunnery(gunneryTotal / activeFighters.size(), 0);</b>
<b class="nc">&nbsp;        getCrew().setGunneryL(gunneryLTotal / activeFighters.size(), 0);</b>
<b class="nc">&nbsp;        getCrew().setGunneryM(gunneryMTotal / activeFighters.size(), 0);</b>
<b class="nc">&nbsp;        getCrew().setGunneryB(gunneryBTotal / activeFighters.size(), 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public ArrayList&lt;Mounted&gt; getAmmo() {
<b class="nc">&nbsp;        ArrayList&lt;Mounted&gt; allAmmo = new ArrayList&lt;Mounted&gt;();</b>
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            Entity fighter = game.getEntity(fId);</b>
<b class="nc">&nbsp;            allAmmo.addAll(fighter.getAmmo());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return allAmmo;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void useFuel(int fuel) {
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            IAero fighter = (IAero) game.getEntity(fId);</b>
<b class="nc">&nbsp;            fighter.useFuel(fuel);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void autoSetMaxBombPoints() {
<b class="nc">&nbsp;        maxBombPoints = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            Entity fighter = game.getEntity(fId);</b>
<b class="nc">&nbsp;            int currBombPoints = (int) Math.round(fighter.getWeight() / 5);</b>
<b class="nc">&nbsp;            maxBombPoints = Math.min(maxBombPoints, currBombPoints);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setBombChoices(int[] bc) {
&nbsp;        // Set the bombs for the squadron
<b class="nc">&nbsp;        if (bc.length == bombChoices.length) {</b>
<b class="nc">&nbsp;            bombChoices = bc;</b>
&nbsp;        }
&nbsp;        // Update each fighter in the squadron
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            IBomber fighter = (IBomber) game.getEntity(fId);</b>
<b class="nc">&nbsp;            fighter.setBombChoices(bc);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Produce an int array of the number of bombs of each type based on the
&nbsp;     * current bomblist. Since this is a FighterSquadron, these numbers
&nbsp;     * represent the number of bombs in a salvo. That is, it is a count of the
&nbsp;     * number of fighters in the squadron that have a bomb of the particular
&nbsp;     * type mounted.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int[] getBombLoadout() {
<b class="nc">&nbsp;        int[] loadout = new int[BombType.B_NUM];</b>
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            Entity fighter = (Entity) game.getEntity(fId);</b>
<b class="nc">&nbsp;            for (Mounted m : fighter.getBombs()) {</b>
<b class="nc">&nbsp;                loadout[((BombType) m.getType()).getBombType()]++;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return loadout;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void applyBombs() {
&nbsp;        // Make sure all of the aeros have their bombs applied, otherwise
&nbsp;        // problems
&nbsp;        // once the bombs are applied, the choices are cleared, so it&#39;s not an
&nbsp;        // issue if the bombs are applied twice for an Aero
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            IBomber fighter = (IBomber) game.getEntity(fId);</b>
<b class="nc">&nbsp;            fighter.applyBombs();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        computeSquadronBombLoadout();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This method looks at the bombs equipped on all the fighters in the
&nbsp;     * squadron and determines what possible bombing attacks the squadrons
&nbsp;     * can make.
&nbsp;     * 
&nbsp;     * TODO: Make this into a generic &quot;clean up bomb loadout&quot; method
&nbsp;     */
&nbsp;    public void computeSquadronBombLoadout() {
&nbsp;        // Remove any currently equipped bombs
<b class="nc">&nbsp;        for (Mounted bomb : bombList) {</b>
<b class="nc">&nbsp;            equipmentList.remove(bomb);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        bombList.clear();</b>
&nbsp;
&nbsp;        // Find out what bombs everyone has
<b class="nc">&nbsp;        for (int btype = 0; btype &lt; BombType.B_NUM; btype++) {</b>
&nbsp;            // This is smallest number of such a bomb
<b class="nc">&nbsp;            int maxBombCount = 0;</b>
<b class="nc">&nbsp;            for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;                int bombCount = 0;</b>
<b class="nc">&nbsp;                Entity fighter = game.getEntity(fId);</b>
<b class="nc">&nbsp;                for (Mounted m : fighter.getBombs()) {</b>
<b class="nc">&nbsp;                    if (((BombType) m.getType()).getBombType() == btype) {</b>
<b class="nc">&nbsp;                        bombCount++;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                maxBombCount = Math.max(bombCount, maxBombCount);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            bombChoices[btype] = maxBombCount;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Now that we know our bomb choices, load &#39;em
<b class="nc">&nbsp;        int gameTL = TechConstants.getSimpleLevel(game.getOptions().stringOption(&quot;techlevel&quot;));</b>
<b class="nc">&nbsp;        for (int type = 0; type &lt; BombType.B_NUM; type++) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; bombChoices[type]; i++) {</b>
<b class="nc">&nbsp;                if ((type == BombType.B_ALAMO)</b>
<b class="nc">&nbsp;                        &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AT2_NUKES)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((type &gt; BombType.B_TAG) &amp;&amp; (gameTL &lt; TechConstants.T_SIMPLE_ADVANCED)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // some bombs need an associated weapon and if so
&nbsp;                // they need a weapon for each bomb
<b class="nc">&nbsp;                if ((null != BombType.getBombWeaponName(type)) &amp;&amp; (type != BombType.B_ARROW)</b>
&nbsp;                        &amp;&amp; (type != BombType.B_HOMING)) {
&nbsp;                    try {
<b class="nc">&nbsp;                        addBomb(EquipmentType.get(BombType.getBombWeaponName(type)), LOC_NOSE);</b>
<b class="nc">&nbsp;                    } catch (LocationFullException ex) {</b>
&nbsp;                        // throw new LocationFullException(ex.getMessage());
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // If the bomb was added as a weapon, don&#39;t add the ammo
&nbsp;                // The ammo will end up never getting removed from the squadron
&nbsp;                // because it doesn&#39;t count as a weapon.
<b class="nc">&nbsp;                if ((type != BombType.B_TAG) &amp;&amp; (null == BombType.getBombWeaponName(type))) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        addEquipment(EquipmentType.get(BombType.getBombInternalName(type)), LOC_NOSE, false);</b>
<b class="nc">&nbsp;                    } catch (LocationFullException ex) {</b>
&nbsp;                        // throw new LocationFullException(ex.getMessage());
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Clear out the bomb choice once the bombs are loaded
<b class="nc">&nbsp;            bombChoices[type] = 0;</b>
&nbsp;        }
&nbsp;        // add the space bomb attack
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SPACE_BOMB)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().inSpace() &amp;&amp; (getBombs(AmmoType.F_SPACE_BOMB).size() &gt; 0)) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                addEquipment(EquipmentType.get(SPACE_BOMB_ATTACK), LOC_NOSE, false);</b>
<b class="nc">&nbsp;            } catch (LocationFullException ex) {</b>
&nbsp;                // throw new LocationFullException(ex.getMessage());
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!game.getBoard().inSpace() &amp;&amp; (getBombs(AmmoType.F_GROUND_BOMB).size() &gt; 0)) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                addEquipment(EquipmentType.get(DIVE_BOMB_ATTACK), LOC_NOSE, false);</b>
<b class="nc">&nbsp;            } catch (LocationFullException ex) {</b>
&nbsp;                // throw new LocationFullException(ex.getMessage());
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; Math.min(10, getBombs(AmmoType.F_GROUND_BOMB).size()); i++) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    addEquipment(EquipmentType.get(ALT_BOMB_ATTACK), LOC_NOSE, false);</b>
<b class="nc">&nbsp;                } catch (LocationFullException ex) {</b>
&nbsp;                    // throw new LocationFullException(ex.getMessage());
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        updateWeaponGroups();</b>
<b class="nc">&nbsp;        loadAllWeapons();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Determine MAX_SIZE based on game options
&nbsp;     */
&nbsp;    public int getMaxSize() {
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVAERORULES_ALLOW_LARGE_SQUADRONS)) {
<b class="nc">&nbsp;            return ALTERNATE_MAX_SIZE;</b>
&nbsp;        }
<b class="nc">&nbsp;        return MAX_SIZE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * The transporter functions
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this object can accept the given unit. The unit may not be
&nbsp;     * of the appropriate type or there may be no room for the unit.
&nbsp;     *
&nbsp;     * @param unit
&nbsp;     *            - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit can be loaded, &lt;code&gt;false&lt;/code&gt;
&nbsp;     *         otherwise.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean canLoad(Entity unit, boolean checkFalse) {
&nbsp;        // We must have enough space for the new fighter.
<b class="nc">&nbsp;        if(!unit.isEnemyOf(this) &amp;&amp; unit.isFighter() &amp;&amp; (fighters.size() &lt; getMaxSize())) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        // fighter squadrons can also load other fighter squadrons provided
&nbsp;        // there is enough space
&nbsp;        // and the loadee is not empty
<b class="nc">&nbsp;        if ((unit instanceof FighterSquadron)</b>
<b class="nc">&nbsp;                &amp;&amp; !unit.isEnemyOf(this)</b>
<b class="nc">&nbsp;                &amp;&amp; (getId() != unit.getId())</b>
<b class="nc">&nbsp;                &amp;&amp; (((FighterSquadron) unit).fighters.size() &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; ((fighters.size() + ((FighterSquadron) unit).fighters.size()) &lt;= getMaxSize())) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Load the given unit.
&nbsp;     *
&nbsp;     * @param unit
&nbsp;     *            - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
&nbsp;     * @exception -
&nbsp;     *                If the unit can&#39;t be loaded, an
&nbsp;     *                &lt;code&gt;IllegalArgumentException&lt;/code&gt; exception will be
&nbsp;     *                thrown.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void load(Entity unit, boolean checkFalse) throws IllegalArgumentException {
&nbsp;        // If we can&#39;t load the unit, throw an exception.
<b class="nc">&nbsp;        if (!canLoad(unit)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can not load &quot; + unit.getShortName() + &quot; into this squadron. &quot;);</b>
&nbsp;        }
&nbsp;        // if this is a fighter squadron then we actually need to load the
&nbsp;        // individual units
<b class="nc">&nbsp;        if (unit instanceof FighterSquadron) {</b>
<b class="nc">&nbsp;            fighters.addAll(((FighterSquadron) unit).fighters);</b>
&nbsp;        } else {
&nbsp;            // Add the unit to our squadron.
<b class="nc">&nbsp;            fighters.addElement(unit.getId());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getPhase() != Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;            computeSquadronBombLoadout();</b>
&nbsp;            // updateWeaponGroups() and loadAllWeapons() are called in
&nbsp;            // computeSquadronBombLoadout()
&nbsp;        } else {
<b class="nc">&nbsp;            updateWeaponGroups();</b>
<b class="nc">&nbsp;            loadAllWeapons();</b>
&nbsp;        }
<b class="nc">&nbsp;        updateSkills();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * We need to override this function to make sure the proper load method
&nbsp;     * gets called in some cases, but Squadrons can&#39;t have bays, so we can just
&nbsp;     * ignore the bay number.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void load(Entity unit, boolean checkFalse, int bayNumber) {
<b class="nc">&nbsp;        load(unit, checkFalse);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Unload the given unit. TODO: need to strip out ammo
&nbsp;     *
&nbsp;     * @param unit
&nbsp;     *            - the &lt;code&gt;Entity&lt;/code&gt; to be unloaded.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit was contained in this space,
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean unload(Entity unit) {
&nbsp;        // Remove the unit if we are carrying it.
<b class="nc">&nbsp;        boolean success = fighters.removeElement(unit.getId());</b>
<b class="nc">&nbsp;        if (game.getPhase() != Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;            computeSquadronBombLoadout();</b>
&nbsp;            // updateWeaponGroups() and loadAllWeapons() are called in
&nbsp;            // computeSquadronBombLoadout()
&nbsp;        } else {
<b class="nc">&nbsp;            updateWeaponGroups();</b>
<b class="nc">&nbsp;            loadAllWeapons();</b>
&nbsp;        }
<b class="nc">&nbsp;        updateSkills();</b>
<b class="nc">&nbsp;        return success;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get a &lt;code&gt;List&lt;/code&gt; of the units currently loaded into this payload.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;List&lt;/code&gt; of loaded &lt;code&gt;Entity&lt;/code&gt; units. This
&nbsp;     *         list will never be &lt;code&gt;null&lt;/code&gt;, but it may be empty. The
&nbsp;     *         returned &lt;code&gt;List&lt;/code&gt; is independant from the under- lying
&nbsp;     *         data structure; modifying one does not affect the other.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Vector&lt;Entity&gt; getLoadedUnits() {
<b class="nc">&nbsp;        return fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .collect(Collectors.toCollection(Vector::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a string that identifies the unused capacity of this transporter.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;String&lt;/code&gt; meant for a human.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getUnusedString() {
<b class="nc">&nbsp;        return &quot; - &quot; + (getMaxSize() - fighters.size()) + &quot; units&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double getUnused() {
<b class="nc">&nbsp;        return getMaxSize() - fighters.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current amount of cargo space for an entity of the given
&nbsp;     * type.
&nbsp;     * 
&nbsp;     * @param e
&nbsp;     *            An entity that defines the unit class
&nbsp;     * @return The number of units of the given type that can be loaded in this
&nbsp;     *         Entity
&nbsp;     * 
&nbsp;     *         TODO: Fix this so we can&#39;t actually &quot;load&quot; warships or
&nbsp;     *         tele-operated missiles into fighter squadrons ...
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double getUnused(Entity e) {
<b class="nc">&nbsp;        if (e.isFighter()) {</b>
<b class="nc">&nbsp;            return getUnused();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if transported units prevent a weapon in the given location
&nbsp;     * from firing.
&nbsp;     *
&nbsp;     * @param loc
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; location attempting to fire.
&nbsp;     * @param isRear
&nbsp;     *            - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
&nbsp;     *            is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
&nbsp;     *            facing.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if a transported unit is in the way,
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; if the weapon can fire.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isWeaponBlockedAt(int loc, boolean isRear) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If a unit is being transported on the outside of the transporter, it can
&nbsp;     * suffer damage when the transporter is hit by an attack. Currently, no
&nbsp;     * more than one unit can be at any single location; that same unit can be
&nbsp;     * &quot;spread&quot; over multiple locations.
&nbsp;     *
&nbsp;     * @param loc
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; location hit by attack.
&nbsp;     * @param isRear
&nbsp;     *            - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
&nbsp;     *            is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
&nbsp;     *            facing.
&nbsp;     * @return The &lt;code&gt;Entity&lt;/code&gt; being transported on the outside at that
&nbsp;     *         location. This value will be &lt;code&gt;null&lt;/code&gt; if no unit is
&nbsp;     *         transported on the outside at that location.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Entity getExteriorUnitAt(int loc, boolean isRear) {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCargoMpReduction(Entity carrier) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getEntityType() {
<b class="nc">&nbsp;        return Entity.ETYPE_AERO | Entity.ETYPE_FIGHTER_SQUADRON;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Engine getEngine() {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public boolean hasEngine() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the movement mode of the entity, based on consensus.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public EntityMovementMode getMovementMode() {
<b class="nc">&nbsp;        if (fighters.size() &lt; 1) {</b>
<b class="nc">&nbsp;            return EntityMovementMode.NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        EntityMovementMode moveMode = game.getEntity(fighters.get(0)).getMovementMode();</b>
<b class="nc">&nbsp;        for (Integer fId : fighters) {</b>
<b class="nc">&nbsp;            Entity fighter = game.getEntity(fId);</b>
<b class="nc">&nbsp;            if (moveMode != fighter.getMovementMode()) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Error: Fighter squadron movement mode &quot; + &quot;doesn&#39;t agree!&quot;);</b>
<b class="nc">&nbsp;                return EntityMovementMode.NONE;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return moveMode;</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public Optional&lt;List&lt;Entity&gt;&gt; getSubEntities() {
<b class="nc">&nbsp;        return Optional.of(fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .collect(Collectors.toList()));</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public Optional&lt;List&lt;Entity&gt;&gt; getActiveSubEntities() {
<b class="nc">&nbsp;        return Optional.of(fighters.stream().map(fid -&gt; game.getEntity(fid))</b>
<b class="nc">&nbsp;            .filter(ACTIVE_CHECK)</b>
<b class="nc">&nbsp;            .collect(Collectors.toList()));</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
