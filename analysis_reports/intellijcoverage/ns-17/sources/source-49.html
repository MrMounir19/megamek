


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > IGame</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: IGame (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">IGame$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IGame$MockitoMock$1862657212</td>
  </tr>
  <tr>
    <td class="name">IGame$MockitoMock$1862657212$auxiliary$Q9l2dXww</td>
  </tr>
  <tr>
    <td class="name">IGame$MockitoMock$1862657212$auxiliary$sjTROeET</td>
  </tr>
  <tr>
    <td class="name">IGame$Phase</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61%
  </span>
  <span class="absValue">
    (25/41)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.5%
  </span>
  <span class="absValue">
    (25/42)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2005 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2018 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.event.GameEvent;
&nbsp;import megamek.common.event.GameListener;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.weapons.AttackHandler;
&nbsp;import megamek.server.SmokeCloud;
&nbsp;import megamek.server.victory.Victory;
&nbsp;
&nbsp;/**
&nbsp; * This interface is the root of all data about the game in progress. Both the
&nbsp; * Client and the Server should have one of these objects and it is their job to
&nbsp; * keep it synched. note from itmo: this needs WAY MORE javadoc. also preferably
&nbsp; * remove the abstract-modifiers and divide this interface into two
&nbsp; * subinterfaces for reading and modifying. -stuff should be documented as
&nbsp; * contracts. bad example of javadoccing found in getVictory* ... also phases
&nbsp; * should be documented. wtf is an exchange-phase?
&nbsp; */
&nbsp;public interface IGame {
&nbsp;
&nbsp;    public static int ILLUMINATED_NONE = 0;
&nbsp;    public static int ILLUMINATED_FIRE = 1;
&nbsp;    public static int ILLUMINATED_FLARE = 2;
&nbsp;    public static int ILLUMINATED_LIGHT = 3;
&nbsp;
<b class="fc">&nbsp;    public enum Phase {</b>
<b class="fc">&nbsp;        PHASE_UNKNOWN,</b>
<b class="fc">&nbsp;        PHASE_LOUNGE,</b>
<b class="fc">&nbsp;        PHASE_SELECTION,</b>
<b class="fc">&nbsp;        PHASE_EXCHANGE,</b>
<b class="fc">&nbsp;        PHASE_DEPLOYMENT,</b>
<b class="fc">&nbsp;        PHASE_INITIATIVE,</b>
<b class="fc">&nbsp;        PHASE_INITIATIVE_REPORT,</b>
<b class="fc">&nbsp;        PHASE_TARGETING,</b>
<b class="fc">&nbsp;        PHASE_TARGETING_REPORT,</b>
<b class="fc">&nbsp;        PHASE_MOVEMENT,</b>
<b class="fc">&nbsp;        PHASE_MOVEMENT_REPORT,</b>
<b class="fc">&nbsp;        PHASE_OFFBOARD,</b>
<b class="fc">&nbsp;        PHASE_OFFBOARD_REPORT,</b>
<b class="fc">&nbsp;        PHASE_POINTBLANK_SHOT, // Fake phase only reached through hidden units</b>
<b class="fc">&nbsp;        PHASE_FIRING,</b>
<b class="fc">&nbsp;        PHASE_FIRING_REPORT,</b>
<b class="fc">&nbsp;        PHASE_PHYSICAL,</b>
<b class="fc">&nbsp;        PHASE_PHYSICAL_REPORT,</b>
<b class="fc">&nbsp;        PHASE_END,</b>
<b class="fc">&nbsp;        PHASE_END_REPORT,</b>
<b class="fc">&nbsp;        PHASE_VICTORY,</b>
<b class="fc">&nbsp;        PHASE_DEPLOY_MINEFIELDS,</b>
<b class="fc">&nbsp;        PHASE_STARTING_SCENARIO,</b>
<b class="fc">&nbsp;        PHASE_SET_ARTYAUTOHITHEXES;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * @param otherPhase
&nbsp;         * @return
&nbsp;         */
&nbsp;        public boolean isDuringOrAfter(Phase otherPhase) {
<b class="nc">&nbsp;            return compareTo(otherPhase) &gt;= 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param otherPhase
&nbsp;         * @return
&nbsp;         */
&nbsp;        public boolean isBefore(Phase otherPhase) {
<b class="nc">&nbsp;            return compareTo(otherPhase) &lt; 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get the displayable name for the given Phase.
&nbsp;         *
&nbsp;         * @param phase
&nbsp;         * @return
&nbsp;         */
&nbsp;        static public String getDisplayableName(Phase phase) {
<b class="nc">&nbsp;            return Messages.getString(&quot;GAME_&quot; + phase.name());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Given a displayable name for a phase, return the Phase instance for
&nbsp;         * that name.  Null will be returned if no match is found or a null
&nbsp;         * string is passed.
&nbsp;         *
&nbsp;         * @param name
&nbsp;         * @return
&nbsp;         */
&nbsp;        @Nullable
&nbsp;        static public Phase getPhaseFromName(@Nullable String name) {
<b class="nc">&nbsp;            if (name == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (Phase p : values()) {</b>
<b class="nc">&nbsp;                if (name.equals(getDisplayableName(p))) {</b>
<b class="nc">&nbsp;                    return p;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if this phase is simultaneous.
&nbsp;         *
&nbsp;         * @param game  Game instance used to get game options
&nbsp;         * @return
&nbsp;         */
&nbsp;        public boolean isPhaseSimultaneous(IGame game) {
<b class="nc">&nbsp;            switch (this) {</b>
&nbsp;                case PHASE_DEPLOYMENT:
<b class="nc">&nbsp;                    return game.getOptions().booleanOption(OptionsConstants.INIT_SIMULTANEOUS_DEPLOYMENT);</b>
&nbsp;                case PHASE_MOVEMENT:
<b class="nc">&nbsp;                    return game.getOptions().booleanOption(OptionsConstants.INIT_SIMULTANEOUS_MOVEMENT);</b>
&nbsp;                case PHASE_FIRING:
<b class="nc">&nbsp;                    return game.getOptions().booleanOption(OptionsConstants.INIT_SIMULTANEOUS_FIRING);</b>
&nbsp;                case PHASE_PHYSICAL:
<b class="nc">&nbsp;                    return game.getOptions().booleanOption(OptionsConstants.INIT_SIMULTANEOUS_PHYSICAL);</b>
&nbsp;                case PHASE_TARGETING:
&nbsp;                case PHASE_OFFBOARD:
<b class="nc">&nbsp;                    return game.getOptions().booleanOption(OptionsConstants.INIT_SIMULTANEOUS_TARGETING);</b>
&nbsp;                default:
<b class="nc">&nbsp;                    return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    // New accessors for external game id
&nbsp;    abstract int getExternalGameId();
&nbsp;
&nbsp;    abstract void setExternalGameId(int value);
&nbsp;
&nbsp;    /**
&nbsp;     * @return the currently active context-object for victorycondition
&nbsp;     *         checking. This should be a mutable object and it will be modified
&nbsp;     *         by the victory condition checkers. whoever saves the game state
&nbsp;     *         when doing saves, is also responsible of saving this state. at
&nbsp;     *         the start of the game this should be initialized to an empty
&nbsp;     *         hashmap
&nbsp;     */
&nbsp;    abstract HashMap&lt;String, Object&gt; getVictoryContext();
&nbsp;
&nbsp;    /**
&nbsp;     * set the game victory state.
&nbsp;     */
&nbsp;    abstract void setVictoryContext(HashMap&lt;String, Object&gt; ctx);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the specified game listener to receive board events from this Game.
&nbsp;     *
&nbsp;     * @param listener the game listener.
&nbsp;     */
&nbsp;    abstract void addGameListener(GameListener listener);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the specified game listener.
&nbsp;     *
&nbsp;     * @param listener the game listener.
&nbsp;     */
&nbsp;    abstract void removeGameListener(GameListener listener);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all the GameListeners.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    abstract List&lt;GameListener&gt; getGameListeners();
&nbsp;
&nbsp;    /**
&nbsp;     * purges all Game Listener objects.
&nbsp;     */
&nbsp;    abstract void purgeGameListeners();
&nbsp;
&nbsp;    /**
&nbsp;     * Processes game events by dispatching them to any registered GameListener
&nbsp;     * objects.
&nbsp;     *
&nbsp;     * @param event the game event.
&nbsp;     */
&nbsp;    abstract void processGameEvent(GameEvent event);
&nbsp;
&nbsp;    /**
&nbsp;     * Check if there is a minefield at given coords
&nbsp;     *
&nbsp;     * @param coords coords to check
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if there is a minefield at given coords or
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; otherwise
&nbsp;     */
&nbsp;    abstract boolean containsMinefield(Coords coords);
&nbsp;
&nbsp;    /**
&nbsp;     * Get the minefields at specified coords
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     * @return the &lt;code&gt;Vector&lt;/code&gt; of minefields at specified coord
&nbsp;     */
&nbsp;    abstract Vector&lt;Minefield&gt; getMinefields(Coords coords);
&nbsp;
&nbsp;    /**
&nbsp;     * Get the number of the minefields at specified coords
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     * @return the number of the minefields at specified coord
&nbsp;     */
&nbsp;    abstract int getNbrMinefields(Coords coords);
&nbsp;
&nbsp;    /**
&nbsp;     * Get the coordinates of all mined hexes in the game.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the &lt;code&gt;Coords&lt;/code&gt;
&nbsp;     *         containing minefilds. This will not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Coords&gt; getMinedCoords();
&nbsp;
&nbsp;    /**
&nbsp;     * Addds the specified minefield
&nbsp;     *
&nbsp;     * @param mf minefield to add
&nbsp;     */
&nbsp;    abstract void addMinefield(Minefield mf);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a number of minefields
&nbsp;     *
&nbsp;     * @param minefields the &lt;code&gt;Vector&lt;/code&gt; of the minefields to add
&nbsp;     */
&nbsp;    abstract void addMinefields(Vector&lt;Minefield&gt; minefields);
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the minefields to the given &lt;code&gt;Vector&lt;/code&gt; of the minefields
&nbsp;     *
&nbsp;     * @param minefields
&nbsp;     */
&nbsp;    abstract void setMinefields(Vector&lt;Minefield&gt; minefields);
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the minefield density for a given &lt;code&gt;Vector&lt;/code&gt; of minefields
&nbsp;     * @param newMinefields
&nbsp;     */
&nbsp;    abstract void resetMinefieldDensity(Vector&lt;Minefield&gt; newMinefields);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the specified minefield
&nbsp;     *
&nbsp;     * @param mf minefield to remove
&nbsp;     */
&nbsp;    abstract void removeMinefield(Minefield mf);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all minefields
&nbsp;     */
&nbsp;    abstract void clearMinefields();
&nbsp;
&nbsp;    /**
&nbsp;     * @return the &lt;code&gt;Vector&lt;/code&gt; of the vibrabombs
&nbsp;     */
&nbsp;    abstract Vector&lt;Minefield&gt; getVibrabombs();
&nbsp;
&nbsp;    /**
&nbsp;     * Addds the specified vibrabomb
&nbsp;     *
&nbsp;     * @param mf Vibrabomb to add
&nbsp;     */
&nbsp;    abstract void addVibrabomb(Minefield mf);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the specified Vibrabomb
&nbsp;     *
&nbsp;     * @param mf Vibrabomb to remove
&nbsp;     */
&nbsp;    abstract void removeVibrabomb(Minefield mf);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the game contains the specified Vibrabomb
&nbsp;     *
&nbsp;     * @param mf the Vibrabomb to ceck
&nbsp;     * @return true iff the minefield contains a vibrabomb.
&nbsp;     */
&nbsp;    abstract boolean containsVibrabomb(Minefield mf);
&nbsp;
&nbsp;    /**
&nbsp;     * @return game options
&nbsp;     */
&nbsp;    abstract GameOptions getOptions();
&nbsp;
&nbsp;    /**
&nbsp;     * sets the game options
&nbsp;     *
&nbsp;     * @param options
&nbsp;     */
&nbsp;    abstract void setOptions(GameOptions options);
&nbsp;
&nbsp;    /**
&nbsp;     * @return the game board
&nbsp;     */
&nbsp;    abstract IBoard getBoard();
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the new game board
&nbsp;     *
&nbsp;     * @param board
&nbsp;     */
&nbsp;    abstract void setBoard(IBoard board);
&nbsp;
&nbsp;    /**
&nbsp;     * Return an enumeration of teams in the game
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Team&gt; getTeams();
&nbsp;
&nbsp;    /**
&nbsp;     * Return the current number of teams in the game.
&nbsp;     */
&nbsp;    abstract int getNoOfTeams();
&nbsp;
&nbsp;    /**
&nbsp;     * Return the immutable vector of teams
&nbsp;     */
&nbsp;    abstract List&lt;Team&gt; getTeamsVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Return a players team Note: may return null if player has no team
&nbsp;     */
&nbsp;    abstract Team getTeamForPlayer(IPlayer p);
&nbsp;
&nbsp;    /**
&nbsp;     * Set up the teams vector. Each player on a team (Team 1 .. Team X) is
&nbsp;     * placed in the appropriate vector. Any player on &#39;No Team&#39;, is placed in
&nbsp;     * their own object
&nbsp;     */
&nbsp;    abstract void setupTeams();
&nbsp;
&nbsp;    /**
&nbsp;     * Return an enumeration of player in the game
&nbsp;     */
&nbsp;    abstract Enumeration&lt;IPlayer&gt; getPlayers();
&nbsp;
&nbsp;    /**
&nbsp;     * Return the players vector
&nbsp;     */
&nbsp;    abstract Vector&lt;IPlayer&gt; getPlayersVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Return the current number of active players in the game.
&nbsp;     */
&nbsp;    abstract int getNoOfPlayers();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the individual player assigned the id parameter.
&nbsp;     */
&nbsp;    abstract IPlayer getPlayer(int id);
&nbsp;
&nbsp;    abstract void addPlayer(int id, IPlayer player);
&nbsp;
&nbsp;    abstract void setPlayer(int id, IPlayer player);
&nbsp;
&nbsp;    abstract void removePlayer(int id);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of entities owned by the player, regardless of their
&nbsp;     * status, as long as they are in the game.
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract int getEntitiesOwnedBy(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of entities owned by the player, regardless of their
&nbsp;     * status.
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract int getAllEntitiesOwnedBy(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of non-destroyed entityes owned by the player
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract int getLiveEntitiesOwnedBy(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of non-destroyed deployed entities owned by the
&nbsp;     * player. Ignore offboard units and captured Mek pilots.
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract int getLiveDeployedEntitiesOwnedBy(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of non-destroyed deployed entities owned by the
&nbsp;     * player. Ignore offboard units and captured Mek pilots.
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract int getLiveCommandersOwnedBy(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the player has a valid unit with the Tactical Genius
&nbsp;     * pilot special ability.
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract boolean hasTacticalGenius(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Get a vector of entity objects that are &quot;acceptable&quot; to attack with this
&nbsp;     * entity
&nbsp;     */
&nbsp;    abstract List&lt;Entity&gt; getValidTargets(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this phase has turns. If false, the phase is simply
&nbsp;     * waiting for everybody to declare &quot;done&quot;.
&nbsp;     */
&nbsp;    abstract boolean phaseHasTurns(IGame.Phase phase);
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if the current phase can be played simultaneously
&nbsp;     */
&nbsp;    abstract boolean isPhaseSimultaneous();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current GameTurn object
&nbsp;     */
&nbsp;    abstract GameTurn getTurn();
&nbsp;
&nbsp;    /**
&nbsp;     * @return the first GameTurn object for the specified player, or null
&nbsp;     * if the player has no turns to play
&nbsp;     */
&nbsp;    abstract GameTurn getTurnForPlayer(int pn);
&nbsp;
&nbsp;    /**
&nbsp;     * Changes to the next turn, returning it.
&nbsp;     */
&nbsp;    abstract GameTurn changeToNextTurn();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the turn index to -1 (awaiting first turn)
&nbsp;     */
&nbsp;    abstract void resetTurnIndex();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if there is a turn after the current one
&nbsp;     */
&nbsp;    abstract boolean hasMoreTurns();
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts a turn that will come directly after the current one
&nbsp;     */
&nbsp;    abstract void insertNextTurn(GameTurn turn);
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts a turn after the specific index
&nbsp;     */
&nbsp;    abstract void insertTurnAfter(GameTurn turn, int index);
&nbsp;
&nbsp;    /**
&nbsp;     * Swaps the turn at index 1 with the turn at index 2.
&nbsp;     *
&nbsp;     * @param index1
&nbsp;     * @param index2
&nbsp;     */
&nbsp;    abstract void swapTurnOrder(int index1, int index2);
&nbsp;    /**
&nbsp;     * Returns an Enumeration of the current turn list
&nbsp;     */
&nbsp;    abstract Enumeration&lt;GameTurn&gt; getTurns();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current turn index
&nbsp;     */
&nbsp;    abstract int getTurnIndex();
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the current turn index
&nbsp;     *
&nbsp;     * @param turnIndex
&nbsp;     *            The new turn index.
&nbsp;     * @param prevPlayerId
&nbsp;     *            The ID of the player who triggered the turn index change.
&nbsp;     */
&nbsp;    abstract void setTurnIndex(int turnIndex, int prevPlayerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current turn vector
&nbsp;     */
&nbsp;    abstract List&lt;GameTurn&gt; getTurnVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the current turn vector
&nbsp;     */
&nbsp;    abstract void setTurnVector(List&lt;GameTurn&gt; turnVector);
&nbsp;
&nbsp;    abstract IGame.Phase getPhase();
&nbsp;
&nbsp;    abstract void setPhase(IGame.Phase phase);
&nbsp;
&nbsp;    abstract IGame.Phase getLastPhase();
&nbsp;
&nbsp;    abstract void setLastPhase(IGame.Phase lastPhase);
&nbsp;
&nbsp;    abstract void setDeploymentComplete(boolean deploymentComplete);
&nbsp;
&nbsp;    abstract boolean isDeploymentComplete();
&nbsp;
&nbsp;    /**
&nbsp;     * Sets up up the hashtable of who deploys when
&nbsp;     */
&nbsp;    abstract void setupRoundDeployment();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if we&#39;ve past our deployment completion
&nbsp;     */
&nbsp;    abstract void checkForCompleteDeployment();
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if we should deploy this round
&nbsp;     */
&nbsp;    abstract boolean shouldDeployThisRound();
&nbsp;
&nbsp;    abstract boolean shouldDeployForRound(int round);
&nbsp;
&nbsp;    /**
&nbsp;     * Clear this round from this list of entities to deploy
&nbsp;     */
&nbsp;    abstract void clearDeploymentThisRound();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of entities that have not yet deployed
&nbsp;     */
&nbsp;    abstract List&lt;Entity&gt; getUndeployedEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of all the entites in the game.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actual vector for the entities
&nbsp;     */
&nbsp;    abstract List&lt;Entity&gt; getEntitiesVector();
&nbsp;
&nbsp;    abstract void setEntitiesVector(List&lt;Entity&gt; entities);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actual vector for the out-of-game entities
&nbsp;     */
&nbsp;    abstract Vector&lt;Entity&gt; getOutOfGameEntitiesVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an out-of-game entity.
&nbsp;     *
&nbsp;     * @param id the &lt;code&gt;int&lt;/code&gt; ID of the out-of-game entity.
&nbsp;     * @return the out-of-game &lt;code&gt;Entity&lt;/code&gt; with that ID. If no
&nbsp;     *         out-of-game entity has that ID, returns a &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    abstract Entity getOutOfGameEntity(int id);
&nbsp;
&nbsp;    /**
&nbsp;     * Swap out the current list of dead (or fled) units for a new one.
&nbsp;     *
&nbsp;     * @param vOutOfGame - the new &lt;code&gt;Vector&lt;/code&gt; of dead or fled units.
&nbsp;     *            This value should &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @throw &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the new list is
&nbsp;     *        &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    abstract void setOutOfGameEntitiesVector(List&lt;Entity&gt; vOutOfGame);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a &lt;code&gt;Vector&lt;/code&gt; containing the &lt;code&gt;Entity&lt;/code&gt;s
&nbsp;     * that are in the same C3 network as the passed-in unit. The output will
&nbsp;     * contain the passed-in unit, if the unit has a C3 computer. If the unit
&nbsp;     * has no C3 computer, the output will be empty (but it will never be
&nbsp;     * &lt;code&gt;null&lt;/code&gt;).
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; whose C3 network co- members is
&nbsp;     *            required. This value may be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; that will contain all other
&nbsp;     *         &lt;code&gt;Entity&lt;/code&gt;s that are in the same C3 network as the
&nbsp;     *         passed-in unit. This &lt;code&gt;Vector&lt;/code&gt; may be empty, but it
&nbsp;     *         will not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @see #getC3SubNetworkMembers(Entity)
&nbsp;     */
&nbsp;    abstract Vector&lt;Entity&gt; getC3NetworkMembers(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a &lt;code&gt;Vector&lt;/code&gt; containing the &lt;code&gt;Entity&lt;/code&gt;s
&nbsp;     * that are in the C3 sub-network under the passed-in unit. The output will
&nbsp;     * contain the passed-in unit, if the unit has a C3 computer. If the unit
&nbsp;     * has no C3 computer, the output will be empty (but it will never be
&nbsp;     * &lt;code&gt;null&lt;/code&gt;). If the passed-in unit is a company commander or a
&nbsp;     * member of a C3i network, this call is the same as
&nbsp;     * &lt;code&gt;getC3NetworkMembers&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; whose C3 network sub- members
&nbsp;     *            is required. This value may be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; that will contain all other
&nbsp;     *         &lt;code&gt;Entity&lt;/code&gt;s that are in the same C3 network under the
&nbsp;     *         passed-in unit. This &lt;code&gt;Vector&lt;/code&gt; may be empty, but it
&nbsp;     *         will not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @see #getC3NetworkMembers(Entity)
&nbsp;     */
&nbsp;    abstract Vector&lt;Entity&gt; getC3SubNetworkMembers(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt; of
&nbsp;     * each unit in this &lt;code&gt;Game&lt;/code&gt; to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt;s at that positions. Units that have no position
&nbsp;     * (e.g. loaded units) will not be in the map.
&nbsp;     *
&nbsp;     * @return a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt;
&nbsp;     *         positions or each unit in the game to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     *         &lt;code&gt;Entity&lt;/code&gt;s at that position.
&nbsp;     */
&nbsp;    abstract Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; getPositionMap();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of salvagable entities.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getGraveyardEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of wrecked entities.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getWreckedEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of entities that have retreated
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getRetreatedEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of entities that were utterly destroyed
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getDevastatedEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of &quot;carcass&quot; entities, i.e., vehicles with dead
&nbsp;     * crews that are still on the map.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getCarcassEntities();
&nbsp;    /**
&nbsp;     * Return the current number of entities in the game.
&nbsp;     */
&nbsp;    abstract int getNoOfEntities();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the appropriate target for this game given a type and id
&nbsp;     */
&nbsp;    abstract Targetable getTarget(int nType, int nID);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity with the given id number, if any.
&nbsp;     */
&nbsp;    abstract Entity getEntity(int id);
&nbsp;
&nbsp;    /**
&nbsp;     * looks for an entity by id number even if out of the game
&nbsp;     */
&nbsp;    abstract Entity getEntityFromAllSources(int id);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a collection of new Entities.  Only one GameEntityNewEvent is
&nbsp;     * created for the whole list.
&nbsp;     *
&nbsp;     * @param entities  The Entity objects to be added.
&nbsp;     */
&nbsp;    abstract void addEntities(List&lt;Entity&gt; entities);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a new Entity to this Game object.
&nbsp;     *
&nbsp;     * @param entity    The Entity to add.
&nbsp;     * @param genEvent  A flag that determiens wheher a GameEntityNewEvent is
&nbsp;     *                  generated.
&nbsp;     */
&nbsp;    abstract void addEntity(Entity entity, boolean genEvent);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a new Entity to this Game object and generates a GameEntityNewEvent.
&nbsp;     *
&nbsp;     * @param entity The Entity to add.
&nbsp;     **/
&nbsp;    void addEntity(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a new Entity.  The id parameter is ignored and addEntity(Entity)
&nbsp;     * is called instead.  This is just to maintain compatibility with the old
&nbsp;     * API.
&nbsp;     *
&nbsp;     * @param id    Value that is ignored: the id is pulled from the passed
&nbsp;     *               Entity
&nbsp;     * @param entity The Entity to add to the game.
&nbsp;     */
&nbsp;    void addEntity(int id, Entity entity);
&nbsp;
&nbsp;    abstract void setEntity(int id, Entity entity);
&nbsp;
&nbsp;    void setEntity(int id, Entity entity, Vector&lt;UnitLocation&gt; movePath);
&nbsp;
&nbsp;    /**
&nbsp;     * @return int containing an unused entity id
&nbsp;     */
&nbsp;    abstract int getNextEntityId();
&nbsp;
&nbsp;    /**
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if an entity with the specified id number
&nbsp;     *         exists in this game.
&nbsp;     */
&nbsp;    abstract boolean hasEntity(int entityId);
&nbsp;
&nbsp;    /**
&nbsp;     * Remove an entity from the master list. If we can&#39;t find that entity,
&nbsp;     * (probably due to double-blind) ignore it.
&nbsp;     */
&nbsp;    abstract void removeEntity(int id, int condition);
&nbsp;
&nbsp;    abstract void removeEntities(List&lt;Integer&gt; ids, int condition);
&nbsp;
&nbsp;    /**
&nbsp;     * Resets this game by removing all entities.
&nbsp;     */
&nbsp;    abstract void reset();
&nbsp;
&nbsp;    /**
&nbsp;     * add a smoke cloud to the list of smoke clouds
&nbsp;     */
&nbsp;    abstract void addSmokeCloud(SmokeCloud cloud);
&nbsp;
&nbsp;    /**
&nbsp;     * get the list of smokeclouds
&nbsp;     */
&nbsp;    abstract List&lt;SmokeCloud&gt; getSmokeCloudList();
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a list of smoke clouds
&nbsp;     * @param cloudsToRemove
&nbsp;     */
&nbsp;    abstract void removeSmokeClouds(List&lt;SmokeCloud&gt; cloudsToRemove);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first entity at the given coordinate, if any. Only returns
&nbsp;     * targetable (non-dead) entities.
&nbsp;     *
&nbsp;     * @param c the coordinates to search at
&nbsp;     */
&nbsp;    abstract Entity getFirstEntity(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first enemy entity at the given coordinate, if any. Only
&nbsp;     * returns targetable (non-dead) entities.
&nbsp;     *
&nbsp;     * @param c the coordinates to search at
&nbsp;     * @param currentEntity the entity that is firing
&nbsp;     */
&nbsp;    abstract Entity getFirstEnemyEntity(Coords c, Entity currentEntity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of the active entities at the given coordinates.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getEntities(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of the active entities at the given coordinates.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getEntities(Coords c, boolean ignore);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a List of the active entities at the given coordinates.
&nbsp;     */
&nbsp;    abstract List&lt;Entity&gt; getEntitiesVector(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a List of the active entities at the given coordinates.
&nbsp;     */
&nbsp;    abstract List&lt;Entity&gt; getEntitiesVector(Coords c, boolean ignore);
&nbsp;
&nbsp;    abstract List&lt;Entity&gt; getAllOffboardEnemyEntities(IPlayer player);
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns a Vector of the gun emplacements at the given coordinates.
&nbsp;     */
&nbsp;    abstract Vector&lt;GunEmplacement&gt; getGunEmplacements(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the given set of coordinates has a gun emplacement on the roof of a building.
&nbsp;     */
&nbsp;    abstract boolean hasRooftopGunEmplacement(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a Target for an Accidental Fall From above, or null if no
&nbsp;     * possible target is there
&nbsp;     *
&nbsp;     * @param c The &lt;code&gt;Coords&lt;/code&gt; of the hex in which the accidental
&nbsp;     *            fall from above happens
&nbsp;     * @param ignore The entity who is falling, so shouldn&#39;t be returned
&nbsp;     * @return The &lt;code&gt;Entity&lt;/code&gt; that should be an AFFA target.
&nbsp;     */
&nbsp;    abstract Entity getAffaTarget(Coords c, Entity ignore);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the enemy&#39;s active entities at
&nbsp;     * the given coordinates.
&nbsp;     *
&nbsp;     * @param c the &lt;code&gt;Coords&lt;/code&gt; of the hex being examined.
&nbsp;     * @param currentEntity the &lt;code&gt;Entity&lt;/code&gt; whose enemies are needed.
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s at the
&nbsp;     *         given coordinates who are enemies of the given unit.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getEnemyEntities(final Coords c,
&nbsp;            final Entity currentEntity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of active enemy entities
&nbsp;     *
&nbsp;     * @param currentEntity the &lt;code&gt;Entity&lt;/code&gt; whose enemies are needed.
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s at the
&nbsp;     *         given coordinates who are enemies of the given unit.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getAllEnemyEntities(final Entity currentEntity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of friendly active entities at the
&nbsp;     * given coordinates.
&nbsp;     *
&nbsp;     * @param c the &lt;code&gt;Coords&lt;/code&gt; of the hex being examined.
&nbsp;     * @param currentEntity the &lt;code&gt;Entity&lt;/code&gt; whose friends are needed.
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s at the
&nbsp;     *         given coordinates who are friends of the given unit.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getFriendlyEntities(final Coords c,
&nbsp;            final Entity currentEntity);
&nbsp;
&nbsp;    /**
&nbsp;     * Moves an entity into the graveyard so it stops getting sent out every
&nbsp;     * phase.
&nbsp;     */
&nbsp;    abstract void moveToGraveyard(int id);
&nbsp;
&nbsp;    /**
&nbsp;     * See if the &lt;code&gt;Entity&lt;/code&gt; with the given ID is out of the game.
&nbsp;     *
&nbsp;     * @param id - the ID of the &lt;code&gt;Entity&lt;/code&gt; to be checked.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Entity&lt;/code&gt; is in the
&nbsp;     *         graveyard, &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    abstract boolean isOutOfGame(int id);
&nbsp;
&nbsp;    /**
&nbsp;     * See if the &lt;code&gt;Entity&lt;/code&gt; is out of the game.
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Entity&lt;/code&gt; is in the
&nbsp;     *         graveyard, &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    abstract boolean isOutOfGame(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first entity that can act in the present turn, or null if
&nbsp;     * none can.
&nbsp;     */
&nbsp;    abstract Entity getFirstEntity();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first entity that can act in the specified turn, or null if
&nbsp;     * none can.33
&nbsp;     */
&nbsp;    abstract Entity getFirstEntity(GameTurn turn);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the id of the first entity that can act in the current turn, or
&nbsp;     * -1 if none can.
&nbsp;     */
&nbsp;    abstract int getFirstEntityNum();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the id of the first entity that can act in the specified turn, or
&nbsp;     * -1 if none can.
&nbsp;     */
&nbsp;    abstract int getFirstEntityNum(GameTurn turn);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the next selectable entity that can act this turn, or null if
&nbsp;     * none can.
&nbsp;     *
&nbsp;     * @param start
&nbsp;     *            the index number to start at (not an Entity Id)
&nbsp;     */
&nbsp;    abstract Entity getNextEntity(int start);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity id of the next entity that can move during the
&nbsp;     * specified
&nbsp;     *
&nbsp;     * @param turn the turn to use
&nbsp;     * @param start the entity id to start at
&nbsp;     */
&nbsp;    abstract int getNextEntityNum(GameTurn turn, int start);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity id of the previous entity that can move during the
&nbsp;     * specified
&nbsp;     *
&nbsp;     * @param turn the turn to use
&nbsp;     * @param start the entity id to start at
&nbsp;     */
&nbsp;    abstract int getPrevEntityNum(GameTurn turn, int start);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the first deployable entity that is valid for the specified turn
&nbsp;     */
&nbsp;    abstract int getFirstDeployableEntityNum(GameTurn turn);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the next deployable entity that is valid for the specified turn
&nbsp;     */
&nbsp;    abstract int getNextDeployableEntityNum(GameTurn turn, int start);
&nbsp;
&nbsp;    /**
&nbsp;     * Get the entities for the player.
&nbsp;     *
&nbsp;     *
&nbsp;     * @param player - the &lt;code&gt;Player&lt;/code&gt; whose entities are required.
&nbsp;     * @param hide - should fighters loaded into squadrons be excluded from this list?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s.
&nbsp;     */
&nbsp;    abstract ArrayList&lt;Entity&gt; getPlayerEntities(IPlayer player, boolean hide);
&nbsp;
&nbsp;    /**
&nbsp;     * Get the entities for the player.
&nbsp;     *
&nbsp;     *
&nbsp;     * @param player - the &lt;code&gt;Player&lt;/code&gt; whose entities are required.
&nbsp;     * @param hide - should fighters loaded into squadrons be excluded from this list?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s.
&nbsp;     */
&nbsp;    abstract ArrayList&lt;Integer&gt; getPlayerEntityIds(IPlayer player, boolean hide);
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the indicated entity is stranded on a transport that can&#39;t
&nbsp;     * move. &lt;p/&gt; According to &lt;a
&nbsp;     * href=&quot;http://www.classicbattletech.com/w3t/showflat.php?Cat=&amp;Board=ask&amp;Number=555466&amp;page=2&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=&quot;&gt;
&nbsp;     * Randall Bills&lt;/a&gt;, the &quot;minimum move&quot; rule allow stranded units to
&nbsp;     * dismount at the start of the turn.
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; that may be stranded
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity is stranded &lt;code&gt;false&lt;/code&gt;
&nbsp;     *         otherwise.
&nbsp;     */
&nbsp;    abstract boolean isEntityStranded(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of remaining selectable infantry owned by a player.
&nbsp;     */
&nbsp;    abstract int getInfantryLeft(int playerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of remaining selectable Protomechs owned by a player.
&nbsp;     */
&nbsp;    abstract int getProtomechsLeft(int playerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of remaining selectable Vehicles owned by a player.
&nbsp;     */
&nbsp;    abstract int getVehiclesLeft(int playerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of remaining selectable Mechs owned by a player.
&nbsp;     */
&nbsp;    abstract int getMechsLeft(int playerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the last, next turn found that the specified entity can move in.
&nbsp;     * Used when, say, an entity dies mid-phase.
&nbsp;     */
&nbsp;    abstract void removeTurnFor(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the first turn found that the specified entity can move in.
&nbsp;     * Used when a turn is played out of order
&nbsp;     */
&nbsp;    abstract GameTurn removeFirstTurnFor(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Removes any turns that can only be taken by the specified entity.  Useful
&nbsp;     * if the specified Entity is being removed from the game to ensure any
&nbsp;     * turns that only it can take are gone.
&nbsp;     * @param entity
&nbsp;     * @return The number of turns returned
&nbsp;     */
&nbsp;    abstract int removeSpecificEntityTurnsFor(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Check each player for the presence of a Battle Armor squad equipped with
&nbsp;     * a Magnetic Clamp. If one unit is found, update that player&#39;s units to
&nbsp;     * allow the squad to be transported. &lt;p/&gt; This method should be called
&nbsp;     * &lt;/b&gt;*ONCE*&lt;/b&gt; per game, after all units for all players have been
&nbsp;     * loaded.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if a unit was updated, &lt;code&gt;false&lt;/code&gt;
&nbsp;     *         if no player has a Battle Armor squad equipped with a Magnetic
&nbsp;     *         Clamp.
&nbsp;     */
&nbsp;    /* Taharqa: I am removing this function and instead I am simply adding clamp mounts to all
&nbsp;     * non omni/ none BA handled mechs in the game.addEntity routine - It should not be too much memory to
&nbsp;     * do this and it allows us to load these units in the lobby
&nbsp;    abstract boolean checkForMagneticClamp();
&nbsp;    */
&nbsp;
&nbsp;    /** Adds the specified action to the actions list for this phase. */
&nbsp;    abstract void addAction(EntityAction ea);
&nbsp;
&nbsp;    abstract void addAttack(AttackHandler ah);
&nbsp;
&nbsp;    abstract void removeAttack(AttackHandler ah);
&nbsp;
&nbsp;    abstract Enumeration&lt;AttackHandler&gt; getAttacks();
&nbsp;
&nbsp;    abstract Vector&lt;AttackHandler&gt; getAttacksVector();
&nbsp;
&nbsp;    abstract void resetAttacks();
&nbsp;
&nbsp;    int getArtillerySize();
&nbsp;
&nbsp;    void setArtilleryVector(Vector&lt;ArtilleryAttackAction&gt; v);
&nbsp;
&nbsp;    Enumeration&lt;ArtilleryAttackAction&gt; getArtilleryAttacks();
&nbsp;
&nbsp;    // HACK.
&nbsp;    abstract void setAttacksVector(Vector&lt;AttackHandler&gt; v);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of actions scheduled for this phase.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;EntityAction&gt; getActions();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the actions list.
&nbsp;     */
&nbsp;    abstract void resetActions();
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all actions by the specified entity
&nbsp;     */
&nbsp;    abstract void removeActionsFor(int entityId);
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a specified action
&nbsp;     *
&nbsp;     * @param o The action to remove.
&nbsp;     */
&nbsp;    abstract void removeAction(Object o);
&nbsp;
&nbsp;    abstract int actionsSize();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actions vector. Do not use to modify the actions; I will be
&nbsp;     * angry. &gt;:[ Used for sending all actions to the client.
&nbsp;     */
&nbsp;    abstract List&lt;EntityAction&gt; getActionsVector();
&nbsp;
&nbsp;    abstract void addInitiativeRerollRequest(Team t);
&nbsp;
&nbsp;    abstract void rollInitAndResolveTies();
&nbsp;
&nbsp;    abstract void handleInitiativeCompensation();
&nbsp;
&nbsp;    abstract int getNoOfInitiativeRerollRequests();
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending displacement attack to the list for this phase.
&nbsp;     */
&nbsp;    abstract void addCharge(AttackAction ea);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of displacement attacks scheduled for the end of
&nbsp;     * the physical phase.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;AttackAction&gt; getCharges();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the pending charges list.
&nbsp;     */
&nbsp;    abstract void resetCharges();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the charges vector. Do not modify. &gt;:[ Used for sending all
&nbsp;     * charges to the client.
&nbsp;     */
&nbsp;    abstract List&lt;AttackAction&gt; getChargesVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending ram attack to the list for this phase.
&nbsp;     */
&nbsp;    abstract void addRam(AttackAction ea);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of ram attacks scheduled for the end of
&nbsp;     * the physical phase.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;AttackAction&gt; getRams();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the pending ram list.
&nbsp;     */
&nbsp;    abstract void resetRams();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the ram vector. Do not modify. &gt;:[ Used for sending all
&nbsp;     * charges to the client.
&nbsp;     */
&nbsp;    abstract List&lt;AttackAction&gt; getRamsVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending tele-missile attack to the list for this phase.
&nbsp;     */
&nbsp;    abstract void addTeleMissileAttack(AttackAction ea);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of telemissile attacks scheduled for the end of
&nbsp;     * the physical phase.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;AttackAction&gt; getTeleMissileAttacks();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the pending telemissile attack list.
&nbsp;     */
&nbsp;    abstract void resetTeleMissileAttacks();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the telemissile attack vector. Do not modify. &gt;:[ Used for sending all
&nbsp;     * charges to the client.
&nbsp;     */
&nbsp;    abstract List&lt;AttackAction&gt; getTeleMissileAttacksVector();
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending PSR to the list for this phase.
&nbsp;     */
&nbsp;    abstract void addPSR(PilotingRollData psr);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of pending PSRs.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;PilotingRollData&gt; getPSRs();
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending extreme Gravity PSR to the list for this phase.
&nbsp;     */
&nbsp;    abstract void addExtremeGravityPSR(PilotingRollData psr);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of pending extreme GravityPSRs.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;PilotingRollData&gt; getExtremeGravityPSRs();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the PSR list for a given entity.
&nbsp;     */
&nbsp;    abstract void resetPSRs(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the extreme Gravity PSR list.
&nbsp;     */
&nbsp;    abstract void resetExtremeGravityPSRs();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the extreme Gravity PSR list for a given entity.
&nbsp;     */
&nbsp;    abstract void resetExtremeGravityPSRs(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the PSR list.
&nbsp;     */
&nbsp;    abstract void resetPSRs();
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property roundCount.
&nbsp;     *
&nbsp;     * @return Value of property roundCount.
&nbsp;     */
&nbsp;    abstract int getRoundCount();
&nbsp;
&nbsp;    abstract void setRoundCount(int roundCount);
&nbsp;
&nbsp;    /**
&nbsp;     * Increments the round counter
&nbsp;     */
&nbsp;    abstract void incrementRoundCount();
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property forceVictory. this tells us that a claim for victory
&nbsp;     * is active.
&nbsp;     *
&nbsp;     * @return Value of property forceVictory.
&nbsp;     */
&nbsp;    abstract boolean isForceVictory();
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property forceVictory.
&nbsp;     *
&nbsp;     * @param forceVictory New value of property forceVictory.
&nbsp;     */
&nbsp;    abstract void setForceVictory(boolean forceVictory);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the given reports vector to the GameReport collection.
&nbsp;     *
&nbsp;     * @param v Vector of reports
&nbsp;     */
&nbsp;    abstract void addReports(Vector&lt;Report&gt; v);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of reports for the given round.
&nbsp;     *
&nbsp;     * @param r Round number
&nbsp;     */
&nbsp;    abstract Vector&lt;Report&gt; getReports(int r);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of all the reports.
&nbsp;     */
&nbsp;    abstract Vector&lt;Vector&lt;Report&gt;&gt; getAllReports();
&nbsp;
&nbsp;    /**
&nbsp;     * Used to populate previous game reports, e.g. after a client connects to
&nbsp;     * an existing game.
&nbsp;     */
&nbsp;    void setAllReports(Vector&lt;Vector&lt;Report&gt;&gt; v);
&nbsp;
&nbsp;    /**
&nbsp;     * Clears out all the current reports, paving the way for a new game.
&nbsp;     */
&nbsp;    void clearAllReports();
&nbsp;
&nbsp;    abstract void end(int winner, int winnerTeam);
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property victoryPlayerId. itmo: apparently this is the guy who
&nbsp;     * claims to have won the game also used to tell who won when the game is
&nbsp;     * won
&nbsp;     *
&nbsp;     * @return Value of property victoryPlayerId.
&nbsp;     */
&nbsp;    abstract int getVictoryPlayerId();
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property victoryPlayerId.
&nbsp;     *
&nbsp;     * @param victoryPlayerId New value of property victoryPlayerId.
&nbsp;     */
&nbsp;    abstract void setVictoryPlayerId(int victoryPlayerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property victoryTeam. corresponding claiming/winning team if
&nbsp;     * the player is in a team
&nbsp;     *
&nbsp;     * @return Value of property victoryTeam.
&nbsp;     */
&nbsp;    abstract int getVictoryTeam();
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property victoryTeam.
&nbsp;     *
&nbsp;     * @param victoryTeam New value of property victoryTeam.
&nbsp;     */
&nbsp;    abstract void setVictoryTeam(int victoryTeam);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the specified player is either the victor, or is on the
&nbsp;     * winning team. Best to call during PHASE_VICTORY.
&nbsp;     * @param player
&nbsp;     */
&nbsp;    abstract boolean isPlayerVictor(IPlayer player);
&nbsp;
&nbsp;    /**
&nbsp;     * Shortcut to isPlayerVictor(Player player)
&nbsp;     */
&nbsp;    abstract boolean isPlayerVictor(int playerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Get all &lt;code&gt;Entity&lt;/code&gt;s that pass the given selection criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test
&nbsp;     *            that an entity must pass to be included. This value may be
&nbsp;     *            &lt;code&gt;null&lt;/code&gt; (in which case all entities in the game
&nbsp;     *            will be returned).
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of all entities that the selector
&nbsp;     *         accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     *         empty.
&nbsp;     */
&nbsp;    abstract Iterator&lt;Entity&gt; getSelectedEntities(
&nbsp;            EntitySelector selector);
&nbsp;
&nbsp;    /**
&nbsp;     * Count all &lt;code&gt;Entity&lt;/code&gt;s that pass the given selection criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test
&nbsp;     *            that an entity must pass to be included. This value may be
&nbsp;     *            &lt;code&gt;null&lt;/code&gt; (in which case the count of all entities
&nbsp;     *            in the game will be returned).
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; count of all entities that the selector
&nbsp;     *         accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     *         empty.
&nbsp;     */
&nbsp;    abstract int getSelectedEntityCount(EntitySelector selector);
&nbsp;
&nbsp;    /**
&nbsp;     * Get all out-of-game &lt;code&gt;Entity&lt;/code&gt;s that pass the given selection
&nbsp;     * criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test
&nbsp;     *            that an entity must pass to be included. This value may be
&nbsp;     *            &lt;code&gt;null&lt;/code&gt; (in which case all entities in the game
&nbsp;     *            will be returned).
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of all entities that the selector
&nbsp;     *         accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     *         empty.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getSelectedOutOfGameEntities(
&nbsp;            EntitySelector selector);
&nbsp;
&nbsp;    /**
&nbsp;     * Count all out-of-game&lt;code&gt;Entity&lt;/code&gt;s that pass the given
&nbsp;     * selection criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test
&nbsp;     *            that an entity must pass to be included. This value may be
&nbsp;     *            &lt;code&gt;null&lt;/code&gt; (in which case the count of all
&nbsp;     *            out-of-game entities will be returned).
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; count of all entities that the selector
&nbsp;     *         accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     *         empty.
&nbsp;     */
&nbsp;    abstract int getSelectedOutOfGameEntityCount(EntitySelector selector);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the player has any valid units this turn that are not
&nbsp;     * infantry, not protomechs, or not either of those. This method is
&nbsp;     * utitilized by the &quot;A players Infantry moves after that players other
&nbsp;     * units&quot;, and &quot;A players Protomechs move after that players other units&quot;
&nbsp;     * options.
&nbsp;     */
&nbsp;    abstract boolean checkForValidNonInfantryAndOrProtomechs(int playerId);
&nbsp;
&nbsp;    /**
&nbsp;     * Get Entities that have have a iNarc Nemesis pod attached and are situated
&nbsp;     * between two Coords
&nbsp;     *
&nbsp;     * @param attacker The attacking &lt;code&gt;Entity&lt;/code&gt;.
&nbsp;     * @param target The &lt;code&gt;Coords&lt;/code&gt; of the original target.
&nbsp;     * @return a &lt;code&gt;Enumeration&lt;/code&gt; of entities that have nemesis pods
&nbsp;     *         attached and are located between attacker and target and are
&nbsp;     *         friendly with the attacker.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;Entity&gt; getNemesisTargets(Entity attacker,
&nbsp;            Coords target);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the previous entity from the master list of entities. Will wrap
&nbsp;     * around to the end of the list if necessary.
&nbsp;     *
&nbsp;     * @param current The &lt;code&gt;Entity&lt;/code&gt; whose list position you wish to
&nbsp;     *            start from.
&nbsp;     * @return The previous &lt;code&gt;Entity&lt;/code&gt; in the list.
&nbsp;     */
&nbsp;    abstract Entity getPreviousEntityFromList(Entity current);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the next entity from the master list of entities. Will wrap
&nbsp;     * around to the begining of the list if necessary.
&nbsp;     *
&nbsp;     * @param current The &lt;code&gt;Entity&lt;/code&gt; whose list position you wish to
&nbsp;     *            start from.
&nbsp;     * @return The next &lt;code&gt;Entity&lt;/code&gt; in the list.
&nbsp;     */
&nbsp;    abstract Entity getNextEntityFromList(Entity current);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this turn&#39;s tag information
&nbsp;     */
&nbsp;    abstract Vector&lt;TagInfo&gt; getTagInfo();
&nbsp;
&nbsp;    /**
&nbsp;     * add the results of one tag attack
&nbsp;     */
&nbsp;    abstract void addTagInfo(TagInfo info);
&nbsp;
&nbsp;    /**
&nbsp;     * clears the &quot;shots&quot; attribute of all TagInfos where attacker is on same
&nbsp;     * team as ae and target is on same mapsheet as tc
&nbsp;     */
&nbsp;    abstract void clearTagInfoShots(Entity ae, Coords tc);
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Computes whether two coordinates are within 8 hexes of each other
&nbsp;     *
&nbsp;     * @param c1 The first coordinate
&nbsp;     * @param c2 The second coordinate
&nbsp;     * @return True if both coordinates are within 8 hexes of each other
&nbsp;     */
&nbsp;    boolean isIn8HexRadius(Coords c1, Coords c2);
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Reset tag information
&nbsp;     */
&nbsp;    abstract void resetTagInfo();
&nbsp;
&nbsp;    /**
&nbsp;     * Get a list of flares
&nbsp;     */
&nbsp;    abstract Vector&lt;Flare&gt; getFlares();
&nbsp;
&nbsp;    /**
&nbsp;     * Set the list of flares
&nbsp;     */
&nbsp;    abstract void setFlares(Vector&lt;Flare&gt; flares);
&nbsp;
&nbsp;    /**
&nbsp;     * Add a new flare
&nbsp;     */
&nbsp;    abstract void addFlare(Flare flare);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the level of illumination for a given coords.  Different light
&nbsp;     * sources affect how much the night-time penalties are reduced. Note: this
&nbsp;     * method should be used for determining is a Coords/Hex is illuminated, not
&nbsp;     * IGame. getIlluminatedPositions(), as that just returns the hexes that
&nbsp;     * are effected by spotlights, whereas this one considers searchlights as
&nbsp;     * well as other light sources.
&nbsp;     */
&nbsp;    abstract int isPositionIlluminated(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Age the flare list and remove any which have burnt out Artillery flares
&nbsp;     * drift with wind. (called at end of turn)
&nbsp;     */
&nbsp;    abstract Vector&lt;Report&gt; ageFlares();
&nbsp;
&nbsp;    abstract boolean gameTimerIsExpired();
&nbsp;
&nbsp;    /**
&nbsp;     * use victoryfactory to generate a new victorycondition checker provided
&nbsp;     * that the victorycontext is saved properly, calling this method at any
&nbsp;     * time is ok and should not affect anything unless the
&nbsp;     * victorycondition-configoptions have changed.
&nbsp;     */
&nbsp;    abstract void createVictoryConditions();
&nbsp;
&nbsp;    abstract Victory getVictory();
&nbsp;
&nbsp;    abstract boolean useVectorMove();
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending control roll to the list for this phase.
&nbsp;     */
&nbsp;    abstract void addControlRoll(PilotingRollData control);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of pending Control roll.
&nbsp;     */
&nbsp;    abstract Enumeration&lt;PilotingRollData&gt; getControlRolls();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the Control Roll list for a given entity.
&nbsp;     */
&nbsp;    abstract void resetControlRolls(Entity entity);
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the Control Roll list.
&nbsp;     */
&nbsp;    abstract void resetControlRolls();
&nbsp;
&nbsp;    abstract boolean checkForValidSpaceStations(int playerId);
&nbsp;
&nbsp;    abstract boolean checkForValidJumpships(int playerId);
&nbsp;
&nbsp;    abstract boolean checkForValidWarships(int playerId);
&nbsp;
&nbsp;    abstract boolean checkForValidDropships(int playerId);
&nbsp;
&nbsp;    abstract boolean checkForValidSmallCraft(int playerId);
&nbsp;
&nbsp;    abstract PlanetaryConditions getPlanetaryConditions();
&nbsp;
&nbsp;    abstract void setPlanetaryConditions(PlanetaryConditions conditions);
&nbsp;
&nbsp;    /**
&nbsp;     * Get a set of Coords illuminated by searchlights.
&nbsp;     *
&nbsp;     * Note: coords could be illuminated by other sources as well, it&#39;s likely
&nbsp;     * that IGame.isPositionIlluminated is desired unless the searchlighted hex
&nbsp;     * set is being sent to the client or server.
&nbsp;     */
&nbsp;    abstract HashSet&lt;Coords&gt; getIlluminatedPositions();
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the set of searchlight illuminated hexes.
&nbsp;     */
&nbsp;    abstract void clearIlluminatedPositions();
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for the list of Coords illuminated by search lights.
&nbsp;     */
&nbsp;    abstract void setIlluminatedPositions(HashSet&lt;Coords&gt; ip);
&nbsp;
&nbsp;    /**
&nbsp;     * Add a new hex to the collection of Coords illuminated by searchlights.
&nbsp;     *
&nbsp;     * @return True if a new hex was added, else false if the set already
&nbsp;     *      contained the input hex.
&nbsp;     */
&nbsp;    abstract boolean addIlluminatedPosition(Coords c);
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the map that maps a position to the list of Entity&#39;s in that
&nbsp;     * position.
&nbsp;     *
&nbsp;     * @param e
&nbsp;     */
&nbsp;    abstract void updateEntityPositionLookup(Entity e,
&nbsp;            HashSet&lt;Coords&gt; oldPositions);
&nbsp;
&nbsp;    public abstract String getUUIDString();
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
