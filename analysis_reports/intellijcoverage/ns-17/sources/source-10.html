


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Board</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: Board (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Board</td>
<td class="coverageStat">
  <span class="percent">
    2.9%
  </span>
  <span class="absValue">
    (3/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.6%
  </span>
  <span class="absValue">
    (20/765)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$0HjlHdgL</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$2VDYPODG</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$3mQJ4Uz1</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$45KBbVDs</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$46qHOlIJ</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$4BKBQUYX</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$4ukYoTXx</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$7eDdpINB</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$8ibt1uZh</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$8XdGcmvU</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$9MglCyKn</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$AB8birnz</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$AE44plzT</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$akBpB2eq</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$ayq9VWff</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$b0Geb6eT</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$BAOeU3Mf</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$BumZEtZp</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$bvrOz7At</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$cf5Oftjl</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$CHCBSJmq</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$clCtH6jN</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$DViQGRyS</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$EbZt35xp</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$eHgIKldT</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$eiGT91B8</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$EO7Wek3y</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$ExEevcsL</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$FASl2cDr</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$FjlgLzRc</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$fKwL6ts1</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$gThRIuo4</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$GXjnxyiu</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$H4NSqFNc</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$i4fSr4NY</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$IdzS9eo4</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$iN40tGUx</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$IUeeoSgf</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$Iyp0FLFM</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$j6K1WxLS</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$jcCNVWQG</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$K3fNNkTQ</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$kAi1jmGk</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$kCXgce4B</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$kF8fsGaS</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$KkOTNFtO</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$LDLUFgvB</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$m1wdd1BG</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$M8iPX3Dg</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$NDphq7i3</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$nNSPanph</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$NUNEJqxR</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$OFlL1PmQ</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$Ohci0nZp</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$P15HRK22</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$PexVOgVm</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$QAdVgDv4</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$QHWfhGZi</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$QRaUMZpj</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$qTwbteiI</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$R1lrISEQ</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$R4zBzmIr</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$RskNaJEk</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$RvtbgwIS</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$sImUQdxw</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$sWVkCP2D</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$uH5pXnbA</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$V8HKBOXc</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$vK0md1zi</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$vz4F8eDL</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$WD3TEZ6O</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$WJHAUc3T</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$WW20jvfD</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$WzMGJmyK</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$xMbB8iUk</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$xWIgUDsg</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$y0GJyC0F</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$Y4Pt4Qdy</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$YqsgC3gM</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$yrIDwAYe</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$YwcAGRqF</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$YwEUFx3c</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$ywuMH6aX</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$yzv0tdt7</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$Z2Qsz7Ff</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$znU3Ui2N</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$zo6xBv8n</td>
  </tr>
  <tr>
    <td class="name">Board$MockitoMock$1974896685$auxiliary$ZrzoQoYx</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    2.9%
  </span>
  <span class="absValue">
    (3/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.6%
  </span>
  <span class="absValue">
    (20/765)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000,2001,2002,2003,2004 Ben Mazur (bmazur@sev.org)
&nbsp; * Copyright © 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.FileReader;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.OutputStreamWriter;
&nbsp;import java.io.Reader;
&nbsp;import java.io.Serializable;
&nbsp;import java.io.StreamTokenizer;
&nbsp;import java.io.Writer;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.client.ui.swing.GUIPreferences;
&nbsp;import megamek.common.Building.BasementType;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.event.BoardEvent;
&nbsp;import megamek.common.event.BoardListener;
&nbsp;import megamek.common.util.fileUtils.MegaMekFile;
&nbsp;
&nbsp;public class Board implements Serializable, IBoard {
&nbsp;    private static final long serialVersionUID = -5744058872091016636L;
&nbsp;
&nbsp;    public static final String BOARD_REQUEST_ROTATION = &quot;rotate:&quot;;
&nbsp;
&nbsp;    // starting positions
&nbsp;    public static final int START_NONE = -1;
&nbsp;    public static final int START_ANY = 0;
&nbsp;    public static final int START_NW = 1;
&nbsp;    public static final int START_N = 2;
&nbsp;    public static final int START_NE = 3;
&nbsp;    public static final int START_E = 4;
&nbsp;    public static final int START_SE = 5;
&nbsp;    public static final int START_S = 6;
&nbsp;    public static final int START_SW = 7;
&nbsp;    public static final int START_W = 8;
&nbsp;    public static final int START_EDGE = 9;
&nbsp;    public static final int START_CENTER = 10;
&nbsp;    
&nbsp;    //Board Dimensions
&nbsp;    //Used for things like artillery rules that reference the standard mapsheet dimensions
&nbsp;    public static final int DEFAULT_BOARD_HEIGHT = 17;
&nbsp;    public static final int DEFAULT_BOARD_WIDTH = 16;
&nbsp;    //Variable board width and height. Used for most everything else since we&#39;re not restricted to paper map sizes
&nbsp;    protected int width;
&nbsp;    protected int height;
&nbsp;
&nbsp;    // MapType
&nbsp;    public static final int T_GROUND = 0;
&nbsp;    public static final int T_ATMOSPHERE = 1;
&nbsp;    public static final int T_SPACE = 2;
&nbsp;
<b class="fc">&nbsp;    private static final String[] typeNames = { &quot;Ground&quot;, &quot;Low Atmosphere&quot;, &quot;Space&quot; };</b>
&nbsp;
&nbsp;    // Min and Max elevation values for when they are undefined (since you cant
&nbsp;    // set an int to null).
&nbsp;    private static final int UNDEFINED_MIN_ELEV = 10000;
&nbsp;    private static final int UNDEFINED_MAX_ELEV = -10000;
&nbsp;
&nbsp;    // The min and max elevation values for this board.
&nbsp;    // set when getMinElevation/getMax is called for the first time.
<b class="fc">&nbsp;    private int minElevation = UNDEFINED_MIN_ELEV;</b>
<b class="fc">&nbsp;    private int maxElevation = UNDEFINED_MAX_ELEV;</b>
&nbsp;
<b class="fc">&nbsp;    private int mapType = T_GROUND;</b>
&nbsp;
&nbsp;    private IHex[] data;
&nbsp;
&nbsp;    /**
&nbsp;     * The path to the file to load as background image for this board. To avoid
&nbsp;     * the Server sending a serialized image, the image isn&#39;t loaded until
&nbsp;     * requested.
&nbsp;     */
<b class="fc">&nbsp;    private List&lt;String&gt; backgroundPaths = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of how many boards were combined to create this board. These
&nbsp;     * are necessary to properly index into the background image, and only need
&nbsp;     * to be set if backgroundPaths are present.
&nbsp;     */
&nbsp;    private int numBoardsWidth, numBoardsHeight;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the size of the boards used to create this board. These
&nbsp;     * are necessary to properly index into the background image, and only need
&nbsp;     * to be set if backgroundPaths are present.
&nbsp;     */
&nbsp;    private int subBoardWidth, subBoardHeight;
&nbsp;
&nbsp;    /**
&nbsp;     * Flags that determine if the background image should be flipped. These are
&nbsp;     * necessary to properly index into the background image, and only need to
&nbsp;     * be set if backgroundPaths are present.
&nbsp;     */
<b class="fc">&nbsp;    private List&lt;Boolean&gt; flipBGHoriz = new ArrayList&lt;&gt;(), flipBGVert = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Building data structures.
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Building&gt; buildings = new Vector&lt;Building&gt;();</b>
<b class="fc">&nbsp;    private transient Hashtable&lt;Coords, Building&gt; bldgByCoords = new Hashtable&lt;Coords, Building&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    protected transient Vector&lt;BoardListener&gt; boardListeners = new Vector&lt;BoardListener&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Record the infernos placed on the board.
&nbsp;     */
<b class="fc">&nbsp;    private Hashtable&lt;Coords, InfernoTracker&gt; infernos = new Hashtable&lt;Coords, InfernoTracker&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt; specialHexes = new Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Option to turn have roads auto-exiting to pavement.
&nbsp;     */
<b class="fc">&nbsp;    private boolean roadsAutoExit = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the map.
&nbsp;     */
&nbsp;    private String description;
&nbsp;
&nbsp;    /**
&nbsp;     * Per-hex annotations on the map.
&nbsp;     */
<b class="fc">&nbsp;    private Map&lt;Coords, Collection&lt;String&gt;&gt; annotations = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new board with zero as its width and height parameters.
&nbsp;     */
&nbsp;    public Board() {
<b class="fc">&nbsp;        this(0, 0);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new board of the specified dimensions. All hexes in the board
&nbsp;     * will be null until otherwise set.
&nbsp;     *
&nbsp;     * @param width
&nbsp;     *            the width dimension.
&nbsp;     * @param height
&nbsp;     *            the height dimension.
&nbsp;     */
<b class="fc">&nbsp;    public Board(int width, int height) {</b>
<b class="fc">&nbsp;        this.width = width;</b>
<b class="fc">&nbsp;        this.height = height;</b>
<b class="fc">&nbsp;        data = new IHex[width * height];</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new board of the specified dimensions and specified hex data.
&nbsp;     *
&nbsp;     * @param width
&nbsp;     *            the width dimension.
&nbsp;     * @param height
&nbsp;     *            the height dimension.
&nbsp;     * @param data
&nbsp;     */
<b class="nc">&nbsp;    public Board(int width, int height, IHex[] data) {</b>
<b class="nc">&nbsp;        this.width = width;</b>
<b class="nc">&nbsp;        this.height = height;</b>
<b class="nc">&nbsp;        this.data = new IHex[width * height];</b>
<b class="nc">&nbsp;        for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; width; x++) {</b>
<b class="nc">&nbsp;                this.data[(y * width) + x] = data[(y * width) + x];</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new board of the specified dimensions, hexes, buildings, and
&nbsp;     * inferno trackers. Do *not* use this method unless you have carefully
&nbsp;     * examined this class.
&nbsp;     *
&nbsp;     * @param width
&nbsp;     *            The &lt;code&gt;int&lt;/code&gt; width dimension in hexes.
&nbsp;     * @param height
&nbsp;     *            The &lt;code&gt;int&lt;/code&gt; height dimension in hexes.
&nbsp;     * @param hexes
&nbsp;     *            The array of &lt;code&gt;Hex&lt;/code&gt;es for this board. This object is
&nbsp;     *            used directly without being copied. This value should only be
&nbsp;     *            &lt;code&gt;null&lt;/code&gt; if either &lt;code&gt;width&lt;/code&gt; or
&nbsp;     *            &lt;code&gt;height&lt;/code&gt; is zero.
&nbsp;     * @param bldgs
&nbsp;     *            The &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s for this
&nbsp;     *            board. This object is used directly without being copied.
&nbsp;     * @param infMap
&nbsp;     *            The &lt;code&gt;Hashtable&lt;/code&gt; that map &lt;code&gt;Coords&lt;/code&gt; to
&nbsp;     *            &lt;code&gt;InfernoTracker&lt;/code&gt;s for this board. This object is
&nbsp;     *            used directly without being copied.
&nbsp;     */
&nbsp;    public Board(int width, int height, IHex[] hexes, Vector&lt;Building&gt; bldgs,
<b class="nc">&nbsp;            Hashtable&lt;Coords, InfernoTracker&gt; infMap) {</b>
<b class="nc">&nbsp;        this.width = width;</b>
<b class="nc">&nbsp;        this.height = height;</b>
<b class="nc">&nbsp;        data = hexes;</b>
<b class="nc">&nbsp;        buildings = bldgs;</b>
<b class="nc">&nbsp;        infernos = infMap;</b>
<b class="nc">&nbsp;        createBldgByCoords();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#getHeight()
&nbsp;     */
&nbsp;    public int getHeight() {
<b class="nc">&nbsp;        return height;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Coords getCenter() {
<b class="nc">&nbsp;        return new Coords(getWidth() / 2, getHeight() / 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#getWidth()
&nbsp;     */
&nbsp;    public int getWidth() {
<b class="nc">&nbsp;        return width;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#newData(int, int, megamek.common.IHex[])
&nbsp;     */
&nbsp;    public void newData(int width, int height, IHex[] data, StringBuffer errBuff) {
<b class="nc">&nbsp;        this.width = width;</b>
<b class="nc">&nbsp;        this.height = height;</b>
<b class="nc">&nbsp;        this.data = data;</b>
&nbsp;
<b class="nc">&nbsp;        initializeAll(errBuff);</b>
<b class="nc">&nbsp;        processBoardEvent(new BoardEvent(this, null, BoardEvent.BOARD_NEW_BOARD));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#newData(int, int)
&nbsp;     */
&nbsp;    public void newData(int width, int height) {
<b class="nc">&nbsp;        newData(width, height, new IHex[width * height], null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Board contains the (x, y) Coords, and if so, returns
&nbsp;     * the Hex at that position.
&nbsp;     *
&nbsp;     * @param x
&nbsp;     *            the x Coords.
&nbsp;     * @param y
&nbsp;     *            the y Coords.
&nbsp;     * @return the Hex, if this Board contains the (x, y) location; null
&nbsp;     *         otherwise.
&nbsp;     */
&nbsp;    public IHex getHex(int x, int y) {
<b class="nc">&nbsp;        if (contains(x, y)) {</b>
<b class="nc">&nbsp;            return data[(y * width) + x];</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the hex in the specified direction from the specified starting
&nbsp;     * coordinates.
&nbsp;     */
&nbsp;    public IHex getHexInDir(Coords c, int dir) {
<b class="nc">&nbsp;        return getHex(c.xInDir(dir), c.yInDir(dir));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the hex in the specified direction from the specified starting
&nbsp;     * coordinates. Avoids calls to Coords.translated, and thus, object
&nbsp;     * construction.
&nbsp;     */
&nbsp;    public IHex getHexInDir(int x, int y, int dir) {
<b class="nc">&nbsp;        return getHex(Coords.xInDir(x, y, dir), Coords.yInDir(x, y, dir));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initialize all hexes
&nbsp;     */
&nbsp;    protected void initializeAll(StringBuffer errBuff) {
&nbsp;        // Initialize all buildings.
<b class="nc">&nbsp;        buildings.removeAllElements();</b>
<b class="nc">&nbsp;        if (bldgByCoords == null) {</b>
<b class="nc">&nbsp;            bldgByCoords = new Hashtable&lt;Coords, Building&gt;();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            bldgByCoords.clear();</b>
&nbsp;        }
&nbsp;        // Walk through the hexes, creating buildings.
<b class="nc">&nbsp;        for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; width; x++) {</b>
&nbsp;                // Does this hex contain a building?
<b class="nc">&nbsp;                IHex curHex = getHex(x, y);</b>
<b class="nc">&nbsp;                if ((curHex != null) &amp;&amp; (curHex.containsTerrain(Terrains.BUILDING))) {</b>
&nbsp;                    // Yup, but is it a repeat?
<b class="nc">&nbsp;                    Coords coords = new Coords(x, y);</b>
<b class="nc">&nbsp;                    if (!bldgByCoords.containsKey(coords)) {</b>
&nbsp;
&nbsp;                        // Nope. Try to create an object for the new building.
&nbsp;                        try {
<b class="nc">&nbsp;                            Building bldg = new Building(coords, this, Terrains.BUILDING,</b>
<b class="nc">&nbsp;                                    BasementType.getType(curHex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)));</b>
<b class="nc">&nbsp;                            buildings.addElement(bldg);</b>
&nbsp;
&nbsp;                            // Each building will identify the hexes it covers.
<b class="nc">&nbsp;                            Enumeration&lt;Coords&gt; iter = bldg.getCoords();</b>
<b class="nc">&nbsp;                            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                                bldgByCoords.put(iter.nextElement(), bldg);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch (IllegalArgumentException excep) {</b>
&nbsp;                            // Log the error and remove the
&nbsp;                            // building from the board.
<b class="nc">&nbsp;                            if (errBuff == null) {</b>
<b class="nc">&nbsp;                                MegaMek.getLogger().error(this, &quot;Unable to create building.&quot;);</b>
<b class="nc">&nbsp;                                excep.printStackTrace();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                errBuff.append(&quot;Unable to create building at &quot; + coords.toString() + &quot;!\n&quot;);</b>
<b class="nc">&nbsp;                                errBuff.append(excep.getMessage() + &quot;\n&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            curHex.removeTerrain(Terrains.BUILDING);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } // End building-is-new
&nbsp;                } // End hex-has-building
<b class="nc">&nbsp;                if ((curHex != null) &amp;&amp; (curHex.containsTerrain(Terrains.FUEL_TANK))) {</b>
&nbsp;                    // Yup, but is it a repeat?
<b class="nc">&nbsp;                    Coords coords = new Coords(x, y);</b>
<b class="nc">&nbsp;                    if (!bldgByCoords.containsKey(coords)) {</b>
&nbsp;
&nbsp;                        // Nope. Try to create an object for the new building.
&nbsp;                        try {
<b class="nc">&nbsp;                            int magnitude = curHex.getTerrain(Terrains.FUEL_TANK_MAGN).getLevel();</b>
<b class="nc">&nbsp;                            FuelTank bldg = new FuelTank(coords, this, Terrains.FUEL_TANK, magnitude);</b>
<b class="nc">&nbsp;                            buildings.addElement(bldg);</b>
&nbsp;
&nbsp;                            // Each building will identify the hexes it covers.
<b class="nc">&nbsp;                            Enumeration&lt;Coords&gt; iter = bldg.getCoords();</b>
<b class="nc">&nbsp;                            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                                bldgByCoords.put(iter.nextElement(), bldg);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch (IllegalArgumentException excep) {</b>
&nbsp;                            // Log the error and remove the
&nbsp;                            // fuel tank from the board.
<b class="nc">&nbsp;                            if (errBuff == null) {</b>
<b class="nc">&nbsp;                                MegaMek.getLogger().error(this, &quot;Unable to create fuel tank.&quot;);</b>
<b class="nc">&nbsp;                                excep.printStackTrace();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                errBuff.append(&quot;Unable to create fuel tank at &quot; + coords.toString() + &quot;!\n&quot;);</b>
<b class="nc">&nbsp;                                errBuff.append(excep.getMessage() + &quot;\n&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            curHex.removeTerrain(Terrains.FUEL_TANK);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } // End building-is-new
&nbsp;                } // End hex-has-building
<b class="nc">&nbsp;                if ((curHex != null) &amp;&amp; curHex.containsTerrain(Terrains.BRIDGE)) {</b>
&nbsp;
&nbsp;                    // Yup, but is it a repeat?
<b class="nc">&nbsp;                    Coords coords = new Coords(x, y);</b>
<b class="nc">&nbsp;                    if (!bldgByCoords.containsKey(coords)) {</b>
&nbsp;
&nbsp;                        // Nope. Try to create an object for the new building.
&nbsp;                        try {
<b class="nc">&nbsp;                            Building bldg = new Building(coords, this, Terrains.BRIDGE, BasementType.NONE);</b>
<b class="nc">&nbsp;                            buildings.addElement(bldg);</b>
&nbsp;
&nbsp;                            // Each building will identify the hexes it covers.
<b class="nc">&nbsp;                            Enumeration&lt;Coords&gt; iter = bldg.getCoords();</b>
<b class="nc">&nbsp;                            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                                bldgByCoords.put(iter.nextElement(), bldg);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch (IllegalArgumentException excep) {</b>
&nbsp;                            // Log the error and remove the
&nbsp;                            // bridge from the board.
<b class="nc">&nbsp;                            if (errBuff == null) {</b>
<b class="nc">&nbsp;                                MegaMek.getLogger().error(this, &quot;Unable to create bridge.&quot;);</b>
<b class="nc">&nbsp;                                excep.printStackTrace();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                errBuff.append(&quot;Unable to create bridge at &quot; + coords.toString() + &quot;!\n&quot;);</b>
<b class="nc">&nbsp;                                errBuff.append(excep.getMessage() + &quot;\n&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            curHex.removeTerrain(Terrains.BRIDGE);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                    } // End bridge-is-new
&nbsp;
&nbsp;                } // End hex-has-bridge
&nbsp;            }
&nbsp;        }
&nbsp;        // Initialize all exits.
<b class="nc">&nbsp;        for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; width; x++) {</b>
<b class="nc">&nbsp;                initializeHex(x, y, false);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        processBoardEvent(new BoardEvent(this, null, BoardEvent.BOARD_CHANGED_ALL_HEXES));</b>
&nbsp;        // good time to ensure hex cache
<b class="nc">&nbsp;        IdealHex.ensureCacheSize(width + 1, height + 1);</b>
&nbsp;
<b class="nc">&nbsp;    } // End private void initializeAll()</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initialize a hex and the hexes around it
&nbsp;     */
&nbsp;    public void initializeAround(int x, int y) {
<b class="nc">&nbsp;        initializeHex(x, y);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            initializeInDir(x, y, i);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes a hex in a specific direction from an origin hex
&nbsp;     */
&nbsp;    private void initializeInDir(int x, int y, int dir) {
<b class="nc">&nbsp;        initializeHex(Coords.xInDir(x, y, dir), Coords.yInDir(x, y, dir));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes a hex in its surroundings. Currently sets the connects
&nbsp;     * parameter appropriately to the surrounding hexes. If a surrounding hex is
&nbsp;     * off the board, it checks the hex opposite the missing hex.
&nbsp;     */
&nbsp;    public void initializeHex(int x, int y) {
<b class="nc">&nbsp;        initializeHex(x, y, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void initializeHex(int x, int y, boolean event) {
<b class="nc">&nbsp;        IHex hex = getHex(x, y);</b>
&nbsp;
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Always make the coords of the hex match the actual position on the board
<b class="nc">&nbsp;        hex.setCoords(new Coords(x, y));</b>
&nbsp;        
<b class="nc">&nbsp;        hex.clearExits();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            IHex other = getHexInDir(x, y, i);</b>
<b class="nc">&nbsp;            hex.setExits(other, i, roadsAutoExit);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Internally handled terrain (inclines, cliff-bottoms)
<b class="nc">&nbsp;        initializeAutomaticTerrain(x, y);</b>
&nbsp;        
&nbsp;        // Add woods/jungle elevation where none was saved
<b class="nc">&nbsp;        initializeFoliageElev(x, y);</b>
&nbsp;        
<b class="nc">&nbsp;        if (event) {</b>
<b class="nc">&nbsp;            processBoardEvent(new BoardEvent(this, new Coords(x, y), BoardEvent.BOARD_CHANGED_HEX));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /** Adds the FOLIAGE_ELEV terrain when none is present. */
&nbsp;    private void initializeFoliageElev(int x, int y) {
<b class="nc">&nbsp;        IHex hex = getHex(x, y);</b>
&nbsp;
&nbsp;        // If the foliage elevation is present or the hex doesn&#39;t even have foliage,
&nbsp;        // nothing needs to be done
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.FOLIAGE_ELEV) || </b>
<b class="nc">&nbsp;                (!hex.containsTerrain(Terrains.WOODS) &amp;&amp; !hex.containsTerrain(Terrains.JUNGLE))) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Foliage is missing, therefore add it with the standard TW values
&nbsp;        // elevation 3 for Ultra Woods/Jungle and 2 for Light/Heavy
<b class="nc">&nbsp;        if (hex.terrainLevel(Terrains.WOODS) == 3 || hex.terrainLevel(Terrains.JUNGLE) == 3) {</b>
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                    .createTerrain(Terrains.FOLIAGE_ELEV, 3));    </b>
&nbsp;        } else {
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                    .createTerrain(Terrains.FOLIAGE_ELEV, 2));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /** 
&nbsp;     * Checks all hex edges of the hex at (x,y) if automatically handled 
&nbsp;     * terrains such as inclines must be placed or removed. 
&nbsp;     */
&nbsp;    private void initializeAutomaticTerrain(int x, int y) {
<b class="nc">&nbsp;        IHex hex = getHex(x, y);</b>
<b class="nc">&nbsp;        int origCliffTopExits = 0;</b>
<b class="nc">&nbsp;        int correctedCliffTopExits = 0;</b>
<b class="nc">&nbsp;        int cliffBotExits = 0;</b>
<b class="nc">&nbsp;        int inclineTopExits = 0;</b>
<b class="nc">&nbsp;        int inclineBotExits = 0;</b>
<b class="nc">&nbsp;        int highInclineTopExits = 0;</b>
<b class="nc">&nbsp;        int highInclineBotExits = 0;</b>
&nbsp;
&nbsp;        // Get the currently set cliff-tops for correction. When exits
&nbsp;        // are not specified, the cliff-tops are removed.
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.CLIFF_TOP) </b>
<b class="nc">&nbsp;                &amp;&amp; hex.getTerrain(Terrains.CLIFF_TOP).hasExitsSpecified()) {</b>
<b class="nc">&nbsp;            origCliffTopExits = hex.getTerrain(Terrains.CLIFF_TOP).getExits();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            IHex other = getHexInDir(x, y, i);</b>
<b class="nc">&nbsp;            if (other == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;//            int levelDiff = hex.getLevel() - other.getLevel();
<b class="nc">&nbsp;            int levelDiff = hex.floor() - other.floor();</b>
<b class="nc">&nbsp;            int levelDiffToWaterSurface = hex.floor() - other.getLevel();</b>
<b class="nc">&nbsp;            boolean inWater = hex.containsTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;            boolean towardsWater = other.containsTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;            boolean manualCliffTopExitInThisDir = ((origCliffTopExits &amp; (1 &lt;&lt; i)) != 0);</b>
<b class="nc">&nbsp;            boolean cliffTopExitInThisDir = false;</b>
&nbsp;
<b class="nc">&nbsp;            if ( ((levelDiff == 1) || (levelDiff == 2))  </b>
&nbsp;                    &amp;&amp; manualCliffTopExitInThisDir ) {
<b class="nc">&nbsp;                correctedCliffTopExits += (1 &lt;&lt; i);</b>
<b class="nc">&nbsp;                cliffTopExitInThisDir = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Should there be an incline top?
<b class="nc">&nbsp;            if ( ((levelDiff == 1) || (levelDiff == 2))  </b>
&nbsp;                    &amp;&amp; !cliffTopExitInThisDir 
&nbsp;                    &amp;&amp; !inWater
&nbsp;                    &amp;&amp; !towardsWater) {
<b class="nc">&nbsp;                inclineTopExits += (1 &lt;&lt; i);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (towardsWater</b>
&nbsp;                    &amp;&amp; !inWater
&nbsp;                    &amp;&amp; !cliffTopExitInThisDir 
&nbsp;                    &amp;&amp; ((levelDiffToWaterSurface == 1) || levelDiffToWaterSurface == 2)) {
<b class="nc">&nbsp;                inclineTopExits += (1 &lt;&lt; i);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Should there be a high level cliff top?
<b class="nc">&nbsp;            if (levelDiff &gt; 2 </b>
&nbsp;                    &amp;&amp; !inWater
&nbsp;                    &amp;&amp; (!towardsWater || levelDiffToWaterSurface &gt; 2)) {
<b class="nc">&nbsp;                highInclineTopExits += (1 &lt;&lt; i);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Should there be an incline bottom or a cliff bottom?
&nbsp;            // This needs to check for a cliff-top in the other hex and
&nbsp;            // in the opposite direction
<b class="nc">&nbsp;            if ((levelDiff == -1) || (levelDiff == -2)) {</b>
<b class="nc">&nbsp;                if (other.hasCliffTopTowards(hex)) {</b>
<b class="nc">&nbsp;                    cliffBotExits += (1 &lt;&lt; i);</b>
<b class="nc">&nbsp;                } else if (!inWater) {</b>
<b class="nc">&nbsp;                    inclineBotExits += (1 &lt;&lt; i);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Should there be a high level cliff bottom?
<b class="nc">&nbsp;            if (levelDiff &lt; -2 &amp;&amp; !inWater) {</b>
<b class="nc">&nbsp;                highInclineBotExits += (1 &lt;&lt; i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        addOrRemoveAutoTerrain(hex, Terrains.CLIFF_TOP, correctedCliffTopExits);</b>
<b class="nc">&nbsp;        addOrRemoveAutoTerrain(hex, Terrains.CLIFF_BOTTOM, cliffBotExits);</b>
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getHexInclines()) {</b>
<b class="nc">&nbsp;            addOrRemoveAutoTerrain(hex, Terrains.INCLINE_TOP, inclineTopExits);</b>
<b class="nc">&nbsp;            addOrRemoveAutoTerrain(hex, Terrains.INCLINE_BOTTOM, inclineBotExits);</b>
<b class="nc">&nbsp;            addOrRemoveAutoTerrain(hex, Terrains.INCLINE_HIGH_TOP, highInclineTopExits);</b>
<b class="nc">&nbsp;            addOrRemoveAutoTerrain(hex, Terrains.INCLINE_HIGH_BOTTOM, highInclineBotExits);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            hex.removeTerrain(Terrains.INCLINE_TOP);</b>
<b class="nc">&nbsp;            hex.removeTerrain(Terrains.INCLINE_BOTTOM);</b>
<b class="nc">&nbsp;            hex.removeTerrain(Terrains.INCLINE_HIGH_TOP);</b>
<b class="nc">&nbsp;            hex.removeTerrain(Terrains.INCLINE_HIGH_BOTTOM);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** 
&nbsp;     * Adds automatically handled terrain such as inclines when the given
&nbsp;     * exits value is not 0, otherwise removes it.
&nbsp;     */
&nbsp;    private void addOrRemoveAutoTerrain(IHex hex, int terrainType, int exits) {
<b class="nc">&nbsp;        if (exits &gt; 0) {</b>
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory()</b>
<b class="nc">&nbsp;                    .createTerrain(terrainType, 1, true, exits));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            hex.removeTerrain(terrainType);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /** Rebuilds automatic terrains for the whole board. */
&nbsp;    public void initializeAllAutomaticTerrain() {
<b class="nc">&nbsp;        for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; width; x++) {</b>
<b class="nc">&nbsp;                initializeAutomaticTerrain(x, y);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        processBoardEvent(new BoardEvent(this, null, BoardEvent.BOARD_CHANGED_ALL_HEXES));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether this Board &quot;contains&quot; the specified Coords.
&nbsp;     *
&nbsp;     * @param x
&nbsp;     *            the x Coords.
&nbsp;     * @param y
&nbsp;     *            the y Coords.
&nbsp;     */
&nbsp;    public boolean contains(int x, int y) {
<b class="nc">&nbsp;        return (x &gt;= 0) &amp;&amp; (y &gt;= 0) &amp;&amp; (x &lt; width) &amp;&amp; (y &lt; height);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether this Board &quot;contains&quot; the specified Coords.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            the Coords.
&nbsp;     */
&nbsp;    public boolean contains(Coords c) {
<b class="nc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return contains(c.getX(), c.getY());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the Hex at the specified Coords.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            the Coords.
&nbsp;     */
&nbsp;    public IHex getHex(Coords c) {
<b class="nc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getHex(c.getX(), c.getY());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Board contains the (x, y) Coords, and if so, sets the
&nbsp;     * specified Hex into that position and initializes it.
&nbsp;     *
&nbsp;     * @param x
&nbsp;     *            the x Coords.
&nbsp;     * @param y
&nbsp;     *            the y Coords.
&nbsp;     * @param hex
&nbsp;     *            the hex to be set into position.
&nbsp;     */
&nbsp;    public void setHex(int x, int y, IHex hex) {
<b class="nc">&nbsp;        data[(y * width) + x] = hex;</b>
<b class="nc">&nbsp;        initializeHex(x, y);</b>
&nbsp;        // If this hex has exitable terrain, we may need to update the exits in
&nbsp;        // adjacent hexes
<b class="nc">&nbsp;        if (hex.hasExitableTerrain()) {</b>
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                if (hex.containsExit(dir)) {</b>
<b class="nc">&nbsp;                    initializeInDir(x, y, dir);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Similar to the setHex function for a collection of coordinates and hexes.
&nbsp;     * For each coord/hex pair in the supplied collections, this method
&nbsp;     * determines if the Board contains the coords and if so updates the
&nbsp;     * specified hex into that position and intializes it.
&nbsp;     * &lt;p/&gt;
&nbsp;     * The method ensures that each hex that needs to be updated is only updated
&nbsp;     * once.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            A list of coordinates to be updated
&nbsp;     * @param hexes
&nbsp;     *            The hex to be updated for each coordinate
&nbsp;     */
&nbsp;    public void setHexes(List&lt;Coords&gt; coords, List&lt;IHex&gt; hexes) {
&nbsp;        // Keeps track of hexes that will need to be reinitialized
<b class="nc">&nbsp;        LinkedHashSet&lt;Coords&gt; needsUpdate = new LinkedHashSet&lt;Coords&gt;((int) (coords.size() * 1.25 + 0.5));</b>
&nbsp;
&nbsp;        // Sanity check
<b class="nc">&nbsp;        if (coords.size() != hexes.size()) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;setHexes received two collections differeing size!&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update all input hexes, plus create a set of coords that need
&nbsp;        // updating
<b class="nc">&nbsp;        Iterator&lt;Coords&gt; coordIter = coords.iterator();</b>
<b class="nc">&nbsp;        Iterator&lt;IHex&gt; hexIter = hexes.iterator();</b>
<b class="nc">&nbsp;        while (coordIter.hasNext() &amp;&amp; hexIter.hasNext()) {</b>
<b class="nc">&nbsp;            Coords currCoord = coordIter.next();</b>
<b class="nc">&nbsp;            IHex currHex = hexIter.next();</b>
<b class="nc">&nbsp;            int x = currCoord.getX();</b>
<b class="nc">&nbsp;            int y = currCoord.getY();</b>
<b class="nc">&nbsp;            data[(y * width) + x] = currHex;</b>
<b class="nc">&nbsp;            initializeHex(x, y);</b>
&nbsp;
&nbsp;            // Add any adjacent hexes that may need to have exits updated
<b class="nc">&nbsp;            if (currHex.hasExitableTerrain()) {</b>
<b class="nc">&nbsp;                for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                    if (currHex.containsExit(dir)) {</b>
<b class="nc">&nbsp;                        needsUpdate.add(currCoord.translated(dir));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (Coords coord : needsUpdate) {</b>
<b class="nc">&nbsp;            initializeHex(coord.getX(), coord.getY());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the hex into the location specified by the Coords.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            the Coords.
&nbsp;     * @param hex
&nbsp;     *            the hex to be set into position.
&nbsp;     */
&nbsp;    public void setHex(Coords c, IHex hex) {
<b class="nc">&nbsp;        setHex(c.getX(), c.getY(), hex);</b>
<b class="nc">&nbsp;        if (hex.getLevel() &lt; minElevation &amp;&amp; minElevation != UNDEFINED_MIN_ELEV) {</b>
<b class="nc">&nbsp;            minElevation = hex.getLevel();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hex.getLevel() &gt; maxElevation &amp;&amp; maxElevation != UNDEFINED_MAX_ELEV) {</b>
<b class="nc">&nbsp;            maxElevation = hex.getLevel();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a board file is the specified size.
&nbsp;     *
&nbsp;     * @param filepath
&nbsp;     *            The path to the board file.
&nbsp;     * @param size
&nbsp;     *            The dimensions of the board to test.
&nbsp;     * @return {@code true} if the dimensions match.
&nbsp;     */
&nbsp;    public static boolean boardIsSize(final File filepath, final BoardDimensions size) {
<b class="nc">&nbsp;        int boardx = 0;</b>
<b class="nc">&nbsp;        int boardy = 0;</b>
<b class="nc">&nbsp;        try (Reader r = new BufferedReader(new FileReader(filepath))) {</b>
&nbsp;            // read board, looking for &quot;size&quot;
<b class="nc">&nbsp;            StreamTokenizer st = new StreamTokenizer(r);</b>
<b class="nc">&nbsp;            st.eolIsSignificant(true);</b>
<b class="nc">&nbsp;            st.commentChar(&#39;#&#39;);</b>
<b class="nc">&nbsp;            st.quoteChar(&#39;&quot;&#39;);</b>
<b class="nc">&nbsp;            st.wordChars(&#39;_&#39;, &#39;_&#39;);</b>
<b class="nc">&nbsp;            while (st.nextToken() != StreamTokenizer.TT_EOF) {</b>
<b class="nc">&nbsp;                if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;size&quot;)) {</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    boardx = (int) st.nval;</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    boardy = (int) st.nval;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check and return
<b class="nc">&nbsp;        return (boardx == size.width()) &amp;&amp; (boardy == size.height());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inspect specified board file and return its dimensions.
&nbsp;     *
&nbsp;     * @param filepath
&nbsp;     *            The path to the board file.
&nbsp;     * @return A {@link BoardDimensions} object containing the dimension.
&nbsp;     */
&nbsp;    public static BoardDimensions getSize(final File filepath) {
<b class="nc">&nbsp;        int boardx = 0;</b>
<b class="nc">&nbsp;        int boardy = 0;</b>
<b class="nc">&nbsp;        try (Reader r = new BufferedReader(new FileReader(filepath))) {</b>
&nbsp;            // read board, looking for &quot;size&quot;
<b class="nc">&nbsp;            StreamTokenizer st = new StreamTokenizer(r);</b>
<b class="nc">&nbsp;            st.eolIsSignificant(true);</b>
<b class="nc">&nbsp;            st.commentChar(&#39;#&#39;);</b>
<b class="nc">&nbsp;            st.quoteChar(&#39;&quot;&#39;);</b>
<b class="nc">&nbsp;            st.wordChars(&#39;_&#39;, &#39;_&#39;);</b>
<b class="nc">&nbsp;            while (st.nextToken() != StreamTokenizer.TT_EOF) {</b>
<b class="nc">&nbsp;                if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;size&quot;)) {</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    boardx = (int) st.nval;</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    boardy = (int) st.nval;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return new BoardDimensions(boardx, boardy);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can the player deploy an entity here? There are no canon rules for the
&nbsp;     * deployment phase (?!). I&#39;m using 3 hexes from map edge.
&nbsp;     */
&nbsp;    public boolean isLegalDeployment(Coords c, int nDir) {
<b class="nc">&nbsp;        if ((c == null) || !contains(c)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int nLimit = 3;</b>
&nbsp;        // int nDir = en.getStartingPos();
<b class="nc">&nbsp;        int minx = 0;</b>
<b class="nc">&nbsp;        int maxx = width;</b>
<b class="nc">&nbsp;        int miny = 0;</b>
<b class="nc">&nbsp;        int maxy = height;</b>
<b class="nc">&nbsp;        if (nDir &gt; 10) {</b>
&nbsp;            // Deep deployment, the board is effectively smaller
<b class="nc">&nbsp;            nDir -= 10;</b>
<b class="nc">&nbsp;            minx = width / 5;</b>
<b class="nc">&nbsp;            maxx -= width / 5;</b>
<b class="nc">&nbsp;            miny = height / 5;</b>
<b class="nc">&nbsp;            maxy -= height / 5;</b>
<b class="nc">&nbsp;            if ((c.getX() &lt; minx) || (c.getY() &lt; miny) || (c.getX() &gt;= maxx) || (c.getY() &gt;= maxy)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        switch (nDir) {</b>
&nbsp;        case START_ANY:
<b class="nc">&nbsp;            return true;</b>
&nbsp;        case START_NW:
<b class="nc">&nbsp;            return ((c.getX() &lt; (minx + nLimit)) &amp;&amp; (c.getX() &gt;= minx) &amp;&amp; (c.getY() &lt; (height / 2)))</b>
<b class="nc">&nbsp;                    || ((c.getY() &lt; (miny + nLimit)) &amp;&amp; (c.getY() &gt;= miny) &amp;&amp; (c.getX() &lt; (width / 2)));</b>
&nbsp;        case START_N:
<b class="nc">&nbsp;            return (c.getY() &lt; (miny + nLimit)) &amp;&amp; (c.getY() &gt;= miny);</b>
&nbsp;        case START_NE:
<b class="nc">&nbsp;            return ((c.getX() &gt; (maxx - nLimit)) &amp;&amp; (c.getX() &lt; maxx) &amp;&amp; (c.getY() &lt; (height / 2)))</b>
<b class="nc">&nbsp;                    || ((c.getY() &lt; (miny + nLimit)) &amp;&amp; (c.getY() &gt;= miny) &amp;&amp; (c.getX() &gt; (width / 2)));</b>
&nbsp;        case START_E:
<b class="nc">&nbsp;            return (c.getX() &gt;= (maxx - nLimit)) &amp;&amp; (c.getX() &lt; maxx);</b>
&nbsp;        case START_SE:
<b class="nc">&nbsp;            return ((c.getX() &gt;= (maxx - nLimit)) &amp;&amp; (c.getX() &lt; maxx) &amp;&amp; (c.getY() &gt; (height / 2)))</b>
<b class="nc">&nbsp;                    || ((c.getY() &gt;= (maxy - nLimit)) &amp;&amp; (c.getY() &lt; maxy) &amp;&amp; (c.getX() &gt; (width / 2)));</b>
&nbsp;        case START_S:
<b class="nc">&nbsp;            return (c.getY() &gt;= (maxy - nLimit)) &amp;&amp; (c.getY() &lt; maxy);</b>
&nbsp;        case START_SW:
<b class="nc">&nbsp;            return ((c.getX() &lt; (minx + nLimit)) &amp;&amp; (c.getX() &gt;= minx) &amp;&amp; (c.getY() &gt; (height / 2)))</b>
<b class="nc">&nbsp;                    || ((c.getY() &gt;= (maxy - nLimit)) &amp;&amp; (c.getY() &lt; maxy) &amp;&amp; (c.getX() &lt; (width / 2)));</b>
&nbsp;        case START_W:
<b class="nc">&nbsp;            return (c.getX() &lt; (minx + nLimit)) &amp;&amp; (c.getX() &gt;= minx);</b>
&nbsp;        case START_EDGE:
<b class="nc">&nbsp;            return ((c.getX() &lt; (minx + nLimit)) &amp;&amp; (c.getX() &gt;= minx))</b>
<b class="nc">&nbsp;                    || ((c.getY() &lt; (miny + nLimit)) &amp;&amp; (c.getY() &gt;= miny))</b>
<b class="nc">&nbsp;                    || ((c.getX() &gt;= (maxx - nLimit)) &amp;&amp; (c.getX() &lt; maxx))</b>
<b class="nc">&nbsp;                    || ((c.getY() &gt;= (maxy - nLimit)) &amp;&amp; (c.getY() &lt; maxy));</b>
&nbsp;        case START_CENTER:
<b class="nc">&nbsp;            return (c.getX() &gt;= (width / 3)) &amp;&amp; (c.getX() &lt;= ((2 * width) / 3)) &amp;&amp; (c.getY() &gt;= (height / 3))</b>
<b class="nc">&nbsp;                    &amp;&amp; (c.getY() &lt;= ((2 * height) / 3));</b>
&nbsp;        default: // ummm. .
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the opposite edge from the given edge
&nbsp;     * Returns START_NONE for non-cardinal edges (North, South, West, East)
&nbsp;     * @param cardinalEdge The edge to return the opposite off
&nbsp;     * @return Constant representing the opposite edge
&nbsp;     */
&nbsp;    public int getOppositeEdge(int cardinalEdge) {
<b class="nc">&nbsp;        switch(cardinalEdge) {</b>
&nbsp;        case Board.START_E:
<b class="nc">&nbsp;            return Board.START_W;</b>
&nbsp;        case Board.START_N:
<b class="nc">&nbsp;            return Board.START_S;</b>
&nbsp;        case Board.START_W:
<b class="nc">&nbsp;            return Board.START_E;</b>
&nbsp;        case Board.START_S:
<b class="nc">&nbsp;            return Board.START_N;</b>
&nbsp;        default:
<b class="nc">&nbsp;            return Board.START_NONE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    @Deprecated
&nbsp;    public void load(final String filename) {
<b class="nc">&nbsp;        load(new MegaMekFile(Configuration.boardsDir(), filename).getFile());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void load(final File filepath) {
<b class="nc">&nbsp;        try (InputStream is = new FileInputStream(filepath)) {</b>
<b class="nc">&nbsp;            load(is);</b>
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(this, &quot;IO Error opening file to load board! &quot; + ex);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads this board from an InputStream
&nbsp;     */
&nbsp;    public void load(InputStream is) {
<b class="nc">&nbsp;        load(is, null, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void load(InputStream is, StringBuffer errBuff, boolean continueLoadOnError) {
<b class="nc">&nbsp;        int nw = 0, nh = 0, di = 0;</b>
<b class="nc">&nbsp;        IHex[] nd = new IHex[0];</b>
<b class="nc">&nbsp;        int index = 0;</b>
<b class="nc">&nbsp;        resetStoredElevation();</b>
<b class="nc">&nbsp;        try (Reader r = new BufferedReader(new InputStreamReader(is))) {</b>
<b class="nc">&nbsp;            StreamTokenizer st = new StreamTokenizer(r);</b>
<b class="nc">&nbsp;            st.eolIsSignificant(true);</b>
<b class="nc">&nbsp;            st.commentChar(&#39;#&#39;);</b>
<b class="nc">&nbsp;            st.quoteChar(&#39;&quot;&#39;);</b>
<b class="nc">&nbsp;            st.wordChars(&#39;_&#39;, &#39;_&#39;);</b>
<b class="nc">&nbsp;            while (st.nextToken() != StreamTokenizer.TT_EOF) {</b>
<b class="nc">&nbsp;                if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;size&quot;)) {</b>
&nbsp;                    // read rest of line
<b class="nc">&nbsp;                    String[] args = { &quot;0&quot;, &quot;0&quot; };</b>
<b class="nc">&nbsp;                    int i = 0;</b>
<b class="nc">&nbsp;                    while ((st.nextToken() == StreamTokenizer.TT_WORD) || (st.ttype == &#39;&quot;&#39;)</b>
&nbsp;                            || (st.ttype == StreamTokenizer.TT_NUMBER)) {
<b class="nc">&nbsp;                        args[i++] = st.ttype == StreamTokenizer.TT_NUMBER ? (int) st.nval + &quot;&quot; : st.sval;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    nw = Integer.parseInt(args[0]);</b>
<b class="nc">&nbsp;                    nh = Integer.parseInt(args[1]);</b>
<b class="nc">&nbsp;                    nd = new IHex[nw * nh];</b>
<b class="nc">&nbsp;                    di = 0;</b>
<b class="nc">&nbsp;                } else if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;option&quot;)) {</b>
&nbsp;                    // read rest of line
<b class="nc">&nbsp;                    String[] args = { &quot;&quot;, &quot;&quot; };</b>
<b class="nc">&nbsp;                    int i = 0;</b>
<b class="nc">&nbsp;                    while ((st.nextToken() == StreamTokenizer.TT_WORD) || (st.ttype == &#39;&quot;&#39;)</b>
&nbsp;                            || (st.ttype == StreamTokenizer.TT_NUMBER)) {
<b class="nc">&nbsp;                        args[i++] = st.ttype == StreamTokenizer.TT_NUMBER ? (int) st.nval + &quot;&quot; : st.sval;</b>
&nbsp;                    }
&nbsp;                    // Only expect certain options.
<b class="nc">&nbsp;                    if (args[0].equalsIgnoreCase(&quot;exit_roads_to_pavement&quot;)) {</b>
<b class="nc">&nbsp;                        if (args[1].equalsIgnoreCase(&quot;false&quot;)) {</b>
<b class="nc">&nbsp;                            roadsAutoExit = false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            roadsAutoExit = true;</b>
&nbsp;                        }
&nbsp;                    } // End exit_roads_to_pavement-option
<b class="nc">&nbsp;                } else if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;hex&quot;)) {</b>
&nbsp;                    // read rest of line
<b class="nc">&nbsp;                    String[] args = { &quot;&quot;, &quot;0&quot;, &quot;&quot;, &quot;&quot; };</b>
<b class="nc">&nbsp;                    int i = 0;</b>
<b class="nc">&nbsp;                    while ((st.nextToken() == StreamTokenizer.TT_WORD) || (st.ttype == &#39;&quot;&#39;)</b>
&nbsp;                            || (st.ttype == StreamTokenizer.TT_NUMBER)) {
<b class="nc">&nbsp;                        args[i++] = st.ttype == StreamTokenizer.TT_NUMBER ? (int) st.nval + &quot;&quot; : st.sval;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    int elevation = Integer.parseInt(args[1]);</b>
&nbsp;                    // The coordinates in the .board file are ignored!
<b class="nc">&nbsp;                    nd[index] = new Hex(elevation, args[2], args[3], new Coords(index % nw, index / nw));</b>
<b class="nc">&nbsp;                    index++;</b>
<b class="nc">&nbsp;                } else if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;background&quot;)) {</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    File bgFile = new MegaMekFile(Configuration.boardBackgroundsDir(),</b>
<b class="nc">&nbsp;                            st.sval).getFile();</b>
<b class="nc">&nbsp;                    if (bgFile.exists()) {</b>
<b class="nc">&nbsp;                        backgroundPaths.add(bgFile.getPath());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        MegaMek.getLogger().error(this, </b>
<b class="nc">&nbsp;                                &quot;Board specified background image, but path couldn&#39;t be found! Path: &quot; + bgFile.getPath());</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;description&quot;)) {</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    if (st.ttype == &#39;&quot;&#39;) {</b>
<b class="nc">&nbsp;                        String d = getDescription();</b>
<b class="nc">&nbsp;                        if (null == d) {</b>
<b class="nc">&nbsp;                            setDescription(st.sval);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            setDescription(d + &quot;\n\n&quot; + st.sval);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;note&quot;)) {</b>
<b class="nc">&nbsp;                    st.nextToken();</b>
<b class="nc">&nbsp;                    if (st.ttype == StreamTokenizer.TT_NUMBER) {</b>
<b class="nc">&nbsp;                        int x, y, coordWidth = 100;</b>
<b class="nc">&nbsp;                        int coords = (int)st.nval;</b>
<b class="nc">&nbsp;                        if (coords &gt; 9999) {</b>
<b class="nc">&nbsp;                            coordWidth = 1000;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        y = coords % coordWidth;</b>
<b class="nc">&nbsp;                        coords /= coordWidth;</b>
<b class="nc">&nbsp;                        x = coords;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;                        if (st.ttype == &#39;&quot;&#39;) {</b>
<b class="nc">&nbsp;                            Collection&lt;String&gt; a = new ArrayList&lt;&gt;(getAnnotations(c));</b>
<b class="nc">&nbsp;                            a.add(st.sval);</b>
<b class="nc">&nbsp;                            setAnnotations(c, a);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if ((st.ttype == StreamTokenizer.TT_WORD) &amp;&amp; st.sval.equalsIgnoreCase(&quot;end&quot;)) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(this, &quot;I/O Error: &quot; + ex);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // fill nulls with blank hexes
<b class="nc">&nbsp;        for (int i = 0; i &lt; nd.length; i++) {</b>
<b class="nc">&nbsp;            if (nd[i] == null) {</b>
<b class="nc">&nbsp;                nd[i] = new Hex();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check data integrity
<b class="nc">&nbsp;        if (isValid(nd, nw, nh, errBuff) &amp;&amp; ((nw &gt; 1) || (nh &gt; 1) || (di == (nw * nh)))) {</b>
<b class="nc">&nbsp;            newData(nw, nh, nd, errBuff);</b>
<b class="nc">&nbsp;        } else if (continueLoadOnError &amp;&amp; ((nw &gt; 1) || (nh &gt; 1) || (di == (nw * nh)))) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(this, &quot;Invalid board data!&quot;);</b>
<b class="nc">&nbsp;            newData(nw, nh, nd, errBuff);</b>
<b class="nc">&nbsp;        } else if (errBuff == null){</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(this, &quot;Invalid board data!&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isValid() {
&nbsp;        // Search for black-listed hexes
<b class="nc">&nbsp;        return isValid(data, width, height, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isValid(StringBuffer errBuff) {
&nbsp;        // Search for black-listed hexes
<b class="nc">&nbsp;        return isValid(data, width, height, errBuff);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isValid(IHex[] data, int width, int height, StringBuffer errBuff) {
&nbsp;        // Search for black-listed hexes
<b class="nc">&nbsp;        for (int x = 0; x &lt; width; x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;                IHex hex = data[(y * width) + x];</b>
<b class="nc">&nbsp;                if (hex == null) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                StringBuffer currBuff = new StringBuffer();</b>
<b class="nc">&nbsp;                boolean valid = hex.isValid(currBuff);</b>
&nbsp;                
&nbsp;                // Multi-hex problems 
&nbsp;                // A building hex must only have exits to other building hexes of the same Building Type and Class
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.BUILDING) &amp;&amp; hex.getTerrain(Terrains.BUILDING).hasExitsSpecified()) {</b>
<b class="nc">&nbsp;                    for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                        IHex adjHex = getHexInDir(x, y, dir);</b>
<b class="nc">&nbsp;                        if ((adjHex != null) </b>
<b class="nc">&nbsp;                                &amp;&amp; adjHex.containsTerrain(Terrains.BUILDING) </b>
<b class="nc">&nbsp;                                &amp;&amp; hex.containsTerrainExit(Terrains.BUILDING, dir)) {</b>
<b class="nc">&nbsp;                            if (adjHex.getTerrain(Terrains.BUILDING).getLevel() != hex.getTerrain(Terrains.BUILDING).getLevel()) {</b>
<b class="nc">&nbsp;                                valid = false;</b>
<b class="nc">&nbsp;                                currBuff.append(&quot;Building has an exit to a building of another Building Type (Light, Medium...).\n&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (hex.containsTerrain(Terrains.BLDG_CLASS) </b>
<b class="nc">&nbsp;                                    &amp;&amp; ((adjHex.containsTerrain(Terrains.BLDG_CLASS) </b>
<b class="nc">&nbsp;                                            &amp;&amp; (adjHex.getTerrain(Terrains.BLDG_CLASS).getLevel() != hex.getTerrain(Terrains.BLDG_CLASS).getLevel()))</b>
<b class="nc">&nbsp;                                            || (!adjHex.containsTerrain(Terrains.BLDG_CLASS)))) {</b>
<b class="nc">&nbsp;                                valid = false;</b>
<b class="nc">&nbsp;                                currBuff.append(&quot;Building has an exit in direction &quot;).append(dir).append(&quot; to a building of another Building Class.\n&quot;);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                
&nbsp;                // Return early if we aren&#39;t logging errors
<b class="nc">&nbsp;                if (!valid &amp;&amp; (errBuff == null)) {</b>
<b class="nc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                } else if (!valid) { // Otherwise, log the error for later output</b>
<b class="nc">&nbsp;                    if (errBuff.length() &gt; 0) {</b>
<b class="nc">&nbsp;                        errBuff.append(&quot;----\n&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;                    errBuff.append(&quot;Hex &quot; + c.getBoardNum() + &quot; is invalid:\n&quot; + currBuff.toString());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes data for the board, as text to the OutputStream
&nbsp;     */
&nbsp;    public void save(OutputStream os) {
<b class="nc">&nbsp;        try (Writer w = new OutputStreamWriter(os)) {</b>
<b class="nc">&nbsp;            w.write(&quot;size &quot; + width + &quot; &quot; + height + &quot;\r\n&quot;);</b>
<b class="nc">&nbsp;            if (!roadsAutoExit) {</b>
<b class="nc">&nbsp;                w.write(&quot;option exit_roads_to_pavement false\r\n&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int i = 0; i &lt; data.length; i++) {</b>
<b class="nc">&nbsp;                IHex hex = data[i];</b>
<b class="nc">&nbsp;                boolean firstTerrain = true;</b>
&nbsp;
<b class="nc">&nbsp;                StringBuffer hexBuff = new StringBuffer(&quot;hex &quot;);</b>
&nbsp;                // The coordinates in the .board file are ignored when loading the board!
<b class="nc">&nbsp;                hexBuff.append(new Coords(i % width, i / width).getBoardNum());</b>
<b class="nc">&nbsp;                hexBuff.append(&quot; &quot;);</b>
<b class="nc">&nbsp;                hexBuff.append(hex.getLevel());</b>
<b class="nc">&nbsp;                hexBuff.append(&quot; \&quot;&quot;);</b>
<b class="nc">&nbsp;                int terrainTypes[] = hex.getTerrainTypes();</b>
<b class="nc">&nbsp;                for (int j = 0; j &lt; terrainTypes.length; j++) {</b>
<b class="nc">&nbsp;                    int terrType = terrainTypes[j];</b>
&nbsp;                    // do not save internally handled terrains
<b class="nc">&nbsp;                    if (Terrains.AUTOMATIC.contains(terrType)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    ITerrain terrain = hex.getTerrain(terrType);</b>
<b class="nc">&nbsp;                    if (terrain != null) {</b>
<b class="nc">&nbsp;                        if (!firstTerrain) {</b>
<b class="nc">&nbsp;                            hexBuff.append(&quot;;&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        hexBuff.append(terrain.toString());</b>
&nbsp;                        // Do something funky to save building exits.
<b class="nc">&nbsp;                        if (((Terrains.BUILDING == terrType) || (terrType == Terrains.FUEL_TANK))</b>
<b class="nc">&nbsp;                                &amp;&amp; !terrain.hasExitsSpecified() &amp;&amp; (terrain.getExits() != 0)) {</b>
<b class="nc">&nbsp;                            hexBuff.append(&quot;:&quot;).append(terrain.getExits());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        firstTerrain = false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                hexBuff.append(&quot;\&quot; \&quot;&quot;);</b>
<b class="nc">&nbsp;                if (hex.getTheme() != null) {</b>
<b class="nc">&nbsp;                    hexBuff.append(hex.getTheme());</b>
&nbsp;                }
<b class="nc">&nbsp;                hexBuff.append(&quot;\&quot;\r\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                w.write(hexBuff.toString());</b>
&nbsp;                // w.write(&quot;hex \&quot;&quot; + hex.getTerrain().name + &quot;\&quot; &quot; +
&nbsp;                // Terrain.TERRAIN_NAMES[hex.getTerrainType()] + &quot; \&quot;&quot; +
&nbsp;                // hex.getTerrain().picfile + &quot;\&quot; &quot; + hex.getElevation() +
&nbsp;                // &quot;\r\n&quot;);
&nbsp;            }
<b class="nc">&nbsp;            w.write(&quot;end\r\n&quot;);</b>
&nbsp;            // make sure it&#39;s written
<b class="nc">&nbsp;            w.flush();</b>
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(this, &quot;I/O Error: &quot; + ex);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Writes data for the board, as serialization, to the OutputStream
&nbsp;     */
&nbsp;    public void save2(OutputStream os) {
&nbsp;        try {
<b class="nc">&nbsp;            ObjectOutputStream oos = new ObjectOutputStream(os);</b>
<b class="nc">&nbsp;            oos.writeObject(this);</b>
<b class="nc">&nbsp;            oos.flush();</b>
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(this, &quot;I/O Error: &quot; + ex);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Record that the given coordinates have recieved a hit from an inferno.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; of the hit.
&nbsp;     * @param round
&nbsp;     *            - the kind of round that hit the hex.
&nbsp;     * @param hits
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; number of rounds that hit. If a
&nbsp;     *            negative number is passed, then an
&nbsp;     *            &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
&nbsp;     */
&nbsp;    public void addInfernoTo(Coords coords, InfernoTracker.Inferno round, int hits) {
&nbsp;        // Declare local variables.
<b class="nc">&nbsp;        InfernoTracker tracker = null;</b>
&nbsp;
&nbsp;        // Make sure the # of hits is valid.
<b class="nc">&nbsp;        if (hits &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Board can&#39;t track negative hits. &quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Do nothing if the coords aren&#39;t on this board.
<b class="nc">&nbsp;        if (!this.contains(coords)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Do we already have a tracker for those coords?
<b class="nc">&nbsp;        tracker = infernos.get(coords);</b>
<b class="nc">&nbsp;        if (null == tracker) {</b>
&nbsp;            // Nope. Make one.
<b class="nc">&nbsp;            tracker = new InfernoTracker();</b>
<b class="nc">&nbsp;            infernos.put(coords, tracker);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update the tracker.
<b class="nc">&nbsp;        tracker.add(round, hits);</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeInfernoFrom(Coords coords) {
&nbsp;        // Do nothing if the coords aren&#39;t on this board.
<b class="nc">&nbsp;        if (!this.contains(coords)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        infernos.remove(coords);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the given coordinates has a burning inferno.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being checked.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if those coordinates have a burning inferno
&nbsp;     *         round. &lt;code&gt;false&lt;/code&gt; if no inferno has hit those coordinates
&nbsp;     *         or if it has burned out.
&nbsp;     */
&nbsp;    public boolean isInfernoBurning(Coords coords) {
<b class="nc">&nbsp;        boolean result = false;</b>
<b class="nc">&nbsp;        InfernoTracker tracker = null;</b>
&nbsp;
&nbsp;        // Get the tracker for those coordinates
&nbsp;        // and see if the fire is still burning.
<b class="nc">&nbsp;        tracker = infernos.get(coords);</b>
<b class="nc">&nbsp;        if (null != tracker) {</b>
<b class="nc">&nbsp;            if (tracker.isStillBurning()) {</b>
<b class="nc">&nbsp;                result = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Record that a new round of burning has passed for the given coordinates.
&nbsp;     * This routine also determines if the fire is still burning.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being checked.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if those coordinates have a burning inferno
&nbsp;     *         round. &lt;code&gt;false&lt;/code&gt; if no inferno has hit those coordinates
&nbsp;     *         or if it has burned out.
&nbsp;     */
&nbsp;    public boolean burnInferno(Coords coords) {
<b class="nc">&nbsp;        boolean result = false;</b>
<b class="nc">&nbsp;        InfernoTracker tracker = null;</b>
&nbsp;
&nbsp;        // Get the tracker for those coordinates, record the round
&nbsp;        // of burning and see if the fire is still burning.
<b class="nc">&nbsp;        tracker = infernos.get(coords);</b>
<b class="nc">&nbsp;        if (null != tracker) {</b>
<b class="nc">&nbsp;            tracker.newRound(-1);</b>
<b class="nc">&nbsp;            if (tracker.isStillBurning()) {</b>
<b class="nc">&nbsp;                result = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                infernos.remove(coords);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get an enumeration of all coordinates with infernos still burning.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Coords&lt;/code&gt; that have
&nbsp;     *         infernos still burning.
&nbsp;     */
&nbsp;    public Enumeration&lt;Coords&gt; getInfernoBurningCoords() {
&nbsp;        // Only include *burning* inferno trackers.
<b class="nc">&nbsp;        Vector&lt;Coords&gt; burning = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        Enumeration&lt;Coords&gt; iter = infernos.keys();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Coords coords = iter.nextElement();</b>
<b class="nc">&nbsp;            if (isInfernoBurning(coords)) {</b>
<b class="nc">&nbsp;                burning.addElement(coords);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return burning.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the remaining number of turns the given coordinates will have a
&nbsp;     * burning inferno.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being checked. This value must not
&nbsp;     *            be &lt;code&gt;null&lt;/code&gt;. Unchecked.
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; number of burn turns left for all infernos
&nbsp;     *         This value will be non-negative.
&nbsp;     */
&nbsp;    public int getInfernoBurnTurns(Coords coords) {
<b class="nc">&nbsp;        int turns = 0;</b>
<b class="nc">&nbsp;        InfernoTracker tracker = null;</b>
&nbsp;
&nbsp;        // Get the tracker for those coordinates
&nbsp;        // and see if the fire is still burning.
<b class="nc">&nbsp;        tracker = infernos.get(coords);</b>
<b class="nc">&nbsp;        if (null != tracker) {</b>
<b class="nc">&nbsp;            turns = tracker.getTurnsLeftToBurn();</b>
&nbsp;        }
<b class="nc">&nbsp;        return turns;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the remaining number of turns the given coordinates will have a
&nbsp;     * burning Inferno IV round.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being checked. This value must not
&nbsp;     *            be &lt;code&gt;null&lt;/code&gt;. Unchecked.
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; number of burn turns left for Arrow IV
&nbsp;     *         infernos. This value will be non-negative.
&nbsp;     */
&nbsp;    public int getInfernoIVBurnTurns(Coords coords) {
<b class="nc">&nbsp;        int turns = 0;</b>
<b class="nc">&nbsp;        InfernoTracker tracker = null;</b>
&nbsp;
&nbsp;        // Get the tracker for those coordinates
&nbsp;        // and see if the fire is still burning.
<b class="nc">&nbsp;        tracker = infernos.get(coords);</b>
<b class="nc">&nbsp;        if (null != tracker) {</b>
<b class="nc">&nbsp;            turns = tracker.getArrowIVTurnsLeftToBurn();</b>
&nbsp;        }
<b class="nc">&nbsp;        return turns;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get an enumeration of all buildings on the board.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s.
&nbsp;     */
&nbsp;    public Enumeration&lt;Building&gt; getBuildings() {
<b class="nc">&nbsp;        return buildings.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the building at the given coordinates.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; being examined.
&nbsp;     * @return a &lt;code&gt;Building&lt;/code&gt; object, if there is one at the given
&nbsp;     *         coordinates, otherwise a &lt;code&gt;null&lt;/code&gt; will be returned.
&nbsp;     */
&nbsp;    public Building getBuildingAt(Coords coords) {
<b class="nc">&nbsp;        return bldgByCoords.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the local object for the given building. Call this routine any time
&nbsp;     * the input &lt;code&gt;Building&lt;/code&gt; is suspect.
&nbsp;     *
&nbsp;     * @param other
&nbsp;     *            - a &lt;code&gt;Building&lt;/code&gt; object which may or may not be
&nbsp;     *            represented on this board. This value may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     *            .
&nbsp;     * @return The local &lt;code&gt;Building&lt;/code&gt; object if we can find a match. If
&nbsp;     *         the other building is not on this board, a &lt;code&gt;null&lt;/code&gt; is
&nbsp;     *         returned instead.
&nbsp;     */
&nbsp;    private Building getLocalBuilding(Building other) {
&nbsp;
&nbsp;        // Handle garbage input.
<b class="nc">&nbsp;        if (other == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // ASSUMPTION: it is better to use the Hashtable than the Vector.
<b class="nc">&nbsp;        Building local = null;</b>
<b class="nc">&nbsp;        Enumeration&lt;Coords&gt; coords = other.getCoords();</b>
<b class="nc">&nbsp;        if (coords.hasMoreElements()) {</b>
<b class="nc">&nbsp;            local = bldgByCoords.get(coords.nextElement());</b>
<b class="nc">&nbsp;            if (!other.equals(local)) {</b>
<b class="nc">&nbsp;                local = null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // TODO: if local is still null, try the Vector.
<b class="nc">&nbsp;        return local;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Collapse a vector of building hexes.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Coord&lt;/code&gt; objects to be
&nbsp;     *            collapsed.
&nbsp;     */
&nbsp;    public void collapseBuilding(Vector&lt;Coords&gt; coords) {
&nbsp;
&nbsp;        // Walk through the vector of coords.
<b class="nc">&nbsp;        Enumeration&lt;Coords&gt; loop = coords.elements();</b>
<b class="nc">&nbsp;        while (loop.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Coords other = loop.nextElement();</b>
&nbsp;
&nbsp;            // Update the building.
<b class="nc">&nbsp;            this.collapseBuilding(other);</b>
&nbsp;
<b class="nc">&nbsp;        } // Handle the next building.</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The given building hex has collapsed. Remove it from the board and
&nbsp;     * replace it with rubble.
&nbsp;     *
&nbsp;     * @param coords
&nbsp;     *            - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.
&nbsp;     */
&nbsp;    public void collapseBuilding(Coords coords) {
<b class="nc">&nbsp;        final IHex curHex = this.getHex(coords);</b>
&nbsp;
&nbsp;        // Remove the building from the building map.
<b class="nc">&nbsp;        Building bldg = bldgByCoords.get(coords);</b>
<b class="nc">&nbsp;        if (bldg == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        bldg.removeHex(coords);</b>
<b class="nc">&nbsp;        bldgByCoords.remove(coords);</b>
&nbsp;
&nbsp;        // determine type of rubble
&nbsp;        // Terrain type can be a max of 4 for harded building
&nbsp;        // 5 for walls, but the only place where we actually check
&nbsp;        // for rubble type is resolveFindClub in Server, and we
&nbsp;        // make it impossible to find clubs in wallrubble there
<b class="nc">&nbsp;        int type = curHex.terrainLevel(Terrains.BUILDING);</b>
<b class="nc">&nbsp;        type = Math.max(type, curHex.terrainLevel(Terrains.BRIDGE));</b>
<b class="nc">&nbsp;        type = Math.max(type, curHex.terrainLevel(Terrains.FUEL_TANK));</b>
&nbsp;
&nbsp;        // Remove the building terrain.
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.BUILDING);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.BLDG_CF);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.FUEL_TANK);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.FUEL_TANK_CF);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.FUEL_TANK_ELEV);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.FUEL_TANK_MAGN);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.BRIDGE);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.BRIDGE_CF);</b>
<b class="nc">&nbsp;        curHex.removeTerrain(Terrains.BRIDGE_ELEV);</b>
&nbsp;
&nbsp;        // Add rubble terrain that matches the building type.
<b class="nc">&nbsp;        if (type &gt; 0) {</b>
<b class="nc">&nbsp;            int rubbleLevel = bldg.getBldgClass() == Building.FORTRESS ? 2 : 1;</b>
<b class="nc">&nbsp;            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.RUBBLE, rubbleLevel));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (curHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {</b>
&nbsp;            // per TW 176 the basement doesn&#39;t change the elevation of the
&nbsp;            // bulding hex
&nbsp;            // the basement fills in with the rubble of the building
&nbsp;            // any units in the basement are destroyed
<b class="nc">&nbsp;            curHex.removeTerrain(Terrains.BLDG_BASEMENT_TYPE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update the hex.
&nbsp;        // TODO : Do I need to initialize it???
&nbsp;        // ASSUMPTION: It&#39;s faster to update one at a time.
<b class="nc">&nbsp;        this.setHex(coords, curHex);</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The given building has collapsed. Remove it from the board and replace it
&nbsp;     * with rubble.
&nbsp;     *
&nbsp;     * @param bldg
&nbsp;     *            - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.
&nbsp;     */
&nbsp;    public void collapseBuilding(Building bldg) {
&nbsp;
&nbsp;        // Remove the building from our building vector.
<b class="nc">&nbsp;        buildings.removeElement(bldg);</b>
&nbsp;
&nbsp;        // Walk through the building&#39;s hexes.
<b class="nc">&nbsp;        Enumeration&lt;Coords&gt; bldgCoords = bldg.getCoords();</b>
<b class="nc">&nbsp;        while (bldgCoords.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Coords coords = bldgCoords.nextElement();</b>
<b class="nc">&nbsp;            collapseBuilding(coords);</b>
<b class="nc">&nbsp;        } // Handle the next building hex.</b>
&nbsp;
<b class="nc">&nbsp;    } // End public void collapseBuilding( Building )</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Update the construction factors on an array of buildings.
&nbsp;     *
&nbsp;     * @param bldgs
&nbsp;     *            - the &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt; objects to
&nbsp;     *            be updated.
&nbsp;     */
&nbsp;    public void updateBuildings(Vector&lt;Building&gt; bldgs) {
&nbsp;
&nbsp;        // Walk through the vector of buildings.
<b class="nc">&nbsp;        Enumeration&lt;Building&gt; loop = bldgs.elements();</b>
<b class="nc">&nbsp;        while (loop.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Building other = loop.nextElement();</b>
&nbsp;
&nbsp;            // Find the local object for the given building.
<b class="nc">&nbsp;            Building bldg = getLocalBuilding(other);</b>
&nbsp;
&nbsp;            // Handle garbage input.
<b class="nc">&nbsp;            if (bldg == null) {</b>
<b class="nc">&nbsp;                MegaMek.getLogger().error(this, &quot;Could not find a match for &quot; + other + &quot; to update.&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Enumeration&lt;Coords&gt; coordsEnum = bldg.getCoords();</b>
<b class="nc">&nbsp;            while (coordsEnum.hasMoreElements()) {</b>
&nbsp;                // Set the current and phase CFs of the building hexes.
<b class="nc">&nbsp;                final Coords coords = coordsEnum.nextElement();</b>
<b class="nc">&nbsp;                bldg.setCurrentCF(other.getCurrentCF(coords), coords);</b>
<b class="nc">&nbsp;                bldg.setPhaseCF(other.getPhaseCF(coords), coords);</b>
<b class="nc">&nbsp;                bldg.setArmor(other.getArmor(coords), coords);</b>
<b class="nc">&nbsp;                bldg.setBasement(coords,</b>
<b class="nc">&nbsp;                        BasementType.getType(getHex(coords).terrainLevel(Terrains.BLDG_BASEMENT_TYPE)));</b>
<b class="nc">&nbsp;                bldg.setBasementCollapsed(coords, other.getBasementCollapsed(coords));</b>
<b class="nc">&nbsp;                bldg.setDemolitionCharges(other.getDemolitionCharges());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } // Handle the next building.</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the current value of the &quot;road auto-exit&quot; option.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if roads should automatically exit onto all
&nbsp;     *         adjacent pavement hexes. &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public boolean getRoadsAutoExit() {
<b class="nc">&nbsp;        return roadsAutoExit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the value of the &quot;road auto-exit&quot; option.
&nbsp;     *
&nbsp;     * @param value
&nbsp;     *            - The value to set for the option; &lt;code&gt;true&lt;/code&gt; if roads
&nbsp;     *            should automatically exit onto all adjacent pavement hexes.
&nbsp;     *            &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public void setRoadsAutoExit(boolean value) {
<b class="nc">&nbsp;        roadsAutoExit = value;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Populate the &lt;code&gt;bldgByCoords&lt;/code&gt; member from the current
&nbsp;     * &lt;code&gt;Vector&lt;/code&gt; of buildings. Use this method after de- serializing a
&nbsp;     * &lt;code&gt;Board&lt;/code&gt; object.
&nbsp;     */
&nbsp;    private void createBldgByCoords() {
&nbsp;
&nbsp;        // Make a new hashtable.
<b class="nc">&nbsp;        bldgByCoords = new Hashtable&lt;Coords, Building&gt;();</b>
&nbsp;
&nbsp;        // Walk through the vector of buildings.
<b class="nc">&nbsp;        Enumeration&lt;Building&gt; loop = buildings.elements();</b>
<b class="nc">&nbsp;        while (loop.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Building bldg = loop.nextElement();</b>
&nbsp;
&nbsp;            // Each building identifies the hexes it covers.
<b class="nc">&nbsp;            Enumeration&lt;Coords&gt; iter = bldg.getCoords();</b>
<b class="nc">&nbsp;            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                bldgByCoords.put(iter.nextElement(), bldg);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Override the default deserialization to populate the transient
&nbsp;     * &lt;code&gt;bldgByCoords&lt;/code&gt; member.
&nbsp;     *
&nbsp;     * @param in
&nbsp;     *            - the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read.
&nbsp;     * @throws &lt;code&gt;IOException&lt;/code&gt;
&nbsp;     * @throws &lt;code&gt;ClassNotFoundException&lt;/code&gt;
&nbsp;     */
&nbsp;    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<b class="nc">&nbsp;        in.defaultReadObject();</b>
&nbsp;
&nbsp;        // Restore bldgByCoords from buildings.
<b class="nc">&nbsp;        createBldgByCoords();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#addBoardListener(megamek.common.BoardListener)
&nbsp;     */
&nbsp;    public void addBoardListener(BoardListener listener) {
<b class="nc">&nbsp;        if (boardListeners == null) {</b>
<b class="nc">&nbsp;            boardListeners = new Vector&lt;BoardListener&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        boardListeners.addElement(listener);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see
&nbsp;     * megamek.common.IBoard#removeBoardListener(megamek.common.BoardListener)
&nbsp;     */
&nbsp;    public void removeBoardListener(BoardListener listener) {
<b class="nc">&nbsp;        if (boardListeners != null) {</b>
<b class="nc">&nbsp;            boardListeners.removeElement(listener);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void processBoardEvent(BoardEvent event) {
<b class="nc">&nbsp;        if (boardListeners == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (BoardListener l : boardListeners) {</b>
<b class="nc">&nbsp;            switch (event.getType()) {</b>
&nbsp;            case BoardEvent.BOARD_CHANGED_HEX:
<b class="nc">&nbsp;                l.boardChangedHex(event);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case BoardEvent.BOARD_NEW_BOARD:
<b class="nc">&nbsp;                l.boardNewBoard(event);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case BoardEvent.BOARD_CHANGED_ALL_HEXES:
<b class="nc">&nbsp;                l.boardChangedAllHexes(event);</b>
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected Vector&lt;BoardListener&gt; getListeners() {
<b class="nc">&nbsp;        if (boardListeners == null) {</b>
<b class="nc">&nbsp;            boardListeners = new Vector&lt;BoardListener&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        return boardListeners;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Is there any way I can get around using this?
&nbsp;    public Hashtable&lt;Coords, InfernoTracker&gt; getInfernos() {
<b class="nc">&nbsp;        return infernos;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setBridgeCF(int value) {
<b class="nc">&nbsp;        for (Building bldg : buildings) {</b>
<b class="nc">&nbsp;            for (Enumeration&lt;Coords&gt; coords = bldg.getCoords(); coords.hasMoreElements();) {</b>
<b class="nc">&nbsp;                Coords c = coords.nextElement();</b>
<b class="nc">&nbsp;                IHex h = getHex(c);</b>
<b class="nc">&nbsp;                if (h.containsTerrain(Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                    bldg.setCurrentCF(value, c);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Kill all the unknown basements
&nbsp;    public void setRandomBasementsOff() {
<b class="nc">&nbsp;        Coords c = null;</b>
<b class="nc">&nbsp;        for (Building b : buildings) {</b>
<b class="nc">&nbsp;            for (Enumeration&lt;Coords&gt; coords = b.getCoords(); coords.hasMoreElements();) {</b>
<b class="nc">&nbsp;                c = coords.nextElement();</b>
<b class="nc">&nbsp;                if (b.getBasement(c) == BasementType.UNKNOWN) {</b>
<b class="nc">&nbsp;                    b.setBasement(c, BasementType.NONE);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#getSpecialHexDisplay(megamek.common.Coords)
&nbsp;     */
&nbsp;    public Collection&lt;SpecialHexDisplay&gt; getSpecialHexDisplay(Coords coords) {
<b class="nc">&nbsp;        return specialHexes.get(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#addSpecialHexDisplay(megamek.common.Coords,
&nbsp;     * megamek.common.SpecialHexDisplay)
&nbsp;     */
&nbsp;    public void addSpecialHexDisplay(Coords coords, SpecialHexDisplay shd) {
&nbsp;        Collection&lt;SpecialHexDisplay&gt; col;
<b class="nc">&nbsp;        if (!specialHexes.containsKey(coords)) {</b>
<b class="nc">&nbsp;            col = new LinkedList&lt;SpecialHexDisplay&gt;();</b>
<b class="nc">&nbsp;            specialHexes.put(coords, col);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            col = specialHexes.get(coords);</b>
&nbsp;            // It&#39;s possible we are updating a SHD that is already entered.
&nbsp;            // If that is the case, we want to remove the original entry.
<b class="nc">&nbsp;            if (col.contains(shd)) {</b>
<b class="nc">&nbsp;                col.remove(shd);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        col.add(shd);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeSpecialHexDisplay(Coords coords, SpecialHexDisplay shd) {
<b class="nc">&nbsp;        Collection&lt;SpecialHexDisplay&gt; col = specialHexes.get(coords);</b>
<b class="nc">&nbsp;        if (col != null) {</b>
<b class="nc">&nbsp;            col.remove(shd);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#getSpecialHexDisplayTable()
&nbsp;     */
&nbsp;    public Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt; getSpecialHexDisplayTable() {
<b class="nc">&nbsp;        return specialHexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     * 
&nbsp;     * @see megamek.common.IBoard#setSpecialHexDisplayTable(java.util.Hashtable)
&nbsp;     */
&nbsp;    public void setSpecialHexDisplayTable(Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt; shd) {
<b class="nc">&nbsp;        specialHexes = shd;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setType(int t) {
<b class="nc">&nbsp;        mapType = t;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getType() {
<b class="nc">&nbsp;        return mapType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String getTypeName(int t) {
<b class="nc">&nbsp;        return typeNames[t];</b>
&nbsp;    }
&nbsp;
&nbsp;    // some convenience functions
&nbsp;    public boolean onGround() {
<b class="nc">&nbsp;        return (mapType == T_GROUND);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean inAtmosphere() {
<b class="nc">&nbsp;        return (mapType == T_ATMOSPHERE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean inSpace() {
<b class="nc">&nbsp;        return (mapType == T_SPACE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMaxElevation() {
<b class="nc">&nbsp;        if (maxElevation != UNDEFINED_MAX_ELEV) {</b>
<b class="nc">&nbsp;            return maxElevation;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; width; x++) {</b>
<b class="nc">&nbsp;                int elevation = data[(y * width) + x].getLevel();</b>
<b class="nc">&nbsp;                if (maxElevation &lt; elevation) {</b>
<b class="nc">&nbsp;                    maxElevation = elevation;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return maxElevation;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMinElevation() {
<b class="nc">&nbsp;        if (minElevation != UNDEFINED_MIN_ELEV) {</b>
<b class="nc">&nbsp;            return minElevation;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; width; x++) {</b>
<b class="nc">&nbsp;                int elevation = data[(y * width) + x].getLevel();</b>
<b class="nc">&nbsp;                if (minElevation &gt; elevation) {</b>
<b class="nc">&nbsp;                    minElevation = elevation;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return minElevation;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void resetStoredElevation() {
<b class="nc">&nbsp;        minElevation = UNDEFINED_MIN_ELEV;</b>
<b class="nc">&nbsp;        maxElevation = UNDEFINED_MAX_ELEV;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean containsBridges() {
<b class="nc">&nbsp;        for (Coords c : bldgByCoords.keySet()) {</b>
<b class="nc">&nbsp;            IHex hex = getHex(c);</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;String&gt; getBackgroundPaths() {
<b class="nc">&nbsp;        return backgroundPaths;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getBackgroundPath() {
<b class="nc">&nbsp;        if (backgroundPaths.size() &gt; 0) {</b>
<b class="nc">&nbsp;            return backgroundPaths.get(0);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public int getNumBoardsWidth() {
<b class="nc">&nbsp;        return numBoardsWidth;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNumBoardsHeight() {
<b class="nc">&nbsp;        return numBoardsHeight;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Boolean&gt; getFlipBGHoriz() {
<b class="nc">&nbsp;        return flipBGHoriz;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Boolean&gt; getFlipBGVert() {
<b class="nc">&nbsp;        return flipBGVert;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getSubBoardWidth() {
<b class="nc">&nbsp;        return subBoardWidth;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getSubBoardHeight() {
<b class="nc">&nbsp;        return subBoardHeight;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSubBoardWidth(int width) {
<b class="nc">&nbsp;        subBoardWidth = width;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setSubBoardHeight(int height) {
<b class="nc">&nbsp;        subBoardHeight = height;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setNumBoardsWidth(int width) {
<b class="nc">&nbsp;        numBoardsWidth = width;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setNumBoardsHeight(int height) {
<b class="nc">&nbsp;        numBoardsHeight = height;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addBackgroundPath(String path, boolean flipVert, boolean flipHorz) {
<b class="nc">&nbsp;        backgroundPaths.add(path);</b>
&nbsp;
<b class="nc">&nbsp;        flipBGVert.add(flipVert);</b>
<b class="nc">&nbsp;        flipBGHoriz.add(flipHorz);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean hasBoardBackground() {
<b class="nc">&nbsp;        return (backgroundPaths != null) &amp;&amp; backgroundPaths.size() &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the description of the map.
&nbsp;     * @return The description of the map, if one exists, otherwise null.
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the description of the map.
&nbsp;     * @param s The description of the map; may be null.
&nbsp;     */
&nbsp;    public void setDescription(@Nullable String s) {
<b class="nc">&nbsp;        description = s;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets every annotations on the map.
&nbsp;     * @return A read-only map of per-hex annotations.
&nbsp;     */
&nbsp;    public Map&lt;Coords, Collection&lt;String&gt;&gt; getAnnotations() {
<b class="nc">&nbsp;        return Collections.unmodifiableMap(annotations);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the annotations associated with a hex.
&nbsp;     * @param x The X-Coordinate of the hex.
&nbsp;     * @param y The Y-Coordinate of the hex.
&nbsp;     * @return A collection of annotations for the hex.
&nbsp;     */
&nbsp;    public Collection&lt;String&gt; getAnnotations(int x, int y) {
<b class="nc">&nbsp;        return getAnnotations(new Coords(x, y));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the annotations associated with a hex.
&nbsp;     * @param c Coordinates of the hex.
&nbsp;     * @return A collection of annotations for the hex.
&nbsp;     */
&nbsp;    public Collection&lt;String&gt; getAnnotations(Coords c) {
<b class="nc">&nbsp;        return annotations.getOrDefault(c, Collections.emptyList());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets annotations on a given hex.
&nbsp;     * @param c Coordinates of the hex to apply the annotations to.
&nbsp;     * @param a A collection of annotations to assign to the hex. This may be null.
&nbsp;     */
&nbsp;    public void setAnnotations(Coords c, @Nullable Collection&lt;String&gt; a) {
<b class="nc">&nbsp;        if (null == a || a.isEmpty()) {</b>
<b class="nc">&nbsp;            annotations.remove(c);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            annotations.put(c, a);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** 
&nbsp;     * Sets a tileset theme for all hexes of the board. 
&nbsp;     * Passing null as newTheme resets the theme to the 
&nbsp;     * theme specified in the board file. 
&nbsp;     */ 
&nbsp;    public void setTheme(String newTheme) {
<b class="nc">&nbsp;        boolean reset = newTheme == null;</b>
&nbsp;        
<b class="nc">&nbsp;        for (int c = 0; c &lt; width * height; c++) {</b>
<b class="nc">&nbsp;            if (reset) {</b>
<b class="nc">&nbsp;                data[c].resetTheme();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                data[c].setTheme(newTheme);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        processBoardEvent(new BoardEvent(this, null, BoardEvent.BOARD_CHANGED_ALL_HEXES));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public boolean isOnBoardEdge(Coords c) {
<b class="nc">&nbsp;        return (c.getX() == 0) </b>
<b class="nc">&nbsp;                || (c.getY() == 0)</b>
<b class="nc">&nbsp;                || (c.getX() == (width - 1)) </b>
<b class="nc">&nbsp;                || (c.getY() == (height - 1));</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
