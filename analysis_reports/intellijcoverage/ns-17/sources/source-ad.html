


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TurnOrdered</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: TurnOrdered (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TurnOrdered</td>
<td class="coverageStat">
  <span class="percent">
    4.8%
  </span>
  <span class="absValue">
    (2/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.7%
  </span>
  <span class="absValue">
    (13/355)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TurnOrdered$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    4.5%
  </span>
  <span class="absValue">
    (2/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.6%
  </span>
  <span class="absValue">
    (13/357)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * MegaMek - Copyright (C) 2003, 2004 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;
<b class="fc">&nbsp;public abstract class TurnOrdered implements ITurnOrdered {</b>
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 4131468442031773195L;
&nbsp;
<b class="fc">&nbsp;    private InitiativeRoll initiative = new InitiativeRoll();</b>
<b class="fc">&nbsp;    private static ITurnOrdered lastRoundInitWinner = null;</b>
&nbsp;
<b class="fc">&nbsp;    private transient int turns_other = 0;</b>
<b class="fc">&nbsp;    private transient int turns_even = 0;</b>
<b class="fc">&nbsp;    private transient HashMap&lt;Integer, Integer&gt; turns_multi = new HashMap&lt;Integer, Integer&gt;();</b>
&nbsp;
&nbsp;    // these are special turns for all of the aero units (only used in the
&nbsp;    // movement phase)
<b class="fc">&nbsp;    private transient int turns_aero = 0;</b>
<b class="fc">&nbsp;    private transient int turns_ss = 0;</b>
<b class="fc">&nbsp;    private transient int turns_js = 0;</b>
<b class="fc">&nbsp;    private transient int turns_ws = 0;</b>
<b class="fc">&nbsp;    private transient int turns_ds = 0;</b>
<b class="fc">&nbsp;    private transient int turns_sc = 0;</b>
<b class="fc">&nbsp;    private transient int turns_tm = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Return the number of &quot;normal&quot; turns that this item requires. This is
&nbsp;     * normally the sum of multi-unit turns and the other turns.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Subclasses are expected to override this value in order to make the &quot;move
&nbsp;     * even&quot; code work correctly.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; number of &quot;normal&quot; turns this item should
&nbsp;     *         take in a phase.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getNormalTurns(IGame game) {
<b class="nc">&nbsp;        return getMultiTurns(game) + getOtherTurns();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getOtherTurns() {
<b class="nc">&nbsp;        return turns_other;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getEvenTurns() {
<b class="nc">&nbsp;        return turns_even;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getMultiTurns(IGame game) {
<b class="nc">&nbsp;        int turns = 0;</b>
&nbsp;        // turns_multi is transient, so it could be null
<b class="nc">&nbsp;        if (turns_multi == null) {</b>
<b class="nc">&nbsp;            turns_multi = new HashMap&lt;Integer, Integer&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT)) {</b>
<b class="nc">&nbsp;            double lanceSize = game.getOptions().intOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT_NUMBER);</b>
<b class="nc">&nbsp;            Integer numMekMultis = turns_multi.get(GameTurn.CLASS_MECH);</b>
<b class="nc">&nbsp;            if (numMekMultis != null) {</b>
<b class="nc">&nbsp;                turns += (int) Math.ceil(numMekMultis / lanceSize);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT)) {</b>
<b class="nc">&nbsp;            double lanceSize = game.getOptions().intOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT_NUMBER);</b>
<b class="nc">&nbsp;            Integer numTankMultis = turns_multi.get(GameTurn.CLASS_TANK);</b>
<b class="nc">&nbsp;            if (numTankMultis != null) {</b>
<b class="nc">&nbsp;                turns += (int) Math.ceil(numTankMultis / lanceSize);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_MULTI)) {</b>
<b class="nc">&nbsp;            double lanceSize = game.getOptions().intOption(OptionsConstants.INIT_INF_PROTO_MOVE_MULTI);</b>
<b class="nc">&nbsp;            Integer numProtoMultis = turns_multi.get(GameTurn.CLASS_PROTOMECH);</b>
<b class="nc">&nbsp;            if (numProtoMultis != null) {</b>
<b class="nc">&nbsp;                turns += (int) Math.ceil(numProtoMultis / lanceSize);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_MULTI)) {</b>
<b class="nc">&nbsp;            double lanceSize = game.getOptions().intOption(OptionsConstants.INIT_INF_PROTO_MOVE_MULTI);</b>
<b class="nc">&nbsp;            Integer numInfMultis = turns_multi.get(GameTurn.CLASS_INFANTRY);</b>
<b class="nc">&nbsp;            if (numInfMultis != null) {</b>
<b class="nc">&nbsp;                turns += (int) Math.ceil(numInfMultis / lanceSize);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return turns;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getSpaceStationTurns() {
<b class="nc">&nbsp;        return turns_ss;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getJumpshipTurns() {
<b class="nc">&nbsp;        return turns_js;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getWarshipTurns() {
<b class="nc">&nbsp;        return turns_ws;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getDropshipTurns() {
<b class="nc">&nbsp;        return turns_ds;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getSmallCraftTurns() {
<b class="nc">&nbsp;        return turns_sc;</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public int getTeleMissileTurns() {
<b class="nc">&nbsp;        return turns_tm;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getAeroTurns() {
<b class="nc">&nbsp;        return turns_aero;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementOtherTurns() {
<b class="nc">&nbsp;        turns_other++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementEvenTurns() {
<b class="nc">&nbsp;        turns_even++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementMultiTurns(int entityClass) {
&nbsp;        // turns_multi is transient, so it could be null
<b class="nc">&nbsp;        if (turns_multi == null) {</b>
<b class="nc">&nbsp;            turns_multi = new HashMap&lt;Integer, Integer&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        Integer classCount = turns_multi.get(entityClass);</b>
<b class="nc">&nbsp;        if (classCount == null) {</b>
<b class="nc">&nbsp;            turns_multi.put(entityClass, 1);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            turns_multi.put(entityClass, classCount + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementSpaceStationTurns() {
<b class="nc">&nbsp;        turns_ss++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementJumpshipTurns() {
<b class="nc">&nbsp;        turns_js++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementWarshipTurns() {
<b class="nc">&nbsp;        turns_ws++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementDropshipTurns() {
<b class="nc">&nbsp;        turns_ds++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementSmallCraftTurns() {
<b class="nc">&nbsp;        turns_sc++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    @Override
&nbsp;    public void incrementTeleMissileTurns() {
<b class="nc">&nbsp;        turns_tm++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void incrementAeroTurns() {
<b class="nc">&nbsp;        turns_aero++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetOtherTurns() {
<b class="nc">&nbsp;        turns_other = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetEvenTurns() {
<b class="nc">&nbsp;        turns_even = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetMultiTurns() {
&nbsp;        // turns_multi is transient, so it could be null
<b class="nc">&nbsp;        if (turns_multi == null) {</b>
<b class="nc">&nbsp;            turns_multi = new HashMap&lt;Integer, Integer&gt;();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            turns_multi.clear();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetSpaceStationTurns() {
<b class="nc">&nbsp;        turns_ss = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetJumpshipTurns() {
<b class="nc">&nbsp;        turns_js = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetWarshipTurns() {
<b class="nc">&nbsp;        turns_ws = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetDropshipTurns() {
<b class="nc">&nbsp;        turns_ds = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetSmallCraftTurns() {
<b class="nc">&nbsp;        turns_sc = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    @Override
&nbsp;    public void resetTeleMissileTurns() {
<b class="nc">&nbsp;        turns_tm = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetAeroTurns() {
<b class="nc">&nbsp;        turns_aero = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public InitiativeRoll getInitiative() {
<b class="nc">&nbsp;        return initiative;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setInitiative(InitiativeRoll newRoll) {
<b class="nc">&nbsp;        initiative = newRoll;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the initiative of this object.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void clearInitiative(boolean bUseInitComp) {
<b class="nc">&nbsp;        getInitiative().clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static void rollInitiative(List&lt;? extends ITurnOrdered&gt; v, boolean bUseInitiativeCompensation) {
&nbsp;        // Clear all rolls
<b class="nc">&nbsp;        for (ITurnOrdered item : v) {</b>
<b class="nc">&nbsp;            item.clearInitiative(bUseInitiativeCompensation);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        rollInitAndResolveTies(v, null, bUseInitiativeCompensation);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * This takes a vector of TurnOrdered (Teams or Players), and does post
&nbsp;     * initiative phase cleanup of the initiative streak bonus.
&nbsp;     * 
&nbsp;     * @param v
&nbsp;     *            A vector of items that need to have turns.
&nbsp;     * @param bInitCompBonus
&nbsp;     *            A flag that determines whether initiative compensation bonus
&nbsp;     *            should be used: used to prevent one side getting long init win
&nbsp;     *            streaks
&nbsp;     */
&nbsp;    public static void resetInitiativeCompensation(List&lt;? extends ITurnOrdered&gt; v,
&nbsp;            boolean bInitCompBonus) {
&nbsp;        // initiative compensation
<b class="nc">&nbsp;        if (bInitCompBonus &amp;&amp; (v.size() &gt; 0)) {</b>
<b class="nc">&nbsp;            final ITurnOrdered comparisonElement = v.get(0);</b>
<b class="nc">&nbsp;            int difference = 0;</b>
<b class="nc">&nbsp;            ITurnOrdered winningElement = comparisonElement;</b>
&nbsp;
&nbsp;            // figure out who won initiative this round
<b class="nc">&nbsp;            for (ITurnOrdered item : v) {</b>
&nbsp;                // Observers don&#39;t have initiative, and they don&#39;t get initiative compensation
<b class="nc">&nbsp;                if ((item instanceof IPlayer &amp;&amp; ((Player)item).isObserver()) || (item instanceof Team &amp;&amp; ((Team)item).isObserverTeam())) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (item.getInitiative().compareTo(comparisonElement.getInitiative()) &gt; difference) {</b>
<b class="nc">&nbsp;                    difference = item.getInitiative().compareTo(comparisonElement.getInitiative());</b>
<b class="nc">&nbsp;                    winningElement = item;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // set/reset the initiative compensation counters
<b class="nc">&nbsp;            if (lastRoundInitWinner != null) {</b>
<b class="nc">&nbsp;                for (ITurnOrdered item : v) {</b>
<b class="nc">&nbsp;                    if (!item.equals(winningElement)) {</b>
<b class="nc">&nbsp;                        int newBonus = 0;</b>
<b class="nc">&nbsp;                        boolean observer = false;</b>
&nbsp;                        // Observers don&#39;t have initiative, and they don&#39;t get initiative compensation
<b class="nc">&nbsp;                        if ((item instanceof IPlayer &amp;&amp; ((Player)item).isObserver()) || (item instanceof Team &amp;&amp; ((Team)item).isObserverTeam())) {</b>
<b class="nc">&nbsp;                            observer = true;</b>
&nbsp;                        }
&nbsp;                        
<b class="nc">&nbsp;                        if (!item.equals(lastRoundInitWinner) &amp;&amp; !observer) {</b>
<b class="nc">&nbsp;                            newBonus = item.getInitCompensationBonus() + 1;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        item.setInitCompensationBonus(newBonus);</b>
<b class="nc">&nbsp;                    }  else {</b>
&nbsp;                        // Reset our bonus to 0 if we won
<b class="nc">&nbsp;                        item.setInitCompensationBonus(0);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            lastRoundInitWinner = winningElement;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This takes a vector of TurnOrdered (Teams or Players), rolls initiative,
&nbsp;     * and resolves ties. The second argument is used when a specific teams
&nbsp;     * initiative should be re-rolled.
&nbsp;     * 
&nbsp;     * @param v
&nbsp;     *            A vector of items that need to have turns.
&nbsp;     * @param rerollRequests
&nbsp;     * @param bInitCompBonus
&nbsp;     *            A flag that determines whether initiative compensation bonus
&nbsp;     *            should be used: used to prevent one side getting long init win
&nbsp;     *            streaks
&nbsp;     */
&nbsp;    public static void rollInitAndResolveTies(List&lt;? extends ITurnOrdered&gt; v,
&nbsp;            List&lt;? extends ITurnOrdered&gt; rerollRequests, boolean bInitCompBonus) {
<b class="nc">&nbsp;        for (ITurnOrdered item : v) {</b>
&nbsp;            // Observers don&#39;t have initiative, set it to -1
<b class="nc">&nbsp;            if ((item instanceof IPlayer &amp;&amp; ((Player)item).isObserver()) || (item instanceof Team &amp;&amp; ((Team)item).isObserverTeam())) {</b>
<b class="nc">&nbsp;                item.getInitiative().observerRoll();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            int bonus = 0;</b>
<b class="nc">&nbsp;            if (item instanceof Team) {</b>
<b class="nc">&nbsp;                bonus = ((Team) item).getTotalInitBonus(bInitCompBonus);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (item instanceof Entity) {</b>
<b class="nc">&nbsp;                Entity e = (Entity) item;</b>
<b class="nc">&nbsp;                bonus = e.getGame().getTeamForPlayer(e.getOwner()).getTotalInitBonus(false) + e.getCrew().getInitBonus();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rerollRequests == null) { // normal init roll</b>
&nbsp;                // add a roll for all teams
<b class="nc">&nbsp;                item.getInitiative().addRoll(bonus);</b>
&nbsp;            } else {
&nbsp;                // Resolve Tactical Genius (lvl 3) pilot ability
<b class="nc">&nbsp;                for (ITurnOrdered rerollItem : rerollRequests) {</b>
<b class="nc">&nbsp;                    if (item == rerollItem) { // this is the team re-rolling</b>
<b class="nc">&nbsp;                        item.getInitiative().replaceRoll(bonus);</b>
<b class="nc">&nbsp;                        break; // each team only needs one reroll</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check for ties
<b class="nc">&nbsp;        Vector&lt;ITurnOrdered&gt; ties = new Vector&lt;ITurnOrdered&gt;();</b>
<b class="nc">&nbsp;        for (ITurnOrdered item : v) {</b>
&nbsp;            // Observers don&#39;t have initiative, and were already set to -1
<b class="nc">&nbsp;            if ((item instanceof IPlayer &amp;&amp; ((Player)item).isObserver()) || (item instanceof Team &amp;&amp; ((Team)item).isObserverTeam())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            ties.removeAllElements();</b>
<b class="nc">&nbsp;            ties.addElement(item);</b>
<b class="nc">&nbsp;            for (ITurnOrdered other : v) {</b>
<b class="nc">&nbsp;                if ((item != other) &amp;&amp; item.getInitiative().equals(other.getInitiative())) {</b>
<b class="nc">&nbsp;                    ties.addElement(other);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (ties.size() &gt; 1) {</b>
&nbsp;                // We want to ignore initiative compensation here, because it will
&nbsp;                // get dealt with once we&#39;re done resolving ties
<b class="nc">&nbsp;                rollInitAndResolveTies(ties, null, false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This takes a Vector of TurnOrdered and generates a TurnVector.
&nbsp;     */
&nbsp;    public static TurnVectors generateTurnOrder(List&lt;? extends ITurnOrdered&gt; v, IGame game) {
<b class="nc">&nbsp;        int[] num_even_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_normal_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_space_station_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_jumpship_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_warship_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_dropship_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_small_craft_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_telemissile_turns = new int[v.size()];</b>
<b class="nc">&nbsp;        int[] num_aero_turns = new int[v.size()];</b>
&nbsp;
<b class="nc">&nbsp;        int total_even_turns = 0;</b>
<b class="nc">&nbsp;        int total_normal_turns = 0;</b>
<b class="nc">&nbsp;        int total_space_station_turns = 0;</b>
<b class="nc">&nbsp;        int total_jumpship_turns = 0;</b>
<b class="nc">&nbsp;        int total_warship_turns = 0;</b>
<b class="nc">&nbsp;        int total_dropship_turns = 0;</b>
<b class="nc">&nbsp;        int total_small_craft_turns = 0;</b>
<b class="nc">&nbsp;        int total_telemissile_turns = 0;</b>
<b class="nc">&nbsp;        int total_aero_turns = 0;</b>
&nbsp;        int index;
<b class="nc">&nbsp;        ITurnOrdered[] order = new ITurnOrdered[v.size()];</b>
<b class="nc">&nbsp;        int orderedItems = 0;</b>
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;ITurnOrdered&gt; plist = new ArrayList&lt;ITurnOrdered&gt;(v.size());</b>
<b class="nc">&nbsp;        plist.addAll(v);</b>
&nbsp;
<b class="nc">&nbsp;        Collections.sort(plist, new Comparator&lt;ITurnOrdered&gt;() {</b>
&nbsp;            public int compare(ITurnOrdered o1, ITurnOrdered o2) {
<b class="nc">&nbsp;                return o1.getInitiative().compareTo(o2.getInitiative());</b>
&nbsp;            }
&nbsp;        });
&nbsp;
&nbsp;        // Walk through the ordered items.
<b class="nc">&nbsp;        for (Iterator&lt;ITurnOrdered&gt; i = plist.iterator(); i.hasNext(); orderedItems++) {</b>
<b class="nc">&nbsp;            final ITurnOrdered item = i.next();</b>
<b class="nc">&nbsp;            order[orderedItems] = item;</b>
&nbsp;
&nbsp;            // Track even turns separately from the normal turns.
<b class="nc">&nbsp;            num_normal_turns[orderedItems] = item.getNormalTurns(game);</b>
<b class="nc">&nbsp;            num_even_turns[orderedItems] = item.getEvenTurns();</b>
<b class="nc">&nbsp;            num_space_station_turns[orderedItems] = item.getSpaceStationTurns();</b>
<b class="nc">&nbsp;            num_jumpship_turns[orderedItems] = item.getJumpshipTurns();</b>
<b class="nc">&nbsp;            num_warship_turns[orderedItems] = item.getWarshipTurns();</b>
<b class="nc">&nbsp;            num_dropship_turns[orderedItems] = item.getDropshipTurns();</b>
<b class="nc">&nbsp;            num_small_craft_turns[orderedItems] = item.getSmallCraftTurns();</b>
<b class="nc">&nbsp;            num_telemissile_turns[orderedItems] = item.getTeleMissileTurns();</b>
<b class="nc">&nbsp;            num_aero_turns[orderedItems] = item.getAeroTurns();</b>
&nbsp;
&nbsp;            // Keep a running total.
<b class="nc">&nbsp;            total_even_turns += num_even_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_normal_turns += num_normal_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_space_station_turns += num_space_station_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_jumpship_turns += num_jumpship_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_warship_turns += num_warship_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_dropship_turns += num_dropship_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_small_craft_turns += num_small_craft_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_telemissile_turns += num_telemissile_turns[orderedItems];</b>
<b class="nc">&nbsp;            total_aero_turns += num_aero_turns[orderedItems];</b>
&nbsp;        }
&nbsp;
&nbsp;        int min;
&nbsp;        int turns_left;
&nbsp;        int ntm;
&nbsp;        int minSS;
&nbsp;        int minJS;
&nbsp;        int minWS;
&nbsp;        int minDS;
&nbsp;        int minSC;
&nbsp;        int minTM;
&nbsp;        int minAero;
&nbsp;
&nbsp;        // ok first we have to add in the special Aero turns and then go to
&nbsp;        // &#39;normal&#39; turns which are really just ground turns
&nbsp;
&nbsp;        // We will do the &#39;normal&#39; turns first, and then the &#39;even&#39; turns.
<b class="nc">&nbsp;        min = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minSS = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minJS = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minWS = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minDS = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minSC = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minTM = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        minAero = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        for (index = 0; index &lt; orderedItems; index++) {</b>
<b class="nc">&nbsp;            if ((num_normal_turns[index] != 0) &amp;&amp; (num_normal_turns[index] &lt; min)) {</b>
<b class="nc">&nbsp;                min = num_normal_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_space_station_turns[index] != 0) &amp;&amp; (num_space_station_turns[index] &lt; minSS)) {</b>
<b class="nc">&nbsp;                minSS = num_space_station_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_jumpship_turns[index] != 0) &amp;&amp; (num_jumpship_turns[index] &lt; minJS)) {</b>
<b class="nc">&nbsp;                minJS = num_jumpship_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_warship_turns[index] != 0) &amp;&amp; (num_warship_turns[index] &lt; minWS)) {</b>
<b class="nc">&nbsp;                minWS = num_warship_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_dropship_turns[index] != 0) &amp;&amp; (num_dropship_turns[index] &lt; minDS)) {</b>
<b class="nc">&nbsp;                minDS = num_dropship_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_small_craft_turns[index] != 0) &amp;&amp; (num_small_craft_turns[index] &lt; minSC)) {</b>
<b class="nc">&nbsp;                minSC = num_small_craft_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_telemissile_turns[index] != 0) &amp;&amp; (num_telemissile_turns[index] &lt; minTM)) {</b>
<b class="nc">&nbsp;                minTM = num_telemissile_turns[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((num_aero_turns[index] != 0) &amp;&amp; (num_aero_turns[index] &lt; minAero)) {</b>
<b class="nc">&nbsp;                minAero = num_aero_turns[index];</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int total_turns = total_normal_turns + total_space_station_turns + total_jumpship_turns + total_warship_turns</b>
&nbsp;                + total_dropship_turns + total_small_craft_turns + total_telemissile_turns + total_aero_turns;
&nbsp;
<b class="nc">&nbsp;        TurnVectors turns = new TurnVectors(total_normal_turns, total_turns, total_space_station_turns,</b>
&nbsp;                total_jumpship_turns, total_warship_turns, total_dropship_turns, total_small_craft_turns,
&nbsp;                total_telemissile_turns, total_aero_turns, total_even_turns, min);
&nbsp;
&nbsp;        // Allocate the normal turns.
<b class="nc">&nbsp;        turns_left = total_normal_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_normal_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_normal_turns[index]) / (double) min);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_normal_turns[index] / min;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addNormal(order[index]);</b>
<b class="nc">&nbsp;                    num_normal_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            min--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;regular&#39; turn.
&nbsp;
&nbsp;        // Now, we allocate the &#39;even&#39; turns, if there are any.
<b class="nc">&nbsp;        if (total_even_turns &gt; 0) {</b>
&nbsp;
<b class="nc">&nbsp;            min = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
<b class="nc">&nbsp;                if ((num_even_turns[index] != 0) &amp;&amp; (num_even_turns[index] &lt; min)) {</b>
<b class="nc">&nbsp;                    min = num_even_turns[index];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            turns_left = total_even_turns;</b>
<b class="nc">&nbsp;            while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;                for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                    // If you have no turns here, skip
<b class="nc">&nbsp;                    if (num_even_turns[index] == 0) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // If you have less than twice the lowest,
&nbsp;                    // move 1. Otherwise, move more.
<b class="nc">&nbsp;                    if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                        ntm = (int) Math.ceil(((double) num_even_turns[index]) / (double) min);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        ntm = num_even_turns[index] / min;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                        turns.addEven(order[index]);</b>
<b class="nc">&nbsp;                        num_even_turns[index]--;</b>
<b class="nc">&nbsp;                        turns_left--;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;                min--;</b>
&nbsp;            } // Handle the next &#39;even&#39; turn
&nbsp;        } // End have-&#39;even&#39;-turns
&nbsp;
&nbsp;        // Allocate the space station turns.
<b class="nc">&nbsp;        turns_left = total_space_station_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_space_station_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_space_station_turns[index]) / (double) minSS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_space_station_turns[index] / minSS;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addSpaceStation(order[index]);</b>
<b class="nc">&nbsp;                    num_space_station_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minSS--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;space station&#39; turn.
&nbsp;
&nbsp;        // Allocate the jumpship turns.
<b class="nc">&nbsp;        turns_left = total_jumpship_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_jumpship_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_jumpship_turns[index]) / (double) minJS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_jumpship_turns[index] / minJS;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addJumpship(order[index]);</b>
<b class="nc">&nbsp;                    num_jumpship_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minJS--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;jumpship&#39; turn.
&nbsp;
&nbsp;        // Allocate the warship turns.
<b class="nc">&nbsp;        turns_left = total_warship_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_warship_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_warship_turns[index]) / (double) minWS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_warship_turns[index] / minWS;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addWarship(order[index]);</b>
<b class="nc">&nbsp;                    num_warship_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minWS--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;warship&#39; turn.
&nbsp;
&nbsp;        // Allocate the dropship turns.
<b class="nc">&nbsp;        turns_left = total_dropship_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_dropship_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_dropship_turns[index]) / (double) minDS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_dropship_turns[index] / minDS;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addDropship(order[index]);</b>
<b class="nc">&nbsp;                    num_dropship_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minDS--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;dropship&#39; turn.
&nbsp;
&nbsp;        // Allocate the small craft turns.
<b class="nc">&nbsp;        turns_left = total_small_craft_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_small_craft_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_small_craft_turns[index]) / (double) minSC);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_small_craft_turns[index] / minSC;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addSmallCraft(order[index]);</b>
<b class="nc">&nbsp;                    num_small_craft_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minSC--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;small craft&#39; turn.
&nbsp;        
&nbsp;        // Allocate the telemissile turns.
<b class="nc">&nbsp;        turns_left = total_telemissile_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_telemissile_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.INIT_FRONT_LOAD_INITIATIVE)) {</b>
<b class="nc">&nbsp;                    ntm = (int) Math.ceil(((double) num_telemissile_turns[index]) / (double) minTM);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ntm = num_telemissile_turns[index] / minTM;</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addTelemissile(order[index]);</b>
<b class="nc">&nbsp;                    num_telemissile_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minTM--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;telemissile&#39; turn.
&nbsp;
&nbsp;        // Allocate the aero turns.
<b class="nc">&nbsp;        turns_left = total_aero_turns;</b>
<b class="nc">&nbsp;        while (turns_left &gt; 0) {</b>
<b class="nc">&nbsp;            for (index = 0; index &lt; orderedItems; index++) {</b>
&nbsp;                // If you have no turns here, skip
<b class="nc">&nbsp;                if (num_aero_turns[index] == 0) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // If you have less than twice the lowest,
&nbsp;                // move 1. Otherwise, move more.
<b class="nc">&nbsp;                ntm = num_aero_turns[index] / minAero;</b>
<b class="nc">&nbsp;                for (int j = 0; j &lt; ntm; j++) {</b>
<b class="nc">&nbsp;                    turns.addAero(order[index]);</b>
<b class="nc">&nbsp;                    num_aero_turns[index]--;</b>
<b class="nc">&nbsp;                    turns_left--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            // Since the smallest unit count had to place 1, reduce min)
<b class="nc">&nbsp;            minAero--;</b>
&nbsp;
&nbsp;        } // Handle the next &#39;aero&#39; turn.
<b class="nc">&nbsp;        return turns;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getInitCompensationBonus() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setInitCompensationBonus(int newBonus) {
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
