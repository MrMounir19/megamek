


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MoveStep</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: MoveStep (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MoveStep</td>
<td class="coverageStat">
  <span class="percent">
    0.7%
  </span>
  <span class="absValue">
    (1/148)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.5%
  </span>
  <span class="absValue">
    (45/1823)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MoveStep$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$0ckkXad6</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$2ijQFkAV</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$3M6iO58u</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$3Rz30JJo</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$4c3VSQIY</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$5rpiCeSg</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$5up0riyo</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$6crM9dOL</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$6f4LlSIf</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$7fd8W8Au</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$7O53C94x</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$7WNSmgjn</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$806bmZZZ</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$8DlPMJcb</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$8JAPqyYF</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$8RC9lRsV</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$8YgpzFCC</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$9wTHi21V</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$a9XXP4sI</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$AFCvgRTG</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$AGCykIR9</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$AgwddWsk</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$aJDv9yrz</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Ao5i5MtC</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$bA4PWZ3J</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$BdiPW2Ew</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Bq1rYg6w</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$BTG7O8ni</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Btyk98JN</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$chl0SE5a</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$cHRHFcBW</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$dk1whYTa</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$DOfArbFS</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$dQ1MKDmA</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$DR4TbMHp</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$eAaLnhut</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$eBAzaSKi</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$ECuA4evC</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$ej4aedRq</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$EkEengZ4</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$EKfoedXl</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$EPG3g4U6</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$FbTqQgdo</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$FlCtL02e</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Fufq1PmO</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$fyJ67HRw</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$gaLXXx9H</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$GJsNZLuA</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$GSyEMVCA</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$gtwv6Dyb</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$hajeeUCX</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$hD1ibv7M</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$hfBk4EoF</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Hs315plL</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$HvWpdHkK</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$HYewjhoN</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$IBPsiio2</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$IBxERxr4</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$iEgkm4Zc</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$iHLmvtsv</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$iJNctRZN</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Ikz5bY7r</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$INQJ3b9q</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$iqjc6ZGa</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$IzREVzEn</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$jBak6S4B</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$JquM4LOr</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$jRkfsGzV</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$JVbOEG9K</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$jYH6qpQz</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$KCcscEVY</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$KLLK6Mfp</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$kSevI3RP</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$LmzDpJje</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Mbe8EpQM</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$nas4lqy5</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$nFGxEPVV</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$nokKUQpI</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$O3cyyibR</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Oc5XHzL0</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$ocUNzWJf</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$oDPw6IgE</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$OeZBWDkX</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$oPuvIuxJ</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Pcrx1KYo</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$PCV2AD5v</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$PFv2UQ6F</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$PJp1bsGV</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$PvHvGE0K</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$pxcE4Crk</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$QFBCJaIM</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$qfiqhRJC</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$qjMBIb2x</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$rk9iq2d6</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Rqfge8qh</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$rvA7F6sM</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$s2i10hrd</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$s7wFaDuT</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$SBHxpttl</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$SBRcpX8m</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$shgQRrKo</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$SOIxe6vO</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$SpPgcRiS</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$SPwPYufs</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$t7hTjje1</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$T94rj8Az</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$TeXjDVPO</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$thUFZHI8</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$TPdrW1xf</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$tpK2uV5K</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$tQLRqrfn</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$U8wAGesN</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$ubsma4O1</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$UGXw3cUl</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$UJAZ024I</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$ul66TKim</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$UT9KbB3p</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$UyHYZbqT</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$VqZFFtnE</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$wCyQQaOr</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$wh5gM56r</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$wSWuouuF</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$x92rnNUD</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$XKcwjsM4</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$XmAKrpFu</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$Xt5wvitZ</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$XzpDSUrJ</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$YbXHmx2E</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$YeqxvjpT</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$yhg25rut</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$z1kxwa2u</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$zhqH9KRu</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$ZpcXq70A</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$zREUVNXg</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$zVF42Yfv</td>
  </tr>
  <tr>
    <td class="name">MoveStep$MockitoMock$874366784$auxiliary$zXtqFKEv</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0.7%
  </span>
  <span class="absValue">
    (1/149)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.5%
  </span>
  <span class="absValue">
    (45/1824)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; * This program is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU General Public License as published by the Free
&nbsp; * Software Foundation; either version 2 of the License, or (at your option)
&nbsp; * any later version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
&nbsp; * more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU General Public License along with
&nbsp; * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
&nbsp; * Place, Suite 330, Boston, MA 02111-1307 USA
&nbsp; */
&nbsp;
&nbsp;/*
&nbsp; * Created on Aug 28, 2003
&nbsp; */
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.logging.DefaultMmLogger;
&nbsp;import megamek.common.logging.MMLogger;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.CachedEntityState;
&nbsp;
&nbsp;/**
&nbsp; * A single step in the entity&#39;s movement.  Since the path planner uses shallow
&nbsp; * copies of MovePaths, multiple paths may share the same MoveStep, so this
&nbsp; * class needs to be agnostic of what path it belongs to.
&nbsp; */
&nbsp;public class MoveStep implements Serializable {
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = -6075640793056182285L;
<b class="fc">&nbsp;    private MoveStepType type = MoveStepType.NONE;</b>
<b class="fc">&nbsp;    private int targetId = Entity.NONE;</b>
<b class="fc">&nbsp;    private int targetType = Targetable.TYPE_ENTITY;</b>
&nbsp;    private Coords targetPos;
&nbsp;
&nbsp;    private Coords position;
&nbsp;    private int facing;
&nbsp;
&nbsp;    private int mp; // this step
&nbsp;    private int mpUsed; // whole path
&nbsp;
&nbsp;    private int heat; // this step
&nbsp;    private int totalHeat;
&nbsp;
&nbsp;    private int distance;
&nbsp;    private int leapDistance;
&nbsp;
<b class="fc">&nbsp;    private int elevation = -999;</b>
<b class="fc">&nbsp;    private int altitude = -999;</b>
&nbsp;
<b class="fc">&nbsp;    private int mineToLay = -1;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This step&#39;s static movement type. Additional steps in the path will not
&nbsp;     * change this value.
&nbsp;     */
&nbsp;    private EntityMovementType movementType;
&nbsp;    /**
&nbsp;     * The movement mode after this step completes. Mode conversions will modify it, though
&nbsp;     * it may not take effect until the end of movement.
&nbsp;     */
<b class="fc">&nbsp;    private EntityMovementMode movementMode = EntityMovementMode.NONE;</b>
&nbsp;
&nbsp;    private boolean isProne;
&nbsp;    private boolean isFlying;
&nbsp;    private boolean isHullDown;
&nbsp;    private boolean climbMode;
&nbsp;
&nbsp;    private boolean danger; // keep psr
&nbsp;    private boolean pastDanger;
&nbsp;    private boolean docking;
&nbsp;    private boolean isUsingMASC;
&nbsp;    private int targetNumberMASC; // psr
&nbsp;    //
&nbsp;    private boolean firstStep; // check if no previous
&nbsp;    private boolean isTurning; // method
&nbsp;    private boolean isUnloaded;
&nbsp;    private boolean hasEverUnloaded;
&nbsp;    private boolean prevStepOnPavement; // prev
&nbsp;    private boolean hasJustStood;
&nbsp;    private boolean thisStepBackwards;
&nbsp;    private boolean onlyPavement; // additive
&nbsp;    private boolean isPavementStep;
<b class="fc">&nbsp;    private boolean isRunProhibited = false;</b>
<b class="fc">&nbsp;    private boolean isStackingViolation = false;</b>
<b class="fc">&nbsp;    private boolean isDiggingIn = false;</b>
<b class="fc">&nbsp;    private boolean isTakingCover = false;</b>
<b class="fc">&nbsp;    private int wigeBonus = 0;</b>
<b class="fc">&nbsp;    private int nWigeDescent = 0;</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * The Entity that is taking this MoveStep.
&nbsp;     */
<b class="fc">&nbsp;    private Entity entity = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this MoveStep is part of a MovePath that is jumping.
&nbsp;     */
<b class="fc">&nbsp;    private boolean isJumpingPath = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this MoveStep is part of a MovePath that is moving
&nbsp;     * carefully.
&nbsp;     */
<b class="fc">&nbsp;    private boolean isCarefulPath = true;</b>
&nbsp;    
&nbsp;    /*
&nbsp;     * Aero related stuf
&nbsp;     */
<b class="fc">&nbsp;    private int velocity = -999;</b>
<b class="fc">&nbsp;    private int velocityN = -999;</b>
&nbsp;
&nbsp;    // also keep track of velocity left to spend
<b class="fc">&nbsp;    private int velocityLeft = 0;</b>
&nbsp;    // how many turns?
<b class="fc">&nbsp;    private int nTurns = 0;</b>
<b class="fc">&nbsp;    private int nRolls = 0;</b>
&nbsp;    // does the unit have a free turn available
<b class="fc">&nbsp;    private boolean freeTurn = false;</b>
&nbsp;    // how many hexes straight has the unit traveled
<b class="fc">&nbsp;    private int nStraight = 0;</b>
&nbsp;    // how many altitude down
<b class="fc">&nbsp;    private int nDown = 0;</b>
&nbsp;    // how many hexes moved in this velocity &quot;chunk&quot; (for aero on ground maps)
<b class="fc">&nbsp;    private int nMoved = 0;</b>
&nbsp;    // for Aeros, they may get pushed off board by OOC
<b class="fc">&nbsp;    private boolean offBoard = false;</b>
&nbsp;    // for optional vector movement
&nbsp;    private int[] mv;
<b class="fc">&nbsp;    private int recoveryUnit = -1;</b>
&nbsp;    TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; launched;
<b class="fc">&nbsp;    private boolean isEvading = false;</b>
<b class="fc">&nbsp;    private boolean isShuttingDown = false;</b>
<b class="fc">&nbsp;    private boolean isStartingUp = false;</b>
<b class="fc">&nbsp;    private boolean isSelfDestructing = false;</b>
<b class="fc">&nbsp;    private boolean isRolled = false;</b>
&nbsp;
&nbsp;    // for maneuvers
<b class="fc">&nbsp;    private int maneuverType = ManeuverType.MAN_NONE;</b>
&nbsp;    // steps associated with maneuvers have no cost
<b class="fc">&nbsp;    private boolean noCost = false;</b>
&nbsp;    // is this step part of a maneuver?
<b class="fc">&nbsp;    private boolean maneuver = false;</b>
&nbsp;
&nbsp;    private Minefield mf;
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that indicates that this step is into prohibited terrain.
&nbsp;     * &lt;p/&gt;
&nbsp;     * If the unit is jumping, this step is only invalid if it is the end of the
&nbsp;     * path.
&nbsp;     */
<b class="fc">&nbsp;    private boolean terrainInvalid = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A collection of buildings that are crushed during this move step. This is
&nbsp;     * used for landed Aerodyne Dropships and Mobile Structures.
&nbsp;     */
&nbsp;    private ArrayList&lt;Coords&gt; crushedBuildingLocs;
&nbsp;
&nbsp;    /**
&nbsp;     * Global logging instance.
&nbsp;     */
&nbsp;    private MMLogger logger;
&nbsp;
&nbsp;    /**
&nbsp;     * Create a step of the given type.
&nbsp;     *
&nbsp;     * @param type - should match one of the MovePath constants, but this is not
&nbsp;     *             currently checked.
&nbsp;     */
<b class="fc">&nbsp;    public MoveStep(MovePath path, MoveStepType type) {</b>
<b class="fc">&nbsp;        this.type = type;</b>
<b class="fc">&nbsp;        if (path != null) {</b>
<b class="fc">&nbsp;            entity = path.getEntity();</b>
<b class="fc">&nbsp;            isJumpingPath = path.isJumping();</b>
<b class="fc">&nbsp;            isCarefulPath = path.isCareful();</b>
&nbsp;        }
<b class="fc">&nbsp;        if ((type == MoveStepType.UNLOAD) || (type == MoveStepType.LAUNCH)</b>
&nbsp;                || (type == MoveStepType.DROP) || (type == MoveStepType.UNDOCK)
&nbsp;                || (type == MoveStepType.DISCONNECT)) {
<b class="nc">&nbsp;            hasEverUnloaded = true;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            hasEverUnloaded = false;</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Create a step with the given target and a position for that target
&nbsp;     *
&nbsp;     * @param type   - should match one of the MovePath constants, but this is not
&nbsp;     *               currently checked.
&nbsp;     * @param target - the &lt;code&gt;Targetable&lt;/code&gt; that is the target of this step.
&nbsp;     *               For example, the enemy being charged.
&nbsp;     * @param pos    = the &lt;code&gt;Coords&lt;/code&gt; for the target position.
&nbsp;     */
&nbsp;    public MoveStep(MovePath path, MoveStepType type, Targetable target,
&nbsp;                    Coords pos) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        targetId = target.getTargetId();</b>
<b class="nc">&nbsp;        targetType = target.getTargetType();</b>
<b class="nc">&nbsp;        targetPos = pos;</b>
<b class="nc">&nbsp;        if ((type == MoveStepType.UNLOAD) || (type == MoveStepType.LAUNCH)</b>
&nbsp;                || (type == MoveStepType.DROP) || (type == MoveStepType.UNDOCK)
&nbsp;                || (type == MoveStepType.DISCONNECT)) {
<b class="nc">&nbsp;            hasEverUnloaded = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            hasEverUnloaded = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Create a step with the given target.
&nbsp;     *
&nbsp;     * @param type   - should match one of the MovePath constants, but this is not
&nbsp;     *               currently checked.
&nbsp;     * @param target - the &lt;code&gt;Targetable&lt;/code&gt; that is the target of this step.
&nbsp;     *               For example, the enemy being charged.
&nbsp;     */
&nbsp;    public MoveStep(MovePath path, MoveStepType type, Targetable target) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        targetId = target.getTargetId();</b>
<b class="nc">&nbsp;        targetType = target.getTargetType();</b>
<b class="nc">&nbsp;        if ((type == MoveStepType.UNLOAD) || (type == MoveStepType.LAUNCH)</b>
&nbsp;                || (type == MoveStepType.DROP) || (type == MoveStepType.UNDOCK)
&nbsp;                || (type == MoveStepType.DISCONNECT)) {
<b class="nc">&nbsp;            hasEverUnloaded = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            hasEverUnloaded = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Create a step with the given mine to lay.
&nbsp;     *
&nbsp;     * @param path
&nbsp;     * @param type      - should match one of the MovePath constants, but this is not
&nbsp;     *                  currently checked.
&nbsp;     * @param mineToLay - the &lt;code&gt;int&lt;/code&gt; that is the id of the mine that should
&nbsp;     *                  be laid in this step.
&nbsp;     */
&nbsp;    public MoveStep(MovePath path, MoveStepType type, int mineToLay) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        this.mineToLay = mineToLay;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Create a step with the units to launch or drop.
&nbsp;     *
&nbsp;     * @param path
&nbsp;     * @param type    - should match one of the MovePath constants, but this is not
&nbsp;     *                currently checked.
&nbsp;     * @param targets - vector of integers identifying the entities to launch
&nbsp;     */
&nbsp;    public MoveStep(MovePath path, MoveStepType type,
&nbsp;                    TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; targets) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        launched = targets;</b>
<b class="nc">&nbsp;        if ((type == MoveStepType.UNLOAD) || (type == MoveStepType.LAUNCH)</b>
&nbsp;                || (type == MoveStepType.DROP) || (type == MoveStepType.UNDOCK)
&nbsp;                || (type == MoveStepType.DISCONNECT)) {
<b class="nc">&nbsp;            hasEverUnloaded = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            hasEverUnloaded = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MoveStep(MovePath path, MoveStepType type, int recovery,
&nbsp;                    int mineToLay) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        recoveryUnit = recovery;</b>
<b class="nc">&nbsp;        this.mineToLay = mineToLay;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MoveStep(MovePath path, MoveStepType type, boolean noCost) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        this.noCost = noCost;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MoveStep(MovePath path, MoveStepType type, boolean noCost,
&nbsp;                    boolean isManeuver) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        this.noCost = noCost;</b>
<b class="nc">&nbsp;        maneuver = isManeuver;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MoveStep(MovePath path, MoveStepType type, int recovery,
&nbsp;                    int mineToLay, int manType) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        recoveryUnit = recovery;</b>
<b class="nc">&nbsp;        this.mineToLay = mineToLay;</b>
<b class="nc">&nbsp;        maneuverType = manType;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MoveStep(MovePath path, MoveStepType type, Minefield mf) {
<b class="nc">&nbsp;        this(path, type);</b>
<b class="nc">&nbsp;        this.mf = mf;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the logging instance for this class.
&nbsp;     * 
&nbsp;     * @return The logger for this class.
&nbsp;     */
&nbsp;    private MMLogger getLogger() {
<b class="nc">&nbsp;        return null == logger ? logger = DefaultMmLogger.getInstance() : logger;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BACKWARDS:
<b class="nc">&nbsp;                return &quot;B&quot;;</b>
&nbsp;            case CHARGE:
<b class="nc">&nbsp;                return &quot;Ch&quot;;</b>
&nbsp;            case DFA:
<b class="nc">&nbsp;                return &quot;DFA&quot;;</b>
&nbsp;            case FORWARDS:
<b class="nc">&nbsp;                return &quot;F&quot;;</b>
&nbsp;            case CAREFUL_STAND:
&nbsp;            case GET_UP:
<b class="nc">&nbsp;                return &quot;Up&quot;;</b>
&nbsp;            case GO_PRONE:
<b class="nc">&nbsp;                return &quot;Prone&quot;;</b>
&nbsp;            case START_JUMP:
<b class="nc">&nbsp;                return &quot;StrJump&quot;;</b>
&nbsp;            case TURN_LEFT:
<b class="nc">&nbsp;                return &quot;L&quot;;</b>
&nbsp;            case TURN_RIGHT:
<b class="nc">&nbsp;                return &quot;R&quot;;</b>
&nbsp;            case LATERAL_LEFT:
<b class="nc">&nbsp;                return &quot;ShL&quot;;</b>
&nbsp;            case LATERAL_RIGHT:
<b class="nc">&nbsp;                return &quot;ShR&quot;;</b>
&nbsp;            case LATERAL_LEFT_BACKWARDS:
<b class="nc">&nbsp;                return &quot;ShLB&quot;;</b>
&nbsp;            case LATERAL_RIGHT_BACKWARDS:
<b class="nc">&nbsp;                return &quot;ShRB&quot;;</b>
&nbsp;            case UNJAM_RAC:
<b class="nc">&nbsp;                return &quot;Unjam&quot;;</b>
&nbsp;            case SEARCHLIGHT:
<b class="nc">&nbsp;                return &quot;SLight&quot;;</b>
&nbsp;            case LOAD:
<b class="nc">&nbsp;                return &quot;Load&quot;;</b>
&nbsp;            case UNLOAD:
<b class="nc">&nbsp;                return &quot;Unload&quot;;</b>
&nbsp;            case EJECT:
<b class="nc">&nbsp;                return &quot;Eject&quot;;</b>
&nbsp;            case UP:
<b class="nc">&nbsp;                return &quot;U&quot;;</b>
&nbsp;            case DOWN:
<b class="nc">&nbsp;                return &quot;D&quot;;</b>
&nbsp;            case HULL_DOWN:
<b class="nc">&nbsp;                return &quot;HullDown&quot;;</b>
&nbsp;            case CLIMB_MODE_ON:
<b class="nc">&nbsp;                return &quot;CM+&quot;;</b>
&nbsp;            case CLIMB_MODE_OFF:
<b class="nc">&nbsp;                return &quot;CM-&quot;;</b>
&nbsp;            case TAKEOFF:
<b class="nc">&nbsp;                return &quot;Takeoff&quot;;</b>
&nbsp;            case VTAKEOFF:
<b class="nc">&nbsp;                return &quot;Vertical Takeoff&quot;;</b>
&nbsp;            case LAND:
<b class="nc">&nbsp;                return &quot;Landing&quot;;</b>
&nbsp;            case VLAND:
<b class="nc">&nbsp;                return &quot;Vertical Landing&quot;;</b>
&nbsp;            case ACC:
<b class="nc">&nbsp;                return &quot;Acc&quot;;</b>
&nbsp;            case DEC:
<b class="nc">&nbsp;                return &quot;Dec&quot;;</b>
&nbsp;            case MANEUVER:
<b class="nc">&nbsp;                return &quot;Maneuver&quot;;</b>
&nbsp;            case RETURN:
<b class="nc">&nbsp;                return &quot;Fly Off (Return)&quot;;</b>
&nbsp;            case OFF:
<b class="nc">&nbsp;                return &quot;Fly Off&quot;;</b>
&nbsp;            case FLEE:
<b class="nc">&nbsp;                return &quot;Flee&quot;;</b>
&nbsp;            case EVADE:
<b class="nc">&nbsp;                return &quot;Evade&quot;;</b>
&nbsp;            case CONVERT_MODE:
<b class="nc">&nbsp;                return &quot;ConvMode&quot;;</b>
&nbsp;            case TOW:
<b class="nc">&nbsp;                return &quot;Tow&quot;;</b>
&nbsp;            case DISCONNECT:
<b class="nc">&nbsp;                return &quot;Disconnect&quot;;</b>
&nbsp;            case THRUST:
<b class="nc">&nbsp;                return &quot;Thrust&quot;;</b>
&nbsp;            case YAW:
<b class="nc">&nbsp;                return &quot;Yaw&quot;;</b>
&nbsp;            case HOVER:
<b class="nc">&nbsp;                return &quot;Hover&quot;;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return &quot;???&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public MoveStepType getType() {
<b class="nc">&nbsp;        return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the target of the current step.
&nbsp;     *
&nbsp;     * @param target - the &lt;code&gt;Targetable&lt;/code&gt; that is the target of this step.
&nbsp;     *               For example, the enemy being charged. If there is no target,
&nbsp;     *               pass a &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public void setTarget(Targetable target) {
<b class="nc">&nbsp;        if (target == null) {</b>
<b class="nc">&nbsp;            targetId = Entity.NONE;</b>
<b class="nc">&nbsp;            targetType = Targetable.TYPE_ENTITY;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            targetId = target.getTargetId();</b>
<b class="nc">&nbsp;            targetType = target.getTargetType();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Turns VTOL bombing on or off for this step.
&nbsp;     */
&nbsp;    public void setVTOLBombing(boolean bombing) {
<b class="nc">&nbsp;        if (bombing) {</b>
<b class="nc">&nbsp;            setTarget(new HexTarget(getPosition(), Targetable.TYPE_HEX_AERO_BOMB));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setTarget(null);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Turns VTOL strafing on or off for this step.
&nbsp;     */
&nbsp;    public void setStrafing(boolean strafing) {
<b class="nc">&nbsp;        if (strafing) {</b>
<b class="nc">&nbsp;            setTarget(new HexTarget(getPosition(), Targetable.TYPE_HEX_CLEAR));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setTarget(null);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the target of the current step.
&nbsp;     *
&nbsp;     * @param game - The &lt;code&gt;Game&lt;/code&gt; object.
&nbsp;     * @return The &lt;code&gt;Targetable&lt;/code&gt; that is the target of this step. For
&nbsp;     *         example, the enemy being charged. This value may be
&nbsp;     *         &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public Targetable getTarget(IGame game) {
<b class="nc">&nbsp;        if (targetId == Entity.NONE) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return game.getTarget(targetType, targetId);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Coords getTargetPosition() {
<b class="nc">&nbsp;        return targetPos;</b>
&nbsp;    }
&nbsp;
&nbsp;    public TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; getLaunched() {
<b class="nc">&nbsp;        if(launched == null) {</b>
<b class="nc">&nbsp;            launched = new TreeMap&lt;&gt;();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return launched;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper for compile(), to deal with steps that move to a new hex.
&nbsp;     *
&nbsp;     * @param game
&nbsp;     * @param entity
&nbsp;     * @param prev
&nbsp;     */
&nbsp;    private void compileMove(final IGame game, final Entity entity,
&nbsp;                             MoveStep prev, CachedEntityState cachedEntityState) {
&nbsp;
<b class="nc">&nbsp;        IHex destHex = game.getBoard().getHex(getPosition());</b>
&nbsp;
&nbsp;        // Check for pavement movement.
<b class="nc">&nbsp;        if (!entity.isAirborne() &amp;&amp; Compute.canMoveOnPavement(game, prev.getPosition(), getPosition(), this)) {</b>
<b class="nc">&nbsp;            setPavementStep(true);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setPavementStep(false);</b>
<b class="nc">&nbsp;            setOnlyPavement(false);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        setHasJustStood(false);</b>
<b class="nc">&nbsp;        if (prev.isThisStepBackwards() != isThisStepBackwards()) {</b>
<b class="nc">&nbsp;            setDistance(0); // start over after shifting gears</b>
&nbsp;        }
<b class="nc">&nbsp;        addDistance(1);</b>
&nbsp;
&nbsp;        // need to reduce velocity left for aerospace units (and also reset
&nbsp;        // nTurns)
&nbsp;        // this is handled differently by aerospace units operating on the
&nbsp;        // ground map and by spheroids in atmosphere
<b class="nc">&nbsp;        if (entity.isAirborne() &amp;&amp; game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            setNMoved(getNMoved() + 1);</b>
<b class="nc">&nbsp;            if ((entity.getMovementMode() != EntityMovementMode.SPHEROID)</b>
<b class="nc">&nbsp;                    &amp;&amp; (getNMoved() &gt;= 16)) {</b>
<b class="nc">&nbsp;                setVelocityLeft(getVelocityLeft() - 1);</b>
<b class="nc">&nbsp;                setNMoved(0);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (entity.isAirborne() &amp;&amp; !game.useVectorMove()</b>
<b class="nc">&nbsp;                &amp;&amp; !useSpheroidAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;            setVelocityLeft(getVelocityLeft() - 1);</b>
<b class="nc">&nbsp;            setNTurns(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Track number of moves straight for aero free moves in atmosphere, vehicle turn modes, and bootlegger maneuver
<b class="nc">&nbsp;        setNStraight(getNStraight() + 1);</b>
&nbsp;        // if in atmosphere, then I need to know if this move qualifies the unit
&nbsp;        // for a free turn
<b class="nc">&nbsp;        if (useAeroAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;            if (game.getBoard().onGround() &amp;&amp; (getNStraight() &gt; 7)) {</b>
&nbsp;                // if flying on ground map, then you have to fly at least 8
&nbsp;                // straight hexes between turns (free or not)
&nbsp;                // http://www.classicbattletech.com/forums/index.php/topic,37171.new.html#new
<b class="nc">&nbsp;                setNTurns(0);</b>
&nbsp;            }
&nbsp;                        
<b class="nc">&nbsp;            if (!hasFreeTurn()) {</b>
&nbsp;                // check conditions
<b class="nc">&nbsp;                if (dueFreeTurn()) {</b>
<b class="nc">&nbsp;                    setFreeTurn(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getType() == MoveStepType.DFA) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;            setElevation(Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV)));</b>
&nbsp;            // If we&#39;re DFA-ing, we want to be 1 above the level of the target.
&nbsp;            // However, if that puts us in the ground, we&#39;re instead 1 above the
&nbsp;            // level of the hex right before the target.
<b class="nc">&nbsp;            int otherEl = 0;</b>
<b class="nc">&nbsp;            IHex hex2 = game.getBoard().getHex(prev.getPosition());</b>
<b class="nc">&nbsp;            otherEl = Math.max(0, hex2.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;            if (otherEl &gt; getElevation()) {</b>
<b class="nc">&nbsp;                setElevation(otherEl);</b>
&nbsp;            }
<b class="nc">&nbsp;            setElevation(getElevation() + 1);</b>
<b class="nc">&nbsp;        } else if (isJumping()) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;            int maxElevation = (entity.getJumpMP() + entity.getElevation() + game</b>
<b class="nc">&nbsp;                    .getBoard().getHex(entity.getPosition()).surface())</b>
<b class="nc">&nbsp;                    - hex.surface();</b>
<b class="nc">&nbsp;            int building = hex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;            int depth = -hex.depth(true);</b>
&nbsp;            // need to adjust depth for potential ice over water
<b class="nc">&nbsp;            if ((hex.containsTerrain(Terrains.ICE) &amp;&amp; hex</b>
<b class="nc">&nbsp;                    .containsTerrain(Terrains.WATER))</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.HOVER)) {</b>
<b class="nc">&nbsp;                depth = 0;</b>
&nbsp;            }
&nbsp;            // grounded dropships are treated as level 10 buildings for purposes
&nbsp;            // of jumping over
<b class="nc">&nbsp;            boolean grdDropship = false;</b>
<b class="nc">&nbsp;            if (building &lt; 10) {</b>
<b class="nc">&nbsp;                for (Entity inHex : game.getEntitiesVector(getPosition())) {</b>
<b class="nc">&nbsp;                    if (inHex.equals(entity)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if ((inHex instanceof Dropship) &amp;&amp; !inHex.isAirborne()</b>
<b class="nc">&nbsp;                            &amp;&amp; !inHex.isSpaceborne()) {</b>
<b class="nc">&nbsp;                        building = 10;</b>
<b class="nc">&nbsp;                        grdDropship = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((entity instanceof Infantry) &amp;&amp; !grdDropship) {</b>
&nbsp;                // infantry can jump into a building
<b class="nc">&nbsp;                setElevation(Math.max(depth, Math.min(building, maxElevation)));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                setElevation(Math.max(depth, building));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (climbMode()</b>
<b class="nc">&nbsp;                    &amp;&amp; (maxElevation &gt;= hex.terrainLevel(Terrains.BRIDGE_ELEV))) {</b>
<b class="nc">&nbsp;                setElevation(Math.max(getElevation(),</b>
<b class="nc">&nbsp;                        hex.terrainLevel(Terrains.BRIDGE_ELEV)));</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            Building bld = game.getBoard().getBuildingAt(getPosition());</b>
&nbsp;
<b class="nc">&nbsp;            if (bld != null) {</b>
<b class="nc">&nbsp;                IHex hex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;                int maxElevation = (entity.getElevation() + game.getBoard()</b>
<b class="nc">&nbsp;                        .getHex(entity.getPosition()).surface())</b>
<b class="nc">&nbsp;                        - hex.surface();</b>
&nbsp;
&nbsp;                // Meks can climb up level 2 walls or less while everything
&nbsp;                // can only climb up one level
<b class="nc">&nbsp;                if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;                    maxElevation += 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    maxElevation++;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (bld.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                    if (maxElevation &gt;= hex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                        setElevation(Math.max(getElevation(),</b>
<b class="nc">&nbsp;                                hex.terrainLevel(Terrains.BLDG_ELEV)));</b>
&nbsp;                    } else {// if the wall is taller then the unit then they
&nbsp;                        // cannot climb it or enter it
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // System.err.println(&quot; Entity &quot;+ entity.getDisplayName()
&nbsp;                    // +&quot; moving from elevation &quot; +
&nbsp;                    // game.getBoard().getHex(prev.getPosition()) + &quot; to &quot; +
&nbsp;                    // game.getBoard().getHex(getPosition()) +
&nbsp;                    // &quot; at assumed elevation &quot; +
&nbsp;                    // elevation + &quot; climb = &quot; + climbMode());
<b class="nc">&nbsp;                    setElevation(entity</b>
<b class="nc">&nbsp;                            .calcElevation(</b>
<b class="nc">&nbsp;                                    game.getBoard().getHex(prev.getPosition()),</b>
<b class="nc">&nbsp;                                    game.getBoard().getHex(getPosition()),</b>
&nbsp;                                    elevation,
<b class="nc">&nbsp;                                    climbMode(),</b>
<b class="nc">&nbsp;                                    (entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                                            &amp;&amp; (prev.getType() == MoveStepType.CLIMB_MODE_OFF)));</b>
&nbsp;                    // System.err.println(&quot; Entity &quot;+ entity.getDisplayName()
&nbsp;                    // +&quot; result was &quot; + elevation);
&nbsp;
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
&nbsp;                // System.err.println(&quot; Entity &quot;+ entity.getDisplayName()
&nbsp;                // +&quot; moving from elevation &quot; +
&nbsp;                // game.getBoard().getHex(prev.getPosition()) + &quot; to &quot; +
&nbsp;                // game.getBoard().getHex(getPosition()) +
&nbsp;                // &quot; at assumed elevation &quot; +
&nbsp;                // elevation + &quot; climb = &quot; + climbMode());
<b class="nc">&nbsp;                setElevation(entity</b>
<b class="nc">&nbsp;                        .calcElevation(</b>
<b class="nc">&nbsp;                                game.getBoard().getHex(prev.getPosition()),</b>
<b class="nc">&nbsp;                                game.getBoard().getHex(getPosition()),</b>
&nbsp;                                elevation,
<b class="nc">&nbsp;                                climbMode(),</b>
<b class="nc">&nbsp;                                (entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (prev.getType() == MoveStepType.CLIMB_MODE_OFF)));</b>
&nbsp;                // System.err.println(&quot; Entity &quot;+ entity.getDisplayName()
&nbsp;                // +&quot; result was &quot; + elevation);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if this is a flying aero, then there is no MP cost for moving
<b class="nc">&nbsp;        if ((prev.getAltitude() &gt; 0) || game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            setMp(0);</b>
&nbsp;            // if this is a spheroid in atmosphere then the cost is always one
&nbsp;            // if it is the very first step, we prepend the cost of hovering for convenience
<b class="nc">&nbsp;            if (useSpheroidAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;                if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                    if ((distance % 8) == 1) {</b>
<b class="nc">&nbsp;                        setMp(1);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    setMp(1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            calcMovementCostFor(game, prev, cachedEntityState);</b>
&nbsp;        }
&nbsp;        // check for water
<b class="nc">&nbsp;        if (!isPavementStep()</b>
<b class="nc">&nbsp;                &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; !(destHex.containsTerrain(Terrains.ICE) &amp;&amp; (elevation &gt;= 0))</b>
<b class="nc">&nbsp;                &amp;&amp; !(destHex.terrainLevel(Terrains.BRIDGE_ELEV) == elevation)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                &amp;&amp; !cachedEntityState.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS)) {</b>
<b class="nc">&nbsp;            setRunProhibited(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity.getMovedBackwards()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.hasQuirk(OptionsConstants.QUIRK_POS_POWER_REVERSE)) {</b>
<b class="nc">&nbsp;            setRunProhibited(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int magmaLevel = destHex.terrainLevel(Terrains.MAGMA);</b>
<b class="nc">&nbsp;        if (elevation &gt; 0) {</b>
<b class="nc">&nbsp;            magmaLevel = 0;</b>
&nbsp;        }
&nbsp;        // Check for fire or magma crust in the new hex.
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.FIRE) || (magmaLevel == 1)) {</b>
<b class="nc">&nbsp;            heat = 2;</b>
<b class="nc">&nbsp;            totalHeat += 2;</b>
&nbsp;        }
&nbsp;        // Check for liquid magma
<b class="nc">&nbsp;        else if (magmaLevel == 2) {</b>
<b class="nc">&nbsp;            heat = 5;</b>
<b class="nc">&nbsp;            totalHeat += 5;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Checks for landed dropships collapsing buildings
<b class="nc">&nbsp;        if ((entity instanceof Dropship) &amp;&amp; !entity.isAirborne()) {</b>
<b class="nc">&nbsp;            ArrayList&lt;Coords&gt; secondaryPositions = new ArrayList&lt;Coords&gt;();</b>
<b class="nc">&nbsp;            secondaryPositions.add(getPosition());</b>
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                secondaryPositions.add(getPosition().translated(dir));</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Coords pos : secondaryPositions) {</b>
<b class="nc">&nbsp;                Building bld = game.getBoard().getBuildingAt(pos);</b>
<b class="nc">&nbsp;                if (bld != null) {</b>
<b class="nc">&nbsp;                    getCrushedBuildingLocs().add(pos);</b>
&nbsp;                    // This is dangerous!
<b class="nc">&nbsp;                    danger = true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
&nbsp;        // WiGEs get bonus MP for each string of three consecutive hexes they descend.
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                &amp;&amp; getClearance() &gt; 0</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ADVANCED_MANEUVERS)) {</b>
&nbsp;
<b class="nc">&nbsp;            if (game.getBoard().getHex(getPosition()).ceiling()</b>
<b class="nc">&nbsp;                    &lt; game.getBoard().getHex(prev.getPosition()).ceiling()) {</b>
<b class="nc">&nbsp;                nWigeDescent = prev.getNWigeDescent() + 1;</b>
<b class="nc">&nbsp;                if (nWigeDescent &gt;= 3) {</b>
<b class="nc">&nbsp;                    wigeBonus++;</b>
<b class="nc">&nbsp;                    nWigeDescent = 0;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                nWigeDescent = 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Compile the static move data for this step.
&nbsp;     *
&nbsp;     * @param game   the &lt;code&gt;Game&lt;/code&gt; being played.
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; taking this step.
&nbsp;     * @param prev   the previous step in the path.
&nbsp;     */
&nbsp;    protected void compile(final IGame game, final Entity entity, MoveStep prev, CachedEntityState cachedEntityState) {
<b class="nc">&nbsp;        final boolean isInfantry = entity instanceof Infantry;</b>
<b class="nc">&nbsp;        boolean isFieldArtillery = (entity instanceof Infantry)</b>
<b class="nc">&nbsp;                &amp;&amp; ((Infantry) entity).hasActiveFieldArtillery();</b>
<b class="nc">&nbsp;        copy(game, prev);</b>
&nbsp;
&nbsp;        // Is this the first step?
<b class="nc">&nbsp;        if (prev == null) {</b>
<b class="nc">&nbsp;            prev = new MoveStep(null, MoveStepType.FORWARDS);</b>
<b class="nc">&nbsp;            prev.setFromEntity(entity, game);</b>
<b class="nc">&nbsp;            prev.isCarefulPath = isCareful();</b>
<b class="nc">&nbsp;            prev.isJumpingPath = isJumping();</b>
<b class="nc">&nbsp;            setFirstStep(prev.mpUsed == 0); // Bug 1519330 - its not a first step when continuing after a fall</b>
<b class="nc">&nbsp;        } else if (prev.isFirstStep() // Some step types don&#39;t remove first step status</b>
<b class="nc">&nbsp;                &amp;&amp; ((prev.getType() == MoveStepType.CLIMB_MODE_ON)</b>
<b class="nc">&nbsp;                        || (prev.getType() == MoveStepType.CLIMB_MODE_OFF))) {</b>
<b class="nc">&nbsp;            setFirstStep(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (getType()) {</b>
&nbsp;            case UNLOAD:
&nbsp;            case DISCONNECT:
&nbsp;                // Infantry in immobilized transporters get
&nbsp;                // a special &quot;unload stranded&quot; game turn.
&nbsp;                // So do trailers on an immobilized tractor
<b class="nc">&nbsp;                hasEverUnloaded = true;</b>
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case LOAD:
&nbsp;            case TOW:
<b class="nc">&nbsp;                setMp(1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MOUNT:
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case TURN_LEFT:
&nbsp;            case TURN_RIGHT:
&nbsp;                // Check for pavement movement.
<b class="nc">&nbsp;                if (!entity.isAirborne() &amp;&amp; Compute.canMoveOnPavement(game, prev.getPosition(), getPosition(), this)) {</b>
<b class="nc">&nbsp;                    setPavementStep(true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setPavementStep(false);</b>
<b class="nc">&nbsp;                    setOnlyPavement(false);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Infantry can turn for free, except for field artillery
<b class="nc">&nbsp;                setMp((isJumping() || isHasJustStood() || (isInfantry &amp;&amp; !isFieldArtillery)) ? 0</b>
<b class="nc">&nbsp;                        : 1);</b>
<b class="nc">&nbsp;                setNStraight(0);</b>
<b class="nc">&nbsp;                if (entity.isAirborne() &amp;&amp; (entity.isAero())) {</b>
<b class="nc">&nbsp;                    setMp(asfTurnCost(game, getType(), entity));</b>
<b class="nc">&nbsp;                    setNTurns(getNTurns() + 1);</b>
&nbsp;
<b class="nc">&nbsp;                    if (useAeroAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;                        setFreeTurn(false);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // tripods with all their legs only pay for their first facing change
<b class="nc">&nbsp;                if ((getEntity() instanceof TripodMech) &amp;&amp; (((Mech) getEntity()).countBadLegs() &lt; 1)</b>
&nbsp;                        &amp;&amp; ((prev.type == MoveStepType.TURN_LEFT) || (prev.type == MoveStepType.TURN_RIGHT))) {
<b class="nc">&nbsp;                    setMp(0);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (entity.isDropping()) {</b>
<b class="nc">&nbsp;                    setMp(0);</b>
&nbsp;                }
<b class="nc">&nbsp;                adjustFacing(getType());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case BACKWARDS:
<b class="nc">&nbsp;                moveInDir((getFacing() + 3) % 6);</b>
<b class="nc">&nbsp;                setThisStepBackwards(true);</b>
<b class="nc">&nbsp;                if (!entity.hasQuirk(OptionsConstants.QUIRK_POS_POWER_REVERSE)) {</b>
<b class="nc">&nbsp;                    setRunProhibited(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                compileMove(game, entity, prev, cachedEntityState);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case FORWARDS:
&nbsp;            case DFA:
&nbsp;            case SWIM:
&nbsp;                // step forwards or backwards
<b class="nc">&nbsp;                moveInDir(getFacing());</b>
<b class="nc">&nbsp;                setThisStepBackwards(false);</b>
<b class="nc">&nbsp;                compileMove(game, entity, prev, cachedEntityState);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CHARGE:
<b class="nc">&nbsp;                if (!(entity.isAirborne()) || !game.useVectorMove()) {</b>
<b class="nc">&nbsp;                    moveInDir(getFacing());</b>
<b class="nc">&nbsp;                    setThisStepBackwards(false);</b>
<b class="nc">&nbsp;                    compileMove(game, entity, prev, cachedEntityState);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case LATERAL_LEFT_BACKWARDS:
&nbsp;            case LATERAL_RIGHT_BACKWARDS:
<b class="nc">&nbsp;                moveInDir((MovePath.getAdjustedFacing(getFacing(),</b>
<b class="nc">&nbsp;                        MovePath.turnForLateralShift(getType())) + 3) % 6);</b>
<b class="nc">&nbsp;                setThisStepBackwards(true);</b>
<b class="nc">&nbsp;                if (!entity.hasQuirk(OptionsConstants.QUIRK_POS_POWER_REVERSE)) {</b>
<b class="nc">&nbsp;                    setRunProhibited(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                compileMove(game, entity, prev, cachedEntityState);</b>
<b class="nc">&nbsp;                if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                    setMp(0);</b>
<b class="nc">&nbsp;                } else if (entity.isUsingManAce()</b>
&nbsp;                        &amp; (entity instanceof QuadMech)) {
<b class="nc">&nbsp;                    setMp(getMp());</b>
<b class="nc">&nbsp;                } else if (isJumping() &amp;&amp;</b>
<b class="nc">&nbsp;                        (entity.getJumpType() == Mech.JUMP_BOOSTER)) {</b>
<b class="nc">&nbsp;                    setMp(1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setMp(getMp() + 1); // +1 for side step</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case LATERAL_LEFT:
&nbsp;            case LATERAL_RIGHT:
<b class="nc">&nbsp;                moveInDir(MovePath.getAdjustedFacing(getFacing(),</b>
<b class="nc">&nbsp;                        MovePath.turnForLateralShift(getType())));</b>
<b class="nc">&nbsp;                setThisStepBackwards(false);</b>
<b class="nc">&nbsp;                compileMove(game, entity, prev, cachedEntityState);</b>
<b class="nc">&nbsp;                if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                    setMp(0);</b>
<b class="nc">&nbsp;                } else if (entity.isUsingManAce()</b>
&nbsp;                        &amp; (entity instanceof QuadMech)) {
<b class="nc">&nbsp;                    setMp(getMp());</b>
<b class="nc">&nbsp;                } else if (isJumping() &amp;&amp;</b>
<b class="nc">&nbsp;                        (entity.getJumpType() == Mech.JUMP_BOOSTER)) {</b>
<b class="nc">&nbsp;                    setMp(1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setMp(getMp() + 1); // +1 for side step</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case GET_UP:
&nbsp;                // mechs with 1 MP are allowed to get up
<b class="nc">&nbsp;                setMp(cachedEntityState.getRunMP() == 1 ? 1 : 2);</b>
<b class="nc">&nbsp;                setHasJustStood(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CAREFUL_STAND:
<b class="nc">&nbsp;                if (cachedEntityState.getWalkMP() &lt;= 2) {</b>
<b class="nc">&nbsp;                    entity.setCarefulStand(false);</b>
<b class="nc">&nbsp;                    setMp(cachedEntityState.getRunMP() == 1 ? 1 : 2);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setMp(cachedEntityState.getWalkMP());</b>
&nbsp;                }
<b class="nc">&nbsp;                setHasJustStood(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case GO_PRONE:
<b class="nc">&nbsp;                if (!entity.isHullDown()) {</b>
<b class="nc">&nbsp;                    setMp(1);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case START_JUMP:
<b class="nc">&nbsp;                entity.setIsJumpingNow(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case UP:
<b class="nc">&nbsp;                if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                    setAltitude(altitude + 1);</b>
<b class="nc">&nbsp;                    setMp(2);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
&nbsp;                        // If on the ground, pay liftoff cost. If airborne, pay 1 MP to increase elevation
&nbsp;                        // (LAMs and glider protomechs only)
<b class="nc">&nbsp;                        if (getClearance() == 0) {</b>
<b class="nc">&nbsp;                            setMp((entity instanceof Protomech)? 4 : 5);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            setMp(1);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                            setMp(isJumping() ? 0 : 2);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            setMp(isJumping() ? 0 : 1);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    setElevation(elevation + 1);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case DOWN:
<b class="nc">&nbsp;                if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                    setAltitude(altitude - 1);</b>
&nbsp;                    // it costs nothing (and may increase velocity)
<b class="nc">&nbsp;                    setMp(0);</b>
<b class="nc">&nbsp;                    setNDown(getNDown() + 1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setElevation(elevation - 1);</b>
<b class="nc">&nbsp;                    if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                        setMp(0);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                            setMp(isJumping() ? 0 : 2);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            setMp(isJumping() ? 0 : 1);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case HULL_DOWN:
<b class="nc">&nbsp;                if (isProne() &amp;&amp; (entity instanceof Mech)) {</b>
<b class="nc">&nbsp;                    int mpUsed = 1;</b>
<b class="nc">&nbsp;                    if (entity instanceof BipedMech) {</b>
<b class="nc">&nbsp;                        for (int location = Mech.LOC_RLEG; location &lt;= Mech.LOC_LLEG; location++) {</b>
<b class="nc">&nbsp;                            if (entity.isLocationBad(location)) {</b>
<b class="nc">&nbsp;                                mpUsed += 99;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            mpUsed += ((Mech) entity)</b>
<b class="nc">&nbsp;                                    .countLegActuatorCrits(location);</b>
<b class="nc">&nbsp;                            if (((Mech) entity).legHasHipCrit(location)) {</b>
<b class="nc">&nbsp;                                mpUsed += 1;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        for (int location = Mech.LOC_RARM; location &lt;= Mech.LOC_LLEG; location++) {</b>
<b class="nc">&nbsp;                            if (entity.isLocationBad(location)) {</b>
<b class="nc">&nbsp;                                mpUsed += 99;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            mpUsed += ((QuadMech) entity)</b>
<b class="nc">&nbsp;                                    .countLegActuatorCrits(location);</b>
<b class="nc">&nbsp;                            if (((QuadMech) entity).legHasHipCrit(location)) {</b>
<b class="nc">&nbsp;                                mpUsed += 1;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    setMp(mpUsed);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    setMp(2);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CLIMB_MODE_ON:
<b class="nc">&nbsp;                setClimbMode(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CLIMB_MODE_OFF:
<b class="nc">&nbsp;                setClimbMode(false);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SHAKE_OFF_SWARMERS:
&nbsp;                // Counts as flank move but you can only use cruise MP
<b class="nc">&nbsp;                setMp(cachedEntityState.getRunMP() - cachedEntityState.getWalkMP());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case TAKEOFF:
&nbsp;            case VTAKEOFF:
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case LAND:
&nbsp;            case VLAND:
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                setAltitude(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case ACCN:
<b class="nc">&nbsp;                setVelocityN(getVelocityN() + 1);</b>
<b class="nc">&nbsp;                setMp(1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case DECN:
<b class="nc">&nbsp;                setVelocityN(getVelocityN() - 1);</b>
<b class="nc">&nbsp;                setMp(1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case ACC:
<b class="nc">&nbsp;                setVelocity(getVelocity() + 1);</b>
<b class="nc">&nbsp;                setVelocityLeft(getVelocityLeft() + 1);</b>
<b class="nc">&nbsp;                setMp(1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case DEC:
<b class="nc">&nbsp;                setVelocity(getVelocity() - 1);</b>
<b class="nc">&nbsp;                setVelocityLeft(getVelocityLeft() - 1);</b>
<b class="nc">&nbsp;                setMp(1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case EVADE:
<b class="nc">&nbsp;                setEvading(true);</b>
<b class="nc">&nbsp;                if (entity.isAirborne()) {</b>
<b class="nc">&nbsp;                    setMp(2);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case SHUTDOWN:
<b class="nc">&nbsp;                setShuttingDown(true);</b>
&nbsp;                // Do something here...
<b class="nc">&nbsp;                break;</b>
&nbsp;            case STARTUP:
<b class="nc">&nbsp;                setStartingUp(true);</b>
&nbsp;                // Do something here...
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SELF_DESTRUCT:
<b class="nc">&nbsp;                setSelfDestructing(true);</b>
&nbsp;                // Do something here...
<b class="nc">&nbsp;                break;</b>
&nbsp;            case ROLL:
<b class="nc">&nbsp;                if (prev.isRolled) {</b>
<b class="nc">&nbsp;                    isRolled = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    isRolled = true;</b>
&nbsp;                }
&nbsp;                // doesn&#39;t cost anything if previous was a yaw
<b class="nc">&nbsp;                if (prev.getType() != MoveStepType.YAW) {</b>
<b class="nc">&nbsp;                    setMp(1);</b>
<b class="nc">&nbsp;                    setNRolls(getNRolls() + 1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setMp(0);</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case LAUNCH:
&nbsp;            case DROP:
<b class="nc">&nbsp;                hasEverUnloaded = true;</b>
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case RECOVER:
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case JOIN:
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case THRUST:
<b class="nc">&nbsp;                setVectors(Compute.changeVectors(getVectors(), getFacing()));</b>
<b class="nc">&nbsp;                setMp(1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case YAW:
<b class="nc">&nbsp;                setNRolls(getNRolls() + 1);</b>
<b class="nc">&nbsp;                reverseFacing();</b>
<b class="nc">&nbsp;                setMp(2);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case HOVER:
<b class="nc">&nbsp;                if (entity.isAero()) {</b>
<b class="nc">&nbsp;                    setMp(2);</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                    if (entity instanceof LandAirMech</b>
<b class="nc">&nbsp;                            &amp;&amp; entity.getAltitude() &gt; 0) {</b>
<b class="nc">&nbsp;                        setMp(10);</b>
<b class="nc">&nbsp;                        setElevation(altitude * 10);</b>
<b class="nc">&nbsp;                        setAltitude(0);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        setMp(entity instanceof Protomech? 4 : 5);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            case MANEUVER:
<b class="nc">&nbsp;                int cost = ManeuverType.getCost(getManeuverType(),</b>
<b class="nc">&nbsp;                        getVelocity());</b>
<b class="nc">&nbsp;                if (entity.isUsingManAce()) {</b>
<b class="nc">&nbsp;                    cost = Math.max(cost - 1, 0);</b>
&nbsp;                }
<b class="nc">&nbsp;                setMp(cost);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case LOOP:
<b class="nc">&nbsp;                setVelocityLeft(getVelocityLeft() - 4);</b>
<b class="nc">&nbsp;                setMp(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CONVERT_MODE:
<b class="nc">&nbsp;                if (entity instanceof QuadVee) {</b>
<b class="nc">&nbsp;                    setMp(((QuadVee)entity).conversionCost());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    setMp(0);</b>
&nbsp;                }
<b class="nc">&nbsp;                movementMode = entity.nextConversionMode(prev.getMovementMode());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case BOOTLEGGER:
<b class="nc">&nbsp;                reverseFacing();</b>
<b class="nc">&nbsp;                setMp(2);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                setMp(0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (noCost) {</b>
<b class="nc">&nbsp;            setMp(0);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (type != MoveStepType.CONVERT_MODE) {</b>
<b class="nc">&nbsp;            movementMode = prev.getMovementMode();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Tanks can just drive out of hull-down.  If we&#39;re a tank, and we moved
&nbsp;        //  then we are no longer hull-down.
<b class="nc">&nbsp;        if ((entity instanceof Tank</b>
&nbsp;                || (entity instanceof QuadVee
<b class="nc">&nbsp;                        &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</b>
&nbsp;                &amp;&amp; (distance &gt; 0)) {
<b class="nc">&nbsp;            setHullDown(false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update the entity&#39;s total MP used.
<b class="nc">&nbsp;        addMpUsed(getMp());</b>
&nbsp;
&nbsp;        // Check for a stacking violation.
<b class="nc">&nbsp;        final Entity violation = Compute.stackingViolation(game,</b>
<b class="nc">&nbsp;                entity, getElevation(), getPosition(), null);</b>
<b class="nc">&nbsp;        if ((violation != null) &amp;&amp; (getType() != MoveStepType.CHARGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (getType() != MoveStepType.DFA)) {</b>
<b class="nc">&nbsp;            setStackingViolation(true);</b>
&nbsp;        }
&nbsp;
&nbsp;        // set moveType, illegal, trouble flags
<b class="nc">&nbsp;        compileIllegal(game, entity, prev, cachedEntityState);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether the two step types contain opposite turns
&nbsp;     */
&nbsp;    boolean oppositeTurn(MoveStep turn2) {
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case TURN_LEFT:
<b class="nc">&nbsp;                return turn2.getType() == MoveStepType.TURN_RIGHT;</b>
&nbsp;            case TURN_RIGHT:
<b class="nc">&nbsp;                return turn2.getType() == MoveStepType.TURN_LEFT;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void setElevation(int el) {
<b class="nc">&nbsp;        elevation = el;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setAltitude(int alt) {
<b class="nc">&nbsp;        altitude = alt;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Takes the given state as the previous state and sets flags from it.
&nbsp;     *
&nbsp;     * @param game
&nbsp;     * @param prev
&nbsp;     */
&nbsp;    public void copy(final IGame game, MoveStep prev) {
<b class="nc">&nbsp;        if (prev == null) {</b>
<b class="nc">&nbsp;            setFromEntity(getEntity(), game);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        hasJustStood = prev.hasJustStood;</b>
<b class="nc">&nbsp;        facing = prev.getFacing();</b>
<b class="nc">&nbsp;        position = prev.getPosition();</b>
&nbsp;
<b class="nc">&nbsp;        distance = prev.getDistance();</b>
<b class="nc">&nbsp;        mpUsed = prev.mpUsed;</b>
<b class="nc">&nbsp;        totalHeat = prev.totalHeat;</b>
<b class="nc">&nbsp;        isPavementStep = prev.isPavementStep;</b>
<b class="nc">&nbsp;        onlyPavement = prev.onlyPavement;</b>
<b class="nc">&nbsp;        wigeBonus = prev.wigeBonus;</b>
<b class="nc">&nbsp;        nWigeDescent = prev.nWigeDescent;</b>
<b class="nc">&nbsp;        thisStepBackwards = prev.thisStepBackwards;</b>
<b class="nc">&nbsp;        isProne = prev.isProne;</b>
<b class="nc">&nbsp;        isFlying = prev.isFlying;</b>
<b class="nc">&nbsp;        isHullDown = prev.isHullDown;</b>
<b class="nc">&nbsp;        climbMode = prev.climbMode;</b>
<b class="nc">&nbsp;        isRunProhibited = prev.isRunProhibited;</b>
<b class="nc">&nbsp;        hasEverUnloaded = prev.hasEverUnloaded;</b>
<b class="nc">&nbsp;        elevation = prev.elevation;</b>
<b class="nc">&nbsp;        altitude = prev.altitude;</b>
<b class="nc">&nbsp;        velocity = prev.velocity;</b>
<b class="nc">&nbsp;        velocityN = prev.velocityN;</b>
<b class="nc">&nbsp;        velocityLeft = prev.velocityLeft;</b>
<b class="nc">&nbsp;        nTurns = prev.nTurns;</b>
<b class="nc">&nbsp;        isEvading = prev.isEvading;</b>
<b class="nc">&nbsp;        isShuttingDown = prev.isShuttingDown;</b>
<b class="nc">&nbsp;        isStartingUp = prev.isStartingUp;</b>
<b class="nc">&nbsp;        isSelfDestructing = prev.isSelfDestructing;</b>
<b class="nc">&nbsp;        nRolls = prev.nRolls;</b>
<b class="nc">&nbsp;        isRolled = prev.isRolled;</b>
<b class="nc">&nbsp;        mv = prev.mv.clone();</b>
<b class="nc">&nbsp;        freeTurn = prev.freeTurn;</b>
<b class="nc">&nbsp;        nStraight = prev.nStraight;</b>
<b class="nc">&nbsp;        nDown = prev.nDown;</b>
<b class="nc">&nbsp;        nMoved = prev.nMoved;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets this state as coming from the entity.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     */
&nbsp;    public void setFromEntity(Entity entity, IGame game) {
<b class="nc">&nbsp;        this.entity = entity;</b>
<b class="nc">&nbsp;        position = entity.getPosition();</b>
<b class="nc">&nbsp;        facing = entity.getFacing();</b>
&nbsp;        // elevation
<b class="nc">&nbsp;        mpUsed = entity.mpUsed;</b>
<b class="nc">&nbsp;        distance = entity.delta_distance;</b>
<b class="nc">&nbsp;        isProne = entity.isProne();</b>
<b class="nc">&nbsp;        isFlying = entity.isAirborne() || entity.isAirborneVTOLorWIGE();</b>
<b class="nc">&nbsp;        isHullDown = entity.isHullDown();</b>
<b class="nc">&nbsp;        climbMode = entity.climbMode();</b>
<b class="nc">&nbsp;        thisStepBackwards = entity.inReverse;</b>
&nbsp;        // Moving in reverse prohibits running
<b class="nc">&nbsp;        if (thisStepBackwards) {</b>
<b class="nc">&nbsp;            isRunProhibited = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        elevation = entity.getElevation();</b>
<b class="nc">&nbsp;        altitude = entity.getAltitude();</b>
<b class="nc">&nbsp;        movementType = entity.moved;</b>
<b class="nc">&nbsp;        movementMode = entity.getMovementMode();</b>
&nbsp;
<b class="nc">&nbsp;        isRolled = false;</b>
<b class="nc">&nbsp;        freeTurn = false;</b>
<b class="nc">&nbsp;        nStraight = 0;</b>
<b class="nc">&nbsp;        nDown = 0;</b>
&nbsp;
&nbsp;        // for some reason, doing it directly is adjusting the entity&#39;s vector
&nbsp;        // itself
&nbsp;        // which causes problems when canceling the action
&nbsp;        // what a hack. but I can&#39;t figure out what is going wrong
&nbsp;        // this works but god is it ugly
&nbsp;        // TODO: figure this out
<b class="nc">&nbsp;        int[] tempMv = entity.getVectors();</b>
&nbsp;
<b class="nc">&nbsp;        mv = new int[]{0, 0, 0, 0, 0, 0};</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            mv[i] = tempMv[i];</b>
&nbsp;        }
&nbsp;
&nbsp;        // if ASF get velocity
<b class="nc">&nbsp;        if (entity.isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;            velocity = a.getCurrentVelocity();</b>
<b class="nc">&nbsp;            velocityN = a.getNextVelocity();</b>
<b class="nc">&nbsp;            velocityLeft = a.getCurrentVelocity() - entity.delta_distance;</b>
<b class="nc">&nbsp;            if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                velocityLeft = a.getCurrentVelocity() - (entity.delta_distance / 16);</b>
&nbsp;            }
<b class="nc">&nbsp;            isRolled = false;// a.isRolled();</b>
<b class="nc">&nbsp;            nStraight = a.getStraightMoves();</b>
<b class="nc">&nbsp;            if (dueFreeTurn()) {</b>
<b class="nc">&nbsp;                setFreeTurn(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        EntityMovementMode nMove = entity.getMovementMode();</b>
&nbsp;
&nbsp;        // tanks with stunned crew can&#39;t flank
<b class="nc">&nbsp;        if ((entity instanceof Tank) &amp;&amp; (((Tank) entity).getStunnedTurns() &gt; 0)) {</b>
<b class="nc">&nbsp;            isRunProhibited = true;</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Cannot run while using Mek tracks
<b class="nc">&nbsp;        if (entity instanceof Mech &amp;&amp; entity.getMovementMode() == EntityMovementMode.TRACKED</b>
&nbsp;                &amp;&amp; !(entity instanceof QuadVee)) {
<b class="nc">&nbsp;            isRunProhibited = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check pavement &amp; water
<b class="nc">&nbsp;        if (position != null) {</b>
<b class="nc">&nbsp;            IHex curHex = game.getBoard().getHex(position);</b>
<b class="nc">&nbsp;            if (curHex.hasPavement()) {</b>
<b class="nc">&nbsp;                onlyPavement = true;</b>
<b class="nc">&nbsp;                isPavementStep = true;</b>
&nbsp;                // if we previously moved, and didn&#39;t get a pavement bonus, we
&nbsp;                // shouldn&#39;t now get one, either (this can happen when skidding
&nbsp;                // onto a pavement hex
<b class="nc">&nbsp;                if (!entity.gotPavementBonus</b>
&nbsp;                        &amp;&amp; (entity.delta_distance &gt; 0)) {
<b class="nc">&nbsp;                    onlyPavement = false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // if entity already moved into water it can&#39;t run now
<b class="nc">&nbsp;            if (curHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getElevation() &lt; 0) &amp;&amp; (distance &gt; 0)</b>
&nbsp;                    &amp;&amp; (nMove != EntityMovementMode.NAVAL)
&nbsp;                    &amp;&amp; (nMove != EntityMovementMode.HYDROFOIL)
&nbsp;                    &amp;&amp; (nMove != EntityMovementMode.SUBMARINE)
&nbsp;                    &amp;&amp; (nMove != EntityMovementMode.INF_UMU)) {
<b class="nc">&nbsp;                isRunProhibited = true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adjusts facing to comply with the type of step indicated.
&nbsp;     *
&nbsp;     * @param stepType
&nbsp;     */
&nbsp;    public void adjustFacing(MoveStepType stepType) {
<b class="nc">&nbsp;        facing = MovePath.getAdjustedFacing(facing, stepType);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * For yaws, reverse the current facing
&nbsp;     */
&nbsp;    public void reverseFacing() {
<b class="nc">&nbsp;        facing = MovePath.getAdjustedFacing(facing, MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;        facing = MovePath.getAdjustedFacing(facing, MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;        facing = MovePath.getAdjustedFacing(facing, MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Moves the position one hex in the direction indicated. Does not change
&nbsp;     * facing.
&nbsp;     *
&nbsp;     * @param dir
&nbsp;     */
&nbsp;    public void moveInDir(int dir) {
<b class="nc">&nbsp;        position = position.translated(dir);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a certain amount to the distance parameter.
&nbsp;     *
&nbsp;     * @param increment
&nbsp;     */
&nbsp;    public void addDistance(int increment) {
<b class="nc">&nbsp;        distance += increment;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a certain amount to the mpUsed parameter.
&nbsp;     *
&nbsp;     * @param increment
&nbsp;     */
&nbsp;    public void addMpUsed(int increment) {
<b class="nc">&nbsp;        mpUsed += increment;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isDanger() {
<b class="nc">&nbsp;        return danger;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getDistance() {
<b class="nc">&nbsp;        return distance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getLeapDistance() {
<b class="nc">&nbsp;        return leapDistance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getFacing() {
<b class="nc">&nbsp;        return facing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isFirstStep() {
<b class="nc">&nbsp;        return firstStep;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isHasJustStood() {
<b class="nc">&nbsp;        return hasJustStood;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isPavementStep() {
<b class="nc">&nbsp;        return isPavementStep;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isProne() {
<b class="nc">&nbsp;        return isProne;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity is flying on this step.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isFlying() {
<b class="nc">&nbsp;        return isFlying;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isHullDown() {
<b class="nc">&nbsp;        return isHullDown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean climbMode() {
<b class="nc">&nbsp;        return climbMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isTurning() {
<b class="nc">&nbsp;        return isTurning;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isUnloaded() {
<b class="nc">&nbsp;        return isUnloaded;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isUsingMASC() {
<b class="nc">&nbsp;        return isUsingMASC;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEvading() {
<b class="nc">&nbsp;        return isEvading;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isShuttingDown() {
<b class="nc">&nbsp;        return isShuttingDown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isStartingUp() {
<b class="nc">&nbsp;        return isStartingUp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isSelfDestructing() {
<b class="nc">&nbsp;        return isSelfDestructing;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isRolled() {
<b class="nc">&nbsp;        return isRolled;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public boolean isVTOLBombingStep() {
<b class="nc">&nbsp;        return targetType == Targetable.TYPE_HEX_AERO_BOMB;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public boolean isStrafingStep() {
<b class="nc">&nbsp;        return targetType == Targetable.TYPE_HEX_CLEAR;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Determine if this is a legal step as part of the supplied MovePath.
&nbsp;     *
&nbsp;     * @param path  A MovePath that contains this step.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the step is legal. &lt;code&gt;false&lt;/code&gt;
&nbsp;     *         otherwise.
&nbsp;     */
&nbsp;    public boolean isLegal(MovePath path) {
&nbsp;        // A step is legal if it&#39;s static movement type is not illegal,
&nbsp;        // and it is either a valid end position, or not an end position.
<b class="nc">&nbsp;        return ((movementType != EntityMovementType.MOVE_ILLEGAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (isLegalEndPos() || !isEndPos(path)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return this step&#39;s movement type.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; constant for this step&#39;s movement type.
&nbsp;     */
&nbsp;    public EntityMovementType getMovementType(boolean isLastStep) {
<b class="nc">&nbsp;        EntityMovementType moveType = movementType;</b>
&nbsp;        // If this step&#39;s position is the end of the path, and it is not
&nbsp;        // a valid end postion, then the movement type is &quot;illegal&quot;.
<b class="nc">&nbsp;        if (isLastStep &amp;&amp; !isLegalEndPos()) {</b>
<b class="nc">&nbsp;            moveType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
<b class="nc">&nbsp;        return moveType;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public EntityMovementMode getMovementMode() {
<b class="nc">&nbsp;        if (movementMode == EntityMovementMode.NONE) {</b>
<b class="nc">&nbsp;            return getEntity().getMovementMode();</b>
&nbsp;        }
<b class="nc">&nbsp;        return movementMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if this step&#39;s position is a valid end of a path.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this step&#39;s position is a legal end of a
&nbsp;     *         path. If the step is not legal for an end of a path, then
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; is returned.
&nbsp;     */
&nbsp;    public boolean isLegalEndPos() {
&nbsp;        // Can&#39;t be a stacking violation.
<b class="nc">&nbsp;        boolean legal = true;</b>
<b class="nc">&nbsp;        if (isStackingViolation) {</b>
<b class="nc">&nbsp;            legal = false;</b>
<b class="nc">&nbsp;        } else if (terrainInvalid) {</b>
&nbsp;            // Can&#39;t be into invalid terrain.
<b class="nc">&nbsp;            legal = false;</b>
<b class="nc">&nbsp;        } else if (isJumping() &amp;&amp; (distance == 0)) {</b>
&nbsp;            // Can&#39;t jump zero hexes.
<b class="nc">&nbsp;            legal = false;</b>
<b class="nc">&nbsp;        } else if (hasEverUnloaded &amp;&amp; (type != MoveStepType.UNLOAD)</b>
&nbsp;                &amp;&amp; (type != MoveStepType.LAUNCH) &amp;&amp; (type != MoveStepType.DROP)
&nbsp;                &amp;&amp; (type != MoveStepType.UNDOCK) &amp;&amp; (type != MoveStepType.DISCONNECT)
<b class="nc">&nbsp;                &amp;&amp; (getAltitude() == 0)) {</b>
&nbsp;            // Can&#39;t be after unloading BA/inf
<b class="nc">&nbsp;            legal = false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return legal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update this step&#39;s status as the ending position of a path.
&nbsp;     *
&nbsp;     * @param isEnd the &lt;code&gt;boolean&lt;/code&gt; flag that specifies that this step&#39;s
&nbsp;     *              position is the end of a path.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the path needs to keep updating the steps.
&nbsp;     *         &lt;code&gt;false&lt;/code&gt; if the update of the path is complete.
&nbsp;     * @see &lt;code&gt;#isLegalEndPos()&lt;/code&gt;
&nbsp;     * @see &lt;code&gt;#isEndPos&lt;/code&gt;
&nbsp;     * @see &lt;code&gt;MovePath#addStep( MoveStep )&lt;/code&gt;
&nbsp;     */
&nbsp;    public boolean setEndPos(boolean isEnd) {
<b class="nc">&nbsp;        boolean isEndPos = true;</b>
&nbsp;        // A step that is always illegal is always the end of the path.
<b class="nc">&nbsp;        if (EntityMovementType.MOVE_ILLEGAL == movementType) {</b>
<b class="nc">&nbsp;            isEnd = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If this step didn&#39;t already know it&#39;s status as the ending
&nbsp;        // position of a path, then there are more updates to do.
<b class="nc">&nbsp;        boolean moreUpdates = (isEndPos != isEnd);</b>
<b class="nc">&nbsp;        isEndPos = isEnd;</b>
&nbsp;
&nbsp;        // If this step isn&#39;t the end step anymore, we might not be in danger
&nbsp;        // after all
<b class="nc">&nbsp;        IHex pos = getGame().getBoard().getHex(position);</b>
<b class="nc">&nbsp;        if (getGame().getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_PSR_JUMP_HEAVY_WOODS)) {</b>
<b class="nc">&nbsp;            if (!isEnd</b>
<b class="nc">&nbsp;                    &amp;&amp; isJumping()</b>
<b class="nc">&nbsp;                    &amp;&amp; (pos.containsTerrain(Terrains.WOODS, 2) </b>
<b class="nc">&nbsp;                            || pos.containsTerrain(Terrains.WOODS, 3))) {</b>
<b class="nc">&nbsp;                danger = false;</b>
<b class="nc">&nbsp;                pastDanger = false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return moreUpdates;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns true if a step is considered to be in an end position for the
&nbsp;     * given MovePath. A step is in an end position if it is the last legal
&nbsp;     * step, or is an illegal step past the last legal step.
&nbsp;     * 
&nbsp;     * @param path
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isEndPos(MovePath path) {
&nbsp;        // A step that is illegal is always the end of the path.
<b class="nc">&nbsp;        if (EntityMovementType.MOVE_ILLEGAL == movementType) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (path == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // A step is an end position if it is the last legal step.
<b class="nc">&nbsp;        Vector&lt;MoveStep&gt; steps = path.getStepVector();</b>
&nbsp;        // Starting from the end, each step is considered the last step until
&nbsp;        // we find a legal last step
<b class="nc">&nbsp;        boolean lastStep = true;</b>
<b class="nc">&nbsp;        for (int i = steps.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            MoveStep step = steps.get(i);</b>
<b class="nc">&nbsp;            boolean stepMatch = this.equals(step);</b>
<b class="nc">&nbsp;            if (lastStep) {</b>
<b class="nc">&nbsp;                lastStep &amp;= step.getMovementType(true) == EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;            // If there is a legal step after us, we&#39;re not the end
<b class="nc">&nbsp;            if ((step.getMovementType(lastStep) != EntityMovementType.MOVE_ILLEGAL)</b>
&nbsp;                    &amp;&amp; !stepMatch) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            // If we found the current step, no need to check the others
<b class="nc">&nbsp;            } else if (stepMatch) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Shouldn&#39;t reach here, since this step is assumed be in the step list
<b class="nc">&nbsp;        return false;        </b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getMpUsed() {
<b class="nc">&nbsp;        return mpUsed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isOnlyPavement() {
<b class="nc">&nbsp;        return onlyPavement;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getWiGEBonus() {
<b class="nc">&nbsp;        return wigeBonus;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getNWigeDescent() {
<b class="nc">&nbsp;        return nWigeDescent;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isPastDanger() {
<b class="nc">&nbsp;        return pastDanger;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void setPastDanger(boolean pastDanger) {
<b class="nc">&nbsp;        this.pastDanger = pastDanger;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isDocking() {
<b class="nc">&nbsp;        return docking;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDocking(boolean tf) {
<b class="nc">&nbsp;        docking = tf;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Coords getPosition() {
<b class="nc">&nbsp;        return position;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isPrevStepOnPavement() {
<b class="nc">&nbsp;        return prevStepOnPavement;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getTargetNumberMASC() {
<b class="nc">&nbsp;        return targetNumberMASC;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isThisStepBackwards() {
<b class="nc">&nbsp;        return thisStepBackwards;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    public void setDanger(boolean b) {
<b class="nc">&nbsp;        danger = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param i
&nbsp;     */
&nbsp;    protected void setDistance(int i) {
<b class="nc">&nbsp;        distance = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param i
&nbsp;     */
&nbsp;    protected void setLeapDistance(int i) {
<b class="nc">&nbsp;        leapDistance = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param i
&nbsp;     */
&nbsp;    protected void setFacing(int i) {
<b class="nc">&nbsp;        facing = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setFirstStep(boolean b) {
<b class="nc">&nbsp;        firstStep = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setHasJustStood(boolean b) {
<b class="nc">&nbsp;        hasJustStood = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setPavementStep(boolean b) {
<b class="nc">&nbsp;        isPavementStep = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setProne(boolean b) {
<b class="nc">&nbsp;        isProne = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets whether the entity is flying or not.
&nbsp;     *
&nbsp;     * @param b is this entity flying?
&nbsp;     */
&nbsp;    protected void setFlying(boolean b) {
<b class="nc">&nbsp;        isFlying = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setHullDown(boolean b) {
<b class="nc">&nbsp;        isHullDown = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setClimbMode(boolean b) {
<b class="nc">&nbsp;        climbMode = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setTurning(boolean b) {
<b class="nc">&nbsp;        isTurning = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setUnloaded(boolean b) {
<b class="nc">&nbsp;        isUnloaded = b;</b>
<b class="nc">&nbsp;        if (b) {</b>
<b class="nc">&nbsp;            hasEverUnloaded = true;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setUsingMASC(boolean b) {
<b class="nc">&nbsp;        isUsingMASC = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param i
&nbsp;     */
&nbsp;    public void setMovementType(EntityMovementType i) {
<b class="nc">&nbsp;        movementType = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setEvading(boolean b) {
<b class="nc">&nbsp;        isEvading = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setShuttingDown(boolean b) {
<b class="nc">&nbsp;        isShuttingDown = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setStartingUp(boolean b) {
<b class="nc">&nbsp;        isStartingUp = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setSelfDestructing(boolean b) {
<b class="nc">&nbsp;        isSelfDestructing = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * @param b
&nbsp;     */
&nbsp;    protected void setOnlyPavement(boolean b) {
<b class="nc">&nbsp;        onlyPavement = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    protected void setWiGEBonus(int i) {
<b class="nc">&nbsp;        wigeBonus = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setTargetNumberMASC(int i) {
<b class="nc">&nbsp;        targetNumberMASC = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setThisStepBackwards(boolean b) {
<b class="nc">&nbsp;        thisStepBackwards = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the mp used for just this step.
&nbsp;     */
&nbsp;    public int getMp() {
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * sets the mp for this step.
&nbsp;     *
&nbsp;     * @param i the mp for this step.
&nbsp;     */
&nbsp;    protected void setMp(int i) {
<b class="nc">&nbsp;        mp = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setRunProhibited(boolean isRunProhibited) {
<b class="nc">&nbsp;        this.isRunProhibited = isRunProhibited;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    boolean isRunProhibited() {
<b class="nc">&nbsp;        return isRunProhibited;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setStackingViolation(boolean isStackingViolation) {
<b class="nc">&nbsp;        this.isStackingViolation = isStackingViolation;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    boolean isStackingViolation() {
<b class="nc">&nbsp;        return isStackingViolation;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This function checks that a step is legal. And adjust the movement type.
&nbsp;     * This only checks for things that can make this step by itself illegal.
&nbsp;     * Things that can make a step illegal as part of a movement path are
&nbsp;     * considered in MovePath.addStep.
&nbsp;     *
&nbsp;     * @param game
&nbsp;     * @param entity
&nbsp;     * @param prev
&nbsp;     */
&nbsp;    private void compileIllegal(final IGame game, final Entity entity,
&nbsp;            final MoveStep prev, CachedEntityState cachedEntityState) {
<b class="nc">&nbsp;        final MoveStepType stepType = getType();</b>
<b class="nc">&nbsp;        final boolean isInfantry = entity instanceof Infantry;</b>
&nbsp;
<b class="nc">&nbsp;        Coords curPos = getPosition();</b>
<b class="nc">&nbsp;        Coords lastPos = prev.getPosition();</b>
<b class="nc">&nbsp;        boolean isUnjammingRAC = entity.isUnjammingRAC();</b>
<b class="nc">&nbsp;        prevStepOnPavement = prev.isPavementStep();</b>
<b class="nc">&nbsp;        isTurning = prev.isTurning();</b>
<b class="nc">&nbsp;        isUnloaded = prev.isUnloaded();</b>
&nbsp;
&nbsp;        // Infantry get a first step if all they&#39;ve done is spin on the spot.
<b class="nc">&nbsp;        if (isInfantry &amp;&amp; ((getMpUsed() - getMp()) == 0)) {</b>
<b class="nc">&nbsp;            setFirstStep(true);</b>
&nbsp;
&nbsp;            // getMpUsed() is the MPs used in the whole MovePath
&nbsp;            // getMp() is the MPs used in the last (illegal) step (this step)
&nbsp;            // if the difference between the whole path and this step is 0
&nbsp;            // then this must be their first step
&nbsp;        }
&nbsp;
&nbsp;        // guilty until proven innocent
<b class="nc">&nbsp;        movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;
&nbsp;        // Crushing buildings creates rubble, and Dropships can&#39;t drive on
&nbsp;        // rubble, so they get stuck
<b class="nc">&nbsp;        if ((entity instanceof Dropship)</b>
<b class="nc">&nbsp;                &amp;&amp; !prev.getCrushedBuildingLocs().isEmpty()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // AERO STUFF
&nbsp;        // I am going to put in a whole seperate section for Aeros and just
&nbsp;        // return from it
&nbsp;        // only if Aeros are airborne, otherwise they should move like other
&nbsp;        // units
<b class="nc">&nbsp;        if (type == MoveStepType.HOVER &amp;&amp; entity instanceof LandAirMech</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getAltitude() &lt;= 3) {</b>
<b class="nc">&nbsp;            if (mpUsed &lt;= cachedEntityState.getWalkMP()) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_VTOL_WALK;</b>
<b class="nc">&nbsp;            } else if (mpUsed &lt;= cachedEntityState.getRunMP()) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_VTOL_RUN;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if ((prev.getAltitude() &gt; 0) || game.getBoard().inSpace()) {</b>
&nbsp;            //Ejected crew/pilots just drift or parachute, resulting in a move_none type
<b class="nc">&nbsp;            if (entity instanceof EjectedCrew) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_NONE;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // If airborne and some other non-Aero unit then everything is illegal, except
&nbsp;            // turns and AirMech 
<b class="nc">&nbsp;            if (!entity.isAero()) {</b>
<b class="nc">&nbsp;                switch (type) {</b>
&nbsp;                    case TURN_LEFT:
&nbsp;                    case TURN_RIGHT:
<b class="nc">&nbsp;                        movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;                    case CONVERT_MODE:
<b class="nc">&nbsp;                        movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;                    default:
&nbsp;                        break;
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int tmpSafeTh = cachedEntityState.getWalkMP();</b>
<b class="nc">&nbsp;            IAero a = (IAero) entity;</b>
&nbsp;
&nbsp;            // if the vessel is &quot;immobile&quot; due to shutdown or pilot black out
&nbsp;            // then all moves are illegal
<b class="nc">&nbsp;            if (entity.isImmobile()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // can&#39;t let players do an illegal move and use that to go less than
&nbsp;            // velocity
<b class="nc">&nbsp;            if (!isFirstStep()</b>
<b class="nc">&nbsp;                    &amp;&amp; (prev.getMovementType(false) == EntityMovementType.MOVE_ILLEGAL)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // check the fuel requirements
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_FUEL_CONSUMPTION)) {</b>
<b class="nc">&nbsp;                int fuelUsed = mpUsed + Math.max(mpUsed - cachedEntityState.getWalkMP(), 0);</b>
<b class="nc">&nbsp;                if (fuelUsed &gt; a.getFuel()) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // **Space turning limits**//
<b class="nc">&nbsp;            if (game.getBoard().inSpace()) {</b>
&nbsp;                // space stations can only turn and launch space craft
<b class="nc">&nbsp;                if ((entity instanceof SpaceStation)</b>
&nbsp;                        &amp;&amp; !((type == MoveStepType.TURN_LEFT)
&nbsp;                                || (type == MoveStepType.TURN_RIGHT)
&nbsp;                                || (type == MoveStepType.LAUNCH)
&nbsp;                                || (type == MoveStepType.UNDOCK))) {
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
&nbsp;                // unless velocity is zero ASFs must move forward one hex before
&nbsp;                // making turns in space
<b class="nc">&nbsp;                if (!game.useVectorMove()</b>
&nbsp;                        &amp;&amp; (distance == 0)
&nbsp;                        &amp;&amp; (velocity != 0)
&nbsp;                        &amp;&amp; ((type == MoveStepType.TURN_LEFT) || (type == MoveStepType.TURN_RIGHT))) {
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
&nbsp;                // no more than two turns in one hex unless velocity is zero for
&nbsp;                // anything except ASF in space
<b class="nc">&nbsp;                if (!game.useVectorMove() &amp;&amp; (a instanceof SmallCraft)</b>
<b class="nc">&nbsp;                        &amp;&amp; (velocity != 0) &amp;&amp; (getNTurns() &gt; 2)) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;
&nbsp;                // for warships the limit is one
<b class="nc">&nbsp;                if (!game.useVectorMove() &amp;&amp; (a instanceof Jumpship)</b>
<b class="nc">&nbsp;                        &amp;&amp; (velocity != 0) &amp;&amp; (getNTurns() &gt; 1)) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // atmosphere has its own rules about turning
<b class="nc">&nbsp;            if (useAeroAtmosphere(game, entity)</b>
&nbsp;                    &amp;&amp; ((type == MoveStepType.TURN_LEFT) || (type == MoveStepType.TURN_RIGHT))
<b class="nc">&nbsp;                    &amp;&amp; !prev.canAeroTurn(game)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // spheroids in atmosphere can move a max of 1 hex on the low atmo map
&nbsp;            // and 8 hexes on the ground map, regardless of any other considerations
&nbsp;            // unless they&#39;re out of control, in which case, well...
<b class="nc">&nbsp;            if(useSpheroidAtmosphere(game, entity) &amp;&amp; </b>
<b class="nc">&nbsp;            		(((IAero) entity).isOutControlTotal() ||</b>
<b class="nc">&nbsp;                    (!game.getBoard().onGround() &amp;&amp; (this.getDistance() &gt; 1) || </b>
<b class="nc">&nbsp;                            (game.getBoard().onGround() &amp;&amp; (getDistance() &gt; 8))))) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((type == MoveStepType.FORWARDS)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getBoard().inAtmosphere() &amp;&amp; !a.isOutControl()) {</b>
<b class="nc">&nbsp;                IHex desth = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;                if (altitude &lt;= desth.ceiling(true)) {</b>
<b class="nc">&nbsp;                    return; // can&#39;t fly into a cliff face or woods (unless out</b>
&nbsp;                    // of control)
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /*
&nbsp;             * TODO: better to disable this in movement display //don&#39;t let them
&nbsp;             * evade more than once if(type == MoveStepType.EVADE ) {
&nbsp;             * if(isEvading) { return; } else { setEvading(true); } }
&nbsp;             */
&nbsp;
&nbsp;            // check for thruster damage
<b class="nc">&nbsp;            if ((type == MoveStepType.TURN_LEFT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (a.getRightThrustHits() &gt; 2)</b>
<b class="nc">&nbsp;                    &amp;&amp; !useSpheroidAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((type == MoveStepType.TURN_RIGHT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (a.getLeftThrustHits() &gt; 2)</b>
<b class="nc">&nbsp;                    &amp;&amp; !useSpheroidAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // no moves after launching fighters, unless we were undocking
<b class="nc">&nbsp;            if (!isFirstStep() &amp;&amp; (prev.getType() == MoveStepType.LAUNCH) &amp;&amp;</b>
<b class="nc">&nbsp;                    (getType() != MoveStepType.UNDOCK)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // no moves after launching dropships, unless we are launching
<b class="nc">&nbsp;            if (!isFirstStep() &amp;&amp; (prev.getType() == MoveStepType.UNDOCK) &amp;&amp;</b>
<b class="nc">&nbsp;                    (getType() != MoveStepType.LAUNCH)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // no moves after being recovered
<b class="nc">&nbsp;            if (!isFirstStep() &amp;&amp; (prev.getType() == MoveStepType.RECOVER)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // no moves after joining
<b class="nc">&nbsp;            if (!isFirstStep() &amp;&amp; (prev.getType() == MoveStepType.JOIN)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // no moves after landing
<b class="nc">&nbsp;            if (!isFirstStep()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((prev.getType() == MoveStepType.LAND) || (prev</b>
<b class="nc">&nbsp;                    .getType() == MoveStepType.VLAND))) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // can only use safe thrust when ammo (or bomb) dumping
&nbsp;            // (unless out of control?)
<b class="nc">&nbsp;            boolean bDumping = false;// a.isDumpingBombs();</b>
<b class="nc">&nbsp;            for (Mounted mo : entity.getAmmo()) {</b>
<b class="nc">&nbsp;                if (mo.isDumping()) {</b>
<b class="nc">&nbsp;                    bDumping = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (bDumping &amp;&amp; (getMpUsed() &gt; tmpSafeTh) &amp;&amp; !a.isRandomMove()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
&nbsp;            // check to make sure there is velocity left to spend
<b class="nc">&nbsp;            if ((getVelocityLeft() &gt;= 0) || useSpheroidAtmosphere(game, entity)) {</b>
&nbsp;                // when aeros are flying on the ground mapsheet we need an
&nbsp;                // additional check
&nbsp;                // because velocityLeft is only decremented at intervals of 16
&nbsp;                // hexes
<b class="nc">&nbsp;                if (useAeroAtmosphere(game, entity)</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getBoard().onGround()</b>
<b class="nc">&nbsp;                        &amp;&amp; (getVelocityLeft() == 0) &amp;&amp; (getNMoved() &gt; 0)) {</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (getMpUsed() &lt;= tmpSafeTh) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_SAFE_THRUST;</b>
<b class="nc">&nbsp;                } else if (getMpUsed() &lt;= cachedEntityState.getRunMPwithoutMASC()) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_OVER_THRUST;</b>
<b class="nc">&nbsp;                } else if (a.isRandomMove()) {</b>
&nbsp;                    // if random move then allow it to be over thrust allowance
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_OVER_THRUST;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return;</b>
&nbsp;        } // end AERO stuff
&nbsp;
<b class="nc">&nbsp;        if (prev.isDiggingIn) {</b>
<b class="nc">&nbsp;            isDiggingIn = true;</b>
<b class="nc">&nbsp;            if ((type != MoveStepType.TURN_LEFT)</b>
&nbsp;                    &amp;&amp; (type != MoveStepType.TURN_RIGHT)) {
<b class="nc">&nbsp;                return; // can&#39;t move when digging in</b>
&nbsp;            }
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
<b class="nc">&nbsp;        } else if ((type == MoveStepType.DIG_IN)</b>
&nbsp;                || (type == MoveStepType.FORTIFY)) {
<b class="nc">&nbsp;            if (!isInfantry || !isFirstStep()) {</b>
<b class="nc">&nbsp;                return; // can&#39;t dig in</b>
&nbsp;            }
<b class="nc">&nbsp;            Infantry inf = (Infantry) entity;</b>
<b class="nc">&nbsp;            if ((inf.getDugIn() != Infantry.DUG_IN_NONE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (inf.getDugIn() != Infantry.DUG_IN_COMPLETE)) {</b>
<b class="nc">&nbsp;                return; // already dug in</b>
&nbsp;            }
<b class="nc">&nbsp;            if (game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                    .containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                    || game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                    .containsTerrain(Terrains.FORTIFIED)</b>
<b class="nc">&nbsp;                    || game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                    .containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                    || game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                    .containsTerrain(Terrains.ROAD)) {</b>
&nbsp;                // already fortified - pointless, or terrain is illegal for
&nbsp;                // digging in
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            isDiggingIn = true;</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Taking cover should happen as the last action
<b class="nc">&nbsp;        if (prev.isTakingCover) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (type == MoveStepType.TAKE_COVER) {</b>
&nbsp;            // Only Infantry can take cover
<b class="nc">&nbsp;            if (!isInfantry) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // If there&#39;s no valid cover, it&#39;s illegal
<b class="nc">&nbsp;            if (!Infantry.hasValidCover(game, getPosition(), getElevation())) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            isTakingCover = true;</b>
<b class="nc">&nbsp;            movementType = prev.getMovementType(false);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // WIGEs can take off on their first step...
<b class="nc">&nbsp;        if ((type == MoveStepType.UP) &amp;&amp; (entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (prev.getClearance() == 0)) {</b>
<b class="nc">&nbsp;            if (firstStep &amp;&amp; (cachedEntityState.getRunMP() &gt;= mp)) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_VTOL_WALK;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // WIGEs need to be able to land too, or even descend
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.WIGE</b>
&nbsp;                &amp;&amp; type == MoveStepType.DOWN
<b class="nc">&nbsp;                &amp;&amp; getClearance() &lt; prev.getClearance()) { // landing</b>
<b class="nc">&nbsp;            if (prev.getMovementType(false) == EntityMovementType.MOVE_VTOL_RUN</b>
<b class="nc">&nbsp;                    || prev.getMovementType(false) == EntityMovementType.MOVE_VTOL_SPRINT) {</b>
<b class="nc">&nbsp;                movementType = prev.getMovementType(false);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_VTOL_WALK;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check to see if it&#39;s trying to flee and can legally do so.
<b class="nc">&nbsp;        if ((type == MoveStepType.FLEE) &amp;&amp; entity.canFlee()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_LEGAL;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((type == MoveStepType.CLIMB_MODE_ON)</b>
&nbsp;                || (type == MoveStepType.CLIMB_MODE_OFF)) {
<b class="nc">&nbsp;            movementType = prev.movementType;</b>
&nbsp;        }
&nbsp;        // check for ejection (always legal?)
<b class="nc">&nbsp;        if (type == MoveStepType.EJECT) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.SEARCHLIGHT) {</b>
<b class="nc">&nbsp;            movementType = prev.movementType;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.UNJAM_RAC) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
&nbsp;        // infantry are allowed to clear mines
<b class="nc">&nbsp;        if ((type == MoveStepType.CLEAR_MINEFIELD)</b>
&nbsp;                &amp;&amp; (entity instanceof Infantry)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
&nbsp;        // check for evasion
<b class="nc">&nbsp;        if (type == MoveStepType.EVADE) {</b>
<b class="nc">&nbsp;            if (entity.hasHipCrit()</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() == EntityMovementMode.WIGE</b>
&nbsp;                            &amp;&amp; (entity instanceof LandAirMech || entity instanceof Protomech)
<b class="nc">&nbsp;                            &amp;&amp; getClearance() &gt; 0)) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }                
&nbsp;            // evading means running
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_RUN;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.SHUTDOWN) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.STARTUP) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.SELF_DESTRUCT) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.CONVERT_MODE) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for valid jump mp
<b class="nc">&nbsp;        if (isJumping()</b>
<b class="nc">&nbsp;                &amp;&amp; (getMpUsed() &lt;= entity.getJumpMPWithTerrain())</b>
<b class="nc">&nbsp;                &amp;&amp; !isProne()</b>
<b class="nc">&nbsp;                &amp;&amp; !isHullDown()</b>
&nbsp;                &amp;&amp; !((entity instanceof Protomech) &amp;&amp; (entity
<b class="nc">&nbsp;                .getInternal(Protomech.LOC_LEG) == IArmorState.ARMOR_DESTROYED))</b>
<b class="nc">&nbsp;                &amp;&amp; (!entity.isStuck() || entity.canUnstickByJumping())) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_JUMP;</b>
&nbsp;        }
&nbsp;
&nbsp;        // legged Protos may make one facing change
<b class="nc">&nbsp;        if (isFirstStep()</b>
&nbsp;                &amp;&amp; (entity instanceof Protomech)
<b class="nc">&nbsp;                &amp;&amp; (entity.getInternal(Protomech.LOC_LEG) == IArmorState.ARMOR_DESTROYED)</b>
&nbsp;                &amp;&amp; ((stepType == MoveStepType.TURN_LEFT) || (stepType == MoveStepType.TURN_RIGHT))
<b class="nc">&nbsp;                &amp;&amp; !entity.isStuck()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;        }
&nbsp;        // Infantry that is first stepping and turning is legal
<b class="nc">&nbsp;        if (isInfantry</b>
&nbsp;                &amp;&amp; ((stepType == MoveStepType.TURN_LEFT) || (stepType == MoveStepType.TURN_RIGHT))
<b class="nc">&nbsp;                &amp;&amp; isFirstStep()) {</b>
<b class="nc">&nbsp;            if (isJumping()) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_JUMP;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int bonus = wigeBonus;</b>
<b class="nc">&nbsp;        entity.wigeBonus = wigeBonus;</b>
<b class="nc">&nbsp;        if (entity.isEligibleForPavementBonus()</b>
<b class="nc">&nbsp;                &amp;&amp; isOnlyPavement()) {</b>
<b class="nc">&nbsp;            bonus++;</b>
<b class="nc">&nbsp;            entity.gotPavementBonus = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        int tmpWalkMP = cachedEntityState.getWalkMP() + bonus;</b>
<b class="nc">&nbsp;        int runMP = cachedEntityState.getRunMP() + bonus;</b>
<b class="nc">&nbsp;        int runMPnoMASC = cachedEntityState.getRunMPwithoutMASC() + bonus;</b>
<b class="nc">&nbsp;        int sprintMP = cachedEntityState.getSprintMP() + bonus;</b>
<b class="nc">&nbsp;        int sprintMPnoMASC = cachedEntityState.getSprintMPwithoutMASC() + bonus;</b>
<b class="nc">&nbsp;        final boolean isMASCUsed = entity.isMASCUsed();</b>
<b class="nc">&nbsp;        final boolean hasPoorPerformance = entity</b>
<b class="nc">&nbsp;                .hasQuirk(OptionsConstants.QUIRK_NEG_POOR_PERFORMANCE);</b>
&nbsp;
&nbsp;        // WiGEs, AirMechs, and glider ProtoMechs have different MP for ground and airborne movement
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;            if (getClearance() &lt;= 0 &amp;&amp; type != MoveStepType.UP) {</b>
<b class="nc">&nbsp;                if (entity instanceof LandAirMech) {</b>
&nbsp;                    // On the ground or underwater use AirMech walk/run.
&nbsp;                    // Sprint can only be used on the ground, so that is already set.
<b class="nc">&nbsp;                    tmpWalkMP = ((LandAirMech)entity).getAirMechWalkMP();</b>
<b class="nc">&nbsp;                    runMPnoMASC = ((LandAirMech)entity).getAirMechRunMP();</b>
&nbsp;                    // LAMs cannot use hardened armor, which makes runMP a simpler calculation.
<b class="nc">&nbsp;                    runMP = ((LandAirMech)entity).hasArmedMASC()? tmpWalkMP * 2 : runMPnoMASC;</b>
&nbsp;                } else {
&nbsp;                    // Only 1 ground MP for ground effect vehicles and glider protomechs
<b class="nc">&nbsp;                    tmpWalkMP = runMP = runMPnoMASC = sprintMP = sprintMPnoMASC = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity instanceof LandAirMech) {</b>
&nbsp;                // LAMs cannot use overdrive and MASC does not effect airborne MP.
<b class="nc">&nbsp;                tmpWalkMP = ((LandAirMech)entity).getAirMechCruiseMP();</b>
<b class="nc">&nbsp;                runMP = runMPnoMASC = sprintMP = sprintMPnoMASC = ((LandAirMech)entity).getAirMechFlankMP();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IHex currHex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;        IHex lastHex = game.getBoard().getHex(lastPos);</b>
&nbsp;        
&nbsp;        // Bootlegger ends movement
<b class="nc">&nbsp;        if (prev.type == MoveStepType.BOOTLEGGER) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (stepType == MoveStepType.CONVERT_MODE) {</b>
&nbsp;            //QuadVees and LAMs cannot convert in water, and Mech tracks cannot be used in water.
<b class="nc">&nbsp;            if (currHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; getClearance() &lt; 0) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;            //QuadVees and LAMs cannot convert while prone. Mechs with tracks don&#39;t actually convert,
&nbsp;            //and can switch to track mode while prone then stand.
<b class="nc">&nbsp;            if (getEntity().isProne()</b>
<b class="nc">&nbsp;                    &amp;&amp; (getEntity() instanceof QuadVee || getEntity() instanceof LandAirMech)) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;            // Illegal LAM conversions due to damage have to be determined by entire path, because
&nbsp;            // some conversions take two convert steps and can be legal even though the first one
&nbsp;            // is illegal on its own.
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;            if (!getEntity().isBomber() || getClearance() &lt;= 0) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;            } else if (isFirstStep()) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                movementType = prev.getMovementType(false);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if ((getEntity().getMovementMode() == EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                &amp;&amp; (currHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                &amp;&amp; lastHex.containsTerrain(Terrains.WATER) &amp;&amp; (entity</b>
<b class="nc">&nbsp;                .relHeight() &lt; currHex.surface()))) {</b>
<b class="nc">&nbsp;            tmpWalkMP = entity.getActiveUMUCount();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((getEntity().getMovementMode() == EntityMovementMode.BIPED_SWIM)</b>
<b class="nc">&nbsp;                || (getEntity().getMovementMode() == EntityMovementMode.QUAD_SWIM)</b>
<b class="nc">&nbsp;                || ((getEntity() instanceof Infantry</b>
<b class="nc">&nbsp;                        &amp;&amp; getEntity().getMovementMode() == EntityMovementMode.SUBMARINE))) {</b>
<b class="nc">&nbsp;            tmpWalkMP = entity.getActiveUMUCount();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((getEntity().getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                &amp;&amp; getClearance() &gt; 0</b>
<b class="nc">&nbsp;                &amp;&amp; !(getEntity() instanceof VTOL)) {</b>
<b class="nc">&nbsp;            tmpWalkMP = entity.getJumpMP();</b>
&nbsp;        }
&nbsp;        // check for valid walk/run mp
<b class="nc">&nbsp;        if (!isJumping() &amp;&amp; !entity.isStuck() &amp;&amp; (tmpWalkMP &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; (getMp() &gt; 0)) {</b>
&nbsp;            // Prone mechs can only spend MP to turn or get up
<b class="nc">&nbsp;            if ((stepType != MoveStepType.TURN_LEFT)</b>
&nbsp;                    &amp;&amp; (stepType != MoveStepType.TURN_RIGHT)
&nbsp;                    &amp;&amp; (stepType != MoveStepType.GET_UP)
&nbsp;                    &amp;&amp; (stepType != MoveStepType.LOAD)
&nbsp;                    &amp;&amp; (stepType != MoveStepType.CAREFUL_STAND)
&nbsp;                    &amp;&amp; (stepType != MoveStepType.HULL_DOWN)
&nbsp;                    &amp;&amp; (stepType != MoveStepType.GO_PRONE)
&nbsp;                    &amp;&amp; !(entity instanceof Tank) // Tanks can drive out of
&nbsp;                    // hull-down
<b class="nc">&nbsp;                    &amp;&amp; (isProne() || isHullDown())) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // WiGEs that land are finished with movement
<b class="nc">&nbsp;            if (entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                    &amp;&amp; prev.getType() == MoveStepType.DOWN</b>
<b class="nc">&nbsp;                    &amp;&amp; getClearance() == 0) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (getMpUsed() &lt;= tmpWalkMP) {</b>
<b class="nc">&nbsp;                if ((getEntity().getMovementMode() == EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                        || getEntity().getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                        &amp;&amp; getClearance() &gt; 0) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_WALK;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;                    // Vehicles moving along pavement get &quot;road bonus&quot; of 1 MP.
&nbsp;                    // N.B. The Ask Precentor Martial forum said that a 4/6
&nbsp;                    // tank on a road can move 5/7, **not** 5/8.
&nbsp;                }
<b class="nc">&nbsp;            } else if ((entity instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; (curPos.distance(entity.getPosition()) == 1)</b>
<b class="nc">&nbsp;                    &amp;&amp; (lastPos.equals(entity.getPosition()))) {</b>
&nbsp;                // This ensures that Infantry always get their minimum 1 hex
&nbsp;                //  movement when TO fast infantry movement is on.
&nbsp;                // A movepath that consists of a single step from one hex to the
&nbsp;                // next should always be a walk, since it&#39;s covered under the
&nbsp;                // infantry&#39;s 1 free movement
<b class="nc">&nbsp;                if ((getEntity().getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                        &amp;&amp; getClearance() &gt; 0) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_WALK;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((((getMpUsed() &lt;= runMP) &amp;&amp; isMASCUsed)</b>
<b class="nc">&nbsp;                    || (getMpUsed() &lt;= runMPnoMASC)) &amp;&amp; !isRunProhibited()) {</b>
&nbsp;                // Poor performance requires spending all walk MP in the
&nbsp;                //  previous round in order to flank
<b class="nc">&nbsp;                if (hasPoorPerformance</b>
<b class="nc">&nbsp;                        &amp;&amp; (entity.getMpUsedLastRound() &lt; cachedEntityState.getWalkMP())) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((entity.getMovementMode() == EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                        || entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                        &amp;&amp; getClearance() &gt; 0) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_RUN;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_RUN;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((getMpUsed() &lt;= runMP) &amp;&amp; !isRunProhibited()</b>
<b class="nc">&nbsp;                    &amp;&amp; !isEvading()) {</b>
<b class="nc">&nbsp;                setUsingMASC(true);</b>
<b class="nc">&nbsp;                setTargetNumberMASC(entity.getMASCTarget());</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_RUN;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_RUN;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (canUseSprint(game)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((getMpUsed() &lt;= sprintMPnoMASC)</b>
<b class="nc">&nbsp;                            || ((getMpUsed() &lt;= sprintMP) &amp;&amp; isMASCUsed))</b>
<b class="nc">&nbsp;                    &amp;&amp; !isRunProhibited() &amp;&amp; !isEvading()) {</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                                &amp;&amp; getClearance() &gt; 0)) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_SPRINT;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_SPRINT;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((getMpUsed() &lt;= sprintMP)</b>
<b class="nc">&nbsp;                    &amp;&amp; !isRunProhibited() &amp;&amp; !isEvading()</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_SPRINT)) {</b>
<b class="nc">&nbsp;                setUsingMASC(true);</b>
<b class="nc">&nbsp;                setTargetNumberMASC(entity.getMASCTarget());</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_SPRINT;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_SPRINT;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // If using vehicle acceleration restrictions, it is impossible to go from a stop to overdrive.
&nbsp;        // Stop to flank or cruise to overdrive is permitted with a driving check (&quot;gunning it&quot;).
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ACCELERATION)</b>
&nbsp;                &amp;&amp; movementType == EntityMovementType.MOVE_SPRINT
&nbsp;                &amp;&amp; (entity instanceof Tank
<b class="nc">&nbsp;                        || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</b>
&nbsp;                &amp;&amp; (entity.movedLastRound == EntityMovementType.MOVE_NONE
&nbsp;                    || entity.movedLastRound == EntityMovementType.MOVE_SKID
&nbsp;                    || entity.movedLastRound == EntityMovementType.MOVE_JUMP)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;        // 0 MP infantry units can move 1 hex
<b class="nc">&nbsp;        if (isInfantry</b>
<b class="nc">&nbsp;                &amp;&amp; (cachedEntityState.getWalkMP() == 0)</b>
<b class="nc">&nbsp;                &amp;&amp; getEntity().getPosition().equals(prev.getPosition())</b>
<b class="nc">&nbsp;                &amp;&amp; (prev.getElevation() == entity.getElevation())</b>
<b class="nc">&nbsp;                &amp;&amp; (getEntity().getPosition().distance(getPosition()) &lt;= 1)</b>
<b class="nc">&nbsp;                &amp;&amp; (Math.abs(entity.getElevation() - getElevation()) </b>
<b class="nc">&nbsp;                        &lt;= entity.getMaxElevationChange())</b>
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Free facing changes are legal
<b class="nc">&nbsp;        if (((stepType == MoveStepType.TURN_LEFT) || (stepType == MoveStepType.TURN_RIGHT))</b>
<b class="nc">&nbsp;                &amp;&amp; (getMp() == 0)) {</b>
<b class="nc">&nbsp;            movementType = prev.movementType;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mechanical Jump Boosters don&#39;t allow facing changes
<b class="nc">&nbsp;        if (isJumping()</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getJumpType() == Mech.JUMP_BOOSTER)</b>
&nbsp;                &amp;&amp; ((stepType == MoveStepType.TURN_LEFT) || (stepType == MoveStepType.TURN_RIGHT))) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // going prone from hull down is legal and costs 0
<b class="nc">&nbsp;        if ((getMp() == 0) &amp;&amp; (stepType == MoveStepType.GO_PRONE)</b>
<b class="nc">&nbsp;                &amp;&amp; isHullDown()) {</b>
<b class="nc">&nbsp;            movementType = prev.movementType;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((movementType == EntityMovementType.MOVE_WALK)</b>
&nbsp;                &amp;&amp; (prev.movementType == EntityMovementType.MOVE_RUN)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_RUN;</b>
<b class="nc">&nbsp;        } else if ((movementType == EntityMovementType.MOVE_VTOL_WALK)</b>
&nbsp;                &amp;&amp; (prev.movementType == EntityMovementType.MOVE_VTOL_RUN)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_VTOL_RUN;</b>
<b class="nc">&nbsp;        } else if (((movementType == EntityMovementType.MOVE_WALK) || (movementType == EntityMovementType.MOVE_RUN))</b>
&nbsp;                &amp;&amp; (prev.movementType == EntityMovementType.MOVE_SPRINT)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_SPRINT;</b>
<b class="nc">&nbsp;        } else if (((movementType == EntityMovementType.MOVE_VTOL_WALK)</b>
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_RUN))
&nbsp;                &amp;&amp; (prev.movementType == EntityMovementType.MOVE_VTOL_SPRINT)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_VTOL_SPRINT;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (entity.isGyroDestroyed() &amp;&amp; !((entity instanceof LandAirMech)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getConversionMode() == LandAirMech.CONV_MODE_FIGHTER))) {</b>
&nbsp;            //A prone &#39;Mech with a destroyed gyro can only change a single hex side, or eject
<b class="nc">&nbsp;            if (entity.isProne()) {</b>
<b class="nc">&nbsp;                if (((stepType != MoveStepType.TURN_LEFT &amp;&amp; stepType != MoveStepType.TURN_RIGHT)</b>
<b class="nc">&nbsp;                        || getMpUsed() &gt; 1) &amp;&amp; stepType != MoveStepType.EJECT) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                //Normally a &#39;Mech falls immediately when the gyro is destroyed and can&#39;t stand again.
&nbsp;                //QuadVees using vehicle mode and &#39;Mechs using tracks do not fall and can continue to
&nbsp;                //stand, but cannot use non-tracked/wheeled MP except for a QuadVee converting back to
&nbsp;                //vehicle mode. This also covers a &#39;Mech that started with a destroyed gyro but was not
&nbsp;                //set to deploy prone. Perhaps that should not be allowed.
<b class="nc">&nbsp;                if (getMp() &gt; 0) {</b>
<b class="nc">&nbsp;                    boolean isTracked = entity.getMovementMode() == EntityMovementMode.TRACKED</b>
<b class="nc">&nbsp;                            || entity.getMovementMode() == EntityMovementMode.WHEELED;</b>
<b class="nc">&nbsp;                    if (entity instanceof QuadVee) {</b>
&nbsp;                        //We are in &#39;Mech/non-tracked mode if the end mode is vee and we are converting
&nbsp;                        //of the end mode is &#39;Mech and we are not converting.
<b class="nc">&nbsp;                        if (isTracked == entity.isConvertingNow() &amp;&amp; stepType != MoveStepType.CONVERT_MODE) {</b>
<b class="nc">&nbsp;                            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (!isTracked) {</b>
&nbsp;                        //Non QuadVee tracked &#39;Mechs don&#39;t actually convert. They just go, so we only need to
&nbsp;                        //know the end mode.
<b class="nc">&nbsp;                        movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }                
&nbsp;
&nbsp;        // Mechs with no arms and a missing leg cannot attempt to stand
<b class="nc">&nbsp;        if (((stepType == MoveStepType.GET_UP) ||</b>
&nbsp;                (stepType == MoveStepType.CAREFUL_STAND)) &amp;&amp;
&nbsp;                (entity instanceof Mech) &amp;&amp;
<b class="nc">&nbsp;                entity.isLocationBad(Mech.LOC_LARM) &amp;&amp;</b>
<b class="nc">&nbsp;                entity.isLocationBad(Mech.LOC_RARM) &amp;&amp;</b>
<b class="nc">&nbsp;                (entity.isLocationBad(Mech.LOC_RLEG) ||</b>
<b class="nc">&nbsp;                        entity.isLocationBad(Mech.LOC_LLEG))) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mechs with 1 MP are allowed to get up, except
&nbsp;        // if they&#39;ve used that 1MP up already
<b class="nc">&nbsp;        if ((MoveStepType.GET_UP == stepType) &amp;&amp; (1 == cachedEntityState.getRunMP())</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.mpUsed &lt; 1) &amp;&amp; !entity.isStuck()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_RUN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((MoveStepType.CAREFUL_STAND == stepType) &amp;&amp; (entity.mpUsed &gt; 1)) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isFirstStep()</b>
&nbsp;                &amp;&amp; ((stepType == MoveStepType.TAKEOFF) || (stepType == MoveStepType.VTAKEOFF))) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_SAFE_THRUST;</b>
&nbsp;        } else
&nbsp;
&nbsp;            // VTOLs with a damaged flight stabiliser can&#39;t flank
<b class="nc">&nbsp;            if ((entity instanceof VTOL)</b>
&nbsp;                    &amp;&amp; (movementType == EntityMovementType.MOVE_VTOL_RUN
&nbsp;                        || movementType == EntityMovementType.MOVE_VTOL_SPRINT)
<b class="nc">&nbsp;                    &amp;&amp; ((VTOL) entity).isStabiliserHit(VTOL.LOC_ROTOR)) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;
&nbsp;        // check for UMU infantry on land
<b class="nc">&nbsp;        if ((entity.getMovementMode() == EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                &amp;&amp; !game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                .containsTerrain(Terrains.WATER)</b>
&nbsp;                &amp;&amp; (movementType == EntityMovementType.MOVE_RUN)) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // amnesty for the first step
<b class="nc">&nbsp;        if (isFirstStep() &amp;&amp; (movementType == EntityMovementType.MOVE_ILLEGAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (cachedEntityState.getWalkMP() &gt; 0) &amp;&amp; !entity.isProne()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isHullDown() &amp;&amp; !entity.isStuck()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isGyroDestroyed() &amp;&amp; (stepType == MoveStepType.FORWARDS)) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_RUN;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Bimodal LAMs cannot spend MP when converting to fighter mode on the ground.
<b class="nc">&nbsp;        if (entity instanceof LandAirMech</b>
<b class="nc">&nbsp;                &amp;&amp; ((LandAirMech)entity).getLAMType() == LandAirMech.LAM_BIMODAL</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getConversionMode() == LandAirMech.CONV_MODE_MECH</b>
&nbsp;                &amp;&amp; movementMode == EntityMovementMode.AERODYNE
&nbsp;                &amp;&amp; altitude == 0
&nbsp;                &amp;&amp; mp &gt; 0) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the entity unloading passengers?
<b class="nc">&nbsp;        if (stepType == MoveStepType.UNLOAD) {</b>
&nbsp;
<b class="nc">&nbsp;            if (entity instanceof Aero) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_NONE;</b>
&nbsp;            } else {
&nbsp;
<b class="nc">&nbsp;                if (isFirstStep()) {</b>
<b class="nc">&nbsp;                    if (getMpUsed() &lt;= cachedEntityState.getRunMP()) {</b>
<b class="nc">&nbsp;                        movementType = EntityMovementType.MOVE_RUN;</b>
<b class="nc">&nbsp;                        if (getMpUsed() &lt;= cachedEntityState.getWalkMP()) {</b>
<b class="nc">&nbsp;                            movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = prev.getMovementType(false);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Prone Meks are able to unload, if they have the MP.
<b class="nc">&nbsp;                if ((getMpUsed() &lt;= cachedEntityState.getRunMP())</b>
<b class="nc">&nbsp;                        &amp;&amp; (entity.isProne() || entity.isHullDown())</b>
&nbsp;                        &amp;&amp; (movementType == EntityMovementType.MOVE_ILLEGAL)) {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_RUN;</b>
<b class="nc">&nbsp;                    if (getMpUsed() &lt;= cachedEntityState.getWalkMP()) {</b>
<b class="nc">&nbsp;                        movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Can&#39;t unload units into prohibited terrain
&nbsp;                // or into stacking violation.
<b class="nc">&nbsp;                Targetable target = getTarget(game);</b>
<b class="nc">&nbsp;                if (target instanceof Entity) {</b>
&nbsp;                    //Change the destination hex if an unload dialog box set it elsewhere
<b class="nc">&nbsp;                    if (getTargetPosition() != null) {</b>
<b class="nc">&nbsp;                        curPos = getTargetPosition();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Entity other = (Entity) target;</b>
<b class="nc">&nbsp;                    if ((null != Compute.stackingViolation(game, other, curPos,</b>
<b class="nc">&nbsp;                            entity)) || other.isLocationProhibited(curPos, getElevation())) {</b>
<b class="nc">&nbsp;                        movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Is the entity trying to drop a trailer?
<b class="nc">&nbsp;        if (stepType == MoveStepType.DISCONNECT) {</b>
&nbsp;            
&nbsp;            // If this isn&#39;t the first step, trailer position isn&#39;t updated by Server.processTrailerMovement()
&nbsp;            // before this step, so they don&#39;t drop off in the right place
<b class="nc">&nbsp;            if (!isFirstStep()) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Can&#39;t unload units into prohibited terrain
&nbsp;            // or into stacking violation.
<b class="nc">&nbsp;            Targetable target = getTarget(game);</b>
<b class="nc">&nbsp;            if (target instanceof Entity) {</b>
<b class="nc">&nbsp;                Entity other = (Entity) target;</b>
<b class="nc">&nbsp;                if ((null != Compute.stackingViolation(game, other, curPos,</b>
<b class="nc">&nbsp;                        entity)) || other.isLocationProhibited(curPos, getElevation())) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;        
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (stepType == MoveStepType.SHAKE_OFF_SWARMERS) {</b>
<b class="nc">&nbsp;            if ((getMp() == 0) || !(entity instanceof Tank)) {</b>
&nbsp;                // Can&#39;t shake off swarmers if you can&#39;t flank
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            } else {
&nbsp;                // And its always considered to be flank movement
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_VTOL_RUN;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_RUN;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t run or jump if unjamming a RAC.
<b class="nc">&nbsp;        if (isUnjammingRAC</b>
&nbsp;                &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
&nbsp;                || (movementType == EntityMovementType.MOVE_SPRINT)
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_RUN
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_SPRINT)) 
<b class="nc">&nbsp;                || isJumping())) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // only standing mechs may go prone
<b class="nc">&nbsp;        if ((stepType == MoveStepType.GO_PRONE)</b>
<b class="nc">&nbsp;                &amp;&amp; (isProne() || !(entity instanceof Mech) || entity.isStuck())) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Standing mechs and vehicles in fortified terrain can hull-down
<b class="nc">&nbsp;        if (stepType == MoveStepType.HULL_DOWN) {</b>
<b class="nc">&nbsp;            if ((isHullDown()</b>
&nbsp;                    || !((entity instanceof Mech) || (entity instanceof Tank)) || entity
<b class="nc">&nbsp;                    .isStuck())) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity instanceof Tank</b>
&nbsp;                    || (entity instanceof QuadVee
<b class="nc">&nbsp;                            &amp;&amp; ((entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)</b>
<b class="nc">&nbsp;                                    != entity.isConvertingNow()))) {</b>
&nbsp;                //Tanks and QuadVees ending movement in vehicle mode require a fortified hex.
<b class="nc">&nbsp;                if (!(game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                        .containsTerrain(Terrains.FORTIFIED))) {</b>
<b class="nc">&nbsp;                    movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity.isGyroDestroyed()) {</b>
&nbsp;                // Mechs need to check for valid Gyros
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // initially prone mechs can&#39;t charge
<b class="nc">&nbsp;        if (((stepType == MoveStepType.CHARGE) || (stepType == MoveStepType.DFA))</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isProne()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // do not allow to move onto a bridge if there&#39;s no exit in lastPos&#39;s
&nbsp;        // direction, unless jumping
<b class="nc">&nbsp;        if (!isFirstStep()</b>
<b class="nc">&nbsp;                &amp;&amp; !curPos.equals(lastPos)</b>
&nbsp;                &amp;&amp; climbMode
<b class="nc">&nbsp;                &amp;&amp; entity.getMovementMode() != EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                    || getClearance() == 0)</b>
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                .containsTerrain(Terrains.BRIDGE)</b>
<b class="nc">&nbsp;                &amp;&amp; !game.getBoard()</b>
<b class="nc">&nbsp;                .getHex(curPos)</b>
<b class="nc">&nbsp;                .containsTerrainExit(Terrains.BRIDGE,</b>
<b class="nc">&nbsp;                        curPos.direction(lastPos))</b>
<b class="nc">&nbsp;                &amp;&amp; (getElevation() + entity.getHeight()</b>
<b class="nc">&nbsp;                        &gt;= game.getBoard().getHex(curPos).terrainLevel(Terrains.BRIDGE_ELEV))) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // super heavy mechs can&#39;t climb on buildings
<b class="nc">&nbsp;        if ((entity instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; ((Mech) entity).isSuperHeavy()</b>
&nbsp;                &amp;&amp; climbMode
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().getHex(curPos)</b>
<b class="nc">&nbsp;                .containsTerrain(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // TO p.325 - Mine dispensers
<b class="nc">&nbsp;        if ((type == MoveStepType.LAY_MINE) &amp;&amp; !entity.canLayMine()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if ((type == MoveStepType.LAY_MINE) &amp;&amp; entity.canLayMine()) {</b>
&nbsp;            //All units may only lay mines on its first or last step.
&nbsp;            //BA additionally have to use Jump or VTOL movement.
<b class="nc">&nbsp;            movementType = prev.movementType;</b>
&nbsp;
<b class="nc">&nbsp;            if (entity instanceof BattleArmor &amp;&amp;</b>
<b class="nc">&nbsp;                    !(isFirstStep()</b>
&nbsp;                            || (prev.movementType == EntityMovementType.MOVE_JUMP)
&nbsp;                            || (prev.movementType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                            || (prev.movementType == EntityMovementType.MOVE_VTOL_WALK))) {
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (prev.type == MoveStepType.LAY_MINE &amp;&amp; !prev.isFirstStep()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        if (stepType == MoveStepType.MOUNT) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_WALK;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (stepType == MoveStepType.BOOTLEGGER) {</b>
&nbsp;            // Bootlegger requires three hexes straight and is illegal for tracked, WiGE, or naval.
<b class="nc">&nbsp;            if (prev.nStraight &lt; 3</b>
<b class="nc">&nbsp;                    || (entity.getMovementMode() != EntityMovementMode.WHEELED</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.getMovementMode() != EntityMovementMode.HOVER</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.getMovementMode() != EntityMovementMode.VTOL)) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                danger = true;</b>
&nbsp;            }            
&nbsp;        }
&nbsp;
&nbsp;        // check if this movement is illegal for reasons other than points
<b class="nc">&nbsp;        if (!isMovementPossible(game, lastPos, prev.getElevation(), cachedEntityState)</b>
&nbsp;                || isUnloaded) {
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the previous step is always illegal, then so is this one
<b class="nc">&nbsp;        if (EntityMovementType.MOVE_ILLEGAL == prev.movementType) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_ILLEGAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Don&#39;t compute danger if the step is illegal.
<b class="nc">&nbsp;        if (movementType == EntityMovementType.MOVE_ILLEGAL) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Danger is flagged for PSR checks by entire path when a new step is added, since turning
&nbsp;        // while running on pavement does cannot trigger the danger flag if the turn occurs before
&nbsp;        // enough MP are spent to require running.
&nbsp;
&nbsp;        // getting up is also danger
<b class="nc">&nbsp;        if (stepType == MoveStepType.GET_UP) {</b>
<b class="nc">&nbsp;            danger = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // set past danger
<b class="nc">&nbsp;        pastDanger |= danger;</b>
&nbsp;
&nbsp;        // Record if we&#39;re turning *after* check for danger,
&nbsp;        // because the danger lies in moving *after* turn.
<b class="nc">&nbsp;        switch (stepType) {</b>
&nbsp;            case TURN_LEFT:
&nbsp;            case TURN_RIGHT:
<b class="nc">&nbsp;                setTurning(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case UNLOAD:
&nbsp;            case DISCONNECT:
&nbsp;                // Unloading must be the last step.
<b class="nc">&nbsp;                setUnloaded(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                setTurning(false);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        // update prone state
<b class="nc">&nbsp;        if (stepType == MoveStepType.GO_PRONE) {</b>
<b class="nc">&nbsp;            setProne(true);</b>
<b class="nc">&nbsp;            setHullDown(false);</b>
<b class="nc">&nbsp;        } else if (stepType == MoveStepType.GET_UP) {</b>
<b class="nc">&nbsp;            setProne(false);</b>
<b class="nc">&nbsp;            setHullDown(false);</b>
<b class="nc">&nbsp;        } else if (stepType == MoveStepType.HULL_DOWN) {</b>
<b class="nc">&nbsp;            setProne(false);</b>
<b class="nc">&nbsp;            setHullDown(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.isCarefulStand()) {</b>
<b class="nc">&nbsp;            movementType = EntityMovementType.MOVE_CAREFUL_STAND;</b>
&nbsp;        }
&nbsp;
&nbsp;        // only walking speed in Tornados
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().getWindStrength() == PlanetaryConditions.WI_TORNADO_F4) {</b>
<b class="nc">&nbsp;            if (getMpUsed() &gt; tmpWalkMP) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Vehicles carrying mechanized BA can&#39;t jump, VTOL, or WiGE
<b class="nc">&nbsp;        if (entity instanceof Tank</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getExternalUnits().size() &gt; 0) {</b>
<b class="nc">&nbsp;            if ((movementType == EntityMovementType.MOVE_JUMP)</b>
&nbsp;                    || (movementType == EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                    || (movementType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                    || (movementType == EntityMovementType.MOVE_VTOL_SPRINT)
<b class="nc">&nbsp;                    || ((entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                        &amp;&amp; getClearance() &gt; 0)) {</b>
<b class="nc">&nbsp;                movementType = EntityMovementType.MOVE_ILLEGAL;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }            
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getTotalHeat() {
<b class="nc">&nbsp;        return totalHeat;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getHeat() {
<b class="nc">&nbsp;        return heat;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Amount of movement points required to move from start to dest
&nbsp;     */
&nbsp;    protected void calcMovementCostFor(IGame game, MoveStep prevStep, CachedEntityState cachedEntityState) {
<b class="nc">&nbsp;        final Coords prev = prevStep.getPosition();</b>
<b class="nc">&nbsp;        final int prevEl = prevStep.getElevation();</b>
<b class="nc">&nbsp;        final EntityMovementMode moveMode = getEntity()</b>
<b class="nc">&nbsp;                .getMovementMode();</b>
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(prev);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;        final boolean isInfantry = getEntity() instanceof Infantry;</b>
<b class="nc">&nbsp;        final boolean isSuperHeavyMech = (getEntity() instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; ((Mech) getEntity()).isSuperHeavy();</b>
<b class="nc">&nbsp;        final boolean isMechanizedInfantry = isInfantry</b>
<b class="nc">&nbsp;                &amp;&amp; ((Infantry) getEntity()).isMechanized();</b>
<b class="nc">&nbsp;        final boolean isProto = getEntity() instanceof Protomech;</b>
<b class="nc">&nbsp;        final boolean isMech = getEntity() instanceof Mech;</b>
<b class="nc">&nbsp;        final boolean isAmphibious = cachedEntityState.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS) || </b>
<b class="nc">&nbsp;                cachedEntityState.hasWorkingMisc(MiscType.F_LIMITED_AMPHIBIOUS);</b>
<b class="nc">&nbsp;        int nSrcEl = srcHex.getLevel() + prevEl;</b>
<b class="nc">&nbsp;        int nDestEl = destHex.getLevel() + elevation;</b>
&nbsp;
<b class="nc">&nbsp;        mp = 1;</b>
&nbsp;
&nbsp;
&nbsp;        // 0 MP infantry units can move 1 hex
<b class="nc">&nbsp;        if (isInfantry</b>
<b class="nc">&nbsp;                &amp;&amp; (cachedEntityState.getWalkMP() == 0)</b>
&nbsp;                &amp;&amp; (moveMode != EntityMovementMode.SUBMARINE)
<b class="nc">&nbsp;                &amp;&amp; getEntity().getPosition().equals(prev)</b>
<b class="nc">&nbsp;                &amp;&amp; (getEntity().getPosition().distance(getPosition()) == 1)</b>
<b class="nc">&nbsp;                &amp;&amp; (!isJumping())) {</b>
<b class="nc">&nbsp;            mp = 0;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        boolean applyNightPen =</b>
<b class="nc">&nbsp;                !game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_NO_NIGHT_MOVE_PEN);</b>
<b class="nc">&nbsp;        boolean carefulExempt =</b>
<b class="nc">&nbsp;                (moveMode == EntityMovementMode.VTOL) || isJumping();</b>
&nbsp;
&nbsp;        // Apply careful movement MP penalties for fog and light (TO pg 63)
<b class="nc">&nbsp;        if (!game.getBoard().inSpace() &amp;&amp; isCareful() &amp;&amp; applyNightPen</b>
&nbsp;                &amp;&amp; !carefulExempt) {
&nbsp;            // Fog
<b class="nc">&nbsp;            switch (game.getPlanetaryConditions().getFog()) {</b>
&nbsp;                case PlanetaryConditions.FOG_LIGHT:
<b class="nc">&nbsp;                    mp += 1;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PlanetaryConditions.FOG_HEAVY:
<b class="nc">&nbsp;                    mp += 2;</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;            // Light
<b class="nc">&nbsp;            switch (game.getPlanetaryConditions().getLight()){</b>
&nbsp;                case PlanetaryConditions.L_FULL_MOON:
<b class="nc">&nbsp;                    mp += 1;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case  PlanetaryConditions.L_MOONLESS:
<b class="nc">&nbsp;                    mp += 2;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case PlanetaryConditions.L_PITCH_BLACK:
<b class="nc">&nbsp;                    mp += 3;</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // VTOLs pay 1 for everything
<b class="nc">&nbsp;        if (moveMode == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // jumping always costs 1, unless fog or poor light
<b class="nc">&nbsp;        if (isJumping()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Account for terrain, unless we&#39;re moving along a road.
<b class="nc">&nbsp;        if (!isPavementStep()) {</b>
&nbsp;
<b class="nc">&nbsp;            if ((moveMode != EntityMovementMode.BIPED_SWIM)</b>
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.QUAD_SWIM)
<b class="nc">&nbsp;                    &amp;&amp; getClearance() == 0) {</b>
<b class="nc">&nbsp;                mp += destHex.movementCost(getEntity());</b>
&nbsp;            }
&nbsp;
&nbsp;            // if this is an amphibious unit crossing water, increment movement cost by 1
<b class="nc">&nbsp;            if(isAmphibious &amp;&amp; !destHex.containsTerrain(Terrains.ICE) &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)) {</b>
<b class="nc">&nbsp;                mp++;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // non-hovers, non-navals and non-VTOLs check for water depth and
&nbsp;            // are affected by swamp
<b class="nc">&nbsp;            if ((moveMode != EntityMovementMode.HOVER)</b>
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.NAVAL)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.HYDROFOIL)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.SUBMARINE)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.INF_UMU)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.VTOL)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.BIPED_SWIM)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.QUAD_SWIM)
&nbsp;                    &amp;&amp; (moveMode != EntityMovementMode.WIGE)) {
&nbsp;                // no additional cost when moving on surface of ice.
<b class="nc">&nbsp;                if (!destHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;                        || (nDestEl &lt; destHex.surface())) {</b>
<b class="nc">&nbsp;                    if ((destHex.terrainLevel(Terrains.WATER) == 1) &amp;&amp; !isAmphibious) {</b>
<b class="nc">&nbsp;                        mp++;</b>
<b class="nc">&nbsp;                    } else if ((destHex.terrainLevel(Terrains.WATER) &gt; 1) &amp;&amp; !isAmphibious) {</b>
<b class="nc">&nbsp;                        if (getEntity().hasAbility(OptionsConstants.PILOT_TM_FROGMAN)</b>
&nbsp;                                &amp;&amp; ((entity instanceof Mech) || (entity instanceof Protomech))) {
<b class="nc">&nbsp;                            mp += 2;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            mp += 3;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                // if using non-careful movement on ice then reduce cost
<b class="nc">&nbsp;                if (destHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;                        &amp;&amp; !isCareful()</b>
<b class="nc">&nbsp;                        &amp;&amp; (nDestEl == destHex.surface())) {</b>
<b class="nc">&nbsp;                    mp--;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        } // End not-along-road
&nbsp;
&nbsp;        // non-WIGEs pay for elevation differences
<b class="nc">&nbsp;        if ((nSrcEl != nDestEl) &amp;&amp; (moveMode != EntityMovementMode.WIGE)) {</b>
<b class="nc">&nbsp;            int delta_e = Math.abs(nSrcEl - nDestEl);</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEAPING) &amp;&amp; isMech</b>
&nbsp;                    &amp;&amp; (delta_e &gt; 2) &amp;&amp; (nDestEl &lt; nSrcEl)) {
&nbsp;                // leaping (moving down more than 2 hexes) always costs 4 mp
&nbsp;                // regardless of anything else
<b class="nc">&nbsp;                mp = 4;</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            // non-flying Infantry and ground vehicles are charged double.
<b class="nc">&nbsp;            if ((isInfantry</b>
<b class="nc">&nbsp;                    &amp;&amp; !((getMovementType(false) == EntityMovementType.MOVE_VTOL_WALK)</b>
<b class="nc">&nbsp;                            || (getMovementType(false) == EntityMovementType.MOVE_VTOL_RUN)))</b>
&nbsp;                    || ((moveMode == EntityMovementMode.TRACKED)
&nbsp;                            || (moveMode == EntityMovementMode.WHEELED)
&nbsp;                            || (moveMode == EntityMovementMode.HOVER))) {
<b class="nc">&nbsp;                delta_e *= 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity.hasAbility(OptionsConstants.PILOT_TM_MOUNTAINEER)) {</b>
<b class="nc">&nbsp;                mp += delta_e - 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                mp += delta_e;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // WiGEs in climb mode pay 2 extra MP to stay at the same flight level
&nbsp;        // if more than one elevation above the underlying terrain.
&nbsp;        // If the destination contains a building, the WiGE must pay the extra MP if flying
&nbsp;        // more than one elevation above its top or if climbing a level to get above it.
&nbsp;        // See http://bg.battletech.com/forums/index.php?topic=51081.msg1297747#msg1297747
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.WIGE &amp;&amp; distance &gt; 0 &amp;&amp; (getClearance() &gt; 1</b>
<b class="nc">&nbsp;                || (destHex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                        &amp;&amp; destHex.ceiling() &gt; srcHex.ceiling()))) {</b>
<b class="nc">&nbsp;            mp += 2;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // WIGEs spend one extra MP to ascend a sheer cliff, TO p.39
<b class="nc">&nbsp;        if (entity.getMovementMode() == EntityMovementMode.WIGE </b>
&nbsp;                &amp;&amp; distance &gt; 0 
<b class="nc">&nbsp;                &amp;&amp; destHex.hasCliffTopTowards(srcHex)</b>
&nbsp;                &amp;&amp; nDestEl &gt; nSrcEl) {
<b class="nc">&nbsp;            mp += 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we entering a building, all non-infantry pay additional MP.
<b class="nc">&nbsp;        if (nDestEl &lt; destHex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(getPosition());</b>
&nbsp;            // check for inside hangar movement
<b class="nc">&nbsp;            if ((null != prev)</b>
&nbsp;                    &amp;&amp; (null != bldg)
<b class="nc">&nbsp;                    &amp;&amp; bldg.isIn(prev)</b>
<b class="nc">&nbsp;                    &amp;&amp; (bldg.getBldgClass() == Building.HANGAR)</b>
<b class="nc">&nbsp;                    &amp;&amp; (destHex.terrainLevel(Terrains.BLDG_ELEV) &gt; getEntity()</b>
<b class="nc">&nbsp;                            .height())) {</b>
<b class="nc">&nbsp;                mp += 0;</b>
<b class="nc">&nbsp;            } else if (!isInfantry &amp;&amp; !isSuperHeavyMech) {</b>
<b class="nc">&nbsp;                if (!isProto) {</b>
&nbsp;                    // non-protos pay extra according to the building type
<b class="nc">&nbsp;                    mp += bldg.getType();</b>
<b class="nc">&nbsp;                    if (bldg.getBldgClass() == Building.HANGAR) {</b>
<b class="nc">&nbsp;                        mp--;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (bldg.getBldgClass() == Building.FORTRESS) {</b>
<b class="nc">&nbsp;                        mp++;</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // protos pay one extra
<b class="nc">&nbsp;                    mp += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (isMechanizedInfantry) {</b>
&nbsp;                // mechanized infantry pays 1 extra
<b class="nc">&nbsp;                mp += 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Infantry (except mechanized) pay 1 less MP to enter woods
<b class="nc">&nbsp;        if (isInfantry &amp;&amp; !isMechanizedInfantry</b>
<b class="nc">&nbsp;                &amp;&amp; destHex.containsTerrain(Terrains.WOODS)</b>
&nbsp;                &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            mp--;</b>
&nbsp;
&nbsp;            // Ensures that Infantry always pay at least 1 mp when 
&nbsp;            // entering woods or jungle
<b class="nc">&nbsp;            if (mp &lt;= 0) {</b>
<b class="nc">&nbsp;                mp = 1;</b>
&nbsp;            }
&nbsp;        }        
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Is movement possible from a previous position to this one?
&nbsp;     * &lt;p/&gt;
&nbsp;     * This function does not comment on whether an overall movement path is
&nbsp;     * possible, just whether the &lt;em&gt;current&lt;/em&gt; step is possible.
&nbsp;     */
&nbsp;    public boolean isMovementPossible(IGame game, Coords src, int srcEl, CachedEntityState cachedEntityState) {
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final Coords dest = getPosition();</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;        final Entity entity = getEntity();</b>
&nbsp;
<b class="nc">&nbsp;        if (null == dest) {</b>
<b class="nc">&nbsp;            throw getLogger().error(new IllegalStateException(&quot;Step has no position&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (src.distance(dest) &gt; 1) {</b>
<b class="nc">&nbsp;            StringBuffer buf = new StringBuffer();</b>
<b class="nc">&nbsp;            buf.append(&quot;Coordinates &quot;).append(src.toString()).append(&quot; and &quot;)</b>
<b class="nc">&nbsp;                    .append(dest.toString()).append(&quot; are not adjacent.&quot;);</b>
<b class="nc">&nbsp;            throw getLogger().error(new IllegalArgumentException(buf.toString()));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Assault dropping units cannot move
<b class="nc">&nbsp;        if ((entity.isAssaultDropInProgress() || entity.isDropping())</b>
&nbsp;                &amp;&amp; !((entity instanceof LandAirMech)
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getAltitude() &lt;= 3))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If we&#39;re a tank and immobile, check if we try to unjam
&nbsp;        // or eject and the crew is not unconscious
<b class="nc">&nbsp;        if ((entity instanceof Tank)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.getCrew().isUnconscious()</b>
&nbsp;                &amp;&amp; ((type == MoveStepType.UNJAM_RAC)
&nbsp;                || (type == MoveStepType.EJECT) || (type == MoveStepType.SEARCHLIGHT))) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // We&#39;re wanting to startup our reactor and we&#39;re not unconscious
<b class="nc">&nbsp;        if ((type == MoveStepType.STARTUP) &amp;&amp; !entity.getCrew().isUnconscious()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // We&#39;re wanting to self destruct our reactor and we&#39;re not unconscious
<b class="nc">&nbsp;        if ((type == MoveStepType.SELF_DESTRUCT)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.getCrew().isUnconscious()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If you want to flee, and you can flee, flee.
<b class="nc">&nbsp;        if ((type == MoveStepType.FLEE)</b>
<b class="nc">&nbsp;                &amp;&amp; entity.canFlee()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // super-easy
<b class="nc">&nbsp;        if (entity.isImmobile()) {</b>
&nbsp;            // System.err.println(&quot;illegal - immobile&quot;);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Hidden units, and activating hidden units cannot move 
&nbsp;        // unless it is the movement phase and the plan is to activate then
&nbsp;        // if we&#39;re in this method, we&#39;re implicitly in the movement phase
<b class="nc">&nbsp;        if (entity.isHidden() || (entity.isHiddenActivating() &amp;&amp; (entity.hiddenActivationPhase != Phase.PHASE_MOVEMENT))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // another easy check
<b class="nc">&nbsp;        if (!game.getBoard().contains(dest)) {</b>
&nbsp;            // System.err.println(&quot;board doesn&#39;t contain destination&quot;);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can&#39;t enter impassable hex
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.IMPASSABLE)) {</b>
&nbsp;            // System.err.println(&quot;can&#39;t enter impassable hex&quot;);
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int srcAlt = srcEl + srcHex.getLevel();</b>
<b class="nc">&nbsp;        final int destAlt = elevation + destHex.getLevel();</b>
&nbsp;
<b class="nc">&nbsp;        Building bld = game.getBoard().getBuildingAt(dest);</b>
&nbsp;
<b class="nc">&nbsp;        if (bld != null) {</b>
&nbsp;            // protomechs that are jumping can&#39;t change the level inside a
&nbsp;            // building,
&nbsp;            // they can only jump onto a building or out of it
<b class="nc">&nbsp;            if (src.equals(dest) &amp;&amp; (srcAlt != destAlt)</b>
&nbsp;                    &amp;&amp; (entity instanceof Protomech)
<b class="nc">&nbsp;                    &amp;&amp; (getMovementType(false) == EntityMovementType.MOVE_JUMP)) {</b>
&nbsp;                // System.err
&nbsp;                // .println(&quot;no jumping inside buildings to change levels&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;            int maxElevation = (2 + entity.getElevation() + game.getBoard()</b>
<b class="nc">&nbsp;                    .getHex(entity.getPosition()).surface())</b>
<b class="nc">&nbsp;                    - hex.surface();</b>
&nbsp;
<b class="nc">&nbsp;            if ((bld.getType() == Building.WALL)</b>
<b class="nc">&nbsp;                    &amp;&amp; (maxElevation &lt; hex.terrainLevel(Terrains.BLDG_ELEV))) {</b>
&nbsp;                // System.err.println(&quot;soemthing about walls&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // only infantry can enter an armored building
<b class="nc">&nbsp;            if ((elevation &lt; hex.terrainLevel(Terrains.BLDG_ELEV))</b>
<b class="nc">&nbsp;                    &amp;&amp; (bld.getArmor(dest) &gt; 0)</b>
&nbsp;                    &amp;&amp; !(entity instanceof Infantry)) {
&nbsp;                // System.err.println(&quot;no entering armored buildings for non-inf&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // only infantry can enter a gun emplacement
<b class="nc">&nbsp;            if ((elevation &lt; hex.terrainLevel(Terrains.BLDG_ELEV))</b>
<b class="nc">&nbsp;                    &amp;&amp; (bld.getBldgClass() == Building.GUN_EMPLACEMENT)</b>
&nbsp;                    &amp;&amp; !(entity instanceof Infantry)) {
&nbsp;                // System.err.println(&quot;no entering gun-emplacements for non-inf&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t back up across an elevation change.
<b class="nc">&nbsp;        if (!(entity instanceof VTOL)</b>
<b class="nc">&nbsp;                &amp;&amp; isThisStepBackwards()</b>
<b class="nc">&nbsp;                &amp;&amp; !(isJumping() &amp;&amp; (entity.getJumpType() == Mech.JUMP_BOOSTER))</b>
<b class="nc">&nbsp;                &amp;&amp; (((destAlt != srcAlt) &amp;&amp; !game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                OptionsConstants.ADVGRNDMOV_TACOPS_WALK_BACKWARDS)) || (game.getOptions()</b>
<b class="nc">&nbsp;                .booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_WALK_BACKWARDS) &amp;&amp; (Math</b>
<b class="nc">&nbsp;                .abs(destAlt - srcAlt) &gt; 1)))) {</b>
&nbsp;            // System.err.println(&quot;Can&#39;t back up across an elevation change.&quot;);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Swarming entities can&#39;t move.
<b class="nc">&nbsp;        if (Entity.NONE != entity.getSwarmTargetId()) {</b>
&nbsp;            // System.err.println(&quot;no moving for swarming infantry&quot;);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (type == MoveStepType.MOUNT) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The entity is trying to load. Check for a valid move.
<b class="nc">&nbsp;        if (type == MoveStepType.LOAD) {</b>
&nbsp;
&nbsp;            // Transports can&#39;t load after the first step.
<b class="nc">&nbsp;            if (!firstStep) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Find the unit being loaded.
<b class="nc">&nbsp;            Entity other = null;</b>
<b class="nc">&nbsp;            Iterator&lt;Entity&gt; entities = game.getEntities(src);</b>
<b class="nc">&nbsp;            while (entities.hasNext()) {</b>
&nbsp;
&nbsp;                // Is the other unit friendly and not the current entity?
<b class="nc">&nbsp;                other = entities.next();</b>
<b class="nc">&nbsp;                if (!entity.getOwner().isEnemyOf(other.getOwner())</b>
<b class="nc">&nbsp;                        &amp;&amp; !entity.equals(other)) {</b>
&nbsp;
&nbsp;                    // The moving unit should be able to load the other unit.
<b class="nc">&nbsp;                    if (!entity.canLoad(other)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // The other unit should be able to have a turn.
<b class="nc">&nbsp;                    if (!other.isLoadableThisTurn()) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // We can stop looking.
&nbsp;                    break;
&nbsp;                }
&nbsp;                // Nope. Discard it.
<b class="nc">&nbsp;                other = null;</b>
&nbsp;
&nbsp;            } // Check the next entity in this position.
&nbsp;
&nbsp;            // We were supposed to find someone to load.
<b class="nc">&nbsp;            if (other == null) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;        } // End STEP_LOAD-checks
&nbsp;        
&nbsp;        // The entity is trying to tow. Check for a valid move.
<b class="nc">&nbsp;        if (type == MoveStepType.TOW) {</b>
&nbsp;
&nbsp;            // Find the unit being towed.
<b class="nc">&nbsp;            Entity other = game.getEntity(entity.getTowing());</b>
&nbsp;
&nbsp;            // The moving unit should be able to tow the other unit.
<b class="nc">&nbsp;            if (!entity.canTow(other.getId())) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        } // End STEP_TOW-checks
&nbsp;
&nbsp;        // mechs dumping ammo can&#39;t run
<b class="nc">&nbsp;        boolean bDumping = false;</b>
<b class="nc">&nbsp;        for (Mounted mo : entity.getAmmo()) {</b>
<b class="nc">&nbsp;            if (mo.isDumping()) {</b>
<b class="nc">&nbsp;                bDumping = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (bDumping</b>
&nbsp;                &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
&nbsp;                || (movementType == EntityMovementType.MOVE_SPRINT)
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_SPRINT)
&nbsp;                || (movementType == EntityMovementType.MOVE_JUMP))) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check elevation difference &gt; max
<b class="nc">&nbsp;        EntityMovementMode nMove = entity.getMovementMode();</b>
&nbsp;
&nbsp;        // Make sure that if it&#39;s a VTOL unit with the VTOL MP listed as jump
&nbsp;        // MP...
&nbsp;        // That it can&#39;t jump.
<b class="nc">&nbsp;        if ((movementType == EntityMovementType.MOVE_JUMP)</b>
&nbsp;                &amp;&amp; (nMove == EntityMovementMode.VTOL)) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;    
&nbsp;        
<b class="nc">&nbsp;        if ((movementType != EntityMovementType.MOVE_JUMP)</b>
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.VTOL)) {
<b class="nc">&nbsp;            int maxDown = entity.getMaxElevationDown(srcAlt);</b>
<b class="nc">&nbsp;            if (movementMode == EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                    &amp;&amp; (srcEl == 0 || (srcHex.containsTerrain(Terrains.BLDG_ELEV)</b>
<b class="nc">&nbsp;                            &amp;&amp; (srcHex.terrainLevel(Terrains.BLDG_ELEV) &gt;= srcEl)))) {</b>
<b class="nc">&nbsp;                maxDown = entity.getMaxElevationChange();</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((((srcAlt - destAlt) &gt; 0) &amp;&amp; ((srcAlt - destAlt) &gt; maxDown))</b>
&nbsp;                    || (((destAlt - srcAlt) &gt; 0) &amp;&amp; ((destAlt - srcAlt) &gt; entity
<b class="nc">&nbsp;                    .getMaxElevationChange()))) {</b>
&nbsp;                // System.err.println(&quot;jump VTOL check failed&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Sheer Cliffs, TO p.39
&nbsp;        // Roads over cliffs cancel the cliff effects for units that move on roads
<b class="nc">&nbsp;        boolean vehicleAffectedByCliff = entity instanceof Tank </b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isAirborneVTOLorWIGE();</b>
<b class="nc">&nbsp;        boolean quadveeVehMode = entity instanceof QuadVee </b>
<b class="nc">&nbsp;                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</b>
<b class="nc">&nbsp;        int stepHeight = destAlt - srcAlt;</b>
&nbsp;        // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
&nbsp;        // Everything that does not have a 1 or 2 level drop shouldn&#39;t be handled as a cliff
<b class="nc">&nbsp;        boolean isUpCliff = !src.equals(dest)</b>
<b class="nc">&nbsp;                &amp;&amp; destHex.hasCliffTopTowards(srcHex)</b>
&nbsp;                &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<b class="nc">&nbsp;        boolean isDownCliff = !src.equals(dest) </b>
<b class="nc">&nbsp;                &amp;&amp; srcHex.hasCliffTopTowards(destHex)</b>
&nbsp;                &amp;&amp; (stepHeight == -1 || stepHeight == -2);
&nbsp;        
&nbsp;        // For vehicles exc. VTOL, WIGE, upward Sheer Cliffs is forbidden
&nbsp;        // QuadVees in vehicle mode drive as vehicles, IO p.133
<b class="nc">&nbsp;        if ((vehicleAffectedByCliff || quadveeVehMode) </b>
&nbsp;                &amp;&amp; isUpCliff
&nbsp;                &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // For Infantry, up or down sheer cliffs requires a climbing action 
&nbsp;        // except for Mountain Troops across a level 1 cliff.
&nbsp;        // Climbing actions do not seem to be implemented, so Infantry cannot
&nbsp;        // cross sheer cliffs at all except for Mountain Troops across a level 1 cliff.
<b class="nc">&nbsp;        if (entity instanceof Infantry </b>
&nbsp;                &amp;&amp; (isUpCliff || isDownCliff)
&nbsp;                &amp;&amp; !isPavementStep) {
&nbsp;
<b class="nc">&nbsp;            boolean isMountainTroop = ((Infantry)entity).hasSpecialization(Infantry.MOUNTAIN_TROOPS);</b>
<b class="nc">&nbsp;            if (!isMountainTroop || stepHeight == 2) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if ((entity instanceof Mech) &amp;&amp; ((srcAlt - destAlt) &gt; 2)) {</b>
<b class="nc">&nbsp;            setLeapDistance(srcAlt - destAlt);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Units moving backwards may not change elevation levels.
<b class="nc">&nbsp;        if (((type == MoveStepType.BACKWARDS)</b>
&nbsp;                || (type == MoveStepType.LATERAL_LEFT_BACKWARDS) || (type == MoveStepType.LATERAL_RIGHT_BACKWARDS))
&nbsp;                &amp;&amp; (destAlt != srcAlt)
&nbsp;                &amp;&amp; !(entity instanceof VTOL)
<b class="nc">&nbsp;                &amp;&amp; !(isJumping() &amp;&amp; (entity.getJumpType() == Mech.JUMP_BOOSTER))) {</b>
&nbsp;            // Generally forbidden without TacOps Expanded Backward Movement p.22
<b class="nc">&nbsp;            if (!game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_WALK_BACKWARDS)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // Even with Expanded Backward Movement, ...
&nbsp;            // May not move across a cliff (up) moving backwards at all
<b class="nc">&nbsp;            if (destHex.containsTerrain(Terrains.CLIFF_TOP)</b>
<b class="nc">&nbsp;                    &amp;&amp; destHex.getTerrain(Terrains.CLIFF_TOP).hasExitsSpecified()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((destHex.getTerrain(Terrains.CLIFF_TOP).getExits() &amp; (1 &lt;&lt; dest.direction(src))) != 0) </b>
<b class="nc">&nbsp;                    &amp;&amp; (!src.equals(dest))) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // May not move across a cliff (down) moving backwards at all
<b class="nc">&nbsp;            if (srcHex.containsTerrain(Terrains.CLIFF_TOP)</b>
<b class="nc">&nbsp;                    &amp;&amp; srcHex.getTerrain(Terrains.CLIFF_TOP).hasExitsSpecified()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((srcHex.getTerrain(Terrains.CLIFF_TOP).getExits() &amp; (1 &lt;&lt; src.direction(dest))) != 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (!src.equals(dest))) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // May not move across more than 1 level 
<b class="nc">&nbsp;            if (Math.abs(destAlt - srcAlt) &gt; 1) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // WiGEs can&#39;t move backwards
<b class="nc">&nbsp;        if ((type == MoveStepType.BACKWARDS)</b>
&nbsp;                &amp;&amp; (nMove == EntityMovementMode.WIGE)) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t run into water unless hovering, naval, first step, using a
&nbsp;        // bridge, or fly.
<b class="nc">&nbsp;        if (((movementType == EntityMovementType.MOVE_RUN)</b>
&nbsp;                || (movementType == EntityMovementType.MOVE_SPRINT)
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                || (movementType == EntityMovementType.MOVE_VTOL_SPRINT))
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.HOVER)
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.NAVAL)
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.HYDROFOIL)
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.SUBMARINE)
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.INF_UMU)
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.VTOL)
&nbsp;                &amp;&amp; (nMove != EntityMovementMode.WIGE)
<b class="nc">&nbsp;                &amp;&amp; !cachedEntityState.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS)</b>
<b class="nc">&nbsp;                &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; !(destHex.containsTerrain(Terrains.ICE) &amp;&amp; (elevation &gt;= 0))</b>
<b class="nc">&nbsp;                &amp;&amp; !dest.equals(entity.getPosition())</b>
<b class="nc">&nbsp;                &amp;&amp; !isFirstStep()</b>
<b class="nc">&nbsp;                &amp;&amp; !isPavementStep()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // ugh, stacking checks. well, maybe we&#39;re immune!
<b class="nc">&nbsp;        if (!isJumping() &amp;&amp; (type != MoveStepType.CHARGE)</b>
&nbsp;                &amp;&amp; (type != MoveStepType.DFA)) {
&nbsp;            // can&#39;t move a mech into a hex with an enemy mech
<b class="nc">&nbsp;            if ((entity instanceof Mech)</b>
<b class="nc">&nbsp;                    &amp;&amp; Compute.isEnemyIn(game, entity, dest, true, true,</b>
<b class="nc">&nbsp;                    getElevation())) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Can&#39;t move out of a hex with an enemy unit unless we started
&nbsp;            // there, BUT we&#39;re allowed to turn, unload/Disconnect, or go prone.
<b class="nc">&nbsp;            if (Compute.isEnemyIn(game, entity, src, false,</b>
&nbsp;                    entity instanceof Mech, srcEl)
<b class="nc">&nbsp;                    &amp;&amp; !src.equals(entity.getPosition())</b>
&nbsp;                    &amp;&amp; (type != MoveStepType.TURN_LEFT)
&nbsp;                    &amp;&amp; (type != MoveStepType.TURN_RIGHT)
&nbsp;                    &amp;&amp; (type != MoveStepType.UNLOAD)
&nbsp;                    &amp;&amp; (type != MoveStepType.DISCONNECT)
&nbsp;                    &amp;&amp; (type != MoveStepType.GO_PRONE)) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // cant move through a hex with a LargeSupportTank or a grounded
&nbsp;            // Dropship unless infantry
&nbsp;            // or a VTOL at high enough elevation
<b class="nc">&nbsp;            if (!(entity instanceof Infantry)) {</b>
<b class="nc">&nbsp;                boolean validRoadTrain = false;</b>
<b class="nc">&nbsp;                for (Entity inHex : game.getEntitiesVector(src)) {</b>
<b class="nc">&nbsp;                    if (inHex.equals(entity)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    
&nbsp;                    //ignore the first trailer behind a non-superheavy tractor
&nbsp;                    //which can be in the same hex
<b class="nc">&nbsp;                    if (!entity.getAllTowedUnits().isEmpty() &amp;&amp; !entity.isSuperHeavy()) {</b>
<b class="nc">&nbsp;                        Entity firstTrailer = game.getEntity(entity.getAllTowedUnits().get(0));</b>
<b class="nc">&nbsp;                        if (inHex.equals(firstTrailer)) {</b>
<b class="nc">&nbsp;                            validRoadTrain = true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if ((inHex instanceof LargeSupportTank)</b>
<b class="nc">&nbsp;                            || (!entity.getAllTowedUnits().isEmpty() &amp;&amp; !validRoadTrain)</b>
<b class="nc">&nbsp;                            || (!inHex.getAllTowedUnits().isEmpty())</b>
&nbsp;                            || ((inHex instanceof Dropship)
<b class="nc">&nbsp;                            &amp;&amp; !inHex.isAirborne() &amp;&amp; !inHex</b>
<b class="nc">&nbsp;                            .isSpaceborne())) {</b>
<b class="nc">&nbsp;                        if (getElevation() &lt;= inHex.height()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // can&#39;t jump over too-high terrain
<b class="nc">&nbsp;        if ((movementType == EntityMovementType.MOVE_JUMP)</b>
<b class="nc">&nbsp;                &amp;&amp; (destAlt &gt; (entity.getElevation()</b>
<b class="nc">&nbsp;                + entity.game.getBoard().getHex(entity.getPosition())</b>
<b class="nc">&nbsp;                .getLevel() + entity.getJumpMPWithTerrain() + (type == MoveStepType.DFA ? 1</b>
<b class="nc">&nbsp;                : 0)))) {</b>
&nbsp;            // System.err.println(&quot;can&#39;t jump over too-high terrain&quot;);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Certain movement types have terrain restrictions; terrain
&nbsp;        // restrictions are lifted when moving along a road or bridge,
&nbsp;        // or when flying. Naval movement does not have the pavement
&nbsp;        // exemption.
<b class="nc">&nbsp;        if (entity.isLocationProhibited(dest, getElevation())</b>
&nbsp;                // Units in prohibited terran should still be able to unload/disconnect
&nbsp;                &amp;&amp; (type != MoveStepType.UNLOAD)
&nbsp;                &amp;&amp; (type != MoveStepType.DISCONNECT)
&nbsp;                // Should allow vertical takeoffs
&nbsp;                &amp;&amp; (type != MoveStepType.VTAKEOFF)
&nbsp;                // QuadVees can convert to vehicle mode even if they cannot enter the terrain
&nbsp;                &amp;&amp; (type != MoveStepType.CONVERT_MODE)
<b class="nc">&nbsp;                &amp;&amp; (!isPavementStep() || (nMove == EntityMovementMode.NAVAL)</b>
&nbsp;                || (nMove == EntityMovementMode.HYDROFOIL) || (nMove == EntityMovementMode.SUBMARINE))
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_SPRINT)) {
&nbsp;
&nbsp;            // We&#39;re allowed to pass *over* invalid
&nbsp;            // terrain, but we can&#39;t end there.
<b class="nc">&nbsp;            if (isJumping()) {</b>
<b class="nc">&nbsp;                terrainInvalid = true;</b>
&nbsp;            } else {
&nbsp;                // This is an illegal move.
&nbsp;                // System.err.println(&quot;landing in illegal terrain&quot;);
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // We need extra checking for dropships, due to secondary positions
&nbsp;        // if the Dropship is taking off, movetype will be safe thrust
<b class="nc">&nbsp;        if ((entity instanceof Dropship) &amp;&amp; !entity.isAirborne()</b>
<b class="nc">&nbsp;                &amp;&amp; isPavementStep() &amp;&amp; entity.isLocationProhibited(dest, getElevation())</b>
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_SAFE_THRUST)
&nbsp;                &amp;&amp; (type != MoveStepType.LOAD)
&nbsp;                &amp;&amp; (type != MoveStepType.UNLOAD)) {
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                Coords secondaryCoords = dest.translated(dir);</b>
<b class="nc">&nbsp;                IHex secondaryHex = game.getBoard().getHex(secondaryCoords);</b>
<b class="nc">&nbsp;                if (!secondaryHex.hasPavement()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        //If we&#39;re a land train with mixed motive types, use the most restrictive type
&nbsp;        //to determine terrain restrictions
<b class="nc">&nbsp;        if (!entity.getAllTowedUnits().isEmpty()</b>
&nbsp;                &amp;&amp; (type != MoveStepType.LOAD
&nbsp;                    &amp;&amp; type != MoveStepType.UNLOAD
&nbsp;                    &amp;&amp; type != MoveStepType.TOW
&nbsp;                    &amp;&amp; type != MoveStepType.DISCONNECT)) {
<b class="nc">&nbsp;            boolean prohibitedByTrailer = false;</b>
&nbsp;            //Add up the trailers
<b class="nc">&nbsp;            for (int id : entity.getAllTowedUnits()) {</b>
<b class="nc">&nbsp;                Entity tr = game.getEntity(id);</b>
<b class="nc">&nbsp;                prohibitedByTrailer = tr.isLocationProhibited(dest, getElevation());</b>
<b class="nc">&nbsp;                if (prohibitedByTrailer) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Jumping into a building hex below the roof ends the move
&nbsp;        // assume this applies also to sylph vtol movement
<b class="nc">&nbsp;        if (!(src.equals(dest))</b>
<b class="nc">&nbsp;                &amp;&amp; (src != entity.getPosition())</b>
<b class="nc">&nbsp;                &amp;&amp; (isJumping() || (entity.getMovementMode() == EntityMovementMode.VTOL))</b>
<b class="nc">&nbsp;                &amp;&amp; (srcEl &lt; srcHex.terrainLevel(Terrains.BLDG_ELEV))) {</b>
&nbsp;            // System.err.println(&quot;jumping into side of building&quot;);
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we are *in* restricted terrain, we can only leave via roads.
<b class="nc">&nbsp;        if ((movementType != EntityMovementType.MOVE_JUMP)</b>
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_SPRINT)
&nbsp;                // Units in prohibited terran should still be able to unload/disconnect
&nbsp;                &amp;&amp; (type != MoveStepType.UNLOAD)
&nbsp;                &amp;&amp; (type != MoveStepType.DISCONNECT)
&nbsp;                // Should allow vertical takeoffs
&nbsp;                &amp;&amp; (type != MoveStepType.VTAKEOFF)
&nbsp;                // QuadVees can still convert to vehicle mode in prohibited terrain, but cannot leave
&nbsp;                &amp;&amp; (type != MoveStepType.CONVERT_MODE)
<b class="nc">&nbsp;                &amp;&amp; entity.isLocationProhibited(src, getElevation()) &amp;&amp; !isPavementStep()) {</b>
&nbsp;            // System.err.println(&quot;in restricted terrain&quot;);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.UP) {</b>
<b class="nc">&nbsp;            if (!(entity.canGoUp(elevation - 1, getPosition()))) {</b>
&nbsp;                // System.err.println(&quot;cant go up anymore&quot;);
&nbsp;
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (type == MoveStepType.DOWN) {</b>
<b class="nc">&nbsp;            if (!(entity.canGoDown(elevation + 1, getPosition()))) {</b>
&nbsp;                // System.err.println(&quot;cant go down anymore&quot;);
<b class="nc">&nbsp;                return false;// We can&#39;t intentionally crash.</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof VTOL) {</b>
<b class="nc">&nbsp;            if ((type == MoveStepType.BACKWARDS)</b>
&nbsp;                    || (type == MoveStepType.FORWARDS)
&nbsp;                    || (type == MoveStepType.LATERAL_LEFT)
&nbsp;                    || (type == MoveStepType.LATERAL_LEFT_BACKWARDS)
&nbsp;                    || (type == MoveStepType.LATERAL_RIGHT)
&nbsp;                    || (type == MoveStepType.LATERAL_RIGHT_BACKWARDS)
&nbsp;                    || (type == MoveStepType.TURN_LEFT)
&nbsp;                    || (type == MoveStepType.TURN_RIGHT)) {
<b class="nc">&nbsp;                if (getClearance() == 0) {// can&#39;t move on the ground.</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((entity instanceof VTOL || entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                &amp;&amp; getClearance() &gt; 0</b>
&nbsp;                &amp;&amp; ((type == MoveStepType.BACKWARDS) || (type == MoveStepType.FORWARDS)
&nbsp;                        || (type == MoveStepType.LATERAL_LEFT) || (type == MoveStepType.LATERAL_LEFT_BACKWARDS)
&nbsp;                        || (type == MoveStepType.LATERAL_RIGHT) || (type == MoveStepType.LATERAL_RIGHT_BACKWARDS))) {
&nbsp;            // It&#39;s possible to fly under a bridge.
<b class="nc">&nbsp;            if (destHex.containsTerrain(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;                if (elevation == destHex.terrainLevel(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (elevation &lt;= (destHex.ceiling() - destHex.surface())) {</b>
&nbsp;                // VTOLs and WiGEs can fly through woods and jungle below the level of the treetops on a road.
<b class="nc">&nbsp;                if (destHex.containsTerrain(Terrains.WOODS) || destHex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                    return destHex.containsTerrainExit(Terrains.ROAD, dest.direction(src));</b>
&nbsp;                }
&nbsp;                // System.err.println(&quot;can&#39;t fly into woods or a cliff face&quot;);
<b class="nc">&nbsp;                return false; // can&#39;t fly into woods or a cliff face</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check the elevation is valid for the type of entity and hex
<b class="nc">&nbsp;        if ((type != MoveStepType.DFA)</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isElevationValid(elevation, destHex)) {</b>
<b class="nc">&nbsp;            if (isJumping()) {</b>
<b class="nc">&nbsp;                terrainInvalid = true;</b>
&nbsp;            } else {
&nbsp;                // System.err.println(&quot;isElevationValid failed destHex is &quot; +
&nbsp;                // dest.toString());
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getElevation() {
<b class="nc">&nbsp;        return elevation;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * In hexes with buildings, returns the elevation relative to the roof. Otherwise returns the elevation
&nbsp;     * relative to the surface.
&nbsp;     */
&nbsp;    public int getClearance() {
<b class="nc">&nbsp;        IHex hex = entity.getGame().getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            return elevation - hex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;        }
<b class="nc">&nbsp;        return elevation;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getAltitude() {
<b class="nc">&nbsp;        return altitude;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMineToLay() {
<b class="nc">&nbsp;        return mineToLay;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setMineToLay(int mineId) {
<b class="nc">&nbsp;        mineToLay = mineId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setVelocity(int vel) {
<b class="nc">&nbsp;        velocity = vel;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getVelocity() {
<b class="nc">&nbsp;        return velocity;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setVelocityN(int vel) {
<b class="nc">&nbsp;        velocityN = vel;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getVelocityN() {
<b class="nc">&nbsp;        return velocityN;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setVelocityLeft(int vel) {
<b class="nc">&nbsp;        velocityLeft = vel;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getVelocityLeft() {
<b class="nc">&nbsp;        return velocityLeft;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int asfTurnCost(IGame game, MoveStepType direction, Entity entity) {
&nbsp;
&nbsp;        // jumpships (but not space stations and warships) never pay
<b class="nc">&nbsp;        if ((entity instanceof Jumpship) &amp;&amp; !(entity instanceof Warship)</b>
&nbsp;                &amp;&amp; !(entity instanceof SpaceStation)) {
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we&#39;re behaving like a spheroid in atmosphere, we can spin around to our heart&#39;s content
<b class="nc">&nbsp;        if (useSpheroidAtmosphere(game, entity)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if in atmosphere, the rules are different
<b class="nc">&nbsp;        if (useAeroAtmosphere(game, entity)) {</b>
&nbsp;            // if they have a free turn, then this move is free
<b class="nc">&nbsp;            if (hasFreeTurn()) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;            // it costs half the current velocity (rounded up)
<b class="nc">&nbsp;            return (int) Math.ceil(getVelocity() / 2.0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // first check for thruster damage
&nbsp;        // put illegal for more than three thruster hits in CompileIllegal
<b class="nc">&nbsp;        IAero a = (IAero) entity;</b>
<b class="nc">&nbsp;        int thrustCost = 0;</b>
<b class="nc">&nbsp;        if (direction == MoveStepType.TURN_LEFT) {</b>
<b class="nc">&nbsp;            thrustCost = a.getLeftThrustHits();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (direction == MoveStepType.TURN_RIGHT) {</b>
<b class="nc">&nbsp;            thrustCost = a.getRightThrustHits();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.useVectorMove()) {</b>
&nbsp;            // velocity doesn&#39;t factor into advanced movement
<b class="nc">&nbsp;            return (1 + thrustCost);</b>
&nbsp;        }
&nbsp;
&nbsp;        // based on velocity
<b class="nc">&nbsp;        if (velocity &lt; 3) {</b>
<b class="nc">&nbsp;            return 1 + thrustCost;</b>
<b class="nc">&nbsp;        } else if ((velocity &gt; 2) &amp;&amp; (velocity &lt; 6)) {</b>
<b class="nc">&nbsp;            return 2 + thrustCost;</b>
<b class="nc">&nbsp;        } else if ((velocity &gt; 5) &amp;&amp; (velocity &lt; 8)) {</b>
<b class="nc">&nbsp;            return 3 + thrustCost;</b>
<b class="nc">&nbsp;        } else if ((velocity &gt; 7) &amp;&amp; (velocity &lt; 10)) {</b>
<b class="nc">&nbsp;            return 4 + thrustCost;</b>
<b class="nc">&nbsp;        } else if (velocity == 10) {</b>
<b class="nc">&nbsp;            return 5 + thrustCost;</b>
<b class="nc">&nbsp;        } else if (velocity == 11) {</b>
<b class="nc">&nbsp;            return 6 + thrustCost;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (((6 + velocity) - 11) + thrustCost);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setNTurns(int turns) {
<b class="nc">&nbsp;        nTurns = turns;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getNTurns() {
<b class="nc">&nbsp;        return nTurns;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setNMoved(int moved) {
<b class="nc">&nbsp;        nMoved = moved;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getNMoved() {
<b class="nc">&nbsp;        return nMoved;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setNRolls(int rolls) {
<b class="nc">&nbsp;        nRolls = rolls;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getNRolls() {
<b class="nc">&nbsp;        return nRolls;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setOffBoard(boolean b) {
<b class="nc">&nbsp;        offBoard = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isOffBoard() {
<b class="nc">&nbsp;        return offBoard;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int[] getVectors() {
<b class="nc">&nbsp;        return mv;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setVectors(int[] v) {
<b class="nc">&nbsp;        if (v.length != 6) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        mv = v;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean hasFreeTurn() {
<b class="nc">&nbsp;        return freeTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFreeTurn(boolean b) {
<b class="nc">&nbsp;        freeTurn = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getNStraight() {
<b class="nc">&nbsp;        return nStraight;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setNStraight(int i) {
<b class="nc">&nbsp;        nStraight = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * can this aero turn for any reason in atmosphere?
&nbsp;     */
&nbsp;    public boolean canAeroTurn(IGame game) {
<b class="nc">&nbsp;        Entity en = getEntity();</b>
&nbsp;        
<b class="nc">&nbsp;        if (!en.isAero()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // spheroids in atmo can spin around like a centrifuge all they want
<b class="nc">&nbsp;        if(useSpheroidAtmosphere(game, en)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (dueFreeTurn()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if its part of a maneuver then you can turn
<b class="nc">&nbsp;        if (isManeuver()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (en instanceof ConvFighter) {</b>
&nbsp;            // conventional fighters can only turn on free turns or maneuvers
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // cant use thrust turns in the first hex of movement (or first 8 if
&nbsp;        // ground)
<b class="nc">&nbsp;        if (game.getBoard().onGround()) {</b>
&nbsp;            // if flying on the ground map then they need to move 8 hexes first
<b class="nc">&nbsp;            if (distance &lt; 8) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (distance == 0) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // must have been no prior turns in this hex (or 8 hexes if on ground)
<b class="nc">&nbsp;        return getNTurns() == 0;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public boolean dueFreeTurn() {
&nbsp;
<b class="nc">&nbsp;        Entity en = getEntity();</b>
<b class="nc">&nbsp;        int straight = getNStraight();</b>
<b class="nc">&nbsp;        int vel = getVelocity();</b>
<b class="nc">&nbsp;        int thresh = 99;</b>
&nbsp;
&nbsp;        // I will assume that small craft should be treated as dropships?
<b class="nc">&nbsp;        if (en instanceof SmallCraft) {</b>
<b class="nc">&nbsp;            if (vel &gt; 15) {</b>
<b class="nc">&nbsp;                thresh = 6;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 12) {</b>
<b class="nc">&nbsp;                thresh = 5;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 9) {</b>
<b class="nc">&nbsp;                thresh = 4;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 6) {</b>
<b class="nc">&nbsp;                thresh = 3;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 3) {</b>
<b class="nc">&nbsp;                thresh = 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                thresh = 1;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (en instanceof ConvFighter) {</b>
<b class="nc">&nbsp;            if (vel &gt; 15) {</b>
<b class="nc">&nbsp;                thresh = 4;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 12) {</b>
<b class="nc">&nbsp;                thresh = 3;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 9) {</b>
<b class="nc">&nbsp;                thresh = 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                thresh = 1;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            if (vel &gt; 15) {</b>
<b class="nc">&nbsp;                thresh = 5;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 12) {</b>
<b class="nc">&nbsp;                thresh = 4;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 9) {</b>
<b class="nc">&nbsp;                thresh = 3;</b>
<b class="nc">&nbsp;            } else if (vel &gt; 6) {</b>
<b class="nc">&nbsp;                thresh = 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                thresh = 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // different rules if flying on the ground map
<b class="nc">&nbsp;        if (en.game.getBoard().onGround() &amp;&amp; (getElevation() &gt; 0)) {</b>
<b class="nc">&nbsp;            if (en instanceof Dropship) {</b>
<b class="nc">&nbsp;                thresh = vel * 8;</b>
<b class="nc">&nbsp;            } else if (en instanceof SmallCraft) {</b>
<b class="nc">&nbsp;                thresh = 8 + ((vel - 1) * 6);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                thresh = 8 + ((vel - 1) * 4);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (straight &gt;= thresh) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    protected void setNDown(int i) {
<b class="nc">&nbsp;        nDown = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getNDown() {
<b class="nc">&nbsp;        return nDown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getRecoveryUnit() {
<b class="nc">&nbsp;        return recoveryUnit;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setRecoveryUnit(int i) {
<b class="nc">&nbsp;        recoveryUnit = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getManeuverType() {
<b class="nc">&nbsp;        return maneuverType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasNoCost() {
<b class="nc">&nbsp;        return noCost;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isManeuver() {
<b class="nc">&nbsp;        return maneuver;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Minefield getMinefield() {
<b class="nc">&nbsp;        return mf;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Should we treat this movement as if it is occuring for an aerodyne unit
&nbsp;     * flying in atmosphere?
&nbsp;     */
&nbsp;    boolean useAeroAtmosphere(IGame game, Entity en) {
<b class="nc">&nbsp;        if (!en.isAero()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (((IAero) en).isSpheroid()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // are we in space?
<b class="nc">&nbsp;        if (game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // are we airborne in non-vacuum?
<b class="nc">&nbsp;        return en.isAirborne() &amp;&amp; !game.getPlanetaryConditions().isVacuum();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Should we treat this movement as if it is occurring for a spheroid unit
&nbsp;     * flying in atmosphere?
&nbsp;     */
&nbsp;    public boolean useSpheroidAtmosphere(IGame game, Entity en) {
<b class="nc">&nbsp;        return Compute.useSpheroidAtmosphere(game, en);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return An {@link ArrayList} of {@link Coords} containing buildings within a dropship&#39;s landing zone.
&nbsp;     */
&nbsp;    public ArrayList&lt;Coords&gt; getCrushedBuildingLocs() {
<b class="nc">&nbsp;        if(crushedBuildingLocs == null) {</b>
<b class="nc">&nbsp;            crushedBuildingLocs = new ArrayList&lt;&gt;();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return crushedBuildingLocs;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Entity getEntity() {
<b class="nc">&nbsp;        return entity;</b>
&nbsp;    }
&nbsp;
&nbsp;    public IGame getGame() {
<b class="nc">&nbsp;        if (getEntity() != null) {</b>
<b class="nc">&nbsp;            return getEntity().getGame();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean isJumping() {
&nbsp;        // Need to consider if our type is START_JUMP, as when adding a
&nbsp;        // START_JUMP step, the MovePath may not be considered jumping yet
<b class="nc">&nbsp;        return isJumpingPath || (type == MoveStepType.START_JUMP);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCareful() {
<b class="nc">&nbsp;        return isCarefulPath;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper function to determine whether sprint is available as a game option to the entity
&nbsp;     */
&nbsp;    public boolean canUseSprint(IGame game) {
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_SPRINT)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Tank</b>
<b class="nc">&nbsp;                || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)) {</b>
<b class="nc">&nbsp;            return  game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ADVANCED_MANEUVERS);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof LandAirMech) {</b>
<b class="nc">&nbsp;            return entity.getConversionMode() == LandAirMech.CONV_MODE_MECH</b>
<b class="nc">&nbsp;                    || (entity.getConversionMode() == LandAirMech.CONV_MODE_AIRMECH</b>
<b class="nc">&nbsp;                            &amp;&amp; getClearance() &lt;= 0);</b>
&nbsp;        }
<b class="nc">&nbsp;        return entity instanceof Mech;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
