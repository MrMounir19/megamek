


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Game</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: Game (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Game</td>
<td class="coverageStat">
  <span class="percent">
    1.6%
  </span>
  <span class="absValue">
    (4/250)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.7%
  </span>
  <span class="absValue">
    (51/1367)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Game$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$00DTK2bY</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$0gAZj4Wr</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$0jsbXTn1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$0y4QV38B</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$1FuguEKT</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$1LUAhE5V</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$1qk8HuLu</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$1UsZAG3W</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$1VCyxqor</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$2aQQFTxR</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$2CsTuERS</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$2DVQ5IC7</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$2HmXJHVB</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$3DzJwOat</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$3houUYjZ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$3V5h7j9I</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$4BXZf10p</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$4eDCXbwJ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$4MLGk8z2</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$4SxNvPD4</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$58VKRc2c</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$5DKenQXm</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$5EH21I2i</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$5m5Fvgph</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$5RNSD4RA</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$5zvEeRDD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$6kIB6Chw</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$6Oyf4a1E</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$6Qb4lW8t</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$7ft7QDL8</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$7Ouxm8fO</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$7sDEnHBD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$8AVZgiD3</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$8w4W5qGs</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$90ZvnZZs</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$9ICrtnQ1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$9qs4iiOQ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$9S9Mh73c</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$9Xs52Dbr</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$a0Wzveq5</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$A2PvjbIN</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$A4kaELqt</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$a6V2PSh8</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$A9yQpW9G</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$afDGvanW</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$AhT1rX9t</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$aKQ03J5Z</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$aP7fg5Zq</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$b2gHKTio</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$B3DqAeIj</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$b3sx40Kp</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$b5Ge1mJ6</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$b7OnGX5v</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$bEko4SkX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$beugIkn1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$BFM2ZacE</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$bgzlLOxW</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$BoAotoCz</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$bpqTFnNX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$BYdG3DLg</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$C7S9Cprk</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ckvWDzOT</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$cRghfn8E</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$d2eV6flc</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$d4q0WEeq</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$d7sjwivP</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$dBsS2W64</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$DfHcUyN9</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$dGaH92ms</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$DhAaVhvb</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$dJpmiw2M</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$DMijytsS</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$DmPm6lY0</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$dpkKGRCb</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Dpzxclbc</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$dYiEbIMs</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$E05A7iOX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$e57N9muw</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$EGt1rVLF</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$eOIzMD50</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$eqbMYKjq</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$eQseSh1b</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$F2rKXbkD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$F3JTVe2b</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$f6iY8aRH</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$F7pPrqd7</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$FhkEiNfF</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$fmHm9Obo</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$FpSQDmgC</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Fu3lJbt1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$gArW2zbJ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$gF5lf4cf</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$GjHl5zhz</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$gmhd6zS2</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$gMl4ZMdW</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$GSr94djq</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$GTlCaeDl</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$h9tkbSEd</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$hTXOu7Ea</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$I3HkR7bg</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$iHo25Id6</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ik53TMSD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$IMTZBcyH</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$IQbVD3DX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$IwtlBYaV</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$J27yBPl5</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$JEccjoVY</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$JEWrhGy4</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$jFQmcN8E</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$jHSpf9G9</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$jkMc4CLR</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$JmP96wOc</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$jPCxoV0c</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$JR5ZfWEp</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$jsFV43mf</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$jtdofcTD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ju5JUcE6</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$kiL6lDRC</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$kPtFTDk5</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Kqfp3WcK</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$kuARSp7p</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$KW8xcerl</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ldx1f2dI</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$LFfqw1sX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$lgaSxLOD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$LGqSudPw</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$LIIeozeU</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$lNspRlDe</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$lS3xuJeC</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$lXcOREY4</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$m7Wz6nmV</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$mgo1HKn6</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$mMclV2AK</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$mmJ2lQS2</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$mudKcKUE</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$myul7X9g</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$mZrfIeXt</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$nKaRff0Q</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$NKqzWR8p</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$nr2fQF7G</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$oFn6urdR</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$oSQxnLLm</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$PaijWgwJ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$PBPYgChH</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$pFLEFU4m</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$pMrOgLev</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$pMwoF5Ko</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$PpJXnZuJ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Q0QiAQHS</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Q26LyDgH</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$q78D6v6r</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$qBdzdUuA</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$qblr9NE5</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$QFS3fDEX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$QlvZtd5I</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$qoSYC73l</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$qwiyYwfi</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$QY79cJqy</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$R6ZrDjdN</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$RjdF8EoB</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$rPOGwXj9</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$RzPgz6MG</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$S6a9B052</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$S6JazNWV</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$s83NciW1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$s8clZcVa</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$S8cyY7HK</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$SaEBoPAD</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$sCpEEdYX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$sHyGMa42</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$slVHwvUF</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$snbwetVK</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$snYgEODd</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$SVNWcWcu</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$sWcly1Cx</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$swfzfpwt</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$swiV2wYm</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$sxqTuX1L</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$szFhSt7B</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$sZPRqoN0</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$t7EJUv72</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$TA72EF7k</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$TAW9axNV</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Tdfbynp2</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$TGT277yR</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ThTrDtab</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$tKKj3WkH</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$TSf5LpwV</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ttUc6jT2</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Tyg4cyl1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$UAEc0p4d</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$UiXOCBOS</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$utJfkGCT</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$UUlkvh0r</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$uV8LAZZh</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$UYkPonlw</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$VbiMD1e5</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$VBKGLoL0</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$VbzT6gXy</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$veKW3p7j</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$VEvI563y</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Vj16LOuP</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$VruKmCn1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$vxpGxV5s</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Vy9TVmoB</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$w1eloXXl</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$wBj1ys5d</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$wHIBpPOG</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$wmgYmfaH</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$WmxDiU6q</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$wpy3IrmB</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$WsA5M0kw</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$WUn8vtb1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ww6XCIL3</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$X5UiAXtA</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$XeN1M4Dg</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$xeRi8afW</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$xgTXQYZo</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$XlEDO8fb</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Xmh57NEE</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$xRHJ9THk</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$XUHxPRbS</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$xUZRCB2x</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$xvOck4xX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$XwUEhuXm</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$xXTwKumf</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$XYW9v1ZL</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Y6Q1jPus</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Y6TQrROI</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$y84St6Yh</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$YCB4LK0E</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$yfN2OChC</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Yp54YlB1</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$ySpt2nV0</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$YuqkEkAF</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$zbLPMMIk</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$zin3v7ES</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$zMNHbGHE</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Zn7UXFP2</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$zoPYQtuR</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$zr61G3bR</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$zT0J6JZr</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1339781321$auxiliary$Zxa3SXFc</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    1.5%
  </span>
  <span class="absValue">
    (4/264)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.6%
  </span>
  <span class="absValue">
    (51/1416)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.UUID;
&nbsp;import java.util.Set;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.CopyOnWriteArrayList;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.common.GameTurn.SpecificEntityTurn;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.event.GameBoardChangeEvent;
&nbsp;import megamek.common.event.GameBoardNewEvent;
&nbsp;import megamek.common.event.GameEndEvent;
&nbsp;import megamek.common.event.GameEntityChangeEvent;
&nbsp;import megamek.common.event.GameEntityNewEvent;
&nbsp;import megamek.common.event.GameEntityNewOffboardEvent;
&nbsp;import megamek.common.event.GameEntityRemoveEvent;
&nbsp;import megamek.common.event.GameEvent;
&nbsp;import megamek.common.event.GameListener;
&nbsp;import megamek.common.event.GameNewActionEvent;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.event.GamePlayerChangeEvent;
&nbsp;import megamek.common.event.GameSettingsChangeEvent;
&nbsp;import megamek.common.event.GameTurnChangeEvent;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.weapons.AttackHandler;
&nbsp;import megamek.server.SmokeCloud;
&nbsp;import megamek.server.victory.Victory;
&nbsp;
&nbsp;/**
&nbsp; * The game class is the root of all data about the game in progress. Both the
&nbsp; * Client and the Server should have one of these objects and it is their job to
&nbsp; * keep it synched.
&nbsp; */
<b class="fc">&nbsp;public class Game implements Serializable, IGame {</b>
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 8376320092671792532L;
&nbsp;
&nbsp;    /**
&nbsp;     * A UUID to identify this game instance.
&nbsp;     */
<b class="fc">&nbsp;    public UUID uuid = UUID.randomUUID();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Stores the version of MM, so that it can be serialized in saved games.
&nbsp;     */
<b class="fc">&nbsp;    public String mmVersion = MegaMek.VERSION;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Define constants to describe the condition a unit was in when it wass
&nbsp;     * removed from the game.
&nbsp;     */
&nbsp;
<b class="fc">&nbsp;    private GameOptions options = new GameOptions();</b>
&nbsp;
<b class="fc">&nbsp;    public IBoard board = new Board();</b>
&nbsp;
<b class="fc">&nbsp;    private final List&lt;Entity&gt; entities = new CopyOnWriteArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    private Hashtable&lt;Integer, Entity&gt; entityIds = new Hashtable&lt;Integer, Entity&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Track entities removed from the game (probably by death)
&nbsp;     */
<b class="fc">&nbsp;    Vector&lt;Entity&gt; vOutOfGame = new Vector&lt;Entity&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private Vector&lt;IPlayer&gt; players = new Vector&lt;IPlayer&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;Team&gt; teams = new Vector&lt;Team&gt;(); // DES</b>
&nbsp;
<b class="fc">&nbsp;    private Hashtable&lt;Integer, IPlayer&gt; playerIds = new Hashtable&lt;Integer, IPlayer&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private final Map&lt;Coords, HashSet&lt;Integer&gt;&gt; entityPosLookup = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * have the entities been deployed?
&nbsp;     */
<b class="fc">&nbsp;    private boolean deploymentComplete = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * how&#39;s the weather?
&nbsp;     */
<b class="fc">&nbsp;    private PlanetaryConditions planetaryConditions = new PlanetaryConditions();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * what round is it?
&nbsp;     */
<b class="fc">&nbsp;    private int roundCount = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The current turn list
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;GameTurn&gt; turnVector = new Vector&lt;GameTurn&gt;();</b>
<b class="fc">&nbsp;    private int turnIndex = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The present phase
&nbsp;     */
<b class="fc">&nbsp;    private Phase phase = Phase.PHASE_UNKNOWN;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The past phase
&nbsp;     */
<b class="fc">&nbsp;    private Phase lastPhase = Phase.PHASE_UNKNOWN;</b>
&nbsp;
&nbsp;    // phase state
<b class="fc">&nbsp;    private Vector&lt;EntityAction&gt; actions = new Vector&lt;EntityAction&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;AttackAction&gt; pendingCharges = new Vector&lt;AttackAction&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;AttackAction&gt; pendingRams = new Vector&lt;AttackAction&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;AttackAction&gt; pendingTeleMissileAttacks = new Vector&lt;AttackAction&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;PilotingRollData&gt; pilotRolls = new Vector&lt;PilotingRollData&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;PilotingRollData&gt; extremeGravityRolls = new Vector&lt;PilotingRollData&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;PilotingRollData&gt; controlRolls = new Vector&lt;PilotingRollData&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;Team&gt; initiativeRerollRequests = new Vector&lt;Team&gt;();</b>
&nbsp;
&nbsp;    // reports
<b class="fc">&nbsp;    private GameReports gameReports = new GameReports();</b>
&nbsp;
<b class="fc">&nbsp;    private boolean forceVictory = false;</b>
<b class="fc">&nbsp;    private int victoryPlayerId = Player.PLAYER_NONE;</b>
<b class="fc">&nbsp;    private int victoryTeam = Player.TEAM_NONE;</b>
&nbsp;
<b class="fc">&nbsp;    private Hashtable&lt;Integer, Vector&lt;Entity&gt;&gt; deploymentTable = new Hashtable&lt;Integer, Vector&lt;Entity&gt;&gt;();</b>
<b class="fc">&nbsp;    private int lastDeploymentRound = 0;</b>
&nbsp;
<b class="fc">&nbsp;    private Hashtable&lt;Coords, Vector&lt;Minefield&gt;&gt; minefields = new Hashtable&lt;Coords, Vector&lt;Minefield&gt;&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;Minefield&gt; vibrabombs = new Vector&lt;Minefield&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;AttackHandler&gt; attacks = new Vector&lt;AttackHandler&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;ArtilleryAttackAction&gt; offboardArtilleryAttacks = new Vector&lt;ArtilleryAttackAction&gt;();</b>
&nbsp;
&nbsp;    private int lastEntityId;
&nbsp;
<b class="fc">&nbsp;    private Vector&lt;TagInfo&gt; tagInfoForTurn = new Vector&lt;TagInfo&gt;();</b>
<b class="fc">&nbsp;    private Vector&lt;Flare&gt; flares = new Vector&lt;Flare&gt;();</b>
<b class="fc">&nbsp;    private HashSet&lt;Coords&gt; illuminatedPositions =</b>
&nbsp;            new HashSet&lt;Coords&gt;();
&nbsp;
<b class="fc">&nbsp;    private HashMap&lt;String, Object&gt; victoryContext = null;</b>
&nbsp;
&nbsp;    // internal integer value for an external game id link
<b class="fc">&nbsp;    private int externalGameId = 0;</b>
&nbsp;
&nbsp;    // victory condition related stuff
<b class="fc">&nbsp;    private Victory victory = null;</b>
&nbsp;
&nbsp;    // smoke clouds
<b class="fc">&nbsp;    private List&lt;SmokeCloud&gt; smokeCloudList = new CopyOnWriteArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    transient private Vector&lt;GameListener&gt; gameListeners = new Vector&lt;GameListener&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor
&nbsp;     */
<b class="fc">&nbsp;    public Game() {</b>
&nbsp;        // empty
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Added public accessors for external game id
&nbsp;    public int getExternalGameId() {
<b class="nc">&nbsp;        return externalGameId;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setExternalGameId(int value) {
<b class="nc">&nbsp;        externalGameId = value;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public IBoard getBoard() {
<b class="nc">&nbsp;        return board;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setBoard(IBoard board) {
<b class="nc">&nbsp;        IBoard oldBoard = this.board;</b>
<b class="nc">&nbsp;        this.board = board;</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardNewEvent(this, oldBoard, board));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean containsMinefield(Coords coords) {
<b class="nc">&nbsp;        return minefields.containsKey(coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Minefield&gt; getMinefields(Coords coords) {
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; mfs = minefields.get(coords);</b>
<b class="nc">&nbsp;        if (mfs == null) {</b>
<b class="nc">&nbsp;            return new Vector&lt;Minefield&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        return mfs;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNbrMinefields(Coords coords) {
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; mfs = minefields.get(coords);</b>
<b class="nc">&nbsp;        if (mfs == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return mfs.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the coordinates of all mined hexes in the game.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the &lt;code&gt;Coords&lt;/code&gt; containing
&nbsp;     * minefields. This will not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    public Enumeration&lt;Coords&gt; getMinedCoords() {
<b class="nc">&nbsp;        return minefields.keys();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addMinefield(Minefield mf) {
<b class="nc">&nbsp;        addMinefieldHelper(mf);</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addMinefields(Vector&lt;Minefield&gt; mines) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; mines.size(); i++) {</b>
<b class="nc">&nbsp;            Minefield mf = mines.elementAt(i);</b>
<b class="nc">&nbsp;            addMinefieldHelper(mf);</b>
&nbsp;        }
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setMinefields(Vector&lt;Minefield&gt; minefields) {
<b class="nc">&nbsp;        clearMinefieldsHelper();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; minefields.size(); i++) {</b>
<b class="nc">&nbsp;            Minefield mf = minefields.elementAt(i);</b>
<b class="nc">&nbsp;            addMinefieldHelper(mf);</b>
&nbsp;        }
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void resetMinefieldDensity(Vector&lt;Minefield&gt; newMinefields) {
<b class="nc">&nbsp;        if (newMinefields.size() &lt; 1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; mfs = minefields.get(newMinefields.firstElement()</b>
<b class="nc">&nbsp;                                                            .getCoords());</b>
<b class="nc">&nbsp;        mfs.clear();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; newMinefields.size(); i++) {</b>
<b class="nc">&nbsp;            Minefield mf = newMinefields.elementAt(i);</b>
<b class="nc">&nbsp;            addMinefieldHelper(mf);</b>
&nbsp;        }
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void addMinefieldHelper(Minefield mf) {
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; mfs = minefields.get(mf.getCoords());</b>
<b class="nc">&nbsp;        if (mfs == null) {</b>
<b class="nc">&nbsp;            mfs = new Vector&lt;Minefield&gt;();</b>
<b class="nc">&nbsp;            mfs.addElement(mf);</b>
<b class="nc">&nbsp;            minefields.put(mf.getCoords(), mfs);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        mfs.addElement(mf);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeMinefield(Minefield mf) {
<b class="nc">&nbsp;        removeMinefieldHelper(mf);</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeMinefieldHelper(Minefield mf) {
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; mfs = minefields.get(mf.getCoords());</b>
<b class="nc">&nbsp;        if (mfs == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;Minefield&gt; e = mfs.elements();</b>
<b class="nc">&nbsp;        while (e.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Minefield mftemp = e.nextElement();</b>
<b class="nc">&nbsp;            if (mftemp.equals(mf)) {</b>
<b class="nc">&nbsp;                mfs.removeElement(mftemp);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (mfs.isEmpty()) {</b>
<b class="nc">&nbsp;            minefields.remove(mf.getCoords());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearMinefields() {
<b class="nc">&nbsp;        clearMinefieldsHelper();</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void clearMinefieldsHelper() {
<b class="nc">&nbsp;        minefields.clear();</b>
<b class="nc">&nbsp;        vibrabombs.removeAllElements();</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;IPlayer&gt; iter = getPlayers();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            IPlayer player = iter.nextElement();</b>
<b class="nc">&nbsp;            player.removeMinefields();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Vector&lt;Minefield&gt; getVibrabombs() {
<b class="nc">&nbsp;        return vibrabombs;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addVibrabomb(Minefield mf) {
<b class="nc">&nbsp;        vibrabombs.addElement(mf);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeVibrabomb(Minefield mf) {
<b class="nc">&nbsp;        vibrabombs.removeElement(mf);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean containsVibrabomb(Minefield mf) {
<b class="nc">&nbsp;        return vibrabombs.contains(mf);</b>
&nbsp;    }
&nbsp;
&nbsp;    public GameOptions getOptions() {
<b class="nc">&nbsp;        return options;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOptions(GameOptions options) {
<b class="nc">&nbsp;        if (null == options) {</b>
<b class="nc">&nbsp;            System.err.println(&quot;Can&#39;t set the game options to null!&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.options = options;</b>
<b class="nc">&nbsp;            processGameEvent(new GameSettingsChangeEvent(this));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Return an enumeration of teams in the game
&nbsp;     */
&nbsp;    public Enumeration&lt;Team&gt; getTeams() {
<b class="nc">&nbsp;        return teams.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the current number of teams in the game.
&nbsp;     */
&nbsp;    public int getNoOfTeams() {
<b class="nc">&nbsp;        return teams.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This returns a clone of the vector of teams. Each element is one of the
&nbsp;     * teams in the game.
&nbsp;     */
&nbsp;    public List&lt;Team&gt; getTeamsVector() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(teams);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a players team Note: may return null if player has no team
&nbsp;     */
&nbsp;    public Team getTeamForPlayer(IPlayer p) {
<b class="nc">&nbsp;        for (Team team : teams) {</b>
<b class="nc">&nbsp;            for (Enumeration&lt;IPlayer&gt; j = team.getPlayers(); j.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                final IPlayer player = j.nextElement();</b>
<b class="nc">&nbsp;                if (p == player) {</b>
<b class="nc">&nbsp;                    return team;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set up the teams vector. Each player on a team (Team 1 .. Team X) is
&nbsp;     * placed in the appropriate vector. Any player on &#39;No Team&#39;, is placed in
&nbsp;     * their own object
&nbsp;     */
&nbsp;    public void setupTeams() {
<b class="nc">&nbsp;        Vector&lt;Team&gt; initTeams = new Vector&lt;Team&gt;();</b>
<b class="nc">&nbsp;        boolean useTeamInit = getOptions().getOption(OptionsConstants.BASE_TEAM_INITIATIVE)</b>
<b class="nc">&nbsp;                                          .booleanValue();</b>
&nbsp;
&nbsp;        // Get all NO_TEAM players. If team_initiative is false, all
&nbsp;        // players are on their own teams for initiative purposes.
<b class="nc">&nbsp;        for (Enumeration&lt;IPlayer&gt; i = getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final IPlayer player = i.nextElement();</b>
&nbsp;            // Ignore players not on a team
<b class="nc">&nbsp;            if (player.getTeam() == IPlayer.TEAM_UNASSIGNED) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!useTeamInit || (player.getTeam() == IPlayer.TEAM_NONE)) {</b>
<b class="nc">&nbsp;                Team new_team = new Team(IPlayer.TEAM_NONE);</b>
<b class="nc">&nbsp;                new_team.addPlayer(player);</b>
<b class="nc">&nbsp;                initTeams.addElement(new_team);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (useTeamInit) {</b>
&nbsp;            // Now, go through all the teams, and add the appropriate player
<b class="nc">&nbsp;            for (int t = IPlayer.TEAM_NONE + 1; t &lt; IPlayer.MAX_TEAMS; t++) {</b>
<b class="nc">&nbsp;                Team new_team = null;</b>
<b class="nc">&nbsp;                for (Enumeration&lt;IPlayer&gt; i = getPlayers(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                    final IPlayer player = i.nextElement();</b>
<b class="nc">&nbsp;                    if (player.getTeam() == t) {</b>
<b class="nc">&nbsp;                        if (new_team == null) {</b>
<b class="nc">&nbsp;                            new_team = new Team(t);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        new_team.addPlayer(player);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (new_team != null) {</b>
<b class="nc">&nbsp;                    initTeams.addElement(new_team);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // May need to copy state over from previous teams, such as initiative
<b class="nc">&nbsp;        if ((teams != null) &amp;&amp; (getPhase() != Phase.PHASE_LOUNGE)) {</b>
<b class="nc">&nbsp;            for (Team newTeam : initTeams) {</b>
<b class="nc">&nbsp;                for (Team oldTeam : teams) {</b>
<b class="nc">&nbsp;                    if (newTeam.equals(oldTeam)) {</b>
<b class="nc">&nbsp;                        newTeam.setInitiative(oldTeam.getInitiative());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        teams = initTeams;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Return an enumeration of player in the game
&nbsp;     */
&nbsp;    public Enumeration&lt;IPlayer&gt; getPlayers() {
<b class="nc">&nbsp;        return players.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the players vector
&nbsp;     */
&nbsp;    public Vector&lt;IPlayer&gt; getPlayersVector() {
<b class="nc">&nbsp;        return players;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the current number of active players in the game.
&nbsp;     */
&nbsp;    public int getNoOfPlayers() {
<b class="nc">&nbsp;        return players.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the individual player assigned the id parameter.
&nbsp;     */
&nbsp;    public IPlayer getPlayer(int id) {
<b class="nc">&nbsp;        if (IPlayer.PLAYER_NONE == id) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return playerIds.get(Integer.valueOf(id));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addPlayer(int id, IPlayer player) {
<b class="nc">&nbsp;        player.setGame(this);</b>
<b class="nc">&nbsp;        players.addElement(player);</b>
<b class="nc">&nbsp;        playerIds.put(Integer.valueOf(id), player);</b>
<b class="nc">&nbsp;        setupTeams();</b>
<b class="nc">&nbsp;        updatePlayer(player);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setPlayer(int id, IPlayer player) {
<b class="nc">&nbsp;        final IPlayer oldPlayer = getPlayer(id);</b>
<b class="nc">&nbsp;        player.setGame(this);</b>
<b class="nc">&nbsp;        players.setElementAt(player, players.indexOf(oldPlayer));</b>
<b class="nc">&nbsp;        playerIds.put(Integer.valueOf(id), player);</b>
<b class="nc">&nbsp;        setupTeams();</b>
<b class="nc">&nbsp;        updatePlayer(player);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void updatePlayer(IPlayer player) {
<b class="nc">&nbsp;        processGameEvent(new GamePlayerChangeEvent(this, player));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removePlayer(int id) {
<b class="nc">&nbsp;        IPlayer playerToRemove = getPlayer(id);</b>
<b class="nc">&nbsp;        players.removeElement(playerToRemove);</b>
<b class="nc">&nbsp;        playerIds.remove(Integer.valueOf(id));</b>
<b class="nc">&nbsp;        setupTeams();</b>
<b class="nc">&nbsp;        processGameEvent(new GamePlayerChangeEvent(this, playerToRemove));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of entities owned by the player, regardless of their
&nbsp;     * status, as long as they are in the game.
&nbsp;     */
&nbsp;    public int getEntitiesOwnedBy(IPlayer player) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(player)) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of entities owned by the player, regardless of their
&nbsp;     * status.
&nbsp;     */
&nbsp;    public int getAllEntitiesOwnedBy(IPlayer player) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(player)) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(player)) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of non-destroyed entityes owned by the player
&nbsp;     */
&nbsp;    public int getLiveEntitiesOwnedBy(IPlayer player) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(player) &amp;&amp; !entity.isDestroyed()</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isCarcass()) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of non-destroyed entities owned by the player,
&nbsp;     * including entities not yet deployed. Ignore offboard units and captured
&nbsp;     * Mek pilots.
&nbsp;     */
&nbsp;    public int getLiveDeployedEntitiesOwnedBy(IPlayer player) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(player) &amp;&amp; !entity.isDestroyed()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isCarcass()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isOffBoard() &amp;&amp; !entity.isCaptured()) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of non-destroyed deployed entities owned by the
&nbsp;     * player. Ignore offboard units and captured Mek pilots.
&nbsp;     */
&nbsp;    public int getLiveCommandersOwnedBy(IPlayer player) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.getOwner().equals(player) &amp;&amp; !entity.isDestroyed()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isCarcass()</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isCommander() &amp;&amp; !entity.isOffBoard()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isCaptured()) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the player has a valid unit with the Tactical Genius
&nbsp;     * pilot special ability.
&nbsp;     */
&nbsp;    public boolean hasTacticalGenius(IPlayer player) {
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.hasAbility(OptionsConstants.MISC_TACTICAL_GENIUS)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.getOwner().equals(player) &amp;&amp; !entity.isDestroyed() &amp;&amp; entity.isDeployed()</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isCarcass() &amp;&amp; !entity.getCrew().isUnconscious()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get a vector of entity objects that are &quot;acceptable&quot; to attack with this
&nbsp;     * entity
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getValidTargets(Entity entity) {
<b class="nc">&nbsp;        List&lt;Entity&gt; ents = new ArrayList&lt;Entity&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        boolean friendlyFire = getOptions().booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE);</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity otherEntity : entities) {</b>
&nbsp;            // Even if friendly fire is acceptable, do not shoot yourself
&nbsp;            // Enemy units not on the board can not be shot.
<b class="nc">&nbsp;            if ((otherEntity.getPosition() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; !otherEntity.isOffBoard()</b>
<b class="nc">&nbsp;                    &amp;&amp; otherEntity.isTargetable()</b>
<b class="nc">&nbsp;                    &amp;&amp; !otherEntity.isHidden()</b>
<b class="nc">&nbsp;                    &amp;&amp; !otherEntity.isSensorReturn(entity.getOwner())</b>
<b class="nc">&nbsp;                    &amp;&amp; otherEntity.hasSeenEntity(entity.getOwner())</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.isEnemyOf(otherEntity) || (friendlyFire &amp;&amp; (entity</b>
<b class="nc">&nbsp;                            .getId() != otherEntity.getId())))) {</b>
&nbsp;                // Air to Ground - target must be on flight path
<b class="nc">&nbsp;                if (Compute.isAirToGround(entity, otherEntity)) {</b>
<b class="nc">&nbsp;                    if (entity.getPassedThrough().contains(</b>
<b class="nc">&nbsp;                            otherEntity.getPosition())) {</b>
<b class="nc">&nbsp;                        ents.add(otherEntity);</b>
&nbsp;                    }                
&nbsp;                } else {
<b class="nc">&nbsp;                    ents.add(otherEntity);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return Collections.unmodifiableList(ents);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this phase has turns. If false, the phase is simply
&nbsp;     * waiting for everybody to declare &quot;done&quot;.
&nbsp;     */
&nbsp;    public boolean phaseHasTurns(IGame.Phase thisPhase) {
<b class="nc">&nbsp;        switch (thisPhase) {</b>
&nbsp;            case PHASE_SET_ARTYAUTOHITHEXES:
&nbsp;            case PHASE_DEPLOY_MINEFIELDS:
&nbsp;            case PHASE_DEPLOYMENT:
&nbsp;            case PHASE_MOVEMENT:
&nbsp;            case PHASE_FIRING:
&nbsp;            case PHASE_PHYSICAL:
&nbsp;            case PHASE_TARGETING:
&nbsp;            case PHASE_OFFBOARD:
<b class="nc">&nbsp;                return true;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean isPhaseSimultaneous() {
<b class="nc">&nbsp;        return phase.isPhaseSimultaneous(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current GameTurn object
&nbsp;     */
&nbsp;    public GameTurn getTurn() {
<b class="nc">&nbsp;        if ((turnIndex &lt; 0) || (turnIndex &gt;= turnVector.size())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return turnVector.elementAt(turnIndex);</b>
&nbsp;    }
&nbsp;
&nbsp;    public GameTurn getTurnForPlayer(int pn) {
<b class="nc">&nbsp;        for (int i = turnIndex; i &lt; turnVector.size(); i++) {</b>
<b class="nc">&nbsp;            GameTurn gt = turnVector.get(i);</b>
<b class="nc">&nbsp;            if (gt.isValid(pn, this)) {</b>
<b class="nc">&nbsp;                return gt;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Changes to the next turn, returning it.
&nbsp;     */
&nbsp;    public GameTurn changeToNextTurn() {
<b class="nc">&nbsp;        turnIndex++;</b>
<b class="nc">&nbsp;        return getTurn();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the turn index to -1 (awaiting first turn)
&nbsp;     */
&nbsp;    public void resetTurnIndex() {
<b class="nc">&nbsp;        turnIndex = -1;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if there is a turn after the current one
&nbsp;     */
&nbsp;    public boolean hasMoreTurns() {
<b class="nc">&nbsp;        return turnVector.size() &gt; turnIndex;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts a turn that will come directly after the current one
&nbsp;     */
&nbsp;    public void insertNextTurn(GameTurn turn) {
<b class="nc">&nbsp;        turnVector.insertElementAt(turn, turnIndex + 1);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts a turn after the specific index
&nbsp;     */
&nbsp;    public void insertTurnAfter(GameTurn turn, int index) {
<b class="nc">&nbsp;        if ((index + 1) &gt;= turnVector.size()) {</b>
<b class="nc">&nbsp;            turnVector.add(turn);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            turnVector.insertElementAt(turn, index + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void swapTurnOrder(int index1, int index2) {
<b class="nc">&nbsp;        GameTurn turn1 = turnVector.get(index1);</b>
<b class="nc">&nbsp;        GameTurn turn2 = turnVector.get(index2);</b>
<b class="nc">&nbsp;        turnVector.set(index2, turn1);</b>
<b class="nc">&nbsp;        turnVector.set(index1, turn2);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of the current turn list
&nbsp;     */
&nbsp;    public Enumeration&lt;GameTurn&gt; getTurns() {
<b class="nc">&nbsp;        return turnVector.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current turn index
&nbsp;     */
&nbsp;    public int getTurnIndex() {
<b class="nc">&nbsp;        return turnIndex;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the current turn index
&nbsp;     */
&nbsp;    public void setTurnIndex(int turnIndex, int prevPlayerId) {
&nbsp;        // FIXME: occasionally getTurn() returns null. Handle that case
&nbsp;        // intelligently.
<b class="nc">&nbsp;        this.turnIndex = turnIndex;</b>
<b class="nc">&nbsp;        processGameEvent(new GameTurnChangeEvent(this, getPlayer(getTurn()</b>
<b class="nc">&nbsp;                .getPlayerNum()), prevPlayerId));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current turn vector
&nbsp;     */
&nbsp;    public List&lt;GameTurn&gt; getTurnVector() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(turnVector);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the current turn vector
&nbsp;     */
&nbsp;    public void setTurnVector(List&lt;GameTurn&gt; turnVector) {
<b class="nc">&nbsp;        this.turnVector.clear();</b>
<b class="nc">&nbsp;        for (GameTurn turn : turnVector) {</b>
<b class="nc">&nbsp;            this.turnVector.add(turn);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Phase getPhase() {
<b class="nc">&nbsp;        return phase;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPhase(Phase phase) {
<b class="nc">&nbsp;        final Phase oldPhase = this.phase;</b>
<b class="nc">&nbsp;        this.phase = phase;</b>
&nbsp;        // Handle phase-specific items.
<b class="nc">&nbsp;        switch (phase) {</b>
&nbsp;            case PHASE_LOUNGE:
<b class="nc">&nbsp;                reset();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_TARGETING:
<b class="nc">&nbsp;                resetActions();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_MOVEMENT:
<b class="nc">&nbsp;                resetActions();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_FIRING:
<b class="nc">&nbsp;                resetActions();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_PHYSICAL:
<b class="nc">&nbsp;                resetActions();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_DEPLOYMENT:
<b class="nc">&nbsp;                resetActions();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case PHASE_INITIATIVE:
<b class="nc">&nbsp;                resetActions();</b>
<b class="nc">&nbsp;                resetCharges();</b>
<b class="nc">&nbsp;                resetRams();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            // TODO Is there better solution to handle charges?
&nbsp;            case PHASE_PHYSICAL_REPORT:
&nbsp;            case PHASE_END:
<b class="nc">&nbsp;                resetCharges();</b>
<b class="nc">&nbsp;                resetRams();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        processGameEvent(new GamePhaseChangeEvent(this, oldPhase, phase));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Phase getLastPhase() {
<b class="nc">&nbsp;        return lastPhase;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLastPhase(Phase lastPhase) {
<b class="nc">&nbsp;        this.lastPhase = lastPhase;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setDeploymentComplete(boolean deploymentComplete) {
<b class="nc">&nbsp;        this.deploymentComplete = deploymentComplete;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isDeploymentComplete() {
<b class="nc">&nbsp;        return deploymentComplete;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets up up the hashtable of who deploys when
&nbsp;     */
&nbsp;    public void setupRoundDeployment() {
<b class="nc">&nbsp;        deploymentTable = new Hashtable&lt;Integer, Vector&lt;Entity&gt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity ent : entities) {</b>
<b class="nc">&nbsp;            if (ent.isDeployed()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Vector&lt;Entity&gt; roundVec = deploymentTable.get(Integer.valueOf(ent.getDeployRound()));</b>
&nbsp;
<b class="nc">&nbsp;            if (null == roundVec) {</b>
<b class="nc">&nbsp;                roundVec = new Vector&lt;Entity&gt;();</b>
<b class="nc">&nbsp;                deploymentTable.put(ent.getDeployRound(), roundVec);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            roundVec.addElement(ent);</b>
<b class="nc">&nbsp;            lastDeploymentRound = Math.max(lastDeploymentRound,</b>
<b class="nc">&nbsp;                                           ent.getDeployRound());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if we&#39;ve past our deployment completion
&nbsp;     */
&nbsp;    public void checkForCompleteDeployment() {
<b class="nc">&nbsp;        setDeploymentComplete(lastDeploymentRound &lt; getRoundCount());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if we should deploy this round
&nbsp;     */
&nbsp;    public boolean shouldDeployThisRound() {
<b class="nc">&nbsp;        return shouldDeployForRound(getRoundCount());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean shouldDeployForRound(int round) {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; vec = getEntitiesToDeployForRound(round);</b>
&nbsp;
<b class="nc">&nbsp;        return (((null == vec) || (vec.size() == 0)) ? false : true);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Vector&lt;Entity&gt; getEntitiesToDeployForRound(int round) {
<b class="nc">&nbsp;        return deploymentTable.get(Integer.valueOf(round));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clear this round from this list of entities to deploy
&nbsp;     */
&nbsp;    public void clearDeploymentThisRound() {
<b class="nc">&nbsp;        deploymentTable.remove(Integer.valueOf(getRoundCount()));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of entities that have not yet deployed
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getUndeployedEntities() {
<b class="nc">&nbsp;        List&lt;Entity&gt; entList = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        Enumeration&lt;Vector&lt;Entity&gt;&gt; iter = deploymentTable.elements();</b>
&nbsp;
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Vector&lt;Entity&gt; vecTemp = iter.nextElement();</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = 0; i &lt; vecTemp.size(); i++) {</b>
<b class="nc">&nbsp;                entList.add(vecTemp.elementAt(i));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return Collections.unmodifiableList(entList);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of all the entites in the game.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getEntities() {
<b class="nc">&nbsp;        return entities.iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Entity getPreviousEntityFromList(Entity current) {
<b class="nc">&nbsp;        if ((current != null) &amp;&amp; entities.contains(current)) {</b>
<b class="nc">&nbsp;            int prev = entities.indexOf(current) - 1;</b>
<b class="nc">&nbsp;            if (prev &lt; 0) {</b>
<b class="nc">&nbsp;                prev = entities.size() - 1; // wrap around to end</b>
&nbsp;            }
<b class="nc">&nbsp;            return entities.get(prev);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Entity getNextEntityFromList(Entity current) {
<b class="nc">&nbsp;        if ((current != null) &amp;&amp; entities.contains(current)) {</b>
<b class="nc">&nbsp;            int next = entities.indexOf(current) + 1;</b>
<b class="nc">&nbsp;            if (next &gt;= entities.size()) {</b>
<b class="nc">&nbsp;                next = 0; // wrap-around to begining</b>
&nbsp;            }
<b class="nc">&nbsp;            return entities.get(next);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actual vector for the entities
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getEntitiesVector() {
<b class="fc">&nbsp;        return Collections.unmodifiableList(entities);</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void setEntitiesVector(List&lt;Entity&gt; entities) {
&nbsp;        //checkPositionCacheConsistency();
<b class="nc">&nbsp;        this.entities.clear();</b>
<b class="nc">&nbsp;        this.entities.addAll(entities);</b>
<b class="nc">&nbsp;        reindexEntities();</b>
<b class="nc">&nbsp;        resetEntityPositionLookup();</b>
<b class="nc">&nbsp;        processGameEvent(new GameEntityNewEvent(this, entities));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actual vector for the out-of-game entities
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getOutOfGameEntitiesVector() {
<b class="nc">&nbsp;        return vOutOfGame;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Swap out the current list of dead (or fled) units for a new one.
&nbsp;     *
&nbsp;     * @param vOutOfGame - the new &lt;code&gt;Vector&lt;/code&gt; of dead or fled units. This
&nbsp;     *                   value should &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @throws IllegalArgumentException if the new list is &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    public void setOutOfGameEntitiesVector(List&lt;Entity&gt; vOutOfGame) {
<b class="nc">&nbsp;        assert (vOutOfGame != null) : &quot;New out-of-game list should not be null.&quot;;</b>
<b class="nc">&nbsp;        Vector&lt;Entity&gt; newOutOfGame = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Add entities for the existing players to the game.
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            int ownerId = entity.getOwnerId();</b>
<b class="nc">&nbsp;            if ((ownerId != Entity.NONE) &amp;&amp; (getPlayer(ownerId) != null)) {</b>
<b class="nc">&nbsp;                entity.setGame(this);</b>
<b class="nc">&nbsp;                newOutOfGame.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        this.vOutOfGame = newOutOfGame;</b>
<b class="nc">&nbsp;        processGameEvent(new GameEntityNewOffboardEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an out-of-game entity.
&nbsp;     *
&nbsp;     * @param id the &lt;code&gt;int&lt;/code&gt; ID of the out-of-game entity.
&nbsp;     * @return the out-of-game &lt;code&gt;Entity&lt;/code&gt; with that ID. If no
&nbsp;     * out-of-game entity has that ID, returns a &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    public Entity getOutOfGameEntity(int id) {
<b class="nc">&nbsp;        Entity match = null;</b>
<b class="nc">&nbsp;        Enumeration&lt;Entity&gt; iter = vOutOfGame.elements();</b>
<b class="nc">&nbsp;        while ((null == match) &amp;&amp; iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.nextElement();</b>
<b class="nc">&nbsp;            if (id == entity.getId()) {</b>
<b class="nc">&nbsp;                match = entity;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return match;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a &lt;code&gt;Vector&lt;/code&gt; containing the &lt;code&gt;Entity&lt;/code&gt;s that
&nbsp;     * are in the same C3 network as the passed-in unit. The output will contain
&nbsp;     * the passed-in unit, if the unit has a C3 computer. If the unit has no C3
&nbsp;     * computer, the output will be empty (but it will never be
&nbsp;     * &lt;code&gt;null&lt;/code&gt;).
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; whose C3 network co- members is
&nbsp;     *               required. This value may be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; that will contain all other
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt;s that are in the same C3 network as the
&nbsp;     * passed-in unit. This &lt;code&gt;Vector&lt;/code&gt; may be empty, but it
&nbsp;     * will not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @see #getC3SubNetworkMembers(Entity)
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getC3NetworkMembers(Entity entity) {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; members = new Vector&lt;Entity&gt;();</b>
&nbsp;        //WOR
&nbsp;        // Does the unit have a C3 computer?
<b class="nc">&nbsp;        if ((entity != null) &amp;&amp; (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3())) {</b>
&nbsp;
&nbsp;            // Walk throught the entities in the game, and add all
&nbsp;            // members of the C3 network to the output Vector.
<b class="nc">&nbsp;            for (Entity unit : entities) {</b>
<b class="nc">&nbsp;                if (entity.equals(unit) || entity.onSameC3NetworkAs(unit)) {</b>
<b class="nc">&nbsp;                    members.addElement(unit);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        } // End entity-has-C3
&nbsp;
<b class="nc">&nbsp;        return members;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a &lt;code&gt;Vector&lt;/code&gt; containing the &lt;code&gt;Entity&lt;/code&gt;s that
&nbsp;     * are in the C3 sub-network under the passed-in unit. The output will
&nbsp;     * contain the passed-in unit, if the unit has a C3 computer. If the unit
&nbsp;     * has no C3 computer, the output will be empty (but it will never be
&nbsp;     * &lt;code&gt;null&lt;/code&gt;). If the passed-in unit is a company commander or a
&nbsp;     * member of a C3i network, this call is the same as
&nbsp;     * &lt;code&gt;getC3NetworkMembers&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; whose C3 network sub- members is
&nbsp;     *               required. This value may be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; that will contain all other
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt;s that are in the same C3 network under the
&nbsp;     * passed-in unit. This &lt;code&gt;Vector&lt;/code&gt; may be empty, but it
&nbsp;     * will not be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @see #getC3NetworkMembers(Entity)
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getC3SubNetworkMembers(Entity entity) {
&nbsp;        //WOR
&nbsp;        // Handle null, C3i, NC3, and company commander units.
<b class="nc">&nbsp;        if ((entity == null) || entity.hasC3i() || entity.hasNavalC3() || entity.hasActiveNovaCEWS() || entity.C3MasterIs(entity)) {</b>
<b class="nc">&nbsp;            return getC3NetworkMembers(entity);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Entity&gt; members = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Does the unit have a C3 computer?
<b class="nc">&nbsp;        if (entity.hasC3()) {</b>
&nbsp;
&nbsp;            // Walk throught the entities in the game, and add all
&nbsp;            // sub-members of the C3 network to the output Vector.
<b class="nc">&nbsp;            for (Entity unit : entities) {</b>
<b class="nc">&nbsp;                if (entity.equals(unit) || unit.C3MasterIs(entity)) {</b>
<b class="nc">&nbsp;                    members.addElement(unit);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        } // End entity-has-C3
&nbsp;
<b class="nc">&nbsp;        return members;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt; of
&nbsp;     * each unit in this &lt;code&gt;Game&lt;/code&gt; to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt;s at that positions. Units that have no position (e.g.
&nbsp;     * loaded units) will not be in the map.
&nbsp;     *
&nbsp;     * @return a &lt;code&gt;Hashtable&lt;/code&gt; that maps the &lt;code&gt;Coords&lt;/code&gt;
&nbsp;     * positions or each unit in the game to a &lt;code&gt;Vector&lt;/code&gt; of
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt;s at that position.
&nbsp;     */
&nbsp;    public Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; getPositionMap() {
<b class="nc">&nbsp;        Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt; positionMap = new Hashtable&lt;Coords, Vector&lt;Entity&gt;&gt;();</b>
<b class="nc">&nbsp;        Vector&lt;Entity&gt; atPos = null;</b>
&nbsp;
&nbsp;        // Walk through the entities in this game.
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
&nbsp;            // Get the vector for this entity&#39;s position.
<b class="nc">&nbsp;            final Coords coords = entity.getPosition();</b>
<b class="nc">&nbsp;            if (coords != null) {</b>
<b class="nc">&nbsp;                atPos = positionMap.get(coords);</b>
&nbsp;
&nbsp;                // If this is the first entity at this position,
&nbsp;                // create the vector and add it to the map.
<b class="nc">&nbsp;                if (atPos == null) {</b>
<b class="nc">&nbsp;                    atPos = new Vector&lt;Entity&gt;();</b>
<b class="nc">&nbsp;                    positionMap.put(coords, atPos);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Add the entity to the vector for this position.
<b class="nc">&nbsp;                atPos.addElement(entity);</b>
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;        } // Handle the next entity.</b>
&nbsp;
&nbsp;        // Return the map.
<b class="nc">&nbsp;        return positionMap;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of salvagable entities.
&nbsp;     */
&nbsp;    public Enumeration&lt;Entity&gt; getGraveyardEntities() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; graveyard = new Vector&lt;Entity&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            if ((entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_SALVAGEABLE)</b>
<b class="nc">&nbsp;                || (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_EJECTED)) {</b>
<b class="nc">&nbsp;                graveyard.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return graveyard.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of wrecked entities.
&nbsp;     */
&nbsp;    public Enumeration&lt;Entity&gt; getWreckedEntities() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; wrecks = new Vector&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            if ((entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_SALVAGEABLE)</b>
<b class="nc">&nbsp;                || (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_EJECTED)</b>
<b class="nc">&nbsp;                || (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_DEVASTATED)) {</b>
<b class="nc">&nbsp;                wrecks.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return wrecks.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of entities that have retreated
&nbsp;     */
&nbsp; // TODO: Correctly implement &quot;Captured&quot; Entities
&nbsp;    public Enumeration&lt;Entity&gt; getRetreatedEntities() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; sanctuary = new Vector&lt;Entity&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            if ((entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_IN_RETREAT)</b>
<b class="nc">&nbsp;                || (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_CAPTURED)</b>
<b class="nc">&nbsp;                || (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_PUSHED)) {</b>
<b class="nc">&nbsp;                sanctuary.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return sanctuary.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of entities that were utterly destroyed
&nbsp;     */
&nbsp;    public Enumeration&lt;Entity&gt; getDevastatedEntities() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; smithereens = new Vector&lt;Entity&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            if (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_DEVASTATED) {</b>
<b class="nc">&nbsp;                smithereens.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return smithereens.elements();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns an enumeration of &quot;carcass&quot; entities, i.e., vehicles with dead
&nbsp;     * crews that are still on the map.
&nbsp;     */
&nbsp;    public Enumeration&lt;Entity&gt; getCarcassEntities() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; carcasses = new Vector&lt;Entity&gt;();</b>
&nbsp;        
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.isCarcass()) {</b>
<b class="nc">&nbsp;                carcasses.addElement(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return carcasses.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the current number of entities in the game.
&nbsp;     */
&nbsp;    public int getNoOfEntities() {
<b class="nc">&nbsp;        return entities.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the appropriate target for this game given a type and id
&nbsp;     */
&nbsp;    public Targetable getTarget(int nType, int nID) {
&nbsp;        try {
<b class="nc">&nbsp;            switch (nType) {</b>
&nbsp;                case Targetable.TYPE_ENTITY:
<b class="nc">&nbsp;                    return getEntity(nID);</b>
&nbsp;                case Targetable.TYPE_HEX_CLEAR:
&nbsp;                case Targetable.TYPE_HEX_IGNITE:
&nbsp;                case Targetable.TYPE_HEX_BOMB:
&nbsp;                case Targetable.TYPE_MINEFIELD_DELIVER:
&nbsp;                case Targetable.TYPE_FLARE_DELIVER:
&nbsp;                case Targetable.TYPE_HEX_EXTINGUISH:
&nbsp;                case Targetable.TYPE_HEX_ARTILLERY:
&nbsp;                case Targetable.TYPE_HEX_SCREEN:
&nbsp;                case Targetable.TYPE_HEX_AERO_BOMB:
&nbsp;                case Targetable.TYPE_HEX_TAG:
<b class="nc">&nbsp;                    return new HexTarget(HexTarget.idToCoords(nID), board,</b>
&nbsp;                                         nType);
&nbsp;                case Targetable.TYPE_FUEL_TANK:
&nbsp;                case Targetable.TYPE_FUEL_TANK_IGNITE:
&nbsp;                case Targetable.TYPE_BUILDING:
&nbsp;                case Targetable.TYPE_BLDG_IGNITE:
&nbsp;                case Targetable.TYPE_BLDG_TAG:
<b class="nc">&nbsp;                    return new BuildingTarget(BuildingTarget.idToCoords(nID),</b>
&nbsp;                                              board, nType);
&nbsp;                case Targetable.TYPE_MINEFIELD_CLEAR:
<b class="nc">&nbsp;                    return new MinefieldTarget(MinefieldTarget.idToCoords(nID),</b>
&nbsp;                                               board);
&nbsp;                case Targetable.TYPE_INARC_POD:
<b class="nc">&nbsp;                    return INarcPod.idToInstance(nID);</b>
&nbsp;                default:
<b class="nc">&nbsp;                    return null;</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IllegalArgumentException t) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity with the given id number, if any.
&nbsp;     */
&nbsp;
&nbsp;    public Entity getEntity(int id) {
<b class="nc">&nbsp;        return entityIds.get(Integer.valueOf(id));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * looks for an entity by id number even if out of the game
&nbsp;     */
&nbsp;    public Entity getEntityFromAllSources(int id) {
<b class="nc">&nbsp;        Entity en = getEntity(id);</b>
<b class="nc">&nbsp;        if(null == en) {</b>
<b class="nc">&nbsp;            for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;                if(entity.getId() == id) {</b>
<b class="nc">&nbsp;                    return entity;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return en;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void addEntities(List&lt;Entity&gt; entities) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; entities.size(); i++) {</b>
<b class="nc">&nbsp;            addEntity(entities.get(i), false);</b>
&nbsp;        }
&nbsp;        // We need to delay calculating BV until all units have been added because
&nbsp;        // C3 network connections will be cleared if the master is not in the game yet.
<b class="nc">&nbsp;        entities.forEach(e -&gt; e.setInitialBV(e.calculateBattleValue(false, false)));</b>
<b class="nc">&nbsp;        processGameEvent(new GameEntityNewEvent(this, entities));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addEntity(int id, Entity entity) {
&nbsp;        // Disregard the passed id, addEntity(Entity) pulls the id from the
&nbsp;        //  Entity instance.
<b class="nc">&nbsp;        addEntity(entity);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addEntity(Entity entity) {
<b class="nc">&nbsp;        addEntity(entity, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public synchronized void addEntity(Entity entity, boolean genEvent) {
<b class="nc">&nbsp;        entity.setGame(this);</b>
<b class="nc">&nbsp;        if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            ((Mech) entity).setBAGrabBars();</b>
<b class="nc">&nbsp;            ((Mech) entity).setProtomechClampMounts();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            ((Tank) entity).setBAGrabBars();</b>
<b class="nc">&nbsp;            ((Tank) entity).setTrailerHitches();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Add magnetic clamp mounts
<b class="nc">&nbsp;        if ((entity instanceof Mech) &amp;&amp; !entity.isOmni()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.hasBattleArmorHandles()) {</b>
<b class="nc">&nbsp;            entity.addTransporter(new ClampMountMech());</b>
<b class="nc">&nbsp;        } else if ((entity instanceof Tank) &amp;&amp; !entity.isOmni()</b>
<b class="nc">&nbsp;                &amp;&amp; !entity.hasBattleArmorHandles()) {</b>
<b class="nc">&nbsp;            entity.addTransporter(new ClampMountTank());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        entity.setGameOptions();</b>
<b class="nc">&nbsp;        if (entity.getC3UUIDAsString() == null) { // We don&#39;t want to be</b>
&nbsp;            // resetting a UUID that
&nbsp;            // exists already!
<b class="nc">&nbsp;            entity.setC3UUID();</b>
&nbsp;        }
&nbsp;        // Add this Entity, ensuring that it&#39;s id is unique
<b class="nc">&nbsp;        int id = entity.getId();</b>
<b class="nc">&nbsp;        if (!entityIds.containsKey(id)) {</b>
<b class="nc">&nbsp;            entityIds.put(Integer.valueOf(id), entity);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            id = getNextEntityId();</b>
<b class="nc">&nbsp;            entity.setId(id);</b>
<b class="nc">&nbsp;            entityIds.put(id, entity);</b>
&nbsp;        }
<b class="nc">&nbsp;        entities.add(entity);</b>
<b class="nc">&nbsp;        updateEntityPositionLookup(entity, null);</b>
&nbsp;
<b class="nc">&nbsp;        if (id &gt; lastEntityId) {</b>
<b class="nc">&nbsp;            lastEntityId = id;</b>
&nbsp;        }
&nbsp;
&nbsp;        // And... lets get this straight now.
<b class="nc">&nbsp;        if ((entity instanceof Mech)</b>
<b class="nc">&nbsp;            &amp;&amp; getOptions().booleanOption(OptionsConstants.RPG_CONDITIONAL_EJECTION)) {</b>
<b class="nc">&nbsp;            ((Mech) entity).setAutoEject(true);</b>
<b class="nc">&nbsp;            if (((Mech) entity).hasCase()</b>
<b class="nc">&nbsp;                || ((Mech) entity).hasCASEIIAnywhere()) {</b>
<b class="nc">&nbsp;                ((Mech) entity).setCondEjectAmmo(false);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ((Mech) entity).setCondEjectAmmo(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            ((Mech) entity).setCondEjectEngine(true);</b>
<b class="nc">&nbsp;            ((Mech) entity).setCondEjectCTDest(true);</b>
<b class="nc">&nbsp;            ((Mech) entity).setCondEjectHeadshot(true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        assert (entities.size() == entityIds.size()) : &quot;Add Entity failed&quot;;</b>
<b class="nc">&nbsp;        if (genEvent) {</b>
<b class="nc">&nbsp;            entity.setInitialBV(entity.calculateBattleValue(false, false));</b>
<b class="nc">&nbsp;            processGameEvent(new GameEntityNewEvent(this, entity));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setEntity(int id, Entity entity) {
<b class="nc">&nbsp;        setEntity(id, entity, null);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public synchronized void setEntity(int id, Entity entity, Vector&lt;UnitLocation&gt; movePath) {
<b class="nc">&nbsp;        final Entity oldEntity = getEntity(id);</b>
<b class="nc">&nbsp;        if (oldEntity == null) {</b>
<b class="nc">&nbsp;            addEntity(entity);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            entity.setGame(this);</b>
<b class="nc">&nbsp;            entities.set(entities.indexOf(oldEntity), entity);</b>
<b class="nc">&nbsp;            entityIds.put(id, entity);</b>
&nbsp;            // Get the collection of positions
<b class="nc">&nbsp;            HashSet&lt;Coords&gt; oldPositions = oldEntity.getOccupiedCoords();</b>
&nbsp;            // Update position lookup table
<b class="nc">&nbsp;            updateEntityPositionLookup(entity, oldPositions);</b>
&nbsp;
&nbsp;            // Not sure if this really required
<b class="nc">&nbsp;            if (id &gt; lastEntityId) {</b>
<b class="nc">&nbsp;                lastEntityId = id;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            processGameEvent(</b>
&nbsp;                    new GameEntityChangeEvent(this, entity, movePath, oldEntity));
&nbsp;        }
<b class="nc">&nbsp;        assert (entities.size() == entityIds.size()) : &quot;Set Entity Failed&quot;;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return int containing an unused entity id
&nbsp;     */
&nbsp;    public int getNextEntityId() {
<b class="nc">&nbsp;        return lastEntityId + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if an entity with the specified id number exists in this
&nbsp;     * game.
&nbsp;     */
&nbsp;    public boolean hasEntity(int entityId) {
<b class="nc">&nbsp;        return entityIds.containsKey(Integer.valueOf(entityId));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove an entity from the master list. If we can&#39;t find that entity,
&nbsp;     * (probably due to double-blind) ignore it.
&nbsp;     */
&nbsp;    public synchronized void removeEntity(int id, int condition) {
&nbsp;        // always attempt to remove the entity with this ID from the entities collection
&nbsp;        // as it may have gotten stuck there.
<b class="nc">&nbsp;        entities.removeIf(ent -&gt; (ent.getId() == id));</b>
&nbsp;        
<b class="nc">&nbsp;        Entity toRemove = getEntity(id);</b>
<b class="nc">&nbsp;        if (toRemove == null) {</b>
&nbsp;            // This next statement has been cluttering up double-blind
&nbsp;            // logs for quite a while now. I&#39;m assuming it&#39;s no longer
&nbsp;            // useful.
&nbsp;            // System.err.println(&quot;Game#removeEntity: could not find entity to
&nbsp;            // remove&quot;);
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        entityIds.remove(Integer.valueOf(id));</b>
<b class="nc">&nbsp;        removeEntityPositionLookup(toRemove);</b>
&nbsp;
<b class="nc">&nbsp;        toRemove.setRemovalCondition(condition);</b>
&nbsp;
&nbsp;        // do not keep never-joined entities
<b class="nc">&nbsp;        if ((vOutOfGame != null)</b>
&nbsp;            &amp;&amp; (condition != IEntityRemovalConditions.REMOVE_NEVER_JOINED)) {
<b class="nc">&nbsp;            vOutOfGame.addElement(toRemove);</b>
&nbsp;        }
&nbsp;
&nbsp;        // We also need to remove it from the list of things to be deployed...
&nbsp;        // we might still be in this list if we never joined the game
<b class="nc">&nbsp;        if (deploymentTable.size() &gt; 0) {</b>
<b class="nc">&nbsp;            Enumeration&lt;Vector&lt;Entity&gt;&gt; iter = deploymentTable.elements();</b>
&nbsp;
<b class="nc">&nbsp;            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Vector&lt;Entity&gt; vec = iter.nextElement();</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = vec.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;                    Entity en = vec.elementAt(i);</b>
&nbsp;
<b class="nc">&nbsp;                    if (en.getId() == id) {</b>
<b class="nc">&nbsp;                        vec.removeElementAt(i);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        processGameEvent(new GameEntityRemoveEvent(this, toRemove));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeEntities(List&lt;Integer&gt; ids, int condition) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; ids.size(); i++) {</b>
<b class="nc">&nbsp;            removeEntity(ids.get(i), condition);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resets this game.
&nbsp;     */
&nbsp;    public synchronized void reset() {
<b class="nc">&nbsp;        uuid = UUID.randomUUID();</b>
&nbsp;
<b class="nc">&nbsp;        roundCount = 0;</b>
&nbsp;
<b class="nc">&nbsp;        entities.clear();</b>
<b class="nc">&nbsp;        entityIds.clear();</b>
<b class="nc">&nbsp;        entityPosLookup.clear();</b>
&nbsp;
<b class="nc">&nbsp;        vOutOfGame.removeAllElements();</b>
&nbsp;
<b class="nc">&nbsp;        turnVector.clear();</b>
<b class="nc">&nbsp;        turnIndex = 0;</b>
&nbsp;
<b class="nc">&nbsp;        resetActions();</b>
<b class="nc">&nbsp;        resetCharges();</b>
<b class="nc">&nbsp;        resetRams();</b>
<b class="nc">&nbsp;        resetPSRs();</b>
<b class="nc">&nbsp;        resetArtilleryAttacks();</b>
<b class="nc">&nbsp;        resetAttacks();</b>
&nbsp;        // removeMinefields();  Broken and bad!
<b class="nc">&nbsp;        clearMinefields();</b>
<b class="nc">&nbsp;        removeArtyAutoHitHexes();</b>
<b class="nc">&nbsp;        flares.removeAllElements();</b>
<b class="nc">&nbsp;        illuminatedPositions.clear();</b>
<b class="nc">&nbsp;        clearAllReports();</b>
<b class="nc">&nbsp;        smokeCloudList.clear();</b>
&nbsp;
<b class="nc">&nbsp;        forceVictory = false;</b>
<b class="nc">&nbsp;        victoryPlayerId = Player.PLAYER_NONE;</b>
<b class="nc">&nbsp;        victoryTeam = Player.TEAM_NONE;</b>
<b class="nc">&nbsp;        lastEntityId = 0;</b>
<b class="nc">&nbsp;        planetaryConditions = new PlanetaryConditions();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void removeArtyAutoHitHexes() {
<b class="nc">&nbsp;        Enumeration&lt;IPlayer&gt; iter = getPlayers();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            IPlayer player = iter.nextElement();</b>
<b class="nc">&nbsp;            player.removeArtyAutoHitHexes();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;//    private void removeMinefields() {
&nbsp;//        minefields.clear();
&nbsp;//        vibrabombs.removeAllElements();
&nbsp;//
&nbsp;//        Enumeration&lt;IPlayer&gt; iter = getPlayers();
&nbsp;//        while (iter.hasMoreElements()) {
&nbsp;//            IPlayer player = iter.nextElement();
&nbsp;//            player.removeMinefields();
&nbsp;//        }
&nbsp;//    }
&nbsp;
&nbsp;    /**
&nbsp;     * Regenerates the entities by id hashtable by going thru all entities in
&nbsp;     * the Vector
&nbsp;     */
&nbsp;    private void reindexEntities() {
<b class="nc">&nbsp;        entityIds.clear();</b>
<b class="nc">&nbsp;        lastEntityId = 0;</b>
&nbsp;
<b class="nc">&nbsp;        if (entities != null) {</b>
&nbsp;            // Add these entities to the game.
<b class="nc">&nbsp;            for (Entity entity : entities) {</b>
<b class="nc">&nbsp;                final int id = entity.getId();</b>
<b class="nc">&nbsp;                entityIds.put(Integer.valueOf(id), entity);</b>
&nbsp;
<b class="nc">&nbsp;                if (id &gt; lastEntityId) {</b>
<b class="nc">&nbsp;                    lastEntityId = id;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // We need to ensure that each entity has the propery Game reference
&nbsp;            //  however, the entityIds Hashmap must be fully formed before this
&nbsp;            //  is called, since setGame also calls setGame for loaded Entities
<b class="nc">&nbsp;            for (Entity entity : entities) {</b>
<b class="nc">&nbsp;                entity.setGame(this);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first entity at the given coordinate, if any. Only returns
&nbsp;     * targetable (non-dead) entities.
&nbsp;     *
&nbsp;     * @param c the coordinates to search at
&nbsp;     */
&nbsp;    public Entity getFirstEntity(Coords c) {
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (c.equals(entity.getPosition()) &amp;&amp; entity.isTargetable()) {</b>
<b class="nc">&nbsp;                return entity;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first enemy entity at the given coordinate, if any. Only
&nbsp;     * returns targetable (non-dead) entities.
&nbsp;     *
&nbsp;     * @param c             the coordinates to search at
&nbsp;     * @param currentEntity the entity that is firing
&nbsp;     */
&nbsp;    public Entity getFirstEnemyEntity(Coords c, Entity currentEntity) {
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (c.equals(entity.getPosition()) &amp;&amp; entity.isTargetable()</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isEnemyOf(currentEntity)) {</b>
<b class="nc">&nbsp;                return entity;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of the active entities at the given coordinates.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getEntities(Coords c) {
<b class="nc">&nbsp;        return getEntities(c, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of the active entities at the given coordinates.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getEntities(Coords c, boolean ignore) {
<b class="nc">&nbsp;        return getEntitiesVector(c,ignore).iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a List of Entities at Coords &lt;code&gt;c&lt;/code&gt;
&nbsp;     *
&nbsp;     * @param c The coordinates to check
&nbsp;     * @return &lt;code&gt;List&lt;Entity&gt;&lt;/code&gt;
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getEntitiesVector(Coords c) {
<b class="nc">&nbsp;        return getEntitiesVector(c, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a List of Entities at Coords &lt;code&gt;c&lt;/code&gt;
&nbsp;     *
&nbsp;     * @param c The coordinates to check
&nbsp;     * @param ignore
&nbsp;     *            Flag that determines whether the ability to target is ignored
&nbsp;     * @return &lt;code&gt;List&lt;Entity&gt;&lt;/code&gt;
&nbsp;     */
&nbsp;    public synchronized List&lt;Entity&gt; getEntitiesVector(Coords c, boolean ignore) {
&nbsp;        //checkPositionCacheConsistency();
&nbsp;        // Make sure the look-up is initialized
<b class="nc">&nbsp;        if (entityPosLookup == null</b>
<b class="nc">&nbsp;                || (entityPosLookup.size() &lt; 1 &amp;&amp; entities.size() &gt; 0)) {</b>
<b class="nc">&nbsp;            resetEntityPositionLookup();</b>
&nbsp;        }
<b class="nc">&nbsp;        Set&lt;Integer&gt; posEntities = entityPosLookup.get(c);</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; vector = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        if (posEntities != null) {</b>
<b class="nc">&nbsp;            for (Integer eId : posEntities) {</b>
<b class="nc">&nbsp;                Entity e = getEntity(eId);</b>
&nbsp;                
&nbsp;                // if the entity with the given ID doesn&#39;t exist, we will update the lookup table
&nbsp;                // and move on
<b class="nc">&nbsp;                if(e == null) {</b>
<b class="nc">&nbsp;                    posEntities.remove(eId);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                if (e.isTargetable() || ignore) {</b>
<b class="nc">&nbsp;                    vector.add(e);</b>
&nbsp;
&nbsp;                    // Sanity check
<b class="nc">&nbsp;                    HashSet&lt;Coords&gt; positions = e.getOccupiedCoords();</b>
<b class="nc">&nbsp;                    if (!positions.contains(c)) {</b>
<b class="nc">&nbsp;                        System.out.println(&quot;Game.getEntitiesVector(1) Error! &quot;</b>
<b class="nc">&nbsp;                                + e.getDisplayName() + &quot; is not in &quot; + c + &quot;!&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return Collections.unmodifiableList(vector);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience function that gets a list of all off-board enemy entities.
&nbsp;     * @param player
&nbsp;     * @return
&nbsp;     */
&nbsp;    public synchronized List&lt;Entity&gt; getAllOffboardEnemyEntities(IPlayer player) {
<b class="nc">&nbsp;        List&lt;Entity&gt; vector = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for(Entity e : entities) {</b>
<b class="nc">&nbsp;            if(e.getOwner().isEnemyOf(player) &amp;&amp; e.isOffBoard() &amp;&amp; !e.isDestroyed() &amp;&amp; e.isDeployed()) {</b>
<b class="nc">&nbsp;                vector.add(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return Collections.unmodifiableList(vector);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a Vector of gun emplacements at Coords &lt;code&gt;c&lt;/code&gt;
&nbsp;     *
&nbsp;     * @param c The coordinates to check
&nbsp;     * @return &lt;code&gt;Vector&lt;Entity&gt;&lt;/code&gt;
&nbsp;     */
&nbsp;    public Vector&lt;GunEmplacement&gt; getGunEmplacements(Coords c) {
<b class="nc">&nbsp;        Vector&lt;GunEmplacement&gt; vector = new Vector&lt;GunEmplacement&gt;();</b>
&nbsp;
&nbsp;        // Only build the list if the coords are on the board.
<b class="nc">&nbsp;        if (board.contains(c)) {</b>
<b class="nc">&nbsp;            for (Entity entity : getEntitiesVector(c, true)) {</b>
<b class="nc">&nbsp;                if (entity.hasETypeFlag(Entity.ETYPE_GUN_EMPLACEMENT)) {</b>
<b class="nc">&nbsp;                    vector.addElement((GunEmplacement) entity);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return vector;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Determine if the given set of coordinates has a gun emplacement on the roof of a building.
&nbsp;     * @param c The coordinates to check
&nbsp;     */
&nbsp;    public boolean hasRooftopGunEmplacement(Coords c) {
<b class="nc">&nbsp;        Building building = getBoard().getBuildingAt(c);</b>
<b class="nc">&nbsp;        if(building == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        IHex hex = getBoard().getHex(c);</b>
&nbsp;        
<b class="nc">&nbsp;        for (Entity entity : getEntitiesVector(c, true)) {</b>
<b class="nc">&nbsp;            if (entity.hasETypeFlag(Entity.ETYPE_GUN_EMPLACEMENT) &amp;&amp; entity.getElevation() == hex.ceiling()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a Target for an Accidental Fall From above, or null if no
&nbsp;     * possible target is there
&nbsp;     *
&nbsp;     * @param c      The &lt;code&gt;Coords&lt;/code&gt; of the hex in which the accidental
&nbsp;     *               fall from above happens
&nbsp;     * @param ignore The entity who is falling
&nbsp;     * @return The &lt;code&gt;Entity&lt;/code&gt; that should be an AFFA target.
&nbsp;     */
&nbsp;    public Entity getAffaTarget(Coords c, Entity ignore) {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; vector = new Vector&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        if (board.contains(c)) {</b>
<b class="nc">&nbsp;            IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;            for (Entity entity : getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                if (entity.isTargetable()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((entity.getElevation() == 0) // Standing on hex surface </b>
<b class="nc">&nbsp;                            || (entity.getElevation() == -hex.depth())) // Standing on hex floor</b>
<b class="nc">&nbsp;                    &amp;&amp; (entity.getAltitude() == 0)</b>
&nbsp;                    &amp;&amp; !(entity instanceof Infantry) &amp;&amp; (entity != ignore)) {
<b class="nc">&nbsp;                    vector.addElement(entity);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!vector.isEmpty()) {</b>
<b class="nc">&nbsp;            int count = vector.size();</b>
<b class="nc">&nbsp;            int random = Compute.randomInt(count);</b>
<b class="nc">&nbsp;            return vector.elementAt(random);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the enemy&#39;s active entities at the
&nbsp;     * given coordinates.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            the &lt;code&gt;Coords&lt;/code&gt; of the hex being examined.
&nbsp;     * @param currentEntity
&nbsp;     *            the &lt;code&gt;Entity&lt;/code&gt; whose enemies are needed.
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s at the given
&nbsp;     *         coordinates who are enemies of the given unit.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getEnemyEntities(final Coords c,
&nbsp;            final Entity currentEntity) {
&nbsp;        // Use an EntitySelector to avoid walking the entities vector twice.
<b class="nc">&nbsp;        return getSelectedEntities(new EntitySelector() {</b>
<b class="nc">&nbsp;            private Coords coords = c;</b>
<b class="nc">&nbsp;            private Entity friendly = currentEntity;</b>
&nbsp;
&nbsp;            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                if (coords.equals(entity.getPosition())</b>
<b class="nc">&nbsp;                        &amp;&amp; entity.isTargetable() &amp;&amp; entity.isEnemyOf(friendly)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of all active enemy entities.
&nbsp;     *
&nbsp;     * @param currentEntity
&nbsp;     *            the &lt;code&gt;Entity&lt;/code&gt; whose enemies are needed.
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s at the given
&nbsp;     *         coordinates who are enemies of the given unit.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getAllEnemyEntities(final Entity currentEntity) {
<b class="nc">&nbsp;    	return getSelectedEntities(new EntitySelector() {</b>
<b class="nc">&nbsp;    		private Entity friendly = currentEntity;</b>
&nbsp;    		
&nbsp;    		public boolean accept(Entity entity) {
<b class="nc">&nbsp;    			return entity.isTargetable() &amp;&amp; entity.isEnemyOf(friendly);</b>
&nbsp;    		}
&nbsp;    	});
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of friendly active entities at the
&nbsp;     * given coordinates.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     *            the &lt;code&gt;Coords&lt;/code&gt; of the hex being examined.
&nbsp;     * @param currentEntity
&nbsp;     *            the &lt;code&gt;Entity&lt;/code&gt; whose friends are needed.
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s at the given
&nbsp;     *         coordinates who are friends of the given unit.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getFriendlyEntities(final Coords c,
&nbsp;            final Entity currentEntity) {
&nbsp;        // Use an EntitySelector to avoid walking the entities vector twice.
<b class="nc">&nbsp;        return getSelectedEntities(new EntitySelector() {</b>
<b class="nc">&nbsp;            private Coords coords = c;</b>
<b class="nc">&nbsp;            private Entity friendly = currentEntity;</b>
&nbsp;
&nbsp;            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                if (coords.equals(entity.getPosition())</b>
<b class="nc">&nbsp;                        &amp;&amp; entity.isTargetable() &amp;&amp; !entity.isEnemyOf(friendly)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Moves an entity into the graveyard so it stops getting sent out every
&nbsp;     * phase.
&nbsp;     */
&nbsp;    public void moveToGraveyard(int id) {
<b class="nc">&nbsp;        removeEntity(id, IEntityRemovalConditions.REMOVE_SALVAGEABLE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * See if the &lt;code&gt;Entity&lt;/code&gt; with the given ID is out of the game.
&nbsp;     *
&nbsp;     * @param id - the ID of the &lt;code&gt;Entity&lt;/code&gt; to be checked.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Entity&lt;/code&gt; is in the graveyard,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public boolean isOutOfGame(int id) {
<b class="nc">&nbsp;        for (Entity entity : vOutOfGame) {</b>
<b class="nc">&nbsp;            if (entity.getId() == id) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * See if the &lt;code&gt;Entity&lt;/code&gt; is out of the game.
&nbsp;     *
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Entity&lt;/code&gt; is in the graveyard,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public boolean isOutOfGame(Entity entity) {
<b class="nc">&nbsp;        return isOutOfGame(entity.getId());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first entity that can act in the present turn, or null if
&nbsp;     * none can.
&nbsp;     */
&nbsp;    public Entity getFirstEntity() {
<b class="nc">&nbsp;        return getFirstEntity(getTurn());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first entity that can act in the specified turn, or null if
&nbsp;     * none can.33
&nbsp;     */
&nbsp;    public Entity getFirstEntity(GameTurn turn) {
<b class="nc">&nbsp;        return getEntity(getFirstEntityNum(turn));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the id of the first entity that can act in the current turn, or
&nbsp;     * -1 if none can.
&nbsp;     */
&nbsp;    public int getFirstEntityNum() {
<b class="nc">&nbsp;        return getFirstEntityNum(getTurn());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the id of the first entity that can act in the specified turn, or
&nbsp;     * -1 if none can.
&nbsp;     */
&nbsp;    public int getFirstEntityNum(GameTurn turn) {
<b class="nc">&nbsp;        if (turn == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (turn.isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return entity.getId();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the next selectable entity that can act this turn, or null if
&nbsp;     * none can.
&nbsp;     *
&nbsp;     * @param start the index number to start at (not an Entity Id)
&nbsp;     */
&nbsp;    public Entity getNextEntity(int start) {
<b class="nc">&nbsp;        if (entities.size() == 0) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        start = start % entities.size();</b>
<b class="nc">&nbsp;        int entityId = entities.get(start).getId();</b>
<b class="nc">&nbsp;        return getEntity(getNextEntityNum(getTurn(), entityId));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity id of the next entity that can move during the
&nbsp;     * specified
&nbsp;     *
&nbsp;     * @param turn  the turn to use
&nbsp;     * @param start the entity id to start at
&nbsp;     */
&nbsp;    public int getNextEntityNum(GameTurn turn, int start) {
&nbsp;        // If we don&#39;t have a turn, return ENTITY_NONE
<b class="nc">&nbsp;        if (turn == null) {</b>
<b class="nc">&nbsp;            return Entity.NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean hasLooped = false;</b>
<b class="nc">&nbsp;        int i = (entities.indexOf(entityIds.get(start)) + 1) % entities.size();</b>
<b class="nc">&nbsp;        if (i == -1) {</b>
&nbsp;            //This means we were given an invalid entity ID, punt
<b class="nc">&nbsp;            return Entity.NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        int startingIndex = i;</b>
<b class="nc">&nbsp;        while (!((hasLooped == true) &amp;&amp; (i == startingIndex))) {</b>
<b class="nc">&nbsp;            final Entity entity = entities.get(i);</b>
<b class="nc">&nbsp;            if (turn.isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return entity.getId();</b>
&nbsp;            }
<b class="nc">&nbsp;            i++;</b>
<b class="nc">&nbsp;            if (i == entities.size()) {</b>
<b class="nc">&nbsp;                i = 0;</b>
<b class="nc">&nbsp;                hasLooped = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // return getFirstEntityNum(turn);
<b class="nc">&nbsp;        return Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity id of the previous entity that can move during the
&nbsp;     * specified
&nbsp;     *
&nbsp;     * @param turn  the turn to use
&nbsp;     * @param start the entity id to start at
&nbsp;     */
&nbsp;    public int getPrevEntityNum(GameTurn turn, int start) {
<b class="nc">&nbsp;        boolean hasLooped = false;</b>
<b class="nc">&nbsp;        int i = (entities.indexOf(entityIds.get(start)) - 1) % entities.size();</b>
<b class="nc">&nbsp;        if (i == -2) {</b>
&nbsp;            //This means we were given an invalid entity ID, punt
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (i == -1) {</b>
&nbsp;            //This means we were given an invalid entity ID, punt
<b class="nc">&nbsp;            i = entities.size() - 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        int startingIndex = i;</b>
<b class="nc">&nbsp;        while (!((hasLooped == true) &amp;&amp; (i == startingIndex))) {</b>
<b class="nc">&nbsp;            final Entity entity = entities.get(i);</b>
<b class="nc">&nbsp;            if (turn.isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return entity.getId();</b>
&nbsp;            }
<b class="nc">&nbsp;            i--;</b>
<b class="nc">&nbsp;            if (i &lt; 0) {</b>
<b class="nc">&nbsp;                i = entities.size() - 1;</b>
<b class="nc">&nbsp;                hasLooped = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // return getFirstEntityNum(turn);
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFirstDeployableEntityNum(GameTurn turn) {
&nbsp;        // Repeat the logic from getFirstEntityNum.
<b class="nc">&nbsp;        if (turn == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (turn.isValidEntity(entity, this)</b>
<b class="nc">&nbsp;                &amp;&amp; entity.shouldDeploy(getRoundCount())) {</b>
<b class="nc">&nbsp;                return entity.getId();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNextDeployableEntityNum(GameTurn turn, int start) {
<b class="nc">&nbsp;        if (start &gt;= 0) {</b>
<b class="nc">&nbsp;            for (int i = start; i &lt; entities.size(); i++) {</b>
<b class="nc">&nbsp;                final Entity entity = entities.get(i);</b>
<b class="nc">&nbsp;                if (turn.isValidEntity(entity, this)</b>
<b class="nc">&nbsp;                    &amp;&amp; entity.shouldDeploy(getRoundCount())) {</b>
<b class="nc">&nbsp;                    return entity.getId();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return getFirstDeployableEntityNum(turn);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the entities for the player.
&nbsp;     *
&nbsp;     * @param player - the &lt;code&gt;Player&lt;/code&gt; whose entities are required.
&nbsp;     * @param hide   - should fighters loaded into squadrons be excluded?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s.
&nbsp;     */
&nbsp;    public ArrayList&lt;Entity&gt; getPlayerEntities(IPlayer player, boolean hide) {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; output = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.isPartOfFighterSquadron() &amp;&amp; hide) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (player.equals(entity.getOwner())) {</b>
<b class="nc">&nbsp;                output.add(entity);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return output;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the entities for the player.
&nbsp;     *
&nbsp;     * @param player - the &lt;code&gt;Player&lt;/code&gt; whose entities are required.
&nbsp;     * @param hide   - should fighters loaded into squadrons be excluded from this list?
&nbsp;     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Entity&lt;/code&gt;s.
&nbsp;     */
&nbsp;    public ArrayList&lt;Integer&gt; getPlayerEntityIds(IPlayer player, boolean hide) {
<b class="nc">&nbsp;        ArrayList&lt;Integer&gt; output = new ArrayList&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (entity.isPartOfFighterSquadron() &amp;&amp; hide) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (player.equals(entity.getOwner())) {</b>
<b class="nc">&nbsp;                output.add(entity.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return output;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the indicated entity is stranded on a transport that can&#39;t
&nbsp;     * move.
&nbsp;     * &lt;p/&gt;
&nbsp;     * According to &lt;a href=
&nbsp;     * &quot;http://www.classicbattletech.com/w3t/showflat.php?Cat=&amp;Board=ask&amp;Number=555466&amp;page=2&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=&quot;
&nbsp;     * &gt; Randall Bills&lt;/a&gt;, the &quot;minimum move&quot; rule allow stranded units to
&nbsp;     * dismount at the start of the turn.
&nbsp;     *
&nbsp;     * @param entity the &lt;code&gt;Entity&lt;/code&gt; that may be stranded
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity is stranded &lt;code&gt;false&lt;/code&gt;
&nbsp;     * otherwise.
&nbsp;     */
&nbsp;    public boolean isEntityStranded(Entity entity) {
&nbsp;
&nbsp;        // Is the entity being transported?
<b class="nc">&nbsp;        final int transportId = entity.getTransportId();</b>
<b class="nc">&nbsp;        Entity transport = getEntity(transportId);</b>
<b class="nc">&nbsp;        if ((Entity.NONE != transportId) &amp;&amp; (null != transport)) {</b>
&nbsp;
&nbsp;            // aero units don&#39;t count here
<b class="nc">&nbsp;            if (transport instanceof Aero) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Can that transport unload the unit?
<b class="nc">&nbsp;            if (transport.isImmobile() || (0 == transport.getWalkMP())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of remaining selectable infantry owned by a player.
&nbsp;     */
&nbsp;    public int getInfantryLeft(int playerId) {
<b class="nc">&nbsp;        IPlayer player = getPlayer(playerId);</b>
<b class="nc">&nbsp;        int remaining = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (player.equals(entity.getOwner())</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isSelectableThisTurn()</b>
&nbsp;                &amp;&amp; (entity instanceof Infantry)) {
<b class="nc">&nbsp;                remaining++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return remaining;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of remaining selectable Protomechs owned by a player.
&nbsp;     */
&nbsp;    public int getProtomechsLeft(int playerId) {
<b class="nc">&nbsp;        IPlayer player = getPlayer(playerId);</b>
<b class="nc">&nbsp;        int remaining = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (player.equals(entity.getOwner())</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isSelectableThisTurn()</b>
&nbsp;                &amp;&amp; (entity instanceof Protomech)) {
<b class="nc">&nbsp;                remaining++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return remaining;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of Vehicles that &lt;code&gt;playerId&lt;/code&gt; has not moved
&nbsp;     * yet this turn.
&nbsp;     *
&nbsp;     * @param playerId
&nbsp;     * @return number of vehicles &lt;code&gt;playerId&lt;/code&gt; has not moved yet this
&nbsp;     * turn
&nbsp;     */
&nbsp;    public int getVehiclesLeft(int playerId) {
<b class="nc">&nbsp;        IPlayer player = getPlayer(playerId);</b>
<b class="nc">&nbsp;        int remaining = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (player.equals(entity.getOwner())</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isSelectableThisTurn()</b>
&nbsp;                &amp;&amp; (entity instanceof Tank)) {
<b class="nc">&nbsp;                remaining++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return remaining;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of Mechs that &lt;code&gt;playerId&lt;/code&gt; has not moved
&nbsp;     * yet this turn.
&nbsp;     *
&nbsp;     * @param playerId
&nbsp;     * @return number of vehicles &lt;code&gt;playerId&lt;/code&gt; has not moved yet this
&nbsp;     * turn
&nbsp;     */
&nbsp;    public int getMechsLeft(int playerId) {
<b class="nc">&nbsp;        IPlayer player = getPlayer(playerId);</b>
<b class="nc">&nbsp;        int remaining = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            if (player.equals(entity.getOwner())</b>
<b class="nc">&nbsp;                &amp;&amp; entity.isSelectableThisTurn()</b>
&nbsp;                &amp;&amp; (entity instanceof Mech)) {
<b class="nc">&nbsp;                remaining++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return remaining;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the first turn found that the specified entity can move in. Used
&nbsp;     * when a turn is played out of order
&nbsp;     */
&nbsp;    public GameTurn removeFirstTurnFor(Entity entity) {
<b class="nc">&nbsp;        assert (phase != Phase.PHASE_MOVEMENT); // special move multi cases</b>
&nbsp;        // ignored
<b class="nc">&nbsp;        for (int i = turnIndex; i &lt; turnVector.size(); i++) {</b>
<b class="nc">&nbsp;            GameTurn turn = turnVector.elementAt(i);</b>
<b class="nc">&nbsp;            if (turn.isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                turnVector.removeElementAt(i);</b>
<b class="nc">&nbsp;                return turn;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the last, next turn found that the specified entity can move in.
&nbsp;     * Used when, say, an entity dies mid-phase.
&nbsp;     */
&nbsp;    public void removeTurnFor(Entity entity) {
<b class="nc">&nbsp;        if (turnVector.size() == 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // If the game option &quot;move multiple infantry per mech&quot; is selected,
&nbsp;        // then we might not need to remove a turn at all.
&nbsp;        // A turn only needs to be removed when going from 4 inf (2 turns) to
&nbsp;        // 3 inf (1 turn)
<b class="nc">&nbsp;        if (getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_MULTI)</b>
&nbsp;            &amp;&amp; (entity instanceof Infantry)
&nbsp;            &amp;&amp; (phase == Phase.PHASE_MOVEMENT)) {
<b class="nc">&nbsp;            if ((getInfantryLeft(entity.getOwnerId()) % getOptions().intOption(</b>
&nbsp;                    OptionsConstants.INIT_INF_PROTO_MOVE_MULTI)) != 1) {
&nbsp;                // exception, if the _next_ turn is an infantry turn, remove
&nbsp;                // that
&nbsp;                // contrived, but may come up e.g. one inf accidently kills
&nbsp;                // another
<b class="nc">&nbsp;                if (hasMoreTurns()) {</b>
<b class="nc">&nbsp;                    GameTurn nextTurn = turnVector.elementAt(turnIndex + 1);</b>
<b class="nc">&nbsp;                    if (nextTurn instanceof GameTurn.EntityClassTurn) {</b>
<b class="nc">&nbsp;                        GameTurn.EntityClassTurn ect =</b>
&nbsp;                                (GameTurn.EntityClassTurn) nextTurn;
<b class="nc">&nbsp;                        if (ect.isValidClass(GameTurn.CLASS_INFANTRY)</b>
<b class="nc">&nbsp;                            &amp;&amp; !ect.isValidClass(~GameTurn.CLASS_INFANTRY)) {</b>
<b class="nc">&nbsp;                            turnVector.removeElementAt(turnIndex + 1);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Same thing but for protos
<b class="nc">&nbsp;        if (getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_MULTI)</b>
&nbsp;            &amp;&amp; (entity instanceof Protomech)
&nbsp;            &amp;&amp; (phase == Phase.PHASE_MOVEMENT)) {
<b class="nc">&nbsp;            if ((getProtomechsLeft(entity.getOwnerId()) % getOptions()</b>
<b class="nc">&nbsp;                    .intOption(OptionsConstants.INIT_INF_PROTO_MOVE_MULTI)) != 1) {</b>
&nbsp;                // exception, if the _next_ turn is an protomek turn, remove
&nbsp;                // that
&nbsp;                // contrived, but may come up e.g. one inf accidently kills
&nbsp;                // another
<b class="nc">&nbsp;                if (hasMoreTurns()) {</b>
<b class="nc">&nbsp;                    GameTurn nextTurn = turnVector.elementAt(turnIndex + 1);</b>
<b class="nc">&nbsp;                    if (nextTurn instanceof GameTurn.EntityClassTurn) {</b>
<b class="nc">&nbsp;                        GameTurn.EntityClassTurn ect =</b>
&nbsp;                                (GameTurn.EntityClassTurn) nextTurn;
<b class="nc">&nbsp;                        if (ect.isValidClass(GameTurn.CLASS_PROTOMECH)</b>
<b class="nc">&nbsp;                            &amp;&amp; !ect.isValidClass(~GameTurn.CLASS_PROTOMECH)) {</b>
<b class="nc">&nbsp;                            turnVector.removeElementAt(turnIndex + 1);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Same thing but for vehicles
<b class="nc">&nbsp;        if (getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT)</b>
&nbsp;            &amp;&amp; (entity instanceof Tank) &amp;&amp; (phase == Phase.PHASE_MOVEMENT)) {
<b class="nc">&nbsp;            if ((getVehiclesLeft(entity.getOwnerId()) % getOptions()</b>
<b class="nc">&nbsp;                    .intOption(OptionsConstants.ADVGRNDMOV_VEHICLE_LANCE_MOVEMENT_NUMBER)) != 1) {</b>
&nbsp;                // exception, if the _next_ turn is a tank turn, remove that
&nbsp;                // contrived, but may come up e.g. one tank accidently kills
&nbsp;                // another
<b class="nc">&nbsp;                if (hasMoreTurns()) {</b>
<b class="nc">&nbsp;                    GameTurn nextTurn = turnVector.elementAt(turnIndex + 1);</b>
<b class="nc">&nbsp;                    if (nextTurn instanceof GameTurn.EntityClassTurn) {</b>
<b class="nc">&nbsp;                        GameTurn.EntityClassTurn ect =</b>
&nbsp;                                (GameTurn.EntityClassTurn) nextTurn;
<b class="nc">&nbsp;                        if (ect.isValidClass(GameTurn.CLASS_TANK)</b>
<b class="nc">&nbsp;                            &amp;&amp; !ect.isValidClass(~GameTurn.CLASS_TANK)) {</b>
<b class="nc">&nbsp;                            turnVector.removeElementAt(turnIndex + 1);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Same thing but for meks
<b class="nc">&nbsp;        if (getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT)</b>
&nbsp;            &amp;&amp; (entity instanceof Mech) &amp;&amp; (phase == Phase.PHASE_MOVEMENT)) {
<b class="nc">&nbsp;            if ((getMechsLeft(entity.getOwnerId()) % getOptions()</b>
<b class="nc">&nbsp;                    .intOption(OptionsConstants.ADVGRNDMOV_MEK_LANCE_MOVEMENT_NUMBER)) != 1) {</b>
&nbsp;                // exception, if the _next_ turn is a mech turn, remove that
&nbsp;                // contrived, but may come up e.g. one mech accidently kills
&nbsp;                // another
<b class="nc">&nbsp;                if (hasMoreTurns()) {</b>
<b class="nc">&nbsp;                    GameTurn nextTurn = turnVector.elementAt(turnIndex + 1);</b>
<b class="nc">&nbsp;                    if (nextTurn instanceof GameTurn.EntityClassTurn) {</b>
<b class="nc">&nbsp;                        GameTurn.EntityClassTurn ect =</b>
&nbsp;                                (GameTurn.EntityClassTurn) nextTurn;
<b class="nc">&nbsp;                        if (ect.isValidClass(GameTurn.CLASS_MECH)</b>
<b class="nc">&nbsp;                            &amp;&amp; !ect.isValidClass(~GameTurn.CLASS_MECH)) {</b>
<b class="nc">&nbsp;                            turnVector.removeElementAt(turnIndex + 1);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        boolean useInfantryMoveLaterCheck = true;</b>
&nbsp;        // If we have the &quot;infantry move later&quot; or &quot;protos move later&quot; optional
&nbsp;        //  rules, then we may be removing an infantry unit that would be
&nbsp;        //  considered invalid unless we don&#39;t consider the extra validity
&nbsp;        //  checks.
<b class="nc">&nbsp;        if ((getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_LATER) &amp;&amp;</b>
&nbsp;             (entity instanceof Infantry)) ||
<b class="nc">&nbsp;            (getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_LATER) &amp;&amp;</b>
&nbsp;             (entity instanceof Protomech))) {
<b class="nc">&nbsp;            useInfantryMoveLaterCheck = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = turnVector.size() - 1; i &gt;= turnIndex; i--) {</b>
<b class="nc">&nbsp;            GameTurn turn = turnVector.elementAt(i);</b>
&nbsp;
<b class="nc">&nbsp;            if (turn.isValidEntity(entity, this, useInfantryMoveLaterCheck)) {</b>
<b class="nc">&nbsp;                turnVector.removeElementAt(i);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public int removeSpecificEntityTurnsFor(Entity entity) {
<b class="nc">&nbsp;        List&lt;GameTurn&gt; turnsToRemove = new ArrayList&lt;GameTurn&gt;();</b>
&nbsp;        
<b class="nc">&nbsp;        for (GameTurn turn : turnVector) {</b>
<b class="nc">&nbsp;            if (turn instanceof SpecificEntityTurn) {</b>
<b class="nc">&nbsp;                int turnOwner = ((SpecificEntityTurn) turn).getEntityNum();</b>
<b class="nc">&nbsp;                if (entity.getId() == turnOwner) {</b>
<b class="nc">&nbsp;                    turnsToRemove.add(turn);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        turnVector.removeAll(turnsToRemove);</b>
<b class="nc">&nbsp;        return turnsToRemove.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check each player for the presence of a Battle Armor squad equipped with
&nbsp;     * a Magnetic Clamp. If one unit is found, update that player&#39;s units to
&nbsp;     * allow the squad to be transported.
&nbsp;     * &lt;p/&gt;
&nbsp;     * This method should be called &lt;/b&gt;*ONCE*&lt;/b&gt; per game, after all units for
&nbsp;     * all players have been loaded.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if a unit was updated, &lt;code&gt;false&lt;/code&gt; if no
&nbsp;     *         player has a Battle Armor squad equipped with a Magnetic Clamp.
&nbsp;     */
&nbsp;    /* Taharqa: I am removing this function and instead I am simply adding clamp mounts to all
&nbsp;     * non omni/ none BA handled mechs in the game.addEntity routine - It should not be too much memory to
&nbsp;     * do this and it allows us to load these units in the lobby
&nbsp;    public boolean checkForMagneticClamp() {
&nbsp;
&nbsp;        // Declare local variables.
&nbsp;        Player player = null;
&nbsp;        Entity unit = null;
&nbsp;        boolean result;
&nbsp;        Hashtable&lt;Player, Boolean&gt; playerFlags = null;
&nbsp;
&nbsp;        // Assume that we don&#39;t need new transporters.
&nbsp;        result = false;
&nbsp;
&nbsp;        // Create a map of flags for the players.
&nbsp;        playerFlags = new Hashtable&lt;Player, Boolean&gt;(getNoOfPlayers());
&nbsp;
&nbsp;        // Walk through the game&#39;s entities.
&nbsp;        for (Enumeration&lt;Entity&gt; i = entities.elements(); i.hasMoreElements();) {
&nbsp;
&nbsp;            // Is the next unit a Battle Armor squad?
&nbsp;            unit = i.nextElement();
&nbsp;            if (unit instanceof BattleArmor) {
&nbsp;
&nbsp;                if (unit.countWorkingMisc(MiscType.F_MAGNETIC_CLAMP) &gt; 0) {
&nbsp;                    // The unit&#39;s player needs new transporters.
&nbsp;                    result = true;
&nbsp;                    playerFlags.put(unit.getOwner(), Boolean.TRUE);
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;            } // End unit-is-BattleArmor
&nbsp;
&nbsp;        } // Handle the next entity.
&nbsp;
&nbsp;        // Do we need to add any Magnetic Clamp transporters?
&nbsp;        if (result) {
&nbsp;
&nbsp;            // Walk through the game&#39;s entities again.
&nbsp;            for (Enumeration&lt;Entity&gt; i = entities.elements(); i
&nbsp;                    .hasMoreElements();) {
&nbsp;
&nbsp;                // Get this unit&#39;s player.
&nbsp;                unit = i.nextElement();
&nbsp;                player = unit.getOwner();
&nbsp;
&nbsp;                // Does this player need updated transporters?
&nbsp;                if (Boolean.TRUE.equals(playerFlags.get(player))) {
&nbsp;
&nbsp;                    // Add the appropriate transporter to the unit.
&nbsp;                    if (!unit.isOmni() &amp;&amp; !unit.hasBattleArmorHandles() &amp;&amp; (unit instanceof Mech)) {
&nbsp;                        unit.addTransporter(new ClampMountMech());
&nbsp;                    } else if (!unit.isOmni() &amp;&amp; !unit.hasBattleArmorHandles() &amp;&amp; (unit instanceof Tank)
&nbsp;                            &amp;&amp; !(unit instanceof VTOL)) {
&nbsp;                        unit.addTransporter(new ClampMountTank());
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            } // End player-needs-transports
&nbsp;
&nbsp;        } // Handle the next unit.
&nbsp;
&nbsp;        // Return the result.
&nbsp;        return result;
&nbsp;
&nbsp;    } // End private boolean checkForMagneticClamp()
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the specified action to the actions list for this phase.
&nbsp;     */
&nbsp;    public void addAction(EntityAction ea) {
<b class="nc">&nbsp;        actions.addElement(ea);</b>
<b class="nc">&nbsp;        processGameEvent(new GameNewActionEvent(this, ea));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setArtilleryVector(Vector&lt;ArtilleryAttackAction&gt; v) {
<b class="nc">&nbsp;        offboardArtilleryAttacks = v;</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void resetArtilleryAttacks() {
<b class="nc">&nbsp;        offboardArtilleryAttacks.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Enumeration&lt;ArtilleryAttackAction&gt; getArtilleryAttacks() {
<b class="nc">&nbsp;        return offboardArtilleryAttacks.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getArtillerySize() {
<b class="nc">&nbsp;        return offboardArtilleryAttacks.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of actions scheduled for this phase.
&nbsp;     */
&nbsp;    public Enumeration&lt;EntityAction&gt; getActions() {
<b class="nc">&nbsp;        return actions.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the actions list.
&nbsp;     */
&nbsp;    public void resetActions() {
<b class="nc">&nbsp;        actions.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all actions by the specified entity
&nbsp;     */
&nbsp;    public void removeActionsFor(int entityId) {
&nbsp;        // or rather, only keeps actions NOT by that entity
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; toKeep = new Vector&lt;EntityAction&gt;(actions.size());</b>
<b class="nc">&nbsp;        for (EntityAction ea : actions) {</b>
<b class="nc">&nbsp;            if (ea.getEntityId() != entityId) {</b>
<b class="nc">&nbsp;                toKeep.addElement(ea);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        actions = toKeep;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a specified action
&nbsp;     *
&nbsp;     * @param o The action to remove.
&nbsp;     */
&nbsp;    public void removeAction(Object o) {
<b class="nc">&nbsp;        actions.removeElement(o);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int actionsSize() {
<b class="nc">&nbsp;        return actions.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actions vector. Do not use to modify the actions; I will be
&nbsp;     * angry. &gt;:[ Used for sending all actions to the client.
&nbsp;     */
&nbsp;    public List&lt;EntityAction&gt; getActionsVector() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(actions);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addInitiativeRerollRequest(Team t) {
<b class="nc">&nbsp;        initiativeRerollRequests.addElement(t);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void rollInitAndResolveTies() {
<b class="nc">&nbsp;        if (getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {</b>
<b class="nc">&nbsp;            Vector&lt;TurnOrdered&gt; vRerolls = new Vector&lt;TurnOrdered&gt;();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; entities.size(); i++) {</b>
<b class="nc">&nbsp;                Entity e = entities.get(i);</b>
<b class="nc">&nbsp;                if (initiativeRerollRequests.contains(getTeamForPlayer(e.getOwner()))) {</b>
<b class="nc">&nbsp;                    vRerolls.add(e);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            TurnOrdered.rollInitAndResolveTies(getEntitiesVector(), vRerolls, false);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            TurnOrdered.rollInitAndResolveTies(teams, initiativeRerollRequests,</b>
<b class="nc">&nbsp;                    getOptions().booleanOption(OptionsConstants.INIT_INITIATIVE_STREAK_COMPENSATION));</b>
&nbsp;        }
<b class="nc">&nbsp;        initiativeRerollRequests.removeAllElements();</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public void handleInitiativeCompensation() {
<b class="nc">&nbsp;        if (getOptions().booleanOption(OptionsConstants.INIT_INITIATIVE_STREAK_COMPENSATION)) {</b>
<b class="nc">&nbsp;            TurnOrdered.resetInitiativeCompensation(teams, getOptions().booleanOption(OptionsConstants.INIT_INITIATIVE_STREAK_COMPENSATION));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getNoOfInitiativeRerollRequests() {
<b class="nc">&nbsp;        return initiativeRerollRequests.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending displacement attack to the list for this phase.
&nbsp;     */
&nbsp;    public void addCharge(AttackAction ea) {
<b class="nc">&nbsp;        pendingCharges.addElement(ea);</b>
<b class="nc">&nbsp;        processGameEvent(new GameNewActionEvent(this, ea));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of displacement attacks scheduled for the end of
&nbsp;     * the physical phase.
&nbsp;     */
&nbsp;    public Enumeration&lt;AttackAction&gt; getCharges() {
<b class="nc">&nbsp;        return pendingCharges.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the pending charges list.
&nbsp;     */
&nbsp;    public void resetCharges() {
<b class="nc">&nbsp;        pendingCharges.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the charges vector. Do not modify. &gt;:[ Used for sending all
&nbsp;     * charges to the client.
&nbsp;     */
&nbsp;    public List&lt;AttackAction&gt; getChargesVector() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(pendingCharges);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending ramming attack to the list for this phase.
&nbsp;     */
&nbsp;    public void addRam(AttackAction ea) {
<b class="nc">&nbsp;        pendingRams.addElement(ea);</b>
<b class="nc">&nbsp;        processGameEvent(new GameNewActionEvent(this, ea));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of ramming attacks scheduled for the end of the
&nbsp;     * physical phase.
&nbsp;     */
&nbsp;    public Enumeration&lt;AttackAction&gt; getRams() {
<b class="nc">&nbsp;        return pendingRams.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the pending rams list.
&nbsp;     */
&nbsp;    public void resetRams() {
<b class="nc">&nbsp;        pendingRams.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the rams vector. Do not modify. &gt;:[ Used for sending all charges
&nbsp;     * to the client.
&nbsp;     */
&nbsp;    public List&lt;AttackAction&gt; getRamsVector() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(pendingRams);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending ramming attack to the list for this phase.
&nbsp;     */
&nbsp;    public void addTeleMissileAttack(AttackAction ea) {
<b class="nc">&nbsp;        pendingTeleMissileAttacks.addElement(ea);</b>
<b class="nc">&nbsp;        processGameEvent(new GameNewActionEvent(this, ea));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of ramming attacks scheduled for the end of the
&nbsp;     * physical phase.
&nbsp;     */
&nbsp;    public Enumeration&lt;AttackAction&gt; getTeleMissileAttacks() {
<b class="nc">&nbsp;        return pendingTeleMissileAttacks.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the pending rams list.
&nbsp;     */
&nbsp;    public void resetTeleMissileAttacks() {
<b class="nc">&nbsp;        pendingTeleMissileAttacks.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the rams vector. Do not modify. &gt;:[ Used for sending all charges
&nbsp;     * to the client.
&nbsp;     */
&nbsp;    public List&lt;AttackAction&gt; getTeleMissileAttacksVector() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(pendingTeleMissileAttacks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending PSR to the list for this phase.
&nbsp;     */
&nbsp;    public void addPSR(PilotingRollData psr) {
<b class="nc">&nbsp;        pilotRolls.addElement(psr);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of pending PSRs.
&nbsp;     */
&nbsp;    public Enumeration&lt;PilotingRollData&gt; getPSRs() {
<b class="nc">&nbsp;        return pilotRolls.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending extreme Gravity PSR to the list for this phase.
&nbsp;     */
&nbsp;    public void addExtremeGravityPSR(PilotingRollData psr) {
<b class="nc">&nbsp;        extremeGravityRolls.addElement(psr);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of pending extreme GravityPSRs.
&nbsp;     */
&nbsp;    public Enumeration&lt;PilotingRollData&gt; getExtremeGravityPSRs() {
<b class="nc">&nbsp;        return extremeGravityRolls.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the PSR list for a given entity.
&nbsp;     */
&nbsp;    public void resetPSRs(Entity entity) {
&nbsp;        PilotingRollData roll;
<b class="nc">&nbsp;        Vector&lt;Integer&gt; rollsToRemove = new Vector&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        int i = 0;</b>
&nbsp;
&nbsp;        // first, find all the rolls belonging to the target entity
<b class="nc">&nbsp;        for (i = 0; i &lt; pilotRolls.size(); i++) {</b>
<b class="nc">&nbsp;            roll = pilotRolls.elementAt(i);</b>
<b class="nc">&nbsp;            if (roll.getEntityId() == entity.getId()) {</b>
<b class="nc">&nbsp;                rollsToRemove.addElement(Integer.valueOf(i));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // now, clear them out
<b class="nc">&nbsp;        for (i = rollsToRemove.size() - 1; i &gt; -1; i--) {</b>
<b class="nc">&nbsp;            pilotRolls.removeElementAt(rollsToRemove.elementAt(i).intValue());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the extreme Gravity PSR list.
&nbsp;     */
&nbsp;    public void resetExtremeGravityPSRs() {
<b class="nc">&nbsp;        extremeGravityRolls.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the extreme Gravity PSR list for a given entity.
&nbsp;     */
&nbsp;    public void resetExtremeGravityPSRs(Entity entity) {
&nbsp;        PilotingRollData roll;
<b class="nc">&nbsp;        Vector&lt;Integer&gt; rollsToRemove = new Vector&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        int i = 0;</b>
&nbsp;
&nbsp;        // first, find all the rolls belonging to the target entity
<b class="nc">&nbsp;        for (i = 0; i &lt; extremeGravityRolls.size(); i++) {</b>
<b class="nc">&nbsp;            roll = extremeGravityRolls.elementAt(i);</b>
<b class="nc">&nbsp;            if (roll.getEntityId() == entity.getId()) {</b>
<b class="nc">&nbsp;                rollsToRemove.addElement(Integer.valueOf(i));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // now, clear them out
<b class="nc">&nbsp;        for (i = rollsToRemove.size() - 1; i &gt; -1; i--) {</b>
<b class="nc">&nbsp;            extremeGravityRolls.removeElementAt(rollsToRemove.elementAt(i)</b>
<b class="nc">&nbsp;                    .intValue());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the PSR list.
&nbsp;     */
&nbsp;    public void resetPSRs() {
<b class="nc">&nbsp;        pilotRolls.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * add an AttackHandler to the attacks list
&nbsp;     *
&nbsp;     * @param ah - The &lt;code&gt;AttackHandler&lt;/code&gt; to add
&nbsp;     */
&nbsp;    public void addAttack(AttackHandler ah) {
<b class="nc">&nbsp;        attacks.add(ah);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * remove an AttackHandler from the attacks list
&nbsp;     *
&nbsp;     * @param ah - The &lt;code&gt;AttackHandler&lt;/code&gt; to remove
&nbsp;     */
&nbsp;    public void removeAttack(AttackHandler ah) {
<b class="nc">&nbsp;        attacks.removeElement(ah);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * get the attacks
&nbsp;     *
&nbsp;     * @return a &lt;code&gt;Enumeration&lt;/code&gt; of all &lt;code&gt;AttackHandler&lt;/code&gt;s
&nbsp;     */
&nbsp;    public Enumeration&lt;AttackHandler&gt; getAttacks() {
<b class="nc">&nbsp;        return attacks.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the attacks vector
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;Vector&lt;/code&gt; containing the attacks
&nbsp;     */
&nbsp;    public Vector&lt;AttackHandler&gt; getAttacksVector() {
<b class="nc">&nbsp;        return attacks;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * reset the attacks vector
&nbsp;     */
&nbsp;    public void resetAttacks() {
<b class="nc">&nbsp;        attacks = new Vector&lt;AttackHandler&gt;();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * set the attacks vector
&nbsp;     *
&nbsp;     * @param v - the &lt;code&gt;Vector&lt;/code&gt; that should be the new attacks
&nbsp;     *          vector
&nbsp;     */
&nbsp;    public void setAttacksVector(Vector&lt;AttackHandler&gt; v) {
<b class="nc">&nbsp;        attacks = v;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property roundCount.
&nbsp;     *
&nbsp;     * @return Value of property roundCount.
&nbsp;     */
&nbsp;    public int getRoundCount() {
<b class="nc">&nbsp;        return roundCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setRoundCount(int roundCount) {
<b class="nc">&nbsp;        this.roundCount = roundCount;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Increments the round counter
&nbsp;     */
&nbsp;    public void incrementRoundCount() {
<b class="nc">&nbsp;        roundCount++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property forceVictory.
&nbsp;     *
&nbsp;     * @return Value of property forceVictory.
&nbsp;     */
&nbsp;    public boolean isForceVictory() {
<b class="nc">&nbsp;        return forceVictory;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property forceVictory.
&nbsp;     *
&nbsp;     * @param forceVictory New value of property forceVictory.
&nbsp;     */
&nbsp;    public void setForceVictory(boolean forceVictory) {
<b class="nc">&nbsp;        this.forceVictory = forceVictory;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addReports(Vector&lt;Report&gt; v) {
<b class="nc">&nbsp;        if (v.size() == 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        gameReports.add(roundCount, v);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Vector&lt;Report&gt; getReports(int r) {
<b class="nc">&nbsp;        return gameReports.get(r);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Vector&lt;Report&gt;&gt; getAllReports() {
<b class="nc">&nbsp;        return gameReports.get();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setAllReports(Vector&lt;Vector&lt;Report&gt;&gt; v) {
<b class="nc">&nbsp;        gameReports.set(v);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearAllReports() {
<b class="nc">&nbsp;        gameReports.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void end(int winner, int winnerTeam) {
<b class="nc">&nbsp;        setVictoryPlayerId(winner);</b>
<b class="nc">&nbsp;        setVictoryTeam(winnerTeam);</b>
<b class="nc">&nbsp;        processGameEvent(new GameEndEvent(this));</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property victoryPlayerId.
&nbsp;     *
&nbsp;     * @return Value of property victoryPlayerId.
&nbsp;     */
&nbsp;    public int getVictoryPlayerId() {
<b class="nc">&nbsp;        return victoryPlayerId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property victoryPlayerId.
&nbsp;     *
&nbsp;     * @param victoryPlayerId New value of property victoryPlayerId.
&nbsp;     */
&nbsp;    public void setVictoryPlayerId(int victoryPlayerId) {
<b class="nc">&nbsp;        this.victoryPlayerId = victoryPlayerId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property victoryTeam.
&nbsp;     *
&nbsp;     * @return Value of property victoryTeam.
&nbsp;     */
&nbsp;    public int getVictoryTeam() {
<b class="nc">&nbsp;        return victoryTeam;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property victoryTeam.
&nbsp;     *
&nbsp;     * @param victoryTeam New value of property victoryTeam.
&nbsp;     */
&nbsp;    public void setVictoryTeam(int victoryTeam) {
<b class="nc">&nbsp;        this.victoryTeam = victoryTeam;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the specified player is either the victor, or is on the
&nbsp;     * winning team. Best to call during PHASE_VICTORY.
&nbsp;     */
&nbsp;    public boolean isPlayerVictor(IPlayer player) {
<b class="nc">&nbsp;        if (player.getTeam() == IPlayer.TEAM_NONE) {</b>
<b class="nc">&nbsp;            return player.getId() == victoryPlayerId;</b>
&nbsp;        }
<b class="nc">&nbsp;        return player.getTeam() == victoryTeam;</b>
&nbsp;    }
&nbsp;
&nbsp;    public HashMap&lt;String, Object&gt; getVictoryContext() {
<b class="nc">&nbsp;        return victoryContext;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setVictoryContext(HashMap&lt;String, Object&gt; ctx) {
<b class="nc">&nbsp;        victoryContext = ctx;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Shortcut to isPlayerVictor(Player player)
&nbsp;     */
&nbsp;    public boolean isPlayerVictor(int playerId) {
<b class="nc">&nbsp;        return isPlayerVictor(getPlayer(playerId));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get all &lt;code&gt;Entity&lt;/code&gt;s that pass the given selection criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test that an
&nbsp;     *                 entity must pass to be included. This value may be
&nbsp;     *                 &lt;code&gt;null&lt;/code&gt; (in which case all entities in the game will
&nbsp;     *                 be returned).
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of all entities that the selector
&nbsp;     * accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     * empty.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getSelectedEntities(EntitySelector selector) {
&nbsp;        Iterator&lt;Entity&gt; retVal;
&nbsp;
&nbsp;        // If no selector was supplied, return all entities.
<b class="nc">&nbsp;        if (null == selector) {</b>
<b class="nc">&nbsp;            retVal = this.getEntities();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Otherwise, return an anonymous Enumeration
&nbsp;        // that selects entities in this game.
&nbsp;        else {
<b class="nc">&nbsp;            final EntitySelector entry = selector;</b>
<b class="nc">&nbsp;            retVal = new Iterator&lt;Entity&gt;() {</b>
<b class="nc">&nbsp;                private EntitySelector entitySelector = entry;</b>
<b class="nc">&nbsp;                private Entity current = null;</b>
<b class="nc">&nbsp;                private Iterator&lt;Entity&gt; iter = getEntities();</b>
&nbsp;
&nbsp;                // Do any more entities meet the selection criteria?
&nbsp;                public boolean hasNext() {
&nbsp;                    // See if we have a pre-approved entity.
<b class="nc">&nbsp;                    if (null == current) {</b>
&nbsp;
&nbsp;                        // Find the first acceptable entity
<b class="nc">&nbsp;                        while ((null == current) &amp;&amp; iter.hasNext()) {</b>
<b class="nc">&nbsp;                            current = iter.next();</b>
<b class="nc">&nbsp;                            if (!entitySelector.accept(current)) {</b>
<b class="nc">&nbsp;                                current = null;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    return (null != current);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Get the next entity that meets the selection criteria.
&nbsp;                public Entity next() {
&nbsp;                    // Pre-approve an entity.
<b class="nc">&nbsp;                    if (!hasNext()) {</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Use the pre-approved entity, and null out our reference.
<b class="nc">&nbsp;                    Entity next = current;</b>
<b class="nc">&nbsp;                    current = null;</b>
<b class="nc">&nbsp;                    return next;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void remove() {
<b class="nc">&nbsp;                    throw new UnsupportedOperationException();</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;        } // End use-selector
&nbsp;
&nbsp;        // Return the selected entities.
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Count all &lt;code&gt;Entity&lt;/code&gt;s that pass the given selection criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test that an
&nbsp;     *                 entity must pass to be included. This value may be
&nbsp;     *                 &lt;code&gt;null&lt;/code&gt; (in which case the count of all entities in
&nbsp;     *                 the game will be returned).
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; count of all entities that the selector
&nbsp;     * accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     * empty.
&nbsp;     */
&nbsp;    public int getSelectedEntityCount(EntitySelector selector) {
<b class="nc">&nbsp;        int retVal = 0;</b>
&nbsp;
&nbsp;        // If no selector was supplied, return the count of all game entities.
<b class="nc">&nbsp;        if (null == selector) {</b>
<b class="nc">&nbsp;            retVal = getNoOfEntities();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Otherwise, count the entities that meet the selection criteria.
&nbsp;        else {
<b class="nc">&nbsp;            Iterator&lt;Entity&gt; iter = this.getEntities();</b>
<b class="nc">&nbsp;            while (iter.hasNext()) {</b>
<b class="nc">&nbsp;                if (selector.accept(iter.next())) {</b>
<b class="nc">&nbsp;                    retVal++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        } // End use-selector
&nbsp;
&nbsp;        // Return the number of selected entities.
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get all out-of-game &lt;code&gt;Entity&lt;/code&gt;s that pass the given selection
&nbsp;     * criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test that an
&nbsp;     *                 entity must pass to be included. This value may be
&nbsp;     *                 &lt;code&gt;null&lt;/code&gt; (in which case all entities in the game will
&nbsp;     *                 be returned).
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of all entities that the selector
&nbsp;     * accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     * empty.
&nbsp;     */
&nbsp;    public Enumeration&lt;Entity&gt; getSelectedOutOfGameEntities(
&nbsp;            EntitySelector selector) {
&nbsp;        Enumeration&lt;Entity&gt; retVal;
&nbsp;
&nbsp;        // If no selector was supplied, return all entities.
<b class="nc">&nbsp;        if (null == selector) {</b>
<b class="nc">&nbsp;            retVal = vOutOfGame.elements();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Otherwise, return an anonymous Enumeration
&nbsp;        // that selects entities in this game.
&nbsp;        else {
<b class="nc">&nbsp;            final EntitySelector entry = selector;</b>
<b class="nc">&nbsp;            retVal = new Enumeration&lt;Entity&gt;() {</b>
<b class="nc">&nbsp;                private EntitySelector entitySelector = entry;</b>
<b class="nc">&nbsp;                private Entity current = null;</b>
<b class="nc">&nbsp;                private Enumeration&lt;Entity&gt; iter = vOutOfGame.elements();</b>
&nbsp;
&nbsp;                // Do any more entities meet the selection criteria?
&nbsp;                public boolean hasMoreElements() {
&nbsp;                    // See if we have a pre-approved entity.
<b class="nc">&nbsp;                    if (null == current) {</b>
&nbsp;
&nbsp;                        // Find the first acceptable entity
<b class="nc">&nbsp;                        while ((null == current) &amp;&amp; iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                            current = iter.nextElement();</b>
<b class="nc">&nbsp;                            if (!entitySelector.accept(current)) {</b>
<b class="nc">&nbsp;                                current = null;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    return (null != current);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Get the next entity that meets the selection criteria.
&nbsp;                public Entity nextElement() {
&nbsp;                    // Pre-approve an entity.
<b class="nc">&nbsp;                    if (!hasMoreElements()) {</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Use the pre-approved entity, and null out our reference.
<b class="nc">&nbsp;                    Entity next = current;</b>
<b class="nc">&nbsp;                    current = null;</b>
<b class="nc">&nbsp;                    return next;</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;        } // End use-selector
&nbsp;
&nbsp;        // Return the selected entities.
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Count all out-of-game&lt;code&gt;Entity&lt;/code&gt;s that pass the given selection
&nbsp;     * criteria.
&nbsp;     *
&nbsp;     * @param selector the &lt;code&gt;EntitySelector&lt;/code&gt; that implements test that an
&nbsp;     *                 entity must pass to be included. This value may be
&nbsp;     *                 &lt;code&gt;null&lt;/code&gt; (in which case the count of all out-of-game
&nbsp;     *                 entities will be returned).
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; count of all entities that the selector
&nbsp;     * accepts. This value will not be &lt;code&gt;null&lt;/code&gt; but it may be
&nbsp;     * empty.
&nbsp;     */
&nbsp;    public int getSelectedOutOfGameEntityCount(EntitySelector selector) {
<b class="nc">&nbsp;        int retVal = 0;</b>
&nbsp;
&nbsp;        // If no selector was supplied, return the count of all game entities.
<b class="nc">&nbsp;        if (null == selector) {</b>
<b class="nc">&nbsp;            retVal = vOutOfGame.size();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Otherwise, count the entities that meet the selection criteria.
&nbsp;        else {
<b class="nc">&nbsp;            Enumeration&lt;Entity&gt; iter = vOutOfGame.elements();</b>
<b class="nc">&nbsp;            while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                if (selector.accept(iter.nextElement())) {</b>
<b class="nc">&nbsp;                    retVal++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        } // End use-selector
&nbsp;
&nbsp;        // Return the number of selected entities.
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the player has any valid units this turn that are not
&nbsp;     * infantry, not protomechs, or not either of those. This method is
&nbsp;     * utitilized by the &quot;A players Infantry moves after that players other
&nbsp;     * units&quot;, and &quot;A players Protomechs move after that players other units&quot;
&nbsp;     * options.
&nbsp;     */
&nbsp;    public boolean checkForValidNonInfantryAndOrProtomechs(int playerId) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; iter = getPlayerEntities(getPlayer(playerId), false)</b>
<b class="nc">&nbsp;                .iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.next();</b>
<b class="nc">&nbsp;            boolean excluded = false;</b>
<b class="nc">&nbsp;            if ((entity instanceof Infantry)</b>
<b class="nc">&nbsp;                &amp;&amp; getOptions().booleanOption(OptionsConstants.INIT_INF_MOVE_LATER)) {</b>
<b class="nc">&nbsp;                excluded = true;</b>
<b class="nc">&nbsp;            } else if ((entity instanceof Protomech)</b>
<b class="nc">&nbsp;                       &amp;&amp; getOptions().booleanOption(OptionsConstants.INIT_PROTOS_MOVE_LATER)) {</b>
<b class="nc">&nbsp;                excluded = true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!excluded &amp;&amp; getTurn().isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get Entities that have have a iNarc Nemesis pod attached and are situated
&nbsp;     * between two Coords
&nbsp;     *
&nbsp;     * @param attacker The attacking &lt;code&gt;Entity&lt;/code&gt;.
&nbsp;     * @param target   The &lt;code&gt;Coords&lt;/code&gt; of the original target.
&nbsp;     * @return a &lt;code&gt;Enumeration&lt;/code&gt; of entities that have nemesis pods
&nbsp;     * attached and are located between attacker and target and are
&nbsp;     * friendly with the attacker.
&nbsp;     */
&nbsp;    public Enumeration&lt;Entity&gt; getNemesisTargets(Entity attacker, Coords target) {
<b class="nc">&nbsp;        final Coords attackerPos = attacker.getPosition();</b>
<b class="nc">&nbsp;        final ArrayList&lt;Coords&gt; in = Coords.intervening(attackerPos, target);</b>
<b class="nc">&nbsp;        Vector&lt;Entity&gt; nemesisTargets = new Vector&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for (Coords c : in) {</b>
<b class="nc">&nbsp;            for (Entity entity : getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                if (entity.isINarcedWith(INarcPod.NEMESIS)</b>
<b class="nc">&nbsp;                    &amp;&amp; !entity.isEnemyOf(attacker)) {</b>
<b class="nc">&nbsp;                    nemesisTargets.addElement(entity);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return nemesisTargets.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the specified game listener to receive board events from this board.
&nbsp;     *
&nbsp;     * @param listener the game listener.
&nbsp;     */
&nbsp;    public void addGameListener(GameListener listener) {
&nbsp;        // Since gameListeners is transient, it could be null
<b class="fc">&nbsp;        if (gameListeners == null) {</b>
<b class="nc">&nbsp;            gameListeners = new Vector&lt;GameListener&gt;();</b>
&nbsp;        }
<b class="fc">&nbsp;        gameListeners.addElement(listener);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the specified game listener.
&nbsp;     *
&nbsp;     * @param listener the game listener.
&nbsp;     */
&nbsp;    public void removeGameListener(GameListener listener) {
&nbsp;        // Since gameListeners is transient, it could be null
<b class="nc">&nbsp;        if (gameListeners == null) {</b>
<b class="nc">&nbsp;            gameListeners = new Vector&lt;GameListener&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        gameListeners.removeElement(listener);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all the GameListeners.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public List&lt;GameListener&gt; getGameListeners() {
&nbsp;        // Since gameListeners is transient, it could be null
<b class="nc">&nbsp;        if (gameListeners == null) {</b>
<b class="nc">&nbsp;            gameListeners = new Vector&lt;GameListener&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        return Collections.unmodifiableList(gameListeners);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * purges all Game Listener objects.
&nbsp;     */
&nbsp;    public void purgeGameListeners() {
&nbsp;        // Since gameListeners is transient, it could be null
<b class="nc">&nbsp;        if (gameListeners == null) {</b>
<b class="nc">&nbsp;            gameListeners = new Vector&lt;GameListener&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        gameListeners.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Processes game events occurring on this connection by dispatching them to
&nbsp;     * any registered GameListener objects.
&nbsp;     *
&nbsp;     * @param event the game event.
&nbsp;     */
&nbsp;    public void processGameEvent(GameEvent event) {
&nbsp;        // Since gameListeners is transient, it could be null
<b class="nc">&nbsp;        if (gameListeners == null) {</b>
<b class="nc">&nbsp;            gameListeners = new Vector&lt;GameListener&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Enumeration&lt;GameListener&gt; e = gameListeners.elements(); e</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            event.fireEvent(e.nextElement());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this turn&#39;s tag information
&nbsp;     */
&nbsp;    public Vector&lt;TagInfo&gt; getTagInfo() {
<b class="nc">&nbsp;        return tagInfoForTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addTagInfo(TagInfo info) {
<b class="nc">&nbsp;        tagInfoForTurn.addElement(info);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void resetTagInfo() {
<b class="nc">&nbsp;        tagInfoForTurn.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearTagInfoShots(Entity ae, Coords tc) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; tagInfoForTurn.size(); i++) {</b>
<b class="nc">&nbsp;            TagInfo info = tagInfoForTurn.elementAt(i);</b>
<b class="nc">&nbsp;            Entity attacker = getEntity(info.attackerId);</b>
<b class="nc">&nbsp;            Targetable target = info.target;</b>
<b class="nc">&nbsp;            if (!ae.isEnemyOf(attacker) &amp;&amp; isIn8HexRadius(target.getPosition(), tc)) {</b>
<b class="nc">&nbsp;                info.shots = info.priority;</b>
<b class="nc">&nbsp;                tagInfoForTurn.setElementAt(info, i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isIn8HexRadius(Coords c1, Coords c2) {
&nbsp;
&nbsp;        // errata says we now always use 8 hex radius
<b class="nc">&nbsp;        if (c2.distance(c1) &lt;= 8) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get a list of flares
&nbsp;     */
&nbsp;    public Vector&lt;Flare&gt; getFlares() {
<b class="nc">&nbsp;        return flares;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the list of flares
&nbsp;     */
&nbsp;    public void setFlares(Vector&lt;Flare&gt; flares) {
<b class="nc">&nbsp;        this.flares = flares;</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add a new flare
&nbsp;     */
&nbsp;    public void addFlare(Flare flare) {
<b class="nc">&nbsp;        flares.addElement(flare);</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get a set of Coords illuminated by searchlights.
&nbsp;     * 
&nbsp;     * Note: coords could be illuminated by other sources as well, it&#39;s likely
&nbsp;     * that IGame.isPositionIlluminated is desired unless the searchlighted hex
&nbsp;     * set is being sent to the client or server.
&nbsp;     */
&nbsp;    public HashSet&lt;Coords&gt; getIlluminatedPositions() {
<b class="nc">&nbsp;        return illuminatedPositions;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the set of searchlight illuminated hexes.
&nbsp;     */
&nbsp;    public void clearIlluminatedPositions() {
<b class="nc">&nbsp;        if (illuminatedPositions == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        illuminatedPositions.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for the list of Coords illuminated by search lights.
&nbsp;     */
&nbsp;    public void setIlluminatedPositions(HashSet&lt;Coords&gt; ip) {
<b class="nc">&nbsp;        if (ip == null) {</b>
<b class="nc">&nbsp;            new RuntimeException(&quot;Illuminated Positions is null.&quot;).printStackTrace();</b>
&nbsp;        }
<b class="nc">&nbsp;        illuminatedPositions = ip;</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add a new hex to the collection of Coords illuminated by searchlights.
&nbsp;     *
&nbsp;     * @return True if a new hex was added, else false if the set already
&nbsp;     * contained the input hex.
&nbsp;     */
&nbsp;    public boolean addIlluminatedPosition(Coords c) {
<b class="nc">&nbsp;        boolean rv = illuminatedPositions.add(c);</b>
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;        return rv;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the level of illumination for a given coords.  Different light
&nbsp;     * sources affect how much the night-time penalties are reduced. Note: this
&nbsp;     * method should be used for determining is a Coords/Hex is illuminated, not
&nbsp;     * IGame. getIlluminatedPositions(), as that just returns the hexes that
&nbsp;     * are effected by spotlights, whereas this one considers searchlights as
&nbsp;     * well as other light sources.
&nbsp;     */
&nbsp;    public int isPositionIlluminated(Coords c) {
&nbsp;    	// fix for NPE when recovering spacecraft while in visual range of enemy
<b class="nc">&nbsp;    	if (getBoard().inSpace()) {</b>
<b class="nc">&nbsp;    		return ILLUMINATED_NONE;</b>
&nbsp;    	}
&nbsp;        // Flares happen first, because they totally negate nighttime penalties
<b class="nc">&nbsp;        for (Flare flare : flares) {</b>
<b class="nc">&nbsp;            if (flare.illuminates(c)) {</b>
<b class="nc">&nbsp;                return ILLUMINATED_FLARE;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        IHex hex = getBoard().getHex(c);</b>
&nbsp;
&nbsp;        // Searchlights reduce nighttime penalties by up to 3 points.
<b class="nc">&nbsp;        if (illuminatedPositions.contains(c)) {</b>
<b class="nc">&nbsp;            return ILLUMINATED_LIGHT;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Fires can reduce nighttime penalties by up to 2 points.
<b class="nc">&nbsp;        if (hex != null &amp;&amp; hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            return ILLUMINATED_FIRE;</b>
&nbsp;        }
&nbsp;        // If we are adjacent to a burning hex, we are also illuminated
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            Coords adj = c.translated(dir);</b>
<b class="nc">&nbsp;            hex = getBoard().getHex(adj);</b>
<b class="nc">&nbsp;            if (hex != null &amp;&amp; hex.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;                return ILLUMINATED_FIRE;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return ILLUMINATED_NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Age the flare list and remove any which have burnt out Artillery flares
&nbsp;     * drift with wind. (called at end of turn)
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; ageFlares() {
<b class="nc">&nbsp;        Vector&lt;Report&gt; reports = new Vector&lt;Report&gt;();</b>
&nbsp;        Report r;
<b class="nc">&nbsp;        for (int i = flares.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            Flare flare = flares.elementAt(i);</b>
<b class="nc">&nbsp;            r = new Report(5235);</b>
<b class="nc">&nbsp;            r.add(flare.position.getBoardNum());</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            reports.addElement(r);</b>
<b class="nc">&nbsp;            if ((flare.flags &amp; Flare.F_IGNITED) != 0) {</b>
<b class="nc">&nbsp;                flare.turnsToBurn--;</b>
<b class="nc">&nbsp;                if ((flare.flags &amp; Flare.F_DRIFTING) != 0) {</b>
<b class="nc">&nbsp;                    int dir = planetaryConditions.getWindDirection();</b>
<b class="nc">&nbsp;                    int str = planetaryConditions.getWindStrength();</b>
&nbsp;
&nbsp;                    // strength 1 and 2: drift 1 hex
&nbsp;                    // strength 3: drift 2 hexes
&nbsp;                    // strength 4: drift 3 hexes
&nbsp;                    // for each above strenght 4 (storm), drift one more
<b class="nc">&nbsp;                    if (str &gt; 0) {</b>
<b class="nc">&nbsp;                        flare.position = flare.position.translated(dir);</b>
<b class="nc">&nbsp;                        if (str &gt; 2) {</b>
<b class="nc">&nbsp;                            flare.position = flare.position.translated(dir);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (str &gt; 3) {</b>
<b class="nc">&nbsp;                            flare.position = flare.position.translated(dir);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (str &gt; 4) {</b>
<b class="nc">&nbsp;                            flare.position = flare.position.translated(dir);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (str &gt; 5) {</b>
<b class="nc">&nbsp;                            flare.position = flare.position.translated(dir);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        r = new Report(5236);</b>
<b class="nc">&nbsp;                        r.add(flare.position.getBoardNum());</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        reports.addElement(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(5237);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                reports.addElement(r);</b>
<b class="nc">&nbsp;                flare.flags |= Flare.F_IGNITED;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (flare.turnsToBurn &lt;= 0) {</b>
<b class="nc">&nbsp;                r = new Report(5238);</b>
<b class="nc">&nbsp;                reports.addElement(r);</b>
<b class="nc">&nbsp;                flares.removeElementAt(i);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r = new Report(5239);</b>
<b class="nc">&nbsp;                r.add(flare.turnsToBurn);</b>
<b class="nc">&nbsp;                reports.addElement(r);</b>
<b class="nc">&nbsp;                flares.setElementAt(flare, i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean gameTimerIsExpired() {
<b class="nc">&nbsp;        return ((getOptions().booleanOption(OptionsConstants.VICTORY_USE_GAME_TURN_LIMIT)) &amp;&amp; (getRoundCount() == getOptions()</b>
<b class="nc">&nbsp;                .intOption(OptionsConstants.VICTORY_GAME_TURN_LIMIT)));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void createVictoryConditions() {
<b class="nc">&nbsp;        victory = new Victory(getOptions());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Victory getVictory() {
<b class="nc">&nbsp;        return victory;</b>
&nbsp;    }
&nbsp;
&nbsp;    // a shortcut function for determining whether vectored movement is
&nbsp;    // applicable
&nbsp;    public boolean useVectorMove() {
<b class="nc">&nbsp;        return getOptions().booleanOption(OptionsConstants.ADVAERORULES_ADVANCED_MOVEMENT)</b>
<b class="nc">&nbsp;               &amp;&amp; board.inSpace();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a pending Control roll to the list for this phase.
&nbsp;     */
&nbsp;    public void addControlRoll(PilotingRollData control) {
<b class="nc">&nbsp;        controlRolls.addElement(control);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an Enumeration of pending Control rolls.
&nbsp;     */
&nbsp;    public Enumeration&lt;PilotingRollData&gt; getControlRolls() {
<b class="nc">&nbsp;        return controlRolls.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the Control Roll list for a given entity.
&nbsp;     */
&nbsp;    public void resetControlRolls(Entity entity) {
&nbsp;        PilotingRollData roll;
<b class="nc">&nbsp;        Vector&lt;Integer&gt; rollsToRemove = new Vector&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        int i = 0;</b>
&nbsp;
&nbsp;        // first, find all the rolls belonging to the target entity
<b class="nc">&nbsp;        for (i = 0; i &lt; controlRolls.size(); i++) {</b>
<b class="nc">&nbsp;            roll = controlRolls.elementAt(i);</b>
<b class="nc">&nbsp;            if (roll.getEntityId() == entity.getId()) {</b>
<b class="nc">&nbsp;                rollsToRemove.addElement(Integer.valueOf(i));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // now, clear them out
<b class="nc">&nbsp;        for (i = rollsToRemove.size() - 1; i &gt; -1; i--) {</b>
<b class="nc">&nbsp;            controlRolls.removeElementAt(rollsToRemove.elementAt(i).intValue());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resets the PSR list.
&nbsp;     */
&nbsp;    public void resetControlRolls() {
<b class="nc">&nbsp;        controlRolls.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A set of checks for aero units to make sure that the movement order is
&nbsp;     * maintained
&nbsp;     */
&nbsp;    public boolean checkForValidSpaceStations(int playerId) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; iter = getPlayerEntities(getPlayer(playerId), false)</b>
<b class="nc">&nbsp;                .iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.next();</b>
<b class="nc">&nbsp;            if ((entity instanceof SpaceStation)</b>
<b class="nc">&nbsp;                &amp;&amp; getTurn().isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean checkForValidJumpships(int playerId) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; iter = getPlayerEntities(getPlayer(playerId), false)</b>
<b class="nc">&nbsp;                .iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.next();</b>
<b class="nc">&nbsp;            if ((entity instanceof Jumpship) &amp;&amp; !(entity instanceof Warship)</b>
<b class="nc">&nbsp;                &amp;&amp; getTurn().isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean checkForValidWarships(int playerId) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; iter = getPlayerEntities(getPlayer(playerId), false)</b>
<b class="nc">&nbsp;                .iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.next();</b>
<b class="nc">&nbsp;            if ((entity instanceof Warship)</b>
<b class="nc">&nbsp;                &amp;&amp; getTurn().isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean checkForValidDropships(int playerId) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; iter = getPlayerEntities(getPlayer(playerId), false)</b>
<b class="nc">&nbsp;                .iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.next();</b>
<b class="nc">&nbsp;            if ((entity instanceof Dropship)</b>
<b class="nc">&nbsp;                &amp;&amp; getTurn().isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean checkForValidSmallCraft(int playerId) {
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; iter = getPlayerEntities(getPlayer(playerId), false)</b>
<b class="nc">&nbsp;                .iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            Entity entity = iter.next();</b>
<b class="nc">&nbsp;            if ((entity instanceof SmallCraft)</b>
<b class="nc">&nbsp;                &amp;&amp; getTurn().isValidEntity(entity, this)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public PlanetaryConditions getPlanetaryConditions() {
<b class="nc">&nbsp;        return planetaryConditions;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPlanetaryConditions(PlanetaryConditions conditions) {
<b class="nc">&nbsp;        if (null == conditions) {</b>
<b class="nc">&nbsp;            System.err.println(&quot;Can&#39;t set the planetary conditions to null!&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            planetaryConditions.alterConditions(conditions);</b>
<b class="nc">&nbsp;            processGameEvent(new GameSettingsChangeEvent(this));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addSmokeCloud(SmokeCloud cloud) {
<b class="nc">&nbsp;        smokeCloudList.add(cloud);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public List&lt;SmokeCloud&gt; getSmokeCloudList() {
<b class="nc">&nbsp;        return smokeCloudList;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void removeSmokeClouds(List&lt;SmokeCloud&gt; cloudsToRemove) {
<b class="nc">&nbsp;        for (SmokeCloud cloud : cloudsToRemove) {</b>
<b class="nc">&nbsp;            smokeCloudList.remove(cloud);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the map that maps a position to the list of Entity&#39;s in that
&nbsp;     * position.
&nbsp;     *
&nbsp;     * @param e
&nbsp;     */
&nbsp;    public synchronized void updateEntityPositionLookup(Entity e,
&nbsp;            HashSet&lt;Coords&gt; oldPositions) {
<b class="nc">&nbsp;        HashSet&lt;Coords&gt; newPositions = e.getOccupiedCoords();</b>
&nbsp;        // Check to see that the position has actually changed
<b class="nc">&nbsp;        if (newPositions.equals(oldPositions)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Remove the old cached location(s)
<b class="nc">&nbsp;        if (oldPositions != null) {</b>
<b class="nc">&nbsp;            for (Coords pos : oldPositions) {</b>
<b class="nc">&nbsp;                HashSet&lt;Integer&gt; posEntities = entityPosLookup.get(pos);</b>
<b class="nc">&nbsp;                if (posEntities != null) {</b>
<b class="nc">&nbsp;                    posEntities.remove(e.getId());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Add Entity for each position
<b class="nc">&nbsp;        for (Coords pos : newPositions) {</b>
<b class="nc">&nbsp;            HashSet&lt;Integer&gt; posEntities = entityPosLookup.get(pos);</b>
<b class="nc">&nbsp;            if (posEntities == null) {</b>
<b class="nc">&nbsp;                posEntities = new HashSet&lt;Integer&gt;();</b>
<b class="nc">&nbsp;                posEntities.add(e.getId());</b>
<b class="nc">&nbsp;                entityPosLookup.put(pos, posEntities);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                posEntities.add(e.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void removeEntityPositionLookup(Entity e) {
&nbsp;        // Remove Entity from cache
<b class="nc">&nbsp;        for (Coords pos : e.getOccupiedCoords()) {</b>
<b class="nc">&nbsp;            HashSet&lt;Integer&gt; posEntities = entityPosLookup.get(pos);</b>
<b class="nc">&nbsp;            if (posEntities != null) {</b>
<b class="nc">&nbsp;                posEntities.remove(e.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void resetEntityPositionLookup() {
<b class="nc">&nbsp;        entityPosLookup.clear();</b>
<b class="nc">&nbsp;        for (Entity e : entities) {</b>
<b class="nc">&nbsp;            updateEntityPositionLookup(e, null);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private int countEntitiesInCache(List&lt;Integer&gt; entitiesInCache) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Coords c : entityPosLookup.keySet()) {</b>
<b class="nc">&nbsp;            count += entityPosLookup.get(c).size();</b>
<b class="nc">&nbsp;            entitiesInCache.addAll(entityPosLookup.get(c));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * A check to ensure that the position cache is properly updated.  This 
&nbsp;     * is only used for debugging purposes, and will cause a number of things
&nbsp;     * to slow down.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void checkPositionCacheConsistency() {
&nbsp;        // Sanity check on the position cache
&nbsp;        //  This could be removed once we are confident the cache is working
<b class="nc">&nbsp;        List&lt;Integer&gt; entitiesInCache = new ArrayList&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; entitiesInVector = new ArrayList&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        int entitiesInCacheCount = countEntitiesInCache(entitiesInCache);</b>
<b class="nc">&nbsp;        int entityVectorSize = 0;</b>
<b class="nc">&nbsp;        for (Entity e : entities) {</b>
<b class="nc">&nbsp;            if (e.getPosition() != null) {</b>
<b class="nc">&nbsp;                entityVectorSize++;</b>
<b class="nc">&nbsp;                entitiesInVector.add(e.getId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Collections.sort(entitiesInCache);</b>
<b class="nc">&nbsp;        Collections.sort(entitiesInVector);</b>
<b class="nc">&nbsp;        if ((entitiesInCacheCount != entityVectorSize)</b>
<b class="nc">&nbsp;                &amp;&amp; (getPhase() != Phase.PHASE_DEPLOYMENT)</b>
<b class="nc">&nbsp;                &amp;&amp; (getPhase() != Phase.PHASE_EXCHANGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (getPhase() != Phase.PHASE_LOUNGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (getPhase() != Phase.PHASE_INITIATIVE_REPORT)</b>
<b class="nc">&nbsp;                &amp;&amp; (getPhase() != Phase.PHASE_INITIATIVE)) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;Entities vector has &quot; + entities.size()</b>
<b class="nc">&nbsp;                    + &quot; but pos lookup cache has &quot; + entitiesInCache.size()</b>
&nbsp;                    + &quot; entities!&quot;);
<b class="nc">&nbsp;            List&lt;Integer&gt; missingIds = new ArrayList&lt;Integer&gt;();</b>
<b class="nc">&nbsp;            for (Integer id : entitiesInVector) {</b>
<b class="nc">&nbsp;                if (!entitiesInCache.contains(id)) {</b>
<b class="nc">&nbsp;                    missingIds.add(id);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            System.out.println(&quot;Missing ids: &quot; + missingIds);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity e : entities) {</b>
<b class="nc">&nbsp;            HashSet&lt;Coords&gt; positions = e.getOccupiedCoords();</b>
<b class="nc">&nbsp;            for (Coords c : positions) {</b>
<b class="nc">&nbsp;                HashSet&lt;Integer&gt; ents = entityPosLookup.get(c);</b>
<b class="nc">&nbsp;                if ((ents != null) &amp;&amp; !ents.contains(e.getId())) {</b>
<b class="nc">&nbsp;                    System.out.println(&quot;Entity &quot; + e.getId() + &quot; is in &quot;</b>
<b class="nc">&nbsp;                            + e.getPosition() + &quot; however the position cache &quot;</b>
&nbsp;                            + &quot;does not have it in that position!&quot;);
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Coords c : entityPosLookup.keySet()) {</b>
<b class="nc">&nbsp;            for (Integer eId : entityPosLookup.get(c)) {</b>
<b class="nc">&nbsp;                Entity e = getEntity(eId);</b>
<b class="nc">&nbsp;                if (e == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                HashSet&lt;Coords&gt; positions = e.getOccupiedCoords();</b>
<b class="nc">&nbsp;                if (!positions.contains(c)) {</b>
<b class="nc">&nbsp;                    System.out.println(&quot;Entity Position Cache thinks Entity &quot;</b>
&nbsp;                            + eId + &quot;is in &quot; + c
&nbsp;                            + &quot; but the Entity thinks it&#39;s in &quot;
<b class="nc">&nbsp;                            + e.getPosition());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get a string representation of the UUId for this game.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public String getUUIDString() {
<b class="nc">&nbsp;        if (uuid == null) {</b>
<b class="nc">&nbsp;            uuid = UUID.randomUUID();</b>
&nbsp;        }
<b class="nc">&nbsp;        return uuid.toString();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
