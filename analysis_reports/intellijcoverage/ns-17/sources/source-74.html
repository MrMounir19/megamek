


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MovePath</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: MovePath (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MovePath</td>
<td class="coverageStat">
  <span class="percent">
    10.4%
  </span>
  <span class="absValue">
    (10/96)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.4%
  </span>
  <span class="absValue">
    (26/763)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MovePath$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MovePath$Key</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$099CxPPk</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$0a8xoVrm</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$0Hd4eqsH</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$0NaLrZEQ</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$0QjsJrMH</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$0yuqid7N</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$1do3jCkO</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$1oQgaNt8</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$1WBIeBMU</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$2hARjXuX</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$4uRbiraB</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$6I3rNWIU</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$84YybISn</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$8Ok7rOGI</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$9Ye4AqU9</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$aPQP7QAd</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$B8EN4Vb0</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$bAFZgoxr</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Bi38cJQ7</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$cbicEcCs</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$cMqXtaoc</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$csWHp4Cm</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$ct6MtSFD</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$CuFzSjUH</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$CuPMiiCS</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$D83zrjwc</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Dao7Dkup</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$dDI0n9UL</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$dgOrrv7h</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$DhSmjhkk</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Dynpl8j6</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$eK22BFg6</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$eoJuAbgo</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$gKC7SbRc</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$gmNvzlRm</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$gt9zJjXF</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$gvJvz9gK</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Hc2nJI0F</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$hxIopYaJ</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$IY6DGx88</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$jG6OAiMu</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$jIaTfZ16</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$LkOGxOJE</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$lS16qDzz</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$m2lwVv2x</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$mGGELKeL</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$MU16VW5H</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$nHbJ0qnc</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$NoVHXZR4</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$NtzTGV8u</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$NufueP9q</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$o2L6l9cl</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$oiRAxyzm</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$PbBOgKrp</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$pbrbAyGF</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$PEK88T3k</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Qup222Mc</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$QxDUlbr5</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$RJtEH6Zc</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Rml3wH1Q</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$S8Vj8vaV</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$SgJqXVPS</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$SsutrpUi</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$SvupNAvU</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$t9ATv7MC</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$twlYmk5Z</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$U86l3ukq</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$U9eVssfm</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$uMfkrEI1</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$vhJbefav</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$WAI5Qqjq</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$WH0x4Udf</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$WMtovA6p</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$WyoYpGE5</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$XfSFNdpI</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$XnFKxPRJ</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$xZ8NuVAn</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Y8J0IuAW</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$Yb1L6Y09</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$YerdvyR0</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$ykuA57tG</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$ZD2r2DAC</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$zebCy49G</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$zlEvo1kL</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$zqX4EY48</td>
  </tr>
  <tr>
    <td class="name">MovePath$MockitoMock$1784766039$auxiliary$zxmlvlif</td>
  </tr>
  <tr>
    <td class="name">MovePath$MovePathComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MovePath$MoveStepType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    10.6%
  </span>
  <span class="absValue">
    (11/104)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.2%
  </span>
  <span class="absValue">
    (34/804)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.PriorityQueue;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.client.bot.princess.CardinalEdge;
&nbsp;import megamek.client.bot.princess.Princess;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.logging.LogLevel;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.pathfinder.AbstractPathFinder;
&nbsp;import megamek.common.pathfinder.CachedEntityState;
&nbsp;import megamek.common.pathfinder.DestructionAwareDestinationPathfinder;
&nbsp;import megamek.common.pathfinder.ShortestPathFinder;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;
&nbsp;/**
&nbsp; * Holds movement path for an entity.
&nbsp; */
&nbsp;public class MovePath implements Cloneable, Serializable {
&nbsp;    private static final long serialVersionUID = -4258296679177532986L;
&nbsp;
<b class="fc">&nbsp;    private Set&lt;Coords&gt; coordsSet = null;</b>
<b class="fc">&nbsp;    private final transient Object COORD_SET_LOCK = new Object();</b>
&nbsp;    private transient CachedEntityState cachedEntityState;
&nbsp;
&nbsp;    public IGame getGame() {
<b class="nc">&nbsp;        return game;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setGame(IGame game) {
<b class="fc">&nbsp;        this.game = game;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setEntity(Entity entity) {
<b class="fc">&nbsp;        this.entity = entity;</b>
<b class="fc">&nbsp;        cachedEntityState = new CachedEntityState(entity);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    public enum MoveStepType {</b>
<b class="fc">&nbsp;        NONE, FORWARDS, BACKWARDS, TURN_LEFT, TURN_RIGHT, GET_UP, GO_PRONE, START_JUMP, CHARGE, DFA,</b>
<b class="fc">&nbsp;        FLEE, LATERAL_LEFT, LATERAL_RIGHT, LATERAL_LEFT_BACKWARDS, LATERAL_RIGHT_BACKWARDS, UNJAM_RAC,</b>
<b class="fc">&nbsp;        LOAD, UNLOAD, EJECT, CLEAR_MINEFIELD, UP, DOWN, SEARCHLIGHT, LAY_MINE, HULL_DOWN, CLIMB_MODE_ON,</b>
<b class="fc">&nbsp;        CLIMB_MODE_OFF, SWIM, DIG_IN, FORTIFY, SHAKE_OFF_SWARMERS, TAKEOFF, VTAKEOFF, LAND, ACC, DEC, EVADE,</b>
<b class="fc">&nbsp;        SHUTDOWN, STARTUP, SELF_DESTRUCT, ACCN, DECN, ROLL, OFF, RETURN, LAUNCH, THRUST, YAW, CRASH, RECOVER,</b>
<b class="fc">&nbsp;        RAM, HOVER, MANEUVER, LOOP, CAREFUL_STAND, JOIN, DROP, VLAND, MOUNT, UNDOCK, TAKE_COVER,</b>
<b class="fc">&nbsp;        CONVERT_MODE, BOOTLEGGER, TOW, DISCONNECT;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Key {
&nbsp;        private final Coords coords;
&nbsp;        private final int facing;
&nbsp;        private final int type;
&nbsp;
<b class="nc">&nbsp;        public Key(final Coords coords, final int facing, final int type) {</b>
<b class="nc">&nbsp;            this.coords = coords;</b>
<b class="nc">&nbsp;            this.facing = facing;</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(final Object obj) {
<b class="nc">&nbsp;            if (!(obj instanceof Key)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            final Key s1 = (Key) obj;</b>
<b class="nc">&nbsp;            return (type == s1.type) &amp;&amp; (facing == s1.facing) &amp;&amp; coords.equals(s1.coords);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return type + (7 * (facing + (31 * coords.hashCode())));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private Vector&lt;MoveStep&gt; steps = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;    private transient IGame game;
&nbsp;    private transient Entity entity;
&nbsp;    
&nbsp;    // holds the types of steps present in this movement 
<b class="fc">&nbsp;    private Set&lt;MoveStepType&gt; containedStepTypes = new HashSet&lt;&gt;();</b>
&nbsp;    
&nbsp;    // whether this movePath take us directly over an enemy unit
&nbsp;    // useful for aircraft
&nbsp;    private boolean fliesOverEnemy;
&nbsp;
&nbsp;    public static final int DEFAULT_PATHFINDER_TIME_LIMIT = 500;
&nbsp;
&nbsp;    // is this move path being done using careful movement?
<b class="fc">&nbsp;    private boolean careful = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a new, empty, movement path object.
&nbsp;     */
<b class="fc">&nbsp;    public MovePath(final IGame game, final Entity entity) {</b>
<b class="fc">&nbsp;        this.setEntity(entity);</b>
<b class="fc">&nbsp;        this.setGame(game);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Entity getEntity() {
<b class="fc">&nbsp;        return entity;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public CachedEntityState getCachedEntityState() {
<b class="nc">&nbsp;        return cachedEntityState;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Key getKey() {
<b class="nc">&nbsp;        return new Key(getFinalCoords(), getFinalFacing(), getFinalProne() ? 0 : isJumping() ? 1 : 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        final StringBuffer sb = new StringBuffer();</b>
<b class="nc">&nbsp;        sb.append(&quot;MOVE PATH:&quot;);</b>
<b class="nc">&nbsp;        sb.append(this.getKey().hashCode());</b>
<b class="nc">&nbsp;        sb.append(&#39; &#39;); // it&#39;s useful to know for debugging purposes which path you&#39;re looking at.</b>
<b class="nc">&nbsp;        sb.append(&quot;Length: &quot; + this.length());</b>
<b class="nc">&nbsp;        sb.append(&quot;Final Coords: &quot; + this.getFinalCoords());</b>
<b class="nc">&nbsp;        sb.append(System.lineSeparator());</b>
&nbsp;        
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = steps.elements(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            sb.append(i.nextElement().toString());</b>
<b class="nc">&nbsp;            sb.append(&#39; &#39;);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if(!getGame().getBoard().contains(this.getFinalCoords())) {</b>
<b class="nc">&nbsp;            sb.append(&quot;OUT!&quot;);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if(this.getFliesOverEnemy()) {</b>
<b class="nc">&nbsp;            sb.append(&quot;E! &quot;);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of steps in this movement
&nbsp;     */
&nbsp;    public int length() {
<b class="nc">&nbsp;        return steps.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a new step to the movement path.
&nbsp;     *
&nbsp;     * @param type the type of movement.
&nbsp;     */
&nbsp;    public MovePath addStep(final MoveStepType type) {
&nbsp;        // TODO : detect steps off the map *here*.
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a new step to the movement path with the given target.
&nbsp;     *
&nbsp;     * @param type   the type of movement.
&nbsp;     * @param target the &lt;code&gt;Targetable&lt;/code&gt; object that is the target of this
&nbsp;     *               step. For example, the enemy being charged.
&nbsp;     */
&nbsp;    public MovePath addStep(final MoveStepType type, final Targetable target) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, target));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(final MoveStepType type, final Targetable target, final Coords pos) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, target, pos));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(final MoveStepType type, final int mineToLay) {
<b class="nc">&nbsp;        return addStep(type, -1, mineToLay);</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(final MoveStepType type, final int recover, final int mineToLay) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, recover, mineToLay));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(MoveStepType type, TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; targets) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, targets));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(final MoveStepType type, final boolean noCost) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, noCost));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(final MoveStepType type, final boolean noCost, final boolean isManeuver) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, noCost, isManeuver));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addStep(final MoveStepType type, final Minefield mf) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, type, mf));</b>
&nbsp;    }
&nbsp;
&nbsp;    public MovePath addManeuver(final int manType) {
<b class="nc">&nbsp;        return addStep(new MoveStep(this, MoveStepType.MANEUVER, -1, -1, manType));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean canShift() {
<b class="nc">&nbsp;        return ((getEntity() instanceof QuadMech</b>
&nbsp;                // QuadVee cannot shift in vee mode
<b class="nc">&nbsp;                &amp;&amp; !(getEntity() instanceof QuadVee</b>
<b class="nc">&nbsp;                        &amp;&amp; (entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE</b>
<b class="nc">&nbsp;                            || getEntity().isConvertingNow())))</b>
&nbsp;                // Maneuvering Ace allows Bipeds and VTOLs moving at cruise
&nbsp;                //  speed to perform a lateral shift
<b class="nc">&nbsp;                || (getEntity().isUsingManAce()</b>
<b class="nc">&nbsp;                    &amp;&amp; ((getEntity() instanceof BipedMech)</b>
<b class="nc">&nbsp;                        || ((getEntity() instanceof VTOL)</b>
<b class="nc">&nbsp;                        &amp;&amp; (getMpUsed() &lt;= getCachedEntityState().getWalkMP()))))</b>
<b class="nc">&nbsp;                || (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ADVANCED_MANEUVERS)</b>
<b class="nc">&nbsp;                        &amp;&amp; getEntity() instanceof Tank</b>
<b class="nc">&nbsp;                        &amp;&amp; (getEntity().getMovementMode() == EntityMovementMode.VTOL</b>
<b class="nc">&nbsp;                        || getEntity().getMovementMode() == EntityMovementMode.HOVER))</b>
<b class="nc">&nbsp;                || ((getEntity() instanceof TripodMech)</b>
<b class="nc">&nbsp;                    &amp;&amp; (((Mech) getEntity()).countBadLegs() == 0)))</b>
<b class="nc">&nbsp;                &amp;&amp; !isJumping();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this MovePath contains a lateral shift
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean containsLateralShift() {
<b class="nc">&nbsp;        return this.contains(MoveStepType.LATERAL_LEFT)</b>
<b class="nc">&nbsp;                || this.contains(MoveStepType.LATERAL_RIGHT)</b>
<b class="nc">&nbsp;                || this.contains(MoveStepType.LATERAL_LEFT_BACKWARDS)</b>
<b class="nc">&nbsp;                || this.contains(MoveStepType.LATERAL_RIGHT_BACKWARDS);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean containsVTOLBomb() {
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            if (step.isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected MovePath addStep(final MoveStep step) {
<b class="nc">&nbsp;        return addStep(step, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;Coords&gt; getCoordsSet() {
<b class="nc">&nbsp;        if (coordsSet != null) {</b>
<b class="nc">&nbsp;            return coordsSet;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        synchronized (COORD_SET_LOCK) {</b>
<b class="nc">&nbsp;            if (coordsSet != null) {</b>
<b class="nc">&nbsp;                return coordsSet;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            coordsSet = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (MoveStep step : getStepVector()) {</b>
<b class="nc">&nbsp;                if (step.getPosition() == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                coordsSet.add(step.getPosition());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return coordsSet;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes a step as part of this movement path. Then adds it to the
&nbsp;     * list.
&nbsp;     *
&nbsp;     * @param step
&nbsp;     */
&nbsp;    protected MovePath addStep(final MoveStep step, boolean compile) {
<b class="nc">&nbsp;        if (step == null) {</b>
<b class="nc">&nbsp;            System.err.println(new RuntimeException(&quot;Received NULL MoveStep&quot;));</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        steps.addElement(step);</b>
<b class="nc">&nbsp;        containedStepTypes.add(step.getType());</b>
&nbsp;        
<b class="nc">&nbsp;        final MoveStep prev = getStep(steps.size() - 2);</b>
&nbsp;
<b class="nc">&nbsp;        if (compile) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                step.compile(getGame(), getEntity(), prev, getCachedEntityState());</b>
<b class="nc">&nbsp;            } catch (final RuntimeException re) {</b>
&nbsp;                // // N.B. the pathfinding will try steps off the map.
&nbsp;                // re.printStackTrace();
<b class="nc">&nbsp;                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // check for illegal jumps
<b class="nc">&nbsp;        final Coords start = getEntity().getPosition();</b>
<b class="nc">&nbsp;        final Coords land = step.getPosition();</b>
<b class="nc">&nbsp;        if ((start == null) || (land == null)) {</b>
&nbsp;            // If we have null for either coordinate then we know the step
&nbsp;            // isn&#39;t legal.
<b class="nc">&nbsp;            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;        } else {
&nbsp;            // if we&#39;re jumping without a mechanical jump booster (?)
&nbsp;            // or we&#39;re acting like a spheroid dropship in the atmosphere
<b class="nc">&nbsp;            if ((isJumping() &amp;&amp; (getEntity().getJumpType() != Mech.JUMP_BOOSTER)) ||</b>
<b class="nc">&nbsp;                    (Compute.useSpheroidAtmosphere(game, getEntity()) &amp;&amp; (step.getType() != MoveStepType.HOVER))) {</b>
<b class="nc">&nbsp;                int distance = start.distance(land);</b>
&nbsp;                
<b class="nc">&nbsp;                if (step.isThisStepBackwards() || (step.getDistance() &gt; distance)) {</b>
<b class="nc">&nbsp;                    step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Can&#39;t move backwards and Evade
<b class="nc">&nbsp;        if (!entity.isAirborne() &amp;&amp; contains(MoveStepType.BACKWARDS)</b>
<b class="nc">&nbsp;                &amp;&amp; contains(MoveStepType.EVADE)) {</b>
<b class="nc">&nbsp;            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If jumpships turn, they can&#39;t do anything else 
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
&nbsp;                &amp;&amp; (entity instanceof Jumpship)
&nbsp;                &amp;&amp; !(entity instanceof Warship)
<b class="nc">&nbsp;                &amp;&amp; !step.isFirstStep()</b>
<b class="nc">&nbsp;                &amp;&amp; (contains(MoveStepType.TURN_LEFT) </b>
<b class="nc">&nbsp;                        || contains(MoveStepType.TURN_RIGHT))) {</b>
<b class="nc">&nbsp;            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Ensure we only lay one mine
<b class="nc">&nbsp;        if ((step.getType() == MoveStepType.LAY_MINE)) {</b>
<b class="nc">&nbsp;            boolean containsOtherLayMineStep = false;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; steps.size() - 1; i++) {</b>
<b class="nc">&nbsp;                if (steps.get(i).getType() == MoveStepType.LAY_MINE) {</b>
<b class="nc">&nbsp;                    containsOtherLayMineStep = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (containsOtherLayMineStep) {</b>
<b class="nc">&nbsp;                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Ensure we only bomb one hex
<b class="nc">&nbsp;        if (step.isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;            boolean containsOtherBombStep = false;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; steps.size() - 1; i++) {</b>
<b class="nc">&nbsp;                if (steps.get(i).isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;                    containsOtherBombStep = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (containsOtherBombStep) {</b>
<b class="nc">&nbsp;                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Make sure we are not turning or changing elevation while strafing, and that we are not
&nbsp;        // starting a second group of hexes during the same round
<b class="nc">&nbsp;        if (step.isStrafingStep() &amp;&amp; steps.size() &gt; 1) {</b>
<b class="nc">&nbsp;            MoveStep last = steps.get(steps.size() - 2);</b>
&nbsp;            // If the previous step is a strafing step, make sure we have the same facing and elevation
&nbsp;            // and we are not exceeding the maximum five hexes.
<b class="nc">&nbsp;            if (last.isStrafingStep()) {</b>
<b class="nc">&nbsp;                if (step.getFacing() != last.getFacing()</b>
<b class="nc">&nbsp;                        || (step.getElevation() + getGame().getBoard().getHex(step.getPosition()).floor()</b>
<b class="nc">&nbsp;                            != last.getElevation() + getGame().getBoard().getHex(last.getPosition()).floor())</b>
<b class="nc">&nbsp;                        || steps.stream().filter(s -&gt; s.isStrafingStep()).count() &gt; 5) {</b>
<b class="nc">&nbsp;                    step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // If the previous step is not a strafing step, make sure that the new step is the only strafing
&nbsp;                // step we have in the path.
<b class="nc">&nbsp;                for (int i = 0; i &lt; steps.size() - 2; i++) {</b>
<b class="nc">&nbsp;                    if (steps.get(i).isStrafingStep()) {</b>
<b class="nc">&nbsp;                        step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // jumping into heavy woods is danger
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_PSR_JUMP_HEAVY_WOODS)) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(step.getPosition());</b>
<b class="nc">&nbsp;            if ((hex != null) &amp;&amp; isJumping() &amp;&amp; step.isEndPos(this)) {</b>
<b class="nc">&nbsp;                PilotingRollData psr = entity.checkLandingInHeavyWoods(step.getMovementType(false), hex);</b>
<b class="nc">&nbsp;                if (psr.getValue() != PilotingRollData.CHECK_FALSE) {</b>
<b class="nc">&nbsp;                    step.setDanger(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // VTOLs using maneuvering ace to make lateral shifts can&#39;t flank
&nbsp;        // unless using controlled sideslip
<b class="nc">&nbsp;        if (containsLateralShift() &amp;&amp; getEntity().isUsingManAce()</b>
<b class="nc">&nbsp;                &amp;&amp; (getEntity() instanceof VTOL)</b>
<b class="nc">&nbsp;                &amp;&amp; getMpUsed() &gt; getCachedEntityState().getWalkMP()</b>
<b class="nc">&nbsp;                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ADVANCED_MANEUVERS)) {</b>
<b class="nc">&nbsp;            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (shouldMechanicalJumpCauseFallDamage()) {</b>
<b class="nc">&nbsp;            step.setDanger(true);</b>
&nbsp;        }
&nbsp;       
&nbsp;        // If a tractor connects a new trailer this round, it can&#39;t do anything but add more trailers
&nbsp;        // This prevents the tractor from moving before its MP, stacking limitations and prohibited terrain can be updated by its trailers
&nbsp;        // It makes sense, too. You can&#39;t just connect a trailer and drive off with it in &lt;10 seconds. 
<b class="nc">&nbsp;        if (contains(MoveStepType.TOW) &amp;&amp; !(step.getType() == MoveStepType.TOW)) {</b>
<b class="nc">&nbsp;            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If the new step is legal and is a different position than
&nbsp;        // the previous step, then update the older steps, letting
&nbsp;        // them know that they are no longer the end of the path.
<b class="nc">&nbsp;        if (step.isLegal(this) &amp;&amp; (null != prev) &amp;&amp; !land.equals(prev.getPosition())) {</b>
&nbsp;
&nbsp;            // Loop through the steps from back to front.
&nbsp;            // Stop looping when the step says to, or we run out of steps.
<b class="nc">&nbsp;            int index = steps.size() - 2;</b>
<b class="nc">&nbsp;            while ((index &gt;= 0) &amp;&amp; getStep(index).setEndPos(false)) {</b>
<b class="nc">&nbsp;                index--;</b>
&nbsp;            }
&nbsp;
&nbsp;        } // End step-is-legal
&nbsp;
&nbsp;        // If using TacOps reverse gear option, cannot mix forward and backward movement
&nbsp;        // in the same round except VTOLs.
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_REVERSE_GEAR)</b>
&nbsp;                &amp;&amp; ((entity instanceof Tank &amp;&amp; !(entity instanceof VTOL))
&nbsp;                        || (entity instanceof QuadVee
<b class="nc">&nbsp;                                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))) {</b>
<b class="nc">&nbsp;            boolean fwd = false;</b>
<b class="nc">&nbsp;            boolean rev = false;</b>
<b class="nc">&nbsp;            for (MoveStep s : steps) {</b>
<b class="nc">&nbsp;                fwd |=  s.getType() == MoveStepType.FORWARDS</b>
<b class="nc">&nbsp;                        || s.getType() == MoveStepType.LATERAL_LEFT</b>
<b class="nc">&nbsp;                        || s.getType() == MoveStepType.LATERAL_RIGHT;</b>
<b class="nc">&nbsp;                rev |=  s.getType() == MoveStepType.BACKWARDS</b>
<b class="nc">&nbsp;                        || s.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</b>
<b class="nc">&nbsp;                        || s.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (fwd &amp;&amp; rev) {</b>
<b class="nc">&nbsp;                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;                
&nbsp;        // If we are using turn modes, go back through the path and mark danger for any turn
&nbsp;        // that now exceeds turn mode requirement. We want to show danger on the previous step
&nbsp;        // so the StepSprite will show danger. Hiding the previous step instead would make turning costs
&nbsp;        // show in the turning hex for units tracking turn mode, unlike other units.
<b class="nc">&nbsp;        if (entity.usesTurnMode() &amp;&amp; getMpUsed() &gt; 5) {</b>
<b class="nc">&nbsp;            int turnMode = getMpUsed() / 5;</b>
<b class="nc">&nbsp;            int nStraight = 0;</b>
<b class="nc">&nbsp;            MoveStep prevStep = steps.get(0);</b>
<b class="nc">&nbsp;            for (MoveStep s : steps) {</b>
<b class="nc">&nbsp;                if (s.isTurning() &amp;&amp; nStraight &lt; turnMode) {</b>
<b class="nc">&nbsp;                    prevStep.setDanger(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                nStraight = s.getNStraight();</b>
<b class="nc">&nbsp;                prevStep = s;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If running on pavement we don&#39;t know to mark the danger steps if we turn before expending
&nbsp;        // enough MP to require running movement.
<b class="nc">&nbsp;        if (steps.size() &gt; 1) {</b>
<b class="nc">&nbsp;            MoveStep lastStep = steps.get(steps.size() - 1);</b>
<b class="nc">&nbsp;            MoveStep prevStep = steps.get(0);</b>
<b class="nc">&nbsp;            for (MoveStep s : steps) {</b>
<b class="nc">&nbsp;                if (s.getMovementType(false) == EntityMovementType.MOVE_ILLEGAL) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                s.setDanger(s.isDanger() || Compute.isPilotingSkillNeeded(game, entity.getId(),</b>
<b class="nc">&nbsp;                        prevStep.getPosition(), s.getPosition(), lastStep.getMovementType(true),</b>
<b class="nc">&nbsp;                        prevStep.isTurning(), prevStep.isPavementStep(), prevStep.getElevation(),</b>
<b class="nc">&nbsp;                                s.getElevation(), s));</b>
<b class="nc">&nbsp;                s.setPastDanger(s.isPastDanger() || s.isDanger());</b>
<b class="nc">&nbsp;                prevStep = s;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if(step.useAeroAtmosphere(game, entity) </b>
<b class="nc">&nbsp;        		&amp;&amp; game.getBoard().onGround()											//we&#39;re an aerospace unit on a ground map</b>
<b class="nc">&nbsp;        		&amp;&amp; step.getPosition() != null  											//null</b>
<b class="nc">&nbsp;        		&amp;&amp; game.getFirstEnemyEntity(step.getPosition(), entity) != null) {</b>
<b class="nc">&nbsp;        	fliesOverEnemy = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void compile(final IGame g, final Entity en) {
<b class="nc">&nbsp;        compile(g, en, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void compile(final IGame g, final Entity en, boolean clip) {
<b class="nc">&nbsp;        setGame(g);</b>
<b class="nc">&nbsp;        setEntity(en);</b>
<b class="nc">&nbsp;        final Vector&lt;MoveStep&gt; temp = new Vector&lt;MoveStep&gt;(steps);</b>
<b class="nc">&nbsp;        steps.removeAllElements();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; temp.size(); i++) {</b>
<b class="nc">&nbsp;            MoveStep step = temp.elementAt(i);</b>
<b class="nc">&nbsp;            if ((step.getTargetPosition() != null) &amp;&amp; (step.getTarget(getGame()) != null)) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.getTarget(getGame()), step.getTargetPosition());</b>
<b class="nc">&nbsp;            } else if (step.getTarget(getGame()) != null) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.getTarget(getGame()));</b>
<b class="nc">&nbsp;            } else if (step.getRecoveryUnit() != -1) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.getRecoveryUnit(), -1);</b>
<b class="nc">&nbsp;            } else if (step.getMineToLay() != -1) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.getMineToLay());</b>
<b class="nc">&nbsp;            } else if (step.getLaunched().size() &gt; 0) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.getLaunched());</b>
<b class="nc">&nbsp;            } else if (step.getManeuverType() != ManeuverType.MAN_NONE) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), -1, -1, step.getManeuverType());</b>
<b class="nc">&nbsp;            } else if (step.isManeuver()) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.hasNoCost(), step.isManeuver());</b>
<b class="nc">&nbsp;            } else if (step.hasNoCost()) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.hasNoCost());</b>
<b class="nc">&nbsp;            } else if (null != step.getMinefield()) {</b>
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType(), step.getMinefield());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                step = new MoveStep(this, step.getType());</b>
&nbsp;            }
<b class="nc">&nbsp;            this.addStep(step);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t move out of a hex with an enemy unit unless we started
&nbsp;        // there, BUT we&#39;re allowed to turn, unload/disconnect, or go prone.
<b class="nc">&nbsp;        Coords pos = getEntity().getPosition();</b>
<b class="nc">&nbsp;        boolean isMech = getEntity() instanceof Mech;</b>
<b class="nc">&nbsp;        int elev = getEntity().getElevation();</b>
<b class="nc">&nbsp;        if (Compute.isEnemyIn(getGame(), getEntity(), pos, false, isMech, elev)) {</b>
&nbsp;            // There is an enemy, can&#39;t go out and back in, and go out again
<b class="nc">&nbsp;            boolean left = false;</b>
<b class="nc">&nbsp;            boolean returned = false;</b>
<b class="nc">&nbsp;            for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;                if (!left) {</b>
<b class="nc">&nbsp;                    if (!step.getPosition().equals(getEntity().getPosition())</b>
<b class="nc">&nbsp;                        || !(step.getElevation() == getEntity().getElevation())) {</b>
&nbsp;                        // we left the location
<b class="nc">&nbsp;                        left = true;</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                if (!returned) {</b>
<b class="nc">&nbsp;                    if (step.getPosition().equals(getEntity().getPosition())</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getElevation() == getEntity().getElevation())) {</b>
&nbsp;                        // we returned to the location
<b class="nc">&nbsp;                        returned = true;</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    continue;
&nbsp;                }
&nbsp;                // We&#39;ve returned, only following 5 types are legal
<b class="nc">&nbsp;                if ((step.getType() != MovePath.MoveStepType.TURN_LEFT)</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getType() != MovePath.MoveStepType.TURN_RIGHT)</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getType() != MovePath.MoveStepType.UNLOAD)</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getType() != MovePath.MoveStepType.DISCONNECT)</b>
<b class="nc">&nbsp;                        &amp;&amp; (step.getType() != MovePath.MoveStepType.GO_PRONE)) {</b>
&nbsp;                    // we only need to identify the first illegal move
<b class="nc">&nbsp;                    step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (getEntity() instanceof LandAirMech</b>
<b class="nc">&nbsp;                &amp;&amp; !((LandAirMech)getEntity()).canConvertTo(getFinalConversionMode())) {</b>
<b class="nc">&nbsp;            steps.forEach(s -&gt; {</b>
<b class="nc">&nbsp;                if (s.getType() == MoveStepType.CONVERT_MODE) {</b>
<b class="nc">&nbsp;                    s.setMovementType(EntityMovementType.MOVE_ILLEGAL);</b>
&nbsp;                }
<b class="nc">&nbsp;            });</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clip) {</b>
<b class="nc">&nbsp;            clipToPossible();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeLastStep() {
<b class="nc">&nbsp;        if (steps.size() &gt; 0) {</b>
<b class="nc">&nbsp;            final MoveStep step1 = getStep(steps.size() - 1);</b>
&nbsp;
<b class="nc">&nbsp;            if (step1.getType() == MovePath.MoveStepType.START_JUMP) {</b>
<b class="nc">&nbsp;                getEntity().setIsJumpingNow(false);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            steps.removeElementAt(steps.size() - 1);</b>
&nbsp;            
<b class="nc">&nbsp;            if (getEntity().isConvertingNow() &amp;&amp; !this.contains(MovePath.MoveStepType.CONVERT_MODE)) {</b>
<b class="nc">&nbsp;                getEntity().setConvertingNow(false);</b>
&nbsp;                //Mechs using tracks have the movement mode set at the beginning of the turn, so
&nbsp;                //it will need to be reset.
<b class="nc">&nbsp;                if (getEntity() instanceof Mech &amp;&amp; ((Mech)getEntity()).hasTracks()) {</b>
<b class="nc">&nbsp;                    getEntity().toggleConversionMode();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            //Treat multiple convert steps as a single command
<b class="nc">&nbsp;            if (step1.getType() == MovePath.MoveStepType.CONVERT_MODE)</b>
<b class="nc">&nbsp;                while (steps.size() &gt; 0</b>
<b class="nc">&nbsp;                    &amp;&amp; steps.get(steps.size() - 1).getType() == MovePath.MoveStepType.CONVERT_MODE) {</b>
<b class="nc">&nbsp;                steps.removeElementAt(steps.size() - 1);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // if this step is part of a manuever, undo the whole manuever, all the way to the beginning.
<b class="nc">&nbsp;            if(step1.isManeuver()) {</b>
<b class="nc">&nbsp;                int stepIndex = steps.size() - 1;</b>
&nbsp;                
<b class="nc">&nbsp;                while (steps.size() &gt; 0 &amp;&amp; steps.get(stepIndex).isManeuver()) {</b>
<b class="nc">&nbsp;                    steps.removeElementAt(stepIndex);</b>
<b class="nc">&nbsp;                    stepIndex--;</b>
&nbsp;                }
&nbsp;                
&nbsp;                // a maneuver begins with a &quot;maneuver&quot; step, so get rid of that as well
<b class="nc">&nbsp;                steps.removeElementAt(stepIndex);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Find the new last step in the path.
<b class="nc">&nbsp;        int index = steps.size() - 1;</b>
<b class="nc">&nbsp;        while ((index &gt;= 0) &amp;&amp; getStep(index).setEndPos(true)</b>
<b class="nc">&nbsp;                &amp;&amp; !getStep(index).isLegal(this)) {</b>
<b class="nc">&nbsp;            index--;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // we may have removed a lot of steps - recalculate the contained step types
<b class="nc">&nbsp;        regenerateStepTypes();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clear() {
<b class="nc">&nbsp;        steps.removeAllElements();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Enumeration&lt;MoveStep&gt; getSteps() {
<b class="nc">&nbsp;        return steps.elements();</b>
&nbsp;    }
&nbsp;
&nbsp;    public MoveStep getStep(final int index) {
<b class="nc">&nbsp;        if ((index &lt; 0) || (index &gt;= steps.size())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return steps.elementAt(index);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function that rebuilds the &quot;contained step types&quot; from scratch.
&nbsp;     * Loops over all the steps in the path, so should only be used when removing or replacing steps.
&nbsp;     */
&nbsp;    private void regenerateStepTypes() {
<b class="nc">&nbsp;        containedStepTypes.clear();</b>
<b class="nc">&nbsp;        for(MoveStep step : steps) {</b>
<b class="nc">&nbsp;            containedStepTypes.add(step.getType());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Check for any of the specified type of step in the path
&nbsp;     * @param type The step type to check for
&nbsp;     * @return Whether or not this step type is contained within this path 
&nbsp;     */
&nbsp;    public boolean contains(final MoveStepType type) {
<b class="fc">&nbsp;        return containedStepTypes.contains(type);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience function to determine whether this path results in the unit explicitly moving off board
&nbsp;     * More relevant for aircraft
&nbsp;     * @return Whether or not this path will result in the unit moving off board
&nbsp;     */
&nbsp;    public boolean fliesOffBoard() {
<b class="nc">&nbsp;    	return contains(MoveStepType.OFF) || </b>
<b class="nc">&nbsp;    	        contains(MoveStepType.RETURN) || </b>
<b class="nc">&nbsp;    	        contains(MoveStepType.FLEE);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Whether any of the steps in the path (except for the last one, based on experimentation)
&nbsp;     * pass over an enemy unit eligible for targeting. Useful for aerotech units.
&nbsp;     * Note that this is only useful for debugging against stationary targets, as it &quot;may&quot; become inaccurate
&nbsp;     * if the target moves.
&nbsp;     * @return Whether or not this flight path takes us over an enemy unit
&nbsp;     */
&nbsp;    public boolean getFliesOverEnemy() {
<b class="nc">&nbsp;    	return fliesOverEnemy;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method that determines whether a given path goes through a given set of x/y coordinates
&nbsp;     * Useful for debugging mainly.
&nbsp;     * Note that battletech map coordinates begin at 1, while the internal representation begins at 0
&nbsp;     * so subtract 1 from each axis to get the actual coordinates.
&nbsp;     * @param x X-coordinate
&nbsp;     * @param y Y-coordinate
&nbsp;     * @return Whether this path goes through the set of coordinates.
&nbsp;     */
&nbsp;    public boolean goesThroughCoords(int x, int y) {
<b class="nc">&nbsp;        Enumeration&lt;MoveStep&gt; steps = getSteps();</b>
<b class="nc">&nbsp;        while(steps.hasMoreElements()) {</b>
<b class="nc">&nbsp;            MoveStep step = steps.nextElement();</b>
<b class="nc">&nbsp;            if(step.getPosition().getX() == x &amp;&amp; step.getPosition().getY() == y) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Check for the presence of any step type that&#39;s not the specified step type in the move path
&nbsp;     * @param type The step type to check for
&nbsp;     * @return Whether or not there are any other step types 
&nbsp;     */
&nbsp;    public boolean containsAnyOther(final MoveStepType type) {
<b class="nc">&nbsp;    	for(Iterator&lt;MoveStepType&gt; iter = containedStepTypes.iterator(); iter.hasNext();) {</b>
<b class="nc">&nbsp;    		if(iter.next() != type)</b>
<b class="nc">&nbsp;				return true;</b>
&nbsp;    	}
&nbsp;    	
<b class="nc">&nbsp;    	return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for MASC use
&nbsp;     */
&nbsp;    public boolean hasActiveMASC() {
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = getSteps(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;            if (step.isUsingMASC()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the final coordinates if a mech were to perform all the steps in
&nbsp;     * this path.
&nbsp;     */
&nbsp;    public Coords getFinalCoords() {
<b class="nc">&nbsp;        if(getGame().useVectorMove()) {</b>
<b class="nc">&nbsp;            return Compute.getFinalPosition(getEntity().getPosition(), getFinalVectors());</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getPosition();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return getEntity().getPosition();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the starting {@link Coords} of this path.
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    public Coords getStartCoords() {
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; e = getSteps(); e.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final MoveStep step = e.nextElement();</b>
<b class="nc">&nbsp;            final Coords coords = step.getPosition();</b>
<b class="nc">&nbsp;            if (coords != null) {</b>
<b class="nc">&nbsp;                return coords;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the final facing if a mech were to perform all the steps in this
&nbsp;     * path.
&nbsp;     */
&nbsp;    public int getFinalFacing() {
<b class="nc">&nbsp;        MoveStep last = getLastStep();</b>
<b class="nc">&nbsp;        if (last != null) {</b>
<b class="nc">&nbsp;            return last.getFacing();</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().getFacing();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether or not a unit would end up prone after all of the steps
&nbsp;     */
&nbsp;    public boolean getFinalProne() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().isProne();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getEntity() == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().isProne();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether or not a unit would end up hull-down after all of the steps
&nbsp;     */
&nbsp;    public boolean getFinalHullDown() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().isHullDown();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getEntity() == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().isHullDown();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether or not a unit would be in climb mode after all the steps
&nbsp;     */
&nbsp;    public boolean getFinalClimbMode() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().climbMode();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getEntity() == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().climbMode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get final elevation relative to the hex.
&nbsp;     */
&nbsp;    public int getFinalElevation() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getElevation();</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().getElevation();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * get final elevation relative to the tops of any buildings in the hex
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getFinalClearance() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getClearance();</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex hex = entity.getGame().getBoard().getHex(getEntity().getPosition());</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            return getEntity().getElevation() - hex.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().getElevation();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the highest elevation in the current path
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getMaxElevation() {
<b class="nc">&nbsp;        int maxElev = 0;</b>
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            maxElev = Math.max(maxElev,</b>
<b class="nc">&nbsp;                    getGame().getBoard().getHex(step.getPosition()).getLevel());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return maxElev;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get final altitude
&nbsp;     */
&nbsp;    public int getFinalAltitude() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getAltitude();</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().getAltitude();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFinalVelocity() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getVelocity();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getEntity().isAero()) {</b>
<b class="nc">&nbsp;            return ((IAero) getEntity()).getCurrentVelocity();</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int getFinalVelocityLeft() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getVelocityLeft();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getEntity().isAero()) {</b>
<b class="nc">&nbsp;            return ((IAero) getEntity()).getCurrentVelocity();</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFinalNDown() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getNDown();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * If the path contains mode conversions, this will determine the movement mode at the end
&nbsp;     * of movement. Note that LAMs converting from AirMech to Biped mode require two convert commands.
&nbsp;     * 
&nbsp;     * @return The movement mode resulting from any mode conversions in the path.
&nbsp;     */
&nbsp;    public EntityMovementMode getFinalConversionMode() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getMovementMode();</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().getMovementMode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the final vector for advanced movement
&nbsp;     */
&nbsp;    public int[] getFinalVectors() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getVectors();</b>
&nbsp;        }
<b class="nc">&nbsp;        return getEntity().getVectors();</b>
&nbsp;    }
&nbsp;
&nbsp;    public EntityMovementType getLastStepMovementType() {
<b class="fc">&nbsp;        if (getLastStep() == null) {</b>
<b class="fc">&nbsp;            return EntityMovementType.MOVE_NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getLastStep().getMovementType(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;MoveStep&gt; getStepVector() {
<b class="fc">&nbsp;        return steps;</b>
&nbsp;    }
&nbsp;
&nbsp;    public MoveStep getLastStep() {
<b class="fc">&nbsp;        for (int i = getStepVector().size() - 1; i &gt;= 0; i--) {</b>
<b class="fc">&nbsp;            MoveStep last = getStepVector().get(i);</b>
<b class="fc">&nbsp;            if (last != null) {</b>
<b class="fc">&nbsp;                return last;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public MoveStep getSecondLastStep() {
<b class="nc">&nbsp;        if (steps.size() &gt; 1) {</b>
<b class="nc">&nbsp;            return getStep(steps.size() - 2);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getLastStep();</b>
&nbsp;    }
&nbsp;
&nbsp;    /* Debug method */
&nbsp;    public void printAllSteps() {
<b class="nc">&nbsp;        System.out.println(&quot;*Steps*&quot;);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; steps.size(); i++) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;  &quot; + i + &quot;: &quot; + getStep(i) + &quot;, &quot; + getStep(i).getMovementType(i == (steps.size() - 1)));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes impossible steps.
&nbsp;     */
&nbsp;    public void clipToPossible() {
<b class="nc">&nbsp;        if (steps.size() == 0) {</b>
&nbsp;            // nothing to clip
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // Do final check for bad moves, and clip movement after first bad one
&nbsp;        // also clear and re-constitute &quot;contained steps&quot; cache
<b class="nc">&nbsp;        containedStepTypes = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        final Vector&lt;MoveStep&gt; goodSteps = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            if (step.getMovementType(isEndStep(step)) != EntityMovementType.MOVE_ILLEGAL) {</b>
<b class="nc">&nbsp;                containedStepTypes.add(step.getType());</b>
<b class="nc">&nbsp;                goodSteps.addElement(step);</b>
&nbsp;            } else {
&nbsp;                break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        steps = goodSteps;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Changes turn-forwards-opposite-turn sequences into quad lateral shifts.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Finds the sequence of three steps that can be transformed, then removes
&nbsp;     * all three and replaces them with the lateral shift step.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void transformLateralShift() {
<b class="nc">&nbsp;        if (steps.size() &lt; 3) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        final int index = steps.size() - 3;</b>
<b class="nc">&nbsp;        final MoveStep step1 = getStep(index);</b>
<b class="nc">&nbsp;        final MoveStep step2 = getStep(index + 1);</b>
<b class="nc">&nbsp;        final MoveStep step3 = getStep(index + 2);</b>
&nbsp;
<b class="nc">&nbsp;        if (step1.oppositeTurn(step3)</b>
<b class="nc">&nbsp;                &amp;&amp; ((step2.getType() == MovePath.MoveStepType.BACKWARDS) || (step2.getType() == MovePath.MoveStepType.FORWARDS))) {</b>
<b class="nc">&nbsp;            final MoveStepType stepType = step1.getType();</b>
<b class="nc">&nbsp;            final MoveStepType direction = step2.getType();</b>
&nbsp;            // remove all old steps
<b class="nc">&nbsp;            steps.removeElementAt(index);</b>
<b class="nc">&nbsp;            steps.removeElementAt(index);</b>
<b class="nc">&nbsp;            steps.removeElementAt(index);</b>
&nbsp;            // add new step
<b class="nc">&nbsp;            final MoveStep shift = new MoveStep(this, lateralShiftForTurn(stepType, direction));</b>
<b class="nc">&nbsp;            addStep(shift);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the lateral shift that corresponds to the turn direction
&nbsp;     */
&nbsp;    public static MoveStepType lateralShiftForTurn(final MoveStepType turn, final MoveStepType direction) {
<b class="nc">&nbsp;        if (direction == MoveStepType.FORWARDS) {</b>
<b class="nc">&nbsp;            switch (turn) {</b>
&nbsp;                case TURN_LEFT:
<b class="nc">&nbsp;                    return MoveStepType.LATERAL_LEFT;</b>
&nbsp;                case TURN_RIGHT:
<b class="nc">&nbsp;                    return MoveStepType.LATERAL_RIGHT;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    return turn;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        switch (turn) {</b>
&nbsp;            case TURN_LEFT:
<b class="nc">&nbsp;                return MoveStepType.LATERAL_LEFT_BACKWARDS;</b>
&nbsp;            case TURN_RIGHT:
<b class="nc">&nbsp;                return MoveStepType.LATERAL_RIGHT_BACKWARDS;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return turn;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the turn direction that corresponds to the lateral shift
&nbsp;     */
&nbsp;    static MoveStepType turnForLateralShift(final MoveStepType shift) {
<b class="nc">&nbsp;        switch (shift) {</b>
&nbsp;            case LATERAL_LEFT:
<b class="nc">&nbsp;                return MoveStepType.TURN_LEFT;</b>
&nbsp;            case LATERAL_RIGHT:
<b class="nc">&nbsp;                return MoveStepType.TURN_RIGHT;</b>
&nbsp;            case LATERAL_LEFT_BACKWARDS:
<b class="nc">&nbsp;                return MoveStepType.TURN_LEFT;</b>
&nbsp;            case LATERAL_RIGHT_BACKWARDS:
<b class="nc">&nbsp;                return MoveStepType.TURN_RIGHT;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return shift;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the direction (either MovePath.MoveStepType.TURN_LEFT or
&nbsp;     * MoveStepType.TURN_RIGHT) that the destination facing lies in.
&nbsp;     */
&nbsp;    public static MoveStepType getDirection(final int facing, final int destFacing) {
<b class="nc">&nbsp;        final int rotate = (destFacing + (6 - facing)) % 6;</b>
<b class="nc">&nbsp;        return rotate &gt;= 3 ? MoveStepType.TURN_LEFT : MoveStepType.TURN_RIGHT;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the adjusted facing, given the start facing.
&nbsp;     */
&nbsp;    public static int getAdjustedFacing(final int facing, final MoveStepType movement) {
<b class="nc">&nbsp;        if (movement == MoveStepType.TURN_RIGHT) {</b>
<b class="nc">&nbsp;            return (facing + 1) % 6;</b>
<b class="nc">&nbsp;        } else if (movement == MoveStepType.TURN_LEFT) {</b>
<b class="nc">&nbsp;            return (facing + 5) % 6;</b>
&nbsp;        }
<b class="nc">&nbsp;        return facing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of MPs used in the path
&nbsp;     */
&nbsp;    public int getMpUsed() {
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getMpUsed();</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the logical number of hexes moved the path (does not count turns,
&nbsp;     * etc).
&nbsp;     */
&nbsp;    public int getHexesMoved() {
<b class="nc">&nbsp;        if (getLastStep() == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getLastStep().getDistance();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity is jumping or if it&#39;s a flying lam.
&nbsp;     */
&nbsp;    public boolean isJumping() {
<b class="fc">&nbsp;        return contains(MoveStepType.START_JUMP);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * @return true if the entity is a QuadVee or LAM changing movement mode
&nbsp;     */
&nbsp;    public boolean isChangingMode() {
<b class="nc">&nbsp;        return contains(MoveStepType.CONVERT_MODE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extend the current path to the destination &lt;code&gt;Coords&lt;/code&gt;, moving
&nbsp;     * only in one direction.  This method works by applying the supplied move
&nbsp;     * step as long as it moves closer to the destination.  If the destination
&nbsp;     * cannot be reached solely by the provided movestep, the pathfinder will
&nbsp;     * quit once it gets as closer as it can.
&nbsp;     *
&nbsp;     * @param dest      the destination &lt;code&gt;Coords&lt;/code&gt; of the move.
&nbsp;     * @param type      the type of movement step required.
&nbsp;     * @param direction the direction of movement.
&nbsp;     */
&nbsp;    public void findSimplePathTo(final Coords dest, final MoveStepType type,
&nbsp;                                 int direction, int facing) {
<b class="nc">&nbsp;        Coords src = getFinalCoords();</b>
<b class="nc">&nbsp;        Coords currStep = src;</b>
<b class="nc">&nbsp;        Coords nextStep = currStep.translated(direction);</b>
<b class="nc">&nbsp;        while (dest.distance(nextStep) &lt; dest.distance(currStep)) {</b>
<b class="nc">&nbsp;            addStep(type);</b>
<b class="nc">&nbsp;            currStep = nextStep;</b>
<b class="nc">&nbsp;            nextStep = currStep.translated(direction);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Did we reach the destination?  If not, try another direction
<b class="nc">&nbsp;        if (!currStep.equals(dest)) {</b>
<b class="nc">&nbsp;            int dir = currStep.direction(dest);</b>
&nbsp;            // Java does mod different from how we want...
<b class="nc">&nbsp;            dir = (((dir - facing) % 6) + 6) % 6;</b>
<b class="nc">&nbsp;            switch (dir) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    findSimplePathTo(dest, MoveStepType.FORWARDS, currStep.direction(dest), facing);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    findSimplePathTo(dest, MoveStepType.LATERAL_RIGHT, currStep.direction(dest), facing);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 2:
&nbsp;                    // TODO: backwards lateral shifts are switched:
&nbsp;                    //  LATERAL_LEFT_BACKWARDS moves back+right and vice-versa
<b class="nc">&nbsp;                    findSimplePathTo(dest, MoveStepType.LATERAL_LEFT_BACKWARDS, currStep.direction(dest), facing);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    findSimplePathTo(dest, MoveStepType.BACKWARDS, currStep.direction(dest), facing);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 4:
&nbsp;                    // TODO: backwards lateral shifts are switched:
&nbsp;                    //  LATERAL_LEFT_BACKWARDS moves back+right and vice-versa
<b class="nc">&nbsp;                    findSimplePathTo(dest, MoveStepType.LATERAL_RIGHT_BACKWARDS, currStep.direction(dest), facing);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    findSimplePathTo(dest, MoveStepType.LATERAL_LEFT, currStep.direction(dest), facing);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Extend the current path to the destination &lt;code&gt;Coords&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param dest the destination &lt;code&gt;Coords&lt;/code&gt; of the move.
&nbsp;     * @param type the type of movement step required.
&nbsp;     */
&nbsp;    public void findPathTo(final Coords dest, final MoveStepType type) {
<b class="nc">&nbsp;        final int timeLimit = PreferenceManager.getClientPreferences().getMaxPathfinderTime();</b>
&nbsp;
<b class="nc">&nbsp;        ShortestPathFinder pf = ShortestPathFinder.newInstanceOfAStar(dest, type, game);</b>
&nbsp;
<b class="nc">&nbsp;        AbstractPathFinder.StopConditionTimeout&lt;MovePath&gt; timeoutCondition = new AbstractPathFinder.StopConditionTimeout&lt;&gt;(timeLimit);</b>
<b class="nc">&nbsp;        pf.addStopCondition(timeoutCondition);</b>
&nbsp;
<b class="nc">&nbsp;        pf.run(this.clone());</b>
<b class="nc">&nbsp;        MovePath finPath = pf.getComputedPath(dest);</b>
&nbsp;        // this can be used for debugging the &quot;destruction aware pathfinder&quot;
&nbsp;        //MovePath finPath = calculateDestructionAwarePath(dest);
&nbsp;
<b class="nc">&nbsp;        if (timeoutCondition.timeoutEngaged || finPath == null) {</b>
&nbsp;            /*
&nbsp;             * Either we have forced searcher to end prematurely or no path was
&nbsp;             * found. Lets try to fix it by taking the path that ended closest
&nbsp;             * to the target and greedily extend it.
&nbsp;             */
<b class="nc">&nbsp;            MovePath bestMp = Collections.min(pf.getAllComputedPaths().values(), new ShortestPathFinder.MovePathGreedyComparator(dest));</b>
<b class="nc">&nbsp;            pf = ShortestPathFinder.newInstanceOfGreedy(dest, type, game);</b>
<b class="nc">&nbsp;            pf.run(bestMp);</b>
<b class="nc">&nbsp;            finPath = pf.getComputedPath(dest);</b>
&nbsp;            // If no path could be found, use the best one returned by A*
<b class="nc">&nbsp;            if (finPath == null) {</b>
<b class="nc">&nbsp;                finPath = bestMp;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (finPath != null) {</b>
<b class="nc">&nbsp;            finPath.compile(game, entity, false);</b>
<b class="nc">&nbsp;            this.steps = finPath.steps;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            System.out.println(&quot;Error: &quot; +</b>
&nbsp;                    &quot;Unable to find a path to the destination hex!&quot;);
<b class="nc">&nbsp;            System.out.println(&quot;\tMoving &quot; + getEntity() + &quot;from &quot;</b>
<b class="nc">&nbsp;                    + getFinalCoords() + &quot; to &quot; + dest);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isMoveLegal() {
&nbsp;        // Moves which end up off of the board are not legal.
<b class="nc">&nbsp;        if (!getGame().getBoard().contains(getFinalCoords())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // for aero units move must use up all their velocity
<b class="nc">&nbsp;        if (getEntity().isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) getEntity();</b>
<b class="nc">&nbsp;            if (getLastStep() == null) {</b>
<b class="nc">&nbsp;                if ((a.getCurrentVelocity() &gt; 0) &amp;&amp; !getGame().useVectorMove()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if ((getLastStep().getVelocityLeft() &gt; 0) &amp;&amp; !getGame().useVectorMove()</b>
<b class="nc">&nbsp;                        &amp;&amp; !(getLastStep().getType() == MovePath.MoveStepType.FLEE</b>
<b class="nc">&nbsp;                        || getLastStep().getType() == MovePath.MoveStepType.EJECT)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getLastStep() == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getLastStep().getType() == MoveStepType.CHARGE) {</b>
<b class="nc">&nbsp;            return getSecondLastStep().isLegal(this);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getLastStep().getType() == MoveStepType.RAM) {</b>
<b class="nc">&nbsp;            return getSecondLastStep().isLegal(this);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getLastStep().isLegal(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An A* pathfinder to get from the end of the current path (or entity&#39;s
&nbsp;     * position if empty) to the destination.
&nbsp;     *
&nbsp;     * @param dest      The goal hex
&nbsp;     * @param type      The type of move we want to do
&nbsp;     * @param timeLimit the maximum &lt;code&gt;int&lt;/code&gt; number of milliseconds to take
&nbsp;     *                  hunting for an ideal path.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    private void notSoLazyPathfinder(final Coords dest, final MoveStepType type,
&nbsp;                                     final int timeLimit) {
<b class="nc">&nbsp;        final int MAX_CANDIDATES = 100;</b>
<b class="nc">&nbsp;        final long endTime = System.currentTimeMillis() + timeLimit;</b>
&nbsp;
<b class="nc">&nbsp;        MoveStepType step = type;</b>
<b class="nc">&nbsp;        if (step != MoveStepType.BACKWARDS) {</b>
<b class="nc">&nbsp;            step = MoveStepType.FORWARDS;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final MovePathComparator mpc =</b>
&nbsp;                new MovePathComparator(dest, step == MoveStepType.BACKWARDS);
&nbsp;
<b class="nc">&nbsp;        MovePath bestPath = clone();</b>
&nbsp;
&nbsp;        // A collection of paths we have already explored
<b class="nc">&nbsp;        final HashMap&lt;MovePath.Key, MovePath&gt; discovered =</b>
&nbsp;                new HashMap&lt;MovePath.Key, MovePath&gt;();
<b class="nc">&nbsp;        discovered.put(bestPath.getKey(), bestPath);</b>
&nbsp;
&nbsp;        // A collection of hte possible next-moves
<b class="nc">&nbsp;        final PriorityQueue&lt;MovePath&gt; candidates =</b>
&nbsp;                new PriorityQueue&lt;MovePath&gt;(110, mpc);
<b class="nc">&nbsp;        candidates.add(bestPath);</b>
&nbsp;
<b class="nc">&nbsp;        boolean keepLooping = getFinalCoords().distance(dest) &gt; 1;</b>
<b class="nc">&nbsp;        int loopcount = 0;</b>
&nbsp;
&nbsp;        // Keep looping while we have candidates to explore, and certain stop
&nbsp;        //  conditions aren&#39;t met (time-limit, destination found, etc)
<b class="nc">&nbsp;        while ((candidates.size() &gt; 0) &amp;&amp; keepLooping) {</b>
<b class="nc">&nbsp;            final MovePath candidatePath = candidates.poll();</b>
<b class="nc">&nbsp;            final Coords startingPos = candidatePath.getFinalCoords();</b>
<b class="nc">&nbsp;            final int startingElev = candidatePath.getFinalElevation();</b>
&nbsp;
&nbsp;            // Check to see if we have found the destination
<b class="nc">&nbsp;            if (candidatePath.getFinalCoords().distance(dest) == 0) {</b>
<b class="nc">&nbsp;                bestPath = candidatePath;</b>
<b class="nc">&nbsp;                keepLooping = false;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Get next possible steps
<b class="nc">&nbsp;            final Iterator&lt;MovePath&gt; adjacent =</b>
<b class="nc">&nbsp;                    candidatePath.getNextMoves(step == MoveStepType.BACKWARDS,</b>
<b class="nc">&nbsp;                            step == MoveStepType.FORWARDS).iterator();</b>
&nbsp;            // Evaluate possible next steps
<b class="nc">&nbsp;            while (adjacent.hasNext()) {</b>
<b class="nc">&nbsp;                final MovePath expandedPath = adjacent.next();</b>
&nbsp;
<b class="nc">&nbsp;                if (expandedPath.getLastStep().isMovementPossible(getGame(),</b>
<b class="nc">&nbsp;                        startingPos, startingElev, getCachedEntityState())) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (discovered.containsKey(expandedPath.getKey())) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Make sure the candidate list doesn&#39;t get too big
<b class="nc">&nbsp;                    if (candidates.size() &lt;= MAX_CANDIDATES) {</b>
<b class="nc">&nbsp;                        candidates.add(expandedPath);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    discovered.put(expandedPath.getKey(), expandedPath);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // If we&#39;re doing a special movement, like charging or DFA, we will
&nbsp;            //  have to take extra steps to see if we can finish off the move
&nbsp;            //  this is because getNextMoves only considers turning and
&nbsp;            //  forward/backward movement
<b class="nc">&nbsp;            if (type == MoveStepType.CHARGE ||</b>
&nbsp;                    type == MoveStepType.DFA){
<b class="nc">&nbsp;                MovePath expandedPath = candidatePath.clone();</b>
<b class="nc">&nbsp;                expandedPath.addStep(type);</b>
<b class="nc">&nbsp;                if (expandedPath.getLastStep().isMovementPossible(getGame(),</b>
<b class="nc">&nbsp;                        startingPos, startingElev, getCachedEntityState())) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (discovered.containsKey(expandedPath.getKey())) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                    // Make sure the candidate list doesn&#39;t get too big
<b class="nc">&nbsp;                    if (candidates.size() &lt;= MAX_CANDIDATES) {</b>
<b class="nc">&nbsp;                        candidates.add(expandedPath);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    discovered.put(expandedPath.getKey(), expandedPath);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;
<b class="nc">&nbsp;            loopcount++;</b>
<b class="nc">&nbsp;            if (((loopcount % 256) == 0) &amp;&amp; keepLooping</b>
<b class="nc">&nbsp;                    &amp;&amp; (candidates.size() &gt; 0)) {</b>
<b class="nc">&nbsp;                final MovePath front = candidates.peek();</b>
<b class="nc">&nbsp;                if (front.getFinalCoords().distance(dest) &lt; bestPath</b>
<b class="nc">&nbsp;                        .getFinalCoords().distance(dest)) {</b>
<b class="nc">&nbsp;                    bestPath = front;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (System.currentTimeMillis() &gt; endTime) {</b>
<b class="nc">&nbsp;                    keepLooping = false;</b>
<b class="nc">&nbsp;                    System.out.println(&quot;Time limit reached searching &quot; +</b>
&nbsp;                            &quot;for path!&quot;);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } // end while</b>
&nbsp;        //System.out.println(&quot;iteration count: &quot; + loopcount);
<b class="nc">&nbsp;        if (getFinalCoords().distance(dest) &gt; bestPath.getFinalCoords().distance(dest)) {</b>
&nbsp;            // Make the path we found, this path.
<b class="nc">&nbsp;            steps = bestPath.steps;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!getFinalCoords().equals(dest)) {</b>
<b class="nc">&nbsp;            lazyPathfinder(dest, type);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Find the shortest path to the destination &lt;code&gt;Coords&lt;/code&gt; by hex
&nbsp;     * count. This right choice &lt;em&gt;only&lt;/em&gt; when making a simple move like a
&nbsp;     * straight line or one with a single turn.
&nbsp;     *
&nbsp;     * @param dest the destination &lt;code&gt;Coords&lt;/code&gt; of the move.
&nbsp;     * @param type the type of movment step required.
&nbsp;     */
&nbsp;    private void lazyPathfinder(final Coords dest, final MoveStepType type) {
<b class="nc">&nbsp;        MoveStepType step = MoveStepType.FORWARDS;</b>
<b class="nc">&nbsp;        if (type == MoveStepType.BACKWARDS) {</b>
<b class="nc">&nbsp;            step = MoveStepType.BACKWARDS;</b>
&nbsp;        }
<b class="nc">&nbsp;        Coords subDest = dest;</b>
<b class="nc">&nbsp;        if (!dest.equals(getFinalCoords())) {</b>
<b class="nc">&nbsp;            subDest = dest.translated(dest.direction(getFinalCoords()));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (!getFinalCoords().equals(subDest)) {</b>
&nbsp;            // adjust facing
<b class="nc">&nbsp;            rotatePathfinder((getFinalCoords().direction(subDest) + (step == MoveStepType.BACKWARDS ? 3 : 0)) % 6,</b>
&nbsp;                    false);
&nbsp;            // step forwards
<b class="nc">&nbsp;            addStep(step);</b>
&nbsp;        }
<b class="nc">&nbsp;        rotatePathfinder((getFinalCoords().direction(dest) + (step == MoveStepType.BACKWARDS ? 3 : 0)) % 6, false);</b>
<b class="nc">&nbsp;        if (!dest.equals(getFinalCoords())) {</b>
<b class="nc">&nbsp;            addStep(type);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of possible moves that result in a
&nbsp;     * facing/position/(jumping|prone) change, special steps (mine clearing and
&nbsp;     * such) must be handled elsewhere.
&nbsp;     */
&nbsp;    public List&lt;MovePath&gt; getNextMoves(boolean backward, boolean forward) {
<b class="nc">&nbsp;        final ArrayList&lt;MovePath&gt; result = new ArrayList&lt;MovePath&gt;();</b>
<b class="nc">&nbsp;        final MoveStep last = getLastStep();</b>
&nbsp;//        if (isJumping()) {
&nbsp;//            final MovePath left = clone();
&nbsp;//            final MovePath right = clone();
&nbsp;//
&nbsp;//            // From here, we can move F, LF, RF, LLF, RRF, and RRRF.
&nbsp;//            result.add(clone().addStep(MovePath.MoveStepType.FORWARDS));
&nbsp;//            for (int turn = 0; turn &lt; 2; turn++) {
&nbsp;//                left.addStep(MovePath.MoveStepType.TURN_LEFT);
&nbsp;//                right.addStep(MovePath.MoveStepType.TURN_RIGHT);
&nbsp;//                result.add(left.clone().addStep(MovePath.MoveStepType.FORWARDS));
&nbsp;//                result.add(right.clone().addStep(MovePath.MoveStepType.FORWARDS));
&nbsp;//            }
&nbsp;//            right.addStep(MovePath.MoveStepType.TURN_RIGHT);
&nbsp;//            result.add(right.addStep(MovePath.MoveStepType.FORWARDS));
&nbsp;//
&nbsp;//            // We&#39;ve got all our next steps.
&nbsp;//            return result;
&nbsp;//        }
&nbsp;
&nbsp;        // need to do a separate section here for Aeros.
&nbsp;        // just like jumping for now, but I could add some other stuff
&nbsp;        // here later
<b class="nc">&nbsp;        if (getEntity().isAero()) {</b>
<b class="nc">&nbsp;            MovePath left = clone();</b>
<b class="nc">&nbsp;            MovePath right = clone();</b>
&nbsp;
&nbsp;            // From here, we can move F, LF, RF, LLF, RRF, and RRRF.
<b class="nc">&nbsp;            result.add((clone()).addStep(MovePath.MoveStepType.FORWARDS));</b>
<b class="nc">&nbsp;            for (int turn = 0; turn &lt; 2; turn++) {</b>
<b class="nc">&nbsp;                left.addStep(MovePath.MoveStepType.TURN_LEFT);</b>
<b class="nc">&nbsp;                right.addStep(MovePath.MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;                result.add(left.clone().addStep(MovePath.MoveStepType.FORWARDS));</b>
<b class="nc">&nbsp;                result.add(right.clone().addStep(MovePath.MoveStepType.FORWARDS));</b>
&nbsp;            }
<b class="nc">&nbsp;            right.addStep(MovePath.MoveStepType.TURN_RIGHT);</b>
<b class="nc">&nbsp;            result.add(right.addStep(MovePath.MoveStepType.FORWARDS));</b>
&nbsp;
&nbsp;            // We&#39;ve got all our next steps.
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the unit is prone or hull-down it limits movement options, unless
&nbsp;        //  it&#39;s a tank; tanks can just drive out of hull-down and they cannot
&nbsp;        //  be prone.
<b class="nc">&nbsp;        if (getFinalProne() || (getFinalHullDown() &amp;&amp; !(getEntity() instanceof Tank))) {</b>
<b class="nc">&nbsp;            if ((last != null) &amp;&amp; (last.getType() != MoveStepType.TURN_RIGHT)) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.TURN_LEFT));</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((last != null) &amp;&amp; (last.getType() != MoveStepType.TURN_LEFT)) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.TURN_RIGHT));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (getEntity().isCarefulStand()) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.CAREFUL_STAND));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.GET_UP));</b>
&nbsp;            }
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (canShift()) {</b>
<b class="nc">&nbsp;            if (forward &amp;&amp; (!backward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_LEFT)))) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MoveStepType.LATERAL_RIGHT));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (forward &amp;&amp; (!backward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_RIGHT)))) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.LATERAL_LEFT));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (backward</b>
<b class="nc">&nbsp;                    &amp;&amp; (!forward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_LEFT_BACKWARDS)))) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.LATERAL_RIGHT_BACKWARDS));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (backward</b>
<b class="nc">&nbsp;                    &amp;&amp; (!forward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_RIGHT_BACKWARDS)))) {</b>
<b class="nc">&nbsp;                result.add(clone().addStep(MovePath.MoveStepType.LATERAL_LEFT_BACKWARDS));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (forward &amp;&amp; (!backward || ((last == null) || (last.getType() != MovePath.MoveStepType.BACKWARDS)))) {</b>
<b class="nc">&nbsp;            result.add(clone().addStep(MovePath.MoveStepType.FORWARDS));</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((last == null) || (last.getType() != MovePath.MoveStepType.TURN_LEFT)) {</b>
<b class="nc">&nbsp;            result.add(clone().addStep(MovePath.MoveStepType.TURN_RIGHT));</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((last == null) || (last.getType() != MovePath.MoveStepType.TURN_RIGHT)) {</b>
<b class="nc">&nbsp;            result.add(clone().addStep(MovePath.MoveStepType.TURN_LEFT));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (backward &amp;&amp; (!forward || ((last == null) || (last.getType() != MovePath.MoveStepType.FORWARDS)))) {</b>
<b class="nc">&nbsp;            result.add(clone().addStep(MovePath.MoveStepType.BACKWARDS));</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clones this path, will contain a new clone of the steps so that the clone
&nbsp;     * is independent from the original.
&nbsp;     *
&nbsp;     * @return the cloned MovePath
&nbsp;     */
&nbsp;    @Override
&nbsp;    public MovePath clone() {
<b class="nc">&nbsp;        final MovePath copy = new MovePath(getGame(), getEntity());</b>
<b class="nc">&nbsp;        copyFields(copy);</b>
<b class="nc">&nbsp;        return copy;</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected void copyFields(MovePath copy) {
<b class="nc">&nbsp;        copy.steps = new Vector&lt;MoveStep&gt;(steps);</b>
<b class="nc">&nbsp;        copy.careful = careful;</b>
<b class="nc">&nbsp;        copy.containedStepTypes = new HashSet&lt;&gt;(containedStepTypes);</b>
<b class="nc">&nbsp;        copy.fliesOverEnemy = fliesOverEnemy;</b>
<b class="nc">&nbsp;        copy.cachedEntityState = cachedEntityState; // intentional pointer copy</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Rotate from the current facing to the destination facing.
&nbsp;     */
&nbsp;    public void rotatePathfinder(final int destFacing, final boolean isManeuver) {
<b class="nc">&nbsp;        while (getFinalFacing() != destFacing) {</b>
<b class="nc">&nbsp;            final MoveStepType stepType = getDirection(getFinalFacing(), destFacing);</b>
<b class="nc">&nbsp;            addStep(stepType, isManeuver, isManeuver);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if a jump using mechanical jump boosters would cause falling
&nbsp;     * damage.  Mechanical jump boosters are only designed to handle the stress
&nbsp;     * of falls from a height equal to their jumpMP; if a jump has a fall that
&nbsp;     * is further than the jumpMP of the unit, fall damage applies.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean shouldMechanicalJumpCauseFallDamage() {
<b class="nc">&nbsp;        if (isJumping() &amp;&amp; (getEntity().getJumpType() == Mech.JUMP_BOOSTER) &amp;&amp;</b>
<b class="nc">&nbsp;            (getJumpMaxElevationChange() &gt; getEntity().getJumpMP())) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the highest elevation along a jump path.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Coords getJumpPathHighestPoint() {
<b class="nc">&nbsp;        Coords highestCoords = null;</b>
<b class="nc">&nbsp;        int highestElevation = 0;</b>
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            if (getGame().getBoard().getHex(step.getPosition()).getLevel() &gt; highestElevation) {</b>
<b class="nc">&nbsp;                highestElevation = step.getElevation();</b>
<b class="nc">&nbsp;                highestCoords = step.getPosition();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return highestCoords;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the distance between the highest elevation in the jump path and
&nbsp;     * the elevation at the landing point.  This gives the largest distance the
&nbsp;     * unit has fallen during the jump.
&nbsp;     */
&nbsp;    public int getJumpMaxElevationChange() {
<b class="nc">&nbsp;        return getMaxElevation() -</b>
<b class="nc">&nbsp;               getGame().getBoard().getHex(getFinalCoords()).getLevel();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return TRUE if there are any buildings in a dropship&#39;s landing zone.
&nbsp;     */
&nbsp;    public boolean willCrushBuildings() {
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            if (!step.getCrushedBuildingLocs().isEmpty()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Airborne WiGEs that move less than five hexes (four for glider protomech) in a movement phase must
&nbsp;     * land unless it has taken off in the same phase or it is a LAM or glider ProtoMech that is using hover
&nbsp;     * movement.
&nbsp;     * 
&nbsp;     * @param includeMovePathHexes  Whether to include the hexes plotted in this MovePath in the total distance
&nbsp;     *                              moved. This should be true when plotting movement in the client and
&nbsp;     *                              false when the server checks for automatic landing at the end of movement. 
&nbsp;     * @return whether the unit is an airborne WiGE that must land at the end of movement.
&nbsp;     */
&nbsp;    public boolean automaticWiGELanding(boolean includeMovePathHexes) {
<b class="nc">&nbsp;        if (getEntity().getMovementMode() != EntityMovementMode.WIGE</b>
<b class="nc">&nbsp;                || getEntity().isAirborne()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // A LAM converting from AirMech to Mech mode automatically lands at the end of movement.
<b class="nc">&nbsp;        if ((getEntity() instanceof LandAirMech)</b>
<b class="nc">&nbsp;                &amp;&amp; (((LandAirMech)getEntity()).getConversionModeFor(getFinalConversionMode()) == LandAirMech.CONV_MODE_MECH)){</b>
<b class="nc">&nbsp;            if (getLastStep() != null) {</b>
<b class="nc">&nbsp;                return getLastStep().getClearance() &gt; 0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return getEntity().isAirborneVTOLorWIGE();</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // If movement has been interrupted (such as by a sideslip) and remaining movement points have
&nbsp;        // been spent, this MovePath only contains the hexes moved after the interruption. The hexes already
&nbsp;        // moved this turn are in delta_distance. WHen the server checks at the end of movement, delta_distance
&nbsp;        // already includes the hexes in this MovePath.
<b class="nc">&nbsp;        int moved = getEntity().delta_distance;</b>
<b class="nc">&nbsp;        if (includeMovePathHexes) {</b>
<b class="nc">&nbsp;            moved += getHexesMoved();</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((moved &gt;= 5)</b>
<b class="nc">&nbsp;                || (getEntity().hasETypeFlag(Entity.ETYPE_PROTOMECH)</b>
&nbsp;                        &amp;&amp; moved == 4)) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getEntity().wigeLiftoffHover() || steps.stream().map(s -&gt; s.getType())</b>
<b class="nc">&nbsp;                .anyMatch(st -&gt; st == MoveStepType.UP</b>
&nbsp;                        || st == MoveStepType.HOVER)) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getLastStep() != null) {</b>
<b class="nc">&nbsp;            return getLastStep().getClearance() &gt; 0;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return getEntity().isAirborneVTOLorWIGE();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    protected static class MovePathComparator implements Comparator&lt;MovePath&gt; {
&nbsp;        private final Coords destination;
&nbsp;        boolean backward;
&nbsp;
<b class="nc">&nbsp;        public MovePathComparator(final Coords destination, final boolean backward) {</b>
<b class="nc">&nbsp;            this.destination = destination;</b>
<b class="nc">&nbsp;            this.backward = backward;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int compare(final MovePath first, final MovePath second) {
<b class="nc">&nbsp;            final int firstDist = first.getMpUsed() + first.getFinalCoords().distance(destination)</b>
<b class="nc">&nbsp;                    + getFacingDiff(first);</b>
<b class="nc">&nbsp;            final int secondDist = second.getMpUsed() + second.getFinalCoords().distance(destination)</b>
<b class="nc">&nbsp;                    + getFacingDiff(second);</b>
<b class="nc">&nbsp;            return firstDist - secondDist;</b>
&nbsp;        }
&nbsp;
&nbsp;        private int getFacingDiff(final MovePath first) {
<b class="nc">&nbsp;            if (first.isJumping()) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (first.getFinalCoords().equals(destination)) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            int firstFacing = Math.abs(((first.getFinalCoords().direction(destination) + (backward ? 3 : 0)) % 6)</b>
<b class="nc">&nbsp;                    - first.getFinalFacing());</b>
<b class="nc">&nbsp;            if (firstFacing &gt; 3) {</b>
<b class="nc">&nbsp;                firstFacing = 6 - firstFacing;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (first.canShift()) {</b>
<b class="nc">&nbsp;                firstFacing = Math.max(0, firstFacing - 1);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((first.getFinalCoords().degree(destination) % 60) != 0) {</b>
<b class="nc">&nbsp;                firstFacing++;</b>
&nbsp;            }
<b class="nc">&nbsp;            return firstFacing;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Get the position in the step immediately prior to the final position
&nbsp;     */
&nbsp;    public Coords getSecondFinalPosition(Coords startPos) {
&nbsp;
<b class="nc">&nbsp;        Coords priorPos = startPos;</b>
<b class="nc">&nbsp;        Coords finalPos = getFinalCoords();</b>
&nbsp;
&nbsp;        // if we moved one or fewer hexes, then just return starting position
<b class="nc">&nbsp;        if (getHexesMoved() &lt; 2) {</b>
<b class="nc">&nbsp;            return priorPos;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (final Enumeration&lt;MoveStep&gt; i = getSteps(); i.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            final MoveStep step = i.nextElement();</b>
<b class="nc">&nbsp;            if (!step.getPosition().equals(finalPos)) {</b>
<b class="nc">&nbsp;                priorPos = step.getPosition();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return priorPos;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCareful() {
<b class="fc">&nbsp;        return careful;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCareful(boolean b) {
<b class="nc">&nbsp;        careful = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int countMp(boolean jumping) {
<b class="nc">&nbsp;        int mp = 0;</b>
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            if (jumping &amp;&amp; (step.getType() != MoveStepType.TURN_LEFT) &amp;&amp;</b>
<b class="nc">&nbsp;                    (step.getType() != MoveStepType.TURN_RIGHT)) {</b>
<b class="nc">&nbsp;                mp += step.getMp();</b>
<b class="nc">&nbsp;            } else if (!jumping) {</b>
<b class="nc">&nbsp;                mp += step.getMp();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addSteps(Vector&lt;MoveStep&gt; path, boolean compile) {
<b class="nc">&nbsp;        for (MoveStep step : path) {</b>
<b class="nc">&nbsp;            addStep(step, compile);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void replaceSteps(Vector&lt;MoveStep&gt; path) {
<b class="nc">&nbsp;        steps.clear();</b>
<b class="nc">&nbsp;        addSteps(path, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public boolean isEndStep(MoveStep step) {
<b class="nc">&nbsp;        if (step == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return step.isEndPos(this);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method to determine whether this path is happening on a ground map with an atmosphere
&nbsp;     */
&nbsp;    public boolean isOnAtmosphericGroundMap() {
<b class="nc">&nbsp;    	return getEntity().isOnAtmosphericGroundMap(); </b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Searches the movement path for the first step that has the given position and sets it as
&nbsp;     * a VTOL bombing step. If found, any previous bombing step is cleared. If the coordinates are not
&nbsp;     * part of the path nothing is changed.
&nbsp;     * 
&nbsp;     * @param pos The &lt;code&gt;Coords&lt;/code&gt; of the hex to be bombed.
&nbsp;     * @return Whether the position was found in the movement path
&nbsp;     */
&nbsp;    public boolean setVTOLBombStep(Coords pos) {
<b class="nc">&nbsp;        boolean foundPos = false;</b>
<b class="nc">&nbsp;        MoveStep prevBombing = null;</b>
<b class="nc">&nbsp;        for (MoveStep step : steps) {</b>
<b class="nc">&nbsp;            if (step.getPosition().equals(pos)) {</b>
<b class="nc">&nbsp;                if (step.isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    step.setVTOLBombing(true);</b>
<b class="nc">&nbsp;                    foundPos = true;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (step.isVTOLBombingStep()) {</b>
<b class="nc">&nbsp;                prevBombing = step;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (foundPos &amp;&amp; prevBombing != null) {</b>
<b class="nc">&nbsp;            prevBombing.setVTOLBombing(false);</b>
&nbsp;        }
<b class="nc">&nbsp;        return foundPos;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Searches the path for the first &lt;code&gt;MoveStep&lt;/code&gt; that matches the given position and sets it
&nbsp;     * as a strafing step. In cases where there are multiple steps with the same coordinates, we want the
&nbsp;     * first one because it is the one that enters the hex. In the rare case where the path crosses
&nbsp;     * itself, select the one closest to the end of the path.
&nbsp;     * 
&nbsp;     * FIXME: this does not deal with paths that cross themselves
&nbsp;     * 
&nbsp;     * @param pos The &lt;code&gt;Coords&lt;/code&gt; of the hex to be strafed
&nbsp;     * @return Whether the position was found in the path
&nbsp;     */
&nbsp;    public boolean setStrafingStep(Coords pos) {
<b class="nc">&nbsp;        MoveStep found = null;</b>
<b class="nc">&nbsp;        for (int i = steps.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            if (steps.get(i).getPosition().equals(pos)) {</b>
<b class="nc">&nbsp;                found = steps.get(i);</b>
<b class="nc">&nbsp;            } else if (found != null) {</b>
<b class="nc">&nbsp;                found.setStrafing(true);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (found != null) {</b>
<b class="nc">&nbsp;            found.setStrafing(true);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * @return A list of entity ids for all units that have previously be plotted to be dropped/launched.
&nbsp;     */
&nbsp;    public Set&lt;Integer&gt; getDroppedUnits() {
<b class="nc">&nbsp;        Set&lt;Integer&gt; dropped = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (MoveStep s : steps) {</b>
<b class="nc">&nbsp;            for (Vector&lt;Integer&gt; ids : s.getLaunched().values()) {</b>
<b class="nc">&nbsp;                dropped.addAll(ids);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return dropped;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience function encapsulating logic for whether, if we continue forward 
&nbsp;     * along the current path in the current direction, we will run off the board
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean nextForwardStepOffBoard() {
<b class="nc">&nbsp;        return !game.getBoard().contains(getFinalCoords().translated(getFinalFacing()));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Debugging method that calculates a destruction-aware move path to the destination coordinates
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public MovePath calculateDestructionAwarePath(Coords dest) {
&nbsp;        // code that&#39;s useful to test the destruction-aware pathfinder
<b class="nc">&nbsp;        DestructionAwareDestinationPathfinder dpf = new DestructionAwareDestinationPathfinder();</b>
&nbsp;        // the destruction aware pathfinder takes either a CardinalEdge or an explicit set of coordinates
<b class="nc">&nbsp;        Set&lt;Coords&gt; destinationSet = new HashSet&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        destinationSet.add(dest);</b>
&nbsp;        
&nbsp;        // debugging code that can be used to find a path to a specific edge
<b class="nc">&nbsp;        Princess princess = new Princess(&quot;test&quot;, &quot;test&quot;, 2020, LogLevel.OFF);</b>
&nbsp;        //Set&lt;Coords&gt; destinationSet = princess.getClusterTracker().getDestinationCoords(entity, CardinalEdge.WEST, true);
&nbsp;        
<b class="nc">&nbsp;        long marker1 = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        MovePath finPath = dpf.findPathToCoords(entity, destinationSet, false, princess.getClusterTracker());</b>
<b class="nc">&nbsp;        long marker2 = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        long marker3 = marker2 - marker1;</b>
&nbsp;        
<b class="nc">&nbsp;        return finPath;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
