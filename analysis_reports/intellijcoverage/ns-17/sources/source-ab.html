


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TripodMech</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: TripodMech (megamek.common)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TripodMech</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/776)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * MegaMek -
&nbsp; *  Copyright (C) 2013
&nbsp; *    Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.PrintWriter;
&nbsp;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;
&nbsp;public class TripodMech extends Mech {
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 4166375446709772785L;
&nbsp;
<b class="nc">&nbsp;    private static final String[] LOCATION_NAMES = {&quot;Head&quot;, &quot;Center Torso&quot;,</b>
&nbsp;                                                    &quot;Right Torso&quot;, &quot;Left Torso&quot;, &quot;Right Arm&quot;, &quot;Left Arm&quot;, &quot;Right Leg&quot;,
&nbsp;                                                    &quot;Left Leg&quot;, &quot;Center Leg&quot;};
&nbsp;
<b class="nc">&nbsp;    private static final String[] LOCATION_ABBRS = {&quot;HD&quot;, &quot;CT&quot;, &quot;RT&quot;, &quot;LT&quot;,</b>
&nbsp;                                                    &quot;RA&quot;, &quot;LA&quot;, &quot;RL&quot;, &quot;LL&quot;, &quot;CL&quot;};
&nbsp;
<b class="nc">&nbsp;    private static final int[] NUM_OF_SLOTS = {6, 12, 12, 12, 12, 12, 6, 6, 6};</b>
&nbsp;
&nbsp;    public TripodMech(String inGyroType, String inCockpitType) {
<b class="nc">&nbsp;        this(getGyroTypeForString(inGyroType),</b>
<b class="nc">&nbsp;             getCockpitTypeForString(inCockpitType));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public TripodMech() {
<b class="nc">&nbsp;        this(Mech.GYRO_STANDARD, Mech.COCKPIT_STANDARD);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public TripodMech(int inGyroType, int inCockpitType) {
<b class="nc">&nbsp;        super(inGyroType, inCockpitType);</b>
&nbsp;
<b class="nc">&nbsp;        movementMode = EntityMovementMode.TRIPOD;</b>
<b class="nc">&nbsp;        originalMovementMode = EntityMovementMode.TRIPOD;</b>
&nbsp;
<b class="nc">&nbsp;        setCritical(LOC_RARM, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_SHOULDER));
<b class="nc">&nbsp;        setCritical(LOC_RARM, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_UPPER_ARM));
<b class="nc">&nbsp;        setCritical(LOC_RARM, 2, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_LOWER_ARM));
<b class="nc">&nbsp;        setCritical(LOC_RARM, 3, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_HAND));
&nbsp;
<b class="nc">&nbsp;        setCritical(LOC_LARM, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_SHOULDER));
<b class="nc">&nbsp;        setCritical(LOC_LARM, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_UPPER_ARM));
<b class="nc">&nbsp;        setCritical(LOC_LARM, 2, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_LOWER_ARM));
<b class="nc">&nbsp;        setCritical(LOC_LARM, 3, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_HAND));
&nbsp;
<b class="nc">&nbsp;        setCritical(LOC_CLEG, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_HIP));
<b class="nc">&nbsp;        setCritical(LOC_CLEG, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_UPPER_LEG));
<b class="nc">&nbsp;        setCritical(LOC_CLEG, 2, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_LOWER_LEG));
<b class="nc">&nbsp;        setCritical(LOC_CLEG, 3, new CriticalSlot(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  ACTUATOR_FOOT));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the location in question is a leg
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean locationIsLeg(int loc) {
<b class="nc">&nbsp;        return (loc == LOC_LLEG) || (loc == LOC_RLEG) || (loc == LOC_CLEG);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getEntityType() {
<b class="nc">&nbsp;        return Entity.ETYPE_MECH | Entity.ETYPE_TRIPOD_MECH;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity can flip its arms
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean canFlipArms() {
<b class="nc">&nbsp;        boolean canFlip = true;</b>
&nbsp;
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_HAND, Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            canFlip = false;</b>
<b class="nc">&nbsp;        } else if (hasSystem(Mech.ACTUATOR_LOWER_ARM, Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            canFlip = false;</b>
<b class="nc">&nbsp;        } else if (hasSystem(Mech.ACTUATOR_HAND, Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;            canFlip = false;</b>
<b class="nc">&nbsp;        } else if (hasSystem(Mech.ACTUATOR_LOWER_ARM, Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;            canFlip = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_HYPER_ACTUATOR)) {</b>
<b class="nc">&nbsp;            canFlip = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isProne()) {</b>
<b class="nc">&nbsp;            canFlip = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return canFlip;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getWalkMP(boolean gravity, boolean ignoreheat,
&nbsp;                         boolean ignoremodulararmor) {
<b class="nc">&nbsp;        int wmp = getOriginalWalkMP();</b>
<b class="nc">&nbsp;        int legsDestroyed = 0;</b>
<b class="nc">&nbsp;        int hipHits = 0;</b>
<b class="nc">&nbsp;        int actuatorHits = 0;</b>
&nbsp;
&nbsp;        //A Mech using tracks has its movement reduced by 1/3 per leg or track destroyed, based
&nbsp;        //on analogy with biped and quad mechs.
<b class="nc">&nbsp;        if (getMovementMode() == EntityMovementMode.TRACKED) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                if (m.getType().hasFlag(MiscType.F_TRACKS)) {</b>
<b class="nc">&nbsp;                    if (m.isHit() || isLocationBad(m.getLocation())) {</b>
<b class="nc">&nbsp;                        legsDestroyed++;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            wmp = (wmp * (3 - legsDestroyed)) / 3; </b>
&nbsp;        } else {
<b class="nc">&nbsp;            for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;                if (locationIsLeg(i)) {</b>
<b class="nc">&nbsp;                    if (!isLocationBad(i)) {</b>
<b class="nc">&nbsp;                        if (legHasHipCrit(i)) {</b>
<b class="nc">&nbsp;                            hipHits++;</b>
<b class="nc">&nbsp;                            if ((game == null)</b>
<b class="nc">&nbsp;                                || !game.getOptions().booleanOption(</b>
&nbsp;                                    OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        actuatorHits += countLegActuatorCrits(i);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        legsDestroyed++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // leg damage effects
<b class="nc">&nbsp;            if (legsDestroyed &gt; 0) {</b>
<b class="nc">&nbsp;                wmp = (legsDestroyed == 1) ? 1 : 0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (hipHits &gt; 0) {</b>
<b class="nc">&nbsp;                    if ((game != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {</b>
<b class="nc">&nbsp;                        wmp = (hipHits &gt;= 1) ? wmp - (2 * hipHits) : 0;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        wmp = (hipHits == 1) ? (int) Math.ceil(wmp / 2.0) : 0;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                wmp -= actuatorHits;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasShield()) {</b>
<b class="nc">&nbsp;            wmp -= getNumberOfShields(MiscType.S_SHIELD_LARGE);</b>
<b class="nc">&nbsp;            wmp -= getNumberOfShields(MiscType.S_SHIELD_MEDIUM);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!ignoremodulararmor &amp;&amp; hasModularArmor()) {</b>
<b class="nc">&nbsp;            wmp--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!ignoreheat) {</b>
&nbsp;            // factor in heat
<b class="nc">&nbsp;            if ((game != null)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HEAT)) {</b>
<b class="nc">&nbsp;                if (heat &lt; 30) {</b>
<b class="nc">&nbsp;                    wmp -= (heat / 5);</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 49) {</b>
<b class="nc">&nbsp;                    wmp -= 9;</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 43) {</b>
<b class="nc">&nbsp;                    wmp -= 8;</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 37) {</b>
<b class="nc">&nbsp;                    wmp -= 7;</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 31) {</b>
<b class="nc">&nbsp;                    wmp -= 6;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    wmp -= 5;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                wmp -= (heat / 5);</b>
&nbsp;            }
&nbsp;            // TSM negates some heat
<b class="nc">&nbsp;            if ((heat &gt;= 9) &amp;&amp; hasTSM() &amp;&amp; legsDestroyed == 0 &amp;&amp; movementMode != EntityMovementMode.TRACKED) {</b>
<b class="nc">&nbsp;                wmp += 2;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        wmp = Math.max(wmp - getCargoMpReduction(this), 0);</b>
<b class="nc">&nbsp;        if (null != game) {</b>
<b class="nc">&nbsp;            int weatherMod = game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                 .getMovementMods(this);</b>
<b class="nc">&nbsp;            if (weatherMod != 0) {</b>
<b class="nc">&nbsp;                wmp = Math.max(wmp + weatherMod, 0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // gravity
<b class="nc">&nbsp;        if (gravity) {</b>
<b class="nc">&nbsp;            wmp = applyGravityEffectsOnMP(wmp);</b>
&nbsp;        }
&nbsp;
&nbsp;        // For sanity sake...
<b class="nc">&nbsp;        wmp = Math.max(0, wmp);</b>
&nbsp;
<b class="nc">&nbsp;        return wmp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this mech&#39;s running/flank mp modified for leg loss &amp; stuff.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getRunMP(boolean gravity, boolean ignoreheat,
&nbsp;                        boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (countBadLegs() == 0) {</b>
<b class="nc">&nbsp;            return super.getRunMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getWalkMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns run MP without considering MASC modified for leg loss &amp; stuff.
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public int getRunMPwithoutMASC(boolean gravity, boolean ignoreheat,
&nbsp;                                   boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (countBadLegs() == 0) {</b>
<b class="nc">&nbsp;            return super.getRunMPwithoutMASC(gravity, ignoreheat,</b>
&nbsp;                                             ignoremodulararmor);
&nbsp;        }
<b class="nc">&nbsp;        return getWalkMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the internal structure for the mech.
&nbsp;     *
&nbsp;     * @param head head
&nbsp;     * @param ct   center torso
&nbsp;     * @param t    right/left torso
&nbsp;     * @param arm  right/left arm
&nbsp;     * @param leg  right/left leg
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setInternal(int head, int ct, int t, int arm, int leg) {
<b class="nc">&nbsp;        initializeInternal(head, LOC_HEAD);</b>
<b class="nc">&nbsp;        initializeInternal(ct, LOC_CT);</b>
<b class="nc">&nbsp;        initializeInternal(t, LOC_RT);</b>
<b class="nc">&nbsp;        initializeInternal(t, LOC_LT);</b>
<b class="nc">&nbsp;        initializeInternal(arm, LOC_RARM);</b>
<b class="nc">&nbsp;        initializeInternal(arm, LOC_LARM);</b>
<b class="nc">&nbsp;        initializeInternal(leg, LOC_RLEG);</b>
<b class="nc">&nbsp;        initializeInternal(leg, LOC_LLEG);</b>
<b class="nc">&nbsp;        initializeInternal(leg, LOC_CLEG);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add in any piloting skill mods
&nbsp;     */
&nbsp;    @Override
&nbsp;    public PilotingRollData addEntityBonuses(PilotingRollData roll) {
<b class="nc">&nbsp;        if (getCrew().hasDedicatedPilot()) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;dedicated pilot&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(2, &quot;pilot incapacitated&quot;);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        int[] locsToCheck = new int[3];</b>
&nbsp;
<b class="nc">&nbsp;        locsToCheck[0] = Mech.LOC_RLEG;</b>
<b class="nc">&nbsp;        locsToCheck[1] = Mech.LOC_LLEG;</b>
<b class="nc">&nbsp;        locsToCheck[2] = Mech.LOC_CLEG;</b>
&nbsp;
<b class="nc">&nbsp;        if (hasFunctionalLegAES()) {</b>
<b class="nc">&nbsp;            roll.addModifier(-2, &quot;AES bonus&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (countBadLegs() == 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;tripod bonus&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; locsToCheck.length; i++) {</b>
<b class="nc">&nbsp;            int loc = locsToCheck[i];</b>
&nbsp;
<b class="nc">&nbsp;            if (isLocationBad(loc)) {</b>
<b class="nc">&nbsp;                roll.addModifier(5, getLocationName(loc) + &quot; destroyed&quot;);</b>
&nbsp;            } else {
&nbsp;                // check for damaged hip actuators
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                    Mech.ACTUATOR_HIP, loc) &gt; 0) {
<b class="nc">&nbsp;                    roll.addModifier(2, getLocationName(loc)</b>
&nbsp;                                        + &quot; Hip Actuator destroyed&quot;);
<b class="nc">&nbsp;                    if (!game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // upper leg actuators?
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                    Mech.ACTUATOR_UPPER_LEG, loc) &gt; 0) {
<b class="nc">&nbsp;                    roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                        + &quot; Upper Leg Actuator destroyed&quot;);
&nbsp;                }
&nbsp;                // lower leg actuators?
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                    Mech.ACTUATOR_LOWER_LEG, loc) &gt; 0) {
<b class="nc">&nbsp;                    roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                        + &quot; Lower Leg Actuator destroyed&quot;);
&nbsp;                }
&nbsp;                // foot actuators?
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                    Mech.ACTUATOR_FOOT, loc) &gt; 0) {
<b class="nc">&nbsp;                    roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                        + &quot; Foot Actuator destroyed&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return super.addEntityBonuses(roll);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of slot counts for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected int[] getNoOfSlots() {
<b class="nc">&nbsp;        return NUM_OF_SLOTS;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of names for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String[] getLocationNames() {
<b class="nc">&nbsp;        return LOCATION_NAMES;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of abbreviations for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String[] getLocationAbbrs() {
<b class="nc">&nbsp;        return LOCATION_ABBRS;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected double getArmActuatorCost() {
<b class="nc">&nbsp;        double cost = 0;</b>
<b class="nc">&nbsp;        int numOfUpperArmActuators = 0;</b>
<b class="nc">&nbsp;        int numOfLowerArmActuators = 0;</b>
<b class="nc">&nbsp;        int numOfHands = 0;</b>
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_HAND, Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            numOfHands++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_LOWER_ARM, Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            numOfLowerArmActuators++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_UPPER_ARM, Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            numOfUpperArmActuators++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_HAND, Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;            numOfHands++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_LOWER_ARM, Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;            numOfLowerArmActuators++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasSystem(Mech.ACTUATOR_UPPER_ARM, Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;            numOfUpperArmActuators++;</b>
&nbsp;        }
<b class="nc">&nbsp;        cost += numOfUpperArmActuators * weight * 100;</b>
<b class="nc">&nbsp;        cost += numOfLowerArmActuators * weight * 50;</b>
<b class="nc">&nbsp;        cost += numOfHands * weight * 80;</b>
<b class="nc">&nbsp;        return cost;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected double getLegActuatorCost() {
<b class="nc">&nbsp;        return (weight * 150 * 2) + (weight * 80 * 2) + (weight * 120 * 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see if a Biped mech has a claw in one of its arms
&nbsp;     *
&nbsp;     * @param location (LOC_RARM or LOC_LARM)
&nbsp;     * @return True/False
&nbsp;     */
&nbsp;    public boolean hasClaw(int location) {
&nbsp;        // only arms have claws.
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; this.getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(location, slot);</b>
&nbsp;
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; type.hasFlag(MiscType.F_HAND_WEAPON)</b>
<b class="nc">&nbsp;                &amp;&amp; type.hasSubType(MiscType.S_CLAW)) {</b>
<b class="nc">&nbsp;                return !(m.isDestroyed() || m.isMissing() || m.isBreached());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if this bipmech has any vibro blades on them.
&nbsp;     *
&nbsp;     * @return boolean &lt;code&gt;true&lt;/code&gt; if the mech has vibroblades
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if not.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasVibroblades() {
<b class="nc">&nbsp;        int count = 0;</b>
&nbsp;
<b class="nc">&nbsp;        if (hasVibrobladesInLocation(Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;            count++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasVibrobladesInLocation(Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            count++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return count &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if this bipedmech has a vibroblade in this location.
&nbsp;     *
&nbsp;     * @param location
&nbsp;     * @return boolean &lt;code&gt;true&lt;/code&gt; if the mech has vibroblades
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if not.
&nbsp;     */
&nbsp;    public boolean hasVibrobladesInLocation(int location) {
&nbsp;
&nbsp;        // Only arms have VibroBlades.
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; this.getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(location, slot);</b>
&nbsp;
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
&nbsp;            // sometimes this mounted is null in MML - causing problems so check
<b class="nc">&nbsp;            if (null == m) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; ((MiscType) type).isVibroblade()) {</b>
<b class="nc">&nbsp;                return !(m.isDestroyed() || m.isMissing() || m.isBreached());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the entity have a retracted blade in the given location
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasRetractedBlade(int loc) {
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getLocation() == loc) &amp;&amp; !m.isDestroyed() &amp;&amp; !m.isBreached()</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_CLUB)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasSubType(MiscType.S_RETRACTABLE_BLADE)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.curMode().equals(&quot;extended&quot;)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for Active Vibroblades in &lt;code&gt;location&lt;/code&gt; and returns the
&nbsp;     * amount of heat genereated if active.
&nbsp;     *
&nbsp;     * @param location
&nbsp;     * @return &lt;code&gt;int&lt;/code&gt; amount of heat genereated by an active
&nbsp;     * vibroblade.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getActiveVibrobladeHeat(int location) {
<b class="nc">&nbsp;        return getActiveVibrobladeHeat(location, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getActiveVibrobladeHeat(int location, boolean ignoreMode) {
&nbsp;        // Only arms have VibroBlades.
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; this.getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(location, slot);</b>
&nbsp;
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
&nbsp;            // sometimes this mounted is null in MML - causing problems so check
<b class="nc">&nbsp;            if (null == m) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; ((MiscType) type).isVibroblade()</b>
<b class="nc">&nbsp;                &amp;&amp; (m.curMode().equals(&quot;Active&quot;) || ignoreMode)</b>
<b class="nc">&nbsp;                &amp;&amp; !(m.isDestroyed() || m.isMissing() || m.isBreached())) {</b>
<b class="nc">&nbsp;                MiscType blade = (MiscType) type;</b>
<b class="nc">&nbsp;                if (blade.hasSubType(MiscType.S_VIBRO_LARGE)) {</b>
<b class="nc">&nbsp;                    return 7;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (blade.hasSubType(MiscType.S_VIBRO_MEDIUM)) {</b>
<b class="nc">&nbsp;                    return 5;</b>
&nbsp;                }
&nbsp;                // else
<b class="nc">&nbsp;                return 3;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 0;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have any shields. a mech can have up to 2 shields.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if unit has a shield crit.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasShield() {
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if (((m.getLocation() == Mech.LOC_LARM) || (m.getLocation() == Mech.LOC_RARM))</b>
&nbsp;                    &amp;&amp; (type instanceof MiscType)
<b class="nc">&nbsp;                    &amp;&amp; ((MiscType) type).isShield()</b>
<b class="nc">&nbsp;                    &amp;&amp; !m.isInoperable()</b>
<b class="nc">&nbsp;                    &amp;&amp; (this.getInternal(m.getLocation()) &gt; 0)) {</b>
<b class="nc">&nbsp;                for (int slot = 0; slot &lt; this.getNumberOfCriticals(m</b>
<b class="nc">&nbsp;                        .getLocation()); slot++) {</b>
<b class="nc">&nbsp;                    CriticalSlot cs = getCritical(m.getLocation(), slot);</b>
<b class="nc">&nbsp;                    if ((cs != null)</b>
<b class="nc">&nbsp;                            &amp;&amp; (cs.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                            &amp;&amp; cs.getMount().equals(m) &amp;&amp; !cs.isDestroyed()</b>
<b class="nc">&nbsp;                            &amp;&amp; !cs.isMissing()) {</b>
&nbsp;                        // when all crits of a shield are destroyed, it
&nbsp;                        // no longer hinders movement and stuff
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see how many shields of a certain size a mek has. you can have
&nbsp;     * up to shields per mek. However they can be of different size and each
&nbsp;     * size has its own draw backs. So check each size and add modifers based on
&nbsp;     * the number shields of that size.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getNumberOfShields(long size) {
&nbsp;
<b class="nc">&nbsp;        int raShield = 0;</b>
<b class="nc">&nbsp;        int laShield = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_CLUB)</b>
<b class="nc">&nbsp;                &amp;&amp; (type.hasSubType(size))) {</b>
&nbsp;                // ok so we have a shield of certain size. no which arm is it.
<b class="nc">&nbsp;                if (m.getLocation() == Mech.LOC_RARM) {</b>
<b class="nc">&nbsp;                    raShield = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (m.getLocation() == Mech.LOC_LARM) {</b>
<b class="nc">&nbsp;                    laShield = 1;</b>
&nbsp;                }
&nbsp;                // break now.
<b class="nc">&nbsp;                if ((raShield &gt; 0) &amp;&amp; (laShield &gt; 0)) {</b>
<b class="nc">&nbsp;                    return 2;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return raShield + laShield;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have an active shield This should only be called after
&nbsp;     * hasShield has been called.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasActiveShield(int location, boolean rear) {
&nbsp;
<b class="nc">&nbsp;        switch (location) {</b>
&nbsp;            case Mech.LOC_CT:
&nbsp;            case Mech.LOC_HEAD:
&nbsp;                // no rear head location so must be rear CT which is not
&nbsp;                // proected by
&nbsp;                // any shield
<b class="nc">&nbsp;                if (rear) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hasActiveShield(Mech.LOC_LARM)</b>
<b class="nc">&nbsp;                    || hasActiveShield(Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                // else
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case Mech.LOC_LARM:
&nbsp;            case Mech.LOC_LT:
&nbsp;            case Mech.LOC_LLEG:
<b class="nc">&nbsp;                return hasActiveShield(Mech.LOC_LARM);</b>
&nbsp;            default:
<b class="nc">&nbsp;                return hasActiveShield(Mech.LOC_RARM);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have an active shield This should only be called by
&nbsp;     * hasActiveShield(location,rear)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasActiveShield(int location) {
&nbsp;
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isShutDown()</b>
<b class="nc">&nbsp;            || (getCrew().isKoThisRound() || getCrew().isUnconscious())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; this.getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(location, slot);</b>
&nbsp;
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cs.isDamaged()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; ((MiscType) type).isShield()</b>
<b class="nc">&nbsp;                &amp;&amp; m.curMode().equals(MiscType.S_ACTIVE_SHIELD)) {</b>
<b class="nc">&nbsp;                return m.getCurrentDamageCapacity(this, m.getLocation()) &gt; 0;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a passive shield This should only be called after
&nbsp;     * hasShield has been called.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasPassiveShield(int location, boolean rear) {
&nbsp;
<b class="nc">&nbsp;        switch (location) {</b>
&nbsp;            // CT Head and legs are not protected by Passive shields.
&nbsp;            case Mech.LOC_CT:
&nbsp;            case Mech.LOC_HEAD:
&nbsp;            case Mech.LOC_LLEG:
&nbsp;            case Mech.LOC_RLEG:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case Mech.LOC_LARM:
&nbsp;            case Mech.LOC_LT:
<b class="nc">&nbsp;                if (rear) {</b>
&nbsp;                    // that
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                return hasPassiveShield(Mech.LOC_LARM);</b>
&nbsp;            // RA RT
&nbsp;            default:
<b class="nc">&nbsp;                if (rear) {</b>
&nbsp;                    // that
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                return hasPassiveShield(Mech.LOC_RARM);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a passive shield This should only be called by
&nbsp;     * hasPassiveShield(location,rear)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasPassiveShield(int location) {
&nbsp;
<b class="nc">&nbsp;        if (isShutDown()</b>
<b class="nc">&nbsp;            || (getCrew().isKoThisRound() || getCrew().isUnconscious())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; this.getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(location, slot);</b>
&nbsp;
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cs.isDamaged()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; ((MiscType) type).isShield()</b>
<b class="nc">&nbsp;                &amp;&amp; m.curMode().equals(MiscType.S_PASSIVE_SHIELD)) {</b>
<b class="nc">&nbsp;                return m.getCurrentDamageCapacity(this, m.getLocation()) &gt; 0;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have an shield in no defense mode
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasNoDefenseShield(int location) {
&nbsp;
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; this.getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(location, slot);</b>
&nbsp;
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cs.isDamaged()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; ((MiscType) type).isShield()</b>
<b class="nc">&nbsp;                &amp;&amp; (m.curMode().equals(MiscType.S_NO_SHIELD)</b>
<b class="nc">&nbsp;                    || isShutDown() || // if</b>
&nbsp;                    // he
&nbsp;                    // has
&nbsp;                    // a
&nbsp;                    // shield
&nbsp;                    // and
&nbsp;                    // the mek is SD or pilot
&nbsp;                    // KOed then it goes to no
&nbsp;                    // defense mode
<b class="nc">&nbsp;                    getCrew().isKoThisRound() || getCrew()</b>
<b class="nc">&nbsp;                    .isUnconscious())) {</b>
<b class="nc">&nbsp;                return m.getCurrentDamageCapacity(this, m.getLocation()) &gt; 0;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks is Biped Mek has functional AES in the location. Only works for
&nbsp;     * Arms
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasFunctionalArmAES(int location) {
&nbsp;
<b class="nc">&nbsp;        boolean hasAES = false;</b>
<b class="nc">&nbsp;        if ((location != Mech.LOC_RARM) &amp;&amp; (location != Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if ((mounted.getLocation() == location)</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.getType().hasFlag(</b>
&nbsp;                    MiscType.F_ACTUATOR_ENHANCEMENT_SYSTEM)
<b class="nc">&nbsp;                &amp;&amp; !mounted.isDestroyed() &amp;&amp; !mounted.isBreached()</b>
<b class="nc">&nbsp;                &amp;&amp; !mounted.isMissing()) {</b>
<b class="nc">&nbsp;                hasAES = true;</b>
&nbsp;            } // AES is destroyed their for it cannot be used.
<b class="nc">&nbsp;            else if ((mounted.getLocation() == location)</b>
<b class="nc">&nbsp;                     &amp;&amp; mounted.getType().hasFlag(</b>
&nbsp;                    MiscType.F_ACTUATOR_ENHANCEMENT_SYSTEM)) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return hasAES;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for functional AES in both legs
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasFunctionalLegAES() {
<b class="nc">&nbsp;        boolean rightLeg = false;</b>
<b class="nc">&nbsp;        boolean leftLeg = false;</b>
<b class="nc">&nbsp;        boolean centerLeg = false;</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if ((mounted.getLocation() == Mech.LOC_LLEG)</b>
<b class="nc">&nbsp;                || (mounted.getLocation() == Mech.LOC_RLEG)</b>
<b class="nc">&nbsp;                || (mounted.getLocation() == Mech.LOC_CLEG)) {</b>
<b class="nc">&nbsp;                if (((MiscType) mounted.getType())</b>
<b class="nc">&nbsp;                            .hasFlag(MiscType.F_ACTUATOR_ENHANCEMENT_SYSTEM)</b>
<b class="nc">&nbsp;                    &amp;&amp; !mounted.isDestroyed()</b>
<b class="nc">&nbsp;                    &amp;&amp; !mounted.isBreached()</b>
<b class="nc">&nbsp;                    &amp;&amp; !mounted.isMissing()) {</b>
<b class="nc">&nbsp;                    if (mounted.getLocation() == Mech.LOC_LLEG) {</b>
<b class="nc">&nbsp;                        leftLeg = true;</b>
<b class="nc">&nbsp;                    } else if (mounted.getLocation() == Mech.LOC_RLEG) {</b>
<b class="nc">&nbsp;                        rightLeg = true;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        centerLeg = true;</b>
&nbsp;                    }
&nbsp;                }// AES is destroyed their for it cannot be used.
<b class="nc">&nbsp;                else if (((MiscType) mounted.getType())</b>
<b class="nc">&nbsp;                        .hasFlag(MiscType.F_ACTUATOR_ENHANCEMENT_SYSTEM)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return rightLeg &amp;&amp; leftLeg &amp;&amp; centerLeg;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canGoHullDown() {
&nbsp;        // check the option
<b class="nc">&nbsp;        boolean retVal = game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_HULL_DOWN);</b>
<b class="nc">&nbsp;        if (!retVal) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // check the locations
<b class="nc">&nbsp;        retVal = (!isLocationBad(Mech.LOC_LLEG)</b>
<b class="nc">&nbsp;                  &amp;&amp; !isLocationBad(Mech.LOC_RLEG) &amp;&amp; !isLocationBad(LOC_CLEG)</b>
<b class="nc">&nbsp;                  &amp;&amp; !isLocationDoomed(Mech.LOC_LLEG) &amp;&amp; !isLocationDoomed(Mech.LOC_RLEG))</b>
<b class="nc">&nbsp;                 &amp;&amp; !isLocationDoomed(LOC_CLEG);</b>
<b class="nc">&nbsp;        if (!retVal) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // check the Gyro
<b class="nc">&nbsp;        return !isGyroDestroyed();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PilotingRollData checkGetUp(MoveStep step,
&nbsp;            EntityMovementType moveType) {
&nbsp;
<b class="nc">&nbsp;        PilotingRollData roll = super.checkGetUp(step, moveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (roll.getValue() != TargetRoll.CHECK_FALSE) {</b>
<b class="nc">&nbsp;            addStandingPenalties(roll);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addStandingPenalties(PilotingRollData roll) {
&nbsp;
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_NO_ARMS)) {</b>
<b class="nc">&nbsp;            roll.addModifier(2, &quot;no/minimal arms&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_ATTEMPTING_STAND)) {</b>
<b class="nc">&nbsp;            int[] locsToCheck = new int[2];</b>
&nbsp;
<b class="nc">&nbsp;            locsToCheck[0] = Mech.LOC_RARM;</b>
<b class="nc">&nbsp;            locsToCheck[1] = Mech.LOC_LARM;</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = 0; i &lt; locsToCheck.length; i++) {</b>
<b class="nc">&nbsp;                int loc = locsToCheck[i];</b>
<b class="nc">&nbsp;                if (isLocationBad(loc)) {</b>
<b class="nc">&nbsp;                    roll.addModifier(2, getLocationName(loc) + &quot; destroyed&quot;);</b>
&nbsp;                } else {
&nbsp;                    // check for damaged hip actuators
<b class="nc">&nbsp;                    if (!hasWorkingSystem(Mech.ACTUATOR_HAND, loc)) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                            + &quot; hand Actuator missing/destroyed&quot;);
<b class="nc">&nbsp;                    } else if (!hasWorkingSystem(Mech.ACTUATOR_LOWER_ARM, loc)) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                            + &quot; lower Actuator missing/destroyed&quot;);
<b class="nc">&nbsp;                    } else if (!hasWorkingSystem(Mech.ACTUATOR_UPPER_ARM, loc)) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                            + &quot; upper ctuator missing/destroyed&quot;);
<b class="nc">&nbsp;                    } else if (!hasWorkingSystem(Mech.ACTUATOR_SHOULDER, loc)) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc)</b>
&nbsp;                                            + &quot; shoulder Actuator missing/destroyed&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return if this mech cannot stand up from hulldown
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean cannotStandUpFromHullDown() {
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        if (isLocationBad(LOC_LLEG)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isLocationBad(LOC_RLEG)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isLocationBad(LOC_CLEG)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (i &gt;= 1) || isGyroDestroyed();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasMPReducingHardenedArmor() {
<b class="nc">&nbsp;        return (armorType[LOC_LLEG] == EquipmentType.T_ARMOR_HARDENED)</b>
&nbsp;               || (armorType[LOC_RLEG] == EquipmentType.T_ARMOR_HARDENED)
&nbsp;               || (armorType[LOC_CLEG] == EquipmentType.T_ARMOR_HARDENED);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of locations in the entity
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int locations() {
<b class="nc">&nbsp;        return 9;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     *
&nbsp;     * @see megamek.common.Entity#rollHitLocation(int, int, int, int)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public HitData rollHitLocation(int table, int side, int aimedLocation,
&nbsp;                                   int aimingMode, int cover) {
<b class="nc">&nbsp;        int roll = -1;</b>
&nbsp;
<b class="nc">&nbsp;        if ((aimedLocation != LOC_NONE)</b>
&nbsp;            &amp;&amp; (aimingMode != IAimingModes.AIM_MODE_NONE)) {
&nbsp;
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;            if ((5 &lt; roll) &amp;&amp; (roll &lt; 9)) {</b>
<b class="nc">&nbsp;                return new HitData(aimedLocation, side == ToHitData.SIDE_REAR,</b>
&nbsp;                                   true);
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((table == ToHitData.HIT_NORMAL)</b>
&nbsp;            || (table == ToHitData.HIT_PARTIAL_COVER)) {
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences()</b>
<b class="nc">&nbsp;                                                  .getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_FRONT) {</b>
&nbsp;                // normal front hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining() &amp;&amp; getCrew()</b>
<b class="nc">&nbsp;                                .getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side,</b>
&nbsp;                                                         Mech.LOC_CT, cover, false));
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_CT, cover, false);</b>
&nbsp;                    case 3:
&nbsp;                    case 4:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 5:
&nbsp;                    case 9:
<b class="nc">&nbsp;                        int legRoll = Compute.d6();</b>
<b class="nc">&nbsp;                        if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                        } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                        }
&nbsp;                    case 6:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 10:
&nbsp;                    case 11:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_LEFT) {</b>
&nbsp;                // normal left side hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining() &amp;&amp; getCrew()</b>
<b class="nc">&nbsp;                                .getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side,</b>
&nbsp;                                                         Mech.LOC_LT, cover, false));
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_LT, cover, false);</b>
&nbsp;                    case 3:
&nbsp;                    case 6:
&nbsp;                    case 11:
<b class="nc">&nbsp;                        int legRoll = Compute.d6() + 1;</b>
<b class="nc">&nbsp;                        if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                        } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                        }
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        if (game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS)) {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 9:
<b class="nc">&nbsp;                        if (game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS)) {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RT, true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 10:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_RIGHT) {</b>
&nbsp;                // normal right side hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining() &amp;&amp; getCrew()</b>
<b class="nc">&nbsp;                                .getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side,</b>
&nbsp;                                                         Mech.LOC_RT, cover, false));
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_RT, cover, false);</b>
&nbsp;                    case 3:
&nbsp;                    case 6:
&nbsp;                    case 11:
<b class="nc">&nbsp;                        int legRoll = Compute.d6() - 1;</b>
<b class="nc">&nbsp;                        if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                        } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                        }
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        if (game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS)) {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 9:
<b class="nc">&nbsp;                        if (game.getOptions().booleanOption(</b>
&nbsp;                                OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS)) {
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LT, true);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 10:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_REAR) {</b>
&nbsp;                // normal rear hits
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(</b>
&nbsp;                        OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS)
<b class="nc">&nbsp;                    &amp;&amp; isProne()) {</b>
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            if ((getCrew().hasEdgeRemaining() &amp;&amp; getCrew()</b>
<b class="nc">&nbsp;                                    .getOptions()</b>
<b class="nc">&nbsp;                                    .booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; !game.getOptions().booleanOption(</b>
&nbsp;                                    OptionsConstants.ADVCOMBAT_NO_TAC)) {
<b class="nc">&nbsp;                                getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                                HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                                 aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                                result.setUndoneLocation(tac(table, side,</b>
&nbsp;                                                             Mech.LOC_CT, cover, true));
<b class="nc">&nbsp;                                return result;</b>
&nbsp;                            } // if
<b class="nc">&nbsp;                            return tac(table, side, Mech.LOC_CT, cover, true);</b>
&nbsp;                        case 3:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RARM, true);</b>
&nbsp;                        case 4:
&nbsp;                        case 5:
&nbsp;                        case 9:
&nbsp;                        case 10:
<b class="nc">&nbsp;                            int legRoll = Compute.d6();</b>
<b class="nc">&nbsp;                            if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                                return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                            } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                                return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                            }
&nbsp;                        case 6:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RT, true);</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                        case 8:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LT, true);</b>
&nbsp;                        case 11:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LARM, true);</b>
&nbsp;                        case 12:
<b class="nc">&nbsp;                            if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                    &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                                getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                                HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                                 aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                                result.setUndoneLocation(new HitData(</b>
&nbsp;                                        Mech.LOC_HEAD, true));
<b class="nc">&nbsp;                                return result;</b>
&nbsp;                            } // if
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_HEAD, true);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                        case 2:
<b class="nc">&nbsp;                            if ((getCrew().hasEdgeRemaining() &amp;&amp; getCrew()</b>
<b class="nc">&nbsp;                                    .getOptions()</b>
<b class="nc">&nbsp;                                    .booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; !game.getOptions().booleanOption(</b>
&nbsp;                                    OptionsConstants.ADVCOMBAT_NO_TAC)) {
<b class="nc">&nbsp;                                getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                                HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                                 aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                                result.setUndoneLocation(tac(table, side,</b>
&nbsp;                                                             Mech.LOC_CT, cover, true));
<b class="nc">&nbsp;                                return result;</b>
&nbsp;                            } // if
<b class="nc">&nbsp;                            return tac(table, side, Mech.LOC_CT, cover, true);</b>
&nbsp;                        case 3:
&nbsp;                        case 4:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RARM, true);</b>
&nbsp;                        case 5:
&nbsp;                        case 9:
<b class="nc">&nbsp;                            int legRoll = Compute.d6();</b>
<b class="nc">&nbsp;                            if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                                return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                            } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                                return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                            }
&nbsp;                        case 6:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_RT, true);</b>
&nbsp;                        case 7:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                        case 8:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LT, true);</b>
&nbsp;                        case 10:
&nbsp;                        case 11:
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_LARM, true);</b>
&nbsp;                        case 12:
<b class="nc">&nbsp;                            if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                    &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                                getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                                HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                                 aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                                result.setUndoneLocation(new HitData(</b>
&nbsp;                                        Mech.LOC_HEAD, true));
<b class="nc">&nbsp;                                return result;</b>
&nbsp;                            } // if
<b class="nc">&nbsp;                            return new HitData(Mech.LOC_HEAD, true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (table == ToHitData.HIT_PUNCH) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(1);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences()</b>
<b class="nc">&nbsp;                                                  .getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_FRONT) {</b>
&nbsp;                // front punch hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_LEFT) {</b>
&nbsp;                // left side punch hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 1:
&nbsp;                    case 2:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_RIGHT) {</b>
&nbsp;                // right side punch hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 1:
&nbsp;                    case 2:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_REAR) {</b>
&nbsp;                // rear punch hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 1:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM, true);</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT, true);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                    case 4:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT, true);</b>
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM, true);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                                &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                             aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD,</b>
&nbsp;                                                                 true));
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD, true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (table == ToHitData.HIT_KICK) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(1);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences()</b>
<b class="nc">&nbsp;                                                  .getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if ((side == ToHitData.SIDE_FRONT) || (side == ToHitData.SIDE_REAR)) {</b>
&nbsp;                // front/rear kick hits
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                    case 1:
&nbsp;                    case 2:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RLEG,</b>
&nbsp;                                           (side == ToHitData.SIDE_REAR));
&nbsp;                    case 3:
&nbsp;                    case 4:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CLEG,</b>
&nbsp;                                           (side == ToHitData.SIDE_REAR));
&nbsp;                    case 5:
&nbsp;                    case 6:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LLEG,</b>
&nbsp;                                           (side == ToHitData.SIDE_REAR));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_LEFT) {</b>
<b class="nc">&nbsp;                int legRoll = Compute.d6() + 1;</b>
<b class="nc">&nbsp;                if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_RIGHT) {</b>
<b class="nc">&nbsp;                int legRoll = Compute.d6() - 1;</b>
<b class="nc">&nbsp;                if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;                } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CLEG);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((table == ToHitData.HIT_SWARM)</b>
&nbsp;            || (table == ToHitData.HIT_SWARM_CONVENTIONAL)) {
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;            int effects;
<b class="nc">&nbsp;            if (table == ToHitData.HIT_SWARM_CONVENTIONAL) {</b>
<b class="nc">&nbsp;                effects = HitData.EFFECT_NONE;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                effects = HitData.EFFECT_CRITICAL;</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences()</b>
<b class="nc">&nbsp;                                                  .getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Swarm attack locations.
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                        &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                            &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                         aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD,</b>
&nbsp;                                                             false, effects));
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD, false, effects);</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT, true, effects);</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT, true, effects);</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT, false, effects);</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RARM, false, effects);</b>
&nbsp;                case 7:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT, false, effects);</b>
&nbsp;                case 8:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LARM, false, effects);</b>
&nbsp;                case 9:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT, false, effects);</b>
&nbsp;                case 10:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT, true, effects);</b>
&nbsp;                case 11:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT, true, effects);</b>
&nbsp;                case 12:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                        &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                            &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                         aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD,</b>
&nbsp;                                                             false, effects));
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD, false, effects);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (table == ToHitData.HIT_ABOVE) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(1);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences()</b>
<b class="nc">&nbsp;                                                  .getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Hits from above.
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LARM,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;                case 2:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;                case 5:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RARM,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;                case 6:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                        &amp;&amp; getCrew().getOptions().booleanOption(</b>
&nbsp;                            &quot;edge_when_headhit&quot;)) {
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side,</b>
&nbsp;                                                         aimedLocation, aimingMode, cover);
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD,</b>
&nbsp;                                                             (side == ToHitData.SIDE_REAR)));
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (table == ToHitData.HIT_BELOW) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(1);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences()</b>
<b class="nc">&nbsp;                                                  .getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Hits from below.
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;                case 1:
&nbsp;                case 2:
&nbsp;                case 5:
&nbsp;                case 6:
<b class="nc">&nbsp;                    int legRoll = Compute.d6();</b>
<b class="nc">&nbsp;                    if (legRoll &lt;= 2) {</b>
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RLEG,</b>
&nbsp;                                           (side == ToHitData.SIDE_REAR));
<b class="nc">&nbsp;                    } else if (legRoll &lt;= 4) {</b>
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CLEG,</b>
&nbsp;                                           (side == ToHitData.SIDE_REAR));
&nbsp;                    } else {
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LLEG,</b>
&nbsp;                                           (side == ToHitData.SIDE_REAR));
&nbsp;                    }
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT,</b>
&nbsp;                                       (side == ToHitData.SIDE_REAR));
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can this mech torso twist in the given direction?
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isValidSecondaryFacing(int dir) {
<b class="nc">&nbsp;        return canChangeSecondaryFacing();</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
