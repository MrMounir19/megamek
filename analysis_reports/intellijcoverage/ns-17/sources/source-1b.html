


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Compute</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: Compute (megamek.common)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Compute</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (12/145)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2.2%
  </span>
  <span class="absValue">
    (70/3236)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2018 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.Building.BasementType;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.actions.BAVibroClawAttackAction;
&nbsp;import megamek.common.actions.BreakGrappleAttackAction;
&nbsp;import megamek.common.actions.BrushOffAttackAction;
&nbsp;import megamek.common.actions.ClubAttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.GrappleAttackAction;
&nbsp;import megamek.common.actions.JumpJetAttackAction;
&nbsp;import megamek.common.actions.KickAttackAction;
&nbsp;import megamek.common.actions.LayExplosivesAttackAction;
&nbsp;import megamek.common.actions.ProtomechPhysicalAttackAction;
&nbsp;import megamek.common.actions.PunchAttackAction;
&nbsp;import megamek.common.actions.PushAttackAction;
&nbsp;import megamek.common.actions.ThrashAttackAction;
&nbsp;import megamek.common.actions.TripAttackAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.weapons.InfantryAttack;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.artillery.ArtilleryCannonWeapon;
&nbsp;import megamek.common.weapons.bayweapons.BayWeapon;
&nbsp;import megamek.common.weapons.gaussrifles.HAGWeapon;
&nbsp;import megamek.common.weapons.infantry.InfantryWeapon;
&nbsp;import megamek.common.weapons.mgs.MGWeapon;
&nbsp;import megamek.common.weapons.mortars.MekMortarWeapon;
&nbsp;import megamek.server.Server;
&nbsp;import megamek.server.SmokeCloud;
&nbsp;
&nbsp;/**
&nbsp; * The compute class is designed to provide static methods for mechs and other
&nbsp; * entities moving, firing, etc.
&nbsp; */
<b class="nc">&nbsp;public class Compute {</b>
&nbsp;
&nbsp;    public static final int ARC_360 = 0;
&nbsp;    public static final int ARC_FORWARD = 1;
&nbsp;    public static final int ARC_LEFTARM = 2;
&nbsp;    public static final int ARC_RIGHTARM = 3;
&nbsp;    public static final int ARC_REAR = 4;
&nbsp;    public static final int ARC_LEFTSIDE = 5;
&nbsp;    public static final int ARC_RIGHTSIDE = 6;
&nbsp;    public static final int ARC_MAINGUN = 7;
&nbsp;    public static final int ARC_NORTH = 8;
&nbsp;    public static final int ARC_EAST = 9;
&nbsp;    public static final int ARC_WEST = 10;
&nbsp;    public static final int ARC_NOSE = 11;
&nbsp;    public static final int ARC_LWING = 12;
&nbsp;    public static final int ARC_RWING = 13;
&nbsp;    public static final int ARC_LWINGA = 14;
&nbsp;    public static final int ARC_RWINGA = 15;
&nbsp;    public static final int ARC_LEFTSIDE_SPHERE = 16;
&nbsp;    public static final int ARC_RIGHTSIDE_SPHERE = 17;
&nbsp;    public static final int ARC_LEFTSIDEA_SPHERE = 18;
&nbsp;    public static final int ARC_RIGHTSIDEA_SPHERE = 19;
&nbsp;    public static final int ARC_LEFT_BROADSIDE = 20;
&nbsp;    public static final int ARC_RIGHT_BROADSIDE = 21;
&nbsp;    public static final int ARC_AFT = 22;
&nbsp;    public static final int ARC_LEFT_SPHERE_GROUND = 23;
&nbsp;    public static final int ARC_RIGHT_SPHERE_GROUND = 24;
&nbsp;    public static final int ARC_TURRET = 25;
&nbsp;    public static final int ARC_SPONSON_TURRET_LEFT = 26;
&nbsp;    public static final int ARC_SPONSON_TURRET_RIGHT = 27;
&nbsp;    public static final int ARC_PINTLE_TURRET_LEFT = 28;
&nbsp;    public static final int ARC_PINTLE_TURRET_RIGHT = 29;
&nbsp;    public static final int ARC_PINTLE_TURRET_FRONT = 30;
&nbsp;    public static final int ARC_PINTLE_TURRET_REAR = 31;
&nbsp;    public static final int ARC_VGL_FRONT = 32;
&nbsp;    public static final int ARC_VGL_RF = 33;
&nbsp;    public static final int ARC_VGL_RR = 34;
&nbsp;    public static final int ARC_VGL_REAR = 35;
&nbsp;    public static final int ARC_VGL_LR = 36;
&nbsp;    public static final int ARC_VGL_LF = 37;
&nbsp;    //Expanded arcs for Waypoint Launched Capital Missiles
&nbsp;    public static final int ARC_NOSE_WPL = 38;
&nbsp;    public static final int ARC_LWING_WPL = 39;
&nbsp;    public static final int ARC_RWING_WPL = 40;
&nbsp;    public static final int ARC_LWINGA_WPL = 41;
&nbsp;    public static final int ARC_RWINGA_WPL = 42;
&nbsp;    public static final int ARC_LEFTSIDE_SPHERE_WPL = 43;
&nbsp;    public static final int ARC_RIGHTSIDE_SPHERE_WPL = 44;
&nbsp;    public static final int ARC_LEFTSIDEA_SPHERE_WPL = 45;
&nbsp;    public static final int ARC_RIGHTSIDEA_SPHERE_WPL = 46;
&nbsp;    public static final int ARC_AFT_WPL = 47;
&nbsp;    public static final int ARC_LEFT_BROADSIDE_WPL = 48;
&nbsp;    public static final int ARC_RIGHT_BROADSIDE_WPL = 49;
&nbsp;    
&nbsp;    /** Lookup table for vehicular grenade launcher firing arc from facing */
<b class="fc">&nbsp;    private static final int[] VGL_FIRING_ARCS = { ARC_VGL_FRONT, ARC_VGL_RF, ARC_VGL_RR,</b>
&nbsp;            ARC_VGL_REAR, ARC_VGL_LR, ARC_VGL_LF
&nbsp;    };
&nbsp;
<b class="fc">&nbsp;    private static MMRandom random = MMRandom.generate(MMRandom.R_DEFAULT);</b>
&nbsp;
<b class="fc">&nbsp;    private static final int[][] clusterHitsTable = new int[][]{</b>
&nbsp;            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
&nbsp;            {2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2},
&nbsp;            {3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3},
&nbsp;            {4, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4},
&nbsp;            {5, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5},
&nbsp;            {6, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6},
&nbsp;            {7, 2, 2, 3, 4, 4, 4, 4, 6, 6, 7, 7},
&nbsp;            {8, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8},
&nbsp;            {9, 3, 3, 4, 5, 5, 5, 5, 7, 7, 9, 9},
&nbsp;            {10, 3, 3, 4, 6, 6, 6, 6, 8, 8, 10, 10},
&nbsp;            {11, 4, 4, 5, 7, 7, 7, 7, 9, 9, 11, 11},
&nbsp;            {12, 4, 4, 5, 8, 8, 8, 8, 10, 10, 12, 12},
&nbsp;            {13, 4, 4, 5, 8, 8, 8, 8, 11, 11, 13, 13},
&nbsp;            {14, 5, 5, 6, 9, 9, 9, 9, 11, 11, 14, 14},
&nbsp;            {15, 5, 5, 6, 9, 9, 9, 9, 12, 12, 15, 15},
&nbsp;            {16, 5, 5, 7, 10, 10, 10, 10, 13, 13, 16, 16},
&nbsp;            {17, 5, 5, 7, 10, 10, 10, 10, 14, 14, 17, 17},
&nbsp;            {18, 6, 6, 8, 11, 11, 11, 11, 14, 14, 18, 18},
&nbsp;            {19, 6, 6, 8, 11, 11, 11, 11, 15, 15, 19, 19},
&nbsp;            {20, 6, 6, 9, 12, 12, 12, 12, 16, 16, 20, 20},
&nbsp;            {21, 7, 7, 9, 13, 13, 13, 13, 17, 17, 21, 21},
&nbsp;            {22, 7, 7, 9, 14, 14, 14, 14, 18, 18, 22, 22},
&nbsp;            {23, 7, 7, 10, 15, 15, 15, 15, 19, 19, 23, 23},
&nbsp;            {24, 8, 8, 10, 16, 16, 16, 16, 20, 20, 24, 24},
&nbsp;            {25, 8, 8, 10, 16, 16, 16, 16, 21, 21, 25, 25},
&nbsp;            {26, 9, 9, 11, 17, 17, 17, 17, 21, 21, 26, 26},
&nbsp;            {27, 9, 9, 11, 17, 17, 17, 17, 22, 22, 27, 27},
&nbsp;            {28, 9, 9, 11, 17, 17, 17, 17, 23, 23, 28, 28},
&nbsp;            {29, 10, 10, 12, 18, 18, 18, 18, 23, 23, 29, 29},
&nbsp;            {30, 10, 10, 12, 18, 18, 18, 18, 24, 24, 30, 30},
&nbsp;            {40, 12, 12, 18, 24, 24, 24, 24, 32, 32, 40, 40}};
&nbsp;
&nbsp;    /**
&nbsp;     * Wrapper to random#d6(n)
&nbsp;     */
&nbsp;    public static int d6(int dice) {
<b class="fc">&nbsp;        Roll roll = random.d6(dice);</b>
<b class="fc">&nbsp;        if (Server.getServerInstance() != null) {</b>
<b class="nc">&nbsp;            if (Server.getServerInstance().getGame().getOptions()</b>
<b class="nc">&nbsp;                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</b>
<b class="nc">&nbsp;                Server.getServerInstance().reportRoll(roll);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return roll.getIntValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wrapper to random#d6(n)
&nbsp;     */
&nbsp;    public static int d6(int dice, int keep) {
<b class="nc">&nbsp;        Roll roll = random.d6(dice, keep);</b>
<b class="nc">&nbsp;        if (Server.getServerInstance() != null) {</b>
<b class="nc">&nbsp;            if (Server.getServerInstance().getGame().getOptions()</b>
<b class="nc">&nbsp;                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</b>
<b class="nc">&nbsp;                Server.getServerInstance().reportRoll(roll);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return roll.getIntValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wrapper to random#d6()
&nbsp;     */
&nbsp;    public static int d6() {
<b class="nc">&nbsp;        Roll roll = random.d6();</b>
<b class="nc">&nbsp;        if (Server.getServerInstance() != null) {</b>
<b class="nc">&nbsp;            if (Server.getServerInstance().getGame().getOptions()</b>
<b class="nc">&nbsp;                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</b>
<b class="nc">&nbsp;                Server.getServerInstance().reportRoll(roll);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return roll.getIntValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wrapper to random#randomInt(n)
&nbsp;     */
&nbsp;    public static int randomInt(int maxValue) {
<b class="nc">&nbsp;        Roll roll = new MMRoll(random, maxValue);</b>
<b class="nc">&nbsp;        return roll.getIntValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wrapper to random#randomFloat()
&nbsp;     */
&nbsp;    public static float randomFloat() {
<b class="nc">&nbsp;        return random.randomFloat();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the RNG to the desired type
&nbsp;     */
&nbsp;    public static void setRNG(int type) {
<b class="nc">&nbsp;        random = MMRandom.generate(type);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the RNG to the specific instance.
&nbsp;     * @param random A non-null instance of {@see MMRandom} to use
&nbsp;     *               for all random number generation.
&nbsp;     */
&nbsp;    public static void setRNG(MMRandom random) {
<b class="nc">&nbsp;        Compute.random = Objects.requireNonNull(random);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the odds that a certain number or above will be rolled on 2d6.
&nbsp;     */
&nbsp;    public static double oddsAbove(int n) {
<b class="fc">&nbsp;        return oddsAbove(n, false);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the odds that a certain number or above will be rolled on 2d6,
&nbsp;     * or on 3d6 drop the lowest if the flag is set.
&nbsp;     *
&nbsp;     * @param n
&nbsp;     * @param dropLowest Flag that determines whether 2d6 or 3d6 drop the
&nbsp;     *                   lowest is used
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static double oddsAbove(int n, boolean dropLowest) {
<b class="fc">&nbsp;        if (n &lt;= 2) {</b>
<b class="nc">&nbsp;            return 100.0;</b>
<b class="fc">&nbsp;        } else if (n &gt; 12) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (dropLowest) {</b>
<b class="nc">&nbsp;            final double[] odds = {100.0, 100.0, 100.0, 99.54, 98.15, 94.91,</b>
&nbsp;                                   89.35, 80.56, 68.06, 52.32, 35.65, 19.91, 7.41, 0};
<b class="nc">&nbsp;            return odds[n];</b>
&nbsp;        } else {
<b class="fc">&nbsp;            final double[] odds = {100.0, 100.0, 100.0, 97.2, 91.6, 83.3, 72.2,</b>
&nbsp;                                   58.3, 41.6, 27.7, 16.6, 8.3, 2.78, 0};
<b class="fc">&nbsp;            return odds[n];</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an entity if the specified entity would cause a stacking
&nbsp;     * violation entering a hex, or returns null if it would not. The returned
&nbsp;     * entity is the entity causing the violation.
&nbsp;     *
&nbsp;     * The position, and elevation for the stacking violation are derived from
&nbsp;     * the Entity represented by the passed Entity ID.
&nbsp;     */
&nbsp;    public static Entity stackingViolation(IGame game, int enteringId,
&nbsp;            Coords coords) {
<b class="nc">&nbsp;        Entity entering = game.getEntity(enteringId);</b>
<b class="nc">&nbsp;        if (entering == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return Compute.stackingViolation(game, entering, coords, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When compiling an unloading step, both the transporter and the unloaded
&nbsp;     * unit probably occupy some other position on the board.
&nbsp;     *
&nbsp;     * The position, and elevation for the stacking violation are derived from
&nbsp;     * the passed Entity.
&nbsp;     *
&nbsp;     * @param transport
&nbsp;     *            Represents the unit transporing entering, which may affect
&nbsp;     *            stacking, can be null
&nbsp;     */
&nbsp;    public static Entity stackingViolation(IGame game, Entity entering,
&nbsp;            Coords dest, Entity transport) {
<b class="nc">&nbsp;        return stackingViolation(game, entering, entering.getElevation(), dest,</b>
&nbsp;                transport);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an entity if the specified entity would cause a stacking
&nbsp;     * violation entering a hex, or returns null if it would not. The returned
&nbsp;     * entity is the entity causing the violation.
&nbsp;     *
&nbsp;     * The position is derived from the passed Entity, while the elevation is
&nbsp;     * derived from the passed Entity parameter.
&nbsp;     *
&nbsp;     * @param transport
&nbsp;     *            Represents the unit transporing entering, which may affect
&nbsp;     *            stacking, can be null
&nbsp;     */
&nbsp;    public static Entity stackingViolation(IGame game, Entity entering,
&nbsp;            int elevation, Coords dest, Entity transport) {
<b class="nc">&nbsp;        return stackingViolation(game, entering, entering.getPosition(),</b>
&nbsp;                elevation, dest, transport);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an entity if the specified entity would cause a stacking
&nbsp;     * violation entering a hex, or returns null if it would not. The returned
&nbsp;     * entity is the entity causing the violation.
&nbsp;     *
&nbsp;     * The position and elevation is derived from the passed Entity parameter.
&nbsp;     *
&nbsp;     * @param transport
&nbsp;     *            Represents the unit transporing entering, which may affect
&nbsp;     *            stacking, can be null
&nbsp;     */
&nbsp;    public static Entity stackingViolation(IGame game, Entity entering,
&nbsp;            Coords origPosition, int elevation, Coords dest, Entity transport) {
&nbsp;        // no stacking violations on the low-atmosphere and space maps
<b class="nc">&nbsp;        if (!game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // no stacking violations for flying aeros
<b class="nc">&nbsp;        if (entering.isAirborne()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean isMech = (entering instanceof Mech)</b>
&nbsp;                || (entering instanceof SmallCraft);
<b class="nc">&nbsp;        boolean isLargeSupport = (entering instanceof LargeSupportTank)</b>
&nbsp;                || (entering instanceof Dropship)
&nbsp;                || ((entering instanceof Mech) &amp;&amp; ((Mech) entering)
<b class="nc">&nbsp;                        .isSuperHeavy());</b>
&nbsp;
<b class="nc">&nbsp;        boolean isTrain = !entering.getAllTowedUnits().isEmpty();</b>
<b class="nc">&nbsp;        boolean isDropship = entering instanceof Dropship;</b>
<b class="nc">&nbsp;        boolean isInfantry = entering instanceof Infantry;</b>
<b class="nc">&nbsp;        Entity firstEntity = transport;</b>
<b class="nc">&nbsp;        int totalUnits = 1;</b>
<b class="nc">&nbsp;        Vector&lt;Coords&gt; positions = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        positions.add(dest);</b>
<b class="nc">&nbsp;        if (isDropship) {</b>
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                positions.add(dest.translated(dir));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (Coords coords : positions) {</b>
<b class="nc">&nbsp;            int thisLowStackingLevel = elevation;</b>
<b class="nc">&nbsp;            if ((coords != null) &amp;&amp; (origPosition != null)) {</b>
<b class="nc">&nbsp;                thisLowStackingLevel = entering.calcElevation(game.getBoard()</b>
<b class="nc">&nbsp;                        .getHex(origPosition), game.getBoard()</b>
<b class="nc">&nbsp;                        .getHex(coords), elevation, entering</b>
<b class="nc">&nbsp;                        .climbMode(), false);</b>
&nbsp;            }
<b class="nc">&nbsp;            int thisHighStackingLevel = thisLowStackingLevel;</b>
&nbsp;            // mechs only occupy one level of a building
<b class="nc">&nbsp;            if (!Compute.isInBuilding(game, entering, coords)) {</b>
<b class="nc">&nbsp;                thisHighStackingLevel += entering.height();</b>
&nbsp;            }
&nbsp;
&nbsp;            // Walk through the entities in the given hex.
<b class="nc">&nbsp;            for (Entity inHex : game.getEntitiesVector(coords)) {</b>
&nbsp;
<b class="nc">&nbsp;                if (inHex.isAirborne()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int lowStackingLevel = inHex.getElevation();</b>
<b class="nc">&nbsp;                int highStackingLevel = lowStackingLevel;</b>
&nbsp;                // units only occupy one level of a building
<b class="nc">&nbsp;                if (!Compute.isInBuilding(game, inHex)) {</b>
<b class="nc">&nbsp;                    highStackingLevel += inHex.height();</b>
&nbsp;                }
&nbsp;
&nbsp;                // Only do all this jazz if they&#39;re close enough together on lvl
&nbsp;                // to interfere.
<b class="nc">&nbsp;                if ((thisLowStackingLevel &lt;= highStackingLevel)</b>
&nbsp;                        &amp;&amp; (thisHighStackingLevel &gt;= lowStackingLevel)) {
&nbsp;                    // Don&#39;t compare the entering entity to itself.
<b class="nc">&nbsp;                    if (inHex.equals(entering)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Ignore the transport of the entering entity.
<b class="nc">&nbsp;                    if (inHex.equals(transport)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    //ignore the first trailer behind a non-superheavy tractor
&nbsp;                    //which can be in the same hex
<b class="nc">&nbsp;                    if (isTrain &amp;&amp; !entering.isSuperHeavy()) {</b>
<b class="nc">&nbsp;                        Entity firstTrailer = game.getEntity(entering.getAllTowedUnits().get(0));</b>
<b class="nc">&nbsp;                        if (inHex.equals(firstTrailer)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // DFAing units don&#39;t count towards stacking
<b class="nc">&nbsp;                    if (inHex.isMakingDfa()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // If the entering entity is a mech,
&nbsp;                    // then any other mech in the hex is a violation.
&nbsp;                    // Unless grappled (but chain whip grapples don&#39;t count)
&nbsp;                    // grounded small craft are treated as mechs for purposes
&nbsp;                    // of stacking
<b class="nc">&nbsp;                    if (isMech</b>
&nbsp;                            &amp;&amp; (((inHex instanceof Mech) &amp;&amp; (inHex
<b class="nc">&nbsp;                                    .getGrappled() != entering.getId() || inHex</b>
<b class="nc">&nbsp;                                    .isChainWhipGrappled())) || (inHex instanceof SmallCraft))) {</b>
<b class="nc">&nbsp;                        return inHex;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // only inf can be in the same hex as a large support vee
&nbsp;                    // grounded dropships are treated as large support vees,
&nbsp;                    // ditto for superheavy mechs
<b class="nc">&nbsp;                    if (isLargeSupport &amp;&amp; !(inHex instanceof Infantry)) {</b>
<b class="nc">&nbsp;                        return inHex;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (((inHex instanceof LargeSupportTank)</b>
&nbsp;                            || (inHex instanceof Dropship) || ((inHex instanceof Mech) &amp;&amp; ((Mech) inHex)
<b class="nc">&nbsp;                            .isSuperHeavy())) &amp;&amp; !isInfantry) {</b>
<b class="nc">&nbsp;                        return inHex;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    totalUnits++;</b>
&nbsp;                    // If the new one is the most
<b class="nc">&nbsp;                    if (totalUnits &gt; 4) {</b>
&nbsp;                        // Arbitrarily return this one, because we can, and it&#39;s
&nbsp;                        // simpler.
<b class="nc">&nbsp;                        return inHex;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Otherwise, if there are two present entities controlled
&nbsp;                    // by this player, returns a random one of the two.
&nbsp;                    // Somewhat arbitrary, but how else should we resolve it?
<b class="nc">&nbsp;                    if (!inHex.getOwner().isEnemyOf(entering.getOwner())) {</b>
<b class="nc">&nbsp;                        if (firstEntity == null) {</b>
<b class="nc">&nbsp;                            firstEntity = inHex;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return Compute.d6() &gt; 3 ? firstEntity : inHex;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // okay, all clear
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if there is any unit that is an enemy of the specified unit
&nbsp;     * in the specified hex. This is only called for stacking purposes, and so
&nbsp;     * does not return true if the enemy unit is currenly making a DFA.
&nbsp;     */
&nbsp;    public static boolean isEnemyIn(IGame game, Entity entity, Coords coords,
&nbsp;                                    boolean onlyMechs, boolean ignoreInfantry, int enLowEl) {
<b class="nc">&nbsp;        int enHighEl = enLowEl + entity.getHeight();</b>
<b class="nc">&nbsp;        for (Entity inHex : game.getEntitiesVector(coords)) {</b>
<b class="nc">&nbsp;            int inHexEnLowEl = inHex.getElevation();</b>
<b class="nc">&nbsp;            int inHexEnHighEl = inHexEnLowEl + inHex.getHeight();</b>
<b class="nc">&nbsp;            if ((!onlyMechs || (inHex instanceof Mech))</b>
&nbsp;                &amp;&amp; !(ignoreInfantry &amp;&amp; (inHex instanceof Infantry))
<b class="nc">&nbsp;                &amp;&amp; inHex.isEnemyOf(entity) &amp;&amp; !inHex.isMakingDfa()</b>
&nbsp;                &amp;&amp; (enLowEl &lt;= inHexEnHighEl) &amp;&amp; (enHighEl &gt;= inHexEnLowEl)) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if a piloting skill roll is needed to traverse the terrain
&nbsp;     */
&nbsp;    public static boolean isPilotingSkillNeeded(IGame game, int entityId,
&nbsp;            Coords src, Coords dest, EntityMovementType movementType,
&nbsp;            boolean isTurning, boolean prevStepIsOnPavement, int srcElevation,
&nbsp;            int destElevation, MoveStep moveStep) {
<b class="nc">&nbsp;        final Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;        final boolean isInfantry = (entity instanceof Infantry);</b>
<b class="nc">&nbsp;        int delta_alt = (destElevation + destHex.getLevel())</b>
<b class="nc">&nbsp;                        - (srcElevation + srcHex.getLevel());</b>
&nbsp;
&nbsp;        // arguments valid?
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Entity invalid. ID &quot; + entityId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (src.distance(dest) &gt; 1) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Coordinates must be adjacent.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // let&#39;s only worry about actual movement, please
<b class="nc">&nbsp;        if (src.equals(dest)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // airborne aircraft do not require pavement-related checks
<b class="nc">&nbsp;        final boolean isPavementStep = entity.isAirborne() ? false : Compute.canMoveOnPavement(game, src, dest, moveStep);</b>
&nbsp;
&nbsp;        // check for rubble
<b class="nc">&nbsp;        if ((movementType != EntityMovementType.MOVE_JUMP)</b>
<b class="nc">&nbsp;            &amp;&amp; (destHex.terrainLevel(Terrains.RUBBLE) &gt; 0)</b>
&nbsp;            &amp;&amp; (destElevation == 0)
&nbsp;            &amp;&amp; !isPavementStep
<b class="nc">&nbsp;            &amp;&amp; entity.canFall()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for swamp
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.SWAMP)</b>
<b class="nc">&nbsp;            &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.VTOL)</b>
&nbsp;            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</b>
&nbsp;            &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for thin ice
<b class="nc">&nbsp;        if (destHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;            &amp;&amp; destHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;            &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</b>
&nbsp;            &amp;&amp; !isPavementStep
&nbsp;            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check for water unless we&#39;re a hovercraft or naval or using a bridge
&nbsp;        // or flying or QuadVee in vehicle mode.
<b class="nc">&nbsp;        if ((movementType != EntityMovementType.MOVE_JUMP)</b>
<b class="nc">&nbsp;                &amp;&amp; !(entity.getElevation() &gt; destHex.surface())</b>
<b class="nc">&nbsp;                &amp;&amp; !((entity.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)</b>
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                        || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</b>
<b class="nc">&nbsp;                &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
&nbsp;                &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Sheer Cliffs, TO p.39
&nbsp;        // Roads over cliffs cancel the cliff effects for units that move on roads
<b class="nc">&nbsp;        boolean quadveeVehMode = entity instanceof QuadVee </b>
<b class="nc">&nbsp;                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</b>
<b class="nc">&nbsp;        boolean vehicleAffectedByCliff = entity instanceof Tank </b>
<b class="nc">&nbsp;                &amp;&amp; !entity.isAirborneVTOLorWIGE();</b>
<b class="nc">&nbsp;        boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech) </b>
&nbsp;                &amp;&amp; movementType != EntityMovementType.MOVE_JUMP
<b class="nc">&nbsp;                &amp;&amp; !entity.isAero(); // LAM</b>
<b class="nc">&nbsp;        int stepHeight = destElevation + destHex.getLevel() - (srcElevation + srcHex.getLevel());</b>
&nbsp;        // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
&nbsp;        // Everything that does not have a 1 or 2 level drop shouldn&#39;t be handled as a cliff
<b class="nc">&nbsp;        boolean isUpCliff = !src.equals(dest)</b>
<b class="nc">&nbsp;                &amp;&amp; destHex.hasCliffTopTowards(srcHex)</b>
&nbsp;                &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<b class="nc">&nbsp;        boolean isDownCliff = !src.equals(dest) </b>
<b class="nc">&nbsp;                &amp;&amp; srcHex.hasCliffTopTowards(destHex)</b>
&nbsp;                &amp;&amp; (stepHeight == -1 || stepHeight == -2);
&nbsp;
&nbsp;        // Mechs and Vehicles moving down a cliff
&nbsp;        // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133 
<b class="nc">&nbsp;        if ((mechAffectedByCliff || vehicleAffectedByCliff) </b>
&nbsp;                &amp;&amp; !quadveeVehMode
&nbsp;                &amp;&amp; isDownCliff
&nbsp;                &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mechs moving up a cliff
<b class="nc">&nbsp;        if (mechAffectedByCliff </b>
&nbsp;                &amp;&amp; !quadveeVehMode 
&nbsp;                &amp;&amp; isUpCliff
&nbsp;                &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check for skid. Please note, the skid will be rolled on the
&nbsp;        // current step, but starts from the previous step&#39;s location.
&nbsp;        // TODO: add check for elevation of pavement, road,
&nbsp;        // or bridge matches entity elevation.
&nbsp;        /*
&nbsp;         * Bug 754610: Revert fix for bug 702735. if ( (
&nbsp;         * srcHex.contains(Terrain.PAVEMENT) || srcHex.contains(Terrain.ROAD) ||
&nbsp;         * srcHex.contains(Terrain.BRIDGE) )
&nbsp;         */
<b class="nc">&nbsp;        if (((prevStepIsOnPavement</b>
&nbsp;                &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
&nbsp;                        || (movementType == EntityMovementType.MOVE_SPRINT)))
<b class="nc">&nbsp;                        || ((srcHex.containsTerrain(Terrains.ICE))</b>
&nbsp;                                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)))
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</b>
&nbsp;                &amp;&amp; isTurning &amp;&amp; !isInfantry) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we entering a building, all non-infantry
&nbsp;        // need to make a piloting check to avoid damage.
<b class="nc">&nbsp;        if ((destElevation &lt; destHex.terrainLevel(Terrains.BLDG_ELEV))</b>
&nbsp;            &amp;&amp; !(entity instanceof Infantry)) {
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(dest);</b>
<b class="nc">&nbsp;            boolean insideHangar = (null != bldg)</b>
<b class="nc">&nbsp;                                   &amp;&amp; bldg.isIn(src)</b>
<b class="nc">&nbsp;                                   &amp;&amp; (bldg.getBldgClass() == Building.HANGAR)</b>
<b class="nc">&nbsp;                                   &amp;&amp; (destHex.terrainLevel(Terrains.BLDG_ELEV) &gt; entity</b>
<b class="nc">&nbsp;                    .height());</b>
<b class="nc">&nbsp;            if (!insideHangar) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check sideslips
<b class="nc">&nbsp;        if ((entity instanceof VTOL)</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                || (entity.getMovementMode() == EntityMovementMode.WIGE</b>
&nbsp;                        &amp;&amp; destElevation &gt; 0 &amp;&amp; !(entity instanceof Protomech))) {
<b class="nc">&nbsp;            if (isTurning</b>
&nbsp;                    &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
&nbsp;                            || (movementType == EntityMovementType.MOVE_SPRINT)
&nbsp;                            || (movementType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                            || (movementType == EntityMovementType.MOVE_VTOL_SPRINT))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // Controlled sideslip requires check to avoid extra hex of sideslip movement.
<b class="nc">&nbsp;            if ((moveStep.getType() == MoveStepType.LATERAL_LEFT</b>
<b class="nc">&nbsp;                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT</b>
<b class="nc">&nbsp;                    || moveStep.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</b>
<b class="nc">&nbsp;                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS)</b>
<b class="nc">&nbsp;                    &amp;&amp; (!entity.isUsingManAce()</b>
&nbsp;                            || movementType != EntityMovementType.MOVE_WALK
&nbsp;                            || movementType != EntityMovementType.MOVE_VTOL_WALK)) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check leaps
<b class="nc">&nbsp;        if ((entity instanceof Mech) &amp;&amp; (delta_alt &lt; -2)</b>
&nbsp;            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP
&nbsp;            &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_WALK
&nbsp;            &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_RUN)))) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can the defending unit be displaced from the source to the destination?
&nbsp;     */
&nbsp;    public static boolean isValidDisplacement(IGame game, int entityId,
&nbsp;            Coords src, int direction) {
<b class="nc">&nbsp;        return Compute.isValidDisplacement(game, entityId, src,</b>
<b class="nc">&nbsp;                src.translated(direction));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can the defending unit be displaced from the source to the destination?
&nbsp;     */
&nbsp;    public static boolean isValidDisplacement(IGame game, int entityId,
&nbsp;            Coords src, Coords dest) {
<b class="nc">&nbsp;        final Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;        final ArrayList&lt;Coords&gt; intervening = Coords.intervening(src, dest);</b>
<b class="nc">&nbsp;        final int direction = src.direction(dest);</b>
&nbsp;
&nbsp;        // arguments valid?
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Entity invalid.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // dropships should never be displaceable
&nbsp;        // this should also take care of the situation of displacing another
&nbsp;        // entity
&nbsp;        // into a grounded droppers hex, because of the stacking violation check
&nbsp;        // below
<b class="nc">&nbsp;        if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // an easy check
<b class="nc">&nbsp;        if (!game.getBoard().contains(dest)) {</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.BASE_PUSH_OFF_BOARD)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can&#39;t be displaced into prohibited terrain
&nbsp;        // unless we&#39;re displacing a tracked or wheeled vee into water
<b class="nc">&nbsp;        if (entity.isLocationProhibited(dest)</b>
&nbsp;                &amp;&amp; !((entity instanceof Tank)
<b class="nc">&nbsp;                        &amp;&amp; destHex.containsTerrain(Terrains.WATER)</b>
&nbsp;                        &amp;&amp; ((entity.movementMode == EntityMovementMode.TRACKED)
&nbsp;                                || (entity.movementMode == EntityMovementMode.WHEELED)))) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // can&#39;t go up more levels than normally possible
<b class="nc">&nbsp;        for (Coords c : intervening) {</b>
&nbsp;            // ignore off-board hexes
<b class="nc">&nbsp;            if (!game.getBoard().contains(c)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            final IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;            int change = entity.elevationOccupied(hex)</b>
<b class="nc">&nbsp;                         - entity.elevationOccupied(srcHex);</b>
<b class="nc">&nbsp;            if (change &gt; entity.getMaxElevationChange()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // if there&#39;s an entity in the way, can they be displaced in that
&nbsp;        // direction?
<b class="nc">&nbsp;        Entity inTheWay = Compute.stackingViolation(game, entityId, dest);</b>
<b class="nc">&nbsp;        if (inTheWay != null) {</b>
<b class="nc">&nbsp;            return Compute.isValidDisplacement(game, inTheWay.getId(),</b>
<b class="nc">&nbsp;                    inTheWay.getPosition(), direction);</b>
&nbsp;        }
&nbsp;
&nbsp;        // okay, that&#39;s about all the checks
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a valid displacement, from the hexes around src, as close to the
&nbsp;     * original direction as is possible.
&nbsp;     *
&nbsp;     * @return valid displacement coords, or null if none
&nbsp;     */
&nbsp;    public static Coords getValidDisplacement(IGame game, int entityId,
&nbsp;            Coords src, int direction) {
&nbsp;        // check the surrounding hexes, nearest to the original direction first
<b class="nc">&nbsp;        int[] offsets = {0, 1, 5, 2, 4, 3};</b>
<b class="nc">&nbsp;        int range = 1;</b>
&nbsp;        // check for a central dropship hex and if so, then displace to a two
&nbsp;        // hex radius
<b class="nc">&nbsp;        for (Entity en : game.getEntitiesVector(src)) {</b>
<b class="nc">&nbsp;            if ((en instanceof Dropship) &amp;&amp; !en.isAirborne()</b>
<b class="nc">&nbsp;                &amp;&amp; en.getPosition().equals(src)) {</b>
<b class="nc">&nbsp;                range = 2;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (int offset : offsets) {</b>
<b class="nc">&nbsp;            Coords dest = src.translated((direction + offset) % 6, range);</b>
<b class="nc">&nbsp;            if (Compute.isValidDisplacement(game, entityId, src, dest)) {</b>
<b class="nc">&nbsp;                return dest;</b>
&nbsp;            }
&nbsp;            // code here borrowed from Compute.coordsAtRange
<b class="nc">&nbsp;            for (int count = 1; count &lt; range; count++) {</b>
<b class="nc">&nbsp;                dest = dest.translated((direction + offset + 2) % 6);</b>
<b class="nc">&nbsp;                if (Compute.isValidDisplacement(game, entityId, src, dest)) {</b>
<b class="nc">&nbsp;                    return dest;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // have fun being insta-killed!
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a preferred displacement. Right now this picks the surrounding hex
&nbsp;     * with the same elevation as original hex, if not available it picks the
&nbsp;     * highest elevation that is a valid displacement. This will preferably not
&nbsp;     * displace into friendly units
&nbsp;     *
&nbsp;     * @return valid displacement coords, or null if none
&nbsp;     */
&nbsp;    public static Coords getPreferredDisplacement(IGame game, int entityId,
&nbsp;            Coords src, int direction) {
<b class="nc">&nbsp;        final Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        int highestElev = Integer.MIN_VALUE;</b>
<b class="nc">&nbsp;        Coords highest = null;</b>
<b class="nc">&nbsp;        int srcElevation =</b>
<b class="nc">&nbsp;                entity.elevationOccupied(game.getBoard().getHex(src));</b>
&nbsp;
&nbsp;        // check the surrounding hexes, nearest to the original direction first
<b class="nc">&nbsp;        int[] offsets = {0, 1, 5, 2, 4, 3};</b>
&nbsp;        // first, try not to displace into friendly units
<b class="nc">&nbsp;        for (int offset : offsets) {</b>
<b class="nc">&nbsp;            Coords dest = src.translated((direction + offset) % 6);</b>
<b class="nc">&nbsp;            if (Compute.isValidDisplacement(game, entityId, src, dest)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().contains(dest)) {</b>
<b class="nc">&nbsp;                Iterator&lt;Entity&gt; entities = game.getFriendlyEntities(dest,</b>
<b class="nc">&nbsp;                        game.getEntity(entityId));</b>
<b class="nc">&nbsp;                if (entities.hasNext()) {</b>
&nbsp;                    // friendly unit here, try next hex
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                IHex hex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;                int elevation = entity.elevationOccupied(hex);</b>
<b class="nc">&nbsp;                if (elevation &gt; highestElev) {</b>
<b class="nc">&nbsp;                    highestElev = elevation;</b>
<b class="nc">&nbsp;                    highest = dest;</b>
&nbsp;                }
&nbsp;                // preferably, go to same elevation
<b class="nc">&nbsp;                if (elevation == srcElevation) {</b>
<b class="nc">&nbsp;                    return dest;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (highest != null) {</b>
<b class="nc">&nbsp;            return highest;</b>
&nbsp;        }
&nbsp;        // ok, all hexes occupied, now displace preferably to same elevation,
&nbsp;        // else highest
<b class="nc">&nbsp;        for (int offset : offsets) {</b>
<b class="nc">&nbsp;            Coords dest = src.translated((direction + offset) % 6);</b>
<b class="nc">&nbsp;            if (Compute.isValidDisplacement(game, entityId, src, dest)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().contains(dest)) {</b>
<b class="nc">&nbsp;                IHex hex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;                int elevation = entity.elevationOccupied(hex);</b>
<b class="nc">&nbsp;                if (elevation &gt; highestElev) {</b>
<b class="nc">&nbsp;                    highestElev = elevation;</b>
<b class="nc">&nbsp;                    highest = dest;</b>
&nbsp;                }
&nbsp;                // preferably, go to same elevation
<b class="nc">&nbsp;                if (elevation == entity.getElevation()) {</b>
<b class="nc">&nbsp;                    return dest;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return highest;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a hex to displace a missed charge to. Picks left or right, first
&nbsp;     * preferring higher hexes, then randomly, or returns the base hex if
&nbsp;     * they&#39;re impassible.
&nbsp;     */
&nbsp;    public static Coords getMissedChargeDisplacement(IGame game, int entityId,
&nbsp;                                                     Coords src, int direction) {
<b class="nc">&nbsp;        Coords first = src.translated((direction + 1) % 6);</b>
<b class="nc">&nbsp;        Coords second = src.translated((direction + 5) % 6);</b>
<b class="nc">&nbsp;        IHex firstHex = game.getBoard().getHex(first);</b>
<b class="nc">&nbsp;        IHex secondHex = game.getBoard().getHex(second);</b>
<b class="nc">&nbsp;        Entity entity = game.getEntity(entityId);</b>
&nbsp;
<b class="nc">&nbsp;        if ((firstHex == null) || (secondHex == null)) {</b>
&nbsp;            // leave it, will be handled
<b class="nc">&nbsp;        } else if (entity.elevationOccupied(firstHex) &gt; entity</b>
<b class="nc">&nbsp;                .elevationOccupied(secondHex)) {</b>
&nbsp;            // leave it
<b class="nc">&nbsp;        } else if (entity.elevationOccupied(firstHex) &lt; entity</b>
<b class="nc">&nbsp;                .elevationOccupied(secondHex)) {</b>
&nbsp;            // switch
<b class="nc">&nbsp;            Coords temp = first;</b>
<b class="nc">&nbsp;            first = second;</b>
<b class="nc">&nbsp;            second = temp;</b>
<b class="nc">&nbsp;        } else if (Compute.d6() &gt; 3) {</b>
&nbsp;            // switch randomly
<b class="nc">&nbsp;            Coords temp = first;</b>
<b class="nc">&nbsp;            first = second;</b>
<b class="nc">&nbsp;            second = temp;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (Compute.isValidDisplacement(game, entityId, src,</b>
<b class="nc">&nbsp;                                        src.direction(first))</b>
<b class="nc">&nbsp;            &amp;&amp; game.getBoard().contains(first)) {</b>
<b class="nc">&nbsp;            return first;</b>
<b class="nc">&nbsp;        } else if (Compute.isValidDisplacement(game, entityId, src,</b>
<b class="nc">&nbsp;                                               src.direction(second))</b>
<b class="nc">&nbsp;                   &amp;&amp; game.getBoard().contains(second)) {</b>
<b class="nc">&nbsp;            return second;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return src;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds the best spotter for the attacker. The best spotter is the one with
&nbsp;     * the lowest attack modifiers, of course. LOS modifiers and movement are
&nbsp;     * considered.
&nbsp;     */
&nbsp;    public static Entity findSpotter(IGame game, Entity attacker,
&nbsp;                                     Targetable target) {
<b class="nc">&nbsp;        Entity spotter = null;</b>
<b class="nc">&nbsp;        int taggedBy = -1;</b>
<b class="nc">&nbsp;        if (target instanceof Entity) {</b>
<b class="nc">&nbsp;            taggedBy = ((Entity) target).getTaggedBy();</b>
&nbsp;        }
<b class="nc">&nbsp;        ToHitData bestMods = new ToHitData(TargetRoll.IMPOSSIBLE, &quot;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity other : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (((other.isSpotting() &amp;&amp; (other.getSpotTargetId() == target</b>
<b class="nc">&nbsp;                    .getTargetId())) || (taggedBy == other.getId()))</b>
<b class="nc">&nbsp;                &amp;&amp; !attacker.isEnemyOf(other)) {</b>
&nbsp;                // what are this guy&#39;s mods to the attack?
<b class="nc">&nbsp;                LosEffects los = LosEffects.calculateLos(game, other.getId(),</b>
&nbsp;                        target, true);
<b class="nc">&nbsp;                ToHitData mods = los.losModifiers(game);</b>
&nbsp;                // If the target isn&#39;t spotted, can&#39;t target
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                    &amp;&amp; !Compute.inVisualRange(game, los, other, target)</b>
<b class="nc">&nbsp;                    &amp;&amp; !Compute.inSensorRange(game, los, other, target, null)) {</b>
<b class="nc">&nbsp;                    mods.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;outside of visual and sensor range&quot;);
&nbsp;                }
<b class="nc">&nbsp;                los.setTargetCover(LosEffects.COVER_NONE);</b>
<b class="nc">&nbsp;                mods.append(Compute.getAttackerMovementModifier(game,</b>
<b class="nc">&nbsp;                                                                other.getId()));</b>
&nbsp;                
&nbsp;                // a spotter suffers a penalty if it&#39;s also making an attack this round
&nbsp;                // unless it has a command console or has TAGged the target
<b class="nc">&nbsp;                if (other.isAttackingThisTurn() &amp;&amp; !other.getCrew().hasActiveCommandConsole() &amp;&amp; </b>
<b class="nc">&nbsp;                        (!isTargetTagged(attacker, target, game) || (taggedBy != -1))) {</b>
<b class="nc">&nbsp;                    mods.addModifier(1, &quot;spotter is making an attack this turn&quot;);</b>
&nbsp;                }
&nbsp;                
&nbsp;                // is this guy a better spotter?
<b class="nc">&nbsp;                if ((spotter == null)</b>
<b class="nc">&nbsp;                    || (mods.getValue() &lt; bestMods.getValue())) {</b>
<b class="nc">&nbsp;                    spotter = other;</b>
<b class="nc">&nbsp;                    bestMods = mods;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return spotter;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Worker function to determine if the target has been tagged.
&nbsp;     * @param target The non-entity target to check
&nbsp;     * @param game Game object
&nbsp;     * @return Whether or not the given entity or other targetable is tagged.
&nbsp;     */
&nbsp;    public static boolean isTargetTagged(Targetable target, IGame game) {
<b class="nc">&nbsp;        boolean targetTagged = false;</b>
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if(target instanceof Entity) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If this is an entity, we can see if it&#39;s tagged
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            targetTagged = te.getTaggedBy() != -1;</b>
&nbsp;        } else { // Non entities will require us to look harder
<b class="nc">&nbsp;            for (TagInfo ti : game.getTagInfo()) {</b>
<b class="nc">&nbsp;                if (target.getTargetId() == ti.target.getTargetId()) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return targetTagged;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Worker function to determine if the target has been tagged by the specific attacker.
&nbsp;     * @param attacker The attacker.
&nbsp;     * @param target The non-entity target to check
&nbsp;     * @param game Game object
&nbsp;     * @return Whether or not the given entity or other targetable is tagged by the specific attacker.
&nbsp;     */
&nbsp;    public static boolean isTargetTagged(Entity attacker, Targetable target, IGame game) {
<b class="nc">&nbsp;        boolean targetTagged = false;</b>
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if(target instanceof Entity) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If this is an entity, we can see if it&#39;s tagged
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            targetTagged = te.getTaggedBy() == attacker.getId();</b>
&nbsp;        } else { // Non entities will require us to look harder
<b class="nc">&nbsp;            for (TagInfo ti : game.getTagInfo()) {</b>
<b class="nc">&nbsp;                if ((target.getTargetId() == ti.target.getTargetId()) &amp;&amp;</b>
<b class="nc">&nbsp;                        (ti.attackerId == attacker.getId())) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return targetTagged;</b>
&nbsp;    }
&nbsp;    
&nbsp;    
&nbsp;    public static ToHitData getImmobileMod(Targetable target) {
<b class="nc">&nbsp;        return Compute.getImmobileMod(target, Entity.LOC_NONE,</b>
&nbsp;                                      IAimingModes.AIM_MODE_NONE);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the ToHitData associated with firing at an immobile target. Returns null if target isn&#39;t.
&nbsp;     * @param target The target being considered for firing
&nbsp;     * @param aimingAt The location of the unit being aimed at
&nbsp;     * @param aimingMode The aiming mode
&nbsp;     * @return The relevant ToHitData
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    public static ToHitData getImmobileMod(Targetable target, int aimingAt,
&nbsp;                                           int aimingMode) {
&nbsp;        // if we are bombing hexes, they are not considered immobile.
<b class="nc">&nbsp;        if(target.getTargetType() == Targetable.TYPE_HEX_BOMB ||</b>
<b class="nc">&nbsp;           target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (target.isImmobile()) {</b>
<b class="nc">&nbsp;            if ((target instanceof Mech) &amp;&amp; (aimingAt == Mech.LOC_HEAD)</b>
&nbsp;                &amp;&amp; (aimingMode == IAimingModes.AIM_MODE_IMMOBILE)) {
<b class="nc">&nbsp;                return new ToHitData(3, &quot;aiming at head&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new ToHitData(-4, &quot;target immobile&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the to-hit modifier due to range for an attack with the
&nbsp;     * specified parameters. Includes minimum range, infantry 0-range mods, and
&nbsp;     * target stealth mods. Accounts for friendly C3 units.
&nbsp;     *
&nbsp;     * @return the modifiers
&nbsp;     */
&nbsp;    public static ToHitData getRangeMods(IGame game, Entity ae, int weaponId,
&nbsp;                                         Targetable target) {
<b class="nc">&nbsp;        Mounted weapon = ae.getEquipment(weaponId);</b>
<b class="nc">&nbsp;        WeaponType wtype = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;        int[] weaponRanges = wtype.getRanges(weapon);</b>
<b class="nc">&nbsp;        boolean isAttackerInfantry = (ae instanceof Infantry);</b>
<b class="nc">&nbsp;        boolean isAttackerBA = (ae instanceof BattleArmor);</b>
<b class="nc">&nbsp;        boolean isWeaponInfantry = (wtype instanceof InfantryWeapon) &amp;&amp; !wtype.hasFlag(WeaponType.F_TAG);</b>
<b class="nc">&nbsp;        boolean isSwarmOrLegAttack = (wtype instanceof InfantryAttack);</b>
<b class="nc">&nbsp;        boolean isIndirect = ((wtype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_EXLRM)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_TBOLT_5)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_TBOLT_10)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_TBOLT_15)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_TBOLT_20)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_IATM)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_MEK_MORTAR)</b>
&nbsp;                || (wtype instanceof ArtilleryCannonWeapon))
<b class="nc">&nbsp;                &amp;&amp; weapon.curMode().equals(&quot;Indirect&quot;);</b>
<b class="nc">&nbsp;        boolean useExtremeRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE);</b>
<b class="nc">&nbsp;        boolean useLOSRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE);</b>
&nbsp;        //Naval C3 only provides full C3 range benefits to energy weapons and guided missiles
<b class="nc">&nbsp;        boolean nc3EnergyGuided = ((wtype.hasFlag(WeaponType.F_ENERGY))</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_CAPITAL_MISSILE)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_TELE_MISSILE)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_AR10)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_ATM)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_LRM)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_SRM)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_MML)</b>
<b class="nc">&nbsp;                || (wtype.getAtClass() == WeaponType.CLASS_THUNDERBOLT));</b>
&nbsp;
<b class="nc">&nbsp;        if (ae.isAirborne()) {</b>
<b class="nc">&nbsp;            useExtremeRange = true;</b>
&nbsp;            // This is a separate SO rule, and isn&#39;t implemented yet
<b class="nc">&nbsp;            useLOSRange = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ToHitData mods = new ToHitData();</b>
&nbsp;
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target instanceof Entity) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
&nbsp;        // We need to adjust the ranges for Centurion Weapon Systems: it&#39;s
&nbsp;        //  default range is 6/12/18 but that&#39;s only for units that are
&nbsp;        //  susceptible to CWS, for those that aren&#39;t the ranges are 1/2/3
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_CWS)</b>
<b class="nc">&nbsp;            &amp;&amp; ((te == null) || !te.hasQuirk(&quot;susceptible_cws&quot;))) {</b>
<b class="nc">&nbsp;            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</b>
<b class="nc">&nbsp;            weaponRanges[RangeType.RANGE_SHORT] = 1;</b>
<b class="nc">&nbsp;            weaponRanges[RangeType.RANGE_MEDIUM] = 2;</b>
<b class="nc">&nbsp;            weaponRanges[RangeType.RANGE_LONG] = 3;</b>
<b class="nc">&nbsp;            weaponRanges[RangeType.RANGE_EXTREME] = 4;</b>
&nbsp;        }
&nbsp;
&nbsp;        //
&nbsp;        // modifiy the ranges for PPCs when field inhibitors are turned off
&nbsp;        // TODO: See above, it should be coded elsewhere...
&nbsp;        //
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_PPC)) {</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PPC_INHIBITORS)) {</b>
<b class="nc">&nbsp;                if ((weapon.curMode() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; weapon.curMode().equals(&quot;Field Inhibitor OFF&quot;)) {</b>
<b class="nc">&nbsp;                    weaponRanges[RangeType.RANGE_MINIMUM] = 0;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Hotloaded weapons
<b class="nc">&nbsp;        if (weapon.isHotLoaded()</b>
<b class="nc">&nbsp;            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HOTLOAD)) {</b>
<b class="nc">&nbsp;            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // is water involved?
<b class="nc">&nbsp;        IHex targHex = game.getBoard().getHex(target.getPosition());</b>
<b class="nc">&nbsp;        int targTop = target.relHeight();</b>
<b class="nc">&nbsp;        int targBottom = target.getElevation();</b>
&nbsp;
<b class="nc">&nbsp;        boolean targetInPartialWater = false;</b>
<b class="nc">&nbsp;        boolean targetUnderwater = false;</b>
<b class="nc">&nbsp;        boolean weaponUnderwater = (ae.getLocationStatus(weapon.getLocation()) == ILocationExposureStatus.WET);</b>
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_ENTITY)</b>
<b class="nc">&nbsp;            &amp;&amp; (targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER) </b>
&nbsp;            &amp;&amp; (targBottom &lt; 0)) {
&nbsp;            
<b class="nc">&nbsp;                if (targTop &gt;= 0) {</b>
<b class="nc">&nbsp;                    targetInPartialWater = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    targetUnderwater = true;</b>
&nbsp;                }
&nbsp;        }
&nbsp;
&nbsp;        // allow naval units on surface to be attacked from above or below
<b class="nc">&nbsp;        if ((null != te) &amp;&amp; (targBottom == 0)</b>
<b class="nc">&nbsp;            &amp;&amp; (te.getUnitType() == UnitType.NAVAL)) {</b>
<b class="nc">&nbsp;            targetInPartialWater = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // allow naval units to target underwater units,
&nbsp;        // torpedo tubes are mounted underwater
<b class="nc">&nbsp;        if ((targetUnderwater</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) || (wtype</b>
<b class="nc">&nbsp;                .getAmmoType() == AmmoType.T_SRM_TORPEDO))</b>
<b class="nc">&nbsp;            &amp;&amp; (ae.getUnitType() == UnitType.NAVAL)) {</b>
<b class="nc">&nbsp;            weaponUnderwater = true;</b>
<b class="nc">&nbsp;            weaponRanges = wtype.getWRanges();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // allow ice to be cleared from below
<b class="nc">&nbsp;        if ((targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;            &amp;&amp; (target.getTargetType() == Targetable.TYPE_HEX_CLEAR)) {</b>
<b class="nc">&nbsp;            targetInPartialWater = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (weaponUnderwater) {</b>
<b class="nc">&nbsp;            weaponRanges = wtype.getWRanges();</b>
<b class="nc">&nbsp;            boolean MPM = false;</b>
<b class="nc">&nbsp;            if ((wtype.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_MRM)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_MML)) {</b>
<b class="nc">&nbsp;                AmmoType atype = (AmmoType) weapon.getLinked().getType();</b>
<b class="nc">&nbsp;                if (atype.getMunitionType() == AmmoType.M_TORPEDO) {</b>
<b class="nc">&nbsp;                    weaponRanges = wtype.getRanges(weapon);</b>
<b class="nc">&nbsp;                } else if (atype.getMunitionType() == AmmoType.M_MULTI_PURPOSE) {</b>
<b class="nc">&nbsp;                    weaponRanges = wtype.getRanges(weapon);</b>
<b class="nc">&nbsp;                    MPM = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // HACK on ranges: for those without underwater range,
&nbsp;            // long == medium; iteration in rangeBracket() allows this
<b class="nc">&nbsp;            if (weaponRanges[RangeType.RANGE_SHORT] == 0) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Weapon cannot fire underwater.&quot;);
&nbsp;            }
<b class="nc">&nbsp;            if (!targetUnderwater &amp;&amp; !targetInPartialWater &amp;&amp; !MPM) {</b>
&nbsp;                // target on land or over water
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Weapon underwater, but not target.&quot;);
&nbsp;            }
&nbsp;            // special case: mechs can only fire upper body weapons at surface
&nbsp;            // naval
<b class="nc">&nbsp;            if ((te != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.getUnitType() == UnitType.NAVAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (ae instanceof Mech) &amp;&amp; (ae.height() &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; (ae.getElevation() == -1)) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Partially submerged mech cannot fire leg weapons at surface naval vessels.&quot;);
&nbsp;            }
<b class="nc">&nbsp;        } else if (targetUnderwater) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                 &quot;Target underwater, but not weapon.&quot;);
<b class="nc">&nbsp;        } else if ((wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</b>
<b class="nc">&nbsp;                   || (wtype.getAmmoType() == AmmoType.T_SRM_TORPEDO)) {</b>
&nbsp;            // Torpedos only fire underwater.
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                 &quot;Weapon can only fire underwater.&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // if Aero then adjust to standard ranges
<b class="nc">&nbsp;        if (ae.isAero() &amp;&amp; (ae.isAirborne()</b>
<b class="nc">&nbsp;            || (ae.usesWeaponBays() &amp;&amp; game.getBoard().onGround()))) {</b>
<b class="nc">&nbsp;            weaponRanges = wtype.getATRanges();</b>
&nbsp;        }
&nbsp;        // And if you&#39;re using bearings-only capital missiles, update the extreme range
<b class="nc">&nbsp;        if (weapon.isInBearingsOnlyMode()) {</b>
<b class="nc">&nbsp;            weaponRanges = new int[] { Integer.MIN_VALUE, 12, 24, 40, RangeType.RANGE_BEARINGS_ONLY_OUT };</b>
&nbsp;        }
&nbsp;
&nbsp;        // determine base distance &amp; range bracket
<b class="nc">&nbsp;        int distance = Compute.effectiveDistance(game, ae, target, false);</b>
<b class="nc">&nbsp;        int range = RangeType.rangeBracket(distance, weaponRanges,</b>
&nbsp;                                           useExtremeRange, useLOSRange);
&nbsp;
&nbsp;        // Additional checks for LOS range and some weapon types, TO 85
<b class="nc">&nbsp;        if (range == RangeType.RANGE_LOS) {</b>
&nbsp;            // Swarm or leg attacks can&#39;t use LoS range
<b class="nc">&nbsp;            if (isSwarmOrLegAttack) {</b>
<b class="nc">&nbsp;                range = RangeType.RANGE_OUT;</b>
&nbsp;            }
&nbsp;
&nbsp;            // MGs lack range for LOS Range, but don&#39;t have F_DIRECT_FIRE flag
<b class="nc">&nbsp;            if (wtype instanceof MGWeapon) {</b>
<b class="nc">&nbsp;                range = RangeType.RANGE_OUT;</b>
&nbsp;            }
&nbsp;
&nbsp;            // AMS lack range for LOS Range, but don&#39;t have F_DIRECT_FIRE flag
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;                range = RangeType.RANGE_OUT;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Flamers lack range for LOS Range, but don&#39;t have F_DIRECT_FIRE
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_FLAMER)) {</b>
<b class="nc">&nbsp;                range = RangeType.RANGE_OUT;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int longRange = wtype.getRanges(weapon)[RangeType.RANGE_LONG];</b>
&nbsp;            // No Missiles or Direct Fire Ballistics with range &lt; 13
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_MISSILE)</b>
<b class="nc">&nbsp;                || (wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</b>
<b class="nc">&nbsp;                    &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC))) {</b>
<b class="nc">&nbsp;                if (longRange &lt; 13) {</b>
<b class="nc">&nbsp;                    range = RangeType.RANGE_OUT;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // No Direct Fire Energy or Pulse with range &lt; 7
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_PULSE)</b>
<b class="nc">&nbsp;                || (wtype.hasFlag(WeaponType.F_ENERGY)</b>
<b class="nc">&nbsp;                    &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE))) {</b>
<b class="nc">&nbsp;                if (longRange &lt; 7) {</b>
<b class="nc">&nbsp;                    range = RangeType.RANGE_OUT;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        int maxRange = wtype.getMaxRange(weapon);</b>
&nbsp;
&nbsp;        // if aero and greater than max range then swith to range_out
<b class="nc">&nbsp;        if ((ae.isAirborne() || (ae.usesWeaponBays() &amp;&amp; game.getBoard()</b>
<b class="nc">&nbsp;                .onGround())) &amp;&amp; (range &gt; maxRange)) {</b>
<b class="nc">&nbsp;            range = RangeType.RANGE_OUT;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Swarm/Leg attacks need to  be impossible, not auto-fail, so that the
&nbsp;        // attack can&#39;t even be attempted
<b class="nc">&nbsp;        if (isSwarmOrLegAttack &amp;&amp; (distance &gt; 0)) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                    &quot;Swarm/Leg attacks can &quot;
&nbsp;                            + &quot;only target units in the same hex!&quot;);
&nbsp;        }
&nbsp;        // short circuit if at zero range or out of range
<b class="nc">&nbsp;        if ((range == RangeType.RANGE_OUT) &amp;&amp; !isWeaponInfantry) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                 &quot;Target out of range&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // Infantry with infantry weapons (rifles, etc, i.e. not field pieces)
&nbsp;        //  and BattleArmor can fire at zero range, among other things
<b class="nc">&nbsp;        if ((distance == 0)</b>
&nbsp;            &amp;&amp; (!isAttackerInfantry ||
&nbsp;                !(isWeaponInfantry || isSwarmOrLegAttack
&nbsp;                  || isAttackerBA))
<b class="nc">&nbsp;            &amp;&amp; !(ae.isAirborne())</b>
<b class="nc">&nbsp;            &amp;&amp; !(ae.isBomber() &amp;&amp; ((IBomber)ae).isVTOLBombing())</b>
<b class="nc">&nbsp;            &amp;&amp; !((ae instanceof Dropship) &amp;&amp; ((Dropship) ae).isSpheroid()</b>
<b class="nc">&nbsp;                 &amp;&amp; !ae.isAirborne() &amp;&amp; !ae.isSpaceborne())</b>
<b class="nc">&nbsp;            &amp;&amp; !((ae instanceof Mech) &amp;&amp; (((Mech) ae).getGrappled() == target</b>
<b class="nc">&nbsp;                .getTargetId()))) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                 &quot;Only infantry weapons shoot at zero range&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<b class="nc">&nbsp;        if (!Compute.useSpheroidAtmosphere(game, ae) &amp;&amp; Compute.inDeadZone(game, ae, target)) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;Target in dead zone&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // find any c3 spotters that could help
<b class="nc">&nbsp;        Entity c3spotter = Compute.findC3Spotter(game, ae, target);</b>
<b class="nc">&nbsp;        if (isIndirect) {</b>
<b class="nc">&nbsp;            c3spotter = ae; // no c3 when using indirect fire</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isIndirect</b>
<b class="nc">&nbsp;            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_INDIRECT_ALWAYS_POSSIBLE)</b>
<b class="nc">&nbsp;            &amp;&amp; LosEffects.calculateLos(game, ae.getId(), target).canSee()</b>
<b class="nc">&nbsp;            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND) || Compute</b>
<b class="nc">&nbsp;                .canSee(game, ae, target))</b>
&nbsp;            &amp;&amp; !(wtype instanceof MekMortarWeapon)) {
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                    &quot;Indirect fire impossible with direct LOS&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int c3dist = Compute.effectiveDistance(game, c3spotter, target, false);</b>
&nbsp;        // C3 can&#39;t benefit from LOS range
<b class="nc">&nbsp;        int c3range = RangeType.rangeBracket(c3dist, weaponRanges,</b>
&nbsp;                useExtremeRange, false);
&nbsp;
&nbsp;        /*
&nbsp;         * Tac Ops Extreme Range Rule p. 85 if the weapons normal range is
&nbsp;         * Extreme then C3 uses the next highest range bracket, i.e. medium
&nbsp;         * instead of short.
&nbsp;         */
<b class="nc">&nbsp;        if ((range == RangeType.RANGE_EXTREME) &amp;&amp; (c3range &lt; range)) {</b>
<b class="nc">&nbsp;            c3range++;</b>
&nbsp;        }
&nbsp;
&nbsp;        // determine which range we&#39;re using
<b class="nc">&nbsp;        int usingRange = Math.min(range, c3range);</b>
&nbsp;
&nbsp;        // add range modifier, C3 can&#39;t be used with LOS Range
<b class="nc">&nbsp;        if ((usingRange == range) || (range == RangeType.RANGE_LOS) || (ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided)) {</b>
&nbsp;            // Ensure usingRange is set to range, ie with C3
<b class="nc">&nbsp;            usingRange = range;</b>
&nbsp;            // Naval C3 adjustment for ballistic and unguided weapons
<b class="nc">&nbsp;            if ((ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided) &amp;&amp; (c3range &lt; range)) {</b>
<b class="nc">&nbsp;                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</b>
<b class="nc">&nbsp;                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</b>
<b class="nc">&nbsp;                    mods.addModifier((ae.getShortRangeModifier() / 2), &quot;NC3 modified short range&quot;);</b>
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_MEDIUM) {</b>
<b class="nc">&nbsp;                    mods.addModifier((ae.getMediumRangeModifier() / 2), &quot;NC3 modified medium range&quot;);</b>
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_LONG) {</b>
<b class="nc">&nbsp;                    mods.addModifier((ae.getLongRangeModifier() / 2), &quot;NC3 modified long range&quot;);</b>
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_EXTREME) {</b>
<b class="nc">&nbsp;                    mods.addModifier((ae.getExtremeRangeModifier() / 2), &quot;NC3 modified Extreme range&quot;);</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // no c3 adjustment
<b class="nc">&nbsp;                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</b>
<b class="nc">&nbsp;                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</b>
<b class="nc">&nbsp;                    mods.addModifier(ae.getShortRangeModifier(), &quot;short range&quot;);</b>
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_MEDIUM) {</b>
&nbsp;                    // Right now, the range-mod affecting targeting systems DON&#39;T
&nbsp;                    // affect medium range, so we won&#39;t add that here ever.
<b class="nc">&nbsp;                    mods.addModifier(ae.getMediumRangeModifier(), &quot;medium range&quot;);</b>
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_LONG) {</b>
&nbsp;                    // Protos that loose head sensors can&#39;t shoot long range.
<b class="nc">&nbsp;                    if ((ae instanceof Protomech)</b>
&nbsp;                            &amp;&amp; (2 == ((Protomech) ae)
<b class="nc">&nbsp;                            .getCritsHit(Protomech.LOC_HEAD))) {</b>
<b class="nc">&nbsp;                        mods.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;No long range attacks with destroyed head sensors.&quot;);
&nbsp;                    } else {
<b class="nc">&nbsp;                        mods.addModifier(ae.getLongRangeModifier(), &quot;long range&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_EXTREME) {</b>
&nbsp;                    // Protos that loose head sensors can&#39;t shoot extreme range.
<b class="nc">&nbsp;                    if ((ae instanceof Protomech)</b>
&nbsp;                            &amp;&amp; (2 == ((Protomech) ae)
<b class="nc">&nbsp;                            .getCritsHit(Protomech.LOC_HEAD))) {</b>
<b class="nc">&nbsp;                        mods.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;No extreme range attacks with destroyed head sensors.&quot;);
&nbsp;                    } else {
<b class="nc">&nbsp;                        mods.addModifier(ae.getExtremeRangeModifier(),</b>
&nbsp;                                         &quot;extreme range&quot;);
&nbsp;                    }
<b class="nc">&nbsp;                } else if (range == RangeType.RANGE_LOS) {</b>
&nbsp;                    // Protos that loose head sensors can&#39;t shoot LOS range.
<b class="nc">&nbsp;                    if ((ae instanceof Protomech)</b>
&nbsp;                            &amp;&amp; (2 == ((Protomech) ae)
<b class="nc">&nbsp;                            .getCritsHit(Protomech.LOC_HEAD))) {</b>
<b class="nc">&nbsp;                        mods.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;No LOS range attacks with destroyed head sensors.&quot;);
&nbsp;                    } else {
<b class="nc">&nbsp;                        mods.addModifier(ae.getLOSRangeModifier(),</b>
&nbsp;                                         &quot;LOS range&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
&nbsp;            // report c3 adjustment
<b class="nc">&nbsp;            if ((c3range == RangeType.RANGE_SHORT)</b>
&nbsp;                || (c3range == RangeType.RANGE_MINIMUM)) {
<b class="nc">&nbsp;                mods.addModifier(ae.getShortRangeModifier(),</b>
&nbsp;                                 &quot;short range due to C3 spotter&quot;);
<b class="nc">&nbsp;            } else if (c3range == RangeType.RANGE_MEDIUM) {</b>
<b class="nc">&nbsp;                mods.addModifier(ae.getMediumRangeModifier(),</b>
&nbsp;                                 &quot;medium range due to C3 spotter&quot;);
<b class="nc">&nbsp;            } else if (c3range == RangeType.RANGE_LONG) {</b>
<b class="nc">&nbsp;                mods.addModifier(ae.getLongRangeModifier(),</b>
&nbsp;                                 &quot;long range due to C3 spotter&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // add minimum range modifier (only for ground-to-ground attacks)
<b class="nc">&nbsp;        int minRange = weaponRanges[RangeType.RANGE_MINIMUM];</b>
<b class="nc">&nbsp;        if ((minRange &gt; 0) &amp;&amp; (distance &lt;= minRange)</b>
<b class="nc">&nbsp;            &amp;&amp; Compute.isGroundToGround(ae, target)) {</b>
<b class="nc">&nbsp;            int minPenalty = (minRange - distance) + 1;</b>
<b class="nc">&nbsp;            mods.addModifier(minPenalty, &quot;minimum range&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if this is an infantry weapon then we use a whole different
&nbsp;        // calculation
&nbsp;        // to figure out range, so overwrite whatever we have at this point
<b class="nc">&nbsp;        if (isWeaponInfantry) {</b>
<b class="nc">&nbsp;            mods = Compute.getInfantryRangeMods(Math.min(distance, c3dist),</b>
&nbsp;                    (InfantryWeapon) wtype,
<b class="nc">&nbsp;                    (ae instanceof Infantry)? ((Infantry)ae).getSecondaryWeapon() : null,</b>
&nbsp;                            weaponUnderwater);
&nbsp;
<b class="nc">&nbsp;            int rangeModifier = mods.getValue();</b>
<b class="nc">&nbsp;            if (rangeModifier == TargetRoll.AUTOMATIC_FAIL) {</b>
<b class="nc">&nbsp;                usingRange = RangeType.RANGE_OUT;</b>
<b class="nc">&nbsp;            } else if (rangeModifier == 0) {</b>
<b class="nc">&nbsp;                usingRange = RangeType.RANGE_SHORT;</b>
<b class="nc">&nbsp;            } else if (rangeModifier &lt;= 2) {</b>
<b class="nc">&nbsp;                usingRange = RangeType.RANGE_MEDIUM;</b>
<b class="nc">&nbsp;            } else if (rangeModifier &lt;= 4) {</b>
<b class="nc">&nbsp;                usingRange = RangeType.RANGE_LONG;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                usingRange = RangeType.RANGE_EXTREME;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // add any target stealth modifier
<b class="nc">&nbsp;        if (target instanceof Entity) {</b>
<b class="nc">&nbsp;            TargetRoll tmpTR = ((Entity) target).getStealthModifier(usingRange,</b>
&nbsp;                                                                    ae);
<b class="nc">&nbsp;            if ((tmpTR != null) &amp;&amp; (tmpTR.getValue() != 0)) {</b>
<b class="nc">&nbsp;                mods.append(((Entity) target)</b>
<b class="nc">&nbsp;                                    .getStealthModifier(usingRange, ae));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return mods;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate the range modifiers for a conventional infantry attack.
&nbsp;     *
&nbsp;     * @param distance - range to target
&nbsp;     * @param wpn - the weapon used to calculate range -- secondary if 2/squad, otherwise primary
&nbsp;     * @param secondary - the secondary weapon, if any. Range zero penalties apply even if primary is used for range
&nbsp;     * @param underwater - underwater range is half, rounded down
&nbsp;     * @return - all modifiers for range
&nbsp;     */
&nbsp;    public static ToHitData getInfantryRangeMods(int distance, InfantryWeapon wpn,
&nbsp;            InfantryWeapon secondary, boolean underwater) {
<b class="nc">&nbsp;        ToHitData mods = new ToHitData();</b>
<b class="nc">&nbsp;        int range = wpn.getInfantryRange();</b>
<b class="nc">&nbsp;        if (underwater) {</b>
<b class="nc">&nbsp;            range /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        int mod = 0;</b>
&nbsp;
<b class="nc">&nbsp;        switch (range) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                if (distance &gt; 0) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = 0;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 1:
<b class="nc">&nbsp;                if (distance &gt; 3) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -2;</b>
<b class="nc">&nbsp;                } else if (distance == 2) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance == 3) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 2:
<b class="nc">&nbsp;                if (distance &gt; 6) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance &gt; 4) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 2) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -2;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 3:
<b class="nc">&nbsp;                if (distance &gt; 9) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance &gt; 6) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 3) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -2;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 4:
<b class="nc">&nbsp;                if (distance &gt; 12) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance &gt; 10) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 8) {</b>
<b class="nc">&nbsp;                    mod = 3;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 6) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 4) {</b>
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -2;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 5:
<b class="nc">&nbsp;                if (distance &gt; 15) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance &gt; 12) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 10) {</b>
<b class="nc">&nbsp;                    mod = 3;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 7) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 5) {</b>
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -1;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 6:
<b class="nc">&nbsp;                if (distance &gt; 18) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance &gt; 15) {</b>
<b class="nc">&nbsp;                    mod = 5;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 12) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 9) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 6) {</b>
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -1;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case 7:
<b class="nc">&nbsp;                if (distance &gt; 21) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                         &quot;Target out of range&quot;);
<b class="nc">&nbsp;                } else if (distance &gt; 17) {</b>
<b class="nc">&nbsp;                    mod = 6;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 14) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 10) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                } else if (distance &gt; 7) {</b>
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                } else if (distance == 0) {</b>
<b class="nc">&nbsp;                    mod = -1;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                     &quot;Target out of range&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // a bunch of special conditions at range 0
&nbsp;        // penalties due to point blank or encumbering apply for secondary weapon even if
&nbsp;        // primary is used to determine range
<b class="nc">&nbsp;        if (distance == 0) {</b>
&nbsp;
<b class="nc">&nbsp;            if (wpn.hasFlag(WeaponType.F_INF_POINT_BLANK)</b>
<b class="nc">&nbsp;                    || (secondary != null &amp;&amp; secondary.hasFlag(WeaponType.F_INF_POINT_BLANK))) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;point blank weapon&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wpn.hasFlag(WeaponType.F_INF_ENCUMBER) || (wpn.getCrew() &gt; 1)</b>
&nbsp;                    || (secondary != null
<b class="nc">&nbsp;                        &amp;&amp; (secondary.hasFlag(WeaponType.F_INF_ENCUMBER)</b>
<b class="nc">&nbsp;                                || secondary.getCrew() &gt; 1))) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;point blank support weapon&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (wpn.hasFlag(WeaponType.F_INF_BURST)) {</b>
<b class="nc">&nbsp;                mods.addModifier(-1, &quot;point blank burst fire weapon&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // TODO: we need to adjust for stealth modifiers for Chameleon LPS but
&nbsp;        // we don&#39;t have range brackets
&nbsp;        // http://bg.battletech.com/forums/index.php/topic,27433.new.html#new
&nbsp;
<b class="nc">&nbsp;        if (mod != 0) {</b>
<b class="nc">&nbsp;            mods.addModifier(mod, &quot;infantry range&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return mods;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds the effective distance between an attacker and a target. Includes
&nbsp;     * the distance bonus if the attacker and target are in the same building
&nbsp;     * and on different levels. Also takes account of altitude differences
&nbsp;     *
&nbsp;     * @return the effective distance
&nbsp;     */
&nbsp;    public static int effectiveDistance(IGame game, Entity attacker, Targetable target) {
<b class="nc">&nbsp;        return Compute.effectiveDistance(game, attacker, target, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds the effective distance between an attacker and a target. Includes
&nbsp;     * the distance bonus if the attacker and target are in the same building
&nbsp;     * and on different levels. Also takes account of altitude differences
&nbsp;     *
&nbsp;     * @return the effective distance
&nbsp;     */
&nbsp;    public static int effectiveDistance(IGame game, Entity attacker, Targetable target,
&nbsp;                                        boolean useGroundDistance) {
<b class="nc">&nbsp;        if (Compute.isAirToGround(attacker, target)</b>
<b class="nc">&nbsp;                || (attacker.isBomber() &amp;&amp; target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB)) {</b>
&nbsp;            // always a distance of zero
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Coords&gt; attackPos = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        attackPos.add(attacker.getPosition());</b>
<b class="nc">&nbsp;        Vector&lt;Coords&gt; targetPos = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;        targetPos.add(target.getPosition());</b>
&nbsp;        // if a grounded dropship is the attacker, then it gets to choose the
&nbsp;        // best secondary position for LoS
<b class="nc">&nbsp;        if ((attacker instanceof Dropship) &amp;&amp; !attacker.isAirborne() &amp;&amp; !attacker.isSpaceborne()) {</b>
<b class="nc">&nbsp;            attackPos = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (int key : attacker.getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                attackPos.add(attacker.getSecondaryPositions().get(key));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((target instanceof Dropship) &amp;&amp; !target.isAirborne() &amp;&amp; !((Entity) target).isSpaceborne()) {</b>
<b class="nc">&nbsp;            targetPos = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            for (final int key : target.getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                targetPos.add(target.getSecondaryPositions().get(key));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        int distance = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        for (Coords apos : attackPos) {</b>
<b class="nc">&nbsp;            for (Coords tpos : targetPos) {</b>
<b class="nc">&nbsp;                if ((tpos != null) &amp;&amp; (apos != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (apos.distance(tpos) &lt; distance)) {</b>
<b class="nc">&nbsp;                    distance = apos.distance(tpos);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (Compute.isGroundToAir(attacker, target) &amp;&amp; (target instanceof Entity)) {</b>
&nbsp;            // distance is determined by closest point on flight path
<b class="nc">&nbsp;            distance = attacker.getPosition().distance(getClosestFlightPath(attacker.getId(),</b>
<b class="nc">&nbsp;                    attacker.getPosition(), (Entity) target));</b>
&nbsp;
&nbsp;            // if the ground attacker uses weapon bays and we are on a
&nbsp;            // ground map, then we will divide this distance by 16
&nbsp;            // This is totally crazy, but I don&#39;t see how else to do it. Use
&nbsp;            // the unofficial
&nbsp;            // &quot;grounded dropships use individual weapons&quot; for sanity.
<b class="nc">&nbsp;            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                distance = (int) Math.ceil(distance / 16.0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if this is an air-to-air attack on the ground map, then divide
&nbsp;        // distance by 16
<b class="nc">&nbsp;        if (Compute.isAirToAir(attacker, target) &amp;&amp; game.getBoard().onGround() &amp;&amp; !useGroundDistance) {</b>
<b class="nc">&nbsp;            distance = (int) Math.ceil(distance / 16.0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the attack is completely inside a building, add the difference
&nbsp;        // in elevations between the attacker and target to the range.
&nbsp;        // TODO: should the player be explicitly notified?
<b class="nc">&nbsp;        if (Compute.isInSameBuilding(game, attacker, target)) {</b>
<b class="nc">&nbsp;            int aElev = attacker.getElevation();</b>
<b class="nc">&nbsp;            int tElev = target.getElevation();</b>
<b class="nc">&nbsp;            distance += Math.abs(aElev - tElev);</b>
&nbsp;        }
&nbsp;
&nbsp;        // air-to-air attacks add one for altitude differences
<b class="nc">&nbsp;        if (Compute.isAirToAir(attacker, target)) {</b>
<b class="nc">&nbsp;            int aAlt = attacker.getAltitude();</b>
<b class="nc">&nbsp;            int tAlt = target.getAltitude();</b>
<b class="nc">&nbsp;            if (target.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                tAlt++;</b>
&nbsp;            }
<b class="nc">&nbsp;            distance += Math.abs(aAlt - tAlt);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (Compute.isGroundToAir(attacker, target)) {</b>
<b class="nc">&nbsp;            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;                distance += (target.getAltitude());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                distance += (2 * target.getAltitude());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Attacking a ground unit while dropping
<b class="nc">&nbsp;        if (attacker.isDropping() &amp;&amp; target.getAltitude() == 0) {</b>
<b class="nc">&nbsp;            distance += (2 * attacker.getAltitude());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return distance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param aPos the attacker&#39;s position
&nbsp;     * @param te the target entity
&nbsp;     * @return the closest position along &lt;code&gt;te&lt;/codeE&gt;&#39;s flight path to &lt;code&gt;aPos&lt;/code&gt;. In
&nbsp;     * the case of multiple equi-distance positions, the first one is picked unless
&nbsp;     * &lt;code&gt;te&lt;/code&gt;&#39;s playerPickedPassThrough position is non-null.
&nbsp;     */
&nbsp;    public static @Nullable Coords getClosestFlightPath(int attackerId, Coords aPos, Entity te) {
<b class="nc">&nbsp;        Coords finalPos = te.getPosition();</b>
<b class="nc">&nbsp;        if (te.getPlayerPickedPassThrough(attackerId) != null) {</b>
<b class="nc">&nbsp;            finalPos = te.getPlayerPickedPassThrough(attackerId);</b>
&nbsp;        }
<b class="nc">&nbsp;        int distance = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        if (finalPos != null) {</b>
<b class="nc">&nbsp;            distance = aPos.distance(finalPos);</b>
&nbsp;        }
&nbsp;        // don&#39;t return zero distance Coords, but rather the Coords immediately
&nbsp;        // before this
&nbsp;        // This is necessary to determine angle of attack and arc information
&nbsp;        // for direct fly-overs
<b class="nc">&nbsp;        for (Coords c : te.getPassedThrough()) {</b>
<b class="nc">&nbsp;            if (!aPos.equals(c) &amp;&amp; (c != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</b>
<b class="nc">&nbsp;                finalPos = c;</b>
<b class="nc">&nbsp;                distance = aPos.distance(c);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return finalPos;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int getClosestFlightPathFacing(int attackerId,
&nbsp;            Coords aPos, Entity te) {
&nbsp;
<b class="nc">&nbsp;        Coords finalPos = te.getPosition();</b>
<b class="nc">&nbsp;        if (te.getPlayerPickedPassThrough(attackerId) != null) {</b>
<b class="nc">&nbsp;            finalPos = te.getPlayerPickedPassThrough(attackerId);</b>
&nbsp;        }
<b class="nc">&nbsp;        int distance = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        if (finalPos != null) {</b>
<b class="nc">&nbsp;            distance = aPos.distance(finalPos);</b>
&nbsp;        }
<b class="nc">&nbsp;        int finalFacing = te.getFacing();</b>
&nbsp;        // don&#39;t return zero distance Coords, but rather the Coords immediately
&nbsp;        // before this
&nbsp;        // This is necessary to determine angle of attack and arc information
&nbsp;        // for direct fly-overs
<b class="nc">&nbsp;        for (int i = 0; i &lt; te.getPassedThrough().size(); i++) {</b>
<b class="nc">&nbsp;            Coords c = te.getPassedThrough().get(i);</b>
<b class="nc">&nbsp;            if (!aPos.equals(c) &amp;&amp; (c != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</b>
<b class="nc">&nbsp;                finalFacing = te.getPassedThroughFacing().get(i);</b>
<b class="nc">&nbsp;                finalPos = c;</b>
<b class="nc">&nbsp;                distance = aPos.distance(c);</b>
<b class="nc">&nbsp;            } else if (c.equals(finalPos)) {</b>
<b class="nc">&nbsp;                finalFacing = te.getPassedThroughFacing().get(i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return finalFacing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * WOR: Need this function to find out where my nova stuff doesn&#39;t work.
&nbsp;     * Delete it if nova works but remember to alter the /nova debug server
&nbsp;     * command.
&nbsp;     */
&nbsp;    public static Entity exposed_findC3Spotter(IGame game, Entity attacker,
&nbsp;                                               Targetable target) {
<b class="nc">&nbsp;        return findC3Spotter(game, attacker, target);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * find a c3, c3i, NC3, or nova spotter that is closer to the target than the
&nbsp;     * attacker.
&nbsp;     *
&nbsp;     * @param game
&nbsp;     * @param attacker
&nbsp;     * @param target
&nbsp;     * @return A closer C3/C3i/Nova spotter, or the attacker if no spotters are
&nbsp;     *         found
&nbsp;     */
&nbsp;    private static Entity findC3Spotter(IGame game, Entity attacker,
&nbsp;            Targetable target) {
&nbsp;        // no available C3-like system
<b class="nc">&nbsp;        if (!attacker.hasC3() &amp;&amp; !attacker.hasC3i()</b>
<b class="nc">&nbsp;                &amp;&amp; !attacker.hasActiveNovaCEWS() &amp;&amp; !attacker.hasNavalC3()) {</b>
<b class="nc">&nbsp;            return attacker;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; network = new ArrayList&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Compute friends in network
<b class="nc">&nbsp;        for (Entity friend : game.getEntitiesVector()) {</b>
&nbsp;
<b class="nc">&nbsp;            if (attacker.equals(friend)</b>
<b class="nc">&nbsp;                    || !attacker.onSameC3NetworkAs(friend, true)</b>
<b class="nc">&nbsp;                    || !friend.isDeployed()</b>
<b class="nc">&nbsp;                    || (friend.getTransportId() != Entity.NONE)) {</b>
<b class="nc">&nbsp;                continue; // useless to us...</b>
&nbsp;            }
&nbsp;
&nbsp;            // Must have LoS, Compute.canSee considers sensors and visual range
<b class="nc">&nbsp;            if (!LosEffects.calculateLos(game, friend.getId(), target).canSee()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int buddyRange = Compute.effectiveDistance(game, friend, target,</b>
&nbsp;                    false);
&nbsp;
<b class="nc">&nbsp;            boolean added = false;</b>
&nbsp;            // put everyone in the C3 network into a list and sort it by range.
<b class="nc">&nbsp;            for (int pos = 0; pos &lt; network.size(); pos++) {</b>
<b class="nc">&nbsp;                if (Compute.effectiveDistance(game, network.get(pos), target,</b>
&nbsp;                        false) &gt;= buddyRange) {
<b class="nc">&nbsp;                    network.add(pos, friend);</b>
<b class="nc">&nbsp;                    added = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!added) {</b>
<b class="nc">&nbsp;                network.add(friend);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // ensure network connectivity
<b class="nc">&nbsp;        List&lt;ECMInfo&gt; allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</b>
<b class="nc">&nbsp;                .getEntitiesVector());</b>
<b class="nc">&nbsp;        int position = 0;</b>
<b class="nc">&nbsp;        for (Entity spotter : network) {</b>
<b class="nc">&nbsp;            for (int count = position++; count &lt; network.size(); count++) {</b>
<b class="nc">&nbsp;                if (Compute.canCompleteNodePath(spotter, attacker, network,</b>
&nbsp;                        count, allECMInfo)) {
<b class="nc">&nbsp;                    return spotter;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return attacker;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Looks through the network list to ensure that the given Entity is
&nbsp;     * connected to the network.
&nbsp;     *
&nbsp;     * @param start
&nbsp;     * @param end
&nbsp;     * @param network
&nbsp;     * @param startPosition
&nbsp;     * @return
&nbsp;     */
&nbsp;    private static boolean canCompleteNodePath(Entity start, Entity end,
&nbsp;            ArrayList&lt;Entity&gt; network, int startPosition,
&nbsp;            List&lt;ECMInfo&gt; allECMInfo) {
&nbsp;
<b class="nc">&nbsp;        Entity spotter = network.get(startPosition);</b>
&nbsp;
&nbsp;        // ECMInfo for line between spotter&#39;s position and start&#39;s position
<b class="nc">&nbsp;        ECMInfo spotterStartECM = ComputeECM.getECMEffects(spotter,</b>
<b class="nc">&nbsp;                start.getPosition(), spotter.getPosition(), true, allECMInfo);</b>
&nbsp;
&nbsp;        // Check for ECM between spotter and start
<b class="nc">&nbsp;        boolean isC3BDefeated = start.hasBoostedC3()</b>
<b class="nc">&nbsp;                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isAngelECM();</b>
<b class="nc">&nbsp;        boolean isNovaDefeated = start.hasNovaCEWS()</b>
<b class="nc">&nbsp;                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isNovaECM();</b>
<b class="nc">&nbsp;        boolean isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</b>
<b class="nc">&nbsp;                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isECM();</b>
<b class="nc">&nbsp;        if (isC3BDefeated || isNovaDefeated || isC3Defeated) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // ECMInfo for line between spotter&#39;s position and end&#39;s position
<b class="nc">&nbsp;        ECMInfo spotterEndECM = ComputeECM.getECMEffects(spotter,</b>
<b class="nc">&nbsp;                spotter.getPosition(), end.getPosition(), true, allECMInfo);</b>
<b class="nc">&nbsp;        isC3BDefeated = start.hasBoostedC3() &amp;&amp; (spotterEndECM != null)</b>
<b class="nc">&nbsp;                &amp;&amp; spotterEndECM.isAngelECM();</b>
<b class="nc">&nbsp;        isNovaDefeated = start.hasNovaCEWS() &amp;&amp; (spotterEndECM != null)</b>
<b class="nc">&nbsp;                &amp;&amp; spotterEndECM.isNovaECM();</b>
<b class="nc">&nbsp;        isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</b>
<b class="nc">&nbsp;                &amp;&amp; (spotterEndECM != null) &amp;&amp; spotterEndECM.isECM();</b>
&nbsp;        // If there&#39;s no ECM between spotter and end, we&#39;re done
<b class="nc">&nbsp;        if (!(isC3BDefeated || isNovaDefeated || isC3Defeated)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (++startPosition; startPosition &lt; network.size(); startPosition++) {</b>
<b class="nc">&nbsp;            if (Compute.canCompleteNodePath(spotter, end, network,</b>
&nbsp;                    startPosition, allECMInfo)) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the modifiers, if any, that the mech receives from being prone.
&nbsp;     *
&nbsp;     * @return any applicable modifiers due to being prone
&nbsp;     */
&nbsp;    public static ToHitData getProneMods(IGame game, Entity attacker,
&nbsp;                                         int weaponId) {
<b class="nc">&nbsp;        if (!attacker.isProne()) {</b>
<b class="nc">&nbsp;            return null; // no modifier</b>
&nbsp;        }
<b class="nc">&nbsp;        ToHitData mods = new ToHitData();</b>
<b class="nc">&nbsp;        Mounted weapon = attacker.getEquipment(weaponId);</b>
<b class="nc">&nbsp;        if (attacker.entityIsQuad()) {</b>
<b class="nc">&nbsp;            int legsDead = ((Mech) attacker).countBadLegs();</b>
<b class="nc">&nbsp;            if (legsDead == 0 &amp;&amp; !((Mech)attacker).hasHipCrit()) {</b>
&nbsp;                // No legs destroyed and no hip crits: no penalty and can fire all weapons
<b class="nc">&nbsp;                return null; // no modifier</b>
<b class="nc">&nbsp;            } else if (legsDead &gt;= 3) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Prone with three or more legs destroyed.&quot;);
&nbsp;            }
&nbsp;            // we have one or two dead legs...
&nbsp;
&nbsp;            // Need an intact front leg
<b class="nc">&nbsp;            if (attacker.isLocationBad(Mech.LOC_RARM)</b>
<b class="nc">&nbsp;                &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Prone with both front legs destroyed.&quot;);
&nbsp;            }
&nbsp;
&nbsp;            // front leg-mounted weapons have addidional trouble
<b class="nc">&nbsp;            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</b>
<b class="nc">&nbsp;                || (weapon.getLocation() == Mech.LOC_LARM || (weapon.getSecondLocation() == Mech.LOC_LARM))) {</b>
<b class="nc">&nbsp;                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</b>
<b class="nc">&nbsp;                        || weapon.getSecondLocation() == Mech.LOC_RARM)? Mech.LOC_LARM</b>
<b class="nc">&nbsp;                                                                     : Mech.LOC_RARM;</b>
&nbsp;                // check previous attacks for weapons fire from the other arm
<b class="nc">&nbsp;                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</b>
&nbsp;                                                   otherArm)) {
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;Prone and firing from other front leg already.&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;            // can&#39;t fire rear leg weapons
<b class="nc">&nbsp;            if ((weapon.getLocation() == Mech.LOC_LLEG)</b>
<b class="nc">&nbsp;                || (weapon.getLocation() == Mech.LOC_RLEG)) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Can&#39;t fire rear leg-mounted weapons while prone with destroyed legs.&quot;);
&nbsp;            }
<b class="nc">&nbsp;            if (((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</b>
<b class="nc">&nbsp;                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;attacker prone&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                mods.addModifier(2, &quot;attacker prone&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            int l3ProneFiringArm = Entity.LOC_NONE;</b>
&nbsp;
<b class="nc">&nbsp;            if (attacker.isLocationBad(Mech.LOC_RARM)</b>
<b class="nc">&nbsp;                || attacker.isLocationBad(Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PRONE_FIRE)) {</b>
&nbsp;                    // Can fire with only one arm
<b class="nc">&nbsp;                    if (attacker.isLocationBad(Mech.LOC_RARM)</b>
<b class="nc">&nbsp;                        &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                        return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                             &quot;Prone with both arms destroyed.&quot;);
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    l3ProneFiringArm = attacker.isLocationBad(Mech.LOC_RARM) ? Mech.LOC_LARM</b>
<b class="nc">&nbsp;                                                                             : Mech.LOC_RARM;</b>
&nbsp;                } else {
&nbsp;                    // must have an arm intact
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;Prone with one or both arms destroyed.&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // arm-mounted weapons have addidional trouble
<b class="nc">&nbsp;            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</b>
<b class="nc">&nbsp;                || (weapon.getLocation() == Mech.LOC_LARM) || (weapon.getSecondLocation() == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                if (l3ProneFiringArm == weapon.getLocation()</b>
<b class="nc">&nbsp;                        || (weapon.getSecondLocation() != Entity.NONE &amp;&amp; l3ProneFiringArm == weapon.getSecondLocation())) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;Prone and propping up with this arm.&quot;);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</b>
<b class="nc">&nbsp;                        || weapon.getSecondLocation() == Mech.LOC_RARM)? Mech.LOC_LARM</b>
<b class="nc">&nbsp;                                                                        : Mech.LOC_RARM;</b>
&nbsp;                // check previous attacks for weapons fire from the other arm
<b class="nc">&nbsp;                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</b>
&nbsp;                                                   otherArm)) {
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;Prone and firing from other arm already.&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;            // can&#39;t fire leg weapons
<b class="nc">&nbsp;            if ((weapon.getLocation() == Mech.LOC_LLEG)</b>
<b class="nc">&nbsp;                || (weapon.getLocation() == Mech.LOC_RLEG)) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                     &quot;Can&#39;t fire leg-mounted weapons while prone.&quot;);
&nbsp;            }
<b class="nc">&nbsp;            if (((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</b>
<b class="nc">&nbsp;                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;attacker prone&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                mods.addModifier(2, &quot;attacker prone&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (l3ProneFiringArm != Entity.LOC_NONE) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;attacker propping on single arm&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return mods;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if there is an attack previous to the one with this weapon
&nbsp;     * from the specified arm.
&nbsp;     *
&nbsp;     * @return true if there is a previous attack from this arm
&nbsp;     */
&nbsp;    private static boolean isFiringFromArmAlready(IGame game, int weaponId,
&nbsp;                                                  final Entity attacker, int armLoc) {
<b class="nc">&nbsp;        int torsoLoc = Mech.getInnerLocation(armLoc);</b>
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;            if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
&nbsp;            // stop when we get to this weaponattack (does this always work?)
<b class="nc">&nbsp;            if ((prevAttack.getEntityId() == attacker.getId())</b>
<b class="nc">&nbsp;                &amp;&amp; (prevAttack.getWeaponId() == weaponId)) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((prevAttack.getEntityId() == attacker.getId()) &amp;&amp; (attacker</b>
<b class="nc">&nbsp;                                                                            .getEquipment(prevAttack.getWeaponId())</b>
<b class="nc">&nbsp;                                                                            .getLocation() == armLoc))</b>
<b class="nc">&nbsp;                || ((prevAttack.getEntityId() == attacker.getId())</b>
<b class="nc">&nbsp;                    &amp;&amp; (attacker.getEquipment(prevAttack.getWeaponId())</b>
<b class="nc">&nbsp;                                .getLocation() == torsoLoc) &amp;&amp; attacker</b>
<b class="nc">&nbsp;                            .getEquipment(prevAttack.getWeaponId()).isSplit())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds any damage modifiers from arm critical hits or sensor damage.
&nbsp;     *
&nbsp;     * @return Any applicable damage modifiers
&nbsp;     */
&nbsp;    public static ToHitData getDamageWeaponMods(Entity attacker, Mounted weapon) {
<b class="fc">&nbsp;        ToHitData mods = new ToHitData();</b>
<b class="fc">&nbsp;        if (attacker instanceof Protomech) {</b>
&nbsp;            // Head criticals add to target number of all weapons.
<b class="nc">&nbsp;            int hits = ((Protomech) attacker).getCritsHit(Protomech.LOC_HEAD);</b>
<b class="nc">&nbsp;            if (hits &gt; 0) {</b>
<b class="nc">&nbsp;                mods.addModifier(hits, hits + &quot; head critical(s)&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Arm mounted (and main gun) weapons get DRMs from arm crits.
<b class="nc">&nbsp;            switch (weapon.getLocation()) {</b>
&nbsp;                case Protomech.LOC_LARM:
&nbsp;                case Protomech.LOC_RARM:
<b class="nc">&nbsp;                    hits = ((Protomech) attacker).getCritsHit(weapon</b>
<b class="nc">&nbsp;                                                                      .getLocation());</b>
<b class="nc">&nbsp;                    if (hits &gt; 0) {</b>
<b class="nc">&nbsp;                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Protomech.LOC_MAINGUN:
&nbsp;                    // Main gun is affected by crits in *both* arms.
<b class="nc">&nbsp;                    hits = ((Protomech) attacker)</b>
<b class="nc">&nbsp;                            .getCritsHit(Protomech.LOC_LARM);</b>
<b class="nc">&nbsp;                    hits += ((Protomech) attacker)</b>
<b class="nc">&nbsp;                            .getCritsHit(Protomech.LOC_RARM);</b>
<b class="nc">&nbsp;                    if (4 == hits) {</b>
<b class="nc">&nbsp;                        mods.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                         &quot;Cannot fire main gun with no arms.&quot;);
<b class="nc">&nbsp;                    } else if (hits &gt; 0) {</b>
<b class="nc">&nbsp;                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } // End attacker-is-Protomech</b>
&nbsp;
&nbsp;        // only mechs have arm actuators - for those, we check whether
&nbsp;        // there is arm actuator damage
<b class="fc">&nbsp;        else if(attacker instanceof Mech) {</b>
&nbsp;            // split weapons need to account for arm actuator hits, too
&nbsp;            // see bug 1363690
&nbsp;            // we don&#39;t need to specifically check for weapons split between
&nbsp;            // torso and leg, because for those, the location stored in the
&nbsp;            // Mounted is the leg.
<b class="fc">&nbsp;            int location = weapon.getLocation();</b>
<b class="fc">&nbsp;            if (weapon.isSplit()) {</b>
<b class="nc">&nbsp;                switch (location) {</b>
&nbsp;                    case Mech.LOC_LT:
<b class="nc">&nbsp;                        location = Mech.LOC_LARM;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case Mech.LOC_RT:
<b class="nc">&nbsp;                        location = Mech.LOC_RARM;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // only arms can have damaged arm actuators
<b class="fc">&nbsp;            if(location == Mech.LOC_LARM || location == Mech.LOC_RARM) {</b>
<b class="fc">&nbsp;                if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                             Mech.ACTUATOR_SHOULDER, location) &gt; 0) {
<b class="nc">&nbsp;                    mods.addModifier(4, &quot;shoulder actuator destroyed&quot;);</b>
&nbsp;                } else {
&nbsp;                    // no shoulder hits, add other arm hits
<b class="fc">&nbsp;                    int actuatorHits = 0;</b>
<b class="fc">&nbsp;                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                 Mech.ACTUATOR_UPPER_ARM, location) &gt; 0) {
<b class="nc">&nbsp;                        actuatorHits++;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                 Mech.ACTUATOR_LOWER_ARM, location) &gt; 0) {
<b class="nc">&nbsp;                        actuatorHits++;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (actuatorHits &gt; 0) {</b>
<b class="nc">&nbsp;                        mods.addModifier(actuatorHits, actuatorHits</b>
&nbsp;                                                       + &quot; destroyed arm actuators&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // sensors critical hit to attacker
<b class="fc">&nbsp;        int sensorHits = attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                  Mech.SYSTEM_SENSORS, Mech.LOC_HEAD);
<b class="fc">&nbsp;        if ((attacker instanceof Mech)</b>
<b class="fc">&nbsp;            &amp;&amp; (((Mech) attacker).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)) {</b>
<b class="nc">&nbsp;            sensorHits += attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                                   Mech.SYSTEM_SENSORS, Mech.LOC_CT);
<b class="nc">&nbsp;            if (sensorHits &gt; 1) {</b>
<b class="nc">&nbsp;                mods.addModifier(4, &quot;attacker sensors badly damaged&quot;);</b>
<b class="nc">&nbsp;            } else if (sensorHits &gt; 0) {</b>
<b class="nc">&nbsp;                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (sensorHits &gt; 0) {</b>
<b class="fc">&nbsp;            if (attacker instanceof Mech &amp;&amp; ((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</b>
<b class="nc">&nbsp;                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;attacker sensors damaged&quot;);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if partial sensor/stabilizer/fcs/cic repairs are present the shot will be more difficult
<b class="fc">&nbsp;        if (attacker.getPartialRepairs() != null) {</b>
<b class="nc">&nbsp;            if (attacker.getPartialRepairs().booleanOption(&quot;sensors_1_crit&quot;)) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;sensor damage&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (attacker.getPartialRepairs().booleanOption(&quot;mech_sensors_2_crit&quot;)) {</b>
<b class="nc">&nbsp;                mods.addModifier(2, &quot;sensor damage&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (attacker.getPartialRepairs().booleanOption(&quot;veh_stabilizer_crit&quot;)) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;stabilizer damage&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_replace&quot;)) {</b>
<b class="nc">&nbsp;                mods.addModifier(1, &quot;misreplaced cic/fcs equipment&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_crit&quot;)) {</b>
<b class="nc">&nbsp;                 mods.addModifier(1, &quot;faulty cic/fcs repairs&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return mods;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the current target is a secondary target, and if so,
&nbsp;     * returns the appropriate modifier.
&nbsp;     *
&nbsp;     * @return The secondary target modifier.
&nbsp;     * @author Ben
&nbsp;     */
&nbsp;    public static ToHitData getSecondaryTargetMod(IGame game, Entity attacker,
&nbsp;            Targetable target) {
&nbsp;
&nbsp;        // large craft do not get secondary target mod
&nbsp;        // http://www.classicbattletech.com/forums/index.php/topic,37661.0.html
<b class="nc">&nbsp;        if (attacker.getCrew().getCrewType().getMaxPrimaryTargets() &lt; 0) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean curInFrontArc = Compute</b>
<b class="nc">&nbsp;                .isInArc(attacker.getPosition(), attacker.getSecondaryFacing(),</b>
<b class="nc">&nbsp;                         target, attacker.getForwardArc());</b>
<b class="nc">&nbsp;        boolean curInRearArc = Compute.isInArc(attacker.getPosition(),</b>
<b class="nc">&nbsp;                                               attacker.getSecondaryFacing(), target, attacker.getRearArc());</b>
<b class="nc">&nbsp;        if (!curInRearArc &amp;&amp; attacker.hasQuirk(OptionsConstants.QUIRK_POS_MULTI_TRAC)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int primaryTarget = Entity.NONE;</b>
<b class="nc">&nbsp;        boolean primaryInFrontArc = false;</b>
&nbsp;        // Track # of targets, for secondary modifiers w/ multi-crew vehicles
<b class="nc">&nbsp;        Set&lt;Integer&gt; targIds = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            Object o = i.nextElement();</b>
<b class="nc">&nbsp;            if (!(o instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            WeaponAttackAction prevAttack = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;            if (prevAttack.getEntityId() == attacker.getId()) {</b>
&nbsp;                // Don&#39;t add id of current target, as it gets counted elsewhere
<b class="nc">&nbsp;                if (prevAttack.getTargetId() != target.getTargetId()) {</b>
<b class="nc">&nbsp;                    targIds.add(prevAttack.getTargetId());</b>
&nbsp;                }
&nbsp;                // first front arc target is our primary.
&nbsp;                // if first target is non-front, and either a later target or
&nbsp;                // the current one is in front, use that instead.
<b class="nc">&nbsp;                if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_FORCED_PRIMARY_TARGETS)) {</b>
<b class="nc">&nbsp;                    Targetable pte = game.getTarget(prevAttack.getTargetType(),</b>
<b class="nc">&nbsp;                                                    prevAttack.getTargetId());</b>
&nbsp;                    // in double blind play, we might not have the target in our
&nbsp;                    // local copy of the game. In that case, the sprite won&#39;t
&nbsp;                    // have the correct to-hit number, but at least we don&#39;t crash
<b class="nc">&nbsp;                    if (pte == null) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Determine primary target
<b class="nc">&nbsp;                    if ((primaryTarget == Entity.NONE || !primaryInFrontArc)</b>
<b class="nc">&nbsp;                        &amp;&amp; Compute.isInArc(attacker.getPosition(),</b>
<b class="nc">&nbsp;                                           attacker.getSecondaryFacing(), pte,</b>
<b class="nc">&nbsp;                                           attacker.getForwardArc())) {</b>
<b class="nc">&nbsp;                        primaryTarget = prevAttack.getTargetId();</b>
<b class="nc">&nbsp;                        primaryInFrontArc = true;</b>
<b class="nc">&nbsp;                    } else if ((primaryTarget == Entity.NONE) &amp;&amp; !curInFrontArc) {</b>
<b class="nc">&nbsp;                        primaryTarget = prevAttack.getTargetId();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (primaryTarget == Entity.NONE){</b>
<b class="nc">&nbsp;                    primaryTarget = prevAttack.getTargetId();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // # of targets, +1 for the passed target
<b class="nc">&nbsp;        int countTargets = 1 + targIds.size();</b>
&nbsp;
<b class="nc">&nbsp;        int maxPrimary = 1;</b>
&nbsp;        //Tripods and QuadVees with dedicated gunnery can target up to three units before incurring a penalty, and two for dual cockpit
<b class="nc">&nbsp;        if (attacker.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;            maxPrimary = attacker.getCrew().getCrewType().getMaxPrimaryTargets();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(&quot;tacops_tank_crews&quot;)</b>
&nbsp;            &amp;&amp; (attacker instanceof Tank)) {
&nbsp;
&nbsp;            // If we are a tank, and only have 1 crew then we have some special
&nbsp;            //  restrictions
<b class="nc">&nbsp;            if (countTargets &gt; 1 &amp;&amp; attacker.getCrew().getSize() == 1) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                        &quot;Vehicles with only 1 crewman may not attack &quot;
&nbsp;                                + &quot;secondary targets&quot;);
&nbsp;            }
&nbsp;            // If we are a tank, we can have Crew Size - 1 targets before
&nbsp;            //  incurring a secondary target penalty (or crew size - 2 secondary
&nbsp;            //  targets without penalty)
<b class="nc">&nbsp;            maxPrimary =  attacker.getCrew().getSize() - 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (countTargets &lt;= maxPrimary) {</b>
<b class="nc">&nbsp;            return null; // no modifier</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((primaryTarget == Entity.NONE)</b>
<b class="nc">&nbsp;            || (primaryTarget == target.getTargetId())) {</b>
&nbsp;            // current target is primary target
<b class="nc">&nbsp;            return null; // no modifier</b>
&nbsp;        }
&nbsp;
&nbsp;        // current target is secondary
&nbsp;
&nbsp;        // Stealthed Mechs can&#39;t be secondary targets (TW, pg. 142)
<b class="nc">&nbsp;        if (((target instanceof Tank) || (target instanceof Mech) || (target instanceof Aero))</b>
<b class="nc">&nbsp;            &amp;&amp; ((Entity) target).isStealthActive()) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                 &quot;Can&#39;t target unit with active stealth armor as &quot; +
&nbsp;                                 &quot;secondary target&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int mod = 2;</b>
<b class="nc">&nbsp;        if (curInFrontArc || (attacker instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (attacker.hasAbility(OptionsConstants.GUNNERY_MULTI_TASKER)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new ToHitData(mod, &quot;secondary target modifier&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Damage that a mech does with a accidental fall from above.
&nbsp;     */
&nbsp;
&nbsp;    public static int getAffaDamageFor(Entity entity) {
<b class="nc">&nbsp;        return (int) entity.getWeight() / 10;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to attacker movement
&nbsp;     */
&nbsp;    public static ToHitData getAttackerMovementModifier(IGame game, int entityId) {
<b class="nc">&nbsp;        return Compute.getAttackerMovementModifier(game, entityId,</b>
<b class="nc">&nbsp;                                                   game.getEntity(entityId).moved);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to attacker movement
&nbsp;     */
&nbsp;    public static ToHitData getAttackerMovementModifier(IGame game,
&nbsp;            int entityId, EntityMovementType movement) {
<b class="nc">&nbsp;        final Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
&nbsp;
&nbsp;        // infantry aren&#39;t affected by their own movement.
<b class="nc">&nbsp;        if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</b>
<b class="nc">&nbsp;            || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(3, &quot;attacker used UMUs&quot;);</b>
<b class="nc">&nbsp;        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_WALK) {</b>
<b class="nc">&nbsp;            toHit.addModifier(3, &quot;attacker cruised&quot;);</b>
<b class="nc">&nbsp;        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_RUN) {</b>
<b class="nc">&nbsp;            toHit.addModifier(4, &quot;attacker flanked&quot;);</b>
<b class="nc">&nbsp;        } else if ((movement == EntityMovementType.MOVE_WALK) || (movement == EntityMovementType.MOVE_VTOL_WALK)</b>
&nbsp;                || (movement == EntityMovementType.MOVE_CAREFUL_STAND)) {
<b class="nc">&nbsp;            toHit.addModifier(1, &quot;attacker walked&quot;);</b>
<b class="nc">&nbsp;        } else if ((movement == EntityMovementType.MOVE_RUN) || (movement == EntityMovementType.MOVE_VTOL_RUN)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, &quot;attacker ran&quot;);</b>
<b class="nc">&nbsp;        } else if (movement == EntityMovementType.MOVE_SKID) {</b>
<b class="nc">&nbsp;            toHit.addModifier(3, &quot;attacker ran and skidded&quot;);</b>
<b class="nc">&nbsp;        } else if (movement == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;            if (entity.hasAbility(OptionsConstants.PILOT_JUMPING_JACK)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;attacker jumped&quot;);</b>
<b class="nc">&nbsp;            } else if (entity.hasAbility(OptionsConstants.PILOT_HOPPING_JACK)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, &quot;attacker jumped&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(3, &quot;attacker jumped&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (movement == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_FAIL, &quot;attacker sprinted&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //Dual cockpit with both pilot and gunner has lower modifier for attacker movement.
<b class="nc">&nbsp;        if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL</b>
<b class="nc">&nbsp;                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_DUAL</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;            for (TargetRollModifier mod : toHit.getModifiers()) {</b>
<b class="nc">&nbsp;                mod.setValue(mod.getValue() / 2);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to spotter movement
&nbsp;     */
&nbsp;    public static ToHitData getSpotterMovementModifier(IGame game, int entityId) {
<b class="nc">&nbsp;        return Compute.getSpotterMovementModifier(game, entityId,</b>
<b class="nc">&nbsp;                                                  game.getEntity(entityId).moved);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to spotter movement
&nbsp;     */
&nbsp;    public static ToHitData getSpotterMovementModifier(IGame game,
&nbsp;                                                       int entityId, EntityMovementType movement) {
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
&nbsp;
<b class="nc">&nbsp;        Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        if ((e != null) &amp;&amp; (e instanceof Infantry)) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((movement == EntityMovementType.MOVE_WALK)</b>
&nbsp;            || (movement == EntityMovementType.MOVE_VTOL_WALK)) {
<b class="nc">&nbsp;            toHit.addModifier(1, &quot;spotter walked&quot;);</b>
<b class="nc">&nbsp;        } else if ((movement == EntityMovementType.MOVE_RUN)</b>
&nbsp;                   || (movement == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                   || (movement == EntityMovementType.MOVE_SKID)) {
<b class="nc">&nbsp;            toHit.addModifier(2, &quot;spotter ran&quot;);</b>
<b class="nc">&nbsp;        } else if (movement == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;            toHit.addModifier(3, &quot;spotter jumped&quot;);</b>
<b class="nc">&nbsp;        } else if (movement == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;spotter sprinted&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to physical attack BTH due to pilot advantages
&nbsp;     */
&nbsp;    public static void modifyPhysicalBTHForAdvantages(final Entity attacker, final Entity target,
&nbsp;                                                      final ToHitData toHit, final IGame game) {
<b class="nc">&nbsp;        Objects.requireNonNull(attacker);</b>
&nbsp;
<b class="nc">&nbsp;        if (attacker.hasAbility(OptionsConstants.PILOT_MELEE_SPECIALIST)</b>
&nbsp;                &amp;&amp; (attacker instanceof Mech)) {
<b class="nc">&nbsp;            toHit.addModifier(-1, &quot;melee specialist&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (attacker.hasAbility(OptionsConstants.PILOT_TM_FROGMAN)</b>
&nbsp;                &amp;&amp; ((attacker instanceof Mech) || (attacker instanceof Protomech))
<b class="nc">&nbsp;                &amp;&amp; (game.getBoard().getHex(attacker.getPosition()).terrainLevel(Terrains.WATER) &gt; 1)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, &quot;Frogman&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (attacker.hasAbility(OptionsConstants.UNOFF_CLAN_PILOT_TRAINING)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, &quot;clan pilot training&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Mek targets that are dodging are harder to hit.
<b class="nc">&nbsp;        if ((target instanceof Mech)</b>
<b class="nc">&nbsp;                &amp;&amp; target.hasAbility(OptionsConstants.PILOT_DODGE_MANEUVER) &amp;&amp; target.dodging) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, &quot;target is dodging&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to target movement
&nbsp;     */
&nbsp;    public static ToHitData getTargetMovementModifier(IGame game, int entityId) {
<b class="nc">&nbsp;        Entity entity = game.getEntity(entityId);</b>
&nbsp;
<b class="nc">&nbsp;        if (entity.isAero()) {</b>
<b class="nc">&nbsp;            return new ToHitData();</b>
&nbsp;        }
&nbsp;
&nbsp;        //If we&#39;re a trailer and being towed, return data for the tractor
<b class="nc">&nbsp;        if (entity.isTrailer() &amp;&amp; entity.getTractor() != Entity.NONE) {</b>
<b class="nc">&nbsp;            return getTargetMovementModifier(game, entity.getTractor());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_STANDING_STILL)</b>
&nbsp;            &amp;&amp; (entity.mpUsed == 0)
<b class="nc">&nbsp;            &amp;&amp; !entity.isImmobile()</b>
&nbsp;            &amp;&amp; !((entity instanceof Infantry) || (entity instanceof VTOL) || (entity instanceof GunEmplacement))) {
<b class="nc">&nbsp;            ToHitData toHit = new ToHitData();</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, &quot;target didn&#39;t move&quot;);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entity.isAssaultDropInProgress()) {</b>
<b class="nc">&nbsp;            ToHitData toHit = new ToHitData();</b>
<b class="nc">&nbsp;            toHit.addModifier(3, &quot;target is assault dropping&quot;);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ToHitData toHit = Compute</b>
<b class="nc">&nbsp;                .getTargetMovementModifier(</b>
&nbsp;                        entity.delta_distance,
<b class="nc">&nbsp;                        (entity.getMovementMode() != EntityMovementMode.WIGE)</b>
&nbsp;                        &amp;&amp; ((entity.moved == EntityMovementType.MOVE_JUMP)
&nbsp;                                || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                                || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
&nbsp;                                || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT)),
&nbsp;
&nbsp;                        (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
<b class="nc">&nbsp;                        || (entity.getMovementMode() == EntityMovementMode.VTOL)</b>
&nbsp;                        || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT),
&nbsp;                        game);
<b class="nc">&nbsp;        if (entity.moved != EntityMovementType.MOVE_JUMP</b>
&nbsp;                &amp;&amp; entity.delta_distance &gt; 0
<b class="nc">&nbsp;                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_DUAL</b>
<b class="nc">&nbsp;                &amp;&amp; entity.getCrew().hasDedicatedPilot()) {</b>
<b class="nc">&nbsp;            if (toHit.getModifiers().isEmpty()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target moved 1-2 hexes&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.getModifiers().get(0).setValue(toHit.getModifiers().get(0).getValue() + 1);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Did the target skid this turn?
<b class="nc">&nbsp;        if (entity.moved == EntityMovementType.MOVE_SKID) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, &quot;target skidded&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((entity.getElevation() &gt; 0)</b>
<b class="nc">&nbsp;            &amp;&amp; (entity.getMovementMode() == EntityMovementMode.WIGE)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target is airborne&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // did the target sprint?
<b class="nc">&nbsp;        if (entity.moved == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || entity.moved == EntityMovementType.MOVE_VTOL_SPRINT) {
<b class="nc">&nbsp;            toHit.addModifier(-1, &quot;target sprinted&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Target movement modifer for the specified delta_distance
&nbsp;     */
&nbsp;    public static ToHitData getTargetMovementModifier(int distance,
&nbsp;            boolean jumped, boolean isVTOL, IGame game) {
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
<b class="nc">&nbsp;        if (distance == 0 &amp;&amp; !jumped) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game != null)</b>
<b class="nc">&nbsp;            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_MAXTECH_MOVEMENT_MODS)) {</b>
<b class="nc">&nbsp;            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 13)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(4, &quot;target moved 10-13 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 14) &amp;&amp; (distance &lt;= 18)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 19) &amp;&amp; (distance &lt;= 24)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(6, &quot;target moved 18-24 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if (distance &gt;= 25) {</b>
<b class="nc">&nbsp;                toHit.addModifier(7, &quot;target moved 25+ hexes&quot;);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 17)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(4, &quot;target moved 10-17 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if ((distance &gt;= 18) &amp;&amp; (distance &lt;= 24)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</b>
<b class="nc">&nbsp;            } else if (distance &gt;= 25) {</b>
<b class="nc">&nbsp;                toHit.addModifier(6, &quot;target moved 25+ hexes&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (jumped) {</b>
<b class="nc">&nbsp;            if (isVTOL &amp;&amp; (distance &gt; 0)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target VTOL used MPs&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target jumped&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to attacker terrain
&nbsp;     */
&nbsp;    public static ToHitData getAttackerTerrainModifier(IGame game, int entityId) {
<b class="nc">&nbsp;        final Entity attacker = game.getEntity(entityId);</b>
<b class="nc">&nbsp;        final IHex hex = game.getBoard().getHex(attacker.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
&nbsp;
&nbsp;        // space screens; bonus depends on number (level)
<b class="nc">&nbsp;        if ((hex != null) &amp;&amp; (hex.terrainLevel(Terrains.SCREEN) &gt; 0)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</b>
&nbsp;                              &quot;attacker in screen(s)&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to attacks due to target terrain TODO:um....should VTOLs get
&nbsp;     * modifiers for smoke, etc.
&nbsp;     */
&nbsp;    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t) {
<b class="nc">&nbsp;        return Compute.getTargetTerrainModifier(game, t, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
&nbsp;                                                     int eistatus) {
<b class="nc">&nbsp;        return Compute.getTargetTerrainModifier(game, t, eistatus, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
&nbsp;                                                     int eistatus, boolean attackerInSameBuilding) {
<b class="nc">&nbsp;        return Compute.getTargetTerrainModifier(game, t, eistatus,</b>
&nbsp;                                                attackerInSameBuilding, false);
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
&nbsp;                                                     int eistatus, boolean attackerInSameBuilding,
&nbsp;                                                     boolean underwaterWeapon) {
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
&nbsp;
&nbsp;        // no terrain mods for bombs, artillery strikes
<b class="nc">&nbsp;        if (t.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB ||</b>
<b class="nc">&nbsp;                t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity entityTarget = null;</b>
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(t.getPosition());</b>
<b class="nc">&nbsp;        if (t.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            entityTarget = (Entity) t;</b>
<b class="nc">&nbsp;            if (hex == null) {</b>
<b class="nc">&nbsp;                entityTarget.setPosition(game.getEntity(entityTarget.getId())</b>
<b class="nc">&nbsp;                                             .getPosition());</b>
<b class="nc">&nbsp;                hex = game.getBoard().getHex(</b>
<b class="nc">&nbsp;                        game.getEntity(entityTarget.getId()).getPosition());</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // if the hex doesn&#39;t exist, it&#39;s unlikely to have terrain modifiers
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        boolean hasWoods = hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE);</b>
&nbsp;        // Standard mechs (standing) report their height as 1, tanks as 0
&nbsp;        // Standard mechs should not benefit from 1 level high woods
&nbsp;        
<b class="nc">&nbsp;        boolean isAboveWoods = (entityTarget == null) </b>
<b class="nc">&nbsp;                || (entityTarget.relHeight() + 1 &gt; hex.terrainLevel(Terrains.FOLIAGE_ELEV)) </b>
<b class="nc">&nbsp;                || entityTarget.isAirborne() </b>
&nbsp;                || !hasWoods;
<b class="nc">&nbsp;        boolean isAboveSmoke = (entityTarget == null)</b>
<b class="nc">&nbsp;                || (entityTarget.relHeight() + 1 &gt; 2) </b>
<b class="nc">&nbsp;                || !hex.containsTerrain(Terrains.SMOKE);</b>
<b class="nc">&nbsp;        boolean isUnderwater = (entityTarget != null)</b>
<b class="nc">&nbsp;                               &amp;&amp; hex.containsTerrain(Terrains.WATER) &amp;&amp; (hex.depth() &gt; 0)</b>
<b class="nc">&nbsp;                               &amp;&amp; (entityTarget.getElevation() &lt; hex.surface());</b>
&nbsp;
&nbsp;        // if we have in-building combat, it&#39;s a +1
<b class="nc">&nbsp;        if (attackerInSameBuilding) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, &quot;target in a building hex&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Smoke and woods. With L3, the effects STACK.
<b class="nc">&nbsp;        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</b>
<b class="nc">&nbsp;        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;        String woodsText = &quot;woods&quot;;</b>
<b class="nc">&nbsp;        if (woodsLevel &lt; jungleLevel) {</b>
<b class="nc">&nbsp;            woodsLevel = jungleLevel;</b>
<b class="nc">&nbsp;            woodsText = &quot;jungle&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (woodsLevel == 1) {</b>
<b class="nc">&nbsp;            woodsText = &quot;target in light &quot; + woodsText;</b>
<b class="nc">&nbsp;        } else if (woodsLevel == 2) {</b>
<b class="nc">&nbsp;            woodsText = &quot;target in heavy &quot; + woodsText;</b>
<b class="nc">&nbsp;        } else if (woodsLevel == 3) {</b>
<b class="nc">&nbsp;            woodsText = &quot;target in ultra heavy &quot; + woodsText;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)</b>
&nbsp;            &amp;&amp; !isAboveWoods
<b class="nc">&nbsp;            &amp;&amp; !((t.getTargetType() == Targetable.TYPE_HEX_CLEAR)</b>
<b class="nc">&nbsp;                 || (t.getTargetType() == Targetable.TYPE_HEX_IGNITE)</b>
<b class="nc">&nbsp;                 || (t.getTargetType() == Targetable.TYPE_HEX_BOMB)</b>
<b class="nc">&nbsp;                 || (t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)</b>
<b class="nc">&nbsp;                 || (t.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER))) {</b>
<b class="nc">&nbsp;            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, woodsText);</b>
<b class="nc">&nbsp;            } else if (woodsLevel &gt; 1) {</b>
<b class="nc">&nbsp;                if (eistatus &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(woodsLevel - 1, woodsText);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(woodsLevel, woodsText);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!isAboveSmoke &amp;&amp; !isUnderwater &amp;&amp; !underwaterWeapon) {</b>
<b class="nc">&nbsp;            if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</b>
<b class="nc">&nbsp;                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</b>
<b class="nc">&nbsp;                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</b>
<b class="nc">&nbsp;                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target in light smoke&quot;);</b>
<b class="nc">&nbsp;            } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</b>
<b class="nc">&nbsp;                if (eistatus &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(1, &quot;target in heavy smoke&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(2, &quot;target in heavy smoke&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</b>
<b class="nc">&nbsp;            if (eistatus &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;target in erupting geyser&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(2, &quot;target in erupting geyser&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.INDUSTRIAL)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, &quot;target in heavy industrial zone&quot;);</b>
&nbsp;        }
&nbsp;        // space screens; bonus depends on number (level)
<b class="nc">&nbsp;        if (hex.terrainLevel(Terrains.SCREEN) &gt; 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</b>
&nbsp;                              &quot;target in screen(s)&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // only entities get remaining terrain bonuses
&nbsp;        // TODO: should this be changed for buildings???
<b class="nc">&nbsp;        if (entityTarget == null) {</b>
<b class="nc">&nbsp;            return toHit;</b>
<b class="nc">&nbsp;        } else if (entityTarget.isMakingDfa()) {</b>
&nbsp;            // you don&#39;t get terrain modifiers in midair
&nbsp;            // should be abstracted more into a &#39;not on the ground&#39;
&nbsp;            // flag for vtols and such
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entityTarget.isStuck()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-2, &quot;target stuck in swamp&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((entityTarget instanceof Infantry)</b>
<b class="nc">&nbsp;            &amp;&amp; hex.containsTerrain(Terrains.FIELDS)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, &quot;target in planted fields&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData getStrafingTerrainModifier(IGame game,
&nbsp;                                                       int eistatus, IHex hex) {
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
&nbsp;        // Smoke and woods. With L3, the effects STACK.
<b class="nc">&nbsp;        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</b>
<b class="nc">&nbsp;        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;        String woodsText = &quot;woods&quot;;</b>
<b class="nc">&nbsp;        if (woodsLevel &lt; jungleLevel) {</b>
<b class="nc">&nbsp;            woodsLevel = jungleLevel;</b>
<b class="nc">&nbsp;            woodsText = &quot;jungle&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (woodsLevel == 1) {</b>
<b class="nc">&nbsp;            woodsText = &quot;light &quot; + woodsText;</b>
<b class="nc">&nbsp;        } else if (woodsLevel == 2) {</b>
<b class="nc">&nbsp;            woodsText = &quot;heavy &quot; + woodsText;</b>
<b class="nc">&nbsp;        } else if (woodsLevel == 3) {</b>
<b class="nc">&nbsp;            woodsText = &quot;heavy &quot; + woodsText;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)) {</b>
<b class="nc">&nbsp;            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, woodsText);</b>
<b class="nc">&nbsp;            } else if (woodsLevel &gt; 1) {</b>
<b class="nc">&nbsp;                if (eistatus &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(woodsLevel - 1, woodsText);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(woodsLevel, woodsText);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</b>
<b class="nc">&nbsp;            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</b>
<b class="nc">&nbsp;            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</b>
<b class="nc">&nbsp;            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, &quot;light smoke&quot;);</b>
<b class="nc">&nbsp;        } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</b>
<b class="nc">&nbsp;            if (eistatus &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;heavy smoke&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(2, &quot;heavy smoke&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</b>
<b class="nc">&nbsp;            if (eistatus &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, &quot;erupting geyser&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(2, &quot;erupting geyser&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the current theoretical damage absorbable(armor+structure, etc) by the given target.
&nbsp;     * Used as a measure of the potential durability of the target under fire.
&nbsp;     */
&nbsp;    public static int getTargetTotalHP(IGame game, Targetable target) {
<b class="nc">&nbsp;        int targetType = target.getTargetType();</b>
<b class="nc">&nbsp;        int targetId = target.getTargetId();</b>
<b class="nc">&nbsp;        Coords position = target.getPosition();</b>
&nbsp;
&nbsp;        //First, handle buildings versus entities, since they are handled differently.
<b class="nc">&nbsp;        if(targetType == Targetable.TYPE_BUILDING) {</b>
&nbsp;            //Buildings are a simple sum of their current CF and armor values.
<b class="nc">&nbsp;            Building parentBuilding = game.getBoard().getBuildingAt(position); //the building the targeted hex belongs to. We have to get this and then get values for the specific hex internally to it.</b>
<b class="nc">&nbsp;            int targetCF = parentBuilding.getCurrentCF(position);</b>
<b class="nc">&nbsp;            int targetArmor = parentBuilding.getArmor(position);</b>
<b class="nc">&nbsp;            return targetCF + targetArmor;</b>
<b class="nc">&nbsp;        } else if (targetType == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //I don&#39;t *think* we have to handle infantry differently here- I think these methods should return the total number of men remaining as internal structure.
<b class="nc">&nbsp;            Entity targetEntity = game.getEntity(targetId);</b>
&nbsp;
<b class="nc">&nbsp;            if (targetEntity instanceof GunEmplacement) { //If this is a gun emplacement, handle it as the building hex it is in.</b>
<b class="nc">&nbsp;                Building parentBuilding = game.getBoard().getBuildingAt(position);</b>
<b class="nc">&nbsp;                int targetCF = parentBuilding.getCurrentCF(position);</b>
<b class="nc">&nbsp;                int targetArmor = parentBuilding.getArmor(position);</b>
<b class="nc">&nbsp;                return targetCF + targetArmor;</b>
&nbsp;            }
<b class="nc">&nbsp;            int targetArmor = targetEntity.getTotalArmor();</b>
<b class="nc">&nbsp;            int targetStructure = targetEntity.getTotalInternal();</b>
<b class="nc">&nbsp;            return targetArmor + targetStructure;</b>
<b class="nc">&nbsp;        } else if (targetType == Targetable.TYPE_HEX_CLEAR) {</b>
&nbsp;            // clearing a hex - the &quot;HP&quot; is the terrain factor of destroyable terrain on this hex
<b class="nc">&nbsp;            IHex mhex = game.getBoard().getHex(position);</b>
<b class="nc">&nbsp;            int terrainTypes[] = mhex.getTerrainTypes();</b>
<b class="nc">&nbsp;            int totalTF = 0;</b>
&nbsp;            
<b class="nc">&nbsp;            for (int i = 0; i &lt; terrainTypes.length; i++) {</b>
<b class="nc">&nbsp;                int tf = 0;</b>
<b class="nc">&nbsp;                int terType = terrainTypes[i];</b>
<b class="nc">&nbsp;                if (mhex.containsTerrain(terType)) {</b>
<b class="nc">&nbsp;                    tf = mhex.getTerrain(terType).getTerrainFactor();</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                totalTF += tf;</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            return totalTF;</b>
&nbsp;        } else { //something else, e.g. terrain. We probably don&#39;t need to handle it for now.
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the weapon attack out of a list that has the highest expected
&nbsp;     * damage
&nbsp;     */
&nbsp;    public static WeaponAttackAction getHighestExpectedDamage(IGame g,
&nbsp;            List&lt;WeaponAttackAction&gt; vAttacks, boolean assumeHit) {
<b class="nc">&nbsp;        float fHighest = -1.0f;</b>
<b class="nc">&nbsp;        WeaponAttackAction waaHighest = null;</b>
<b class="nc">&nbsp;        for (int x = 0, n = vAttacks.size(); x &lt; n; x++) {</b>
<b class="nc">&nbsp;            WeaponAttackAction waa = vAttacks.get(x);</b>
<b class="nc">&nbsp;            float fDanger = Compute.getExpectedDamage(g, waa, assumeHit);</b>
<b class="nc">&nbsp;            if (fDanger &gt; fHighest) {</b>
<b class="nc">&nbsp;                fHighest = fDanger;</b>
<b class="nc">&nbsp;                waaHighest = waa;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return waaHighest;</b>
&nbsp;    }
&nbsp;
&nbsp;    // store these as constants since the tables will never change
<b class="fc">&nbsp;    private static float[] expectedHitsByRackSize = { 0.0f, 1.0f, 1.58f, 2.0f,</b>
&nbsp;            2.63f, 3.17f, 4.0f, 4.49f, 4.98f, 5.47f, 6.31f, 7.23f, 8.14f,
&nbsp;            8.59f, 9.04f, 9.5f, 10.1f, 10.8f, 11.42f, 12.1f, 12.7f };
&nbsp;
&nbsp;    /*
&nbsp;     * | No Modifier | +2 (Artemis, Narc) | -2 (HAG, AMS v Art)| -4 (AMS) | |
&nbsp;     * Avg | Avg | Avg | Avg | | Hits Pct | Hits Pct | Hits Pct | Hits Pct | |
&nbsp;     * Avg Per vs | Avg Per vs | Avg Per vs | Avg Per vs | Size| Hits Size Avg |
&nbsp;     * Hits Size Avg | Hits Size Avg | Hits Size Avg |
&nbsp;     * ----+--------------------+
&nbsp;     * --------------------+--------------------+--------------------+ 2 | 1.42
&nbsp;     * 0.708 9.1 | 1.72 0.861 10.3 | 1.17 0.583 10.7 | 1.03 0.514 21.9 | 3 |
&nbsp;     * 2.00 0.667 2.7 | 2.39 0.796 2.0 | 1.61 0.537 2.0 | 1.28 0.426 1.0 | 4 |
&nbsp;     * 2.64 0.660 1.6 | 3.11 0.778 -0.4 | 2.11 0.528 0.2 | 1.67 0.417 -1.2 | 5 |
&nbsp;     * 3.17 0.633 -2.5 | 3.83 0.767 -1.8 | 2.50 0.500 -5.1 | 1.86 0.372 -11.7 |
&nbsp;     * 6 | 4.00 0.667 2.7 | 4.78 0.796 2.0 | 3.22 0.537 2.0 | 2.58 0.431 2.1 | 7
&nbsp;     * | 4.39 0.627 -3.4 | 5.42 0.774 -0.9 | 3.47 0.496 -5.8 | 2.69 0.385 -8.7 |
&nbsp;     * 8 | 5.08 0.635 -2.1 | 6.06 0.757 -3.0 | 4.22 0.528 0.2 | 3.58 0.448 6.2 |
&nbsp;     * 9 | 5.47 0.608 -6.4 | 6.69 0.744 -4.7 | 4.47 0.497 -5.7 | 3.69 0.410 -2.7
&nbsp;     * | 10 | 6.31 0.631 -2.9 | 7.67 0.767 -1.8 | 5.06 0.506 -4.0 | 3.97 0.397
&nbsp;     * -5.8 | 11 | 7.31 0.664 2.3 | 8.67 0.788 0.9 | 6.06 0.551 4.5 | 4.97 0.452
&nbsp;     * 7.2 | 12 | 8.14 0.678 4.5 | 9.64 0.803 2.9 | 6.64 0.553 5.0 | 5.25 0.438
&nbsp;     * 3.7 | 13 | 8.42 0.647 -0.3 | 10.22 0.786 0.7 | 6.72 0.517 -1.8 | 5.25
&nbsp;     * 0.404 -4.2 | 14 | 9.22 0.659 1.5 | 10.92 0.780 -0.1 | 7.64 0.546 3.6 |
&nbsp;     * 6.25 0.446 5.9 | 15 | 9.50 0.633 -2.5 | 11.50 0.767 -1.8 | 7.72 0.515
&nbsp;     * -2.3 | 6.25 0.417 -1.2 | 16 | 10.42 0.651 0.3 | 12.50 0.781 0.1 | 8.44
&nbsp;     * 0.528 0.2 | 6.67 0.417 -1.2 | 17 | 10.69 0.629 -3.1 | 13.08 0.770 -1.4 |
&nbsp;     * 8.53 0.502 -4.8 | 6.67 0.392 -7.0 | 18 | 11.50 0.639 -1.6 | 13.78 0.765
&nbsp;     * -1.9 | 9.44 0.525 -0.4 | 7.67 0.426 1.0 | 19 | 11.78 0.620 -4.5 | 14.36
&nbsp;     * 0.756 -3.2 | 9.53 0.501 -4.8 | 7.67 0.404 -4.3 | 20 | 12.69 0.635 -2.2 |
&nbsp;     * 15.36 0.768 -1.6 | 10.25 0.512 -2.7 | 8.08 0.404 -4.2 | 21 | 13.61 0.648
&nbsp;     * -0.2 | 16.33 0.778 -0.4 | 11.11 0.529 0.4 | 8.94 0.426 1.0 | 22 | 14.44
&nbsp;     * 0.657 1.1 | 17.31 0.787 0.8 | 11.69 0.532 0.9 | 9.22 0.419 -0.6 | 23 |
&nbsp;     * 15.36 0.668 2.9 | 18.31 0.796 2.0 | 12.42 0.540 2.5 | 9.64 0.419 -0.6 |
&nbsp;     * 24 | 16.28 0.678 4.5 | 19.28 0.803 2.9 | 13.28 0.553 5.0 | 10.50 0.438
&nbsp;     * 3.7 | 25 | 16.56 0.662 2.0 | 19.86 0.794 1.8 | 13.36 0.534 1.5 | 10.50
&nbsp;     * 0.420 -0.4 | 26 | 17.36 0.668 2.8 | 20.56 0.791 1.3 | 14.28 0.549 4.2 |
&nbsp;     * 11.50 0.442 4.9 | 27 | 17.64 0.653 0.6 | 21.14 0.783 0.3 | 14.36 0.532
&nbsp;     * 1.0 | 11.50 0.426 1.0 | 28 | 17.92 0.640 -1.4 | 21.72 0.776 -0.6 | 14.44
&nbsp;     * 0.516 -2.1 | 11.50 0.411 -2.6 | 29 | 18.72 0.646 -0.6 | 22.42 0.773 -1.0
&nbsp;     * | 15.36 0.530 0.6 | 12.50 0.431 2.2 | 30 | 19.00 0.633 -2.5 | 23.00 0.767
&nbsp;     * -1.8 | 15.44 0.515 -2.3 | 12.50 0.417 -1.2 | 40 | 25.39 0.635 -2.2 |
&nbsp;     * 30.72 0.768 -1.6 | 20.50 0.512 -2.7 | 16.17 0.404 -4.2 | ----- -----
&nbsp;     * ----- ----- Average: 0.649 0.781 0.527 0.422 1.202 0.811 0.649
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the expected damage of a weapon attack, based on to-hit, salvo
&nbsp;     * sizes, etc.
&nbsp;     */
&nbsp;    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
&nbsp;            boolean assumeHit) {
<b class="nc">&nbsp;        return Compute.getExpectedDamage(g, waa, assumeHit, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the expected damage of a weapon attack, based on to-hit, salvo
&nbsp;     * sizes, etc.
&nbsp;     */
&nbsp;    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
&nbsp;            boolean assumeHit, List&lt;ECMInfo&gt; allECMInfo) {
<b class="nc">&nbsp;        boolean use_table = false;</b>
&nbsp;
<b class="nc">&nbsp;        AmmoType loaded_ammo = new AmmoType();</b>
&nbsp;
<b class="nc">&nbsp;        Entity attacker = g.getEntity(waa.getEntityId());</b>
<b class="nc">&nbsp;        Entity target = g.getEntity(waa.getTargetId());</b>
&nbsp;        
<b class="nc">&nbsp;        int baShootingStrength = attacker instanceof BattleArmor ? </b>
<b class="nc">&nbsp;                ((BattleArmor) attacker).getShootingStrength() : 0;</b>
&nbsp;        
<b class="nc">&nbsp;        int infShootingStrength = 0;</b>
<b class="nc">&nbsp;        double infDamagePerTrooper = 0;</b>
&nbsp;                
<b class="nc">&nbsp;        Mounted weapon = attacker.getEquipment(waa.getWeaponId());</b>
&nbsp;        Mounted lnk_guide;
&nbsp;
<b class="nc">&nbsp;        ToHitData hitData = waa.toHit(g, allECMInfo);</b>
&nbsp;
<b class="nc">&nbsp;        if (attacker.isConventionalInfantry()) {</b>
<b class="nc">&nbsp;            infShootingStrength = ((Infantry) attacker).getShootingStrength();</b>
<b class="nc">&nbsp;            infDamagePerTrooper = ((Infantry) attacker).getDamagePerTrooper();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        WeaponType wt = (WeaponType) weapon.getType();</b>
&nbsp;
<b class="nc">&nbsp;        float fDamage = 0.0f;</b>
<b class="nc">&nbsp;        float fChance = 0.0f;</b>
<b class="nc">&nbsp;        if (assumeHit) {</b>
<b class="nc">&nbsp;            fChance = 1.0f;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if ((hitData.getValue() == TargetRoll.IMPOSSIBLE)</b>
<b class="nc">&nbsp;                || (hitData.getValue() == TargetRoll.AUTOMATIC_FAIL)) {</b>
<b class="nc">&nbsp;                return 0.0f;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (hitData.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;                fChance = 1.0f;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                fChance = (float) Compute.oddsAbove(hitData.getValue(),</b>
<b class="nc">&nbsp;                                                    attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))</b>
&nbsp;                          / 100.0f;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Missiles, HAGs, LBX cluster rounds, and ultra/rotary cannons (when
&nbsp;        // spun up)
&nbsp;        // use the missile hits table
<b class="nc">&nbsp;        if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="nc">&nbsp;            use_table = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Unless it&#39;s a fighter squadron, which uses a weird group of single weapons and should return mass AV
<b class="nc">&nbsp;        if (attacker.isCapitalFighter()) {</b>
<b class="nc">&nbsp;            use_table = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((wt.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;            || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
<b class="nc">&nbsp;            || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)) {</b>
<b class="nc">&nbsp;            loaded_ammo = (AmmoType) weapon.getLinked().getType();</b>
<b class="nc">&nbsp;            if (((loaded_ammo.getAmmoType() == AmmoType.T_AC_LBX) || (loaded_ammo</b>
<b class="nc">&nbsp;                                                                              .getAmmoType() == AmmoType.T_AC_LBX_THB))</b>
<b class="nc">&nbsp;                &amp;&amp; (loaded_ammo.getMunitionType() == AmmoType.M_CLUSTER)) {</b>
<b class="nc">&nbsp;                use_table = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;            || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;            || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</b>
<b class="nc">&nbsp;            if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</b>
<b class="nc">&nbsp;                || (weapon.curMode().getName().equals(&quot;2-shot&quot;))</b>
<b class="nc">&nbsp;                || (weapon.curMode().getName().equals(&quot;3-shot&quot;))</b>
<b class="nc">&nbsp;                || (weapon.curMode().getName().equals(&quot;4-shot&quot;))</b>
<b class="nc">&nbsp;                || (weapon.curMode().getName().equals(&quot;5-shot&quot;))</b>
<b class="nc">&nbsp;                || (weapon.curMode().getName().equals(&quot;6-shot&quot;))) {</b>
<b class="nc">&nbsp;                use_table = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Kinda cheap, but lets use the missile hits table for Battle armor
&nbsp;        // weapons too
&nbsp;
<b class="nc">&nbsp;        if (attacker instanceof BattleArmor) {</b>
<b class="nc">&nbsp;            if ((wt.getInternalName() != Infantry.SWARM_MEK)</b>
<b class="nc">&nbsp;                &amp;&amp; (wt.getInternalName() != Infantry.LEG_ATTACK)) {</b>
<b class="nc">&nbsp;                use_table = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (use_table == true) {</b>
<b class="nc">&nbsp;            if (!(attacker instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                if (weapon.getLinked() == null) {</b>
<b class="nc">&nbsp;                    return 0.0f;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            AmmoType at = null;</b>
<b class="nc">&nbsp;            if ((weapon.getLinked() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</b>
<b class="nc">&nbsp;                at = (AmmoType) weapon.getLinked().getType();</b>
<b class="nc">&nbsp;                fDamage = at.getDamagePerShot();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            float fHits = 0.0f;</b>
<b class="nc">&nbsp;            if ((wt.getRackSize() != 40) &amp;&amp; (wt.getRackSize() != 30)) {</b>
<b class="nc">&nbsp;                fHits = expectedHitsByRackSize[wt.getRackSize()];</b>
&nbsp;            } else {
<b class="nc">&nbsp;                fHits = 2.0f * expectedHitsByRackSize[wt.getRackSize() / 2];</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((wt.getAmmoType() == AmmoType.T_SRM_STREAK)</b>
<b class="nc">&nbsp;                    || (wt.getAmmoType() == AmmoType.T_MRM_STREAK) || (wt</b>
<b class="nc">&nbsp;                    .getAmmoType() == AmmoType.T_LRM_STREAK))</b>
<b class="nc">&nbsp;                    &amp;&amp; !ComputeECM.isAffectedByAngelECM(attacker, attacker</b>
<b class="nc">&nbsp;                            .getPosition(), waa.getTarget(g).getPosition(),</b>
&nbsp;                            allECMInfo)) {
<b class="nc">&nbsp;                fHits = wt.getRackSize();</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</b>
<b class="nc">&nbsp;                if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</b>
<b class="nc">&nbsp;                    || (weapon.curMode().getName().equals(&quot;2-shot&quot;))) {</b>
<b class="nc">&nbsp;                    fHits = expectedHitsByRackSize[2];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.curMode().getName().equals(&quot;3-shot&quot;)) {</b>
<b class="nc">&nbsp;                    fHits = expectedHitsByRackSize[3];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.curMode().getName().equals(&quot;4-shot&quot;)) {</b>
<b class="nc">&nbsp;                    fHits = expectedHitsByRackSize[4];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.curMode().getName().equals(&quot;5-shot&quot;)) {</b>
<b class="nc">&nbsp;                    fHits = expectedHitsByRackSize[5];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.curMode().getName().equals(&quot;6-shot&quot;)) {</b>
<b class="nc">&nbsp;                    fHits = expectedHitsByRackSize[6];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Most Battle Armor units have a weapon per trooper, plus their
&nbsp;            // weapons do odd things when mounting multiples
<b class="nc">&nbsp;            if (attacker instanceof BattleArmor) {</b>
&nbsp;                // The number of troopers hitting
<b class="nc">&nbsp;                fHits = expectedHitsByRackSize[baShootingStrength];</b>
<b class="nc">&nbsp;                if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="nc">&nbsp;                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (wt.getDamage() != WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="nc">&nbsp;                    if (wt.getDamage() != WeaponType.DAMAGE_VARIABLE) {</b>
<b class="nc">&nbsp;                        fDamage = wt.getDamage();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        fDamage = wt.getRackSize();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (wt.hasFlag(WeaponType.F_MISSILE_HITS)) {</b>
<b class="nc">&nbsp;                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // If there is no ECM coverage to the target, guidance systems are
&nbsp;            // good for another 1.20x damage on missile weapons
<b class="nc">&nbsp;            if ((!ComputeECM.isAffectedByECM(attacker, attacker.getPosition(), g</b>
<b class="nc">&nbsp;                    .getEntity(waa.getTargetId()).getPosition(), allECMInfo))</b>
<b class="nc">&nbsp;                &amp;&amp; (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</b>
<b class="nc">&nbsp;                &amp;&amp; (wt.hasFlag(WeaponType.F_MISSILE))) {</b>
&nbsp;                // Check for linked artemis guidance system
<b class="nc">&nbsp;                if ((wt.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                        || (wt.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                        || (wt.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                        || (wt.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                        || (wt.getAmmoType() == AmmoType.T_SRM_IMP)) {</b>
<b class="nc">&nbsp;                    lnk_guide = weapon.getLinkedBy();</b>
<b class="nc">&nbsp;                    if ((lnk_guide != null) &amp;&amp; (lnk_guide.getType() instanceof MiscType) &amp;&amp; !lnk_guide.isDestroyed()</b>
<b class="nc">&nbsp;                            &amp;&amp; !lnk_guide.isMissing() &amp;&amp; !lnk_guide.isBreached()</b>
<b class="nc">&nbsp;                            &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_ARTEMIS)) {</b>
&nbsp;
&nbsp;                        // Don&#39;t use artemis if this is indirect fire
&nbsp;                        // -&gt; Hook for Artemis V Level 3 Clan tech here; use
&nbsp;                        // 1.30f multiplier when implemented
<b class="nc">&nbsp;                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</b>
<b class="nc">&nbsp;                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE)) {</b>
<b class="nc">&nbsp;                            fHits *= 1.2f;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</b>
<b class="nc">&nbsp;                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_V_CAPABLE)) {</b>
<b class="nc">&nbsp;                            fHits *= 1.3f;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Check for ATMs, which have built in Artemis
<b class="nc">&nbsp;                if (wt.getAmmoType() == AmmoType.T_ATM) {</b>
<b class="nc">&nbsp;                    fHits *= 1.2f;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Check for target with attached Narc or iNarc homing pod from
&nbsp;                // friendly unit
<b class="nc">&nbsp;                if (target.isNarcedBy(attacker.getOwner().getTeam())</b>
<b class="nc">&nbsp;                        || target.isINarcedBy(attacker.getOwner().getTeam())) {</b>
<b class="nc">&nbsp;                    if (((at.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                            || (at.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                            || (at.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                            || (at.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                            || (at.getAmmoType() == AmmoType.T_SRM_IMP))</b>
<b class="nc">&nbsp;                            &amp;&amp; (at.getMunitionType() == AmmoType.M_NARC_CAPABLE)) {</b>
<b class="nc">&nbsp;                        fHits *= 1.2f;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (wt.getAmmoType() == AmmoType.T_MRM) {</b>
<b class="nc">&nbsp;                lnk_guide = weapon.getLinkedBy();</b>
<b class="nc">&nbsp;                if ((lnk_guide != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (lnk_guide.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                    &amp;&amp; !lnk_guide.isDestroyed() &amp;&amp; !lnk_guide.isMissing()</b>
<b class="nc">&nbsp;                    &amp;&amp; !lnk_guide.isBreached()</b>
<b class="nc">&nbsp;                    &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_APOLLO)) {</b>
<b class="nc">&nbsp;                    fHits *= .9f;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // adjust for previous AMS
<b class="nc">&nbsp;            if ((wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</b>
<b class="nc">&nbsp;                &amp;&amp; wt.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Mounted&gt; vCounters = waa.getCounterEquipment();</b>
<b class="nc">&nbsp;                if (vCounters != null) {</b>
<b class="nc">&nbsp;                    for (int x = 0; x &lt; vCounters.size(); x++) {</b>
<b class="nc">&nbsp;                        EquipmentType type = vCounters.get(x).getType();</b>
<b class="nc">&nbsp;                        if ((type instanceof WeaponType)</b>
<b class="nc">&nbsp;                            &amp;&amp; type.hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;                            fHits *= 0.6;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // * HAGs modify their cluster hits for range.
<b class="nc">&nbsp;            if (wt instanceof HAGWeapon) {</b>
<b class="nc">&nbsp;                int distance = attacker.getPosition().distance(</b>
<b class="nc">&nbsp;                        target.getPosition());</b>
<b class="nc">&nbsp;                if (distance &lt;= wt.getShortRange()) {</b>
<b class="nc">&nbsp;                    fHits *= 1.2;</b>
<b class="nc">&nbsp;                } else if (distance &gt; wt.getMediumRange()) {</b>
<b class="nc">&nbsp;                    fHits *= 0.8;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            fDamage *= fHits;</b>
&nbsp;
<b class="nc">&nbsp;            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</b>
<b class="nc">&nbsp;                fDamage = fHits * wt.getDamage();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Direct fire weapons (and LBX slug rounds) just do a single shot
&nbsp;            // so they don&#39;t use the missile hits table. Weapon bays also deal
&nbsp;            // damage in a single block
<b class="nc">&nbsp;            if ((attacker.getPosition() != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (target.getPosition() != null)) {</b>
&nbsp;                // Damage may vary by range for some weapons, so let&#39;s see how far
&nbsp;                // away we actually are and then set the damage accordingly.
<b class="nc">&nbsp;                int rangeToTarget = attacker.getPosition().distance(target.getPosition());</b>
&nbsp;                
&nbsp;                //Convert AV to fDamage for bay weapons, fighters, etc
<b class="nc">&nbsp;                if (attacker.usesWeaponBays()){</b>
<b class="nc">&nbsp;                    double av = 0;</b>
<b class="nc">&nbsp;                    double threat = 1;</b>
<b class="nc">&nbsp;                    for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                        Mounted bayW = attacker.getEquipment(wId);</b>
<b class="nc">&nbsp;                        WeaponType bayWType = ((WeaponType) bayW.getType());</b>
&nbsp;                        //Capital weapons have a different range scale
<b class="nc">&nbsp;                        if (wt.isCapital()) {</b>
&nbsp;                            // Capital missiles get higher priority than standard missiles:
&nbsp;                            // damage plus a bonus for the critical hit threat they represent
<b class="nc">&nbsp;                            threat = 12;</b>
<b class="nc">&nbsp;                            if (rangeToTarget &gt; 50) {</b>
<b class="nc">&nbsp;                                av = 0;</b>
<b class="nc">&nbsp;                            } else if (rangeToTarget &gt; 40) {</b>
<b class="nc">&nbsp;                                av += bayWType.getExtAV();</b>
<b class="nc">&nbsp;                            } else if (rangeToTarget &gt; 25) {</b>
<b class="nc">&nbsp;                                av += bayWType.getLongAV();</b>
<b class="nc">&nbsp;                            } else if (rangeToTarget &gt; 12) {</b>
<b class="nc">&nbsp;                                av += bayWType.getMedAV();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                av += bayWType.getShortAV();</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (rangeToTarget &gt; 25) {</b>
<b class="nc">&nbsp;                                av = 0;</b>
<b class="nc">&nbsp;                            } else if (rangeToTarget &gt; 20) {</b>
<b class="nc">&nbsp;                                av += bayWType.getExtAV();</b>
<b class="nc">&nbsp;                            } else if (rangeToTarget &gt; 12) {</b>
<b class="nc">&nbsp;                                av += bayWType.getLongAV();</b>
<b class="nc">&nbsp;                            } else if (rangeToTarget &gt; 6) {</b>
<b class="nc">&nbsp;                                av += bayWType.getMedAV();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                av += bayWType.getShortAV();</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        fDamage = (float) (av * threat);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (attacker.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                    double av = 0;</b>
<b class="nc">&nbsp;                    double threat = 1;</b>
&nbsp;                    //Capital weapons have a different range scale
<b class="nc">&nbsp;                    if (wt.isCapital()) {</b>
&nbsp;                        // Capital missiles should have higher priority than standard missiles
<b class="nc">&nbsp;                        threat = 12;</b>
<b class="nc">&nbsp;                        if (rangeToTarget &gt; 50) {</b>
<b class="nc">&nbsp;                            av = 0;</b>
<b class="nc">&nbsp;                        } else if (rangeToTarget &gt; 40) {</b>
<b class="nc">&nbsp;                            av += (wt.getExtAV() * weapon.getNWeapons());</b>
<b class="nc">&nbsp;                        } else if (rangeToTarget &gt; 25) {</b>
<b class="nc">&nbsp;                            av += (wt.getLongAV() * weapon.getNWeapons());</b>
<b class="nc">&nbsp;                        } else if (rangeToTarget &gt; 12) {</b>
<b class="nc">&nbsp;                            av += (wt.getMedAV() * weapon.getNWeapons());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            av += (wt.getShortAV() * weapon.getNWeapons());</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (rangeToTarget &gt; 25) {</b>
<b class="nc">&nbsp;                            av = 0;</b>
<b class="nc">&nbsp;                        } else if (rangeToTarget &gt; 20) {</b>
<b class="nc">&nbsp;                            av += (wt.getExtAV() * weapon.getNWeapons());</b>
<b class="nc">&nbsp;                        } else if (rangeToTarget &gt; 12) {</b>
<b class="nc">&nbsp;                            av += (wt.getLongAV() * weapon.getNWeapons());</b>
<b class="nc">&nbsp;                        } else if (rangeToTarget &gt; 6) {</b>
<b class="nc">&nbsp;                            av += (wt.getMedAV() * weapon.getNWeapons());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            av += (wt.getShortAV() * weapon.getNWeapons());</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    fDamage = (float) (av * threat);</b>
&nbsp;
<b class="nc">&nbsp;                } else if ((wt.getAmmoType() == AmmoType.T_ARROW_IV)</b>
<b class="nc">&nbsp;                        || wt.getAmmoType() == BombType.B_HOMING) {</b>
&nbsp;                    //This is for arrow IV AMS threat processing
<b class="nc">&nbsp;                    fDamage = (float) wt.getRackSize();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    fDamage = wt.getDamage(rangeToTarget);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Infantry follow some special rules, but do fixed amounts of damage
&nbsp;            // Anti-mek attacks are weapon-like in nature, so include them here as well
<b class="nc">&nbsp;            if (attacker instanceof Infantry) {</b>
<b class="nc">&nbsp;                if (wt.getInternalName() == Infantry.LEG_ATTACK) {</b>
<b class="nc">&nbsp;                    fDamage = 20.0f; // Actually 5, but the chance of crits</b>
&nbsp;                    // deserves a boost
&nbsp;                // leg attacks are mutually exclusive with swarm attacks, 
&nbsp;                } else {                
<b class="nc">&nbsp;                    boolean targetIsSwarmable = (target instanceof Mech) || (target instanceof Tank);</b>
&nbsp;    
<b class="nc">&nbsp;                    if (attacker.isConventionalInfantry()) {</b>
<b class="nc">&nbsp;                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</b>
&nbsp;                            // If the target is a Mek that is not swarmed, this is a
&nbsp;                            // good thing
<b class="nc">&nbsp;                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</b>
<b class="nc">&nbsp;                                fDamage = 1.5f</b>
&nbsp;                                        * (float) infDamagePerTrooper
&nbsp;                                        * infShootingStrength;
&nbsp;                            }
&nbsp;                            // Otherwise, call it 0 damage
&nbsp;                            else {
<b class="nc">&nbsp;                                fDamage = 0.0f;</b>
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            // conventional weapons; field guns should be handled
&nbsp;                            // under the standard weapons section
<b class="nc">&nbsp;                            fDamage = 0.6f</b>
&nbsp;                                    * (float) infDamagePerTrooper
&nbsp;                                    * infShootingStrength;
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // Battle armor units conducting swarm attack
<b class="nc">&nbsp;                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</b>
&nbsp;                            // If the target is a Mek that is not swarmed, this is a
&nbsp;                            // good thing
<b class="nc">&nbsp;                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</b>
&nbsp;                                // Overestimated, but the chance at crits and head
&nbsp;                                // shots deserves a boost
<b class="nc">&nbsp;                                fDamage = 10.0f * baShootingStrength;</b>
&nbsp;                            }
&nbsp;                            // Otherwise, call it 0 damage
&nbsp;                            else {
<b class="nc">&nbsp;                                fDamage = 0.0f;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // Need to adjust damage if the target is infantry.
<b class="nc">&nbsp;        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</b>
<b class="nc">&nbsp;            fDamage = directBlowInfantryDamage(fDamage, 0,</b>
<b class="nc">&nbsp;                    wt.getInfantryDamageClass(), ((Infantry) (g.getEntity(waa</b>
<b class="nc">&nbsp;                            .getTargetId()))).isMechanized(), false);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        fDamage *= fChance;</b>
&nbsp;
&nbsp;        // Conventional infantry take double damage in the open
<b class="nc">&nbsp;        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</b>
<b class="nc">&nbsp;            IHex e_hex = g.getBoard().getHex(</b>
<b class="nc">&nbsp;                    g.getEntity(waa.getTargetId()).getPosition().getX(),</b>
<b class="nc">&nbsp;                    g.getEntity(waa.getTargetId()).getPosition().getY());</b>
<b class="nc">&nbsp;            if (!e_hex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                &amp;&amp; !e_hex.containsTerrain(Terrains.JUNGLE)</b>
<b class="nc">&nbsp;                &amp;&amp; !e_hex.containsTerrain(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;                fDamage *= 2.0f;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Cap damage to prevent run-away values
<b class="nc">&nbsp;            if (infShootingStrength &gt; 0) {</b>
<b class="nc">&nbsp;                fDamage = Math.min(infShootingStrength, fDamage);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return fDamage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If the unit is carrying multiple types of ammo for the specified weapon,
&nbsp;     * cycle through them and choose the type best suited to engage the
&nbsp;     * specified target Value returned is expected damage Note that some ammo
&nbsp;     * types, such as infernos, do no damage or have special properties and so
&nbsp;     * the damage is an estimation of effectiveness
&nbsp;     */
&nbsp;
&nbsp;    public static double getAmmoAdjDamage(IGame cgame, WeaponAttackAction atk) {
<b class="nc">&nbsp;        boolean no_bin = true;</b>
<b class="nc">&nbsp;        boolean multi_bin = false;</b>
&nbsp;
&nbsp;        double ammo_multiple, ex_damage, max_damage;
&nbsp;
&nbsp;        Entity shooter, target;
&nbsp;
&nbsp;        Mounted fabin, best_bin;
<b class="nc">&nbsp;        AmmoType abin_type = new AmmoType();</b>
<b class="nc">&nbsp;        AmmoType fabin_type = new AmmoType();</b>
<b class="nc">&nbsp;        WeaponType wtype = new WeaponType();</b>
<b class="nc">&nbsp;        WeaponType target_weapon = new WeaponType();</b>
&nbsp;
&nbsp;        // Get shooter entity, target entity, and weapon being fired
<b class="nc">&nbsp;        target = cgame.getEntity(atk.getTargetId());</b>
<b class="nc">&nbsp;        shooter = atk.getEntity(cgame);</b>
<b class="nc">&nbsp;        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</b>
&nbsp;
<b class="nc">&nbsp;        max_damage = 0.0;</b>
&nbsp;
&nbsp;        // If the weapon doesn&#39;t require ammo, just get the estimated damage
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_ENERGY)</b>
<b class="nc">&nbsp;            || wtype.hasFlag(WeaponType.F_ONESHOT)</b>
<b class="nc">&nbsp;            || wtype.hasFlag(WeaponType.F_INFANTRY)</b>
<b class="nc">&nbsp;            || (wtype.getAmmoType() == AmmoType.T_NA)) {</b>
<b class="nc">&nbsp;            return Compute.getExpectedDamage(cgame, atk, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get a list of ammo bins and the first valid bin
<b class="nc">&nbsp;        fabin = null;</b>
<b class="nc">&nbsp;        best_bin = null;</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted abin : shooter.getAmmo()) {</b>
<b class="nc">&nbsp;            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</b>
&nbsp;                                   abin)) {
<b class="nc">&nbsp;                if (abin.getUsableShotsLeft() &gt; 0) {</b>
<b class="nc">&nbsp;                    abin_type = (AmmoType) abin.getType();</b>
<b class="nc">&nbsp;                    if (!AmmoType.canDeliverMinefield(abin_type)) {</b>
<b class="nc">&nbsp;                        fabin = abin;</b>
<b class="nc">&nbsp;                        fabin_type = (AmmoType) fabin.getType();</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // To save processing time, lets see if we have more than one type of
&nbsp;        // bin
&nbsp;        // Thunder-type ammos and empty bins are excluded from the list
<b class="nc">&nbsp;        for (Mounted abin : shooter.getAmmo()) {</b>
<b class="nc">&nbsp;            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</b>
&nbsp;                                   abin)) {
<b class="nc">&nbsp;                if (abin.getUsableShotsLeft() &gt; 0) {</b>
<b class="nc">&nbsp;                    abin_type = (AmmoType) abin.getType();</b>
<b class="nc">&nbsp;                    if (!AmmoType.canDeliverMinefield(abin_type)) {</b>
<b class="nc">&nbsp;                        no_bin = false;</b>
<b class="nc">&nbsp;                        if (abin_type.getMunitionType() != fabin_type</b>
<b class="nc">&nbsp;                                .getMunitionType()) {</b>
<b class="nc">&nbsp;                            multi_bin = true;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If no_bin is true, then either all bins are empty or contain
&nbsp;        // Thunder-type rounds and
&nbsp;        // we can safely say that the expected damage is 0.0
&nbsp;        // If no_bin is false, then we have at least one good bin
<b class="nc">&nbsp;        if (no_bin) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;        // If multi_bin is true, then multiple ammo types are present and an
&nbsp;        // appropriate type must be selected
&nbsp;        // If multi_bin is false, then all bin types are the same; skip down
&nbsp;        // to getting the expected damage
<b class="nc">&nbsp;        if (!multi_bin) {</b>
<b class="nc">&nbsp;            return Compute.getExpectedDamage(cgame, atk, false);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (multi_bin) {</b>
&nbsp;
&nbsp;            // Set default max damage as 0, and the best bin as the first
&nbsp;            // bin
<b class="nc">&nbsp;            max_damage = 0.0;</b>
<b class="nc">&nbsp;            best_bin = fabin;</b>
&nbsp;
&nbsp;            // For each valid ammo bin
<b class="nc">&nbsp;            for (Mounted abin : shooter.getAmmo()) {</b>
<b class="nc">&nbsp;                if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</b>
&nbsp;                                       abin)) {
<b class="nc">&nbsp;                    if (abin.getUsableShotsLeft() &gt; 0) {</b>
<b class="nc">&nbsp;                        abin_type = (AmmoType) abin.getType();</b>
<b class="nc">&nbsp;                        if (!AmmoType.canDeliverMinefield(abin_type)) {</b>
&nbsp;
&nbsp;                            // Load weapon with specified bin
<b class="nc">&nbsp;                            shooter.loadWeapon(</b>
<b class="nc">&nbsp;                                    shooter.getEquipment(atk.getWeaponId()),</b>
&nbsp;                                    abin);
<b class="nc">&nbsp;                            atk.setAmmoId(shooter.getEquipmentNum(abin));</b>
&nbsp;
&nbsp;                            // Get expected damage
<b class="nc">&nbsp;                            ex_damage = Compute.getExpectedDamage(cgame, atk,</b>
&nbsp;                                                                  false);
&nbsp;
&nbsp;                            // Calculate any modifiers due to ammo type
<b class="nc">&nbsp;                            ammo_multiple = 1.0;</b>
&nbsp;
&nbsp;                            // Frag missiles, flechette AC rounds do double
&nbsp;                            // damage against conventional infantry
&nbsp;                            // and 0 damage against everything else
&nbsp;                            // Any further anti-personnel specialized rounds
&nbsp;                            // should be tested for here
<b class="nc">&nbsp;                            if (((((abin_type.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)))</b>
<b class="nc">&nbsp;                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FRAGMENTATION))</b>
<b class="nc">&nbsp;                                    || (((abin_type.getAmmoType() == AmmoType.T_AC)</b>
<b class="nc">&nbsp;                                            || (abin_type.getAmmoType() == AmmoType.T_LAC)</b>
<b class="nc">&nbsp;                                            || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</b>
<b class="nc">&nbsp;                                            || (abin_type.getAmmoType() == AmmoType.T_PAC))</b>
<b class="nc">&nbsp;                                            &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FLECHETTE))) {</b>
<b class="nc">&nbsp;                                ammo_multiple = 0.0;</b>
<b class="nc">&nbsp;                                if (target instanceof Infantry) {</b>
<b class="nc">&nbsp;                                    if (!(target instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                                        ammo_multiple = 2.0;</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            // LBX cluster rounds work better against units
&nbsp;                            // with little armor, vehicles, and Meks in
&nbsp;                            // partial cover
&nbsp;                            // Other ammo that deliver lots of small
&nbsp;                            // submunitions should be tested for here too
<b class="nc">&nbsp;                            if (((abin_type.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                                 || (abin_type.getAmmoType() == AmmoType.T_AC_LBX_THB) || (abin_type</b>
<b class="nc">&nbsp;                                                                                                   .getAmmoType() ==</b>
&nbsp;                                                                                           AmmoType.T_SBGAUSS))
<b class="nc">&nbsp;                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_CLUSTER)) {</b>
<b class="nc">&nbsp;                                if (target.getArmorRemainingPercent() &lt;= 0.25) {</b>
<b class="nc">&nbsp;                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                if (target instanceof Tank) {</b>
<b class="nc">&nbsp;                                    ammo_multiple += 1.0;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            // AP autocannon rounds work much better against
&nbsp;                            // Meks and vehicles than infantry,
&nbsp;                            // give a damage boost in proportion to calibre
&nbsp;                            // to reflect scaled crit chance
&nbsp;                            // Other armor-penetrating ammo types should be
&nbsp;                            // tested here, such as Tandem-charge SRMs
<b class="nc">&nbsp;                            if (((abin_type.getAmmoType() == AmmoType.T_AC)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_LAC)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_PAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ARMOR_PIERCING)) {</b>
<b class="nc">&nbsp;                                if ((target instanceof Mech)</b>
&nbsp;                                    || (target instanceof Tank)) {
<b class="nc">&nbsp;                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                if (target instanceof Infantry) {</b>
<b class="nc">&nbsp;                                    ammo_multiple = 0.6;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            // Inferno SRMs work better against overheating
&nbsp;                            // Meks that are not/almost not on fire,
&nbsp;                            // and against vehicles and protos if allowed by
&nbsp;                            // game option
<b class="nc">&nbsp;                            if (((abin_type.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                                    || (abin_type.getAmmoType() == AmmoType.T_MML))</b>
<b class="nc">&nbsp;                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_INFERNO)) {</b>
<b class="nc">&nbsp;                                ammo_multiple = 0.5;</b>
<b class="nc">&nbsp;                                if (target instanceof Mech) {</b>
<b class="nc">&nbsp;                                    if ((target.infernos.getTurnsLeftToBurn() &lt; 4)</b>
&nbsp;                                        &amp;&amp; (target.heat &gt;= 5)) {
<b class="nc">&nbsp;                                        ammo_multiple = 1.1;</b>
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                                if ((target instanceof Tank)</b>
<b class="nc">&nbsp;                                    &amp;&amp; !(cgame.getOptions()</b>
<b class="nc">&nbsp;                                              .booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_SAFE_FROM_INFERNOS))) {</b>
<b class="nc">&nbsp;                                    ammo_multiple = 1.1;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                if ((target instanceof Protomech)</b>
<b class="nc">&nbsp;                                    &amp;&amp; !(cgame.getOptions()</b>
<b class="nc">&nbsp;                                              .booleanOption(OptionsConstants.ADVCOMBAT_PROTOS_SAFE_FROM_INFERNOS))) {</b>
<b class="nc">&nbsp;                                    ammo_multiple = 1.1;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            // Narc beacon doesn&#39;t really do damage but if
&nbsp;                            // the target is not infantry and doesn&#39;t have
&nbsp;                            // one, give &#39;em one by making it an attractive
&nbsp;                            // option
<b class="nc">&nbsp;                            if ((wtype.getAmmoType() == AmmoType.T_NARC)</b>
<b class="nc">&nbsp;                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_STANDARD)) {</b>
<b class="nc">&nbsp;                                if (!(target.isNarcedBy(shooter.getOwner().getTeam()))</b>
&nbsp;                                        &amp;&amp; !(target instanceof Infantry)) {
<b class="nc">&nbsp;                                    ex_damage = 5.0;</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    ex_damage = 0.5;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            // iNarc beacon doesn&#39;t really do damage, but if
&nbsp;                            // the target is not infantry and doesn&#39;t have
&nbsp;                            // one, give &#39;em one by making it an attractive
&nbsp;                            // option
<b class="nc">&nbsp;                            if (wtype.getAmmoType() == AmmoType.T_INARC) {</b>
<b class="nc">&nbsp;                                if ((abin_type.getMunitionType() == AmmoType.M_STANDARD)</b>
&nbsp;                                        &amp;&amp; !(target instanceof Infantry)) {
<b class="nc">&nbsp;                                    if (!(target.isINarcedBy(shooter.getOwner().getTeam()))) {</b>
<b class="nc">&nbsp;                                        ex_damage = 7.0;</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        ex_damage = 1.0;</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                // iNarc ECM doesn&#39;t really do damage, but
&nbsp;                                // if the target has a C3 link or missile
&nbsp;                                // launchers
&nbsp;                                // make it a priority
&nbsp;                                // Checking for actual ammo types carried
&nbsp;                                // would be nice, but can&#39;t be sure of exact
&nbsp;                                // loads
&nbsp;                                // when &quot;true&quot; double blind is implemented
<b class="nc">&nbsp;                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ECM)</b>
&nbsp;                                        &amp;&amp; !(target instanceof Infantry)) {
<b class="nc">&nbsp;                                    if (!target.isINarcedWith(AmmoType.M_ECM)) {</b>
<b class="nc">&nbsp;                                        if (!(target.getC3MasterId() == Entity.NONE)</b>
<b class="nc">&nbsp;                                                || target.hasC3M()</b>
<b class="nc">&nbsp;                                                || target.hasC3MM()</b>
<b class="nc">&nbsp;                                                || target.hasC3i()) {</b>
<b class="nc">&nbsp;                                            ex_damage = 8.0;</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            ex_damage = 0.5;</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                        for (Mounted weapon : shooter.getWeaponList()) {</b>
<b class="nc">&nbsp;                                            target_weapon = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;                                            if ((target_weapon.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                                                    || (target_weapon.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                                                    || (target_weapon.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM_IMP)) {</b>
<b class="nc">&nbsp;                                                ex_damage = ex_damage + (target_weapon.getRackSize() / 2);</b>
&nbsp;                                            }
<b class="nc">&nbsp;                                        }</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                // iNarc Nemesis doesn&#39;t really do damage,
&nbsp;                                // but if the target is not infantry and
&nbsp;                                // doesn&#39;t have
&nbsp;                                // one give it a try; make fast units a
&nbsp;                                // priority because they are usually out
&nbsp;                                // front
<b class="nc">&nbsp;                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_NEMESIS)</b>
&nbsp;                                        &amp;&amp; !(target instanceof Infantry)) {
<b class="nc">&nbsp;                                    if (!target.isINarcedWith(AmmoType.M_NEMESIS)) {</b>
<b class="nc">&nbsp;                                        ex_damage = (double) (target.getWalkMP() + target.getJumpMP()) / 2;</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        ex_damage = 0.5;</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            // If the adjusted damage is highest, store the
&nbsp;                            // damage and bin
<b class="nc">&nbsp;                            if ((ex_damage * ammo_multiple) &gt; max_damage) {</b>
<b class="nc">&nbsp;                                max_damage = ex_damage * ammo_multiple;</b>
<b class="nc">&nbsp;                                best_bin = abin;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Now that the best bin has been found, reload the weapon with
&nbsp;            // it
<b class="nc">&nbsp;            shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</b>
&nbsp;                               best_bin);
<b class="nc">&nbsp;            atk.setAmmoId(shooter.getEquipmentNum(best_bin));</b>
&nbsp;        }
<b class="nc">&nbsp;        return max_damage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this is an ultra or rotary cannon, lets see about &#39;spinning it up&#39; for
&nbsp;     * extra damage
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
&nbsp;     */
&nbsp;    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk) {
<b class="nc">&nbsp;        return spinUpCannon(cgame, atk, Compute.d6(2) - 1);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * If this is an ultra or rotary cannon, lets see about &#39;spinning it up&#39; for
&nbsp;     * extra damage
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
&nbsp;     */
&nbsp;
&nbsp;    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk, int spinupThreshold) {
&nbsp;
<b class="fc">&nbsp;        int threshold = 12;</b>
&nbsp;        int final_spin;
&nbsp;        Entity shooter;
&nbsp;        Mounted weapon;
<b class="fc">&nbsp;        WeaponType wtype = new WeaponType();</b>
&nbsp;
&nbsp;        // Double check this is an Ultra or Rotary cannon
&nbsp;        // or a standard AC with the TacOps rapid fire rule turned on
<b class="fc">&nbsp;        shooter = atk.getEntity(cgame);</b>
<b class="fc">&nbsp;        weapon = shooter.getEquipment(atk.getWeaponId());</b>
<b class="fc">&nbsp;        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</b>
&nbsp;        
<b class="fc">&nbsp;        boolean rapidAC = (wtype.getAmmoType() == AmmoType.T_AC) &amp;&amp; cgame.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RAPID_AC);</b>
&nbsp;
<b class="fc">&nbsp;        if (!((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="fc">&nbsp;              || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB) </b>
<b class="fc">&nbsp;              || (wtype.getAmmoType() == AmmoType.T_AC_ROTARY)</b>
&nbsp;              || rapidAC)) {
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the to-hit number
<b class="nc">&nbsp;        threshold = atk.toHit(cgame).getValue();</b>
&nbsp;
&nbsp;        // Set the weapon to single shot mode
<b class="nc">&nbsp;        weapon.setMode(rapidAC ? &quot;&quot; : Weapon.MODE_AC_SINGLE);</b>
<b class="nc">&nbsp;        final_spin = 0;</b>
&nbsp;
&nbsp;        // If weapon can&#39;t hit target, exit the function with the weapon on
&nbsp;        // single shot
<b class="nc">&nbsp;        if ((threshold == TargetRoll.IMPOSSIBLE)</b>
&nbsp;            || (threshold == TargetRoll.AUTOMATIC_FAIL)) {
<b class="nc">&nbsp;            return final_spin;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If random roll is &gt;= to-hit + 1, then set double-spin
<b class="nc">&nbsp;        if (spinupThreshold &gt;= threshold) {</b>
<b class="nc">&nbsp;            final_spin = 1;</b>
<b class="nc">&nbsp;            if ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {</b>
<b class="nc">&nbsp;                weapon.setMode(Weapon.MODE_UAC_ULTRA);</b>
<b class="nc">&nbsp;            } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</b>
<b class="nc">&nbsp;                weapon.setMode(Weapon.MODE_RAC_TWO_SHOT);</b>
<b class="nc">&nbsp;            } else if (rapidAC) {</b>
<b class="nc">&nbsp;                weapon.setMode(Weapon.MODE_AC_RAPID);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // If this is a Rotary cannon
<b class="nc">&nbsp;        if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</b>
&nbsp;
&nbsp;            // If random roll is &gt;= to-hit + 2 then set to quad-spin
<b class="nc">&nbsp;            if (spinupThreshold &gt;= (threshold + 1)) {</b>
<b class="nc">&nbsp;                final_spin = 2;</b>
<b class="nc">&nbsp;                weapon.setMode(Weapon.MODE_RAC_FOUR_SHOT);</b>
&nbsp;            }
&nbsp;
&nbsp;            // If random roll is &gt;= to-hit + 3 then set to six-spin
<b class="nc">&nbsp;            if (spinupThreshold &gt;= (threshold + 2)) {</b>
<b class="nc">&nbsp;                final_spin = 3;</b>
<b class="nc">&nbsp;                weapon.setMode(Weapon.MODE_RAC_SIX_SHOT);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return final_spin;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if a target is in arc of the specified weapon, on the
&nbsp;     * specified entity
&nbsp;     */
&nbsp;    public static boolean isInArc(IGame game, int attackerId, int weaponId,
&nbsp;            Targetable t) {
<b class="nc">&nbsp;        Entity ae = game.getEntity(attackerId);</b>
<b class="nc">&nbsp;        if ((ae instanceof Mech)</b>
<b class="nc">&nbsp;            &amp;&amp; (((Mech) ae).getGrappled() == t.getTargetId())) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        int facing = ae.isSecondaryArcWeapon(weaponId) ? ae</b>
<b class="nc">&nbsp;                .getSecondaryFacing() : ae.getFacing();</b>
<b class="nc">&nbsp;        if ((ae instanceof Tank)</b>
<b class="nc">&nbsp;            &amp;&amp; (ae.getEquipment(weaponId).getLocation() == ((Tank) ae)</b>
<b class="nc">&nbsp;                .getLocTurret2())) {</b>
<b class="nc">&nbsp;            facing = ((Tank) ae).getDualTurretFacing();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (ae.getEquipment(weaponId).isMechTurretMounted()) {</b>
<b class="nc">&nbsp;            facing = ae.getSecondaryFacing()</b>
<b class="nc">&nbsp;                     + (ae.getEquipment(weaponId).getFacing() % 6);</b>
&nbsp;        }
<b class="nc">&nbsp;        Coords aPos = ae.getPosition();</b>
<b class="nc">&nbsp;        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        Coords tPos = t.getPosition();</b>
&nbsp;        // aeros in the same hex in space may still be able to fire at one
&nbsp;        // another. First I need to translate
&nbsp;        // their positions to see who was further back
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            &amp;&amp; ae.getPosition().equals(t.getPosition())</b>
<b class="nc">&nbsp;            &amp;&amp; ae.isAero() &amp;&amp; t.isAero()) {</b>
<b class="nc">&nbsp;            int moveSort = shouldMoveBackHex(ae, (Entity)t);</b>
<b class="nc">&nbsp;            if (moveSort &lt; 0) {</b>
<b class="nc">&nbsp;                aPos = ae.getPriorPosition();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (moveSort &gt; 0) {</b>
<b class="nc">&nbsp;                tPos = ((Entity) t).getPriorPosition();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // if using advanced AA options, then ground-to-air fire determines arc
&nbsp;        // by closest position
<b class="nc">&nbsp;        if (isGroundToAir(ae, t) &amp;&amp; (t instanceof Entity)) {</b>
<b class="nc">&nbsp;            tPos = getClosestFlightPath(ae.getId(), ae.getPosition(),</b>
&nbsp;                    (Entity) t);
&nbsp;        }
&nbsp;
&nbsp;        // AMS defending against Ground to Air fire needs to calculate arc based on the closest flight path
&nbsp;        // Technically it&#39;s an AirToGround attack since the AMS is on the aircraft
<b class="nc">&nbsp;        if (isAirToGround(ae, t) &amp;&amp; (t instanceof Entity)</b>
<b class="nc">&nbsp;                &amp;&amp; (ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMS)</b>
<b class="nc">&nbsp;                        || ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMSBAY))) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) t;</b>
<b class="nc">&nbsp;            aPos = getClosestFlightPath(te.getId(), te.getPosition(),</b>
&nbsp;                    ae);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        tPosV.add(tPos);</b>
&nbsp;        // check for secondary positions
<b class="nc">&nbsp;        if ((t instanceof Entity)</b>
<b class="nc">&nbsp;            &amp;&amp; (null != ((Entity) t).getSecondaryPositions())) {</b>
<b class="nc">&nbsp;            for (int key : ((Entity) t).getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                tPosV.add(((Entity) t).getSecondaryPositions().get(key));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return Compute.isInArc(aPos, facing, tPosV, ae.getWeaponArc(weaponId));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the line between source Coords and target goes through
&nbsp;     * the hex in front of the attacker
&nbsp;     */
&nbsp;    public static boolean isThroughFrontHex(IGame game, Coords src, Entity t) {
<b class="nc">&nbsp;        Coords dest = t.getPosition();</b>
<b class="nc">&nbsp;        int fa = dest.degree(src) - (t.getFacing() * 60);</b>
<b class="nc">&nbsp;        if (fa &lt; 0) {</b>
<b class="nc">&nbsp;            fa += 360;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (fa &gt; 330) || (fa &lt; 30);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Converts the facing of a vehicular grenade launcher to the corresponding firing arc.
&nbsp;     * 
&nbsp;     * @param facing The VGL facing returned by {@link Mounted#getFacing()}
&nbsp;     * @return       The firing arc
&nbsp;     */
&nbsp;    public static int firingArcFromVGLFacing(int facing) {
<b class="nc">&nbsp;        return VGL_FIRING_ARCS[facing % 6];</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isInArc(Coords src, int facing, Targetable target,
&nbsp;                                  int arc) {
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        tPosV.add(target.getPosition());</b>
&nbsp;        // check for secondary positions
<b class="nc">&nbsp;        if ((target instanceof Entity)</b>
<b class="nc">&nbsp;            &amp;&amp; (null != ((Entity) target).getSecondaryPositions())) {</b>
<b class="nc">&nbsp;            for (int key : ((Entity) target).getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                tPosV.add(((Entity) target).getSecondaryPositions().get(key));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return isInArc(src, facing, tPosV, arc);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isInArc(Coords src, int facing, Coords dest, int arc) {
<b class="nc">&nbsp;        Vector&lt;Coords&gt; destV = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        destV.add(dest);</b>
<b class="nc">&nbsp;        return isInArc(src, facing, destV, arc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the target is in the specified arc. Note: This has to
&nbsp;     * take vectors of coordinates to account for potential secondary positions
&nbsp;     *
&nbsp;     * @param src    the attack coordinates
&nbsp;     * @param facing the appropriate attacker sfacing
&nbsp;     * @param destV  A vector of target coordinates
&nbsp;     * @param arc    the arc
&nbsp;     */
&nbsp;    public static boolean isInArc(Coords src, int facing, Vector&lt;Coords&gt; destV,
&nbsp;                                  int arc) {
<b class="nc">&nbsp;        if ((src == null) || (destV == null)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Jay: I have to adjust this to take in vectors of coordinates to
&nbsp;        // account for secondary positions of the
&nbsp;        // target - I am fairly certain that secondary positions of the attacker
&nbsp;        // shouldn&#39;t matter because you don&#39;t get
&nbsp;        // to move the angle based on the secondary positions
&nbsp;
&nbsp;        // if any of the destination coords are in the right place, then return
&nbsp;        // true
<b class="nc">&nbsp;        for (Coords dest : destV) {</b>
&nbsp;            // calculate firing angle
<b class="nc">&nbsp;            int fa = src.degree(dest) - (facing * 60);</b>
<b class="nc">&nbsp;            if (fa &lt; 0) {</b>
<b class="nc">&nbsp;                fa += 360;</b>
&nbsp;            }
&nbsp;            // is it in the specifed arc?
<b class="nc">&nbsp;            switch (arc) {</b>
&nbsp;                case ARC_FORWARD:
<b class="nc">&nbsp;                    if ((fa &gt;= 300) || (fa &lt;= 60)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Compute.ARC_RIGHTARM:
<b class="nc">&nbsp;                    if ((fa &gt;= 300) || (fa &lt;= 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case Compute.ARC_LEFTARM:
<b class="nc">&nbsp;                    if ((fa &gt;= 240) || (fa &lt;= 60)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_REAR:
<b class="nc">&nbsp;                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHTSIDE:
<b class="nc">&nbsp;                    if ((fa &gt; 60) &amp;&amp; (fa &lt;= 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFTSIDE:
<b class="nc">&nbsp;                    if ((fa &lt; 300) &amp;&amp; (fa &gt;= 240)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_MAINGUN:
<b class="nc">&nbsp;                    if ((fa &gt;= 240) || (fa &lt;= 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_360:
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                case ARC_NORTH:
<b class="nc">&nbsp;                    if ((fa &gt;= 270) || (fa &lt;= 30)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_EAST:
<b class="nc">&nbsp;                    if ((fa &gt;= 30) &amp;&amp; (fa &lt;= 150)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_WEST:
<b class="nc">&nbsp;                    if ((fa &gt;= 150) &amp;&amp; (fa &lt;= 270)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_NOSE:
<b class="nc">&nbsp;                    if ((fa &gt; 300) || (fa &lt; 60)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_NOSE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 240) || (fa &lt; 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LWING:
<b class="nc">&nbsp;                    if ((fa &gt; 300) || (fa &lt;= 0)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LWING_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 240) || (fa &lt; 60)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RWING:
<b class="nc">&nbsp;                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 60)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RWING_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 300) || (fa &lt; 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LWINGA:
<b class="nc">&nbsp;                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 240)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LWINGA_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 300)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RWINGA:
<b class="nc">&nbsp;                    if ((fa &gt; 120) &amp;&amp; (fa &lt;= 180)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RWINGA_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 240)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_AFT:
<b class="nc">&nbsp;                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_AFT_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 300)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFTSIDE_SPHERE:
<b class="nc">&nbsp;                    if ((fa &gt; 240) || (fa &lt; 0)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFTSIDE_SPHERE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 180) || (fa &lt; 60)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHTSIDE_SPHERE:
<b class="nc">&nbsp;                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHTSIDE_SPHERE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 300) || (fa &lt; 180)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFTSIDEA_SPHERE:
<b class="nc">&nbsp;                    if ((fa &gt; 180) &amp;&amp; (fa &lt; 300)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFTSIDEA_SPHERE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 360)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHTSIDEA_SPHERE:
<b class="nc">&nbsp;                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 180)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHTSIDEA_SPHERE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 240)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFT_BROADSIDE:
<b class="nc">&nbsp;                    if ((fa &gt;= 240) &amp;&amp; (fa &lt;= 300)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFT_BROADSIDE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 180) &amp;&amp; (fa &lt;= 360)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHT_BROADSIDE:
<b class="nc">&nbsp;                    if ((fa &gt;= 60) &amp;&amp; (fa &lt;= 120)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHT_BROADSIDE_WPL:
<b class="nc">&nbsp;                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 180)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_LEFT_SPHERE_GROUND:
<b class="nc">&nbsp;                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 360)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_RIGHT_SPHERE_GROUND:
<b class="nc">&nbsp;                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 180)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_TURRET:
<b class="nc">&nbsp;                    if ((fa &gt;= 330) || (fa &lt;= 30)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_SPONSON_TURRET_LEFT:
&nbsp;                case ARC_PINTLE_TURRET_LEFT:
<b class="nc">&nbsp;                    if ((fa &gt;= 180) || (fa == 0)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_SPONSON_TURRET_RIGHT:
&nbsp;                case ARC_PINTLE_TURRET_RIGHT:
<b class="nc">&nbsp;                    if ((fa &gt;= 0) &amp;&amp; (fa &lt;= 180)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_PINTLE_TURRET_FRONT:
<b class="nc">&nbsp;                    if ((fa &gt;= 270) || (fa &lt;= 90)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_PINTLE_TURRET_REAR:
<b class="nc">&nbsp;                    if ((fa &gt;= 90) &amp;&amp; (fa &lt;= 270)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case ARC_VGL_FRONT:
<b class="nc">&nbsp;                    return (fa &gt;= 270) || (fa &lt;= 90);</b>
&nbsp;                case ARC_VGL_RF:
<b class="nc">&nbsp;                    return (fa &gt;= 330) || (fa &lt;= 150);</b>
&nbsp;                case ARC_VGL_RR:
<b class="nc">&nbsp;                    return (fa &gt;= 30) &amp;&amp; (fa &lt;= 210);</b>
&nbsp;                case ARC_VGL_REAR:
<b class="nc">&nbsp;                    return (fa &gt;= 90) &amp;&amp; (fa &lt;= 270);</b>
&nbsp;                case ARC_VGL_LR:
<b class="nc">&nbsp;                    return (fa &gt;= 150) &amp;&amp; (fa &lt;= 330);</b>
&nbsp;                case ARC_VGL_LF:
<b class="nc">&nbsp;                    return (fa &gt;= 210) || (fa &lt;= 30);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // if we got here then no matches
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * checks to see whether the target is within visual range of the entity,
&nbsp;     * but not necessarily LoS
&nbsp;     */
&nbsp;    public static boolean inVisualRange(IGame game, Entity ae, Targetable target) {
<b class="nc">&nbsp;        return inVisualRange(game, null, ae, target);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine whether the attacking entity is within visual range of the
&nbsp;     * target.  This requires line of sight effects to determine if there are
&nbsp;     * certain intervening obstructions, like smoke, that can reduce visual
&nbsp;     * range.  Since repeated LoSEffects computations can be expensive, it is
&nbsp;     * possible to pass in the LosEffects, since they are commonly already
&nbsp;     * computed when this method is called.
&nbsp;     *
&nbsp;     * @param game
&nbsp;     * @param los
&nbsp;     * @param ae
&nbsp;     * @param target
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static boolean inVisualRange(IGame game, LosEffects los, Entity ae,
&nbsp;            Targetable target) {
&nbsp;        //Use firing solution if Advanced Sensors is on
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</b>
<b class="nc">&nbsp;                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</b>
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
<b class="nc">&nbsp;            return hasAnyFiringSolution(game, te.getId());</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean teIlluminated = false;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
<b class="nc">&nbsp;            teIlluminated = te.isIlluminated();</b>
<b class="nc">&nbsp;            if (te.isOffBoard()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Target may be in an illuminated hex
<b class="nc">&nbsp;        if (!teIlluminated) {</b>
<b class="nc">&nbsp;            int lightLvl = game.isPositionIlluminated(target.getPosition());</b>
<b class="nc">&nbsp;            teIlluminated = lightLvl != Game.ILLUMINATED_NONE;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if either does not have a position then return false
<b class="nc">&nbsp;        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check visual range based on planetary conditions
<b class="nc">&nbsp;        if (los == null) {</b>
<b class="nc">&nbsp;            los = LosEffects.calculateLos(game, ae.getId(), target);</b>
&nbsp;        }
<b class="nc">&nbsp;        int visualRange = getVisualRange(game, ae, los, teIlluminated);</b>
&nbsp;
&nbsp;        //Check for factors that only apply to an entity target
<b class="nc">&nbsp;        Coords targetPos = target.getPosition();</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
&nbsp;
&nbsp;            // check for camo and null sig on the target
<b class="nc">&nbsp;            if (te.isVoidSigActive()) {</b>
<b class="nc">&nbsp;                visualRange = visualRange / 4;</b>
<b class="nc">&nbsp;            } else if (te.hasWorkingMisc(MiscType.F_VISUAL_CAMO, -1)) {</b>
<b class="nc">&nbsp;                visualRange = visualRange / 2;</b>
<b class="nc">&nbsp;            } else if (te.isChameleonShieldActive()) {</b>
<b class="nc">&nbsp;                visualRange = visualRange / 2;</b>
<b class="nc">&nbsp;            } else if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)</b>
<b class="nc">&nbsp;                       &amp;&amp; ((Infantry) te).hasSneakCamo()) {</b>
<b class="nc">&nbsp;                visualRange = visualRange / 2;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Ground targets pick the closest path to Aeros (TW pg 107)
<b class="nc">&nbsp;            if ((te.isAero()) &amp;&amp; isGroundToAir(ae, target)) {</b>
<b class="nc">&nbsp;                targetPos = Compute.getClosestFlightPath(ae.getId(),</b>
<b class="nc">&nbsp;                        ae.getPosition(), te);</b>
&nbsp;            }
&nbsp;            //Airborne aeros can only see ground targets they overfly, and only at Alt &lt;=8
<b class="nc">&nbsp;            if (isAirToGround(ae, target)) {</b>
<b class="nc">&nbsp;                if (ae.getAltitude() &gt; 8) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (ae.passedOver(target)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        visualRange = Math.max(visualRange, 1);</b>
&nbsp;        int distance;
&nbsp;        // Ground distance
<b class="nc">&nbsp;        distance = ae.getPosition().distance(targetPos);</b>
&nbsp;        //Need to track difference in altitude, not just add altitude to the range
<b class="nc">&nbsp;        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</b>
<b class="nc">&nbsp;        return distance &lt;= visualRange;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    //Space Combat Detection stuff
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if an entity has already been detected by anyone
&nbsp;     * Used for sensor return icons on board
&nbsp;     *
&nbsp;     * @param game - the current game
&nbsp;     * @param targetId - the ID# of the target entity we&#39;re looking for
&nbsp;     */
&nbsp;    public static boolean isAnySensorContact(IGame game, int targetId) {
<b class="nc">&nbsp;        for (Entity detector : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (detector.hasSensorContactFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</b>
<b class="nc">&nbsp;                game.getEntity(targetId).addBeenDetectedBy(detector.getOwner());</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if target entity has already appeared on @detector&#39;s sensors
&nbsp;     * Used with Naval C3 to determine if @detector can fire weapons at @target
&nbsp;     * @param detector - the entity making a sensor scan
&nbsp;     * @param targetId - the entity id of the scan target
&nbsp;     */
&nbsp;    public static boolean hasSensorContact(Entity detector, int targetId) {
<b class="nc">&nbsp;        return detector.hasSensorContactFor(targetId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if an entity is in anyone&#39;s firing solutions list
&nbsp;     * Used for visibility
&nbsp;     *
&nbsp;     * @param game - the current game
&nbsp;     * @param targetId - the ID # of the target we&#39;re firing at
&nbsp;     */
&nbsp;    public static boolean hasAnyFiringSolution(IGame game, int targetId) {
<b class="nc">&nbsp;        for (Entity detector : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (detector.hasFiringSolutionFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</b>
<b class="nc">&nbsp;                game.getEntity(targetId).addBeenSeenBy(detector.getOwner());</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the ECM effects in play between a detector and target pair
&nbsp;     *
&nbsp;     * @param game - the current game
&nbsp;     * @param ae - the entity making a sensor scan
&nbsp;     * @param target - the entity we&#39;re trying to spot
&nbsp;     * @return
&nbsp;     */
&nbsp;    private static int calcSpaceECM(IGame game, Entity ae,
&nbsp;            Targetable target) {
<b class="nc">&nbsp;        int mod = 0;</b>
<b class="nc">&nbsp;        int ecm = ComputeECM.getLargeCraftECM(ae, ae.getPosition(), target.getPosition());</b>
<b class="nc">&nbsp;        if (!ae.isLargeCraft()) {</b>
<b class="nc">&nbsp;            ecm += ComputeECM.getSmallCraftECM(ae, ae.getPosition(), target.getPosition());</b>
&nbsp;        }
<b class="nc">&nbsp;        ecm = Math.min(4, ecm);</b>
<b class="nc">&nbsp;        int eccm = 0;</b>
<b class="nc">&nbsp;        if (ae.isLargeCraft()) {</b>
<b class="nc">&nbsp;            eccm = ((Aero) ae).getECCMBonus();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (ecm &gt; 0) {</b>
<b class="nc">&nbsp;            mod += ecm;</b>
<b class="nc">&nbsp;            if (eccm &gt; 0) {</b>
<b class="nc">&nbsp;                mod -= (Math.min(ecm, eccm));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the Sensor Shadow effect in play between a detector and target pair
&nbsp;     *
&nbsp;     * @param game - the current game
&nbsp;     * @param ae - the entity making a sensor scan
&nbsp;     * @param target - the entity we&#39;re trying to spot
&nbsp;     * @return
&nbsp;     */
&nbsp;    private static int calcSensorShadow(IGame game, Entity ae,
&nbsp;            Targetable target) {
<b class="nc">&nbsp;        int mod = 0;</b>
<b class="nc">&nbsp;        if (target.getTargetType() != Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        Entity te = (Entity) target;</b>
<b class="nc">&nbsp;        for (Entity en : Compute.getAdjacentEntitiesAlongAttack(ae.getPosition(), target.getPosition(), game)) {</b>
<b class="nc">&nbsp;            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) te) &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</b>
<b class="nc">&nbsp;                mod ++;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Entity en : game.getEntitiesVector(target.getPosition())) {</b>
<b class="nc">&nbsp;            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) ae) &amp;&amp; !en.equals((Entity) te)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</b>
<b class="nc">&nbsp;                mod ++;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates an entity&#39;s firingSolutions, removing any objects that no longer meet criteria for being
&nbsp;     * tracked as targets. Also, if the detecting entity no longer meets criteria for having firing solutions,
&nbsp;     * empty the list. We wouldn&#39;t want a dead ship to be providing NC3 data, now would we...
&nbsp;     */
&nbsp;    public static void updateFiringSolutions(IGame game, Entity detector) {
<b class="nc">&nbsp;        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</b>
&nbsp;        //Flush the detecting unit&#39;s firing solutions if any of these conditions applies
<b class="nc">&nbsp;        if (detector.isDestroyed()</b>
<b class="nc">&nbsp;                || detector.isDoomed()</b>
<b class="nc">&nbsp;                || detector.getTransportId() != Entity.NONE</b>
<b class="nc">&nbsp;                || detector.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                || detector.isOffBoard()</b>
<b class="nc">&nbsp;                || detector.getPosition() == null) {</b>
<b class="nc">&nbsp;            detector.clearFiringSolutions();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int id : detector.getFiringSolutions()) {</b>
<b class="nc">&nbsp;            Entity target = game.getEntity(id);</b>
&nbsp;            //The target should be removed if it&#39;s off the board for any of these reasons
<b class="nc">&nbsp;            if (target == null</b>
<b class="nc">&nbsp;                    || target.getPosition() == null</b>
<b class="nc">&nbsp;                    || target.isDestroyed()</b>
<b class="nc">&nbsp;                    || target.isDoomed()</b>
<b class="nc">&nbsp;                    || target.getTransportId() != Entity.NONE</b>
<b class="nc">&nbsp;                    || target.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                    || target.isOffBoard()) {</b>
<b class="nc">&nbsp;                toRemove.add(id);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Coords targetPos = target.getPosition();</b>
<b class="nc">&nbsp;            int distance = detector.getPosition().distance(targetPos);</b>
&nbsp;            //Per SO p119, optical firing solutions are lost if the target moves beyond 1/10 max range
<b class="nc">&nbsp;            if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL</b>
&nbsp;                    &amp;&amp; distance &gt; Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE) {
<b class="nc">&nbsp;                    toRemove.add(id);</b>
<b class="nc">&nbsp;            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL</b>
&nbsp;                    &amp;&amp; distance &gt; Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE) {
<b class="nc">&nbsp;                    toRemove.add(id);</b>
&nbsp;            //For ASF sensors, make sure we&#39;re using the space range of 555...
<b class="nc">&nbsp;            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</b>
&nbsp;                    &amp;&amp; distance &gt; Sensor.ASF_RADAR_MAX_RANGE) {
<b class="nc">&nbsp;                    toRemove.add(id);</b>
&nbsp;            } else {
&nbsp;                //Radar firing solutions are only lost if the target moves out of range
<b class="nc">&nbsp;                if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</b>
<b class="nc">&nbsp;                    toRemove.add(id);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        detector.removeFiringSolution(toRemove);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Updates an entity&#39;s sensorContacts, removing any objects that no longer meet criteria for being
&nbsp;     * tracked. Also, if the detecting entity no longer meets criteria for having sensor contacts,
&nbsp;     * empty the list. We wouldn&#39;t want a dead ship to be providing sensor data, now would we...
&nbsp;     */
&nbsp;    public static void updateSensorContacts(IGame game, Entity detector) {
<b class="nc">&nbsp;        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</b>
&nbsp;        //Flush the detecting unit&#39;s sensor contacts if any of these conditions applies
<b class="nc">&nbsp;        if (detector.getPosition() == null</b>
<b class="nc">&nbsp;                || detector.isDestroyed()</b>
<b class="nc">&nbsp;                || detector.isDoomed()</b>
<b class="nc">&nbsp;                || detector.getTransportId() != Entity.NONE</b>
<b class="nc">&nbsp;                || detector.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                || detector.isOffBoard()) {</b>
<b class="nc">&nbsp;            detector.clearSensorContacts();</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int id : detector.getSensorContacts()) {</b>
<b class="nc">&nbsp;            Entity target = game.getEntity(id);</b>
&nbsp;            //The target should be removed if it&#39;s off the board for any of these reasons
<b class="nc">&nbsp;            if (target == null</b>
<b class="nc">&nbsp;                    || target.getPosition() == null</b>
<b class="nc">&nbsp;                    || target.isDestroyed()</b>
<b class="nc">&nbsp;                    || target.isDoomed()</b>
<b class="nc">&nbsp;                    || target.getTransportId() != Entity.NONE</b>
<b class="nc">&nbsp;                    || target.isPartOfFighterSquadron()</b>
<b class="nc">&nbsp;                    || target.isOffBoard()) {</b>
<b class="nc">&nbsp;                toRemove.add(id);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            //And now calculate whether or not the target has moved out of range. Per SO p117-119,
&nbsp;            //sensor contacts remain tracked on the plotting board until this occurs.
<b class="nc">&nbsp;            Coords targetPos = target.getPosition();</b>
<b class="nc">&nbsp;            int distance = detector.getPosition().distance(targetPos);</b>
<b class="nc">&nbsp;            if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</b>
<b class="nc">&nbsp;                toRemove.add(id);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        detector.removeSensorContact(toRemove);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *If the game is in space, &quot;visual range&quot; represents a firing solution as defined in SO starting on p117
&nbsp;     *Also, in most cases each target must be detected with sensors before it can be seen, so we need to make
&nbsp;     *sensor rolls for detection. This should only be used if Tacops sensor rules are in use.
&nbsp;     * This requires line of sight effects to determine if there are
&nbsp;     * certain intervening obstructions, like sensor shadows, asteroids and that sort of thing, that can reduce visual
&nbsp;     * range.  Since repeated LoSEffects computations can be expensive, it is
&nbsp;     * possible to pass in the LosEffects, since they are commonly already
&nbsp;     * computed when this method is called.
&nbsp;     *
&nbsp;     * @param game - the current game
&nbsp;     * @param ae - the entity making a sensor scan
&nbsp;     * @param target - the entity we&#39;re trying to spot
&nbsp;     * @return
&nbsp;     */
&nbsp;
&nbsp;    public static boolean calcFiringSolution(IGame game, Entity ae,
&nbsp;            Targetable target) {
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
<b class="nc">&nbsp;            if (te.isOffBoard()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //NPE check. Fighter squadrons don&#39;t start with sensors, but pick them up from the component fighters each round
<b class="nc">&nbsp;        if (ae.getActiveSensor() == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //ESM sensor can&#39;t produce a firing solution
<b class="nc">&nbsp;        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        Coords targetPos = target.getPosition();</b>
<b class="nc">&nbsp;        int distance = ae.getPosition().distance(targetPos);</b>
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        int tn = ae.getCrew().getPiloting();</b>
<b class="nc">&nbsp;        int autoVisualRange = 1;</b>
<b class="nc">&nbsp;        int outOfVisualRange = (ae.getActiveSensor().getRangeByBracket());</b>
<b class="nc">&nbsp;        int rangeIncrement = (int) Math.ceil(outOfVisualRange / 10.0);</b>
&nbsp;
&nbsp;        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn&#39;t know about Game or Entity
&nbsp;        //to do otherwise. We need to use the space range instead.
<b class="nc">&nbsp;        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</b>
<b class="nc">&nbsp;            outOfVisualRange = Sensor.ASF_RADAR_MAX_RANGE;</b>
<b class="nc">&nbsp;            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (distance &gt; outOfVisualRange) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ae instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero aero = (Aero) ae;</b>
&nbsp;            //Account for sensor damage
<b class="nc">&nbsp;            if (aero.isAeroSensorDestroyed()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                tn += aero.getSensorHits();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //Targets at 1/10 max range are automatically detected
<b class="nc">&nbsp;        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</b>
<b class="nc">&nbsp;            autoVisualRange = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</b>
<b class="nc">&nbsp;        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR) {</b>
<b class="nc">&nbsp;            autoVisualRange = Sensor.LC_RADAR_AUTOSPOT_RANGE;</b>
<b class="nc">&nbsp;        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL) {</b>
<b class="nc">&nbsp;            autoVisualRange = Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE;</b>
<b class="nc">&nbsp;        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL) {</b>
<b class="nc">&nbsp;            autoVisualRange = Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (distance &lt;= autoVisualRange) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Apply Sensor Geek SPA, if present
<b class="nc">&nbsp;        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</b>
<b class="nc">&nbsp;            tn -= 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Otherwise, we add +1 to the tn for detection for each increment of the autovisualrange between attacker and target
<b class="nc">&nbsp;        tn += (distance / rangeIncrement);</b>
&nbsp;
&nbsp;        // Apply ECM/ECCM effects
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            tn += calcSpaceECM(game, ae, target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Apply large craft sensor shadows
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</b>
<b class="nc">&nbsp;            tn += calcSensorShadow(game, ae, target);</b>
&nbsp;        }
&nbsp;
&nbsp;        //Apply modifiers for attacker&#39;s equipment
&nbsp;        //-2 for a working Large NCSS
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</b>
<b class="nc">&nbsp;            tn -= 2;</b>
&nbsp;        }
&nbsp;        //-1 for a working Small NCSS
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</b>
<b class="nc">&nbsp;            tn -= 1;</b>
&nbsp;        }
&nbsp;        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don&#39;t let the BAP check do that
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</b>
<b class="nc">&nbsp;                || ae.hasBAP(false)) {</b>
<b class="nc">&nbsp;            tn -= 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Now, determine if we&#39;ve detected the target this round
<b class="nc">&nbsp;        return roll &gt;= tn;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *Determines whether we have an &quot;object&quot; detection as defined in SO&#39;s Advanced Sensors rules starting on p117
&nbsp;     *
&nbsp;     * @param game - the current game
&nbsp;     * @param ae - the entity making a sensor scan
&nbsp;     * @param target - the entity we&#39;re trying to spot
&nbsp;     * @return
&nbsp;     */
&nbsp;
&nbsp;    public static boolean calcSensorContact(IGame game, Entity ae,
&nbsp;            Targetable target) {
&nbsp;
&nbsp;        //NPE check. Fighter squadrons don&#39;t start with sensors, but pick them up from the component fighters each round
<b class="nc">&nbsp;        if (ae.getActiveSensor() == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        Coords targetPos = target.getPosition();</b>
<b class="nc">&nbsp;        int distance = ae.getPosition().distance(targetPos);</b>
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;        int tn = ae.getCrew().getPiloting();</b>
<b class="nc">&nbsp;        int maxSensorRange = ae.getActiveSensor().getRangeByBracket();</b>
<b class="nc">&nbsp;        int rangeIncrement = (int) Math.ceil(maxSensorRange / 10.0);</b>
&nbsp;
&nbsp;        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn&#39;t know about Game or Entity
&nbsp;        //to do otherwise. We need to use the space range instead.
<b class="nc">&nbsp;        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</b>
<b class="nc">&nbsp;            maxSensorRange = Sensor.ASF_RADAR_MAX_RANGE;</b>
<b class="nc">&nbsp;            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ae instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero aero = (Aero) ae;</b>
&nbsp;            //Account for sensor damage
<b class="nc">&nbsp;            if (aero.isAeroSensorDestroyed()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                tn += aero.getSensorHits();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //Apply modifiers for attacker&#39;s equipment
&nbsp;        //-2 for a working Large NCSS.  Triple the detection range.
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</b>
<b class="nc">&nbsp;            maxSensorRange *= 3;</b>
<b class="nc">&nbsp;            tn -= 2;</b>
&nbsp;        }
&nbsp;        //-1 for a working Small NCSS. Double the detection range.
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</b>
<b class="nc">&nbsp;            maxSensorRange *= 2;</b>
<b class="nc">&nbsp;            tn -= 1;</b>
&nbsp;        }
&nbsp;        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don&#39;t let the BAP check do that
<b class="nc">&nbsp;        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</b>
<b class="nc">&nbsp;                || ae.hasBAP(false)) {</b>
<b class="nc">&nbsp;            tn -= 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Military ESM automatically detects anyone using active sensors, which includes all telemissiles
<b class="nc">&nbsp;        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
<b class="nc">&nbsp;            if (te.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</b>
<b class="nc">&nbsp;                    || te.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR</b>
&nbsp;                    || te instanceof TeleMissile) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Can&#39;t detect anything beyond this distance
<b class="nc">&nbsp;        if (distance &gt; maxSensorRange) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Apply Sensor Geek SPA, if present
<b class="nc">&nbsp;        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</b>
<b class="nc">&nbsp;            tn -= 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Otherwise, we add +1 to the tn for each 1/10 of the max sensor range (rounded up) between attacker and target
<b class="nc">&nbsp;        tn += (distance / rangeIncrement);</b>
&nbsp;
&nbsp;        // Apply ECM/ECCM effects
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            tn += calcSpaceECM(game, ae, target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Apply large craft sensor shadows
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</b>
<b class="nc">&nbsp;            tn += calcSensorShadow(game, ae, target);</b>
&nbsp;        }
&nbsp;
&nbsp;        //Now, determine if we&#39;ve detected the target this round
<b class="nc">&nbsp;        return roll &gt;= tn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int getVisualRange(IGame game, Entity ae, LosEffects los,
&nbsp;            boolean teIlluminated) {
<b class="nc">&nbsp;        int visualRange = game.getPlanetaryConditions().getVisualRange(ae,</b>
&nbsp;                teIlluminated);
<b class="nc">&nbsp;        visualRange -= los.getLightSmoke();</b>
<b class="nc">&nbsp;        visualRange -= 2 * los.getHeavySmoke();</b>
<b class="nc">&nbsp;        visualRange = Math.max(1, visualRange);</b>
<b class="nc">&nbsp;        return visualRange;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see whether the target is within sensor range (but not
&nbsp;     * necessarily LoS or visual range)
&nbsp;     *
&nbsp;     * @param allECMInfo A collection of ECMInfo for all entities, this value
&nbsp;     *                   can be null and it will be computed when it&#39;s
&nbsp;     *                   needed, however passing in the pre-computed
&nbsp;     *                   collection is much faster
&nbsp;     */
&nbsp;    public static boolean inSensorRange(IGame game, Entity ae,
&nbsp;            Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
<b class="nc">&nbsp;        return inSensorRange(game, null, ae, target, allECMInfo);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean inSensorRange(IGame game, LosEffects los, Entity ae,
&nbsp;            Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
&nbsp;        // This is not applicable to objects on the same team.
<b class="nc">&nbsp;        if(!target.isEnemyOf(ae)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //For Space games with this option, return something different
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</b>
<b class="nc">&nbsp;                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</b>
<b class="nc">&nbsp;                &amp;&amp; game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
<b class="nc">&nbsp;            return hasSensorContact(ae, te.getId());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if either does not have a position then return false
<b class="nc">&nbsp;        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we have no sensors then return false
<b class="nc">&nbsp;        if (ae.getActiveSensor() == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int bracket = Compute.getSensorRangeBracket(ae, target, allECMInfo);</b>
<b class="nc">&nbsp;        int range = Compute.getSensorRangeByBracket(game, ae, target, los);</b>
&nbsp;
<b class="nc">&nbsp;        int maxSensorRange = bracket * range;</b>
<b class="nc">&nbsp;        int minSensorRange = Math.max((bracket - 1) * range, 0);</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</b>
<b class="nc">&nbsp;            minSensorRange = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int distance = ae.getPosition().distance(target.getPosition());</b>
&nbsp;
&nbsp;        //Aeros have to check visibility to ground targets for the closest point of approach along their flight path
&nbsp;        //Because the rules state &quot;within X hexes of the flight path&quot; we&#39;re using ground distance so altitude doesn&#39;t screw us up
<b class="nc">&nbsp;        if (isAirToGround(ae, target) &amp;&amp; (target instanceof Entity)) {</b>
<b class="nc">&nbsp;            Entity te = (Entity) target;</b>
<b class="nc">&nbsp;            distance = te.getPosition().distance(</b>
<b class="nc">&nbsp;                    getClosestFlightPath(te.getId(),</b>
<b class="nc">&nbsp;                            te.getPosition(), (Entity) ae));</b>
<b class="nc">&nbsp;            return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</b>
&nbsp;        }
&nbsp;        //This didn&#39;t work right for Aeros. Should account for the difference in altitude, not just add the target&#39;s altitude to distance
<b class="nc">&nbsp;        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</b>
&nbsp;
&nbsp;        // if this is an air-to-air scan on the ground map, then divide distance by 16 to match weapon ranges
&nbsp;        // I purposely left this calculation out of visual spotting, so we should do some testing with this and
&nbsp;        // see if it&#39;s errata-worthy. The idea is that you&#39;ll boost sensor range to help find an enemy aero on the map
&nbsp;        // but still won&#39;t be able to see it and shoot at it beyond normal visual conditions.
<b class="nc">&nbsp;        if (isAirToAir(ae, target) &amp;&amp; game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            distance = (int) Math.ceil(distance / 16.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if the target is visible to the unit, always considering
&nbsp;     * sensors.
&nbsp;     */
&nbsp;    public static boolean canSee(IGame game, Entity ae, Targetable target) {
<b class="nc">&nbsp;        return canSee(game, ae, target, true, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if the target is visible to the unit, if the sensor flag
&nbsp;     * is true then sensors are checked as well.
&nbsp;     */
&nbsp;    public static boolean canSee(IGame game, Entity ae, Targetable target,
&nbsp;            boolean useSensors, LosEffects los, List&lt;ECMInfo&gt; allECMInfo) {
&nbsp;
<b class="nc">&nbsp;        if (!ae.getCrew().isActive()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (target.isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (los == null) {</b>
<b class="nc">&nbsp;            los = LosEffects.calculateLos(game, ae.getId(), target);</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean isVisible = los.canSee()</b>
<b class="nc">&nbsp;                            &amp;&amp; Compute.inVisualRange(game, los, ae, target);</b>
<b class="nc">&nbsp;        if (useSensors) {</b>
<b class="nc">&nbsp;            isVisible = isVisible</b>
<b class="nc">&nbsp;                    || Compute.inSensorRange(game, los, ae, target, allECMInfo);</b>
&nbsp;        }
<b class="nc">&nbsp;        return isVisible;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * gets the sensor range bracket when detecting a particular type of target.
&nbsp;     * target may be null here, which gives you the bracket without target
&nbsp;     * entity modifiers
&nbsp;     *
&nbsp;     * @param allECMInfo A collection of ECMInfo for all entities, this value
&nbsp;     *                   can be null and it will be computed when it&#39;s
&nbsp;     *                   needed, however passing in the pre-computed
&nbsp;     *                   collection is much faster
&nbsp;     */
&nbsp;    public static int getSensorRangeBracket(Entity ae, Targetable target,
&nbsp;                                            List&lt;ECMInfo&gt; allECMInfo) {
&nbsp;
<b class="nc">&nbsp;        Sensor sensor = ae.getActiveSensor();</b>
<b class="nc">&nbsp;        if (null == sensor) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        // only works for entities
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (null != target) {</b>
<b class="nc">&nbsp;            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if this sensor is an active probe and it is critted, then no can see
<b class="nc">&nbsp;        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        //In space, sensors don&#39;t have brackets, so we should always return the range for bracket 1.
<b class="nc">&nbsp;        if (ae.isSpaceborne()) {</b>
<b class="nc">&nbsp;            return Compute.getSensorBracket(7);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int check = ae.getSensorCheck();</b>
<b class="nc">&nbsp;        if ((null != ae.getCrew()) &amp;&amp; ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</b>
<b class="nc">&nbsp;            check -= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (null != te) {</b>
<b class="nc">&nbsp;            check += sensor.getModsForStealth(te);</b>
&nbsp;            // Metal Content...
<b class="nc">&nbsp;            if (ae.getGame().getOptions().booleanOption(OptionsConstants.ADVANCED_METAL_CONTENT)) {</b>
<b class="nc">&nbsp;                check += sensor.getModForMetalContent(ae, te);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // ECM bubbles
<b class="nc">&nbsp;        check += sensor.getModForECM(ae, allECMInfo);</b>
&nbsp;
<b class="nc">&nbsp;        return Compute.getSensorBracket(check);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns the brackets for sensor checks
&nbsp;     */
&nbsp;    public static int getSensorBracket(int check) {
&nbsp;        // get the range bracket (0 - none; 1 - short; 2 - medium; 3 - long)
<b class="nc">&nbsp;        int bracket = 0;</b>
<b class="nc">&nbsp;        if ((check == 7) || (check == 8)) {</b>
<b class="nc">&nbsp;            bracket = 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((check == 5) || (check == 6)) {</b>
<b class="nc">&nbsp;            bracket = 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (check &lt; 5) {</b>
<b class="nc">&nbsp;            bracket = 3;</b>
&nbsp;        }
<b class="nc">&nbsp;        return bracket;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * gets the size of the sensor range bracket when detecting a particular
&nbsp;     * type of target. target may be null here, which gives you the range
&nbsp;     * without target entity modifiers
&nbsp;     */
&nbsp;    public static int getSensorRangeByBracket(IGame game, Entity ae,
&nbsp;            Targetable target, LosEffects los) {
<b class="nc">&nbsp;        if (los == null) {</b>
<b class="nc">&nbsp;            los = LosEffects.calculateLos(game, ae.getId(), target);</b>
&nbsp;        }
<b class="nc">&nbsp;        Sensor sensor = ae.getActiveSensor();</b>
<b class="nc">&nbsp;        if (null == sensor) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        // only works for entities
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (null != target) {</b>
<b class="nc">&nbsp;            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if this sensor is an active probe and it is critted, then no can see
<b class="nc">&nbsp;        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we are crossing water then only magscan will work unless we are a
&nbsp;        // naval vessel
<b class="nc">&nbsp;        if ((null != te) &amp;&amp; los.isBlockedByWater()</b>
<b class="nc">&nbsp;            &amp;&amp; (sensor.getType() != Sensor.TYPE_MEK_MAGSCAN)</b>
<b class="nc">&nbsp;            &amp;&amp; (sensor.getType() != Sensor.TYPE_VEE_MAGSCAN)</b>
<b class="nc">&nbsp;            &amp;&amp; (ae.getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;            &amp;&amp; (ae.getMovementMode() != EntityMovementMode.NAVAL)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // now get the range
<b class="nc">&nbsp;        int range = sensor.getRangeByBracket();</b>
&nbsp;
&nbsp;        // adjust the range based on LOS and planetary conditions
<b class="nc">&nbsp;        range = sensor.adjustRange(range, game, los);</b>
&nbsp;
&nbsp;        //If we&#39;re an airborne aero, sensor range is limited to within a few hexes of the flightline against ground targets
&nbsp;        //TO Dec 2017 Errata p17
<b class="nc">&nbsp;        if (te != null &amp;&amp; ae.isAirborne() &amp;&amp; !te.isAirborne()) {</b>
&nbsp;            //Can&#39;t see anything if above Alt 8.
<b class="nc">&nbsp;            if (ae.getAltitude() &gt; 8) {</b>
<b class="nc">&nbsp;                range = 0;</b>
<b class="nc">&nbsp;            } else if (sensor.isBAP()) {</b>
&nbsp;            //Add 1 to range for active probe of any type
<b class="nc">&nbsp;                range = 2;</b>
&nbsp;            } else {
&nbsp;            //Basic sensor range listed in errata
<b class="nc">&nbsp;                range = 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            return range;</b>
&nbsp;        }
&nbsp;
&nbsp;        // now adjust for anything about the target entity (size, heat, etc)
<b class="nc">&nbsp;        if (null != te) {</b>
<b class="nc">&nbsp;            range = sensor.entityAdjustments(range, te, game);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (range &lt; 0) {</b>
<b class="nc">&nbsp;            range = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return range;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static int targetSideTable(Coords inPosition, Targetable target) {
<b class="nc">&nbsp;        return target.sideTable(inPosition);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int targetSideTable(Entity attacker, Targetable target) {
<b class="nc">&nbsp;        return Compute</b>
<b class="nc">&nbsp;                .targetSideTable(attacker, target, CalledShot.CALLED_NONE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int targetSideTable(Entity attacker, Targetable target,
&nbsp;                                      int called) {
<b class="nc">&nbsp;        Coords attackPos = attacker.getPosition();</b>
&nbsp;
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target instanceof Entity) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean usePrior = false;</b>
&nbsp;        // aeros in the same hex need to adjust position to get side
&nbsp;        // table
<b class="nc">&nbsp;        if (isAirToAir(attacker, target)</b>
<b class="nc">&nbsp;            &amp;&amp; attackPos.equals(target.getPosition())</b>
<b class="nc">&nbsp;            &amp;&amp; attacker.isAero() &amp;&amp; target.isAero()) {</b>
<b class="nc">&nbsp;            int moveSort = shouldMoveBackHex(attacker, (Entity)target);</b>
<b class="nc">&nbsp;            if (moveSort &lt; 0) {</b>
<b class="nc">&nbsp;                attackPos = attacker.getPriorPosition();</b>
&nbsp;            }
<b class="nc">&nbsp;            usePrior = moveSort &gt; 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if this is a air to ground attack, then attacker position is given by
&nbsp;        // the direction from which they entered the target hex
<b class="nc">&nbsp;        if (isAirToGround(attacker, target)) {</b>
<b class="nc">&nbsp;            attackPos = attacker.passedThroughPrevious(target.getPosition());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isGroundToAir(attacker, target) &amp;&amp; (null != te)) {</b>
<b class="nc">&nbsp;            int facing = Compute.getClosestFlightPathFacing(attacker.getId(),</b>
&nbsp;                    attackPos, te);
<b class="nc">&nbsp;            Coords pos = Compute.getClosestFlightPath(attacker.getId(),</b>
&nbsp;                    attackPos, te);
<b class="nc">&nbsp;            return te.sideTable(attackPos, usePrior, facing, pos);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((null != te) &amp;&amp; (called == CalledShot.CALLED_LEFT)) {</b>
<b class="nc">&nbsp;            return te.sideTable(attackPos, usePrior, (te.getFacing() + 5) % 6);</b>
<b class="nc">&nbsp;        } else if ((null != te) &amp;&amp; (called == CalledShot.CALLED_RIGHT)) {</b>
<b class="nc">&nbsp;            return te.sideTable(attackPos, usePrior, (te.getFacing() + 1) % 6);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return target.sideTable(attackPos, usePrior);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * Compares the initiative of two aerospace units in the same hex to determine attack angle.
&nbsp;         * The attack angle is computed as if the unit with the higher initiative were in its previous hex.
&nbsp;         *
&nbsp;         * @param e1 The first &lt;code&gt;Entity&lt;/code&gt; to compare
&nbsp;         * @param e2 The second &lt;code&gt;Entity&lt;/code&gt; to compare
&nbsp;         * @return &lt; 0 if the first unit has a higher initiative, &gt; 0 if the second is higher,
&nbsp;         *         or 0 if one of the units is not an aerospace unit, does not have a valid position,
&nbsp;         *         or the two units are not in the same hex.
&nbsp;         */
&nbsp;    public static int shouldMoveBackHex(Entity e1, Entity e2) {
<b class="nc">&nbsp;        if (null == e1.getPosition() || null == e2.getPosition()</b>
<b class="nc">&nbsp;                || !e1.getPosition().equals(e2.getPosition())</b>
<b class="nc">&nbsp;                || !e1.isAero() || !e2.isAero()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int retVal = e1.getUnitType() - e2.getUnitType();</b>
<b class="nc">&nbsp;        if (retVal == 0) {</b>
<b class="nc">&nbsp;            retVal = ((IAero)e2).getCurrentVelocity() -</b>
<b class="nc">&nbsp;                    ((IAero)e1).getCurrentVelocity();</b>
&nbsp;        }
&nbsp;        // if all criteria are the same, select randomly
<b class="nc">&nbsp;        if (retVal == 0) {</b>
<b class="nc">&nbsp;            retVal = d6() &lt; 4? -1 : 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maintain backwards compatability.
&nbsp;     *
&nbsp;     * @param missiles - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
&nbsp;     */
&nbsp;    public static int missilesHit(int missiles) {
<b class="nc">&nbsp;        return Compute.missilesHit(missiles, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maintain backwards compatability.
&nbsp;     *
&nbsp;     * @param missiles
&nbsp;     * @param nMod
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static int missilesHit(int missiles, int nMod) {
<b class="nc">&nbsp;        return Compute.missilesHit(missiles, nMod, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maintain backwards compatability.
&nbsp;     *
&nbsp;     * @param missiles
&nbsp;     * @param nMod
&nbsp;     * @param hotloaded
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static int missilesHit(int missiles, int nMod, boolean hotloaded) {
<b class="nc">&nbsp;        return Compute.missilesHit(missiles, nMod, hotloaded, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Roll the number of missiles (or whatever) on the missile hit table, with
&nbsp;     * the specified mod to the roll.
&nbsp;     *
&nbsp;     * @param missiles    - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
&nbsp;     * @param nMod        - the &lt;code&gt;int&lt;/code&gt; modifier to the roll for number of
&nbsp;     *                    missiles that hit.
&nbsp;     * @param hotloaded   - roll 3d6 take worst 2
&nbsp;     * @param streak      - force a roll of 11 on the cluster table
&nbsp;     * @param advancedAMS - the roll can now go below 2, indicating no damage
&nbsp;     */
&nbsp;    public static int missilesHit(int missiles, int nMod, boolean hotloaded,
&nbsp;                                  boolean streak, boolean advancedAMS) {
<b class="nc">&nbsp;        int nRoll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;        if (hotloaded) {</b>
<b class="nc">&nbsp;            int roll1 = Compute.d6();</b>
<b class="nc">&nbsp;            int roll2 = Compute.d6();</b>
<b class="nc">&nbsp;            int roll3 = Compute.d6();</b>
<b class="nc">&nbsp;            int lowRoll1 = 0;</b>
<b class="nc">&nbsp;            int lowRoll2 = 0;</b>
&nbsp;
<b class="nc">&nbsp;            if ((roll1 &lt;= roll2) &amp;&amp; (roll1 &lt;= roll3)) {</b>
<b class="nc">&nbsp;                lowRoll1 = roll1;</b>
<b class="nc">&nbsp;                lowRoll2 = Math.min(roll2, roll3);</b>
<b class="nc">&nbsp;            } else if ((roll2 &lt;= roll1) &amp;&amp; (roll2 &lt;= roll3)) {</b>
<b class="nc">&nbsp;                lowRoll1 = roll2;</b>
<b class="nc">&nbsp;                lowRoll2 = Math.min(roll1, roll3);</b>
<b class="nc">&nbsp;            } else if ((roll3 &lt;= roll1) &amp;&amp; (roll3 &lt;= roll2)) {</b>
<b class="nc">&nbsp;                lowRoll1 = roll3;</b>
<b class="nc">&nbsp;                lowRoll2 = Math.min(roll2, roll1);</b>
&nbsp;            }
<b class="nc">&nbsp;            nRoll = lowRoll1 + lowRoll2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (streak) {</b>
<b class="nc">&nbsp;            nRoll = 11;</b>
&nbsp;        }
<b class="nc">&nbsp;        nRoll += nMod;</b>
<b class="nc">&nbsp;        if (!advancedAMS) {</b>
<b class="nc">&nbsp;            nRoll = Math.min(Math.max(nRoll, 2), 12);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            nRoll = Math.min(nRoll, 12);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (nRoll &lt; 2) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int[] element : clusterHitsTable) {</b>
<b class="nc">&nbsp;            if (element[0] == missiles) {</b>
<b class="nc">&nbsp;                return element[nRoll - 1];</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // BA missiles may have larger number of missiles than max entry on the
&nbsp;        // table
&nbsp;        // if so, take largest, subtract value and try again
<b class="nc">&nbsp;        for (int i = clusterHitsTable.length - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            if (missiles &gt; clusterHitsTable[i][0]) {</b>
<b class="nc">&nbsp;                return clusterHitsTable[i][nRoll - 1]</b>
<b class="nc">&nbsp;                       + Compute.missilesHit(</b>
&nbsp;                        missiles - clusterHitsTable[i][0], nMod,
&nbsp;                        hotloaded, streak, advancedAMS);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        throw new RuntimeException(</b>
&nbsp;                &quot;Could not find number of missiles in hit table&quot;);
&nbsp;    }
&nbsp;
&nbsp;    public static int calculateClusterHitTableAmount(int roll, int rackSize) {
<b class="nc">&nbsp;        for (int[] element : clusterHitsTable) {</b>
<b class="nc">&nbsp;            if (element[0] == rackSize) {</b>
<b class="nc">&nbsp;                return element[roll - 1];</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the consciousness roll number
&nbsp;     *
&nbsp;     * @param hit - the &lt;code&gt;int&lt;/code&gt; number of the crew hit currently being
&nbsp;     *            rolled.
&nbsp;     * @return The &lt;code&gt;int&lt;/code&gt; number that must be rolled on 2d6 for the
&nbsp;     * crew to stay conscious.
&nbsp;     */
&nbsp;    public static int getConsciousnessNumber(int hit) {
<b class="nc">&nbsp;        switch (hit) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                return 2;</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                return 3;</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                return 5;</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                return 7;</b>
&nbsp;            case 4:
<b class="nc">&nbsp;                return 10;</b>
&nbsp;            case 5:
<b class="nc">&nbsp;                return 11;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return Integer.MAX_VALUE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for ferrous metal content in terrain on path from a to b return the
&nbsp;     * total content.
&nbsp;     */
&nbsp;    public static int getMetalInPath(Entity ae, Coords a, Coords b) {
&nbsp;        // If we&#39;re in space, or anything is null... get out.
<b class="nc">&nbsp;        if ((ae == null) || (a == null) || (b == null)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        IBoard board = ae.getGame().getBoard();</b>
<b class="nc">&nbsp;        if (board.inSpace()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!board.contains(a) || !board.contains(b)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // get intervening Coords.
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</b>
&nbsp;        // loop through all intervening coords, check each if they are ECM
&nbsp;        // affected
<b class="nc">&nbsp;        int metalContent = 0;</b>
<b class="nc">&nbsp;        for (Coords c : coords) {</b>
<b class="nc">&nbsp;            IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;            if (hex != null &amp;&amp; hex.containsTerrain(Terrains.METAL_CONTENT)) {</b>
<b class="nc">&nbsp;                metalContent += hex.terrainLevel(Terrains.METAL_CONTENT);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return metalContent;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for ECM bubbles in Ghost Target mode along the path from a to b and
&nbsp;     * return the highest target roll. -1 if no Ghost Targets
&nbsp;     */
&nbsp;    public static int getGhostTargetNumber(Entity ae, Coords a, Coords b) {
<b class="nc">&nbsp;        if (ae.getGame().getBoard().inSpace()) {</b>
&nbsp;            // ghost targets don&#39;t work in space
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((a == null) || (b == null)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Only grab enemies with active ECM
&nbsp;        // need to create two hashtables for ghost targeting, one with mods
&nbsp;        // and one with booleans indicating that this ghost target was
&nbsp;        // intersected
&nbsp;        // the keys will be the entity id
<b class="nc">&nbsp;        Hashtable&lt;Integer, Boolean&gt; hEnemyGTCrossed = new Hashtable&lt;Integer, Boolean&gt;();</b>
<b class="nc">&nbsp;        Hashtable&lt;Integer, Integer&gt; hEnemyGTMods = new Hashtable&lt;Integer, Integer&gt;();</b>
<b class="nc">&nbsp;        Vector&lt;Coords&gt; vEnemyECCMCoords = new Vector&lt;Coords&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Integer&gt; vEnemyECCMRanges = new Vector&lt;Integer&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Double&gt; vEnemyECCMStrengths = new Vector&lt;Double&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Coords&gt; vEnemyGTCoords = new Vector&lt;Coords&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Integer&gt; vEnemyGTRanges = new Vector&lt;Integer&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Integer&gt; vEnemyGTId = new Vector&lt;Integer&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Coords&gt; vFriendlyECMCoords = new Vector&lt;Coords&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Integer&gt; vFriendlyECMRanges = new Vector&lt;Integer&gt;(16);</b>
<b class="nc">&nbsp;        Vector&lt;Double&gt; vFriendlyECMStrengths = new Vector&lt;Double&gt;(16);</b>
<b class="nc">&nbsp;        for (Entity ent : ae.getGame().getEntitiesVector()) {</b>
<b class="nc">&nbsp;            Coords entPos = ent.getPosition();</b>
<b class="nc">&nbsp;            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasGhostTargets(true)</b>
&nbsp;                &amp;&amp; (entPos != null)) {
<b class="nc">&nbsp;                vEnemyGTCoords.addElement(entPos);</b>
<b class="nc">&nbsp;                vEnemyGTRanges.addElement(ent.getECMRange());</b>
<b class="nc">&nbsp;                vEnemyGTId.addElement(ent.getId());</b>
<b class="nc">&nbsp;                hEnemyGTCrossed.put(ent.getId(), false);</b>
<b class="nc">&nbsp;                hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECCM() &amp;&amp; (entPos != null)) {</b>
<b class="nc">&nbsp;                vEnemyECCMCoords.addElement(entPos);</b>
<b class="nc">&nbsp;                vEnemyECCMRanges.addElement(ent.getECMRange());</b>
<b class="nc">&nbsp;                vEnemyECCMStrengths.add(ent.getECCMStrength());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM() &amp;&amp; (entPos != null)) {</b>
<b class="nc">&nbsp;                vFriendlyECMCoords.addElement(entPos);</b>
<b class="nc">&nbsp;                vFriendlyECMRanges.addElement(ent.getECMRange());</b>
<b class="nc">&nbsp;                vFriendlyECMStrengths.add(ent.getECMStrength());</b>
&nbsp;            }
&nbsp;
&nbsp;            // Check the ECM effects of the entity&#39;s passengers.
<b class="nc">&nbsp;            for (Entity other : ent.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                if (other.isEnemyOf(ae) &amp;&amp; other.hasGhostTargets(true)</b>
&nbsp;                    &amp;&amp; (entPos != null)) {
<b class="nc">&nbsp;                    vEnemyGTCoords.addElement(entPos);</b>
<b class="nc">&nbsp;                    vEnemyGTRanges.addElement(other.getECMRange());</b>
<b class="nc">&nbsp;                    vEnemyGTId.addElement(ent.getId());</b>
<b class="nc">&nbsp;                    hEnemyGTCrossed.put(ent.getId(), false);</b>
<b class="nc">&nbsp;                    hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (other.isEnemyOf(ae) &amp;&amp; other.hasActiveECCM()</b>
&nbsp;                    &amp;&amp; (entPos != null)) {
<b class="nc">&nbsp;                    vEnemyECCMCoords.addElement(entPos);</b>
<b class="nc">&nbsp;                    vEnemyECCMRanges</b>
<b class="nc">&nbsp;                            .addElement(other.getECMRange());</b>
<b class="nc">&nbsp;                    vEnemyECCMStrengths.add(ent.getECCMStrength());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!other.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM()</b>
&nbsp;                    &amp;&amp; (entPos != null)) {
<b class="nc">&nbsp;                    vFriendlyECMCoords.addElement(entPos);</b>
<b class="nc">&nbsp;                    vFriendlyECMRanges</b>
<b class="nc">&nbsp;                            .addElement(ent.getECMRange());</b>
<b class="nc">&nbsp;                    vFriendlyECMStrengths.add(ent.getECMStrength());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // none? get out of here
<b class="nc">&nbsp;        if (vEnemyGTCoords.size() == 0) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
&nbsp;        // get intervening Coords.
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</b>
&nbsp;        // loop through all intervening coords, if they are not ecm&#39;ed by
&nbsp;        // friendlys then add any Ghost Targets
&nbsp;        // to the hashlist
&nbsp;        // According to the rules clarification below ECM cancels Ghost Targets
&nbsp;        // http://www.classicbattletech.com/forums/index.php/topic,66035.new.html#new
<b class="nc">&nbsp;        for (Coords c : coords) {</b>
&nbsp;            // &gt;0: in friendly ECM
&nbsp;            // &lt;=0: not in friendly ECM
<b class="nc">&nbsp;            int ecmStatus = 0;</b>
&nbsp;            // first, add 1 for each friendly ECM that affects us
<b class="nc">&nbsp;            Enumeration&lt;Integer&gt; ranges = vFriendlyECMRanges.elements();</b>
<b class="nc">&nbsp;            Enumeration&lt;Double&gt; strengths = vFriendlyECMStrengths.elements();</b>
<b class="nc">&nbsp;            for (Coords friendlyECMCoords : vFriendlyECMCoords) {</b>
<b class="nc">&nbsp;                int range = ranges.nextElement().intValue();</b>
<b class="nc">&nbsp;                int nDist = c.distance(friendlyECMCoords);</b>
<b class="nc">&nbsp;                double strength = strengths.nextElement().doubleValue();</b>
<b class="nc">&nbsp;                if (nDist &lt;= range) {</b>
<b class="nc">&nbsp;                    ecmStatus += strength;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // now, subtract one for each enemy ECCM
<b class="nc">&nbsp;            ranges = vEnemyECCMRanges.elements();</b>
<b class="nc">&nbsp;            strengths = vEnemyECCMStrengths.elements();</b>
<b class="nc">&nbsp;            for (Coords enemyECCMCoords : vEnemyECCMCoords) {</b>
<b class="nc">&nbsp;                int range = ranges.nextElement().intValue();</b>
<b class="nc">&nbsp;                int nDist = c.distance(enemyECCMCoords);</b>
<b class="nc">&nbsp;                double strength = strengths.nextElement().doubleValue();</b>
<b class="nc">&nbsp;                if (nDist &lt;= range) {</b>
<b class="nc">&nbsp;                    ecmStatus -= strength;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (ecmStatus &lt; 1) {</b>
&nbsp;                // find any new Ghost Targets that we have crossed
<b class="nc">&nbsp;                ranges = vEnemyGTRanges.elements();</b>
<b class="nc">&nbsp;                Enumeration&lt;Integer&gt; ids = vEnemyGTId.elements();</b>
<b class="nc">&nbsp;                for (Coords enemyGTCoords : vEnemyGTCoords) {</b>
<b class="nc">&nbsp;                    int range = ranges.nextElement().intValue();</b>
<b class="nc">&nbsp;                    int id = ids.nextElement().intValue();</b>
<b class="nc">&nbsp;                    int nDist = c.distance(enemyGTCoords);</b>
<b class="nc">&nbsp;                    if ((nDist &lt;= range) &amp;&amp; !hEnemyGTCrossed.get(id)) {</b>
<b class="nc">&nbsp;                        hEnemyGTCrossed.put(id, true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // ok so now we have a hashtable that tells us which Ghost Targets have
&nbsp;        // been crossed
&nbsp;        // lets loop through that and identify the highest bonus and count the
&nbsp;        // total number crossed
<b class="nc">&nbsp;        int totalGT = -1;</b>
<b class="nc">&nbsp;        int highestMod = -1;</b>
<b class="nc">&nbsp;        Enumeration&lt;Integer&gt; ids = hEnemyGTCrossed.keys();</b>
<b class="nc">&nbsp;        while (ids.hasMoreElements()) {</b>
<b class="nc">&nbsp;            int id = ids.nextElement();</b>
<b class="nc">&nbsp;            if (hEnemyGTCrossed.get(id)) {</b>
<b class="nc">&nbsp;                totalGT++;</b>
<b class="nc">&nbsp;                if (hEnemyGTMods.get(id) &gt; highestMod) {</b>
<b class="nc">&nbsp;                    highestMod = hEnemyGTMods.get(id);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // according to the following rules clarification, this should be maxed
&nbsp;        // out at +4
&nbsp;        // http://www.classicbattletech.com/forums/index.php?topic=66036.0
<b class="nc">&nbsp;        return Math.min(4, highestMod + totalGT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the base to-hit number of a space bomb attack by the given attacker
&nbsp;     * upon the given defender
&nbsp;     *
&nbsp;     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
&nbsp;     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
&nbsp;     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
&nbsp;     */
&nbsp;    public static ToHitData getSpaceBombBaseToHit(Entity attacker,
&nbsp;                                                  Entity defender, IGame game) {
<b class="nc">&nbsp;        int base = TargetRoll.IMPOSSIBLE;</b>
<b class="nc">&nbsp;        StringBuffer reason = new StringBuffer();</b>
&nbsp;
<b class="nc">&nbsp;        if (!attacker.isAero()) {</b>
<b class="nc">&nbsp;            return new ToHitData(base, &quot;attacker is not an Aero&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IAero a = (IAero) attacker;</b>
&nbsp;
&nbsp;        // the fighters nose must be aligned with its direction of travel
<b class="nc">&nbsp;        boolean rightFacing = false;</b>
&nbsp;        // using normal movement, I think this means that the last move can&#39;t be
&nbsp;        // a turn
<b class="nc">&nbsp;        if (!game.useVectorMove()) {</b>
<b class="nc">&nbsp;            rightFacing = true;</b>
&nbsp;        }
&nbsp;        // for advanced movement, it must be aligned with largest vector
<b class="nc">&nbsp;        if (game.useVectorMove()) {</b>
<b class="nc">&nbsp;            for (int h : attacker.getHeading()) {</b>
<b class="nc">&nbsp;                if (h == attacker.facing) {</b>
<b class="nc">&nbsp;                    rightFacing = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean canTarget = false;</b>
<b class="nc">&nbsp;        Coords attackCoords = null;</b>
<b class="nc">&nbsp;        for (Coords c : attacker.getPassedThrough()) {</b>
<b class="nc">&nbsp;            for (Entity target : game.getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                if (target.getId() == defender.getId()) {</b>
<b class="nc">&nbsp;                    canTarget = true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (canTarget) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            attackCoords = c;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (null == attackCoords) {</b>
<b class="nc">&nbsp;            attackCoords = attacker.getPosition();</b>
&nbsp;        }
&nbsp;
&nbsp;        // must be in control
<b class="nc">&nbsp;        if (a.isOutControlTotal()) {</b>
<b class="nc">&nbsp;            reason.append(&quot;the attacker is out of control&quot;);</b>
<b class="nc">&nbsp;        } else if (attacker.getBombs(AmmoType.F_SPACE_BOMB).size() &lt; 1) {</b>
<b class="nc">&nbsp;            reason.append(&quot;the attacker has no useable bombs&quot;);</b>
<b class="nc">&nbsp;        } else if (!rightFacing) {</b>
<b class="nc">&nbsp;            reason.append(&quot;the attacker is not facing the direction of travel&quot;);</b>
&nbsp;        }
&nbsp;        // attacker and defender must both be in space hex
<b class="nc">&nbsp;        else if (!game.getBoard().getHex(attacker.getPosition())</b>
<b class="nc">&nbsp;                      .containsTerrain(Terrains.SPACE)) {</b>
<b class="nc">&nbsp;            reason.append(&quot;attacker not in space hex&quot;);</b>
<b class="nc">&nbsp;        } else if (!game.getBoard().getHex(defender.getPosition())</b>
<b class="nc">&nbsp;                        .containsTerrain(Terrains.SPACE)) {</b>
<b class="nc">&nbsp;            reason.append(&quot;defender not in space hex&quot;);</b>
<b class="nc">&nbsp;        } else if (!canTarget) {</b>
<b class="nc">&nbsp;            reason.append(&quot;defender is not in hex passed through by attacker this turn&quot;);</b>
&nbsp;        }
&nbsp;        // the defender must weight 10000+ tons
<b class="nc">&nbsp;        else if (defender.weight &lt; 10000) {</b>
<b class="nc">&nbsp;            reason.append(&quot;the defender weighs less than 10,000 tons&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // ok if we are still alive then lets calculate the tohit
&nbsp;        else {
<b class="nc">&nbsp;            base = attacker.getCrew().getGunnery();</b>
<b class="nc">&nbsp;            reason.append(&quot;base&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData(base, reason.toString(),</b>
<b class="nc">&nbsp;                                        ToHitData.HIT_NORMAL, defender.sideTable(attackCoords));</b>
&nbsp;
<b class="nc">&nbsp;        toHit.addModifier(+4, &quot;space bomb attack&quot;);</b>
<b class="nc">&nbsp;        if (attacker.mpUsed &gt; 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(attacker.mpUsed, &quot;attacker thrust&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (defender.mpUsed &gt; 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(defender.mpUsed, &quot;defender thrust&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((defender instanceof SpaceStation) || (defender.getWalkMP() == 0)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-4, &quot;immobile&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (defender.weight &lt; 100000) {</b>
<b class="nc">&nbsp;            int penalty = (int) Math.ceil((100000 - defender.weight) / 10000);</b>
<b class="nc">&nbsp;            toHit.addModifier(penalty, &quot;defender weight&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static ToHitData getAntiMechMods(ToHitData data, Infantry attacker,
&nbsp;                                             Entity defender) {
<b class="nc">&nbsp;        if (attacker == null) {</b>
<b class="nc">&nbsp;            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown attacker&quot;);</b>
<b class="nc">&nbsp;            return data;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (defender == null) {</b>
<b class="nc">&nbsp;            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown defender&quot;);</b>
<b class="nc">&nbsp;            return data;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (attacker instanceof BattleArmor) {</b>
&nbsp;            // Battle Armor units can&#39;t do an AM Attack if they&#39;re burdened.
<b class="nc">&nbsp;            if (((BattleArmor) attacker).isBurdened()) {</b>
<b class="nc">&nbsp;                data.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                 &quot;Launcher not jettisoned.&quot;);
<b class="nc">&nbsp;                return data;</b>
&nbsp;            }
&nbsp;            // BA units that jumped using mechanical jump boosters can&#39;t attack
<b class="nc">&nbsp;            if (attacker.hasWorkingMisc(MiscType.F_MECHANICAL_JUMP_BOOSTER)</b>
&nbsp;                // we used a mechanical jump booster for jumping only if we
&nbsp;                // don&#39;t have normal JJs, or if we are underwater-capable
&nbsp;                // because we underwatercapable BAs can only jump via
&nbsp;                // mechanical jump boosters
&nbsp;                // otherwise, normal JJs give the same MP and do not have
&nbsp;                // this restriction
<b class="nc">&nbsp;                &amp;&amp; ((attacker.getOriginalJumpMP() == 0) || (attacker</b>
<b class="nc">&nbsp;                                                                    .getMovementMode() == EntityMovementMode.INF_UMU))</b>
&nbsp;                &amp;&amp; (attacker.moved == EntityMovementType.MOVE_JUMP)) {
<b class="nc">&nbsp;                data.addModifier(</b>
&nbsp;                        TargetRoll.IMPOSSIBLE,
&nbsp;                        &quot;can&#39;t jump using mechanical jump booster and anti-mech attack in the same turn&quot;);
<b class="nc">&nbsp;                return data;</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // Infantry can&#39;t have encumbering armor
<b class="nc">&nbsp;            if (attacker.isArmorEncumbering()) {</b>
<b class="nc">&nbsp;                data.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                 &quot;can&#39;t engage in anti-mek attacks with encumbering armor.&quot;);
<b class="nc">&nbsp;                return data;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t target a transported entity.
<b class="nc">&nbsp;        if (Entity.NONE != defender.getTransportId()) {</b>
<b class="nc">&nbsp;            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is a passenger.&quot;);</b>
<b class="nc">&nbsp;            return data;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (defender.isMakingDfa()) {</b>
<b class="nc">&nbsp;            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is making a DFA.&quot;);</b>
<b class="nc">&nbsp;            return data;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Already conducting a swarm attack.
<b class="nc">&nbsp;        if (Entity.NONE != attacker.getSwarmTargetId()) {</b>
<b class="nc">&nbsp;            data.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                             &quot;Attacker is currently swarming.&quot;);
<b class="nc">&nbsp;            return data;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((defender instanceof Mech) &amp;&amp; ((Mech) defender).isIndustrial()) {</b>
<b class="nc">&nbsp;            data.addModifier(-1, &quot;targeting industrial mech&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // protected/exposed actuator quirk may adjust target roll
<b class="nc">&nbsp;        if (defender.hasQuirk(OptionsConstants.QUIRK_POS_PRO_ACTUATOR)) {</b>
<b class="nc">&nbsp;            data.addModifier(+1, &quot;protected actuators&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (defender.hasQuirk(OptionsConstants.QUIRK_NEG_EXP_ACTUATOR)) {</b>
<b class="nc">&nbsp;            data.addModifier(-1, &quot;exposed actuators&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // MD Infantry with grappler/magnets get bonus
<b class="nc">&nbsp;        if (attacker.hasAbility(OptionsConstants.MD_PL_ENHANCED)) {</b>
<b class="nc">&nbsp;            data.addModifier(-2, &quot;MD Grapple/Magnet&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return data;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the base to-hit number of a Leg Attack by the given attacker upon the
&nbsp;     * given defender
&nbsp;     *
&nbsp;     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
&nbsp;     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
&nbsp;     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
&nbsp;     */
&nbsp;    public static ToHitData getLegAttackBaseToHit(Entity attacker,
&nbsp;            Entity defender, IGame game) {
<b class="nc">&nbsp;        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</b>
<b class="nc">&nbsp;        ToHitData toReturn = null;</b>
<b class="nc">&nbsp;        boolean alreadyPerformingOther = false;</b>
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = actions.nextElement();</b>
<b class="nc">&nbsp;            if (ea instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                Entity waaAE = waa.getEntity(game);</b>
<b class="nc">&nbsp;                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</b>
&nbsp;                    // impossible if already doing a swarm attack
<b class="nc">&nbsp;                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</b>
<b class="nc">&nbsp;                           .getType().getInternalName()</b>
<b class="nc">&nbsp;                           .equals(Infantry.SWARM_MEK)) {</b>
<b class="nc">&nbsp;                        alreadyPerformingOther = true;</b>
&nbsp;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (alreadyPerformingOther) {</b>
<b class="nc">&nbsp;            reason = &quot;already performing a swarm attack&quot;;</b>
&nbsp;        }
&nbsp;        // Can only attack a Mek&#39;s legs.
<b class="nc">&nbsp;        else if (!(defender instanceof Mech)) {</b>
<b class="nc">&nbsp;            reason = &quot;Defender is not a Mech.&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t attack if flying
<b class="nc">&nbsp;        else if (attacker.getElevation() &gt; defender.getElevation()) {</b>
<b class="nc">&nbsp;            reason = &quot;Cannot do leg attack while flying.&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Handle BattleArmor attackers.
<b class="nc">&nbsp;        else if (attacker instanceof BattleArmor) {</b>
<b class="nc">&nbsp;            BattleArmor inf = (BattleArmor) attacker;</b>
<b class="nc">&nbsp;            toReturn = new ToHitData(inf.getCrew().getPiloting(),</b>
&nbsp;                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<b class="nc">&nbsp;            int men = inf.getShootingStrength();</b>
<b class="nc">&nbsp;            int modifier = TargetRoll.IMPOSSIBLE;</b>
<b class="nc">&nbsp;            if (men &gt;= 4) {</b>
<b class="nc">&nbsp;                modifier = 0;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 3) {</b>
<b class="nc">&nbsp;                modifier = 2;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 2) {</b>
<b class="nc">&nbsp;                modifier = 5;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 1) {</b>
<b class="nc">&nbsp;                modifier = 7;</b>
&nbsp;            }
<b class="nc">&nbsp;            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</b>
<b class="nc">&nbsp;        } else if (attacker instanceof Infantry) {</b>
&nbsp;            // Non-BattleArmor infantry need many more men.
<b class="nc">&nbsp;            Infantry inf = (Infantry) attacker;</b>
<b class="nc">&nbsp;            toReturn = new ToHitData(inf.getCrew().getPiloting(),</b>
&nbsp;                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<b class="nc">&nbsp;            int men = inf.getShootingStrength();</b>
<b class="nc">&nbsp;            int modifier = TargetRoll.IMPOSSIBLE;</b>
<b class="nc">&nbsp;            if (men &gt;= 22) {</b>
<b class="nc">&nbsp;                modifier = 0;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 16) {</b>
<b class="nc">&nbsp;                modifier = 2;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 10) {</b>
<b class="nc">&nbsp;                modifier = 5;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 5) {</b>
<b class="nc">&nbsp;                modifier = 7;</b>
&nbsp;            }
<b class="nc">&nbsp;            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (defender instanceof Mech &amp;&amp; ((Mech)defender).hasTracks()) {</b>
<b class="nc">&nbsp;            toReturn.addModifier(-2, &quot;has tracks&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // If the swarm is impossible, ToHitData wasn&#39;t created
<b class="nc">&nbsp;        if (toReturn == null) {</b>
<b class="nc">&nbsp;            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString(),</b>
&nbsp;                    ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
&nbsp;        }
<b class="nc">&nbsp;        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return toReturn;</b>
&nbsp;        }
<b class="nc">&nbsp;        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</b>
&nbsp;                defender);
<b class="nc">&nbsp;        return toReturn;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the base to-hit number of a Swarm Mek by the given attacker upon the
&nbsp;     * given defender.
&nbsp;     *
&nbsp;     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; swarming.
&nbsp;     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being swarmed.
&nbsp;     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the mek.
&nbsp;     */
&nbsp;    public static ToHitData getSwarmMekBaseToHit(Entity attacker,
&nbsp;            Entity defender, IGame game) {
<b class="nc">&nbsp;        ToHitData toReturn = null;</b>
<b class="nc">&nbsp;        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        boolean alreadyPerformingOther = false;</b>
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            EntityAction ea = actions.nextElement();</b>
<b class="nc">&nbsp;            if (ea instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                Entity waaAE = waa.getEntity(game);</b>
<b class="nc">&nbsp;                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</b>
&nbsp;                    // impossible if already doing a swarm attack
<b class="nc">&nbsp;                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</b>
<b class="nc">&nbsp;                           .getType().getInternalName()</b>
<b class="nc">&nbsp;                           .equals(Infantry.LEG_ATTACK)) {</b>
<b class="nc">&nbsp;                        alreadyPerformingOther = true;</b>
&nbsp;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (alreadyPerformingOther) {</b>
<b class="nc">&nbsp;            reason = &quot;attacker is already performing a leg attack&quot;;</b>
&nbsp;        }
&nbsp;        // Can only swarm a Mek.
<b class="nc">&nbsp;        else if (!(defender instanceof Mech) &amp;&amp; !(defender instanceof Tank)) {</b>
<b class="nc">&nbsp;            reason = &quot;Defender is not a Mech or vehicle.&quot;;</b>
&nbsp;        }
&nbsp;        // Can&#39;t swarm a friendly Mek. See
&nbsp;        // http://www.classicbattletech.com/w3t/showflat
&nbsp;        // .php?Cat=&amp;Board=ask&amp;Number=632321&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=
<b class="nc">&nbsp;        else if (!attacker.isEnemyOf(defender)</b>
<b class="nc">&nbsp;                 &amp;&amp; !attacker.getGame().getOptions()</b>
<b class="nc">&nbsp;                             .booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE)) {</b>
<b class="nc">&nbsp;            reason = &quot;Can only swarm an enemy.&quot;;</b>
&nbsp;        }
&nbsp;        // target is already swarmed
<b class="nc">&nbsp;        else if (defender.getSwarmAttackerId() != Entity.NONE) {</b>
<b class="nc">&nbsp;            reason = &quot;Only one swarm allowed at a time.&quot;;</b>
&nbsp;        }
&nbsp;        // Handle BattleArmor attackers.
<b class="nc">&nbsp;        else if (attacker instanceof BattleArmor) {</b>
<b class="nc">&nbsp;            BattleArmor inf = (BattleArmor) attacker;</b>
<b class="nc">&nbsp;            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</b>
<b class="nc">&nbsp;            int men = inf.getShootingStrength();</b>
<b class="nc">&nbsp;            int modifier = TargetRoll.IMPOSSIBLE;</b>
<b class="nc">&nbsp;            if (men &gt;= 4) {</b>
<b class="nc">&nbsp;                modifier = 2;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 1) {</b>
<b class="nc">&nbsp;                modifier = 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Non-BattleArmor infantry need many more men.
<b class="nc">&nbsp;        else if (attacker instanceof Infantry) {</b>
<b class="nc">&nbsp;            Infantry inf = (Infantry) attacker;</b>
<b class="nc">&nbsp;            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</b>
<b class="nc">&nbsp;            int men = inf.getShootingStrength();</b>
<b class="nc">&nbsp;            int modifier = TargetRoll.IMPOSSIBLE;</b>
<b class="nc">&nbsp;            if (men &gt;= 22) {</b>
<b class="nc">&nbsp;                modifier = 2;</b>
<b class="nc">&nbsp;            } else if (men &gt;= 16) {</b>
<b class="nc">&nbsp;                modifier = 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</b>
&nbsp;        }
&nbsp;        // If the swarm is impossible, ToHitData wasn&#39;t created
<b class="nc">&nbsp;        if (toReturn == null) {</b>
<b class="nc">&nbsp;            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return toReturn;</b>
&nbsp;        }
<b class="nc">&nbsp;        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</b>
&nbsp;                                           defender);
&nbsp;
&nbsp;        // If the attacker has assault claws, give a -1 modifier.
&nbsp;        // We can stop looking when we find our first match.
<b class="nc">&nbsp;        for (Mounted mount : attacker.getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType equip = mount.getType();</b>
<b class="nc">&nbsp;            if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {</b>
<b class="nc">&nbsp;                toReturn.addModifier(-1, &quot;attacker has magnetic claws&quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return toReturn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean canPhysicalTarget(IGame game, int entityId,
&nbsp;                                            Targetable target) {
&nbsp;
<b class="nc">&nbsp;        if (PunchAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                    PunchAttackAction.LEFT, false).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (PunchAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                    PunchAttackAction.RIGHT, false).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (KickAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                   KickAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (KickAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                   KickAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getEntity(entityId) instanceof QuadMech)</b>
<b class="nc">&nbsp;            &amp;&amp; ((KickAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                        KickAttackAction.LEFTMULE).getValue() != TargetRoll.IMPOSSIBLE) ||</b>
&nbsp;                (KickAttackAction
<b class="nc">&nbsp;                         .toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                KickAttackAction.RIGHTMULE).getValue() != TargetRoll.IMPOSSIBLE))) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (BrushOffAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                       BrushOffAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (BrushOffAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                       BrushOffAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (new ThrashAttackAction(entityId, target).toHit(game).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ProtomechPhysicalAttackAction.toHit(game, entityId, target)</b>
<b class="nc">&nbsp;                                         .getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (PushAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (LayExplosivesAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (TripAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (GrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (BreakGrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted club : game.getEntity(entityId).getClubs()) {</b>
<b class="nc">&nbsp;            if (null != club) {</b>
<b class="nc">&nbsp;                if (ClubAttackAction.toHit(game, entityId, target, club,</b>
<b class="nc">&nbsp;                                           ToHitData.HIT_NORMAL, false).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (JumpJetAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                      JumpJetAttackAction.BOTH).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (JumpJetAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                      JumpJetAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (JumpJetAttackAction.toHit(game, entityId, target,</b>
<b class="nc">&nbsp;                                      JumpJetAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (BAVibroClawAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can movement between the two coordinates be on pavement (which includes
&nbsp;     * roads and bridges)? If so it will override prohibited terrain, it may
&nbsp;     * change movement costs, and it may lead to skids.
&nbsp;     *
&nbsp;     * @param game     - the &lt;code&gt;IGame&lt;/code&gt; object.
&nbsp;     * @param src      - the &lt;code&gt;Coords&lt;/code&gt; being left.
&nbsp;     * @param dest     - the &lt;code&gt;Coords&lt;/code&gt; being entered.
&nbsp;     * @param moveStep
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if movement between &lt;code&gt;src&lt;/code&gt; and
&nbsp;     * &lt;code&gt;dest&lt;/code&gt; can be on pavement; &lt;code&gt;false&lt;/code&gt;
&nbsp;     * otherwise.
&nbsp;     */
&nbsp;    public static boolean canMoveOnPavement(IGame game, Coords src,
&nbsp;            Coords dest, MoveStep moveStep) {
<b class="nc">&nbsp;        final IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;        final IHex destHex = game.getBoard().getHex(dest);</b>
<b class="nc">&nbsp;        final int src2destDir = src.direction(dest);</b>
<b class="nc">&nbsp;        final int dest2srcDir = (src2destDir + 3) % 6;</b>
<b class="nc">&nbsp;        boolean result = false;</b>
&nbsp;
&nbsp;        // Jumping shouldn&#39;t be considered to be moving on pavement
<b class="nc">&nbsp;        if (moveStep.isJumping()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // We may be moving in the same hex.
<b class="nc">&nbsp;        if (src.equals(dest)</b>
<b class="nc">&nbsp;                &amp;&amp; (srcHex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                        || srcHex.containsTerrain(Terrains.ROAD) || srcHex</b>
<b class="nc">&nbsp;                            .containsTerrain(Terrains.BRIDGE))) {</b>
<b class="nc">&nbsp;            result = true;</b>
&nbsp;        }
&nbsp;        // If the source is a pavement hex, then see if the destination
&nbsp;        // hex is also a pavement hex or has a road or bridge that exits
&nbsp;        // into the source hex and the entity is climbing onto the bridge.
<b class="nc">&nbsp;        else if (srcHex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                &amp;&amp; (destHex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                        || destHex.containsTerrainExit(Terrains.ROAD,</b>
<b class="nc">&nbsp;                                dest2srcDir) || (destHex.containsTerrainExit(</b>
<b class="nc">&nbsp;                        Terrains.BRIDGE, dest2srcDir) &amp;&amp; moveStep.climbMode()))) {</b>
<b class="nc">&nbsp;            result = true;</b>
&nbsp;        }
&nbsp;        // See if the source hex has a road or bridge (and the entity is on the
&nbsp;        // bridge) that exits into the destination hex, and the dest hex has
&nbsp;        // pavement or a corresponding exit to the src hex
<b class="nc">&nbsp;        else if ((srcHex.containsTerrainExit(Terrains.ROAD, src2destDir) || (srcHex</b>
<b class="nc">&nbsp;                .containsTerrainExit(Terrains.BRIDGE, src2destDir) &amp;&amp; (moveStep.getElevation() == srcHex</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.BRIDGE_ELEV))))</b>
<b class="nc">&nbsp;                &amp;&amp; (destHex.containsTerrainExit(Terrains.ROAD, dest2srcDir)</b>
<b class="nc">&nbsp;                        || (destHex.containsTerrainExit(Terrains.BRIDGE,</b>
<b class="nc">&nbsp;                                dest2srcDir) &amp;&amp; moveStep.climbMode()) || destHex</b>
<b class="nc">&nbsp;                            .containsTerrain(Terrains.PAVEMENT))) {</b>
<b class="nc">&nbsp;            result = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether the attacker and the target are in the same building.
&nbsp;     *
&nbsp;     * @return true if the target can and does occupy the same building, false
&nbsp;     *         otherwise.
&nbsp;     */
&nbsp;    public static boolean isInSameBuilding(IGame game, Entity attacker,
&nbsp;            Targetable target) {
<b class="nc">&nbsp;        if (!(target instanceof Entity)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        Entity targetEntity = (Entity) target;</b>
<b class="nc">&nbsp;        if (!Compute.isInBuilding(game, attacker)</b>
<b class="nc">&nbsp;                || !Compute.isInBuilding(game, targetEntity)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Building attkBldg = game.getBoard().getBuildingAt(</b>
<b class="nc">&nbsp;                attacker.getPosition());</b>
<b class="nc">&nbsp;        Building targBldg = game.getBoard().getBuildingAt(target.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        return attkBldg.equals(targBldg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the given unit is inside of a building at the given
&nbsp;     * coordinates.
&nbsp;     *
&nbsp;     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
&nbsp;     *               &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
&nbsp;     *               &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
&nbsp;     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
&nbsp;     * those coordinates or if the entity is on the roof or in the air
&nbsp;     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * .
&nbsp;     */
&nbsp;    public static boolean isInBuilding(IGame game, Entity entity) {
&nbsp;
&nbsp;        // No game, no building.
<b class="nc">&nbsp;        if (game == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Null entities can&#39;t be in a building.
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Call the version of the function that requires coordinates.
<b class="nc">&nbsp;        return Compute.isInBuilding(game, entity, entity.getPosition());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the given unit is inside of a building at the given
&nbsp;     * coordinates.
&nbsp;     *
&nbsp;     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
&nbsp;     *               &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
&nbsp;     *               &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; of the building hex. This value may
&nbsp;     *               be &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
&nbsp;     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
&nbsp;     * those coordinates or if the entity is on the roof or in the air
&nbsp;     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * .
&nbsp;     */
&nbsp;    public static boolean isInBuilding(IGame game, Entity entity, Coords coords) {
&nbsp;
&nbsp;        // No game, no building.
<b class="nc">&nbsp;        if (game == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Null entities can&#39;t be in a building.
<b class="nc">&nbsp;        if (entity == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Null coordinates can&#39;t have buildings.
<b class="nc">&nbsp;        if (coords == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the Hex at those coordinates.
&nbsp;
<b class="nc">&nbsp;        return Compute.isInBuilding(game, entity.getElevation(), coords);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isInBuilding(IGame game, int entityElev, Coords coords) {
&nbsp;
&nbsp;        // Get the Hex at those coordinates.
<b class="fc">&nbsp;        final IHex curHex = game.getBoard().getHex(coords);</b>
&nbsp;
<b class="fc">&nbsp;        if (curHex == null) {</b>
&nbsp;            // probably off board artillery or reinforcement
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The entity can&#39;t be inside of a building that isn&#39;t there.
<b class="fc">&nbsp;        if (!curHex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The entity can&#39;t be inside of a building that isn&#39;t there.
<b class="nc">&nbsp;        if (!curHex.containsTerrain(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the elevations occupied by the building.
<b class="nc">&nbsp;        int bldgHeight = curHex.terrainLevel(Terrains.BLDG_ELEV);</b>
<b class="nc">&nbsp;        int basement = 0;</b>
<b class="nc">&nbsp;        if (curHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {</b>
<b class="nc">&nbsp;            basement = BasementType.getType(</b>
<b class="nc">&nbsp;                    curHex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</b>
<b class="nc">&nbsp;                                   .getDepth();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Return true if the entity is in the range of building elevations.
<b class="nc">&nbsp;        if ((entityElev &gt;= (-basement)) &amp;&amp; (entityElev &lt; (bldgHeight))) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Entity is not *inside* of the building.
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Scatter from hex according to dive bombing rules (based on MoF),
&nbsp;     * TW pg 246.  The scatter can happen in any direction.
&nbsp;     *
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
&nbsp;     * @param moF The margin of failure, which deterimines scatter distance
&nbsp;     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
&nbsp;     */
&nbsp;    public static Coords scatterDiveBombs(Coords coords, int moF) {
<b class="nc">&nbsp;        return Compute.scatter(coords, moF);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Scatter from hex according to altitude bombing rules (based on MoF),
&nbsp;     * TW pg 246.  The scatter only happens in the &quot;front&quot; three facings.
&nbsp;     *
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
&nbsp;     * @param facing
&nbsp;     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
&nbsp;     */
&nbsp;    public static Coords scatterAltitudeBombs(Coords coords, int facing) {
<b class="nc">&nbsp;        int dir = 0;</b>
<b class="nc">&nbsp;        int scatterDirection = Compute.d6(1);</b>
<b class="nc">&nbsp;        switch (scatterDirection) {</b>
&nbsp;            case 1:
&nbsp;            case 2:
<b class="nc">&nbsp;                dir = (facing - 1) % 6;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 3:
&nbsp;            case 4:
<b class="nc">&nbsp;                dir = facing;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 5:
&nbsp;            case 6:
<b class="nc">&nbsp;                dir = (facing + 1) % 6;</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        int dist = Compute.d6(1);</b>
<b class="nc">&nbsp;        return coords.translated(dir, dist);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * scatter from hex according to direct fire artillery rules (based on MoF)
&nbsp;     *
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
&nbsp;     * @param moF The margin of failure, which deterimines scatter distance
&nbsp;     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
&nbsp;     */
&nbsp;    public static Coords scatterDirectArty(Coords coords, int moF) {
<b class="nc">&nbsp;        return Compute.scatter(coords, moF);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * scatter from a hex according, roll d6 to choose scatter direction
&nbsp;     *
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
&nbsp;     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure, scatter distance will
&nbsp;     *               be the margin of failure
&nbsp;     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
&nbsp;     */
&nbsp;    public static Coords scatter(Coords coords, int margin) {
<b class="nc">&nbsp;        int scatterDirection = Compute.d6(1) - 1;</b>
<b class="nc">&nbsp;        return coords.translated(scatterDirection, margin);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * scatter from hex according to atmospheric drop rules d6 for direction,
&nbsp;     * 1d6 per point of MOF
&nbsp;     *
&nbsp;     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
&nbsp;     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure
&nbsp;     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
&nbsp;     */
&nbsp;    public static Coords scatterAssaultDrop(Coords coords, int margin) {
<b class="nc">&nbsp;        int scatterDirection = Compute.d6(1) - 1;</b>
<b class="nc">&nbsp;        int distance = Compute.d6(margin);</b>
<b class="nc">&nbsp;        return coords.translated(scatterDirection, distance);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a new target for a flight of swarm missiles that was just shot at an
&nbsp;     * entity and has missiles left
&nbsp;     *
&nbsp;     * @param game
&nbsp;     * @param aeId     The attacking &lt;code&gt;Entity&lt;/code&gt;
&nbsp;     * @param coords
&nbsp;     * @param weaponId The &lt;code&gt;int&lt;/code&gt; ID of the launcher used to fire this
&nbsp;     *                 volley
&nbsp;     * @return the new target &lt;code&gt;Entity&lt;/code&gt;. May return null if no new
&nbsp;     * target available
&nbsp;     */
&nbsp;    public static Entity getSwarmMissileTarget(IGame game, int aeId,
&nbsp;                                               Coords coords, int weaponId) {
<b class="nc">&nbsp;        Entity tempEntity = null;</b>
&nbsp;        // first, check the hex of the original target
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; entities = game.getEntities(coords);</b>
<b class="nc">&nbsp;        Vector&lt;Entity&gt; possibleTargets = new Vector&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        while (entities.hasNext()) {</b>
<b class="nc">&nbsp;            tempEntity = entities.next();</b>
<b class="nc">&nbsp;            if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</b>
&nbsp;                // we found a target
<b class="nc">&nbsp;                possibleTargets.add(tempEntity);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // if there is at least one target, get a random one of them
<b class="nc">&nbsp;        if (!possibleTargets.isEmpty()) {</b>
<b class="nc">&nbsp;            return possibleTargets</b>
<b class="nc">&nbsp;                    .get(Compute.randomInt(possibleTargets.size()));</b>
&nbsp;        }
&nbsp;        // loop through adjacent hexes
<b class="nc">&nbsp;        for (int dir = 0; dir &lt;= 5; dir++) {</b>
<b class="nc">&nbsp;            Coords tempcoords = coords.translated(dir);</b>
<b class="nc">&nbsp;            if (!game.getBoard().contains(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (coords.equals(tempcoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            entities = game.getEntities(tempcoords);</b>
<b class="nc">&nbsp;            if (entities.hasNext()) {</b>
<b class="nc">&nbsp;                tempEntity = entities.next();</b>
<b class="nc">&nbsp;                if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</b>
&nbsp;                    // we found a target
<b class="nc">&nbsp;                    possibleTargets.add(tempEntity);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // if there is at least one target, get a random one of them
<b class="nc">&nbsp;        if (!possibleTargets.isEmpty()) {</b>
<b class="nc">&nbsp;            return possibleTargets</b>
<b class="nc">&nbsp;                    .get(Compute.randomInt(possibleTargets.size()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a new target hex for a flight of smoke missiles fired at a hex, if
&nbsp;     * there are remaining missiles.
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * * STUFF FOR VECTOR MOVEMENT CALCULATIONS **
&nbsp;     */
&nbsp;    public static Coords getFinalPosition(Coords curpos, int[] v) {
&nbsp;
<b class="nc">&nbsp;        if ((v == null) || (v.length != 6)) {</b>
<b class="nc">&nbsp;            return curpos;</b>
&nbsp;        }
&nbsp;
&nbsp;        // step through each vector and move the direction indicated
<b class="nc">&nbsp;        int thrust = 0;</b>
<b class="nc">&nbsp;        Coords endpos = curpos;</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            thrust = v[dir];</b>
<b class="nc">&nbsp;            while (thrust &gt; 0) {</b>
<b class="nc">&nbsp;                endpos = endpos.translated(dir);</b>
<b class="nc">&nbsp;                thrust--;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return endpos;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * method to change a set of active vectors for a one-point thrust
&nbsp;     * expenditure in the giving facing
&nbsp;     *
&nbsp;     * @param v
&nbsp;     * @param facing
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static int[] changeVectors(int[] v, int facing) {
&nbsp;
<b class="nc">&nbsp;        if ((v == null) || (v.length != 6)) {</b>
<b class="nc">&nbsp;            return v;</b>
&nbsp;        }
&nbsp;
&nbsp;        // first look at opposing vectors
<b class="nc">&nbsp;        int oppv = facing + 3;</b>
<b class="nc">&nbsp;        if (oppv &gt; 5) {</b>
<b class="nc">&nbsp;            oppv -= 6;</b>
&nbsp;        }
&nbsp;        // is this vector active
<b class="nc">&nbsp;        if (v[oppv] &gt; 0) {</b>
&nbsp;            // then decrement it by one and return
<b class="nc">&nbsp;            v[oppv]--;</b>
<b class="nc">&nbsp;            return v;</b>
&nbsp;        }
&nbsp;
&nbsp;        // now check oblique vectors
<b class="nc">&nbsp;        int oblv1 = facing + 2;</b>
<b class="nc">&nbsp;        if (oblv1 &gt; 5) {</b>
<b class="nc">&nbsp;            oblv1 -= 6;</b>
&nbsp;        }
<b class="nc">&nbsp;        int oblv2 = facing - 2;</b>
<b class="nc">&nbsp;        if (oblv2 &lt; 0) {</b>
<b class="nc">&nbsp;            oblv2 += 6;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check both of these and if either is active
&nbsp;        // deal with it and then return
<b class="nc">&nbsp;        if ((v[oblv1] &gt; 0) || (v[oblv2] &gt; 0)) {</b>
&nbsp;
<b class="nc">&nbsp;            int newface = facing + 1;</b>
<b class="nc">&nbsp;            if (newface &gt; 5) {</b>
<b class="nc">&nbsp;                newface = 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (v[oblv1] &gt; 0) {</b>
<b class="nc">&nbsp;                v[oblv1]--;</b>
<b class="nc">&nbsp;                v[newface]++;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            newface = facing - 1;</b>
<b class="nc">&nbsp;            if (newface &lt; 0) {</b>
<b class="nc">&nbsp;                newface = 5;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (v[oblv2] &gt; 0) {</b>
<b class="nc">&nbsp;                v[oblv2]--;</b>
<b class="nc">&nbsp;                v[newface]++;</b>
&nbsp;            }
<b class="nc">&nbsp;            return v;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if nothing was found, then just increase velocity in this vector
<b class="nc">&nbsp;        v[facing]++;</b>
<b class="nc">&nbsp;        return v;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * compare two vectors and determine if they are the same
&nbsp;     *
&nbsp;     * @param v1
&nbsp;     * @param v2
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static boolean sameVectors(int[] v1, int[] v2) {
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;            if (v1[i] != v2[i]) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the net velocity of two aeros for ramming attacks
&nbsp;     */
&nbsp;    public static int getNetVelocity(Coords src, Entity te, int avel, int tvel) {
<b class="nc">&nbsp;        int angle = te.sideTableRam(src);</b>
&nbsp;
<b class="nc">&nbsp;        switch (angle) {</b>
&nbsp;            case Aero.RAM_TOWARD_DIR:
<b class="nc">&nbsp;                return Math.max(avel + tvel, 1);</b>
&nbsp;            case Aero.RAM_TOWARD_OBL:
<b class="nc">&nbsp;                return Math.max(avel + (tvel / 2), 1);</b>
&nbsp;            case Aero.RAM_AWAY_OBL:
<b class="nc">&nbsp;                return Math.max(avel - (tvel / 2), 1);</b>
&nbsp;            case Aero.RAM_AWAY_DIR:
<b class="nc">&nbsp;                return Math.max(avel - tvel, 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns how much damage a weapon will do against against a BattleArmor
&nbsp;     * target if the BattleArmor vs BattleArmor rules on TO pg 109 are in
&nbsp;     * effect.
&nbsp;     *
&nbsp;     * @param damage     Original weapon damage
&nbsp;     * @param damageType The damage type for BA vs BA damage
&nbsp;     * @param target     The target, used for ensuring the target BA isn&#39;t
&nbsp;     *                   fire resistant
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static int directBlowBADamage(double damage, int damageType,
&nbsp;                                         BattleArmor target) {
<b class="nc">&nbsp;        switch (damageType) {</b>
&nbsp;            case WeaponType.WEAPON_BURST_1D6:
<b class="nc">&nbsp;                damage = Compute.d6();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_BURST_3D6:
<b class="nc">&nbsp;                damage = Compute.d6(3);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_PLASMA:
&nbsp;                // If the target is fire-resistant BA, damage is normal
<b class="nc">&nbsp;                if (!target.isFireResistant()) {</b>
<b class="nc">&nbsp;                    damage = 1 + Compute.d6(1);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        damage = Math.ceil(damage);</b>
<b class="nc">&nbsp;        return (int) damage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to get a human-readable string that represents the passed damage
&nbsp;     * type.
&nbsp;     *
&nbsp;     * @param damageType
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static String getDamageTypeString(int damageType) {
<b class="nc">&nbsp;        switch (damageType) {</b>
&nbsp;            case WeaponType.WEAPON_DIRECT_FIRE:
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponType.DirectFire&quot;);</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponType.BallisticCluster&quot;);</b>
&nbsp;            case WeaponType.WEAPON_PULSE:
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponType.Pulse&quot;);</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE:
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponType.Missile&quot;);</b>
&nbsp;            case WeaponType.WEAPON_BURST_HALFD6:
&nbsp;            case WeaponType.WEAPON_BURST_1D6:
&nbsp;            case WeaponType.WEAPON_BURST_2D6:
&nbsp;            case WeaponType.WEAPON_BURST_3D6:
&nbsp;            case WeaponType.WEAPON_BURST_4D6:
&nbsp;            case WeaponType.WEAPON_BURST_5D6:
&nbsp;            case WeaponType.WEAPON_BURST_6D6:
&nbsp;            case WeaponType.WEAPON_BURST_7D6:
&nbsp;            default:
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponType.Burst&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static int directBlowInfantryDamage(double damage, int mos,
&nbsp;            int damageType, boolean isNonInfantryAgainstMechanized,
&nbsp;            boolean isAttackThruBuilding) {
<b class="nc">&nbsp;        return directBlowInfantryDamage(damage, mos, damageType,</b>
&nbsp;                isNonInfantryAgainstMechanized, isAttackThruBuilding,
&nbsp;                Entity.NONE, null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method replicates the Non-Conventional Damage against Infantry damage
&nbsp;     * table as well as shifting for direct blows. also adjust for non-infantry
&nbsp;     * damaging mechanized infantry
&nbsp;     *
&nbsp;     * @param damage
&nbsp;     * @param mos
&nbsp;     * @param damageType
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static int directBlowInfantryDamage(double damage, int mos,
&nbsp;            int damageType, boolean isNonInfantryAgainstMechanized,
&nbsp;            boolean isAttackThruBuilding, int attackerId, Vector&lt;Report&gt; vReport) {
&nbsp;
<b class="nc">&nbsp;        int origDamageType = damageType;</b>
<b class="nc">&nbsp;        damageType += mos;</b>
<b class="nc">&nbsp;        double origDamage = damage;</b>
<b class="nc">&nbsp;        switch (damageType) {</b>
&nbsp;            case WeaponType.WEAPON_DIRECT_FIRE:
<b class="nc">&nbsp;                damage /= 10;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<b class="nc">&nbsp;                damage /= 10;</b>
<b class="nc">&nbsp;                damage++;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_PULSE:
<b class="nc">&nbsp;                damage /= 10;</b>
<b class="nc">&nbsp;                damage += 2;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE:
<b class="nc">&nbsp;                damage /= 5;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
<b class="nc">&nbsp;                damage /= 5;</b>
<b class="nc">&nbsp;                damage += Compute.d6();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
<b class="nc">&nbsp;                damage /= 5;</b>
<b class="nc">&nbsp;                damage += Compute.d6(2);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<b class="nc">&nbsp;                damage /= 5;</b>
<b class="nc">&nbsp;                damage += Compute.d6(3);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WeaponType.WEAPON_BURST_HALFD6:
<b class="nc">&nbsp;                damage = Compute.d6() / 2.0;</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_1D6:
<b class="nc">&nbsp;                damage = Compute.d6();</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_2D6:
<b class="nc">&nbsp;                damage = Compute.d6(2);</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_3D6:
<b class="nc">&nbsp;                damage = Compute.d6(3);</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_4D6:
<b class="nc">&nbsp;                damage = Compute.d6(4);</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_5D6:
<b class="nc">&nbsp;                damage = Compute.d6(5);</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_6D6:
<b class="nc">&nbsp;                damage = Compute.d6(6);</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case WeaponType.WEAPON_BURST_7D6:
<b class="nc">&nbsp;                damage = Compute.d6(7);</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    damage *= 0.5;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        damage = Math.ceil(damage);</b>
&nbsp;
&nbsp;        // according to the following ruling, the half damage that mechanized
&nbsp;        // inf get against burst fire should trump the double damage they get
&nbsp;        // from non-infantry rather than cancel it out
&nbsp;        // http://bg.battletech.com/forums/index.php/topic,23928.0.html
<b class="nc">&nbsp;        if (isNonInfantryAgainstMechanized) {</b>
<b class="nc">&nbsp;            if (damageType &lt; WeaponType.WEAPON_BURST_HALFD6) {</b>
<b class="nc">&nbsp;                damage *= 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                damage /= 2;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (vReport != null) {</b>
<b class="nc">&nbsp;            Report r = new Report();</b>
<b class="nc">&nbsp;            r.subject = attackerId;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
&nbsp;
<b class="nc">&nbsp;            r.add(getDamageTypeString(origDamageType));</b>
<b class="nc">&nbsp;            if (origDamageType != damageType) {</b>
<b class="nc">&nbsp;                if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                    r.messageId = 9973;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    r.messageId = 9972;</b>
&nbsp;                }
<b class="nc">&nbsp;                r.add(getDamageTypeString(damageType));</b>
<b class="nc">&nbsp;            } else if (isAttackThruBuilding) {</b>
<b class="nc">&nbsp;                r.messageId = 9971;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.messageId = 9970;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            r.add((int)origDamage);</b>
<b class="nc">&nbsp;            r.add((int)damage);</b>
<b class="nc">&nbsp;            vReport.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        return (int) damage;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Method computes how much damage a dial down weapon has done
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     * @param wtype
&nbsp;     * @returnnew damage
&nbsp;     */
&nbsp;    public static int dialDownDamage(Mounted weapon, WeaponType wtype) {
<b class="nc">&nbsp;        return Compute.dialDownDamage(weapon, wtype, 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method computes how much damage a dial down weapon has done
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     * @param wtype
&nbsp;     * @param range
&nbsp;     * @return new damage
&nbsp;     */
&nbsp;    public static int dialDownDamage(Mounted weapon, WeaponType wtype, int range) {
<b class="nc">&nbsp;        int toReturn = wtype.getDamage(range);</b>
&nbsp;
<b class="nc">&nbsp;        if (!wtype.hasModes()) {</b>
<b class="nc">&nbsp;            return toReturn;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String damage = weapon.curMode().getName();</b>
&nbsp;
&nbsp;        // Vehicle flamers have damage and heat modes so lets make sure this is
&nbsp;        // an actual dial down Damage.
<b class="nc">&nbsp;        if ((damage.trim().toLowerCase().indexOf(&quot;damage&quot;) == 0)</b>
<b class="nc">&nbsp;            &amp;&amp; (damage.trim().length() &gt; 6)) {</b>
<b class="nc">&nbsp;            toReturn = Integer.parseInt(damage.substring(6).trim());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return Math.min(wtype.getDamage(range), toReturn);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method computes how much heat a dial down weapon generates
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     * @param wtype
&nbsp;     * @return Heat, minimum of 1;
&nbsp;     */
&nbsp;    public static int dialDownHeat(Mounted weapon, WeaponType wtype) {
<b class="nc">&nbsp;        return Compute.dialDownHeat(weapon, wtype, 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method computes how much heat a dial down weapon generates
&nbsp;     *
&nbsp;     * @param weapon
&nbsp;     * @param wtype
&nbsp;     * @param range
&nbsp;     * @return Heat, minimum of 1;
&nbsp;     */
&nbsp;    public static int dialDownHeat(Mounted weapon, WeaponType wtype, int range) {
<b class="nc">&nbsp;        int toReturn = wtype.getHeat();</b>
&nbsp;
<b class="nc">&nbsp;        if (!wtype.hasModes()) {</b>
<b class="nc">&nbsp;            return toReturn;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int damage = wtype.getDamage(range);</b>
<b class="nc">&nbsp;        int newDamage = Compute.dialDownDamage(weapon, wtype, range);</b>
&nbsp;
<b class="nc">&nbsp;        toReturn = Math.max(1,</b>
<b class="nc">&nbsp;                            wtype.getHeat() - Math.max(0, damage - newDamage));</b>
<b class="nc">&nbsp;        return toReturn;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param aPos - attacking entity
&nbsp;     * @param tPos - targeted entity
&nbsp;     * @return a vector of all the entities that are adjacent to the targeted
&nbsp;     * entity and would fall along the angle of attack
&nbsp;     */
&nbsp;    public static ArrayList&lt;Entity&gt; getAdjacentEntitiesAlongAttack(Coords aPos,
&nbsp;                                                                   Coords tPos, IGame game) {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; coords = Coords.intervening(aPos, tPos);</b>
&nbsp;        // loop through all intervening coords
<b class="nc">&nbsp;        for (Coords c : coords) {</b>
&nbsp;            // must be adjacent to the target
<b class="nc">&nbsp;            if ((c.distance(tPos) &gt; 1) || c.equals(tPos)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // now lets add all the entities here
<b class="nc">&nbsp;            for (Entity en : game.getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                entities.add(en);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return entities;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isInUrbanEnvironment(IGame game, Coords unitPOS) {
<b class="nc">&nbsp;        IHex unitHex = game.getBoard().getHex(unitPOS);</b>
&nbsp;
<b class="nc">&nbsp;        if (unitHex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                || unitHex.containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                || unitHex.containsTerrain(Terrains.RUBBLE)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // loop through adjacent hexes
<b class="nc">&nbsp;        for (int dir = 0; dir &lt;= 5; dir++) {</b>
<b class="nc">&nbsp;            Coords adjCoords = unitPOS.translated(dir);</b>
<b class="nc">&nbsp;            IHex adjHex = game.getBoard().getHex(adjCoords);</b>
&nbsp;
<b class="nc">&nbsp;            if (!game.getBoard().contains(adjCoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (unitPOS.equals(adjCoords)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // hex pavement or building?
<b class="nc">&nbsp;            if (adjHex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                    || adjHex.containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                    || adjHex.containsTerrain(Terrains.RUBBLE)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAirToGround(Entity attacker, Targetable target) {
<b class="fc">&nbsp;        if ((attacker == null) || (target == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Artillery attacks need to return differently, since none of the usual air to ground modifiers apply to them
<b class="fc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (attacker.isSpaceborne()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // According to errata, VTOL and WiGes are considered ground targets
<b class="fc">&nbsp;        return attacker.isAirborne() &amp;&amp; !target.isAirborne() &amp;&amp; attacker.isAero();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAirToAir(Entity attacker, Targetable target) {
<b class="nc">&nbsp;        if ((attacker == null) || (target == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // According to errata, VTOL and WiGes are considered ground targets
<b class="nc">&nbsp;        return attacker.isAirborne() &amp;&amp; target.isAirborne();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isGroundToAir(Entity attacker, Targetable target) {
<b class="fc">&nbsp;        if ((attacker == null) || (target == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return !attacker.isAirborne() &amp;&amp; target.isAirborne();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isGroundToGround(Entity attacker, Targetable target) {
<b class="nc">&nbsp;        if ((attacker == null) || (target == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return !attacker.isAirborne() &amp;&amp; !target.isAirborne();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This is a homebrew function partially drawn from pg. 40-1 of AT2R that
&nbsp;     * allows units that flee the field for any reason to return after a certain
&nbsp;     * number of rounds It can potentially be expanded to include other
&nbsp;     * conditions
&nbsp;     *
&nbsp;     * @param en
&nbsp;     * @return number of rounds until return (-1 if never)
&nbsp;     */
&nbsp;    public static int roundsUntilReturn(IGame game, Entity en) {
&nbsp;
<b class="nc">&nbsp;        if (!en.isAero()) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_RETURN_FLYOVER)) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IAero a = (IAero) en;</b>
&nbsp;
&nbsp;        // the table in AT2R is backwards, it should take longer to return if
&nbsp;        // your velocity is higher
<b class="nc">&nbsp;        int turns = 1 + (int) Math.ceil(a.getCurrentVelocity() / 4.0);</b>
&nbsp;
&nbsp;        // OOC units should take longer, how about two extra turns?
<b class="nc">&nbsp;        if (a.isOutControlTotal()) {</b>
<b class="nc">&nbsp;            turns += 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return turns;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean inDeadZone(IGame game, Entity ae, Targetable target) {
<b class="nc">&nbsp;        if (ae.isSpaceborne()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<b class="nc">&nbsp;        if (Compute.isAirToAir(ae, target)) {</b>
<b class="nc">&nbsp;            int distance = Compute.effectiveDistance(game, ae, target,</b>
<b class="nc">&nbsp;                                                     target.isAirborneVTOLorWIGE());</b>
<b class="nc">&nbsp;            int aAlt = ae.getAltitude();</b>
<b class="nc">&nbsp;            int tAlt = target.getAltitude();</b>
<b class="nc">&nbsp;            if (target.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                tAlt++;</b>
&nbsp;            }
<b class="nc">&nbsp;            int altDiff = Math.abs(aAlt - tAlt);</b>
<b class="nc">&nbsp;            if (altDiff &gt;= (distance - altDiff)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ArrayList&lt;Coords&gt; getAcceptableUnloadPositions(
&nbsp;            List&lt;Coords&gt; ring, Entity unit, IGame game, int elev) {
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; acceptable = new ArrayList&lt;Coords&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Coords pos : ring) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;            if (null == hex) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // no stacking violations, no prohibited terrain, and within 2
&nbsp;            // elevations
&nbsp;
<b class="nc">&nbsp;            if (!unit.isLocationProhibited(pos)</b>
<b class="nc">&nbsp;                &amp;&amp; (null == stackingViolation(game, unit.getId(), pos))</b>
<b class="nc">&nbsp;                &amp;&amp; (Math.abs(hex.getLevel() - elev) &lt; 3)) {</b>
<b class="nc">&nbsp;                acceptable.add(pos);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return acceptable;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds a list of all adjacent units that can load the given Entity.
&nbsp;     * @param en   The entity to load
&nbsp;     * @param pos  The coordinates of the hex to load from
&nbsp;     * @param elev The absolute elevation of the unit at the point of loading (surface
&nbsp;     *             of the hex + elevation over the surface)
&nbsp;     * @param game The game object
&nbsp;     * @return     All adjacent units that can mount the Entity
&nbsp;     */
&nbsp;    public static List&lt;Entity&gt; getMountableUnits(Entity en, Coords pos, int elev, IGame game) {
<b class="nc">&nbsp;        List&lt;Entity&gt; mountable = new ArrayList&lt;&gt;();</b>
&nbsp;        // Expanded to include trains
&nbsp;
&nbsp;        // the rules don&#39;t say that the unit must be facing loader
&nbsp;        // so lets take the ring
<b class="nc">&nbsp;        for (Coords c : pos.allAdjacent()) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;            if (null == hex) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Entity other : game.getEntitiesVector(c)) {</b>
&nbsp;                // Is the other unit friendly and not the current entity?
<b class="nc">&nbsp;                if ((en.getOwner().equals(other.getOwner()) || (en.getOwner()</b>
<b class="nc">&nbsp;                                                                  .getTeam() == other.getOwner().getTeam()))</b>
<b class="nc">&nbsp;                    &amp;&amp; !en.equals(other)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((other instanceof SmallCraft) || other.getTowing() != Entity.NONE || other.getTowedBy() != Entity.NONE)</b>
<b class="nc">&nbsp;                    &amp;&amp; other.canLoad(en)</b>
<b class="nc">&nbsp;                    &amp;&amp; !other.isAirborne()</b>
<b class="nc">&nbsp;                    &amp;&amp; (Math.abs((hex.surface() + other.getElevation())</b>
<b class="nc">&nbsp;                                 - elev) &lt; 3) &amp;&amp; !mountable.contains(other)) {</b>
<b class="nc">&nbsp;                    mountable.add(other);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return mountable;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean allowAimedShotWith(Mounted weapon, int aimingMode) {
<b class="nc">&nbsp;        WeaponType wtype = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;        boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);</b>
<b class="nc">&nbsp;        boolean usesAmmo = (wtype.getAmmoType() != AmmoType.T_NA)</b>
&nbsp;                           &amp;&amp; !isWeaponInfantry;
<b class="nc">&nbsp;        Mounted ammo = usesAmmo ? weapon.getLinked() : null;</b>
<b class="nc">&nbsp;        AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();</b>
&nbsp;
&nbsp;        // Leg and swarm attacks can&#39;t be aimed.
<b class="nc">&nbsp;        if (wtype.getInternalName().equals(Infantry.LEG_ATTACK)</b>
<b class="nc">&nbsp;            || wtype.getInternalName().equals(Infantry.SWARM_MEK)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (aimingMode) {</b>
&nbsp;            case (IAimingModes.AIM_MODE_NONE):
<b class="nc">&nbsp;                return false;</b>
&nbsp;            case (IAimingModes.AIM_MODE_IMMOBILE):
<b class="nc">&nbsp;                if (weapon.getCurrentShots() &gt; 1) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (atype == null) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                switch (atype.getAmmoType()) {</b>
&nbsp;                    case AmmoType.T_SRM_STREAK:
&nbsp;                    case AmmoType.T_LRM_STREAK:
&nbsp;                    case AmmoType.T_LRM:
&nbsp;                    case AmmoType.T_LRM_IMP:
&nbsp;                    case AmmoType.T_LRM_TORPEDO:
&nbsp;                    case AmmoType.T_SRM:
&nbsp;                    case AmmoType.T_SRM_IMP:
&nbsp;                    case AmmoType.T_SRM_TORPEDO:
&nbsp;                    case AmmoType.T_MRM:
&nbsp;                    case AmmoType.T_NARC:
&nbsp;                    case AmmoType.T_INARC:
&nbsp;                    case AmmoType.T_AMS:
&nbsp;                    case AmmoType.T_ARROW_IV:
&nbsp;                    case AmmoType.T_LONG_TOM:
&nbsp;                    case AmmoType.T_SNIPER:
&nbsp;                    case AmmoType.T_THUMPER:
&nbsp;                    case AmmoType.T_SRM_ADVANCED:
&nbsp;                    case AmmoType.T_LRM_TORPEDO_COMBO:
&nbsp;                    case AmmoType.T_ATM:
&nbsp;                    case AmmoType.T_IATM:
&nbsp;                    case AmmoType.T_MML:
&nbsp;                    case AmmoType.T_EXLRM:
&nbsp;                    case AmmoType.T_NLRM:
&nbsp;                    case AmmoType.T_TBOLT_5:
&nbsp;                    case AmmoType.T_TBOLT_10:
&nbsp;                    case AmmoType.T_TBOLT_15:
&nbsp;                    case AmmoType.T_TBOLT_20:
&nbsp;                    case AmmoType.T_PXLRM:
&nbsp;                    case AmmoType.T_HSRM:
&nbsp;                    case AmmoType.T_MRM_STREAK:
&nbsp;                    case AmmoType.T_HAG:
&nbsp;                    case AmmoType.T_ROCKET_LAUNCHER:
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
<b class="nc">&nbsp;                     || (atype.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                     || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                // Flak Ammo can&#39;t make aimed shots
<b class="nc">&nbsp;                if (((atype.getAmmoType() == AmmoType.T_AC)</b>
<b class="nc">&nbsp;                     || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                     || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                break;
&nbsp;            case (IAimingModes.AIM_MODE_TARG_COMP):
<b class="nc">&nbsp;                if (!wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</b>
<b class="nc">&nbsp;                    || wtype.hasFlag(WeaponType.F_PULSE)</b>
&nbsp;                    || (wtype instanceof HAGWeapon)) {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.getCurrentShots() &gt; 1) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if ((atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Flak Ammo can&#39;t make aimed shots
<b class="nc">&nbsp;                if ((atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
&nbsp;    public static int getTotalGunnerNeeds(Entity entity) {
<b class="fc">&nbsp;        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</b>
<b class="fc">&nbsp;            int nStandardW = 0;</b>
<b class="fc">&nbsp;            int nCapitalW = 0;</b>
<b class="fc">&nbsp;            for (Mounted m : entity.getTotalWeaponList()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;                if (type instanceof BayWeapon) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (type instanceof WeaponType) {</b>
<b class="nc">&nbsp;                    if (((WeaponType) type).isCapital()) {</b>
<b class="nc">&nbsp;                        nCapitalW++;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        nStandardW++;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            return nCapitalW + (int) Math.ceil(nStandardW / 6.0);</b>
<b class="nc">&nbsp;        } else if (entity.isSupportVehicle()) {</b>
<b class="nc">&nbsp;            return getSupportVehicleGunnerNeeds(entity);</b>
<b class="nc">&nbsp;        } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            return (getFullCrewSize(entity) - 1);</b>
<b class="nc">&nbsp;        } else if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            return getFullCrewSize(entity);</b>
<b class="nc">&nbsp;        } else if (entity.getCrew().getCrewType().getGunnerPos() &gt; 0) {</b>
&nbsp;            //Tripod, QuadVee, or dual cockpit
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
&nbsp;    public static int getAeroCrewNeeds(Entity entity) {
<b class="fc">&nbsp;        if (entity instanceof Dropship) {</b>
<b class="nc">&nbsp;            if (((Dropship) entity).isMilitary()) {</b>
<b class="nc">&nbsp;                return 4 + (int) Math.ceil(entity.getWeight() / 5000.0);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return 3 + (int) Math.ceil(entity.getWeight() / 5000.0);</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (entity instanceof SmallCraft) {</b>
<b class="nc">&nbsp;            return getTotalDriverNeeds(entity);</b>
<b class="fc">&nbsp;        } else if (entity instanceof Warship || entity instanceof SpaceStation) {</b>
<b class="nc">&nbsp;            return 45 + (int) Math.ceil(entity.getWeight() / 5000.0);</b>
<b class="fc">&nbsp;        } else if (entity instanceof Jumpship) {</b>
<b class="fc">&nbsp;            return 6 + (int) Math.ceil(entity.getWeight() / 20000.0);</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the base crew requirements for support vehicles.
&nbsp;     *
&nbsp;     * @param entity The support vehicle
&nbsp;     * @return       The minimum base crew
&nbsp;     */
&nbsp;    public static int getSVBaseCrewNeeds(Entity entity) {
<b class="nc">&nbsp;        if (entity.isTrailer() &amp;&amp; (entity.getEngine().getEngineType() == Engine.NONE)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        final boolean naval = entity.getMovementMode().equals(EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                || entity.getMovementMode().equals(EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                || entity.getMovementMode().equals(EntityMovementMode.SUBMARINE);</b>
&nbsp;        int crew;
<b class="nc">&nbsp;        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</b>
<b class="nc">&nbsp;            crew = 1;</b>
<b class="nc">&nbsp;        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_MEDIUM_SUPPORT) {</b>
<b class="nc">&nbsp;            if (naval || entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</b>
<b class="nc">&nbsp;                crew = 4;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                crew = 2;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            crew = 3;</b>
<b class="nc">&nbsp;            if (naval) {</b>
<b class="nc">&nbsp;                crew += (int) Math.ceil(entity.getWeight() / 5000);</b>
<b class="nc">&nbsp;            } else if (entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</b>
<b class="nc">&nbsp;                crew += (int) Math.ceil(entity.getWeight() / 500);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return crew;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates number of gunners required for a support vehicle. See TM, 131.
&nbsp;     *
&nbsp;     * @param entity The support vehicle
&nbsp;     * @return       The number of gunners required.
&nbsp;     */
&nbsp;    public static int getSupportVehicleGunnerNeeds(Entity entity) {
<b class="nc">&nbsp;        final boolean advFireCon = entity.hasMisc(MiscType.F_ADVANCED_FIRECONTROL);</b>
<b class="nc">&nbsp;        final boolean basicFireCon = !advFireCon &amp;&amp; entity.hasMisc(MiscType.F_BASIC_FIRECONTROL);</b>
<b class="nc">&nbsp;        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</b>
<b class="nc">&nbsp;            if (!advFireCon &amp;&amp; !basicFireCon) {</b>
&nbsp;                // No fire control requires one gunner per weapon.
<b class="nc">&nbsp;                return entity.getWeaponList().size();</b>
&nbsp;            } else {
&nbsp;                // Otherwise we require one gunner per facing, with turrets and pintle mounts counting
&nbsp;                // as separate facings
<b class="nc">&nbsp;                Set&lt;Integer&gt; facings = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                int pintles = 0;</b>
<b class="nc">&nbsp;                for (Mounted m : entity.getWeaponList()) {</b>
<b class="nc">&nbsp;                    if (m.isPintleTurretMounted()) {</b>
<b class="nc">&nbsp;                        pintles++;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        facings.add(m.getLocation());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (advFireCon) {</b>
&nbsp;                    // Advanced fire control lets the driver count as a gunner, so one fewer dedicated gunners is needed.
<b class="nc">&nbsp;                    return Math.max(0, pintles + facings.size() - 1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return pintles + facings.size();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
&nbsp;            // Medium and large support vehicle gunner requirements are based on weapon tonnage
<b class="nc">&nbsp;            double tonnage = entity.getWeaponList().stream().filter(m -&gt; !m.getType().hasFlag(WeaponType.F_AMS))</b>
<b class="nc">&nbsp;                    .mapToDouble(m -&gt; m.getTonnage()).sum();</b>
<b class="nc">&nbsp;            if (advFireCon) {</b>
<b class="nc">&nbsp;                if (entity.getStructuralTechRating() == ITechnology.RATING_F) {</b>
<b class="nc">&nbsp;                    return (int) Math.ceil(tonnage / 6.0);</b>
<b class="nc">&nbsp;                } else if (entity.getStructuralTechRating() == ITechnology.RATING_E) {</b>
<b class="nc">&nbsp;                    return (int) Math.ceil(tonnage / 5.0);</b>
&nbsp;                }
<b class="nc">&nbsp;                return (int) Math.ceil(tonnage / 4.0);</b>
<b class="nc">&nbsp;            } else if (basicFireCon) {</b>
<b class="nc">&nbsp;                return (int) Math.ceil(tonnage / 3.0);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return (int) Math.ceil(tonnage / 2.0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates addiontal crew required by support vehicles and advanced aerospace vessels
&nbsp;     * for certain misc equipment.
&nbsp;     *
&nbsp;     * @param entity The unit
&nbsp;     * @return       The number of additional crew required
&nbsp;     */
&nbsp;    public static int getAdditionalNonGunner(Entity entity) {
<b class="nc">&nbsp;        int crew = 0;</b>
<b class="nc">&nbsp;        for (Mounted m : entity.getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {</b>
<b class="nc">&nbsp;                crew += (int) m.getTonnage();</b>
<b class="nc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_FIELD_KITCHEN)) {</b>
<b class="nc">&nbsp;                crew += 3;</b>
<b class="nc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_MOBILE_FIELD_BASE)) {</b>
<b class="nc">&nbsp;                crew += 5;</b>
<b class="nc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_MASH)) {</b>
<b class="nc">&nbsp;                crew += 5 * (int) m.getSize();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return crew;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
&nbsp;    public static int getFullCrewSize(Entity entity) {
<b class="fc">&nbsp;        if (entity.isSupportVehicle()) {</b>
<b class="nc">&nbsp;            int crew = getSVBaseCrewNeeds(entity) + getSupportVehicleGunnerNeeds(entity)</b>
<b class="nc">&nbsp;                    + getAdditionalNonGunner(entity);</b>
<b class="nc">&nbsp;            if (crew &lt; 4) {</b>
<b class="nc">&nbsp;                return crew;</b>
&nbsp;            }
<b class="nc">&nbsp;            return crew + (int) Math.ceil(crew / 6.0);</b>
<b class="fc">&nbsp;        } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            return (int) Math.ceil(entity.getWeight() / 15.0) + ((Tank) entity).getExtraCrewSeats();</b>
<b class="fc">&nbsp;        } else if (entity instanceof BattleArmor) {</b>
<b class="nc">&nbsp;            int ntroopers = 0;</b>
<b class="nc">&nbsp;            for (int trooper = 1; trooper &lt; entity.locations(); trooper++) {</b>
&nbsp;                //less than zero means the suit is destroyed
<b class="nc">&nbsp;                if (entity.getInternal(trooper) &gt;= 0) {</b>
&nbsp;                    //Also, if any modular equipment is missing, then we will consider this
&nbsp;                    //unit to be inoperable and will not allow it to load soldiers. This is because
&nbsp;                    //we have no mechanism in MM to handle BA where some suits have the equipment
&nbsp;                    //and others do not
<b class="nc">&nbsp;                    boolean useSuit = true;</b>
<b class="nc">&nbsp;                    for(Mounted m : entity.getEquipment()) {</b>
<b class="nc">&nbsp;                        if(m.isMissingForTrooper(trooper)) {</b>
<b class="nc">&nbsp;                            useSuit = false;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if(useSuit) {</b>
<b class="nc">&nbsp;                        ntroopers++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return ntroopers;</b>
<b class="fc">&nbsp;        } else if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            return ((Infantry) entity).getSquadN() * ((Infantry) entity).getSquadSize();</b>
<b class="fc">&nbsp;        } else if (entity instanceof Jumpship || entity instanceof SmallCraft) {</b>
<b class="fc">&nbsp;            return getAeroCrewNeeds(entity) + getTotalGunnerNeeds(entity);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return 1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
&nbsp;    public static int getTotalDriverNeeds(Entity entity) {
&nbsp;        //Fix for MHQ Bug #3. Space stations have as much need for pilots as jumpships do.
<b class="nc">&nbsp;        if (entity instanceof SpaceStation) {</b>
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</b>
&nbsp;            //its not at all clear how many pilots dropships and jumpships
&nbsp;            //should have, but the old BattleSpace book suggests they should
&nbsp;            //be able to get by with 2. For warships, lets go with 2 per shift
&nbsp;            // so 6.
<b class="nc">&nbsp;            if (entity instanceof Warship) {</b>
<b class="nc">&nbsp;                return 6;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entity instanceof SmallCraft) {</b>
<b class="nc">&nbsp;                return 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity.getCrew().getCrewType() == CrewType.COMMAND_CONSOLE) {</b>
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (entity instanceof Mech || entity instanceof Tank || entity instanceof Aero || entity instanceof Protomech) {</b>
&nbsp;            //only one driver please
<b class="nc">&nbsp;            return 1;</b>
<b class="nc">&nbsp;        } else if (entity instanceof Infantry) {</b>
<b class="nc">&nbsp;            return getFullCrewSize(entity);</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Should we treat this entity, in its current state, as if it is a spheroid unit
&nbsp;     * flying in atmosphere?
&nbsp;     */
&nbsp;    public static boolean useSpheroidAtmosphere(IGame game, Entity en) {
<b class="nc">&nbsp;        if (!en.isAero()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // are we in space?
<b class="nc">&nbsp;        if (game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // aerodyne&#39;s will operate like spheroids in vacuum
<b class="nc">&nbsp;        if (!((IAero) en).isSpheroid()</b>
<b class="nc">&nbsp;                &amp;&amp; !game.getPlanetaryConditions().isVacuum()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // are we in atmosphere?
<b class="nc">&nbsp;        return en.isAirborne();</b>
&nbsp;    }
&nbsp;
&nbsp;} // End public class Compute
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
