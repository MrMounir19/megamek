


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > LandAirMech</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: LandAirMech (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LandAirMech</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/165)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/861)
  </span>
</td>
</tr>
  <tr>
    <td class="name">LandAirMech$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/166)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/863)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000-2003 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; * This program is free software; you can redistribute it and/or modify it under
&nbsp; * the terms of the GNU General Public License as published by the Free Software
&nbsp; * Foundation; either version 2 of the License, or (at your option) any later
&nbsp; * version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp; * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp; * details.
&nbsp; */
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;
&nbsp;public class LandAirMech extends BipedMech implements IAero, IBomber {
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = -8118673802295814548L;
&nbsp;
&nbsp;    public static final int CONV_MODE_MECH = 0;
&nbsp;    public static final int CONV_MODE_AIRMECH = 1;
&nbsp;    public static final int CONV_MODE_FIGHTER = 2;
&nbsp;
&nbsp;    public static final int LAM_AVIONICS = 15;
&nbsp;
&nbsp;    public static final int LAM_LANDING_GEAR = 16;
&nbsp;
<b class="nc">&nbsp;    public static final String systemNames[] = { &quot;Life Support&quot;, &quot;Sensors&quot;, &quot;Cockpit&quot;, &quot;Engine&quot;, &quot;Gyro&quot;, null, null,</b>
&nbsp;            &quot;Shoulder&quot;, &quot;Upper Arm&quot;, &quot;Lower Arm&quot;, &quot;Hand&quot;, &quot;Hip&quot;, &quot;Upper Leg&quot;, &quot;Lower Leg&quot;, &quot;Foot&quot;, &quot;Avionics&quot;,
&nbsp;            &quot;Landing Gear&quot; };
&nbsp;
&nbsp;    public static final int LAM_UNKNOWN = -1;
&nbsp;    public static final int LAM_STANDARD = 0;
&nbsp;    public static final int LAM_BIMODAL = 1;
&nbsp;
<b class="nc">&nbsp;    public static final String[] LAM_STRING = { &quot;Standard&quot;, &quot;Bimodal&quot; };</b>
&nbsp;
&nbsp;    /** Locations for capital fighter weapons groups */
&nbsp;    public static final int LOC_CAPITAL_NOSE = 8;
&nbsp;    public static final int LOC_CAPITAL_AFT = 9;
&nbsp;    public static final int LOC_CAPITAL_WINGS = 10;
&nbsp;
&nbsp;    /**
&nbsp;     * Translate a &#39;Mech location to the equivalent Aero location.
&nbsp;     */
&nbsp;    public static int getAeroLocation(int loc) {
<b class="nc">&nbsp;        switch (loc) {</b>
&nbsp;        case LOC_HEAD:
&nbsp;        case LOC_CT:
&nbsp;        case LOC_CAPITAL_NOSE:
<b class="nc">&nbsp;            return Aero.LOC_NOSE;</b>
&nbsp;        case LOC_RT:
&nbsp;        case LOC_RARM:
<b class="nc">&nbsp;            return Aero.LOC_RWING;</b>
&nbsp;        case LOC_LT:
&nbsp;        case LOC_LARM:
<b class="nc">&nbsp;            return Aero.LOC_LWING;</b>
&nbsp;        case LOC_RLEG:
&nbsp;        case LOC_LLEG:
&nbsp;        case LOC_CAPITAL_AFT:
<b class="nc">&nbsp;            return Aero.LOC_AFT;</b>
&nbsp;        case LOC_CAPITAL_WINGS:
<b class="nc">&nbsp;            return Aero.LOC_WINGS;</b>
&nbsp;        }
<b class="nc">&nbsp;        return LOC_NONE;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final String[] LOCATION_NAMES = { &quot;Head&quot;, &quot;Center Torso&quot;, &quot;Right Torso&quot;, &quot;Left Torso&quot;, &quot;Right Arm&quot;,</b>
&nbsp;            &quot;Left Arm&quot;, &quot;Right Leg&quot;, &quot;Left Leg&quot;, &quot;Nose&quot;, &quot;Aft&quot;, &quot;Wings&quot; };
&nbsp;
<b class="nc">&nbsp;    private static final String[] LOCATION_ABBRS = { &quot;HD&quot;, &quot;CT&quot;, &quot;RT&quot;, &quot;LT&quot;, &quot;RA&quot;, &quot;LA&quot;, &quot;RL&quot;, &quot;LL&quot;, &quot;NOS&quot;, &quot;AFT&quot;,</b>
&nbsp;            &quot;WNG&quot; };
&nbsp;
<b class="nc">&nbsp;    private static final int[] NUM_OF_SLOTS = { 6, 12, 12, 12, 12, 12, 6, 6, 100, 100, 100 };</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of slot counts for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected int[] getNoOfSlots() {
<b class="nc">&nbsp;        return NUM_OF_SLOTS;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of names for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String[] getLocationNames() {
<b class="nc">&nbsp;        return LOCATION_NAMES;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of abbreviations for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String[] getLocationAbbrs() {
<b class="nc">&nbsp;        return LOCATION_ABBRS;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int lamType;
&nbsp;
&nbsp;    /** Fighter mode **/
&nbsp;    // out of control
<b class="nc">&nbsp;    private boolean outControl = false;</b>
<b class="nc">&nbsp;    private boolean outCtrlHeat = false;</b>
<b class="nc">&nbsp;    private boolean randomMove = false;</b>
&nbsp;
&nbsp;    // set up movement
<b class="nc">&nbsp;    private int currentVelocity = 0;</b>
<b class="nc">&nbsp;    private int nextVelocity = currentVelocity;</b>
<b class="nc">&nbsp;    private boolean accLast = false;</b>
<b class="nc">&nbsp;    private boolean rolled = false;</b>
<b class="nc">&nbsp;    private boolean failedManeuver = false;</b>
<b class="nc">&nbsp;    private boolean accDecNow = false;</b>
<b class="nc">&nbsp;    private int straightMoves = 0;</b>
<b class="nc">&nbsp;    private int altLoss = 0;</b>
<b class="nc">&nbsp;    private int altLossThisRound = 0;</b>
&nbsp;    
&nbsp;    //Autoejection
<b class="nc">&nbsp;    private boolean critThresh = false;</b>
&nbsp;
<b class="nc">&nbsp;    private int[] bombChoices = new int[BombType.B_NUM];</b>
<b class="nc">&nbsp;    private Targetable airmechBombTarget = null;</b>
&nbsp;
&nbsp;    private int fuel;
&nbsp;    private int currentfuel;
&nbsp;    private int whoFirst;
&nbsp;
&nbsp;    // Capital Fighter stuff
<b class="nc">&nbsp;    private int capitalArmor = 0;</b>
<b class="nc">&nbsp;    private int capitalArmor_orig = 2;</b>
<b class="nc">&nbsp;    private int fatalThresh = 0;</b>
<b class="nc">&nbsp;    private int currentDamage = 0;</b>
<b class="nc">&nbsp;    private Map&lt;String, Integer&gt; weaponGroups = new HashMap&lt;String, Integer&gt;();</b>
&nbsp;
&nbsp;    public LandAirMech(int inGyroType, int inCockpitType, int inLAMType) {
<b class="nc">&nbsp;        super(inGyroType, inCockpitType);</b>
<b class="nc">&nbsp;        lamType = inLAMType;</b>
&nbsp;
<b class="nc">&nbsp;        setTechLevel(TechConstants.T_IS_ADVANCED);</b>
<b class="nc">&nbsp;        setCritical(Mech.LOC_HEAD, 3, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, LAM_AVIONICS));</b>
<b class="nc">&nbsp;        setCritical(Mech.LOC_LT, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, LAM_AVIONICS));</b>
<b class="nc">&nbsp;        setCritical(Mech.LOC_RT, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, LAM_AVIONICS));</b>
<b class="nc">&nbsp;        setCritical(Mech.LOC_LT, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, LAM_LANDING_GEAR));</b>
<b class="nc">&nbsp;        setCritical(Mech.LOC_RT, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, LAM_LANDING_GEAR));</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(Mech.LOC_CT); i++) {</b>
<b class="nc">&nbsp;            if (null == getCritical(Mech.LOC_CT, i)) {</b>
<b class="nc">&nbsp;                setCritical(Mech.LOC_CT, i, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, LAM_LANDING_GEAR));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        previousMovementMode = movementMode;</b>
<b class="nc">&nbsp;        setFuel(80);</b>
&nbsp;
<b class="nc">&nbsp;        setCrew(new LAMPilot(this));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setCrew(Crew newCrew) {
<b class="nc">&nbsp;        if (newCrew instanceof LAMPilot) {</b>
<b class="nc">&nbsp;            super.setCrew(newCrew);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            super.setCrew(LAMPilot.convertToLAMPilot(this, newCrew));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSystemName(int index) {
<b class="nc">&nbsp;        if (index == SYSTEM_GYRO) {</b>
<b class="nc">&nbsp;            return Mech.getGyroDisplayString(gyroType);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (index == SYSTEM_COCKPIT) {</b>
<b class="nc">&nbsp;            return Mech.getCockpitDisplayString(cockpitType);</b>
&nbsp;        }
<b class="nc">&nbsp;        return systemNames[index];</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getRawSystemName(int index) {
<b class="nc">&nbsp;        return systemNames[index];</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getLAMType() {
<b class="nc">&nbsp;        return lamType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLAMType(int lamType) {
<b class="nc">&nbsp;        this.lamType = lamType;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getLAMTypeString(int lamType) {
<b class="nc">&nbsp;        if (lamType &lt; 0 || lamType &gt;= LAM_STRING.length) {</b>
<b class="nc">&nbsp;            return LAM_STRING[LAM_UNKNOWN];</b>
&nbsp;        }
<b class="nc">&nbsp;        return LAM_STRING[lamType];</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getLAMTypeString() {
<b class="nc">&nbsp;        return getLAMTypeString(getLAMType());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int getLAMTypeForString(String inType) {
<b class="nc">&nbsp;        if ((inType == null) || (inType.length() &lt; 1)) {</b>
<b class="nc">&nbsp;            return LAM_UNKNOWN;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int x = 0; x &lt; LAM_STRING.length; x++) {</b>
<b class="nc">&nbsp;            if (inType.equals(LAM_STRING[x])) {</b>
<b class="nc">&nbsp;                return x;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return LAM_UNKNOWN;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean doomedInAtmosphere() {
<b class="nc">&nbsp;        return getConversionMode() != CONV_MODE_FIGHTER;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean doomedInSpace() {
<b class="nc">&nbsp;        return getConversionMode() != CONV_MODE_FIGHTER;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Current MP is calculated differently depending on the LAM&#39;s mode. AirMech
&nbsp;     * mode returns cruise/flank; walk/run is treated as a special case of WiGE
&nbsp;     * ground movement.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getWalkMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
&nbsp;        int mp;
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            mp = getFighterModeWalkMP(gravity, ignoremodulararmor);</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            mp = getAirMechCruiseMP(gravity, ignoremodulararmor);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            mp = super.getWalkMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (convertingNow) {</b>
<b class="nc">&nbsp;            mp /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;    
&nbsp;    // Use Mech mode to determine walk MP for BV calculations
&nbsp;    public int getBVWalkMP() {
<b class="nc">&nbsp;        return super.getWalkMP(false, true, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getRunMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
&nbsp;        int mp;
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            mp = getFighterModeRunMP(gravity, ignoremodulararmor);</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            mp = getAirMechFlankMP(gravity, ignoremodulararmor);</b>
&nbsp;        } else {
&nbsp;            // conversion reduction has already been done at this point
<b class="nc">&nbsp;            return super.getRunMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (convertingNow) {</b>
<b class="nc">&nbsp;            mp /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getRunMPwithoutMASC(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
&nbsp;        int mp;
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            mp = getFighterModeRunMP(gravity, ignoremodulararmor);</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            mp = getAirMechFlankMP(gravity, ignoremodulararmor);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return super.getRunMPwithoutMASC(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (convertingNow) {</b>
<b class="nc">&nbsp;            mp /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This value should only be used for biped and airmech ground movement.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getSprintMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return getRunMP();</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            if (hasHipCrit()) {</b>
<b class="nc">&nbsp;                return getAirMechRunMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;            }
<b class="nc">&nbsp;            return (int) Math</b>
<b class="nc">&nbsp;                    .ceil(getAirMechWalkMP(gravity, ignoreheat, ignoremodulararmor) * (hasArmedMASC() ? 2.5 : 2.0));</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.getSprintMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This value should only be used for biped and airmech ground movement.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getSprintMPwithoutMASC(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return getRunMP();</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            if (hasHipCrit()) {</b>
<b class="nc">&nbsp;                return getAirMechRunMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;            }
<b class="nc">&nbsp;            return getAirMechWalkMP(gravity, ignoreheat, ignoremodulararmor) * 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.getSprintMPwithoutMASC(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getOriginalSprintMPwithoutMASC() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_MECH) {</b>
<b class="nc">&nbsp;            return (int) Math.ceil(getOriginalWalkMP() * 2.0);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return getOriginalRunMP();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechCruiseMP(boolean gravity, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (game != null &amp;&amp; game.getBoard().inAtmosphere()</b>
<b class="nc">&nbsp;                &amp;&amp; (isLocationBad(Mech.LOC_LT) || isLocationBad(Mech.LOC_RT))) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getJumpMP(gravity, ignoremodulararmor) * 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechFlankMP(boolean gravity, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (game != null &amp;&amp; game.getBoard().inAtmosphere()</b>
<b class="nc">&nbsp;                &amp;&amp; (isLocationBad(Mech.LOC_LT) || isLocationBad(Mech.LOC_RT))) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (int) Math.ceil(getAirMechCruiseMP(gravity, ignoremodulararmor) * 1.5);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechWalkMP() {
<b class="nc">&nbsp;        return getAirMechWalkMP(true, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechWalkMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        int mp = (int) Math.ceil(super.getWalkMP(gravity, ignoreheat, ignoremodulararmor) * 0.33);</b>
<b class="nc">&nbsp;        if (convertingNow) {</b>
<b class="nc">&nbsp;            mp /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechRunMP() {
<b class="nc">&nbsp;        return getAirMechRunMP(true, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechRunMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        int mp = (int) Math.ceil(getAirMechWalkMP(gravity, ignoreheat, ignoremodulararmor) * 1.5);</b>
<b class="nc">&nbsp;        if (convertingNow) {</b>
<b class="nc">&nbsp;            mp /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFighterModeWalkMP(boolean gravity, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        int thrust = getCurrentThrust();</b>
<b class="nc">&nbsp;        if (!isAirborne()) {</b>
<b class="nc">&nbsp;            thrust /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return thrust;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFighterModeRunMP(boolean gravity, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        int walk = getFighterModeWalkMP(gravity, ignoremodulararmor);</b>
<b class="nc">&nbsp;        if (isAirborne()) {</b>
<b class="nc">&nbsp;            return (int) Math.ceil(walk * 1.5);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return walk; // Grounded asfs cannot use flanking movement</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCurrentThrust() {
&nbsp;        // Cannot fly in atmosphere with missing side torso
<b class="nc">&nbsp;        if (!isSpaceborne() &amp;&amp; (isLocationBad(LOC_RT) || isLocationBad(LOC_LT))) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int j = getJumpMP();</b>
<b class="nc">&nbsp;        if (null != game) {</b>
<b class="nc">&nbsp;            int weatherMod = game.getPlanetaryConditions().getMovementMods(this);</b>
<b class="nc">&nbsp;            if (weatherMod != 0) {</b>
<b class="nc">&nbsp;                j = Math.max(j + weatherMod, 0);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return j;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechCruiseMP() {
<b class="nc">&nbsp;        return getAirMechCruiseMP(true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechFlankMP() {
<b class="nc">&nbsp;        return getAirMechFlankMP(true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFighterModeWalkMP() {
<b class="nc">&nbsp;        return getFighterModeWalkMP(true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFighterModeRunMP() {
<b class="nc">&nbsp;        return getFighterModeRunMP(true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * LAMs cannot benefit from MASC in AirMech or fighter mode and cannot mount
&nbsp;     * a supercharger.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasArmedMASC() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_MECH) {</b>
<b class="nc">&nbsp;            return super.hasArmedMASC();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isImmobile() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER &amp;&amp; (isAirborne() || isSpaceborne())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.isImmobile();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getWalkHeat() {
<b class="nc">&nbsp;        if (moved == EntityMovementType.MOVE_VTOL_WALK) {</b>
<b class="nc">&nbsp;            return getAirMechHeat();</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.getWalkHeat();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getRunHeat() {
<b class="nc">&nbsp;        if (moved == EntityMovementType.MOVE_VTOL_RUN) {</b>
<b class="nc">&nbsp;            return getAirMechHeat();</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.getRunHeat();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAirMechHeat() {
<b class="nc">&nbsp;        int mod = bDamagedCoolantSystem ? 1 : 0;</b>
<b class="nc">&nbsp;        return mod + (int) Math.round(getJumpHeat(mpUsed) / 3.0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getEngineCritHeat() {
&nbsp;        // Engine crit heat follows ASF rules in fighter mode.
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return 2 * getEngineHits();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return super.getEngineCritHeat();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getHeatSinks() {
<b class="nc">&nbsp;        return getActiveSinks();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean usesTurnMode() {
&nbsp;        // Turn mode rule is not optional for LAMs in AirMech mode.
<b class="nc">&nbsp;        return getConversionMode() == CONV_MODE_AIRMECH;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When cycling through possible movement modes, we need to know if we&#39;ve
&nbsp;     * returned to the previous mode, which means that no conversion is actually
&nbsp;     * going to take place.
&nbsp;     *
&nbsp;     * @return The movement mode on the previous turn.
&nbsp;     */
&nbsp;    public EntityMovementMode getPreviousMovementMode() {
<b class="nc">&nbsp;        return previousMovementMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getPreviousConversionMode() {
<b class="nc">&nbsp;        switch (previousMovementMode) {</b>
&nbsp;        case AERODYNE:
&nbsp;        case WHEELED:
<b class="nc">&nbsp;            return CONV_MODE_FIGHTER;</b>
&nbsp;        case WIGE:
<b class="nc">&nbsp;            return CONV_MODE_AIRMECH;</b>
&nbsp;        case BIPED:
&nbsp;        default:
<b class="nc">&nbsp;            return CONV_MODE_MECH;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setMovementMode(EntityMovementMode mode) {
<b class="nc">&nbsp;        int prevMode = getConversionMode();</b>
<b class="nc">&nbsp;        if (mode == EntityMovementMode.AERODYNE || mode == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;            setConversionMode(CONV_MODE_FIGHTER);</b>
<b class="nc">&nbsp;        } else if (mode == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;            setConversionMode(CONV_MODE_AIRMECH);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setConversionMode(CONV_MODE_MECH);</b>
&nbsp;        }
<b class="nc">&nbsp;        super.setMovementMode(mode);</b>
&nbsp;
<b class="nc">&nbsp;        if (getConversionMode() != prevMode) {</b>
<b class="nc">&nbsp;            if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                setRapidFire();</b>
<b class="nc">&nbsp;            } else if (prevMode == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                for (Mounted m : getTotalWeaponList()) {</b>
<b class="nc">&nbsp;                    WeaponType wtype = (WeaponType) m.getType();</b>
<b class="nc">&nbsp;                    if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</b>
<b class="nc">&nbsp;                        m.setMode(&quot;&quot;);</b>
<b class="nc">&nbsp;                        m.setModeSwitchable(true);</b>
<b class="nc">&nbsp;                    } else if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA) {</b>
<b class="nc">&nbsp;                        m.setMode(&quot;&quot;);</b>
<b class="nc">&nbsp;                        m.setModeSwitchable(true);</b>
<b class="nc">&nbsp;                    } else if (wtype.hasIndirectFire()) {</b>
<b class="nc">&nbsp;                        m.setModeSwitchable(true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            resetBombAttacks();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setConversionMode(int mode) {
<b class="nc">&nbsp;        if (mode == getConversionMode()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mode == CONV_MODE_MECH) {</b>
<b class="nc">&nbsp;            super.setMovementMode(EntityMovementMode.BIPED);</b>
<b class="nc">&nbsp;        } else if (mode == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            super.setMovementMode(EntityMovementMode.WIGE);</b>
<b class="nc">&nbsp;        } else if (mode == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            super.setMovementMode(EntityMovementMode.AERODYNE);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        super.setConversionMode(mode);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canAssaultDrop() {
<b class="nc">&nbsp;        return getConversionMode() != CONV_MODE_FIGHTER;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isLocationProhibited(Coords c, int currElevation) {
&nbsp;        // Fighter mode has the same terrain restrictions as ASFs.
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            if (isAirborne()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(c);</b>
&nbsp;
&nbsp;            // Additional restrictions for hidden units
<b class="nc">&nbsp;            if (isHidden()) {</b>
&nbsp;                // Can&#39;t deploy in paved hexes
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.PAVEMENT) || hex.containsTerrain(Terrains.ROAD)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                // Can&#39;t deploy on a bridge
<b class="nc">&nbsp;                if ((hex.terrainLevel(Terrains.BRIDGE_ELEV) == currElevation) &amp;&amp; hex.containsTerrain(Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                // Can&#39;t deploy on the surface of water
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.WATER) &amp;&amp; (currElevation == 0)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // grounded aeros have the same prohibitions as wheeled tanks
<b class="nc">&nbsp;            return hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.ROUGH)</b>
<b class="nc">&nbsp;                    || ((hex.terrainLevel(Terrains.WATER) &gt; 0) &amp;&amp; !hex.containsTerrain(Terrains.ICE))</b>
<b class="nc">&nbsp;                    || hex.containsTerrain(Terrains.RUBBLE) || hex.containsTerrain(Terrains.MAGMA)</b>
<b class="nc">&nbsp;                    || hex.containsTerrain(Terrains.JUNGLE) || (hex.terrainLevel(Terrains.SNOW) &gt; 1)</b>
<b class="nc">&nbsp;                    || (hex.terrainLevel(Terrains.GEYSER) == 2);</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH &amp;&amp; currElevation &gt; 0) {</b>
&nbsp;            // Cannot enter woods or a building hex in AirMech mode unless using
&nbsp;            // ground movement
&nbsp;            // or flying over the terrain.
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;            return (hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)</b>
<b class="nc">&nbsp;                    || hex.containsTerrain(Terrains.BLDG_ELEV)) &amp;&amp; hex.ceiling() &gt; currElevation;</b>
&nbsp;        } else {
&nbsp;            // Mech mode or AirMech mode using ground MP have the same
&nbsp;            // restrictions as Biped Mech.
<b class="nc">&nbsp;            return super.isLocationProhibited(c, currElevation);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getMovementString(EntityMovementType mtype) {
<b class="nc">&nbsp;        switch (mtype) {</b>
&nbsp;        case MOVE_WALK:
<b class="nc">&nbsp;            if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                return &quot;Cruised&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return &quot;Walked&quot;;</b>
&nbsp;            }
&nbsp;        case MOVE_RUN:
<b class="nc">&nbsp;            if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                return &quot;Flanked&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return &quot;Ran&quot;;</b>
&nbsp;            }
&nbsp;        case MOVE_VTOL_WALK:
<b class="nc">&nbsp;            return &quot;Cruised&quot;;</b>
&nbsp;        case MOVE_VTOL_RUN:
<b class="nc">&nbsp;            return &quot;Flanked&quot;;</b>
&nbsp;        case MOVE_SAFE_THRUST:
<b class="nc">&nbsp;            return &quot;Safe Thrust&quot;;</b>
&nbsp;        case MOVE_OVER_THRUST:
<b class="nc">&nbsp;            return &quot;Over Thrust&quot;;</b>
&nbsp;        default:
<b class="nc">&nbsp;            return super.getMovementString(mtype);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getMovementAbbr(EntityMovementType mtype) {
<b class="nc">&nbsp;        switch (mtype) {</b>
&nbsp;        case MOVE_WALK:
<b class="nc">&nbsp;            if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                return &quot;C&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return &quot;W&quot;;</b>
&nbsp;            }
&nbsp;        case MOVE_RUN:
<b class="nc">&nbsp;            if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                return &quot;F&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return &quot;R&quot;;</b>
&nbsp;            }
&nbsp;        case MOVE_VTOL_WALK:
<b class="nc">&nbsp;            return &quot;C&quot;;</b>
&nbsp;        case MOVE_VTOL_RUN:
<b class="nc">&nbsp;            return &quot;F&quot;;</b>
&nbsp;        case MOVE_NONE:
<b class="nc">&nbsp;            return &quot;N&quot;;</b>
&nbsp;        case MOVE_SAFE_THRUST:
<b class="nc">&nbsp;            return &quot;S&quot;;</b>
&nbsp;        case MOVE_OVER_THRUST:
<b class="nc">&nbsp;            return &quot;O&quot;;</b>
&nbsp;        default:
<b class="nc">&nbsp;            return super.getMovementAbbr(mtype);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add in any piloting skill mods
&nbsp;     */
&nbsp;    @Override
&nbsp;    public PilotingRollData addEntityBonuses(PilotingRollData roll) {
&nbsp;        // Modifier for pilot hits applies in all modes.
<b class="nc">&nbsp;        if (getCrew().getHits(0) &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(getCrew().getHits(0), &quot;pilot hits&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getConversionMode() != CONV_MODE_FIGHTER &amp;&amp; !isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            return super.addEntityBonuses(roll);</b>
&nbsp;        }
&nbsp;
&nbsp;        // In fighter mode a destroyed gyro gives +6 to the control roll.
<b class="nc">&nbsp;        int gyroHits = getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, Mech.LOC_CT);</b>
<b class="nc">&nbsp;        if (gyroHits &gt; 0) {</b>
<b class="nc">&nbsp;            if (getGyroType() == Mech.GYRO_HEAVY_DUTY) {</b>
<b class="nc">&nbsp;                if (gyroHits == 1) {</b>
<b class="nc">&nbsp;                    roll.addModifier(1, &quot;HD Gyro damaged once&quot;);</b>
<b class="nc">&nbsp;                } else if (gyroHits == 2) {</b>
<b class="nc">&nbsp;                    roll.addModifier(3, &quot;HD Gyro damaged twice&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    roll.addModifier(6, &quot;Gyro destroyed&quot;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (gyroHits == 1) {</b>
<b class="nc">&nbsp;                    roll.addModifier(3, &quot;Gyro damaged&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    roll.addModifier(6, &quot;Gyro destroyed&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // EI bonus?
<b class="nc">&nbsp;        if (hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;Enhanced Imaging&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // VDNI bonus?
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                &amp;&amp; !hasAbility(OptionsConstants.MD_BVDNI)) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;VDNI&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Small/torso-mounted cockpit penalty?
<b class="nc">&nbsp;        if ((getCockpitType() == Mech.COCKPIT_SMALL)</b>
<b class="nc">&nbsp;                &amp;&amp; !hasAbility(OptionsConstants.MD_BVDNI)</b>
<b class="nc">&nbsp;                &amp;&amp; !hasAbility(OptionsConstants.UNOFF_SMALL_PILOT)) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;Small Cockpit&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_CRAMPED_COCKPIT) &amp;&amp; !hasAbility(OptionsConstants.UNOFF_SMALL_PILOT)) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;cramped cockpit&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int avionicsHits = getAvionicsHits();</b>
<b class="nc">&nbsp;        if (avionicsHits &gt; 2) {</b>
<b class="nc">&nbsp;            roll.addModifier(5, &quot;avionics destroyed&quot;);</b>
<b class="nc">&nbsp;        } else if (avionicsHits &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(avionicsHits, &quot;avionics damage&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            if (moved == EntityMovementType.MOVE_OVER_THRUST) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;Used more than safe thrust&quot;);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            int vel = getCurrentVelocity();</b>
<b class="nc">&nbsp;            int vmod = vel - (2 * getWalkMP());</b>
<b class="nc">&nbsp;            if (!getGame().getBoard().inSpace() &amp;&amp; (vmod &gt; 0)) {</b>
<b class="nc">&nbsp;                roll.addModifier(vmod, &quot;Velocity greater than 2x safe thrust&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int atmoCond = game.getPlanetaryConditions().getAtmosphere();</b>
&nbsp;            // add in atmospheric effects later
<b class="nc">&nbsp;            if (!(game.getBoard().inSpace() || (atmoCond == PlanetaryConditions.ATMO_VACUUM)) &amp;&amp; isAirborne()) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;Atmospheric operations&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (hasQuirk(OptionsConstants.QUIRK_POS_ATMO_FLYER) &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                roll.addModifier(-1, &quot;atmospheric flyer&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hasQuirk(OptionsConstants.QUIRK_NEG_ATMO_INSTABILITY) &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;atmospheric flight instability&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Landing in AirMech mode requires a control roll only if the gyro or any
&nbsp;     * of the hip or leg actuators are damaged.
&nbsp;     *
&nbsp;     * @return The control roll that must be passed to land safely.
&nbsp;     */
&nbsp;    public PilotingRollData checkAirMechLanding() {
&nbsp;        // Base piloting skill
<b class="nc">&nbsp;        PilotingRollData roll = new PilotingRollData(getId(), getCrew().getPiloting(), &quot;Base piloting skill&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        addEntityBonuses(roll);</b>
&nbsp;
&nbsp;        // Landing in AirMech mode only requires a roll if gyro or hip/leg
&nbsp;        // actuators are damaged.
<b class="nc">&nbsp;        int gyroHits = getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, Mech.LOC_CT);</b>
<b class="nc">&nbsp;        if (getGyroType() == Mech.GYRO_HEAVY_DUTY) {</b>
<b class="nc">&nbsp;            gyroHits--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean required = gyroHits &gt; 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;            if (locationIsLeg(loc)) {</b>
<b class="nc">&nbsp;                if (isLocationBad(loc)) {</b>
<b class="nc">&nbsp;                    roll.addModifier(5, getLocationName(loc) + &quot; destroyed&quot;);</b>
<b class="nc">&nbsp;                    required = true;</b>
&nbsp;                } else {
&nbsp;                    // check for damaged hip actuators
<b class="nc">&nbsp;                    if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        roll.addModifier(2, getLocationName(loc) + &quot; Hip Actuator destroyed&quot;);</b>
<b class="nc">&nbsp;                        if (!game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        required = true;</b>
&nbsp;                    }
&nbsp;                    // upper leg actuators?
<b class="nc">&nbsp;                    if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc) + &quot; Upper Leg Actuator destroyed&quot;);</b>
<b class="nc">&nbsp;                        required = true;</b>
&nbsp;                    }
&nbsp;                    // lower leg actuators?
<b class="nc">&nbsp;                    if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc) + &quot; Lower Leg Actuator destroyed&quot;);</b>
<b class="nc">&nbsp;                        required = true;</b>
&nbsp;                    }
&nbsp;                    // foot actuators?
<b class="nc">&nbsp;                    if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_FOOT, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        roll.addModifier(1, getLocationName(loc) + &quot; Foot Actuator destroyed&quot;);</b>
<b class="nc">&nbsp;                        required = true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (required) {</b>
<b class="nc">&nbsp;            roll.addModifier(0, &quot;landing with gyro or leg damage&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check not required for landing&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getMaxElevationDown(int currElevation) {
&nbsp;        // Cannot spend AirMech MP above altitude 3 (level 30) so we use that as
&nbsp;        // max descent.
<b class="nc">&nbsp;        if ((currElevation &gt; 0) &amp;&amp; (getConversionMode() == CONV_MODE_AIRMECH)) {</b>
<b class="nc">&nbsp;            return 30;</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.getMaxElevationDown(currElevation);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canChangeSecondaryFacing() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_MECH) {</b>
<b class="nc">&nbsp;            return super.canChangeSecondaryFacing();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Start a new round
&nbsp;     *
&nbsp;     * @param roundNumber
&nbsp;     *            the &lt;code&gt;int&lt;/code&gt; number of the new round
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void newRound(int roundNumber) {
<b class="nc">&nbsp;        super.newRound(roundNumber);</b>
<b class="nc">&nbsp;        previousMovementMode = movementMode;</b>
&nbsp;
&nbsp;        // reset threshold critted
<b class="nc">&nbsp;        setCritThresh(false);</b>
&nbsp;
&nbsp;        // reset maneuver status
<b class="nc">&nbsp;        setFailedManeuver(false);</b>
&nbsp;        // reset acc/dec this turn
<b class="nc">&nbsp;        setAccDecNow(false);</b>
&nbsp;
<b class="nc">&nbsp;        updateBays();</b>
&nbsp;
&nbsp;        // update recovery turn if in recovery
<b class="nc">&nbsp;        if (getRecoveryTurn() &gt; 0) {</b>
<b class="nc">&nbsp;            setRecoveryTurn(getRecoveryTurn() - 1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        airmechBombTarget = null;</b>
&nbsp;
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
&nbsp;            // if in atmosphere, then halve next turn&#39;s velocity
<b class="nc">&nbsp;            if (!game.getBoard().inSpace() &amp;&amp; isDeployed() &amp;&amp; (roundNumber &gt; 0)) {</b>
<b class="nc">&nbsp;                setNextVelocity((int) Math.floor(getNextVelocity() / 2.0));</b>
&nbsp;            }
&nbsp;
&nbsp;            // update velocity
<b class="nc">&nbsp;            setCurrentVelocity(getNextVelocity());</b>
&nbsp;
&nbsp;            // if they are out of control due to heat, then apply this and reset
<b class="nc">&nbsp;            if (isOutCtrlHeat()) {</b>
<b class="nc">&nbsp;                setOutControl(true);</b>
<b class="nc">&nbsp;                setOutCtrlHeat(false);</b>
&nbsp;            }
&nbsp;
&nbsp;            // get new random whofirst
<b class="nc">&nbsp;            setWhoFirst();</b>
&nbsp;
<b class="nc">&nbsp;            resetAltLossThisRound();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Cannot make any physical attacks in fighter mode except ramming, which is
&nbsp;     * handled in the movement phase.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isEligibleForPhysical() {
<b class="nc">&nbsp;        return getConversionMode() != CONV_MODE_FIGHTER &amp;&amp; super.isEligibleForPhysical();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canCharge() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER</b>
<b class="nc">&nbsp;                || ((getConversionMode() == CONV_MODE_AIRMECH) &amp;&amp; isAirborneVTOLorWIGE())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return super.canCharge();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canRam() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return !isImmobile() &amp;&amp; (getWalkMP() &gt; 0);</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            return isAirborneVTOLorWIGE();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Cycling through conversion modes for LAMs in &#39;Mech or fighter mode is
&nbsp;     * simple toggling between two states. LAMs in AirMech mode have three
&nbsp;     * possible states.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public EntityMovementMode nextConversionMode(EntityMovementMode afterMode) {
<b class="nc">&nbsp;        boolean inSpace = game != null &amp;&amp; game.getBoard().inSpace();</b>
<b class="nc">&nbsp;        if (previousMovementMode == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;            if (afterMode == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;                return EntityMovementMode.AERODYNE;</b>
<b class="nc">&nbsp;            } else if (afterMode == EntityMovementMode.AERODYNE || afterMode == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;                return originalMovementMode;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return EntityMovementMode.WIGE;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (afterMode == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;            return inSpace ? EntityMovementMode.AERODYNE : previousMovementMode;</b>
<b class="nc">&nbsp;        } else if (afterMode == EntityMovementMode.AERODYNE || afterMode == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;            return (inSpace || lamType == LAM_BIMODAL) ? originalMovementMode : EntityMovementMode.WIGE;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return lamType == LAM_BIMODAL ? EntityMovementMode.AERODYNE : EntityMovementMode.WIGE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean canConvertTo(EntityMovementMode toMode) {
<b class="nc">&nbsp;        return canConvertTo(getConversionMode(), getConversionModeFor(toMode));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean canConvertTo(int fromMode, EntityMovementMode toMode) {
<b class="nc">&nbsp;        return canConvertTo(fromMode, getConversionModeFor(toMode));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether it is possible to assume a particular mode based on
&nbsp;     * damage and type of map.
&nbsp;     *
&nbsp;     * @param fromMode
&nbsp;     *            The mode to convert from (one of CONV_MODE_MECH,
&nbsp;     *            CONV_MODE_AIRMECH, or CONV_MODE_FIGHTER)
&nbsp;     * @param toMode
&nbsp;     *            The mode to convert to (one of CONV_MODE_MECH,
&nbsp;     *            CONV_MODE_AIRMECH, or CONV_MODE_FIGHTER)
&nbsp;     * @return true if it is possible for the LAM to convert to the given mode.
&nbsp;     */
&nbsp;    public boolean canConvertTo(int fromMode, int toMode) {
&nbsp;        // Cannot convert with any gyro damage
<b class="nc">&nbsp;        int gyroHits = getBadCriticals(CriticalSlot.TYPE_SYSTEM, SYSTEM_GYRO, LOC_CT);</b>
<b class="nc">&nbsp;        if (getGyroType() == Mech.GYRO_HEAVY_DUTY) {</b>
<b class="nc">&nbsp;            gyroHits--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (gyroHits &gt; 0) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Cannot convert to or from mech mode with damage shoulder or arm
&nbsp;        // actuators
<b class="nc">&nbsp;        if ((toMode == CONV_MODE_MECH || fromMode == CONV_MODE_MECH)</b>
<b class="nc">&nbsp;                &amp;&amp; (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_SHOULDER, LOC_RARM)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_ARM, LOC_RARM)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_ARM, LOC_RARM)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_SHOULDER, LOC_LARM)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_ARM, LOC_LARM)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_ARM, LOC_LARM) &gt; 0)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Cannot convert to or from fighter mode with damage hip or leg
&nbsp;        // actuators
<b class="nc">&nbsp;        if ((toMode == CONV_MODE_FIGHTER || fromMode == CONV_MODE_FIGHTER)</b>
<b class="nc">&nbsp;                &amp;&amp; (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, LOC_RLEG)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, LOC_RLEG)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, LOC_RLEG)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, LOC_LLEG)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, LOC_LLEG)</b>
<b class="nc">&nbsp;                        + getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, LOC_LLEG) &gt; 0)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (toMode == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            if (getLAMType() == LAM_BIMODAL) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (toMode == CONV_MODE_FIGHTER) {</b>
&nbsp;            // Standard LAMs can convert from mech to fighter mode in a single
&nbsp;            // round on a space map
<b class="nc">&nbsp;            if (fromMode == CONV_MODE_MECH) {</b>
<b class="nc">&nbsp;                return getLAMType() == LAM_BIMODAL || game.getBoard().inSpace();</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (toMode == CONV_MODE_MECH) {</b>
&nbsp;            // Standard LAMs can convert from fighter to mech mode in a single
&nbsp;            // round on a space map
<b class="nc">&nbsp;            if (fromMode == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;                return getLAMType() == LAM_BIMODAL || game.getBoard().inSpace();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getConversionModeFor(EntityMovementMode mmode) {
<b class="nc">&nbsp;        if (mmode == EntityMovementMode.AERODYNE || mmode == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;            return CONV_MODE_FIGHTER;</b>
<b class="nc">&nbsp;        } else if (mmode == EntityMovementMode.WIGE) {</b>
<b class="nc">&nbsp;            return CONV_MODE_AIRMECH;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return CONV_MODE_MECH;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canFall(boolean gyroLegDamage) {
<b class="nc">&nbsp;        return getConversionMode() != CONV_MODE_FIGHTER &amp;&amp; !isAirborneVTOLorWIGE() &amp;&amp; super.canFall(gyroLegDamage);</b>
&nbsp;    }
&nbsp;    
<b class="nc">&nbsp;    private static final TechAdvancement[] TA_LAM = {</b>
<b class="nc">&nbsp;            new TechAdvancement(TECH_BASE_IS).setISAdvancement(2683, 2688, DATE_NONE, 3085)</b>
<b class="nc">&nbsp;                .setClanAdvancement(DATE_NONE, 2688, DATE_NONE, 2825)</b>
<b class="nc">&nbsp;                .setPrototypeFactions(F_TH).setProductionFactions(F_TH)</b>
<b class="nc">&nbsp;                .setTechRating(RATING_D).setAvailability(RATING_D, RATING_E, RATING_F, RATING_F)</b>
<b class="nc">&nbsp;                .setStaticTechLevel(SimpleTechLevel.EXPERIMENTAL), //standard</b>
<b class="nc">&nbsp;            new TechAdvancement(TECH_BASE_IS).setISAdvancement(2680, 2684, DATE_NONE, 2781)</b>
<b class="nc">&nbsp;                .setClanAdvancement(DATE_NONE, 2684, DATE_NONE, 2801)</b>
<b class="nc">&nbsp;                .setPrototypeFactions(F_TH).setProductionFactions(F_TH)</b>
<b class="nc">&nbsp;                .setTechRating(RATING_E).setAvailability(RATING_E, RATING_F, RATING_X, RATING_X)</b>
<b class="nc">&nbsp;                .setStaticTechLevel(SimpleTechLevel.EXPERIMENTAL) //bimodal</b>
&nbsp;    };
&nbsp;    
&nbsp;    @Override
&nbsp;    public TechAdvancement getConstructionTechAdvancement() {
<b class="nc">&nbsp;        return TA_LAM[lamType];</b>
&nbsp;    }
&nbsp;    
&nbsp;    public int height() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_MECH) {</b>
<b class="nc">&nbsp;            return super.height();</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * LAMs can only carry mechanized BA in mech mode
&nbsp;     * 
&nbsp;     * @return
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean canLoad(Entity unit, boolean checkElev) {
<b class="nc">&nbsp;        return (getConversionMode() == CONV_MODE_MECH) &amp;&amp; super.canLoad(unit, checkElev);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Bomb ordnance is treated as inferno ammo for purposes of avoiding
&nbsp;     * explosion due to heat.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit is still loaded with inferno rounds
&nbsp;     *         or bomb ordnance.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasInfernoAmmo() {
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_BOMB_BAY) &amp;&amp; m.getLinked() != null) {</b>
<b class="nc">&nbsp;                Mounted bomb = m.getLinked();</b>
&nbsp;                // We may have to go through a launcher to get to the ordnance
<b class="nc">&nbsp;                if (bomb.getLinked() != null) {</b>
<b class="nc">&nbsp;                    bomb = bomb.getLinked();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bomb.getExplosionDamage() &gt; 0) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return super.hasInfernoAmmo();</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Fighter Mode **/
&nbsp;
&nbsp;    public void setWhoFirst() {
<b class="nc">&nbsp;        whoFirst = Compute.randomInt(500);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getWhoFirst() {
<b class="nc">&nbsp;        return whoFirst;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getMaxBombPoints() {
<b class="nc">&nbsp;        return countWorkingMisc(MiscType.F_BOMB_BAY);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getMaxBombSize() {
<b class="nc">&nbsp;        return Math.max(emptyBaysInLoc(LOC_CT), Math.max(emptyBaysInLoc(LOC_RT), emptyBaysInLoc(LOC_LT)));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int[] getBombChoices() {
<b class="nc">&nbsp;        return bombChoices.clone();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setBombChoices(int[] bc) {
<b class="nc">&nbsp;        if (bc.length == bombChoices.length) {</b>
<b class="nc">&nbsp;            bombChoices = bc;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void clearBombChoices() {
<b class="nc">&nbsp;        Arrays.fill(bombChoices, 0);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Targetable getVTOLBombTarget() {
<b class="nc">&nbsp;        return airmechBombTarget;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setVTOLBombTarget(Targetable t) {
<b class="nc">&nbsp;        airmechBombTarget = t;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isMakingVTOLGroundAttack() {
<b class="nc">&nbsp;        return airmechBombTarget != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCurrentVelocity() {
&nbsp;        // if using advanced movement then I just want to sum up
&nbsp;        // the different vectors
<b class="nc">&nbsp;        if ((game != null) &amp;&amp; game.useVectorMove()) {</b>
<b class="nc">&nbsp;            return getVelocity();</b>
&nbsp;        }
<b class="nc">&nbsp;        return currentVelocity;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setCurrentVelocity(int velocity) {
<b class="nc">&nbsp;        currentVelocity = velocity;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getNextVelocity() {
<b class="nc">&nbsp;        return nextVelocity;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setNextVelocity(int velocity) {
<b class="nc">&nbsp;        nextVelocity = velocity;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCurrentVelocityActual() {
<b class="nc">&nbsp;        return currentVelocity;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isRolled() {
<b class="nc">&nbsp;        return rolled;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isOutControlTotal() {
<b class="nc">&nbsp;        return outControl || shutDown || getCrew().isUnconscious();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isOutControl() {
<b class="nc">&nbsp;        return outControl;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setOutControl(boolean ocontrol) {
<b class="nc">&nbsp;        outControl = ocontrol;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isOutCtrlHeat() {
<b class="nc">&nbsp;        return outCtrlHeat;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setOutCtrlHeat(boolean octrlheat) {
<b class="nc">&nbsp;        outCtrlHeat = octrlheat;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isRandomMove() {
<b class="nc">&nbsp;        return randomMove;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setRandomMove(boolean randmove) {
<b class="nc">&nbsp;        randomMove = randmove;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setRolled(boolean roll) {
<b class="nc">&nbsp;        rolled = roll;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean didAccLast() {
<b class="nc">&nbsp;        return accLast;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setAccLast(boolean b) {
<b class="nc">&nbsp;        accLast = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setSI(int si) {
<b class="nc">&nbsp;        setInternal(si, LOC_CT);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getSI() {
<b class="nc">&nbsp;        return getInternal(LOC_CT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int get0SI() {
<b class="nc">&nbsp;        return getOInternal(LOC_CT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasLifeSupport() {
<b class="nc">&nbsp;        return getGoodCriticals(CriticalSlot.TYPE_SYSTEM, SYSTEM_LIFE_SUPPORT, LOC_HEAD) &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine modifier for landing.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getNoseArmor() {
<b class="nc">&nbsp;        return getArmor(LOC_CT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns exposure or breached flag for location
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getLocationStatus(int loc) {
<b class="nc">&nbsp;        switch (loc) {</b>
&nbsp;        case LOC_CAPITAL_NOSE:
<b class="nc">&nbsp;            return Math.max(super.getLocationStatus(LOC_HEAD), super.getLocationStatus(LOC_CT));</b>
&nbsp;        case LOC_CAPITAL_AFT:
<b class="nc">&nbsp;            return Math.max(super.getLocationStatus(LOC_RLEG), super.getLocationStatus(LOC_LLEG));</b>
&nbsp;        case LOC_CAPITAL_WINGS:
<b class="nc">&nbsp;            return Math.max(Math.max(super.getLocationStatus(LOC_RT), super.getLocationStatus(LOC_RARM)),</b>
<b class="nc">&nbsp;                    Math.max(super.getLocationStatus(LOC_LT), super.getLocationStatus(LOC_LARM)));</b>
&nbsp;        default:
<b class="nc">&nbsp;            return super.getLocationStatus(loc);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getAvionicsHits() {
<b class="nc">&nbsp;        int hits = 0;</b>
<b class="nc">&nbsp;        for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;            hits += getBadCriticals(CriticalSlot.TYPE_SYSTEM, LAM_AVIONICS, loc);</b>
&nbsp;        }
<b class="nc">&nbsp;        return hits;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getSensorHits() {
<b class="nc">&nbsp;        return getBadCriticals(CriticalSlot.TYPE_SYSTEM, SYSTEM_SENSORS, LOC_HEAD);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getFCSHits() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getLeftThrustHits() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getRightThrustHits() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setGearHit(boolean hit) {
<b class="nc">&nbsp;        if (hit) {</b>
<b class="nc">&nbsp;            List&lt;CriticalSlot&gt; gearSlots = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; crits[loc].length; i++) {</b>
<b class="nc">&nbsp;                    final CriticalSlot slot = crits[loc][i];</b>
<b class="nc">&nbsp;                    if (slot != null &amp;&amp; slot.getType() == CriticalSlot.TYPE_SYSTEM</b>
<b class="nc">&nbsp;                            &amp;&amp; slot.getIndex() == LAM_LANDING_GEAR &amp;&amp; !slot.isDestroyed()) {</b>
<b class="nc">&nbsp;                        gearSlots.add(slot);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (gearSlots.size() &gt; 0) {</b>
<b class="nc">&nbsp;                int index = Compute.randomInt(gearSlots.size());</b>
<b class="nc">&nbsp;                gearSlots.get(index).setDestroyed(true);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Modifier to landing or vertical takeoff roll for landing gear damage.
&nbsp;     *
&nbsp;     * @param vTakeoff
&nbsp;     *            true if this is for a vertical takeoff, false if for a landing
&nbsp;     * @return the control roll modifier
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getLandingGearMod(boolean vTakeoff) {
<b class="nc">&nbsp;        int hits = 0;</b>
<b class="nc">&nbsp;        for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;            hits += getBadCriticals(CriticalSlot.TYPE_SYSTEM, LAM_LANDING_GEAR, loc);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (vTakeoff) {</b>
<b class="nc">&nbsp;            return hits &gt; 0 ? 1 : 0;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return hits &gt; 3 ? 5 : hits;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    //Landing mods for partial repairs
&nbsp;    public int getLandingGearPartialRepairs() {
<b class="nc">&nbsp;    	if (getPartialRepairs().booleanOption(&quot;aero_gear_crit&quot;)) {</b>
<b class="nc">&nbsp;        return 2;</b>
<b class="nc">&nbsp;    	} else if (getPartialRepairs().booleanOption(&quot;aero_gear_replace&quot;)) {</b>
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    	} else {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    	}
&nbsp;    }
&nbsp;    
&nbsp;    //Avionics mods for partial repairs
&nbsp;    public int getAvionicsMisreplaced() {
<b class="nc">&nbsp;    	if (getPartialRepairs().booleanOption(&quot;aero_avionics_replace&quot;)) {</b>
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    	} else {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    	}
&nbsp;    }
&nbsp;    
&nbsp;    public int getAvionicsMisrepaired() {
<b class="nc">&nbsp;    	if (getPartialRepairs().booleanOption(&quot;aero_avionics_crit&quot;)) {</b>
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    	} else {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    	}
&nbsp;    }    
&nbsp;
&nbsp;    /**
&nbsp;     * In fighter mode the weapon arcs need to be translated to Aero arcs.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getWeaponArc(int wn) {
<b class="nc">&nbsp;        if (getConversionMode() != CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return super.getWeaponArc(wn);</b>
&nbsp;        }
<b class="nc">&nbsp;        final Mounted mounted = getEquipment(wn);</b>
<b class="nc">&nbsp;        if (mounted.getType().hasFlag(WeaponType.F_SPACE_BOMB) || mounted.getType().hasFlag(WeaponType.F_DIVE_BOMB)</b>
<b class="nc">&nbsp;                || mounted.getType().hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;            return Compute.ARC_360;</b>
&nbsp;        }
&nbsp;        // We use Aero locations for weapon groups for fighter squadron
&nbsp;        // compatibility
<b class="nc">&nbsp;        if (mounted.isWeaponGroup()) {</b>
<b class="nc">&nbsp;            return (mounted.getLocation() == Aero.LOC_AFT) ? Compute.ARC_AFT : Compute.ARC_NOSE;</b>
&nbsp;        }
<b class="nc">&nbsp;        int arc = Compute.ARC_NOSE;</b>
<b class="nc">&nbsp;        switch (mounted.getLocation()) {</b>
&nbsp;        case LOC_HEAD:
<b class="nc">&nbsp;            arc = Compute.ARC_NOSE;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case LOC_CT:
<b class="nc">&nbsp;            if (mounted.isRearMounted()) {</b>
<b class="nc">&nbsp;                arc = Compute.ARC_AFT;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                arc = Compute.ARC_NOSE;</b>
&nbsp;            }
<b class="nc">&nbsp;            break;</b>
&nbsp;        case LOC_RT:
<b class="nc">&nbsp;            if (mounted.isRearMounted()) {</b>
<b class="nc">&nbsp;                arc = Compute.ARC_RWINGA;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                arc = Compute.ARC_RWING;</b>
&nbsp;            }
<b class="nc">&nbsp;            break;</b>
&nbsp;        case LOC_LT:
<b class="nc">&nbsp;            if (mounted.isRearMounted()) {</b>
<b class="nc">&nbsp;                arc = Compute.ARC_LWINGA;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                arc = Compute.ARC_LWING;</b>
&nbsp;            }
<b class="nc">&nbsp;            break;</b>
&nbsp;        case LOC_RARM:
<b class="nc">&nbsp;            arc = Compute.ARC_RWING;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case LOC_LARM:
<b class="nc">&nbsp;            arc = Compute.ARC_LWING;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case LOC_RLEG:
&nbsp;        case LOC_LLEG:
<b class="nc">&nbsp;            arc = Compute.ARC_AFT;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        default:
<b class="nc">&nbsp;            arc = Compute.ARC_360;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return rollArcs(arc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hit location table for fighter mode
&nbsp;     */
&nbsp;    @Override
&nbsp;    public HitData rollHitLocation(int table, int side) {
<b class="nc">&nbsp;        if (getConversionMode() != CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return super.rollHitLocation(table, side);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int roll = Compute.d6(2);</b>
&nbsp;
&nbsp;        // first check for above/below
<b class="nc">&nbsp;        if ((table == ToHitData.HIT_ABOVE) || (table == ToHitData.HIT_BELOW)) {</b>
&nbsp;
&nbsp;            // have to decide which arm/leg
<b class="nc">&nbsp;            int armloc = LOC_RARM;</b>
<b class="nc">&nbsp;            int legloc = LOC_RLEG;</b>
<b class="nc">&nbsp;            int wingroll = Compute.d6(1);</b>
<b class="nc">&nbsp;            if (wingroll &gt; 3) {</b>
<b class="nc">&nbsp;                armloc = LOC_LARM;</b>
<b class="nc">&nbsp;                legloc = LOC_LLEG;</b>
&nbsp;            }
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;            case 2:
&nbsp;            case 6:
<b class="nc">&nbsp;                return new HitData(LOC_RT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 3:
&nbsp;            case 4:
&nbsp;            case 10:
&nbsp;            case 11:
<b class="nc">&nbsp;                return new HitData(armloc, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 5:
&nbsp;            case 9:
<b class="nc">&nbsp;                return new HitData(legloc, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 7:
<b class="nc">&nbsp;                return new HitData(LOC_CT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 8:
&nbsp;            case 12:
<b class="nc">&nbsp;                return new HitData(LOC_LT, false, HitData.EFFECT_NONE);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (side == ToHitData.SIDE_FRONT) {</b>
&nbsp;            // normal front hits
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;            case 2:
&nbsp;            case 12:
<b class="nc">&nbsp;                return new HitData(LOC_CT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 3:
&nbsp;            case 6:
<b class="nc">&nbsp;                return new HitData(LOC_RT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 4:
&nbsp;            case 5:
<b class="nc">&nbsp;                return new HitData(LOC_RARM, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 7:
<b class="nc">&nbsp;                return new HitData(LOC_CT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 8:
&nbsp;            case 11:
<b class="nc">&nbsp;                return new HitData(LOC_LT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 9:
&nbsp;            case 10:
<b class="nc">&nbsp;                return new HitData(LOC_LARM, false, HitData.EFFECT_NONE);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (side == ToHitData.SIDE_LEFT) {</b>
&nbsp;            // normal left-side hits
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                return new HitData(LOC_HEAD, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 3:
&nbsp;            case 7:
&nbsp;            case 11:
<b class="nc">&nbsp;                return new HitData(LOC_LARM, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 4:
&nbsp;            case 5:
<b class="nc">&nbsp;                return new HitData(LOC_CT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 6:
&nbsp;            case 8:
<b class="nc">&nbsp;                return new HitData(LOC_LT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 9:
&nbsp;            case 10:
&nbsp;            case 12:
<b class="nc">&nbsp;                return new HitData(LOC_LLEG, false, HitData.EFFECT_NONE);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (side == ToHitData.SIDE_RIGHT) {</b>
&nbsp;            // normal right-side hits
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                return new HitData(LOC_HEAD, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 3:
&nbsp;            case 7:
&nbsp;            case 11:
<b class="nc">&nbsp;                return new HitData(LOC_RARM, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 4:
&nbsp;            case 5:
<b class="nc">&nbsp;                return new HitData(LOC_CT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 6:
&nbsp;            case 8:
<b class="nc">&nbsp;                return new HitData(LOC_RT, false, HitData.EFFECT_NONE);</b>
&nbsp;            case 9:
&nbsp;            case 10:
&nbsp;            case 12:
<b class="nc">&nbsp;                return new HitData(LOC_RLEG, false, HitData.EFFECT_NONE);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (side == ToHitData.SIDE_REAR) {</b>
&nbsp;            // rear torso locations are only hit on a roll of 5-6 on d6
<b class="nc">&nbsp;            boolean rear = Compute.d6() &gt; 4;</b>
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;            case 2:
&nbsp;            case 12:
<b class="nc">&nbsp;                return new HitData(LOC_CT, rear, HitData.EFFECT_NONE);</b>
&nbsp;            case 3:
&nbsp;            case 4:
<b class="nc">&nbsp;                return new HitData(LOC_RT, rear, HitData.EFFECT_NONE);</b>
&nbsp;            case 5:
<b class="nc">&nbsp;                return new HitData(LOC_RARM, rear, HitData.EFFECT_NONE);</b>
&nbsp;            case 6:
<b class="nc">&nbsp;                return new HitData(LOC_RLEG, rear, HitData.EFFECT_NONE);</b>
&nbsp;            case 7:
<b class="nc">&nbsp;                if (Compute.d6() &gt; 3) {</b>
<b class="nc">&nbsp;                    return new HitData(LOC_LLEG, rear, HitData.EFFECT_NONE);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new HitData(LOC_RLEG, rear, HitData.EFFECT_NONE);</b>
&nbsp;                }
&nbsp;            case 8:
<b class="nc">&nbsp;                return new HitData(LOC_LLEG, rear, HitData.EFFECT_NONE);</b>
&nbsp;            case 9:
<b class="nc">&nbsp;                return new HitData(LOC_LARM, rear, HitData.EFFECT_NONE);</b>
&nbsp;            case 10:
&nbsp;            case 11:
<b class="nc">&nbsp;                return new HitData(LOC_LT, rear, HitData.EFFECT_NONE);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new HitData(LOC_CT, false, HitData.EFFECT_NONE);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getFuel() {
<b class="nc">&nbsp;        if ((getPartialRepairs().booleanOption(&quot;aero_asf_fueltank_crit&quot;))</b>
<b class="nc">&nbsp;        	|| (getPartialRepairs().booleanOption(&quot;aero_fueltank_crit&quot;))) {</b>
<b class="nc">&nbsp;        	return (int) (fuel * 0.9);</b>
&nbsp;        } else {
<b class="nc">&nbsp;        return fuel;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public int getCurrentFuel() {
<b class="nc">&nbsp;        if ((getPartialRepairs().booleanOption(&quot;aero_asf_fueltank_crit&quot;))</b>
<b class="nc">&nbsp;            	|| (getPartialRepairs().booleanOption(&quot;aero_fueltank_crit&quot;))) {</b>
<b class="nc">&nbsp;            	return (int) (currentfuel * 0.9);</b>
&nbsp;        } else {
<b class="nc">&nbsp;        return currentfuel;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the number of fuel points.
&nbsp;     * 
&nbsp;     * @param gas
&nbsp;     *            Number of fuel points.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setFuel(int gas) {
<b class="nc">&nbsp;        fuel = gas;</b>
<b class="nc">&nbsp;        currentfuel = gas;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public void setCurrentFuel(int gas) {
<b class="nc">&nbsp;    	currentfuel = gas;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public double getFuelPointsPerTon() {
<b class="nc">&nbsp;        return 80;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set number of fuel points based on fuel tonnage.
&nbsp;     *
&nbsp;     * @param fuelTons
&nbsp;     *            The number of tons of fuel
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setFuelTonnage(double fuelTons) {
<b class="nc">&nbsp;        double pointsPerTon = getFuelPointsPerTon();</b>
<b class="nc">&nbsp;        fuel = (int) Math.ceil(pointsPerTon * fuelTons);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the fuel for this Aero in terms of tonnage.
&nbsp;     *
&nbsp;     * @return The number of tons of fuel on this Aero.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double getFuelTonnage() {
<b class="nc">&nbsp;        return fuel / getFuelPointsPerTon();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exceeding damage threshold does not result in critical, but requires
&nbsp;     * control roll.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getThresh(int loc) {
<b class="nc">&nbsp;        return getInternal(loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean wasCritThresh() {
<b class="nc">&nbsp;        return critThresh;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setCritThresh(boolean b) {
<b class="nc">&nbsp;        critThresh = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isSpheroid() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getStraightMoves() {
<b class="nc">&nbsp;        return straightMoves;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setStraightMoves(int i) {
<b class="nc">&nbsp;        straightMoves = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getAltLoss() {
<b class="nc">&nbsp;        return altLoss;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setAltLoss(int i) {
<b class="nc">&nbsp;        altLoss = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetAltLoss() {
<b class="nc">&nbsp;        altLoss = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getAltLossThisRound() {
<b class="nc">&nbsp;        return altLossThisRound;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setAltLossThisRound(int i) {
<b class="nc">&nbsp;        altLossThisRound = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetAltLossThisRound() {
<b class="nc">&nbsp;        altLossThisRound = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isVSTOL() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isSTOL() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getElevation() {
<b class="nc">&nbsp;        if ((game != null) &amp;&amp; game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        // Altitude is not the same as elevation. If an aero is at 0 altitude,
&nbsp;        // then it is
&nbsp;        // grounded and uses elevation normally. Otherwise, just set elevation
&nbsp;        // to a very
&nbsp;        // large number so that a flying aero won&#39;t interact with the ground
&nbsp;        // maps in any way
<b class="nc">&nbsp;        if (isAirborne()) {</b>
<b class="nc">&nbsp;            return 999;</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.getElevation();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getFuelUsed(int thrust) {
<b class="nc">&nbsp;        int overThrust = Math.max(thrust - getWalkMP(), 0);</b>
<b class="nc">&nbsp;        int safeThrust = thrust - overThrust;</b>
<b class="nc">&nbsp;        int used = safeThrust + (2 * overThrust);</b>
<b class="nc">&nbsp;        return used;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean didFailManeuver() {
<b class="nc">&nbsp;        return failedManeuver;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setFailedManeuver(boolean b) {
<b class="nc">&nbsp;        failedManeuver = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setAccDecNow(boolean b) {
<b class="nc">&nbsp;        accDecNow = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean didAccDecNow() {
<b class="nc">&nbsp;        return accDecNow;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCapArmor() {
<b class="nc">&nbsp;        return capitalArmor;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setCapArmor(int i) {
<b class="nc">&nbsp;        capitalArmor = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCap0Armor() {
<b class="nc">&nbsp;        return capitalArmor_orig;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getFatalThresh() {
<b class="nc">&nbsp;        return fatalThresh;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void autoSetCapArmor() {
<b class="nc">&nbsp;        double divisor = 10.0;</b>
<b class="nc">&nbsp;        if ((null != game) &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            divisor = 1.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        capitalArmor_orig = (int) Math.round(getTotalOArmor() / divisor);</b>
<b class="nc">&nbsp;        capitalArmor = (int) Math.round(getTotalArmor() / divisor);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void autoSetFatalThresh() {
<b class="nc">&nbsp;        int baseThresh = 2;</b>
<b class="nc">&nbsp;        if ((null != game) &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            baseThresh = 20;</b>
&nbsp;        }
<b class="nc">&nbsp;        fatalThresh = Math.max(baseThresh, (int) Math.ceil(capitalArmor / 4.0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCurrentDamage() {
<b class="nc">&nbsp;        return currentDamage;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setCurrentDamage(int i) {
<b class="nc">&nbsp;        currentDamage = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Map&lt;String, Integer&gt; getWeaponGroups() {
<b class="nc">&nbsp;        return weaponGroups;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Provide weapon groups for capital fighters. For capital fighter purposes
&nbsp;     * we use Aero locations.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Map&lt;String, Integer&gt; groupWeaponsByLocation() {
<b class="nc">&nbsp;        Map&lt;String, Integer&gt; groups = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Mounted mounted : getTotalWeaponList()) {</b>
<b class="nc">&nbsp;            int loc = LOC_CAPITAL_WINGS;</b>
<b class="nc">&nbsp;            if ((loc == Mech.LOC_CT) || (loc == Mech.LOC_HEAD)) {</b>
<b class="nc">&nbsp;                loc = LOC_CAPITAL_NOSE;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (mounted.isRearMounted() || (loc == Mech.LOC_LLEG) || (loc == Mech.LOC_RLEG)) {</b>
<b class="nc">&nbsp;                loc = LOC_CAPITAL_AFT;</b>
&nbsp;            }
<b class="nc">&nbsp;            String key = mounted.getType().getInternalName() + &quot;:&quot; + loc;</b>
<b class="nc">&nbsp;            if (null == groups.get(key)) {</b>
<b class="nc">&nbsp;                groups.put(key, mounted.getNWeapons());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                groups.put(key, groups.get(key) + mounted.getNWeapons());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return groups;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Damage a fighter that was part of a squadron when splitting it. Per
&nbsp;    // StratOps pg. 32 &amp; 34
&nbsp;    @Override
&nbsp;    public void doDisbandDamage() {
&nbsp;
<b class="nc">&nbsp;        int dealt = 0;</b>
&nbsp;        // Check for critical threshold and if so damage one facing of the
&nbsp;        // fighter completely.
<b class="nc">&nbsp;        if (isDestroyed() || isDoomed()) {</b>
&nbsp;            // Note starting armor + internal so we can compute how many damage
&nbsp;            // points were allocated
&nbsp;            // in this step.
<b class="nc">&nbsp;            int start = getTotalArmor() + getTotalInternal();</b>
<b class="nc">&nbsp;            int side = Compute.randomInt(4);</b>
<b class="nc">&nbsp;            switch (side) {</b>
&nbsp;            case 0: // Nose
<b class="nc">&nbsp;                destroyLocation(LOC_HEAD);</b>
<b class="nc">&nbsp;                destroyLocation(LOC_CT);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 1: // Left wing
<b class="nc">&nbsp;                destroyLocation(LOC_LT);</b>
<b class="nc">&nbsp;                destroyLocation(LOC_LARM);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 2: // Right wing
<b class="nc">&nbsp;                destroyLocation(LOC_RT);</b>
<b class="nc">&nbsp;                destroyLocation(LOC_RARM);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 3: // Aft
<b class="nc">&nbsp;                destroyLocation(LOC_LLEG);</b>
<b class="nc">&nbsp;                destroyLocation(LOC_RLEG);</b>
&nbsp;                break;
&nbsp;            }
&nbsp;            // Also apply three engine hits
<b class="nc">&nbsp;            int i = 0;</b>
<b class="nc">&nbsp;            int engineHits = getEngineHits();</b>
<b class="nc">&nbsp;            while (engineHits &lt; 3 &amp;&amp; i &lt; getNumberOfCriticals(LOC_CT)) {</b>
<b class="nc">&nbsp;                final CriticalSlot slot = getCritical(LOC_CT, i);</b>
<b class="nc">&nbsp;                if (slot != null &amp;&amp; slot.getType() == CriticalSlot.TYPE_SYSTEM &amp;&amp; slot.getIndex() == SYSTEM_ENGINE</b>
<b class="nc">&nbsp;                        &amp;&amp; !slot.isDamaged()) {</b>
<b class="nc">&nbsp;                    slot.setHit(true);</b>
<b class="nc">&nbsp;                    engineHits++;</b>
&nbsp;                }
<b class="nc">&nbsp;                i++;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            dealt = start - getTotalArmor() - getTotalInternal();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Move on to actual damage...
<b class="nc">&nbsp;        int damage = getCap0Armor() - getCapArmor();</b>
<b class="nc">&nbsp;        if ((null != game) || !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
<b class="nc">&nbsp;            damage *= 10;</b>
&nbsp;        }
<b class="nc">&nbsp;        damage -= dealt;</b>
&nbsp;
<b class="nc">&nbsp;        if (damage &gt;= 0) {</b>
<b class="nc">&nbsp;            int hits = (int) Math.ceil(damage / 5.0);</b>
<b class="nc">&nbsp;            int damPerHit = 5;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; hits; i++) {</b>
<b class="nc">&nbsp;                int loc = rollHitLocation(ToHitData.HIT_ABOVE, ToHitData.SIDE_RANDOM).getLocation();</b>
<b class="nc">&nbsp;                setArmor(getArmor(loc) - Math.max(damPerHit, damage), loc);</b>
&nbsp;                // We did too much damage, so we need to damage the internal
&nbsp;                // structure
<b class="nc">&nbsp;                if (getArmor(loc) &lt; 0) {</b>
<b class="nc">&nbsp;                    if (getInternal(loc) &gt; 1) {</b>
<b class="nc">&nbsp;                        int internal = getInternal(loc) + getArmor(loc);</b>
<b class="nc">&nbsp;                        if (internal &lt;= 0) {</b>
<b class="nc">&nbsp;                            if ((loc == LOC_CT || loc == LOC_HEAD) &amp;&amp; !isDestroyed() &amp;&amp; !isDoomed()) {</b>
<b class="nc">&nbsp;                                setInternal(1, loc);// We don&#39;t want to destroy</b>
&nbsp;                                                    // the fighter if it didn&#39;t
&nbsp;                                                    // pass the fatal threshold
&nbsp;                            } else {
<b class="nc">&nbsp;                                destroyLocation(loc);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    setArmor(0, loc);</b>
&nbsp;                }
<b class="nc">&nbsp;                damage -= damPerHit;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        applyDamage();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setBattleForceMovement(Map&lt;String, Integer&gt; movement) {
<b class="nc">&nbsp;        super.setBattleForceMovement(movement);</b>
<b class="nc">&nbsp;        movement.put(&quot;g&quot;, getAirMechCruiseMP(true, false));</b>
<b class="nc">&nbsp;        movement.put(&quot;a&quot;, getFighterModeWalkMP(true, false));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void setAlphaStrikeMovement(Map&lt;String, Integer&gt; movement) {
<b class="nc">&nbsp;        super.setBattleForceMovement(movement);</b>
<b class="nc">&nbsp;        movement.put(&quot;g&quot;, getAirMechCruiseMP(true, false) * 2);</b>
<b class="nc">&nbsp;        movement.put(&quot;a&quot;, getFighterModeWalkMP(true, false));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void addBattleForceSpecialAbilities(Map&lt;BattleForceSPA, Integer&gt; specialAbilities) {
<b class="nc">&nbsp;        super.addBattleForceSpecialAbilities(specialAbilities);</b>
<b class="nc">&nbsp;        int bombs = (int) getEquipment().stream().filter(m -&gt; m.getType().hasFlag(MiscType.F_BOMB_BAY)).count();</b>
<b class="nc">&nbsp;        if (bombs &gt; 0) {</b>
<b class="nc">&nbsp;            specialAbilities.put(BattleForceSPA.BOMB, bombs / 5);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (lamType == LAM_BIMODAL) {</b>
<b class="nc">&nbsp;            specialAbilities.put(BattleForceSPA.BIM, null);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            specialAbilities.put(BattleForceSPA.LAM, null);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public String getTilesetModeString() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return &quot;_FIGHTER&quot;;</b>
<b class="nc">&nbsp;        } else if (getConversionMode() == CONV_MODE_AIRMECH) {</b>
<b class="nc">&nbsp;            return &quot;_AIRMECH&quot;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isAero() {
<b class="nc">&nbsp;        return getConversionMode() == CONV_MODE_FIGHTER;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isBomber() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Try to find a location that has enough empty bomb bays to accommodate the
&nbsp;     * bomb size
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int availableBombLocation(int cost) {
<b class="nc">&nbsp;        if (emptyBaysInLoc(LOC_RT) &gt;= cost) {</b>
<b class="nc">&nbsp;            return LOC_RT;</b>
<b class="nc">&nbsp;        } else if (emptyBaysInLoc(LOC_LT) &gt;= cost) {</b>
<b class="nc">&nbsp;            return LOC_LT;</b>
<b class="nc">&nbsp;        } else if (emptyBaysInLoc(LOC_CT) &gt;= cost) {</b>
<b class="nc">&nbsp;            return LOC_CT;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return LOC_NONE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private int emptyBaysInLoc(int loc) {
<b class="nc">&nbsp;        int bays = 0;</b>
<b class="nc">&nbsp;        for (CriticalSlot slot : crits[loc]) {</b>
<b class="nc">&nbsp;            if ((slot != null) &amp;&amp; (slot.getType() == CriticalSlot.TYPE_EQUIPMENT) &amp;&amp; slot.getMount2() == null</b>
<b class="nc">&nbsp;                    &amp;&amp; slot.getMount().getType() instanceof MiscType</b>
<b class="nc">&nbsp;                    &amp;&amp; slot.getMount().getType().hasFlag(MiscType.F_BOMB_BAY)) {</b>
<b class="nc">&nbsp;                bays++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return bays;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void addBomb(Mounted mounted, int loc) throws LocationFullException {
<b class="nc">&nbsp;        mounted.setLocation(loc, false);</b>
<b class="nc">&nbsp;        int slots = 1;</b>
<b class="nc">&nbsp;        if (mounted.getType() instanceof BombType) {</b>
<b class="nc">&nbsp;            slots = BombType.getBombCost(((BombType) mounted.getType()).getBombType());</b>
<b class="nc">&nbsp;        } else if (mounted.getType() instanceof WeaponType) {</b>
<b class="nc">&nbsp;            int type = BombType.getBombTypeForWeapon(mounted.getType());</b>
<b class="nc">&nbsp;            if (type &gt;= 0) {</b>
<b class="nc">&nbsp;                slots = BombType.getBombCost(type);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                slots = mounted.getCriticals();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; crits[loc].length; i++) {</b>
<b class="nc">&nbsp;            final CriticalSlot slot = crits[loc][i];</b>
<b class="nc">&nbsp;            if (slot != null &amp;&amp; slot.getType() == CriticalSlot.TYPE_EQUIPMENT</b>
<b class="nc">&nbsp;                    &amp;&amp; (slot.getMount().getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                    &amp;&amp; slot.getMount().getType().hasFlag(MiscType.F_BOMB_BAY) &amp;&amp; (slot.getMount2() == null)) {</b>
<b class="nc">&nbsp;                slot.setMount2(mounted);</b>
<b class="nc">&nbsp;                slots--;</b>
&nbsp;                // Link the bay to the slot so we can find the bomb to explode
&nbsp;                // when the slot is hit.
<b class="nc">&nbsp;                slot.getMount().setLinked(mounted);</b>
<b class="nc">&nbsp;                if (slots == 0) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (slots &gt; 0) {</b>
<b class="nc">&nbsp;            throw new LocationFullException();</b>
&nbsp;        }
<b class="nc">&nbsp;        mounted.setBombMounted(true);</b>
<b class="nc">&nbsp;        if (mounted.getType() instanceof BombType) {</b>
<b class="nc">&nbsp;            bombList.add(mounted);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mounted.getType() instanceof WeaponType) {</b>
<b class="nc">&nbsp;            totalWeaponList.add(mounted);</b>
<b class="nc">&nbsp;            weaponList.add(mounted);</b>
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(WeaponType.F_ARTILLERY)) {</b>
<b class="nc">&nbsp;                aTracker.addWeapon(mounted);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(WeaponType.F_ONESHOT) &amp;&amp; (AmmoType.getOneshotAmmo(mounted) != null)) {</b>
<b class="nc">&nbsp;                Mounted m = new Mounted(this, AmmoType.getOneshotAmmo(mounted));</b>
<b class="nc">&nbsp;                m.setShotsLeft(1);</b>
<b class="nc">&nbsp;                mounted.setLinked(m);</b>
&nbsp;                // Oneshot ammo will be identified by having a location
&nbsp;                // of null. Other areas in the code will rely on this.
<b class="nc">&nbsp;                addEquipment(m, Entity.LOC_NONE, false);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (mounted.getType() instanceof AmmoType) {</b>
<b class="nc">&nbsp;            ammoList.add(mounted);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mounted.getType() instanceof MiscType) {</b>
<b class="nc">&nbsp;            miscList.add(mounted);</b>
&nbsp;        }
<b class="nc">&nbsp;        equipmentList.add(mounted);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc, boolean rearMounted) throws LocationFullException {
<b class="nc">&nbsp;        if (etype instanceof BombType) {</b>
<b class="nc">&nbsp;            Mounted mounted = new Mounted(this, etype);</b>
<b class="nc">&nbsp;            addBomb(mounted, loc);</b>
<b class="nc">&nbsp;            return mounted;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return super.addEquipment(etype, loc, rearMounted);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canSpot() {
<b class="nc">&nbsp;        if (getConversionMode() == CONV_MODE_FIGHTER) {</b>
<b class="nc">&nbsp;            return !isAirborne() || hasWorkingMisc(MiscType.F_RECON_CAMERA)</b>
<b class="nc">&nbsp;                    || hasWorkingMisc(MiscType.F_INFRARED_IMAGER) || hasWorkingMisc(MiscType.F_HYPERSPECTRAL_IMAGER)</b>
<b class="nc">&nbsp;                    || (hasWorkingMisc(MiscType.F_HIRES_IMAGER)</b>
<b class="nc">&nbsp;                            &amp;&amp; ((game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DAY)</b>
<b class="nc">&nbsp;                                    || (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DUSK)));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return super.canSpot();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getEntityType() {
<b class="nc">&nbsp;        return Entity.ETYPE_MECH | Entity.ETYPE_BIPED_MECH | Entity.ETYPE_LAND_AIR_MECH;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * A method to add/remove sensors that only work in space as we transition in and out of an atmosphere
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void updateSensorOptions() {
&nbsp;        //Remove everything but Radar if we&#39;re not in space
<b class="nc">&nbsp;        if (!isSpaceborne()) {</b>
<b class="nc">&nbsp;            Vector&lt;Sensor&gt; sensorsToRemove = new Vector&lt;Sensor&gt;();</b>
<b class="nc">&nbsp;            if (isAero()) {</b>
<b class="nc">&nbsp;                for (Sensor sensor : getSensors()) {</b>
<b class="nc">&nbsp;                    if (sensor.getType() == Sensor.TYPE_AERO_THERMAL) {</b>
<b class="nc">&nbsp;                        sensorsToRemove.add(sensor);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            getSensors().removeAll(sensorsToRemove);</b>
<b class="nc">&nbsp;            if (sensorsToRemove.size() &gt;= 1) {</b>
<b class="nc">&nbsp;            setNextSensor(getSensors().firstElement());</b>
&nbsp;            }
&nbsp;        }
&nbsp;        //If we are in space, add them back...
<b class="nc">&nbsp;        if (isSpaceborne()) {</b>
<b class="nc">&nbsp;            if (isAero()) {</b>
&nbsp;                //ASFs and small craft get thermal/optical sensors
<b class="nc">&nbsp;                getSensors().add(new Sensor(Sensor.TYPE_AERO_THERMAL));</b>
<b class="nc">&nbsp;                setNextSensor(getSensors().firstElement());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
