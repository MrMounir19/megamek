


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > IAero</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: IAero (megamek.common)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IAero</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/312)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2017 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;
&nbsp;/**
&nbsp; * Methods shared by Aero and LandAirMech
&nbsp; *
&nbsp; * @author Neoancient
&nbsp; *
&nbsp; */
&nbsp;public interface IAero {
&nbsp;
&nbsp;    int getCurrentThrust();
&nbsp;
&nbsp;    int getCurrentVelocity();
&nbsp;
&nbsp;    void setCurrentVelocity(int velocity);
&nbsp;
&nbsp;    int getNextVelocity();
&nbsp;
&nbsp;    void setNextVelocity(int velocity);
&nbsp;
&nbsp;    int getCurrentVelocityActual();
&nbsp;
&nbsp;    boolean isVSTOL();
&nbsp;
&nbsp;    boolean isSTOL();
&nbsp;
&nbsp;    boolean isSpheroid();
&nbsp;
&nbsp;    boolean isAirborne();
&nbsp;
&nbsp;    boolean isSpaceborne();
&nbsp;
&nbsp;    boolean isRolled();
&nbsp;
&nbsp;    void setRolled(boolean roll);
&nbsp;
&nbsp;    boolean isOutControlTotal();
&nbsp;
&nbsp;    boolean isOutControl();
&nbsp;
&nbsp;    void setOutControl(boolean ocontrol);
&nbsp;
&nbsp;    boolean isOutCtrlHeat();
&nbsp;
&nbsp;    void setOutCtrlHeat(boolean octrlheat);
&nbsp;
&nbsp;    boolean isRandomMove();
&nbsp;
&nbsp;    void setRandomMove(boolean randmove);
&nbsp;
&nbsp;    boolean didAccLast();
&nbsp;
&nbsp;    void setAccLast(boolean b);
&nbsp;
&nbsp;    boolean didFailManeuver();
&nbsp;
&nbsp;    void setFailedManeuver(boolean b);
&nbsp;
&nbsp;    void setAccDecNow(boolean b);
&nbsp;
&nbsp;    boolean didAccDecNow();
&nbsp;
&nbsp;    int getStraightMoves();
&nbsp;
&nbsp;    void setStraightMoves(int straightMoves);
&nbsp;
&nbsp;    int getAltLoss();
&nbsp;
&nbsp;    void setAltLoss(int i);
&nbsp;
&nbsp;    void resetAltLoss();
&nbsp;
&nbsp;    int getAltLossThisRound();
&nbsp;
&nbsp;    void setAltLossThisRound(int i);
&nbsp;
&nbsp;    public void resetAltLossThisRound();
&nbsp;
&nbsp;    int getNoseArmor();
&nbsp;
&nbsp;    void setSI(int si);
&nbsp;
&nbsp;    int getSI();
&nbsp;
&nbsp;    int get0SI();
&nbsp;
&nbsp;    int getAvionicsHits();
&nbsp;
&nbsp;    int getSensorHits();
&nbsp;
&nbsp;    int getFCSHits();
&nbsp;
&nbsp;    int getLandingGearPartialRepairs();
&nbsp;
&nbsp;    int getAvionicsMisreplaced();
&nbsp;
&nbsp;    int getAvionicsMisrepaired();
&nbsp;
&nbsp;    default int getClusterMods() {
<b class="nc">&nbsp;        return -1 * (getFCSHits() + getSensorHits());</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean hasLifeSupport();
&nbsp;
&nbsp;    void setGearHit(boolean hit);
&nbsp;
&nbsp;    int getLandingGearMod(boolean vTakeoff);
&nbsp;
&nbsp;    int getLeftThrustHits();
&nbsp;
&nbsp;    int getRightThrustHits();
&nbsp;
&nbsp;    int getThresh(int loc);
&nbsp;
&nbsp;    boolean wasCritThresh();
&nbsp;
&nbsp;    void setCritThresh(boolean b);
&nbsp;
&nbsp;    int getFuel();
&nbsp;
&nbsp;    void setFuel(int gas);
&nbsp;
&nbsp;    int getCurrentFuel();
&nbsp;
&nbsp;    void setCurrentFuel(int gas);
&nbsp;
&nbsp;    double getFuelPointsPerTon();
&nbsp;
&nbsp;    // Capital fighters
&nbsp;    int getCapArmor();
&nbsp;
&nbsp;    void setCapArmor(int i);
&nbsp;
&nbsp;    int getCap0Armor();
&nbsp;
&nbsp;    int getFatalThresh();
&nbsp;
&nbsp;    int getCurrentDamage();
&nbsp;
&nbsp;    void setCurrentDamage(int i);
&nbsp;
&nbsp;    int getHeatSinks();
&nbsp;
&nbsp;    void doDisbandDamage();
&nbsp;
&nbsp;    void autoSetCapArmor();
&nbsp;
&nbsp;    void autoSetFatalThresh();
&nbsp;
&nbsp;    /**
&nbsp;     * Iterate through current weapons and count the number in each capital
&nbsp;     * fighter location.
&nbsp;     *
&nbsp;     * @return A map with keys in the format &quot;weaponName:loc&quot;, with the number
&nbsp;     *         of weapons of that type in that location as the value.
&nbsp;     */
&nbsp;    Map&lt;String, Integer&gt; groupWeaponsByLocation();
&nbsp;
&nbsp;    Map&lt;String, Integer&gt; getWeaponGroups();
&nbsp;
&nbsp;    /**
&nbsp;     * Refresh the capital fighter weapons groups.
&nbsp;     */
&nbsp;    default void updateWeaponGroups() {
&nbsp;        // first we need to reset all the weapons in our existing mounts to zero
&nbsp;        // until proven otherwise
<b class="nc">&nbsp;        Set&lt;String&gt; set = getWeaponGroups().keySet();</b>
<b class="nc">&nbsp;        Iterator&lt;String&gt; iter = set.iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            String key = iter.next();</b>
<b class="nc">&nbsp;            ((Entity) this).getEquipment(getWeaponGroups().get(key)).setNWeapons(0);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // now collect a hash of all the same weapons in each location by id
<b class="nc">&nbsp;        Map&lt;String, Integer&gt; groups = groupWeaponsByLocation();</b>
&nbsp;        // now we just need to traverse the hash and either update our existing
&nbsp;        // equipment or add new ones if there is none
<b class="nc">&nbsp;        Set&lt;String&gt; newSet = groups.keySet();</b>
<b class="nc">&nbsp;        Iterator&lt;String&gt; newIter = newSet.iterator();</b>
<b class="nc">&nbsp;        while (newIter.hasNext()) {</b>
<b class="nc">&nbsp;            String key = newIter.next();</b>
<b class="nc">&nbsp;            if (null != getWeaponGroups().get(key)) {</b>
&nbsp;                // then this equipment is already loaded, so we just need to
&nbsp;                // correctly update the number of weapons
<b class="nc">&nbsp;                ((Entity) this).getEquipment(getWeaponGroups().get(key)).setNWeapons(groups.get(key));</b>
&nbsp;            } else {
&nbsp;                // need to add a new weapon
<b class="nc">&nbsp;                String name = key.split(&quot;:&quot;)[0];</b>
<b class="nc">&nbsp;                int loc = Integer.parseInt(key.split(&quot;:&quot;)[1]);</b>
<b class="nc">&nbsp;                EquipmentType etype = EquipmentType.get(name);</b>
&nbsp;                Mounted newmount;
<b class="nc">&nbsp;                if (etype != null) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        newmount = ((Entity) this).addWeaponGroup(etype, loc);</b>
<b class="nc">&nbsp;                        newmount.setNWeapons(groups.get(key));</b>
<b class="nc">&nbsp;                        getWeaponGroups().put(key, ((Entity) this).getEquipmentNum(newmount));</b>
<b class="nc">&nbsp;                    } catch (LocationFullException ex) {</b>
<b class="nc">&nbsp;                        System.out.println(&quot;Unable to compile weapon groups&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        ex.printStackTrace();</b>
<b class="nc">&nbsp;                        return;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else if (name != &quot;0&quot;) {</b>
<b class="nc">&nbsp;                    ((Entity) this).addFailedEquipment(name);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set number of fuel points based on fuel tonnage.
&nbsp;     *
&nbsp;     * @param fuelTons
&nbsp;     *            The number of tons of fuel
&nbsp;     */
&nbsp;    void setFuelTonnage(double fuelTons);
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the fuel for this Aero in terms of tonnage.
&nbsp;     *
&nbsp;     * @return The number of tons of fuel on this Aero.
&nbsp;     */
&nbsp;    double getFuelTonnage();
&nbsp;
&nbsp;    /*
&nbsp;     * Default methods that are implemented the same for Aero and LandAirMech
&nbsp;     */
&nbsp;
&nbsp;    default PilotingRollData checkThrustSI(int thrust, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (thrust &gt; getSI()) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), thrust - getSI(),</b>
&nbsp;                    &quot;Thrust exceeds current SI in a single hex&quot;));
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not exceeding SI&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkThrustSITotal(int thrust, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (thrust &gt; getSI()) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;Thrust spent this turn exceeds current SI&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not exceeding SI&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkVelocityDouble(int velocity, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((velocity &gt; (2 * ((Entity) this).getWalkMP())) &amp;&amp; !((Entity) this).getGame().getBoard().inSpace()) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;Velocity greater than 2x safe thrust&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not exceeding 2x safe thrust&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkDown(int drop, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (drop &gt; 2) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), drop, &quot;lost more than two altitudes&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: entity did not drop more than two altitudes&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkHover(MovePath md) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(md.getLastStepMovementType());</b>
&nbsp;
<b class="nc">&nbsp;        if (md.contains(MoveStepType.HOVER) &amp;&amp; (md.getLastStepMovementType() == EntityMovementType.MOVE_OVER_THRUST)) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;hovering above safe thrust&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: entity did not hover&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkStall(MovePath md) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(md.getLastStepMovementType());</b>
&nbsp;
&nbsp;        // if the entity has already moved, its movement got interrupted (probably by a hidden unit, not much else can interrupt an aero unit)
&nbsp;        // in which case, the movement is complete. We just need to allow the user to hit &#39;done&#39;.
<b class="nc">&nbsp;        if(((Entity) this).delta_distance &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: aero has already moved&quot;);</b>
&nbsp;        // an airborne, aerodyne aero is considered to &quot;stall&quot; if it&#39;s not moving anywhere,
&nbsp;        // hovering, landing, or going off board
<b class="nc">&nbsp;        } else if ((md.getFinalVelocity() == 0) &amp;&amp; !md.contains(MoveStepType.HOVER) &amp;&amp; isAirborne() &amp;&amp; !isSpheroid()</b>
<b class="nc">&nbsp;                &amp;&amp; !((Entity) this).getGame().getBoard().inSpace() &amp;&amp; !md.contains(MoveStepType.LAND)</b>
<b class="nc">&nbsp;                &amp;&amp; !md.contains(MoveStepType.VLAND) &amp;&amp; !md.contains(MoveStepType.RETURN)</b>
<b class="nc">&nbsp;                &amp;&amp; !md.contains(MoveStepType.OFF) &amp;&amp; !md.contains(MoveStepType.FLEE)) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;stalled out&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: entity not stalled out&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkRolls(MoveStep step, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (((step.getType() == MoveStepType.ROLL) || (step.getType() == MoveStepType.YAW)) &amp;&amp; (step.getNRolls() &gt; 1)) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;More than one roll in the same turn&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not rolling more than once&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    default PilotingRollData checkVerticalTakeOff() {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(EntityMovementType.MOVE_SAFE_THRUST);</b>
&nbsp;
<b class="nc">&nbsp;        if (getLandingGearMod(true) &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(+1, &quot;landing gear damaged&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getLeftThrustHits() + getRightThrustHits() &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(+3, &quot;Maneuvering thrusters damaged&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Supposed to be -1 for lifting off from an &quot;airfield or landing pad.&quot;
&nbsp;        // We will just treat this as having paved terrain
<b class="nc">&nbsp;        Coords pos = ((Entity) this).getPosition();</b>
<b class="nc">&nbsp;        IHex hex = ((Entity) this).getGame().getBoard().getHex(pos);</b>
<b class="nc">&nbsp;        if ((null != hex) &amp;&amp; hex.containsTerrain(Terrains.PAVEMENT) &amp;&amp; !hex.containsTerrain(Terrains.RUBBLE)) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;on landing pad&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!(this instanceof SmallCraft)) {</b>
<b class="nc">&nbsp;            roll.addModifier(+2, &quot;Fighter making vertical liftoff&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Taking off from a crater
&nbsp;        // TW doesn&#39;t define what a crater is, assume it means that the hex
&nbsp;        // level of all surrounding hexes is greater than what we are sitting on
<b class="nc">&nbsp;        boolean allAdjacentHigher = true;</b>
<b class="nc">&nbsp;        Set&lt;Coords&gt; positions = new HashSet&lt;Coords&gt;(((Entity) this).getSecondaryPositions().values());</b>
<b class="nc">&nbsp;        positions.add(pos);</b>
&nbsp;        IHex adjHex;
<b class="nc">&nbsp;        for (Coords currPos : positions) {</b>
<b class="nc">&nbsp;            hex = ((Entity) this).getGame().getBoard().getHex(currPos);</b>
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                Coords adj = currPos.translated(dir);</b>
<b class="nc">&nbsp;                adjHex = ((Entity) this).getGame().getBoard().getHex(adj);</b>
<b class="nc">&nbsp;                if (!positions.contains(adj) &amp;&amp; (adjHex != null) &amp;&amp; adjHex.getLevel() &lt;= hex.getLevel()) {</b>
<b class="nc">&nbsp;                    allAdjacentHigher = false;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!allAdjacentHigher) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (allAdjacentHigher) {</b>
<b class="nc">&nbsp;            roll.addModifier(+3, &quot;Taking off from crater&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compute the PilotingRollData for a landing control roll (see TW pg 86).
&nbsp;     *
&nbsp;     * @param moveType
&nbsp;     * @param velocity
&nbsp;     *            Velocity when the check is to be made, this needs to be passed
&nbsp;     *            as the check could happen as part of a Move Path
&nbsp;     * @param landingPos
&nbsp;     *            The final position the Aero will land on.
&nbsp;     * @param isVertical
&nbsp;     *            If this a vertical or horizontal landing
&nbsp;     * @return A PilotingRollData tha represents the landing control roll that
&nbsp;     *         must be passed
&nbsp;     */
&nbsp;    default PilotingRollData checkLanding(EntityMovementType moveType, int velocity, Coords landingPos, int face,
&nbsp;            boolean isVertical) {
&nbsp;        // Base piloting skill
<b class="nc">&nbsp;        PilotingRollData roll = new PilotingRollData(((Entity) this).getId(), ((Entity) this).getCrew().getPiloting(),</b>
&nbsp;                &quot;Base piloting skill&quot;);
&nbsp;
&nbsp;        // Apply critical hit effects, TW pg 239
<b class="nc">&nbsp;        int avihits = getAvionicsHits();</b>
<b class="nc">&nbsp;        if ((avihits &gt; 0) &amp;&amp; (avihits &lt; 3)) {</b>
<b class="nc">&nbsp;            roll.addModifier(avihits, &quot;Avionics Damage&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // this should probably be replaced with some kind of AVI_DESTROYED
&nbsp;        // boolean
<b class="nc">&nbsp;        if (avihits &gt;= 3) {</b>
<b class="nc">&nbsp;            roll.addModifier(5, &quot;Avionics Destroyed&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!hasLifeSupport()) {</b>
<b class="nc">&nbsp;            roll.addModifier(+2, &quot;No life support&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Landing Gear Partial Repairs, only apply if the landing gear isn&#39;t currently damaged
<b class="nc">&nbsp;        if (getLandingGearMod(false) == 0) {</b>
<b class="nc">&nbsp;        	if (getLandingGearPartialRepairs() == 2) {</b>
<b class="nc">&nbsp;            roll.addModifier(getLandingGearPartialRepairs(), &quot;landing gear misrepaired&quot;);</b>
<b class="nc">&nbsp;        	} else if (getLandingGearPartialRepairs() == 1) {</b>
<b class="nc">&nbsp;            roll.addModifier(getLandingGearPartialRepairs(), &quot;landing gear misreplaced&quot;);</b>
&nbsp;        	}
&nbsp;    	}
&nbsp;
&nbsp;        //Avionics Partial Repairs, only apply if the Avionics package isn&#39;t destroyed
<b class="nc">&nbsp;        if (avihits &lt; 3) {</b>
<b class="nc">&nbsp;        	if (getAvionicsMisrepaired() == 1) {</b>
<b class="nc">&nbsp;        	roll.addModifier(1, &quot;misrepaired avionics&quot;);</b>
<b class="nc">&nbsp;        	} if (getAvionicsMisreplaced() == 1) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;misreplaced avionics&quot;);</b>
&nbsp;        	}
&nbsp;        }
&nbsp;        // Landing Modifiers table, TW pg 86
&nbsp;        int velmod;
<b class="nc">&nbsp;        if (isVertical) {</b>
<b class="nc">&nbsp;            velmod = Math.max(0, velocity - 1);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            velmod = Math.max(0, velocity - 2);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (velmod &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(velmod, &quot;excess velocity&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getLeftThrustHits() + getRightThrustHits() &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(+4, &quot;Maneuvering thrusters damaged&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getLandingGearMod(false) &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(getLandingGearMod(false), &quot;landing gear damaged&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getNoseArmor() &lt;= 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(+2, &quot;nose armor destroyed&quot;);</b>
&nbsp;        }
&nbsp;        // Unit reduced to 50% or less of starting thrust
<b class="nc">&nbsp;        double thrustPercent = ((double) ((Entity) this).getWalkMP()) / ((Entity) this).getOriginalWalkMP();</b>
<b class="nc">&nbsp;        if (thrustPercent &lt;= .5) {</b>
<b class="nc">&nbsp;            roll.addModifier(+2, &quot;thrust reduced to 50% or less of original&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getCurrentThrust() &lt;= 0) {</b>
<b class="nc">&nbsp;            if (isSpheroid()) {</b>
<b class="nc">&nbsp;                roll.addModifier(+8, &quot;no thrust&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                roll.addModifier(+4, &quot;no thrust&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // terrain mods
<b class="nc">&nbsp;        boolean lightWoods = false;</b>
<b class="nc">&nbsp;        boolean rough = false;</b>
<b class="nc">&nbsp;        boolean heavyWoods = false;</b>
<b class="nc">&nbsp;        boolean clear = false;</b>
<b class="nc">&nbsp;        boolean paved = true;</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;Coords&gt; landingPositions = new HashSet&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        boolean isDropship = (this instanceof Dropship);</b>
&nbsp;        // Vertical landing just checks the landing hex
<b class="nc">&nbsp;        if (isVertical) {</b>
<b class="nc">&nbsp;            landingPositions.add(landingPos);</b>
&nbsp;            // Dropships must also check the adjacent 6 hexes
<b class="nc">&nbsp;            if (isDropship) {</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;                    landingPositions.add(landingPos.translated(i));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Horizontal landing requires checking whole landing strip
&nbsp;        } else {
<b class="nc">&nbsp;            for (int i = 0; i &lt; getLandingLength(); i++) {</b>
<b class="nc">&nbsp;                Coords pos = landingPos.translated(face, i);</b>
<b class="nc">&nbsp;                landingPositions.add(pos);</b>
&nbsp;                // Dropships have to check the front adjacent hexes
<b class="nc">&nbsp;                if (isDropship) {</b>
<b class="nc">&nbsp;                    landingPositions.add(pos.translated((face + 4) % 6));</b>
<b class="nc">&nbsp;                    landingPositions.add(pos.translated((face + 2) % 6));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Coords pos : landingPositions) {</b>
<b class="nc">&nbsp;            IHex hex = ((Entity) this).getGame().getBoard().getHex(pos);</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.ROUGH) || hex.containsTerrain(Terrains.RUBBLE)) {</b>
<b class="nc">&nbsp;                rough = true;</b>
<b class="nc">&nbsp;            } else if (hex.containsTerrain(Terrains.WOODS, 2)) {</b>
<b class="nc">&nbsp;                heavyWoods = true;</b>
<b class="nc">&nbsp;            } else if (hex.containsTerrain(Terrains.WOODS, 1)) {</b>
<b class="nc">&nbsp;                lightWoods = true;</b>
<b class="nc">&nbsp;            } else if (!hex.containsTerrain(Terrains.PAVEMENT) &amp;&amp; !hex.containsTerrain(Terrains.ROAD)) {</b>
<b class="nc">&nbsp;                paved = false;</b>
&nbsp;                // Landing in other terrains isn&#39;t allowed, so if we reach here
&nbsp;                // it must be a clear hex
<b class="nc">&nbsp;                clear = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (heavyWoods) {</b>
<b class="nc">&nbsp;            roll.addModifier(+5, &quot;heavy woods in landing path&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (lightWoods) {</b>
<b class="nc">&nbsp;            roll.addModifier(+4, &quot;light woods in landing path&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (rough) {</b>
<b class="nc">&nbsp;            roll.addModifier(+3, &quot;rough/rubble in landing path&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (paved) {</b>
<b class="nc">&nbsp;            roll.addModifier(+0, &quot;paved/road landing strip&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (clear) {</b>
<b class="nc">&nbsp;            roll.addModifier(+2, &quot;clear hex in landing path&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a maneuver requires a control roll
&nbsp;     */
&nbsp;    default PilotingRollData checkManeuver(MoveStep step, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((step == null) || (step.getType() != MoveStepType.MANEUVER)) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not attempting to get up.&quot;);</b>
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean sideSlipMod = (this instanceof ConvFighter) &amp;&amp; isVSTOL();</b>
<b class="nc">&nbsp;        roll.append(</b>
<b class="nc">&nbsp;                new PilotingRollData(((Entity) this).getId(), ManeuverType.getMod(step.getManeuverType(), sideSlipMod),</b>
<b class="nc">&nbsp;                        ManeuverType.getTypeName(step.getManeuverType()) + &quot; maneuver&quot;));</b>
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * switches certain arcs due to rolling
&nbsp;     */
&nbsp;    default int rollArcs(int arc) {
<b class="nc">&nbsp;        if (isRolled()) {</b>
<b class="nc">&nbsp;            if (arc == Compute.ARC_LWING) {</b>
<b class="nc">&nbsp;                return Compute.ARC_RWING;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_RWING) {</b>
<b class="nc">&nbsp;                return Compute.ARC_LWING;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_LWINGA) {</b>
<b class="nc">&nbsp;                return Compute.ARC_RWINGA;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_RWINGA) {</b>
<b class="nc">&nbsp;                return Compute.ARC_LWINGA;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_LEFTSIDE_SPHERE) {</b>
<b class="nc">&nbsp;                return Compute.ARC_RIGHTSIDE_SPHERE;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_RIGHTSIDE_SPHERE) {</b>
<b class="nc">&nbsp;                return Compute.ARC_LEFTSIDE_SPHERE;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_LEFTSIDEA_SPHERE) {</b>
<b class="nc">&nbsp;                return Compute.ARC_RIGHTSIDEA_SPHERE;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_RIGHTSIDEA_SPHERE) {</b>
<b class="nc">&nbsp;                return Compute.ARC_LEFTSIDEA_SPHERE;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_LEFT_BROADSIDE) {</b>
<b class="nc">&nbsp;                return Compute.ARC_RIGHT_BROADSIDE;</b>
<b class="nc">&nbsp;            } else if (arc == Compute.ARC_RIGHT_BROADSIDE) {</b>
<b class="nc">&nbsp;                return Compute.ARC_LEFT_BROADSIDE;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return arc;</b>
&nbsp;    }
&nbsp;
&nbsp;    default int getTakeOffLength() {
<b class="nc">&nbsp;        if (isVSTOL() || isSTOL()) {</b>
<b class="nc">&nbsp;            return 10;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 20;</b>
&nbsp;    }
&nbsp;
&nbsp;    default int getLandingLength() {
<b class="nc">&nbsp;        if (isVSTOL() || isSTOL()) {</b>
<b class="nc">&nbsp;            return 5;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 8;</b>
&nbsp;    }
&nbsp;
&nbsp;    default boolean canTakeOffHorizontally() {
<b class="nc">&nbsp;        return !isSpheroid() &amp;&amp; (getCurrentThrust() &gt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    default boolean canLandHorizontally() {
<b class="nc">&nbsp;        return !isSpheroid();</b>
&nbsp;    }
&nbsp;
&nbsp;    default boolean canTakeOffVertically() {
<b class="nc">&nbsp;        return (isVSTOL() || isSpheroid()) &amp;&amp; (getCurrentThrust() &gt; 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    default boolean canLandVertically() {
<b class="nc">&nbsp;        return (isVSTOL() || isSpheroid());</b>
&nbsp;    }
&nbsp;
&nbsp;    default String hasRoomForHorizontalTakeOff() {
&nbsp;        // walk along the hexes in the facing of the unit
<b class="nc">&nbsp;        IHex hex = ((Entity) this).getGame().getBoard().getHex(((Entity) this).getPosition());</b>
<b class="nc">&nbsp;        int elev = hex.getLevel();</b>
<b class="nc">&nbsp;        int facing = ((Entity) this).getFacing();</b>
<b class="nc">&nbsp;        String lenString = &quot; (&quot; + getTakeOffLength() + &quot; hexes required)&quot;;</b>
&nbsp;        // dropships need a strip three hexes wide
<b class="nc">&nbsp;        Vector&lt;Coords&gt; startingPos = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        startingPos.add(((Entity) this).getPosition());</b>
<b class="nc">&nbsp;        if (((Entity) this) instanceof Dropship) {</b>
<b class="nc">&nbsp;            startingPos.add(((Entity) this).getPosition().translated((facing + 4) % 6));</b>
<b class="nc">&nbsp;            startingPos.add(((Entity) this).getPosition().translated((facing + 2) % 6));</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Coords pos : startingPos) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; getTakeOffLength(); i++) {</b>
<b class="nc">&nbsp;                pos = pos.translated(facing);</b>
&nbsp;                // check for buildings
<b class="nc">&nbsp;                if (((Entity) this).getGame().getBoard().getBuildingAt(pos) != null) {</b>
<b class="nc">&nbsp;                    return &quot;Buildings in the way&quot; + lenString;</b>
&nbsp;                }
&nbsp;                // no units in the way
<b class="nc">&nbsp;                for (Entity en : ((Entity) this).getGame().getEntitiesVector(pos)) {</b>
<b class="nc">&nbsp;                    if (en.equals((Entity) this)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (!en.isAirborne()) {</b>
<b class="nc">&nbsp;                        return &quot;Ground units in the way&quot; + lenString;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                hex = ((Entity) this).getGame().getBoard().getHex(pos);</b>
&nbsp;                // if the hex is null, then we are offboard. Don&#39;t let units
&nbsp;                // take off offboard.
<b class="nc">&nbsp;                if (null == hex) {</b>
<b class="nc">&nbsp;                    return &quot;Not enough room on map&quot; + lenString;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!hex.isClearForTakeoff()) {</b>
<b class="nc">&nbsp;                    return &quot;Unacceptable terrain for landing&quot; + lenString;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hex.getLevel() != elev) {</b>
<b class="nc">&nbsp;                    return &quot;Runway must contain no elevation change&quot; + lenString;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    default String hasRoomForHorizontalLanding() {
&nbsp;        // walk along the hexes in the facing of the unit
<b class="nc">&nbsp;        IHex hex = ((Entity) this).getGame().getBoard().getHex(((Entity) this).getPosition());</b>
<b class="nc">&nbsp;        int elev = hex.getLevel();</b>
<b class="nc">&nbsp;        int facing = ((Entity) this).getFacing();</b>
<b class="nc">&nbsp;        String lenString = &quot; (&quot; + getLandingLength() + &quot; hexes required)&quot;;</b>
&nbsp;        // dropships need a a landing strip three hexes wide
<b class="nc">&nbsp;        Vector&lt;Coords&gt; startingPos = new Vector&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        startingPos.add(((Entity) this).getPosition());</b>
<b class="nc">&nbsp;        if (this instanceof Dropship) {</b>
<b class="nc">&nbsp;            startingPos.add(((Entity) this).getPosition().translated((facing + 5) % 6));</b>
<b class="nc">&nbsp;            startingPos.add(((Entity) this).getPosition().translated((facing + 1) % 6));</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Coords pos : startingPos) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; getLandingLength(); i++) {</b>
<b class="nc">&nbsp;                pos = pos.translated(facing);</b>
&nbsp;                // check for buildings
<b class="nc">&nbsp;                if (((Entity) this).getGame().getBoard().getBuildingAt(pos) != null) {</b>
<b class="nc">&nbsp;                    return &quot;Buildings in the way&quot; + lenString;</b>
&nbsp;                }
&nbsp;                // no units in the way
<b class="nc">&nbsp;                for (Entity en : ((Entity) this).getGame().getEntitiesVector(pos)) {</b>
<b class="nc">&nbsp;                    if (!en.isAirborne()) {</b>
<b class="nc">&nbsp;                        return &quot;Ground units in the way&quot; + lenString;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                hex = ((Entity) this).getGame().getBoard().getHex(pos);</b>
&nbsp;                // if the hex is null, then we are offboard. Don&#39;t let units
&nbsp;                // land offboard.
<b class="nc">&nbsp;                if (null == hex) {</b>
<b class="nc">&nbsp;                    return &quot;Not enough room on map&quot; + lenString;</b>
&nbsp;                }
&nbsp;                // landing must contain only acceptable terrain
<b class="nc">&nbsp;                if (!hex.isClearForLanding()) {</b>
<b class="nc">&nbsp;                    return &quot;Unacceptable terrain for landing&quot; + lenString;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (hex.getLevel() != elev) {</b>
<b class="nc">&nbsp;                    return &quot;Landing strip must contain no elevation change&quot; + lenString;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    default String hasRoomForVerticalLanding() {
<b class="nc">&nbsp;        Coords pos = ((Entity) this).getPosition();</b>
<b class="nc">&nbsp;        IHex hex = ((Entity) this).getGame().getBoard().getHex(((Entity) this).getPosition());</b>
<b class="nc">&nbsp;        if (((Entity) this).getGame().getBoard().getBuildingAt(pos) != null) {</b>
<b class="nc">&nbsp;            return &quot;Buildings in the way&quot;;</b>
&nbsp;        }
&nbsp;        // no units in the way
<b class="nc">&nbsp;        for (Entity en : ((Entity) this).getGame().getEntitiesVector(pos)) {</b>
<b class="nc">&nbsp;            if (!en.isAirborne()) {</b>
<b class="nc">&nbsp;                return &quot;Ground units in the way&quot;;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        hex = ((Entity) this).getGame().getBoard().getHex(pos);</b>
&nbsp;        // if the hex is null, then we are offboard. Don&#39;t let units
&nbsp;        // land offboard.
<b class="nc">&nbsp;        if (null == hex) {</b>
<b class="nc">&nbsp;            return &quot;landing area not on the map&quot;;</b>
&nbsp;        }
&nbsp;        // landing must contain only acceptable terrain
<b class="nc">&nbsp;        if (!hex.isClearForLanding()) {</b>
<b class="nc">&nbsp;            return &quot;Unacceptable terrain for landing&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    default void liftOff(int altitude) {
<b class="nc">&nbsp;        if (isSpheroid()) {</b>
<b class="nc">&nbsp;            ((Entity) this).setMovementMode(EntityMovementMode.SPHEROID);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ((Entity) this).setMovementMode(EntityMovementMode.AERODYNE);</b>
&nbsp;        }
<b class="nc">&nbsp;        ((Entity) this).setAltitude(altitude);</b>
&nbsp;
<b class="nc">&nbsp;        HashSet&lt;Coords&gt; positions = ((Entity) this).getOccupiedCoords();</b>
<b class="nc">&nbsp;        ((Entity) this).getSecondaryPositions().clear();</b>
<b class="nc">&nbsp;        if (((Entity) this).getGame() != null) {</b>
<b class="nc">&nbsp;            ((Entity) this).getGame().updateEntityPositionLookup((Entity) this, positions);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    default void land() {
<b class="nc">&nbsp;        ((Entity) this).setMovementMode(EntityMovementMode.WHEELED);</b>
<b class="nc">&nbsp;        ((Entity) this).setAltitude(0);</b>
<b class="nc">&nbsp;        ((Entity) this).setElevation(0);</b>
<b class="nc">&nbsp;        setCurrentVelocity(0);</b>
<b class="nc">&nbsp;        setNextVelocity(0);</b>
<b class="nc">&nbsp;        setOutControl(false);</b>
<b class="nc">&nbsp;        setOutCtrlHeat(false);</b>
<b class="nc">&nbsp;        setRandomMove(false);</b>
<b class="nc">&nbsp;        ((Entity) this).delta_distance = 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    default int getFuelUsed(int thrust) {
<b class="nc">&nbsp;        int overThrust = Math.max(thrust - ((Entity) this).getWalkMP(), 0);</b>
<b class="nc">&nbsp;        int safeThrust = thrust - overThrust;</b>
<b class="nc">&nbsp;        int used = safeThrust + (2 * overThrust);</b>
<b class="nc">&nbsp;        return used;</b>
&nbsp;    }
&nbsp;
&nbsp;    /***
&nbsp;     * use the specified amount of fuel for this Aero. The amount may be
&nbsp;     * adjusted by certain game options
&nbsp;     *
&nbsp;     * @param fuelUsed
&nbsp;     *            The number of fuel points to use
&nbsp;     */
&nbsp;    default void useFuel(int fuelUsed) {
<b class="nc">&nbsp;        setCurrentFuel(Math.max(0, getCurrentFuel() - fuelUsed));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A method to add/remove sensors that only work in space as we transition in and out of an atmosphere
&nbsp;     */
&nbsp;    default void updateSensorOptions() {
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
