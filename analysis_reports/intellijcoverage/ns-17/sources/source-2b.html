


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Entity</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: Entity (megamek.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Entity</td>
<td class="coverageStat">
  <span class="percent">
    15.8%
  </span>
  <span class="absValue">
    (164/1041)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14%
  </span>
  <span class="absValue">
    (892/6375)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Entity$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Entity$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Entity$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$02cU3us8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$04T5XGWd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$06SD0Q7m</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$08fozFbL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0d7cK8XU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0EpyWgo5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0hSNpBbL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0IXO4yPQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0J1YfgVt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0OU1Rnc8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0pHByu7E</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0qviGK26</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0u2PYZj2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0uvCuhdm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0vpNnyGQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0wbeWIL0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0WJ9rZkU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0Z2oJnSL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$0Zq7rSRd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$12NuYOJj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$13nhVMCI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$14ldtinU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$17MTDmwb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$19eSU202</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1bQBkFd7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1CU1EE3C</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1eqyIPOl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1Et6Vuc2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1fkYbchE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1gQFp70S</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1HRbl9vN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1isa6qr5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1k9gKAnY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1kJMgxZo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1KX2IpNU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1l1clTro</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1L5zOZ5b</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1MuK2unA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1O2GZpny</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1PBLjyho</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1pg82cCh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1PNmTGFd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1sFoLkA8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1wMHyMtE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$1ZJhX1ER</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$21LfKIB0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$24XAUJwo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$26isBQOz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$272Ag3c8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2FGoI6Oj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2HHXeQeW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2iEhR681</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2iswP9b3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2pU4MvOG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2Qs4zGVn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2qVyc87U</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2RIeZkgF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2riWcBtr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2SCL43DT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2wvk5mPj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2X43pobC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2YIDR0bW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2Z2vZW9F</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$2ZjEZP3u</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$31mrXPVK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$332JjmSQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$35vLFuKL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$37Ha2zll</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3AHvnq5l</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3AVFXlEX</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3C0jtutq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3CqwWs3Q</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3Fz8crn5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3jEKdIXx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3oIJgJGb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3q59v9A9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3qdwLIqw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3RXh8CKy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3SLAaftc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3umDLrgf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3UwFpDjA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3wocoU8F</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3Wychyzi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$3yLmteAI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4cgWRubP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4d9gqNkJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4Da1nHzv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4dS6ylpg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4erJIvKj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4FpWnBRO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4hE90hai</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4IbEEyjc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4JxgYWzJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4LRsCPxR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4MB4odrW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4TSBB1Ho</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4UjXEu7R</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4YbI2RBY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$4zrr06vm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$53891lCC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$53SorIBv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$55srNF4s</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5870d1rj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5AEadHzN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5byAIl6k</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5EBZpbvO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5EZnPVEU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5GaVNLmS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5GRVM31O</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5HeWFqCj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5HlPlj5B</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5jlx392h</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5Kdcx9ZJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5nVJIbpf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5p2jyrmK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5pgHPE4b</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5vnsi3fU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$5Y56P7tU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$625qpU1x</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6DOIoYgT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6GI0dnoH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6J5W9Hy4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6jfdazyL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6L6HH48j</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6lySXdgr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6mCtobfk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6mHDXYgZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6NM5IfYm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6r5kCT6Y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6RyHRPZg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6S1Tnirb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6sSdsaqQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6W4Gl66I</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6WP0X03r</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6WrSILIO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6XRSUQg3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6y6a0FTk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6ygaMZsu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$6ZfvECA7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$70zFk8Ci</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$728zAR53</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$73vvqYz1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7AySt41C</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7ba6vfdf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7CaDtKaQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7h0tlDtn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7HSEdG1Q</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7LbLNGU6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7lN6ANQB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7m0kTqZM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7n7etDJg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7nGmxY4X</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7sylxHyX</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7Y6cwbIQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$7Yqtqk0y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$82g5lqoU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$84I0PNHI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$86mPNAbb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$86SOdcg8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$87Udy9EG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8aFBEibf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8CGpXxG4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8DHZWQXM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8ely71lm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8gjr8Vrp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8hxpyVhw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8iPHbDlE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8IqUsguL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8J4j7EBf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8MeZb9AR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8nTU1Vr1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8OiUD1qv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8RDMSidA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8rzszqPO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8Tr2OrHc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8TUhy729</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8XIE8AJR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$8zgiXmsS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$942SYe4a</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$99udl3Ro</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9EAYnmd9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9fkI3rAQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9fuSnOZV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9HhlhzTH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9I3dNXRX</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9khHZK85</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9Qly9jp1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9T1ttOcy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9T7XWvKd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9TvuaASq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9ufL52ym</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9vUOVKtD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$9ZYWsrcx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$A0XEIBhV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$A13GJjHY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$A2tMxEF0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$a3fWbYRB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$a3TnVsJh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$a4eArgtD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$a4zfr5TA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$A6Iq7DCi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$abqEcCdV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$acz9zTI5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aD8LWYXO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$AdjtjSdG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$adlAcQLP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aglEJXNZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aHd7nlcp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aiwtvimU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$AlC5TEmn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aM5TYWnb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$AmljfMWw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aNxzlo5G</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aP5a3kA3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$AP9LcBKg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aqw3TOXc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aSpagela</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aSymIhmv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aTcagpyj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$AtozPqLP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aUL2kvZk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$AWsnwkKg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$aX1o3t8w</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$axlINHHs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ay5S0tAz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Azt08X3E</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$B3QNGAZP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$b3xxTCdB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$b7dsYPkD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$B8nqHRf1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$B9bhVhRW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BBHGsdne</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bbHZiGAw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bBKZu0B4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Be6sfPiH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BExRJXm3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bGHZ4UZa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bgxmnVXc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bHiKwGA3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bht8UtJr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bHvd8q6A</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bITek7xM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BjHdhn4d</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BJPHEE0I</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BLlOneQD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bNh2N75d</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bPLPyl76</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bqUnyNHb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bRdbqzMx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bRZHCuRc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$btpmeGGs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bUKfDmq2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BuPgVUVR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bvFGLcWT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BvKtIVKI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bvKUzeb1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BwdcG2zw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bWydli7l</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$BxgDPZfQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bXtvrnPR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bYvhdJdz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$bZRXs63s</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C0UrEBJS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C1RmGNad</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C32UgeZz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$c3sbqvNd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C4AMxBeC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C4EU8l5i</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C55WmJ59</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$C5asgVQo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$c9QxVUbP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ccWl4hjD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CdV8iDu7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CDZYhGxu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cEDBWOWa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cFgW3P6F</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cHyQASy3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CiFMKr6j</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ciNCPC1h</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CjWOc5wh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ck0aDtnU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Cl7KVJAC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CMCtVSzM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cMJMObpp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cnV9Tk10</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cOQfVtar</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cPMBZCSl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cqK2plP4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CqSazULu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CtsogLA0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CTVPjdT7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CujEgZ0h</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$cvqoW2jd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CWIJX6OS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CXJG7r6c</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CxMkdmrI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$CZKjHMoo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$d0HgXBM7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$d1reqfLv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$d1zQ8Ewf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$d40bgg2N</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$D4a4Js5E</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$D53oMQV3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$d8MhEcnA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$d9SIgccf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DA8x87Lu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dACwSofT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DAey1uim</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dALdowXe</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DbelYCjf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dHl3UkZB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DIfzksNa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DiZSS8OG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Dk5KBvFm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dl1gJjNc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dL1XdvQy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dL4flJnl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dlFAHPTF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DMaJIGWP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dR7dECsV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dRLLJBJ0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DT1GCIVA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dVlVr3Qq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dxROsZxc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dyWvBARU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$dztmpw5H</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$DzvKq6zT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$E0g3HrN5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$E0OmL9lV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$E1RRE8HF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$e2kt9Lqq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$E3a9ZpjL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$e3ER6WXL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$E5jaEMnS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$e7eu4Wlb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$e7hpG1fm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$E8wwhJKq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eAjJTw0R</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EaqIbFGp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eawKN2L7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EbKvtU5U</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eCgQfu5B</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EcurWg4Q</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eERUaqbw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$efE5wXMk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eFOuCv9U</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eFUpOgzJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eFWqUUfY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EFyo8kXv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eI2RvVnC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EJpS2BRL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EKCKsJpU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ektli2NZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eljOUPOo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ELWEj8Bi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$enEOHfMJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ePAQC4Ux</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ES1oKQup</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eSyucsRU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EtiRvE5i</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$eU68fn71</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EuhffoML</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$EVKBX8qn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$evXfc9AF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ewSWkosD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ExoyWTVi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ezGqoeX8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$F1K9O2lM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$F1WQ7Lj1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$F2yQWYWY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$F5Rx5USY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$F6pLrL8L</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$F8grYLco</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fbvMxscZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FcK5URjn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fCv1XrJd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FeRywIXW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FfV9rvOO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Fgs0P1do</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fH5pb7BL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fILx74gY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fJLyVdGc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FJuESGOd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fkzHew8l</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FN7VeKJ0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fNui1WQ4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fo8hH1Pb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FPeqfRxI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fQ4M3Y83</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FQkXXMhj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FqSJHWO4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fr3ZZelz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FrWoXBDR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fstieclP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ft4mZpgk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FUQaIyec</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$fV7L01cA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$FvdL7Ktr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$G0H6Lry3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$g3RlRbMO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$G84rZcrG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$G8SZiJMt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gaBQbnnA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gEEt8Ndv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gfn83owS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GFxi1q5G</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Gg5NzzVL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$giA3t79B</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GiKfwhi0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GJ0jLXdQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GKNQO8rC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GL0PG6SM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$glPOvXBe</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GoG75qyp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gOMrQmLq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GQ9qBqlH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GQAwPgv3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gQsabA5k</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GSh7Jyuh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GTnQ9Sry</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gVb1TdH1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Gvg2HwDX</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gvrNZD3S</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$GVsxoNvj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gwkSLgCP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$gx7ZFQX3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$H0UVE5Ku</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$h17FVrTW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$h1CGluLm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$H4lPfALW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$H5pbOSli</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$H6aesn0L</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$h6Xb6e4r</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$h98UpyFC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HB8RbWmh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hBAaAks1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hbwNbEh8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hCg01aSV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hdI9JM2d</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hdQ63s3m</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HEwEcWHH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HF9mSG4v</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hfJmTu2s</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HgPxfqBh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hGr3Eff5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hGRAxlBw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HiNmW3st</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HjH9lQOy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HK3S1oTW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HMbWq0Ji</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HmfVf4oN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hmjq8YIb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hmUJhKxr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HnbRCWPD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HoFf3Kgx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HouPaHYV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hpdxcp9c</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hpZrvkln</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hQi3dc6z</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HrycSajo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HS58axIs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hTQUuoS6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$huExIOCT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Hv5mAU0y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hva5hEFd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hVDe9GVn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hVYU7HEj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HwDUlfhx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Hwmq4Muq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hyoQWxcE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$hZCx1ozI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$HziPxtaX</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$i132mvtq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$i1ZTwpft</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$I5xQTYc7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$i8oSoWu1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IbAsDKYK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$idIjXL26</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ifxffgwK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Igzobp4I</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iHMyp9XG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iIsfuSAY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iIXYfNnk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IjyeC5Ig</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iK8jWMsI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ikcjhWp5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iKOSj2Di</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iKTuJej6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Il9VQ2nx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IleedPkU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ilP9zfaF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ilpw4iiQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iMydNTnV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IN0Zhaab</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$INH7tVcV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IOJ380ud</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iozjPcFz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iP4ueAB8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IQ6WjQKe</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iQWOb5QC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iRmwVReY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iTFpqPqv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iTGIuIJ9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iuDQ0yzh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IUntxQev</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IUWEjeNj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IVfMNYM0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iXor7qeO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iYQprluz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IZlBmc32</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$IZryhA1J</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$iZY0i8hP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$j0iHPEML</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$J2ySkSsl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$J37k0cAr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$j40Foxkd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$J4m1Wcen</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$j5nYpx2T</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$j6EPIc7O</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$J6WFCJYF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$j7jU9GhH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$j7NAhzLW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JaleEb8H</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Jaomlpcf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$jB8iQ69P</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Jd1t0wGT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$jeu2wna3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JIXLA30d</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Jj8XmMBT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JJPiwd5N</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Jm3gcnRw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JOAZB40R</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JSdBlNcp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JT8OJKzj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JTz9IIFz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$jUqsBm5s</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JUxu5k71</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JV2Mxf2I</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$JwwHPCkd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$jXYj4RTE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$jYKOu7e2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$k18zDKRM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$k1tJR8O9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$K4dizRYj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$K7Dl7sSN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KbxXxb3H</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KC2HbqGD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KciSzuDe</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KeP651kT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KfnFkFSL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$kivjB1VN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Kjqkgg0y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KKqfls5b</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KMj7JPxE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$koTezvE3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KPHFR92V</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$kQlMlp8z</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$kRex0CVt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KSrFCZpC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KTBkTGPz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ktEXmWED</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KtxloE4y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$kuqPoo9B</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KVSzCtmD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$KWMPpYOx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$kYCV6ms0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Kygqj9bm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$kYIbaRhi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Kz2kqqUV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$L0QSS11N</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$l0RW5dhB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$l51qlgOo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$L8EFtn8c</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LavOpTM0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LB8mst1t</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lbljlJ5T</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LeoZSVsB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$leXVSpkj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Lg8W8FpP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LgGg48sp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lhTPpbwv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$liE6MoOr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$liR8c3f0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LJGltarE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lKrlwbwL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LkZXHpmZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lLXFNNpO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lmjUYE4D</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lNLpn7Eq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lPFU0FSr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lsbhKitU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LTbtfXEp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LwPwUbHU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lYBKqHlx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$lYC5TcNl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$LYLRD3zJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$M0cGSSD2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$m1thSG8M</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$M7eTElJY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$M9sBl2VA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MbGYpz2Y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MBkGFtaj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mBZyg6ux</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MDoluMkM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MdXtkST1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MemYd46s</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mgILynIG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mgJSuR6N</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MgsCFMCy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MgtK75u6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MGxgrWLV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mGyhjwTZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mJLXD45j</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Mk7O9ien</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mK8rOST7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mKP8oESV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MKwf9YNN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MOJnXdEo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mPK1YKlr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mPxK2haM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mQjnjSzj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MquCZfap</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MSbtYSaI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mSOZ4n51</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mWDdYc35</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MwKyaY2E</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$MwTWV8Lp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mxX8mgit</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$mYePzX1O</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$N1QVYbrw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$n4jYPL1y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$n5akHITU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$n5umpbtl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$N63ZdpCZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$N6G3ZLX9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$N7k0SMvP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$n8ps3JuT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$naKENTit</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ncr0HETl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nCXfUudx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nDWNCvs9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NEr9Rval</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NfBzhVHj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nGnvxR25</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nGTVOVGl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ngy87MgJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ni8OpqkF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$niGeFw4x</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NJLs0pj9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nKnQDZRJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nlLxq5vy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NLOFg2b8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nMlIPqaB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$noB6iuWa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$npmLAtv2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nSjPVhA4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NSl3LXNh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nSpX8Nov</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nSWATWCA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NTaqDD8m</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NtlaAoit</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NtvzV5FI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ntXef6z4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NuGj9wGL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nVA2UVQb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NVDdivUN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NVkUcTDJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NVx6C0E8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nwaVdRtm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$nyouedkC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$NZ9Jes2A</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$o05Xlh51</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$o1Uv7vdR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$O43HllzU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oAURA5IF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OBEy1NDz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ODK0Efxd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$odn6aTtA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oe5AxKlh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OeTW1gCJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ogCA1gjc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oGFZbe2G</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Oi5mttaa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OiovQPxw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oj8ZF1jU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ojEyPQh0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oJpsmctP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oKZjAzt0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$onCfC9cl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OOetCibb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OOmVk79y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OQ1VMLaC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OsKeKNt8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OsqbThcx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OTpLg643</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$otTTwsyg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oUiOvKgy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$owcwuMLR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OX2ah4hE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oXKwk9uI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OxLDFpvk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$oY2GUAQP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OYTZ0qyf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$OzRnnr1g</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$P00CZDgs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$P0YU3PYB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$p27zBpH4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$p3NJhCEn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$p4dZFM0b</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$p4xsPEd0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$p5i4pQeU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$P61XjKqZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$p6jrHoDF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$P6QWj0c7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PAR0SO9C</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PaTeEP2w</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PBTf6wiS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PBz99DZ9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pC5koUx5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pgk5tjMj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pHezJdZZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pIcIOnN5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pIspxKCG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pK6pHcae</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pm7VtJjG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pMmc1rUQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pn1Iefvs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pPaRSkIO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PQmsekFP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PrXz007S</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PSMCW3Tu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PTPuM0D4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PUbVef1x</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PuFLVLNf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pUk1GfMn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PvlNCKhK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PwbHQVU6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pxBYmRaK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PXhejpsL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$pXWLjg6D</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PyaKaZjq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Pzd49ZFs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$PzF69Cun</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Q2Av0gmd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$q3ZalHBG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$q6KxNBIO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Q76T6U3e</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$q7Bl9s5W</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$q9GFrmVu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qA7gU46X</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qAD8fcYh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QdZV9xxB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qEgFNAT2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QfdfKQjp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QGSS5sG5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QHFAvnvX</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qIowgLPW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qiskqKSt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QiTIk1at</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QklPf7Ko</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ql2ktQ3h</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qLGaBwOr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qm9wpAKn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Qo3AyoDz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QobJ7wIJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qqhpUUWZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Qqo73hwv</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qQxIbUPp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QSDp2des</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qTSbjJy4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QU0vOmwd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qu3oLVBl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QvHmLJhC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QVSnH2yB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QyhpV4HO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$QZ00Ceow</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$qZad9eH7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$R00mNMs1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$R17XaYHR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$r5NAsMag</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$R8250Qf2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$R8aosxDg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rA8naRZC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rcVn9fYx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$reuTwYkl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RFHiTujT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rGca34dw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rhARP1q6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RHeS8t0g</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RHvsjXcw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RHwB6Wm8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RIfCvqG3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rKrUJDcD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rMwGy26E</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rMwW3xNo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rNxo0xg3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rQ3cKtNg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rqcSVO5s</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rRsaIc9k</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rRssQjGp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RRtNQqTT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rSgDosZp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RTdUPwO4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RtVw7VIj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RUhMldAk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ruWxvCQO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RvBOhaK8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rvESYNwY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rw375C1l</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rWK27NYL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rwO3IPEU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RX7hbOhA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ry6DTHym</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rynDLTow</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$RzCHHigs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$rzllr9XY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$s71lMZbi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$s9xojFy7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Sa9jKLBq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SBIRzRy6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SdCQH441</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SE1783IC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$seo2mfu3</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SFJtZKiT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Sg1RJKhC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Sgxo20b4</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sgY5LDKT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$shiIM06K</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$siIG6XOm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$siYklMp2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SjAdBZ5r</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SjNDGCNw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SKi9dfDf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sky4eDZG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$snbHTG5N</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sNFDM5Ej</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sNrkcJyx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SO8rJEPF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sOhEU91K</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SPbmhw1t</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sQFPWp6m</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sqVaERHj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ss3YQD1I</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ssFSQn61</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sT5QavB5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$STtc7Ggu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$su4Mc4vm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SuEa7rGD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sVmhkTKW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$svRDSzEn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SwLmCHp6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SXNEC6Gi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SXP8yjSb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SXsnZcIa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SxWcLkId</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SY1z6O61</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$sYm46IQM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$SyWsnPPb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$t0kLqYkM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$T0YEznmD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$T3XIsenC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$T6olgtei</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$t7gBp4bP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$T9KV76Av</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tAf4xcIi</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TB2w3Uue</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TCJxiZFU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tev5kdEU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tgMudqiA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Th738sKq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tIrCqQaV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TisvZtzm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TJcTcRmS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tKGQgB4g</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tL8dm0dt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tLohI73K</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tLw3MxLA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tmfXzFaZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TNmOVsXL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tnYj5jA0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TOw982Sd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ToWl9dTl</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TQqWRGXB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TrxMwjIP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tTcWM5x9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TtdTtsZV</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tTDZ4hXq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Tuo8lk5X</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TW57CP3f</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tywRLU13</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$tZDA5iwC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$TZDTj6G2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ubpdNzk5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Ue7GtGhd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ueq9HzoJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UEwvDNtI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uFMggCk1</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UFpHz7rT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uFWRkqya</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UgLuIxpD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ui0ovMlg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UInM2r0b</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UjY4QxV8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uKrfFx8H</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ukv1ctqg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uPpfVutf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uqMyCSMd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UrJQoaWJ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UrNQVn1u</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Usa0iO8i</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uVdDFBzL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uVk8Nf0k</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UwiHXBNQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uwWDcbqA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uX8xZbag</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$uXutMwxS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$UZxPzJVo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$V1BYonzp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$v1EjbP82</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$v6CnWCRm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$va0OjNCZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vcfJWhsR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vCrD78Ng</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VcwvnauY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vdxE893Y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VEMpOzOs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VF9OPjkp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VfCoUlUT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VfZY4TIB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VG0yBOcy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VHhKtgxg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vI1dOIfP</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vIl1roNH</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VIXNlLxB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vke42w1v</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vKTvehSk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vlBZ8qA6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vLFWOtfo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VmMzZvXY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vP2a22W6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VqMtd0Kt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VSc8sgjr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vsOSmj9c</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Vu8sebwS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VV9MZU6o</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vvq1SVtB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Vvy3i21y</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$vVZqNpaq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VwCYP00B</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$VZKTDoiQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$W1ALe1ub</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$w2Tt7S3W</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$W41UN5uW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$w4V5X2rU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$w7f9ojvr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$w8HYSnWm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WBGcOVs9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WD57d33G</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wEaACidG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wFyviIUB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wGn7flRw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wgsuARs7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wHFbuCH9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Whm7y55e</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WJzs2z4U</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wlW9GwcD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wMh9IMPE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WP2gfrSF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wpGejCD2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wPMzQywm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WPQ9p1D6</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Wq879YFZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wQIEBbZt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wqw4J2x0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Wr0eazxw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wSCOjEZr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wSyWCghf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Wt6v4ewF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wTOlRmMo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WU1RgVVz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wVgymwy0</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wvT1T8qD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wWbCjAM8</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WyjLhyeZ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$WypqD4hz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$wzD00iLw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$x0nTaPux</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$X5TPwnzQ</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$X6l5Vr1h</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xbWUQqOR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XcBP49ZK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xEjO4N6G</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XGb4N3TK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XHEooXrU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XhQhdHoE</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XIq3S7hM</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XKqKFI02</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Xm8aQkXa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XmWVgoTf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xO66Mncr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XO882gSx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xOMrOo0O</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xPdGUN3I</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XQraEDPO</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xQrbj0OB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XqwXe6sw</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XsZLPNcx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XtJYySFk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XtmaToGI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XTtwzzJd</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Xu8Kxvgs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XuBJ97Mk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xUqE33Ws</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xvf1P0Vx</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$XwQQUNbp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$xXvY1Ugz</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Y05xLuLA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Y0tqa7WF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Y1CCglDf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Y4ZVKTH9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$y5Pq8WEA</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yaSRWk3A</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yB71LhkL</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YDWEzuQa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YE0HEUUy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Yel2rUcr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YElINWJo</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YfTsyyLa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YI3zwCrt</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yiqFur9l</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YkuHA3bs</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ym3PWurj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YMajuZjf</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ymFITH5K</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YmmIwnOq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ymr2WTqb</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yN9Mdg4J</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YnX9QTqN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Yo7OM1sj</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YoJMgNfg</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ypAKaCA7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yq2sgtlr</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yrf9Oz2N</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yRJ3c7fp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yRu8jWWU</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YsaIhDiW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ysHuC3UR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yVJF1aEI</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yvuN45Mm</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YwnZszqS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yXAdrW2J</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yyBb7xor</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$YyP1Q9pq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yYtRIRf2</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yzRG7ZXN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$yZwVtwaR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Z02caiRh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z0UVmPtk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Z3vGJTMC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z4dvboed</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z536zk34</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z5a0tFx5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z5HIkYYc</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z7TOC7RW</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$z95aq7Ij</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zBlsZDLF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zBor3Xbe</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zdau9Q90</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZdFHwiJn</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZdgdEL7D</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zEbqIXKq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Zee0Rn08</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZfnZ5rDN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zgIigU51</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZGZ3kfFD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zHgqy5fp</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZhoEVQcF</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZhPTEb3V</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zHtuOTHD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Zi2CcUeG</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zIv6F99J</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZkBKA2Cy</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Zl66GVCN</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Znp5ifHC</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Znw19wPT</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zNYHTfXK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Zo0wajzh</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZOqC77o5</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zOuE6Vxa</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zQDds2qY</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZqJkqiHS</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZQlde0Yu</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZRBHugi9</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Zupk1W1D</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zV8M6omD</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZVbISeEK</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZVcF6x6t</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZVSNsgs7</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$Zwy4sbkk</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZxIuL4DR</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$ZyRPf5Tq</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zznsMbNB</td>
  </tr>
  <tr>
    <td class="name">Entity$MockitoMock$1331968307$auxiliary$zZWBzeqW</td>
  </tr>
  <tr>
    <td class="name">Entity$WeaponSortOrder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    15.8%
  </span>
  <span class="absValue">
    (166/1048)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.1%
  </span>
  <span class="absValue">
    (903/6398)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2018 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.math.BigInteger;
&nbsp;import java.text.NumberFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.client.ui.swing.GUIPreferences;
&nbsp;import megamek.common.Building.BasementType;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.MovePath.MoveStepType;
&nbsp;import megamek.common.actions.AbstractAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.ChargeAttackAction;
&nbsp;import megamek.common.actions.DfaAttackAction;
&nbsp;import megamek.common.actions.DisplacementAttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.PushAttackAction;
&nbsp;import megamek.common.actions.TeleMissileAttackAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.annotations.Nullable;
&nbsp;import megamek.common.event.GameEntityChangeEvent;
&nbsp;import megamek.common.icons.Camouflage;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.options.IOption;
&nbsp;import megamek.common.options.IOptionGroup;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.options.PartialRepairs;
&nbsp;import megamek.common.options.Quirks;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;import megamek.common.util.StringUtil;
&nbsp;import megamek.common.weapons.AlamoMissileWeapon;
&nbsp;import megamek.common.weapons.AltitudeBombAttack;
&nbsp;import megamek.common.weapons.CapitalMissileBearingsOnlyHandler;
&nbsp;import megamek.common.weapons.DiveBombAttack;
&nbsp;import megamek.common.weapons.SpaceBombAttack;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.WeaponHandler;
&nbsp;import megamek.common.weapons.battlearmor.ISBAPopUpMineLauncher;
&nbsp;import megamek.common.weapons.bayweapons.AR10BayWeapon;
&nbsp;import megamek.common.weapons.bayweapons.BayWeapon;
&nbsp;import megamek.common.weapons.bayweapons.CapitalMissileBayWeapon;
&nbsp;import megamek.common.weapons.bayweapons.TeleOperatedMissileBayWeapon;
&nbsp;import megamek.common.weapons.bombs.BombArrowIV;
&nbsp;import megamek.common.weapons.bombs.BombISRL10;
&nbsp;import megamek.common.weapons.bombs.CLAAAMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.CLASEWMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.CLASMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.CLBombTAG;
&nbsp;import megamek.common.weapons.bombs.CLLAAMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.ISAAAMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.ISASEWMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.ISASMissileWeapon;
&nbsp;import megamek.common.weapons.bombs.ISBombTAG;
&nbsp;import megamek.common.weapons.bombs.ISLAAMissileWeapon;
&nbsp;import megamek.common.weapons.capitalweapons.CapitalMissileWeapon;
&nbsp;import megamek.common.weapons.infantry.InfantryWeapon;
&nbsp;import megamek.common.weapons.other.TSEMPWeapon;
&nbsp;
&nbsp;/**
&nbsp; * Entity is a master class for basically anything on the board except terrain.
&nbsp; */
&nbsp;public abstract class Entity extends TurnOrdered implements Transporter, Targetable, RoundUpdated,
&nbsp;        PhaseUpdated, ITechnology {
&nbsp;    private static final long serialVersionUID = 1430806396279853295L;
&nbsp;
&nbsp;    public static final int DOES_NOT_TRACK_HEAT = 999;
&nbsp;    public static final int UNLIMITED_JUMP_DOWN = 999;
&nbsp;
&nbsp;    /**
&nbsp;     * Entity Type Id Definitions These are used to identify the type of Entity,
&nbsp;     * such as &#39;mech or aero.
&nbsp;     */
&nbsp;    public static final long ETYPE_MECH = 1L;
&nbsp;    public static final long ETYPE_BIPED_MECH = 1L &lt;&lt; 1;
&nbsp;    public static final long ETYPE_LAND_AIR_MECH = 1L &lt;&lt; 2;
&nbsp;    public static final long ETYPE_QUAD_MECH = 1L &lt;&lt; 3;
&nbsp;    public static final long ETYPE_ARMLESS_MECH = 1L &lt;&lt; 4;
&nbsp;
&nbsp;    public static final long ETYPE_AERO = 1L &lt;&lt; 5;
&nbsp;
&nbsp;    public static final long ETYPE_JUMPSHIP = 1L &lt;&lt; 6;
&nbsp;    public static final long ETYPE_WARSHIP = 1L &lt;&lt; 7;
&nbsp;    public static final long ETYPE_SPACE_STATION = 1L &lt;&lt; 8;
&nbsp;
&nbsp;    public static final long ETYPE_CONV_FIGHTER = 1L &lt;&lt; 9;
&nbsp;    public static final long ETYPE_FIXED_WING_SUPPORT = 1L &lt;&lt; 10;
&nbsp;
&nbsp;    public static final long ETYPE_FIGHTER_SQUADRON = 1L &lt;&lt; 11;
&nbsp;
&nbsp;    public static final long ETYPE_SMALL_CRAFT = 1L &lt;&lt; 12;
&nbsp;    public static final long ETYPE_DROPSHIP = 1L &lt;&lt; 13;
&nbsp;
&nbsp;    public static final long ETYPE_TELEMISSILE = 1L &lt;&lt; 14;
&nbsp;
&nbsp;    public static final long ETYPE_INFANTRY = 1L &lt;&lt; 15;
&nbsp;    public static final long ETYPE_BATTLEARMOR = 1L &lt;&lt; 16;
&nbsp;    public static final long ETYPE_MECHWARRIOR = 1L &lt;&lt; 17;
&nbsp;
&nbsp;    public static final long ETYPE_PROTOMECH = 1L &lt;&lt; 18;
&nbsp;
&nbsp;    public static final long ETYPE_TANK = 1L &lt;&lt; 19;
&nbsp;
&nbsp;    public static final long ETYPE_GUN_EMPLACEMENT = 1L &lt;&lt; 20;
&nbsp;
&nbsp;    public static final long ETYPE_SUPER_HEAVY_TANK = 1L &lt;&lt; 21;
&nbsp;
&nbsp;    public static final long ETYPE_SUPPORT_TANK = 1L &lt;&lt; 22;
&nbsp;    public static final long ETYPE_LARGE_SUPPORT_TANK = 1L &lt;&lt; 23;
&nbsp;
&nbsp;    public static final long ETYPE_VTOL = 1L &lt;&lt; 24;
&nbsp;    public static final long ETYPE_SUPPORT_VTOL = 1L &lt;&lt; 25;
&nbsp;
&nbsp;    public static final long ETYPE_TRIPOD_MECH = 1L &lt;&lt; 26;
&nbsp;    public static final long ETYPE_QUADVEE = 1L &lt;&lt; 27;
&nbsp;
&nbsp;    public static final int NONE = -1;
&nbsp;
&nbsp;    public static final int LOC_NONE = -1;
&nbsp;    public static final int LOC_DESTROYED = -2;
&nbsp;
&nbsp;    public static final int MAX_C3_NODES = 12;
&nbsp;    public static final int MAX_C3i_NODES = 6;
&nbsp;
&nbsp;    public static final int GRAPPLE_BOTH = 0;
&nbsp;    public static final int GRAPPLE_RIGHT = 1;
&nbsp;    public static final int GRAPPLE_LEFT = 2;
&nbsp;
&nbsp;    public static final int DMG_NONE = 0;
&nbsp;    public static final int DMG_LIGHT = 1;
&nbsp;    public static final int DMG_MODERATE = 2;
&nbsp;    public static final int DMG_HEAVY = 3;
&nbsp;    public static final int DMG_CRIPPLED = 4;
&nbsp;
&nbsp;    public static final int USE_STRUCTURAL_RATING = -1;
&nbsp;
<b class="fc">&nbsp;    public static final String ENTITY_AIR_TO_GROUND_SENSOR_RANGE= Messages.getString(&quot;Entity.sensor_range_vs_ground_target&quot;);</b>
&nbsp;
&nbsp;    // Weapon sort order defines
<b class="fc">&nbsp;    public static enum WeaponSortOrder {</b>
<b class="fc">&nbsp;        DEFAULT(&quot;DEFAULT&quot;),</b>
<b class="fc">&nbsp;        RANGE_LH(&quot;RANGE_LH&quot;),</b>
<b class="fc">&nbsp;        RANGE_HL(&quot;RANGE_HL&quot;),</b>
<b class="fc">&nbsp;        DAMAGE_LH(&quot;DAMAGE_LH&quot;),</b>
<b class="fc">&nbsp;        DAMAGE_HL(&quot;DAMAGE_HL&quot;),</b>
<b class="fc">&nbsp;        ARC(&quot;ARC&quot;),</b>
<b class="fc">&nbsp;        CUSTOM(&quot;CUSTOM&quot;);</b>
&nbsp;
&nbsp;        public final String i18nEntry;
&nbsp;
<b class="fc">&nbsp;        WeaponSortOrder(String s) {</b>
<b class="fc">&nbsp;            i18nEntry = s;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    protected transient IGame game;
&nbsp;
<b class="fc">&nbsp;    protected int id = Entity.NONE;</b>
&nbsp;
<b class="fc">&nbsp;    protected Camouflage camouflage = new Camouflage();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * ID settable by external sources (such as mm.net)
&nbsp;     */
<b class="fc">&nbsp;    protected String externalId = &quot;-1&quot;;</b>
&nbsp;
&nbsp;    protected double weight;
<b class="fc">&nbsp;    protected boolean omni = false;</b>
&nbsp;    protected String chassis;
&nbsp;    protected String model;
<b class="fc">&nbsp;    protected int year = 3071;</b>
&nbsp;    protected int techLevel;
&nbsp;    private CompositeTechLevel compositeTechLevel;
&nbsp;    /**
&nbsp;     * Used by support vehicles to define the structural tech rating
&nbsp;     * (TM pg 117).  The values should come from EquipmentType.RATING_A-X.
&nbsp;     */
<b class="fc">&nbsp;    protected int structuralTechRating =  EquipmentType.RATING_A;</b>
&nbsp;    /**
&nbsp;     * Used by support vehicles to define tech rating of armor.  Default value
&nbsp;     * indicates that structural tech rating should be used, as in most cases
&nbsp;     * the armor and structural tech ratings match.
&nbsp;     */
<b class="fc">&nbsp;    protected int armorTechRating = USE_STRUCTURAL_RATING;</b>
&nbsp;    /**
&nbsp;     * Used by support vehicles to define tech rating of armor.  Default value
&nbsp;     * indicates that structural tech rating should be used, as in most cases
&nbsp;     * the engine and structural tech ratings match.
&nbsp;     */
<b class="fc">&nbsp;    protected int engineTechRating = USE_STRUCTURAL_RATING;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used by omni support vehicles to track the weight of optional fire control systems.
&nbsp;     */
<b class="fc">&nbsp;    private double baseChassisFireConWeight = 0.0;</b>
&nbsp;    /**
&nbsp;     * Year to use calculating engine and control system weight and fuel efficiency for primitive
&nbsp;     * support vehicles and aerospace units. This needs to be tracked separately from intro year to
&nbsp;     * account for refits that change the intro year but don&#39;t affect the structural components
&nbsp;     */
<b class="fc">&nbsp;    private int originalBuildYear = -1;</b>
&nbsp;
&nbsp;    private Engine engine;
<b class="fc">&nbsp;    protected boolean mixedTech = false;</b>
<b class="fc">&nbsp;    protected boolean designValid = true;</b>
<b class="fc">&nbsp;    protected boolean useManualBV = false;</b>
<b class="fc">&nbsp;    protected int manualBV = -1;</b>
&nbsp;
<b class="fc">&nbsp;    protected int initialBV = -1;</b>
&nbsp;
<b class="fc">&nbsp;    protected String displayName = null;</b>
<b class="fc">&nbsp;    protected String shortName = null;</b>
<b class="fc">&nbsp;    public int duplicateMarker = 1;</b>
&nbsp;
&nbsp;    protected transient IPlayer owner;
&nbsp;    protected int ownerId;
<b class="fc">&nbsp;    protected int traitorId = -1;</b>
&nbsp;
<b class="fc">&nbsp;    protected int targetBay = -1;</b>
&nbsp;
<b class="fc">&nbsp;    private int startingPos = Board.START_NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The pilot of the entity. Even infantry has a &#39;pilot&#39;.
&nbsp;     */
&nbsp;    private Crew crew;
&nbsp;    
&nbsp;    // Crew and passenger numbers
&nbsp;    protected int nCrew;
&nbsp;    protected int nPassenger;
&nbsp;    protected int nMarines;
&nbsp;
<b class="fc">&nbsp;    private Quirks quirks = new Quirks();</b>
<b class="fc">&nbsp;    private PartialRepairs partReps = new PartialRepairs();</b>
&nbsp;
&nbsp;    // Variable for manually shutdown mechs.
<b class="fc">&nbsp;    protected boolean manualShutdown = false;</b>
<b class="fc">&nbsp;    protected boolean startupThisPhase = false;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean shutDown = false;</b>
<b class="fc">&nbsp;    protected boolean shutDownThisPhase = false;</b>
<b class="fc">&nbsp;    protected boolean doomed = false;</b>
<b class="fc">&nbsp;    protected boolean destroyed = false;</b>
&nbsp;
<b class="fc">&nbsp;    private Coords position = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used for Entities that are bigger than a single hex. This contains the
&nbsp;     * central hex plus all of the other hexes this entity occupies. The central
&nbsp;     * hex is important for drawing multi-hex sprites.
&nbsp;     */
<b class="fc">&nbsp;    protected Map&lt;Integer, Coords&gt; secondaryPositions = null;</b>
&nbsp;
<b class="fc">&nbsp;    protected int facing = 0;</b>
<b class="fc">&nbsp;    protected int sec_facing = 0;</b>
&nbsp;
<b class="fc">&nbsp;    protected int walkMP = 0;</b>
<b class="fc">&nbsp;    protected int jumpMP = 0;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean done = false;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean prone = false;</b>
<b class="fc">&nbsp;    protected boolean hullDown = false;</b>
<b class="fc">&nbsp;    protected boolean findingClub = false;</b>
<b class="fc">&nbsp;    protected boolean armsFlipped = false;</b>
<b class="fc">&nbsp;    protected boolean unjammingRAC = false;</b>
<b class="fc">&nbsp;    protected boolean selfDestructing = false;</b>
<b class="fc">&nbsp;    protected boolean selfDestructInitiated = false;</b>
<b class="fc">&nbsp;    protected boolean selfDestructedThisTurn = false;</b>
&nbsp;    /**
&nbsp;     * Variable to store the state of a possible externally mounted searchlight.
&nbsp;     * True if an operable searchlight is externally mounted, false if one isn&#39;t
&nbsp;     * mounted or if it is destroyed. Other searchlights may be mounted as
&nbsp;     * equipment on the entity.
&nbsp;     */
<b class="fc">&nbsp;    protected boolean hasExternalSpotlight = false;</b>
<b class="fc">&nbsp;    protected boolean illuminated = false;</b>
<b class="fc">&nbsp;    protected boolean spotlightIsActive = false;</b>
<b class="fc">&nbsp;    protected boolean usedSearchlight = false;</b>
<b class="fc">&nbsp;    protected boolean stuckInSwamp = false;</b>
<b class="fc">&nbsp;    protected boolean canUnstickByJumping = false;</b>
<b class="fc">&nbsp;    protected int taggedBy = -1;</b>
<b class="fc">&nbsp;    protected boolean layingMines = false;</b>
<b class="fc">&nbsp;    protected boolean _isEMId = false;</b>
&nbsp;    protected boolean[] hardenedArmorDamaged;
&nbsp;    protected boolean[] locationBlownOff;
&nbsp;    protected boolean[] locationBlownOffThisPhase;
&nbsp;    protected int[] armorType;
&nbsp;    protected int[] armorTechLevel;
<b class="fc">&nbsp;    protected boolean isJumpingNow = false;</b>
<b class="fc">&nbsp;    protected boolean convertingNow = false;</b>
<b class="fc">&nbsp;    private int conversionMode = 0;</b>
&nbsp;    protected EntityMovementMode previousMovementMode;
&nbsp;
<b class="fc">&nbsp;    protected DisplacementAttackAction displacementAttack = null;</b>
&nbsp;
<b class="fc">&nbsp;    public int heat = 0;</b>
<b class="fc">&nbsp;    public int heatBuildup = 0;</b>
<b class="fc">&nbsp;    public int heatFromExternal = 0;</b>
<b class="fc">&nbsp;    public int coolFromExternal = 0;</b>
<b class="fc">&nbsp;    public int delta_distance = 0;</b>
<b class="fc">&nbsp;    public int mpUsed = 0;</b>
<b class="fc">&nbsp;    public EntityMovementType moved = EntityMovementType.MOVE_NONE;</b>
<b class="fc">&nbsp;    public EntityMovementType movedLastRound = EntityMovementType.MOVE_NONE;</b>
<b class="fc">&nbsp;    private boolean movedBackwards = false;</b>
&nbsp;    /**
&nbsp;     * Used to keep track of usage of the power reverse quirk, which allows a
&nbsp;     * combat vehicle to use flank MP in reverse.  If power reverse is used and
&nbsp;     * a PSR is required, it adds a +1 modifier to the PSR.
&nbsp;     */
<b class="fc">&nbsp;    private boolean isPowerReverse = false;</b>
<b class="fc">&nbsp;    private boolean wigeLiftoffHover = false;</b>
<b class="fc">&nbsp;    protected int mpUsedLastRound = 0;</b>
<b class="fc">&nbsp;    public boolean gotPavementBonus = false;</b>
<b class="fc">&nbsp;    public int wigeBonus = 0;</b>
<b class="fc">&nbsp;    public boolean hitThisRoundByAntiTSM = false;</b>
<b class="fc">&nbsp;    public boolean inReverse = false;</b>
<b class="fc">&nbsp;    protected boolean struck = false;</b>
<b class="fc">&nbsp;    protected boolean fell = false;</b>
&nbsp;
&nbsp;    private int[] exposure;
&nbsp;    private int[] armor;
&nbsp;    private int[] internal;
&nbsp;    private int[] orig_armor;
&nbsp;    private int[] orig_internal;
&nbsp;    public int damageThisPhase;
&nbsp;    public int damageThisRound;
&nbsp;    public int engineHitsThisPhase;
<b class="fc">&nbsp;    public boolean rolledForEngineExplosion = false; // So that we don&#39;t roll</b>
&nbsp;    // twice in one round
&nbsp;    public boolean dodging;
&nbsp;    public boolean reckless;
<b class="fc">&nbsp;    private boolean evading = false;</b>
&nbsp;
&nbsp;    public boolean spotting;
<b class="fc">&nbsp;    private boolean clearingMinefield = false;</b>
<b class="fc">&nbsp;    protected int killerId = Entity.NONE;</b>
<b class="fc">&nbsp;    private int offBoardDistance = 0;</b>
<b class="fc">&nbsp;    private OffBoardDirection offBoardDirection = OffBoardDirection.NONE;</b>
<b class="fc">&nbsp;    private OffBoardDirection retreatedDirection = OffBoardDirection.NONE;</b>
&nbsp;
<b class="fc">&nbsp;    protected int[] vectors = {0, 0, 0, 0, 0, 0};</b>
<b class="fc">&nbsp;    private int recoveryTurn = 0;</b>
&nbsp;    // need to keep a list of areas that this entity has passed through on the
&nbsp;    // current turn
<b class="fc">&nbsp;    private Vector&lt;Coords&gt; passedThrough = new Vector&lt;Coords&gt;();</b>
<b class="fc">&nbsp;    private List&lt;Integer&gt; passedThroughFacing = new ArrayList&lt;&gt;();</b>
&nbsp;    /**
&nbsp;     * Stores the player selected hex ground to air targeting.
&nbsp;     * For ground to air, distance to target for the ground unit is determined
&nbsp;     * by the closest hex in the flight path of the airborne unit.  It&#39;s
&nbsp;     * possible that there are multiple equidistance hexes in the flight path
&nbsp;     * and in some cases, one of those hexes will be better than the other (ie,
&nbsp;     * one could be side arc and one rear).  By default, MM picks the first hex,
&nbsp;     * but the user should be able to distinguish between multiple equi-distant
&nbsp;     * hexes.
&nbsp;     */
<b class="fc">&nbsp;    private Map&lt;Integer, Coords&gt; playerPickedPassThrough = new HashMap&lt;&gt;();</b>
&nbsp;    private boolean ramming;
&nbsp;    // to determine what arcs have fired for large craft
&nbsp;    private boolean[] frontArcFired;
&nbsp;    private boolean[] rearArcFired;
&nbsp;
&nbsp;    /**
&nbsp;     * The object that tracks this unit&#39;s Inferno round hits.
&nbsp;     */
<b class="fc">&nbsp;    public InfernoTracker infernos = new InfernoTracker();</b>
<b class="fc">&nbsp;    public ArtilleryTracker aTracker = new ArtilleryTracker();</b>
<b class="fc">&nbsp;    public TeleMissileTracker tmTracker = new TeleMissileTracker();</b>
&nbsp;
<b class="fc">&nbsp;    protected String c3NetIdString = null;</b>
<b class="fc">&nbsp;    protected int c3Master = NONE;</b>
<b class="fc">&nbsp;    protected int c3CompanyMasterIndex = LOC_DESTROYED;</b>
<b class="fc">&nbsp;    private String c3UUID = null;</b>
<b class="fc">&nbsp;    private String c3MasterIsUUID = null;</b>
<b class="fc">&nbsp;    private String[] c3iUUIDs = new String[MAX_C3i_NODES];</b>
<b class="fc">&nbsp;    private String[] NC3UUIDs = new String[MAX_C3i_NODES];</b>
<b class="fc">&nbsp;    private boolean networkBAP = false;</b>
&nbsp;
<b class="fc">&nbsp;    protected int structureType = EquipmentType.T_STRUCTURE_UNKNOWN;</b>
<b class="fc">&nbsp;    protected int structureTechLevel = TechConstants.T_TECH_UNKNOWN;</b>
&nbsp;
<b class="fc">&nbsp;    protected String source = &quot;&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether this Entity was hit by a TSEMP this turn.
&nbsp;     */
<b class="fc">&nbsp;    private int tsempHitsThisTurn = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the current TSEMP effect on this entity
&nbsp;     */
<b class="fc">&nbsp;    private int tsempEffect = TSEMPWeapon.TSEMP_EFFECT_NONE;</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the current ASEW effect on this entity
&nbsp;     */
<b class="fc">&nbsp;    protected int asewAffectedTurns = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether this Entity fired a TSEMP this turn
&nbsp;     */
<b class="fc">&nbsp;    private boolean firedTsempThisTurn = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether this Entity has ever fired a TSEMP.  This is used
&nbsp;     * to avoid having to iterate over all weapons looking for TSEMPs to reset
&nbsp;     * at the start of every round.
&nbsp;     */
<b class="fc">&nbsp;    private boolean hasFiredTsemp = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all mounted equipment. (Weapons, ammo, and misc)
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; equipmentList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all mounted weapons. This only includes regular weapons, not
&nbsp;     * bay mounts or grouped weapon mounts.
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; weaponList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all mounted weapon bays
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; weaponBayList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all mounted weapon groups
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; weaponGroupList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of every weapon mount, including bay mounts and weapon group
&nbsp;     * mounts
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; totalWeaponList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all mounted ammo.
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; ammoList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all mounted bombs.
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; bombList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all remaining equipment.
&nbsp;     */
<b class="fc">&nbsp;    protected ArrayList&lt;Mounted&gt; miscList = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    protected ArrayList&lt;INarcPod&gt; pendingINarcPods = new ArrayList&lt;INarcPod&gt;();</b>
<b class="fc">&nbsp;    protected ArrayList&lt;INarcPod&gt; iNarcPods = new ArrayList&lt;INarcPod&gt;();</b>
<b class="fc">&nbsp;    protected ArrayList&lt;NarcPod&gt; pendingNarcPods = new ArrayList&lt;NarcPod&gt;();</b>
<b class="fc">&nbsp;    protected ArrayList&lt;NarcPod&gt; narcPods = new ArrayList&lt;NarcPod&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    protected ArrayList&lt;String&gt; failedEquipmentList = new ArrayList&lt;String&gt;();</b>
&nbsp;
&nbsp;    // which teams have NARCd us? a long allows for 64 teams.
<b class="fc">&nbsp;    protected long m_lNarcedBy = 0;</b>
<b class="fc">&nbsp;    protected long m_lPendingNarc = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This matrix stores critical slots in the format [location][slot #]. What
&nbsp;     * locations entities have and how many slots there are in each is
&nbsp;     * determined by the subclasses of Entity such as Mech.
&nbsp;     */
&nbsp;    protected CriticalSlot[][] crits; // [loc][slot]
&nbsp;
&nbsp;    /**
&nbsp;     * Stores the current movement mode.
&nbsp;     */
<b class="fc">&nbsp;    protected EntityMovementMode movementMode = EntityMovementMode.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that determines if this Entity is a hidden unit or not (see TW pg
&nbsp;     * 259).
&nbsp;     */
<b class="fc">&nbsp;    protected boolean isHidden = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine if this Entity has made a pointblank shot so far this
&nbsp;     * round.
&nbsp;     */
<b class="fc">&nbsp;    protected boolean madePointblankShot = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether this Entity should activate in a particular game
&nbsp;     * phase.  Generally this will be null, indicating the unit isn&#39;t
&nbsp;     * activating.
&nbsp;     */
<b class="fc">&nbsp;    protected IGame.Phase hiddenActivationPhase = null;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean carcass = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The components of this entity that can transport other entities.
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Transporter&gt; transports = new Vector&lt;Transporter&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The components of this entity that can transport other entities and occupy
&nbsp;     * pod space of an omni unit.
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Transporter&gt; omniPodTransports = new Vector&lt;Transporter&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The ids of the MechWarriors this entity has picked up
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Integer&gt; pickedUpMechWarriors = new Vector&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The ID of the &lt;code&gt;Entity&lt;/code&gt; that has loaded this unit.
&nbsp;     */
<b class="fc">&nbsp;    private int conveyance = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set to &lt;code&gt;true&lt;/code&gt; if this unit was unloaded this turn.
&nbsp;     */
<b class="fc">&nbsp;    private boolean unloadedThisTurn = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set to &lt;code&gt;true&lt;/code&gt; if this unit was loaded this turn.
&nbsp;     */
<b class="fc">&nbsp;    private boolean loadedThisTurn = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Need to keep a vector of entity IDs loaded in the chat lounge
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Integer&gt; loadedKeepers = new Vector&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The id of the &lt;code&gt;Entity&lt;/code&gt; that is the current target of a swarm
&nbsp;     * attack by this unit.
&nbsp;     */
<b class="fc">&nbsp;    private int swarmTargetId = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The id of the &lt;code&gt;Entity&lt;/code&gt; that is attacking this unit with a
&nbsp;     * swarm attack.
&nbsp;     */
<b class="fc">&nbsp;    private int swarmAttackerId = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that indicates that the unit can still be salvaged (given enough
&nbsp;     * time and parts).
&nbsp;     */
<b class="fc">&nbsp;    private boolean salvageable = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The removal condition is set when the entitiy is removed from the game.
&nbsp;     */
<b class="fc">&nbsp;    private int removalCondition = IEntityRemovalConditions.REMOVE_UNKNOWN;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The round this unit will be deployed
&nbsp;     */
<b class="fc">&nbsp;    private int deployRound = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Marks an entity as having been deployed
&nbsp;     */
<b class="fc">&nbsp;    private boolean deployed = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tracks if this entity was never deployed
&nbsp;     */
<b class="fc">&nbsp;    private boolean neverDeployed = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The unit number of this entity. All entities which are members of the
&nbsp;     * same low-level unit are expected to share the same unit number. Future
&nbsp;     * implementations may store multiple unit designations in the same unit
&nbsp;     * number (e.g. battalion, company, platoon, and lance).
&nbsp;     */
<b class="fc">&nbsp;    private short unitNumber = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates whether this entity has been seen by the enemy during the
&nbsp;     * course of this game. Used in double-blind.
&nbsp;     */
<b class="fc">&nbsp;    private boolean everSeenByEnemy = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates whether this entity can currently be seen by the enemy. Used in
&nbsp;     * double-blind.
&nbsp;     */
<b class="fc">&nbsp;    private boolean visibleToEnemy = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that indicates whether this entity has been detected by sensors by
&nbsp;     * an enemy.
&nbsp;     */
&nbsp;    private boolean detectedByEnemy;
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see who has seen this Entity Used for Double Blind Reports.
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;IPlayer&gt; entitySeenBy = new Vector&lt;IPlayer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see what players have detected this entity with sensors, for
&nbsp;     * double blind play.
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;IPlayer&gt; entityDetectedBy = new Vector&lt;IPlayer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Contains the ids of all entities that have been detected by this entity&#39;s sensors.
&nbsp;     * Used for double-blind on space maps - SO p117
&nbsp;     *
&nbsp;     * Entities need only be cleared from this when they move out of range,
&nbsp;     * are destroyed, or move off the board
&nbsp;     */
<b class="fc">&nbsp;    public Set&lt;Integer&gt; sensorContacts = new HashSet&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Contains the ids of all entities that this entity has established a firing solution on.
&nbsp;     * Used for double-blind on space maps - SO p117
&nbsp;     *
&nbsp;     * Entities need only be cleared from this when they move out of range,
&nbsp;     * are destroyed, or move off the board
&nbsp;     */
<b class="fc">&nbsp;    public Set&lt;Integer&gt; firingSolutions = new HashSet&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Whether this entity is captured or not.
&nbsp;     */
<b class="fc">&nbsp;    private boolean captured = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * this is the elevation of the Entity--with respect to the surface of the
&nbsp;     * hex it&#39;s in. In other words, this may need to *change* as it moves from
&nbsp;     * hex to hex--without it going up or down. I.e.--level 0 hex, elevation
&nbsp;     * 5--it moves to a level 2 hex, without going up or down. elevation is now
&nbsp;     * 3.
&nbsp;     */
<b class="fc">&nbsp;    protected int elevation = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * altitude is different from elevation. It is used to measure the vertical
&nbsp;     * distance of Aero units from the ground on low atmosphere and ground maps.
&nbsp;     */
<b class="fc">&nbsp;    protected int altitude = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * 2 vectors holding entity and weapon ids. to see who hit us this round
&nbsp;     * with a swarm volley from what launcher. This vector holds the Entity ids.
&nbsp;     *
&nbsp;     * @see megamek.common.Entity#hitBySwarmsWeapon
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Integer&gt; hitBySwarmsEntity = new Vector&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A vector that stores from which launcher we where hit by a swarm weapon
&nbsp;     * this round. This vector holds the weapon ID&#39;s.
&nbsp;     *
&nbsp;     * @see megamek.common.Entity#hitBySwarmsEntity
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Integer&gt; hitBySwarmsWeapon = new Vector&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * True if and only if this is a canon (published) unit.
&nbsp;     */
&nbsp;    private boolean canon;
&nbsp;
<b class="fc">&nbsp;    private int assaultDropInProgress = 0;</b>
<b class="fc">&nbsp;    private boolean climbMode = GUIPreferences.getInstance()</b>
<b class="fc">&nbsp;            .getBoolean(GUIPreferences.ADVANCED_MOVE_DEFAULT_CLIMB_MODE);</b>
&nbsp;
<b class="fc">&nbsp;    protected int lastTarget = Entity.NONE;</b>
<b class="fc">&nbsp;    protected String lastTargetDisplayName = &quot;&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * the entity id of our current spot-target
&nbsp;     */
<b class="fc">&nbsp;    private int spotTargetId = Entity.NONE;</b>
&nbsp;
<b class="fc">&nbsp;    private boolean isCommander = false;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean isCarefulStanding = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * a vector of currently active sensors that might be able to check range
&nbsp;     */
<b class="fc">&nbsp;    private Vector&lt;Sensor&gt; sensors = new Vector&lt;Sensor&gt;();</b>
&nbsp;    // the currently selected sensor
&nbsp;    private Sensor activeSensor;
&nbsp;    // the sensor chosen for next turn
&nbsp;    private Sensor nextSensor;
&nbsp;    // roll for sensor check
&nbsp;    private int sensorCheck;
&nbsp;
&nbsp;    // the roll for ghost targets
&nbsp;    private int ghostTargetRoll;
&nbsp;    // the roll to override ghost targets
&nbsp;    private int ghostTargetOverride;
&nbsp;
&nbsp;    // Tac Ops HeatSink Coolant Failure number
&nbsp;    protected int heatSinkCoolantFailureFactor;
&nbsp;
&nbsp;    // for how many rounds should this unit stay shutdown due to tasering
<b class="fc">&nbsp;    protected int taserShutdownRounds = 0;</b>
&nbsp;
&nbsp;    // is this unit shutdown by a BA taser?
<b class="fc">&nbsp;    protected boolean shutdownByBATaser = false;</b>
&nbsp;
&nbsp;    // for how many more rounds does this unit suffer from taser feedback?
<b class="fc">&nbsp;    protected int taserFeedBackRounds = 0;</b>
&nbsp;
<b class="fc">&nbsp;    protected int taserInterference = 0;</b>
<b class="fc">&nbsp;    protected int taserInterferenceRounds = 0;</b>
<b class="fc">&nbsp;    protected boolean taserInterferenceHeat = false;</b>
&nbsp;
&nbsp;    // contains a HTML string describing BV calculation
<b class="fc">&nbsp;    protected StringBuffer bvText = null;</b>
<b class="fc">&nbsp;    protected String startTable = &quot;&lt;TABLE&gt;&quot;;</b>
<b class="fc">&nbsp;    protected String endTable = &quot;&lt;/TABLE&gt;&quot;;</b>
&nbsp;
<b class="fc">&nbsp;    protected String startRow = &quot;&lt;TR&gt;&quot;;</b>
<b class="fc">&nbsp;    protected String endRow = &quot;&lt;/TR&gt;&quot;;</b>
&nbsp;
<b class="fc">&nbsp;    protected String startColumn = &quot;&lt;TD&gt;&quot;;</b>
<b class="fc">&nbsp;    protected String endColumn = &quot;&lt;/TD&gt;&quot;;</b>
&nbsp;
<b class="fc">&nbsp;    protected String nl = &quot;&lt;BR&gt;&quot;;</b>
&nbsp;
&nbsp;    // for how many rounds has blueshield been active?
<b class="fc">&nbsp;    private int blueShieldRounds = 0;</b>
&nbsp;
&nbsp;    // Entity fluff object for use with MegaMekLab
&nbsp;    protected EntityFluff fluff;
&nbsp;
&nbsp;    // a settable armor tonnage for use with MML - this is not what
&nbsp;    // is calculated by getArmorTonnage
&nbsp;    protected double armorTonnage;
&nbsp;
<b class="fc">&nbsp;    protected static int[] MASC_FAILURE = {3, 5, 7, 11, 13, 13, 13};</b>
<b class="fc">&nbsp;    protected static int[] ALTERNATE_MASC_FAILURE = {0, 3, 5, 7, 11, 13, 13,</b>
&nbsp;                                                     13};
<b class="fc">&nbsp;    protected static int[] ALTERNATE_MASC_FAILURE_ENHANCED = {0, 3, 3, 5, 7,</b>
&nbsp;                                                              11, 13, 13, 13};
&nbsp;
&nbsp;    // MASCLevel is the # of turns MASC has been used previously
<b class="fc">&nbsp;    protected int nMASCLevel = 0;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean bMASCWentUp = false;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean usedMASC = false; // Has masc been used?</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Nova CEWS can adjust the network on the fly. This keeps track of the C3
&nbsp;     * net ID to be switched to on the next turn.
&nbsp;     */
<b class="fc">&nbsp;    private String newC3NetIdString = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the number of iATM improved magnetic pulse (IMP) his this
&nbsp;     * entity took this turn.
&nbsp;     */
<b class="fc">&nbsp;    private int impThisTurn = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the number of iATM improved magnetic pulse (IMP) his this
&nbsp;     * entity took last turn.
&nbsp;     */
<b class="fc">&nbsp;    private int impLastTurn = 0;</b>
&nbsp;
<b class="fc">&nbsp;    private int impThisTurnHeatHelp = 0;</b>
&nbsp;
&nbsp;    protected boolean military;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of whether or not this Entity has a critically hit radical
&nbsp;     * heat sink.  Using a flag will prevent having to iterate over all of the
&nbsp;     * Entity&#39;s mounted equipment
&nbsp;     */
<b class="fc">&nbsp;    protected boolean hasDamagedRHS = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the number of consecutive turns a radical heat sink has
&nbsp;     * been used.
&nbsp;     */
<b class="fc">&nbsp;    protected int consecutiveRHSUses = 0;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that can be used to indicate whether this Entity should use a
&nbsp;     * geometric mean when computing BV.
&nbsp;     */
<b class="fc">&nbsp;    protected boolean useGeometricBV = false;</b>
&nbsp;
<b class="fc">&nbsp;    protected boolean useReducedOverheatModifierBV = false;</b>
&nbsp;
<b class="fc">&nbsp;    private final Set&lt;Integer&gt; attackedByThisTurn =</b>
<b class="fc">&nbsp;            Collections.newSetFromMap(new ConcurrentHashMap&lt;Integer, Boolean&gt;());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the sort order for weapons in the UnitDisplay weapon list.
&nbsp;     */
&nbsp;    private WeaponSortOrder weaponSortOrder;
&nbsp;
&nbsp;    /**
&nbsp;     * Maps a weapon id to a user-specified index, used to get a custom ordering
&nbsp;     * for weapons.
&nbsp;     */
<b class="fc">&nbsp;    private Map&lt;Integer, Integer&gt; customWeapOrder = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that indicates weapon sort order has changed (included ordering for
&nbsp;     * custom sort order).
&nbsp;     */
<b class="fc">&nbsp;    private boolean weapOrderChanged = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set of team IDs that have observed this entity making attacks from off-board
&nbsp;     */
&nbsp;    private Set&lt;Integer&gt; offBoardShotObservers;
&nbsp;    
&nbsp;    /**
&nbsp;     * Generates a new, blank, entity.
&nbsp;     */
<b class="fc">&nbsp;    public Entity() {</b>
<b class="fc">&nbsp;        crew = new Crew(defaultCrewType());</b>
<b class="fc">&nbsp;        nCrew = 0;</b>
<b class="fc">&nbsp;        nPassenger = 0;</b>
<b class="fc">&nbsp;        nMarines = 0;</b>
<b class="fc">&nbsp;        armor = new int[locations()];</b>
<b class="fc">&nbsp;        internal = new int[locations()];</b>
<b class="fc">&nbsp;        orig_armor = new int[locations()];</b>
<b class="fc">&nbsp;        orig_internal = new int[locations()];</b>
<b class="fc">&nbsp;        crits = new CriticalSlot[locations()][];</b>
<b class="fc">&nbsp;        exposure = new int[locations()];</b>
<b class="fc">&nbsp;        armorType = new int[locations()];</b>
<b class="fc">&nbsp;        armorTechLevel = new int[locations()];</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;            crits[i] = new CriticalSlot[getNumberOfCriticals(i)];</b>
<b class="fc">&nbsp;            armorType[i] = EquipmentType.T_ARMOR_UNKNOWN;</b>
<b class="fc">&nbsp;            armorTechLevel[i] = TechConstants.T_TECH_UNKNOWN;</b>
&nbsp;        }
<b class="fc">&nbsp;        hardenedArmorDamaged = new boolean[locations()];</b>
<b class="fc">&nbsp;        locationBlownOff = new boolean[locations()];</b>
<b class="fc">&nbsp;        locationBlownOffThisPhase = new boolean[locations()];</b>
<b class="fc">&nbsp;        setC3NetId(this);</b>
<b class="fc">&nbsp;        quirks.initialize();</b>
<b class="fc">&nbsp;        secondaryPositions = new HashMap&lt;Integer, Coords&gt;();</b>
<b class="fc">&nbsp;        fluff = new EntityFluff();</b>
<b class="fc">&nbsp;        impThisTurn = 0;</b>
<b class="fc">&nbsp;        impLastTurn = 0;</b>
&nbsp;
<b class="fc">&nbsp;        weaponSortOrder = WeaponSortOrder.values()[GUIPreferences.getInstance()</b>
<b class="fc">&nbsp;                .getDefaultWeaponSortOrder()];</b>
&nbsp;
&nbsp;        //set a random UUID for external ID, this will help us sort enemy salvage and prisoners in MHQ
&nbsp;        //and should have no effect on MM (but need to make sure it doesnt screw up MekWars)
<b class="fc">&nbsp;        externalId = UUID.randomUUID().toString();</b>
<b class="fc">&nbsp;        initTechAdvancement();</b>
<b class="fc">&nbsp;        offBoardShotObservers = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @see {@link UnitType}
&nbsp;     */
&nbsp;    public abstract int getUnitType();
&nbsp;
&nbsp;    public CrewType defaultCrewType() {
<b class="fc">&nbsp;        return CrewType.SINGLE;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void initMilitary() {
<b class="fc">&nbsp;        military = hasViableWeapons();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected boolean hasViableWeapons() {
<b class="fc">&nbsp;        int totalDmg = 0;</b>
<b class="fc">&nbsp;        boolean hasRangeSixPlus = false;</b>
<b class="fc">&nbsp;        List&lt;Mounted&gt; weaponList = getTotalWeaponList();</b>
<b class="fc">&nbsp;        for (Mounted weapon : weaponList) {</b>
<b class="fc">&nbsp;            if (weapon.isCrippled()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="fc">&nbsp;            WeaponType type = (WeaponType) weapon.getType();</b>
<b class="fc">&nbsp;            if (type.getDamage() == WeaponType.DAMAGE_VARIABLE) {</b>
&nbsp;
<b class="fc">&nbsp;            } else if (type.getDamage() == WeaponType.DAMAGE_ARTILLERY) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (type.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</b>
<b class="fc">&nbsp;                totalDmg += type.getRackSize();</b>
<b class="fc">&nbsp;            } else if (type.getDamage() == WeaponType.DAMAGE_SPECIAL) {</b>
<b class="nc">&nbsp;                if (type instanceof ISBAPopUpMineLauncher) {</b>
<b class="nc">&nbsp;                    totalDmg += 4;</b>
&nbsp;                }
&nbsp;            } else {
<b class="fc">&nbsp;                totalDmg += type.getDamage();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (type.getLongRange() &gt;= 6) {</b>
<b class="fc">&nbsp;                hasRangeSixPlus = true;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return (totalDmg &gt;= 5) || hasRangeSixPlus;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Restores the entity after serialization
&nbsp;     */
&nbsp;    public void restore() {
&nbsp;        // restore all mounted equipments
<b class="fc">&nbsp;        for (Mounted mounted : equipmentList) {</b>
<b class="fc">&nbsp;            mounted.restore();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;        // set game options, we derive some equipment&#39;s modes from this
<b class="fc">&nbsp;        setGameOptions();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the ID number of this Entity.
&nbsp;     *
&nbsp;     * @return ID Number.
&nbsp;     */
&nbsp;    public int getId() {
<b class="fc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the ID number of this Entity, which will also set the display name
&nbsp;     * and short name to null.
&nbsp;     *
&nbsp;     * @param id the new ID.
&nbsp;     */
&nbsp;    public void setId(int id) {
<b class="nc">&nbsp;        this.id = id;</b>
<b class="nc">&nbsp;        displayName = null;</b>
<b class="nc">&nbsp;        shortName = null;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This returns the external ID.
&nbsp;     * &lt;p&gt;
&nbsp;     * Taharqa: I am changing
&nbsp;     * externalId to a string so I can use UUIDs in MHQ. It should only require
&nbsp;     * a simple parseInt to be added to it to return an integer for other
&nbsp;     * programs (i.e. MekWars).
&nbsp;     *
&nbsp;     * @return the ID settable by external sources (such as mm.net)
&nbsp;     * @throws NumberFormatException if the stored ID is not an integer
&nbsp;     * @see megamek.common.Entity#externalId
&nbsp;     */
&nbsp;    public int getExternalId() {
<b class="nc">&nbsp;        return Integer.parseInt(externalId);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getExternalIdAsString() {
<b class="nc">&nbsp;        return externalId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This sets the external ID.
&nbsp;     *
&nbsp;     * @param externalId the new external ID for this Entity.
&nbsp;     * @see megamek.common.Entity#externalId
&nbsp;     */
&nbsp;    public void setExternalIdAsString(String externalId) {
<b class="nc">&nbsp;        this.externalId = externalId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setExternalId(int id) {
<b class="nc">&nbsp;        externalId = Integer.toString(id);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This returns the game this Entity belongs to.
&nbsp;     *
&nbsp;     * @return the game.
&nbsp;     */
&nbsp;    public IGame getGame() {
<b class="nc">&nbsp;        return game;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This sets the game the entity belongs to. It also restores the entity and
&nbsp;     * checks that the game is in a consistent state. This function takes care
&nbsp;     * of the units transported by this entity.
&nbsp;     *
&nbsp;     * @param game the game.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setGame(IGame game) {
<b class="fc">&nbsp;        this.game = game;</b>
<b class="fc">&nbsp;        restore();</b>
&nbsp;        // Make sure the owner is set.
<b class="fc">&nbsp;        if (null == owner) {</b>
<b class="nc">&nbsp;            if (Entity.NONE == ownerId) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(</b>
&nbsp;                        &quot;Entity doesn&#39;t know its owner&#39;s ID.&quot;);
&nbsp;            }
<b class="nc">&nbsp;            IPlayer player = game.getPlayer(ownerId);</b>
<b class="nc">&nbsp;            if (null == player) {</b>
<b class="nc">&nbsp;                System.err.println(&quot;Entity can&#39;t find player #&quot; + ownerId);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                setOwner(player);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // also set game for our transports
&nbsp;        // they need it to return correct entites, because they store just the
&nbsp;        // IDs
<b class="fc">&nbsp;        for (Transporter transport : getTransports()) {</b>
<b class="nc">&nbsp;            transport.setGame(game);</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the unit code for this entity.
&nbsp;     */
&nbsp;    public String getModel() {
<b class="fc">&nbsp;        return model;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the unit code for this Entity.
&nbsp;     *
&nbsp;     * @param model The unit code.
&nbsp;     */
&nbsp;    public void setModel(String model) {
<b class="fc">&nbsp;        this.model = model;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the chassis name for this entity.
&nbsp;     */
&nbsp;    public String getChassis() {
<b class="fc">&nbsp;        return chassis;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * sets the chassis name for this entity.
&nbsp;     *
&nbsp;     * @param chassis The chassis name.
&nbsp;     */
&nbsp;    public void setChassis(String chassis) {
<b class="fc">&nbsp;        this.chassis = chassis;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the fluff for this entity.
&nbsp;     */
&nbsp;    public EntityFluff getFluff() {
<b class="fc">&nbsp;        return fluff;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the unit tech for this entity.
&nbsp;     */
&nbsp;    public int getTechLevel() {
<b class="fc">&nbsp;        return techLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tech level for this Entity.
&nbsp;     *
&nbsp;     * @param techLevel The tech level, it must be one of the
&nbsp;     *                  {@link megamek.common.TechConstants TechConstants }.
&nbsp;     */
&nbsp;    public void setTechLevel(int techLevel) {
<b class="fc">&nbsp;        this.techLevel = techLevel;</b>
<b class="fc">&nbsp;        recalculateTechAdvancement();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets initial TechAdvancement without equipment based on construction options.
&nbsp;     */
&nbsp;    protected void initTechAdvancement() {
<b class="fc">&nbsp;        compositeTechLevel = new CompositeTechLevel(this, F_NONE);</b>
<b class="fc">&nbsp;        addSystemTechAdvancement(compositeTechLevel);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public CompositeTechLevel factionTechLevel(int techFaction) {
<b class="nc">&nbsp;        if (techFaction == F_NONE) {</b>
<b class="nc">&nbsp;            return compositeTechLevel;</b>
&nbsp;        }
<b class="nc">&nbsp;        CompositeTechLevel retVal = new CompositeTechLevel(this, techFaction);</b>
<b class="nc">&nbsp;        addSystemTechAdvancement(retVal);</b>
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            retVal.addComponent(m.getType());</b>
<b class="nc">&nbsp;            if (m.isArmored()) {</b>
<b class="nc">&nbsp;                retVal.addComponent(TA_ARMORED_COMPONENT);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addTechComponent(ITechnology tech) {
<b class="nc">&nbsp;        compositeTechLevel.addComponent(tech);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isIntroLevel() {
<b class="nc">&nbsp;        return compositeTechLevel.isIntroLevel();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isUnofficial() {
<b class="nc">&nbsp;        return compositeTechLevel.isUnofficial();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getIntroductionDate() {
<b class="nc">&nbsp;        return year;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getIntroductionDate(boolean clan, int faction) {
<b class="nc">&nbsp;        return year;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The earliest date this unit could be built, based on the latest intro date
&nbsp;     *         of the components.
&nbsp;     */
&nbsp;    public int getEarliestTechDate() {
<b class="nc">&nbsp;        return compositeTechLevel.getEarliestTechDate();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getPrototypeDate() {
<b class="nc">&nbsp;        return compositeTechLevel.getPrototypeDate();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getPrototypeDate(boolean clan, int faction) {
<b class="nc">&nbsp;        return compositeTechLevel.getPrototypeDate(clan, faction);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getProductionDate() {
<b class="nc">&nbsp;        return compositeTechLevel.getProductionDate();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getProductionDate(boolean clan, int faction) {
<b class="nc">&nbsp;        return compositeTechLevel.getProductionDate(clan, faction);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCommonDate() {
<b class="nc">&nbsp;        return compositeTechLevel.getCommonDate();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getExtinctionDate() {
<b class="nc">&nbsp;        return compositeTechLevel.getExtinctionDate();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getExtinctionDate(boolean clan, int faction) {
<b class="nc">&nbsp;        return compositeTechLevel.getExtinctionDate(clan, faction);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getReintroductionDate() {
<b class="nc">&nbsp;        return compositeTechLevel.getReintroductionDate();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getReintroductionDate(boolean clan, int faction) {
<b class="nc">&nbsp;        return compositeTechLevel.getReintroductionDate(clan, faction);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    @Override
&nbsp;    public int getTechRating() {
<b class="nc">&nbsp;        return compositeTechLevel.getTechRating();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SimpleTechLevel getStaticTechLevel() {
<b class="nc">&nbsp;        return compositeTechLevel.getStaticTechLevel();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getBaseAvailability(int era) {
<b class="nc">&nbsp;        return compositeTechLevel.getBaseAvailability(era);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getExtinctionRange() {
<b class="nc">&nbsp;        return compositeTechLevel.getExtinctionRange();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return - the base construction option tech advancement
&nbsp;     */
&nbsp;    public abstract TechAdvancement getConstructionTechAdvancement();
&nbsp;
&nbsp;    /**
&nbsp;     * Resets techAdvancement to initial value and adjusts for all installed equipment.
&nbsp;     */
&nbsp;    public void recalculateTechAdvancement() {
<b class="fc">&nbsp;        initTechAdvancement();</b>
<b class="fc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="fc">&nbsp;            compositeTechLevel.addComponent(m.getType());</b>
<b class="fc">&nbsp;            if (m.isArmored()) {</b>
<b class="nc">&nbsp;                compositeTechLevel.addComponent(TA_ARMORED_COMPONENT);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    protected static final TechAdvancement TA_OMNI = new TechAdvancement(TECH_BASE_ALL)</b>
<b class="fc">&nbsp;            .setISAdvancement(DATE_NONE, DATE_NONE, 3052)</b>
<b class="fc">&nbsp;            .setClanAdvancement(2854, 2856, 2864).setClanApproximate(true)</b>
<b class="fc">&nbsp;            .setPrototypeFactions(F_CCY, F_CSF).setProductionFactions(F_CCY, F_DC)</b>
<b class="fc">&nbsp;            .setTechRating(RATING_E).setAvailability(RATING_X, RATING_E, RATING_E, RATING_D)</b>
<b class="fc">&nbsp;            .setStaticTechLevel(SimpleTechLevel.STANDARD);</b>
&nbsp;    // This is not in the rules anywhere, but is implied by the existence of the Badger and Bandit
&nbsp;    // tanks used by Wolf&#39;s Dragoons and sold to the merc market as early as 3008.
<b class="fc">&nbsp;    private static final TechAdvancement TA_OMNIVEHICLE = new TechAdvancement(TECH_BASE_ALL)</b>
<b class="fc">&nbsp;            .setISAdvancement(3008, DATE_NONE, 3052).setISApproximate(true)</b>
<b class="fc">&nbsp;            .setClanAdvancement(2854, 2856, 2864).setClanApproximate(true)</b>
<b class="fc">&nbsp;            .setPrototypeFactions(F_CCY, F_CSF, F_MERC).setProductionFactions(F_CCY, F_DC)</b>
<b class="fc">&nbsp;            .setTechRating(RATING_E).setAvailability(RATING_X, RATING_E, RATING_E, RATING_D)</b>
<b class="fc">&nbsp;            .setStaticTechLevel(SimpleTechLevel.STANDARD);</b>
<b class="fc">&nbsp;    protected static final TechAdvancement TA_PATCHWORK_ARMOR = new TechAdvancement(TECH_BASE_ALL)</b>
<b class="fc">&nbsp;            .setAdvancement(DATE_PS, 3075, 3080).setApproximate(false, false, true)</b>
<b class="fc">&nbsp;            .setTechRating(RATING_A)</b>
<b class="fc">&nbsp;            .setAvailability(RATING_E, RATING_D, RATING_E, RATING_E)</b>
<b class="fc">&nbsp;            .setStaticTechLevel(SimpleTechLevel.ADVANCED);</b>
<b class="fc">&nbsp;    protected static final TechAdvancement TA_MIXED_TECH = new TechAdvancement(TECH_BASE_ALL)</b>
<b class="fc">&nbsp;            .setISAdvancement(3050, 3082, 3115)</b>
<b class="fc">&nbsp;            .setClanAdvancement(2820, 3082, 3115).setApproximate(true, true, true)</b>
<b class="fc">&nbsp;            .setPrototypeFactions(F_CLAN, F_DC, F_FS, F_LC)</b>
<b class="fc">&nbsp;            .setTechRating(RATING_A).setAvailability(RATING_X, RATING_X, RATING_E, RATING_D)</b>
<b class="fc">&nbsp;            .setStaticTechLevel(SimpleTechLevel.ADVANCED);</b>
<b class="fc">&nbsp;    protected static final TechAdvancement TA_ARMORED_COMPONENT = new TechAdvancement(TECH_BASE_ALL)</b>
<b class="fc">&nbsp;            .setISAdvancement(3061, 3082).setClanAdvancement(3061, 3077)</b>
<b class="fc">&nbsp;            .setPrototypeFactions(F_CSF,F_FW).setProductionFactions(F_CJF,F_FW)</b>
<b class="fc">&nbsp;            .setTechRating(RATING_E).setAvailability(RATING_X, RATING_X, RATING_F, RATING_E)</b>
<b class="fc">&nbsp;            .setStaticTechLevel(SimpleTechLevel.EXPERIMENTAL);</b>
&nbsp;
&nbsp;    public static TechAdvancement getOmniAdvancement() {
<b class="nc">&nbsp;        return getOmniAdvancement(null);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public static TechAdvancement getOmniAdvancement(Entity en) {
<b class="nc">&nbsp;        if (en instanceof Tank) {</b>
<b class="nc">&nbsp;            return new TechAdvancement(TA_OMNIVEHICLE);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new TechAdvancement(TA_OMNI);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static TechAdvancement getPatchworkArmorAdvancement() {
<b class="nc">&nbsp;        return new TechAdvancement(TA_PATCHWORK_ARMOR);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static TechAdvancement getMixedTechAdvancement() {
<b class="nc">&nbsp;        return new TechAdvancement(TA_MIXED_TECH);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static TechAdvancement getArmoredComponentTechAdvancement() {
<b class="nc">&nbsp;        return new TechAdvancement(TA_ARMORED_COMPONENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Incorporate dates for components that are not in the equipment list, such as engines and structure.
&nbsp;     */
&nbsp;    protected void addSystemTechAdvancement(CompositeTechLevel ctl) {
<b class="fc">&nbsp;        if (hasEngine()) {</b>
<b class="fc">&nbsp;            ctl.addComponent(getEngine());</b>
&nbsp;        }
<b class="fc">&nbsp;        if (isOmni()) {</b>
<b class="nc">&nbsp;            ctl.addComponent(TA_OMNI);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (hasPatchworkArmor()) {</b>
<b class="nc">&nbsp;            ctl.addComponent(TA_PATCHWORK_ARMOR);</b>
<b class="nc">&nbsp;            for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;                ctl.addComponent(EquipmentType.getArmorTechAdvancement(armorType[loc],</b>
<b class="nc">&nbsp;                        TechConstants.isClan(armorTechLevel[loc])));</b>
&nbsp;            }
&nbsp;        } else {
<b class="fc">&nbsp;            ctl.addComponent(EquipmentType.getArmorTechAdvancement(armorType[0],</b>
<b class="fc">&nbsp;                    TechConstants.isClan(armorTechLevel[0])));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (isMixedTech()) {</b>
<b class="fc">&nbsp;            ctl.addComponent(TA_MIXED_TECH);</b>
&nbsp;        }
<b class="fc">&nbsp;        ctl.addComponent(EquipmentType.getStructureTechAdvancement(structureType,</b>
<b class="fc">&nbsp;                TechConstants.isClan(structureTechLevel)));</b>
&nbsp;        /* TM, p. 122 gives general eras for each tech rating, but not specific dates.
&nbsp;         * Besides that, there are many canon units with higher tech ratings than should
&nbsp;         * be possible in their era, so we&#39;re just going to add a stub to get the tech rating right
&nbsp;         * for cost purposes. */
<b class="fc">&nbsp;        if (isSupportVehicle()) {</b>
<b class="nc">&nbsp;            TechAdvancement blank = new TechAdvancement(getConstructionTechAdvancement());</b>
<b class="nc">&nbsp;            ctl.addComponent(blank.setTechRating(getEngineTechRating()));</b>
<b class="nc">&nbsp;            ctl.addComponent(blank.setTechRating(getStructuralTechRating()));</b>
<b class="nc">&nbsp;            if (!hasPatchworkArmor() &amp;&amp; (getArmorType(firstArmorIndex()) == EquipmentType.T_ARMOR_STANDARD)) {</b>
<b class="nc">&nbsp;                ctl.addComponent(blank.setTechRating(getArmorTechRating()));</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getRecoveryTurn() {
<b class="nc">&nbsp;        return recoveryTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setRecoveryTurn(int r) {
<b class="nc">&nbsp;        recoveryTurn = r;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isManualShutdown() {
<b class="nc">&nbsp;        return manualShutdown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setManualShutdown(boolean tf) {
<b class="nc">&nbsp;        manualShutdown = tf;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void performManualShutdown() {
<b class="nc">&nbsp;        if (isManualShutdown() || (getTaserShutdownRounds() != 0)</b>
<b class="nc">&nbsp;            || isShutDown()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        setShutDown(true);</b>
<b class="nc">&nbsp;        setManualShutdown(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void performManualStartup() {
<b class="nc">&nbsp;        if (!isManualShutdown()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        setManualShutdown(false);</b>
&nbsp;        // Can&#39;t startup if a taser shutdown or a TSEMP shutdown
<b class="nc">&nbsp;        if ((getTaserShutdownRounds() == 0)</b>
<b class="nc">&nbsp;            &amp;&amp; (getTsempEffect() != TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) {</b>
<b class="nc">&nbsp;            setShutDown(false);</b>
<b class="nc">&nbsp;            setStartupThisPhase(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this is a clan unit. It is determined by tech level.
&nbsp;     *
&nbsp;     * @return true if this unit is a clan unit.
&nbsp;     * @see megamek.common.Entity#setTechLevel(int)
&nbsp;     */
&nbsp;    public boolean isClan() {
<b class="fc">&nbsp;        return ((techLevel == TechConstants.T_CLAN_TW)</b>
&nbsp;                || (techLevel == TechConstants.T_CLAN_ADVANCED)
&nbsp;                || (techLevel == TechConstants.T_CLAN_EXPERIMENTAL) || (techLevel == TechConstants.T_CLAN_UNOFFICIAL));
&nbsp;    }
&nbsp;
&nbsp;    public boolean isClanArmor(int loc) {
&nbsp;        // if the location does not exist, it does not have clan armor
<b class="nc">&nbsp;        if (loc &gt;= locations()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (getArmorTechLevel(loc) == TechConstants.T_TECH_UNKNOWN) {</b>
<b class="nc">&nbsp;            return isClan();</b>
&nbsp;        }
<b class="nc">&nbsp;        return ((getArmorTechLevel(loc) == TechConstants.T_CLAN_TW)</b>
<b class="nc">&nbsp;                || (getArmorTechLevel(loc) == TechConstants.T_CLAN_ADVANCED)</b>
<b class="nc">&nbsp;                || (getArmorTechLevel(loc) == TechConstants.T_CLAN_EXPERIMENTAL) || (getArmorTechLevel(loc) ==</b>
&nbsp;                                                                                     TechConstants.T_CLAN_UNOFFICIAL));
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getTechBase() {
<b class="nc">&nbsp;        return isClan()? TECH_BASE_CLAN : TECH_BASE_IS;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isMixedTech() {
<b class="fc">&nbsp;        return mixedTech;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setMixedTech(boolean mixedTech) {
<b class="fc">&nbsp;        this.mixedTech = mixedTech;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isDesignValid() {
<b class="nc">&nbsp;        return designValid;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDesignValid(boolean designValid) {
<b class="nc">&nbsp;        this.designValid = designValid;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getYear() {
<b class="fc">&nbsp;        return year;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setYear(int year) {
<b class="fc">&nbsp;        this.year = year;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** @return the tonnage of the Entity, not its weight */
&nbsp;    public double getWeight() {
<b class="fc">&nbsp;        return weight;</b>
&nbsp;    }
&nbsp;
&nbsp;    // TODO: WeightClass is no longer correct. See the Tech Manual
&nbsp;    public int getWeightClass() {
<b class="fc">&nbsp;        return EntityWeightClass.getWeightClass(getWeight(), this);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getWeightClassName() {
<b class="nc">&nbsp;        return EntityWeightClass.getClassName(getWeightClass(), this);</b>
&nbsp;    }
&nbsp;
&nbsp;    //Since this varies by unit type, it will be defined as overrides in each relevant class
&nbsp;    public boolean isSuperHeavy() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWeight(double weight) {
<b class="fc">&nbsp;        this.weight = weight;</b>
&nbsp;        // Any time the weight is reset we need to reset the crew size
<b class="fc">&nbsp;        crew.setSize(Compute.getFullCrewSize(this));</b>
<b class="fc">&nbsp;        crew.setCurrentSize(crew.getSize());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isOmni() {
<b class="fc">&nbsp;        return omni;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOmni(boolean omni) {
<b class="fc">&nbsp;        this.omni = omni;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of locations in the entity
&nbsp;     */
&nbsp;    public abstract int locations();
&nbsp;
&nbsp;    /**
&nbsp;     * Determines where to place equipment that does not require a specific location. What
&nbsp;     * this means varies by {@link Entity} type.
&nbsp;     *
&nbsp;     * @return        The location to place equipment that is not required to be assigned a location,
&nbsp;     *                defaulting to Entity.LOC_NONE for unit types that do not have such a location.
&nbsp;     */
&nbsp;    public int getBodyLocation() {
<b class="nc">&nbsp;        return LOC_NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the player that &quot;owns&quot; this entity.
&nbsp;     */
&nbsp;    public IPlayer getOwner() {
<b class="fc">&nbsp;        return owner;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOwner(IPlayer player) {
<b class="fc">&nbsp;        owner = player;</b>
<b class="fc">&nbsp;        ownerId = player.getId();</b>
&nbsp;
<b class="fc">&nbsp;        generateDisplayName();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOwnerId() {
<b class="nc">&nbsp;        return ownerId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the other entity is an enemy of this entity. This is more
&nbsp;     * reliable than Player.isEnemyOf since it knows that an entity will never
&nbsp;     * be an enemy of itself.
&nbsp;     */
&nbsp;    public boolean isEnemyOf(Entity other) {
<b class="fc">&nbsp;        if(null == other) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if(null == owner) {</b>
<b class="fc">&nbsp;            return ((id != other.getId()) &amp;&amp; (ownerId != other.ownerId));</b>
&nbsp;        }
<b class="nc">&nbsp;        return (id != other.getId())</b>
<b class="nc">&nbsp;            &amp;&amp; ((null == other.getOwner()) || owner.isEnemyOf(other.getOwner()));</b>
&nbsp;    }
&nbsp;
&nbsp;    public Crew getCrew() {
<b class="nc">&nbsp;        return crew;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCrew(Crew crew) {
<b class="nc">&nbsp;        this.crew = crew;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * @return The total number of crew available to supplement marines on boarding actions.
&nbsp;     *         Includes officers, enlisted, and bay personnel, but not marines/ba or passengers.
&nbsp;     */
&nbsp;    public int getNCrew() {
<b class="nc">&nbsp;        return nCrew;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void setNCrew(int crew) {
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns the number of passengers on this unit
&nbsp;     * Intended for spacecraft, where we want to get the crews of transported units
&nbsp;     * plus actual passengers assigned to quarters
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getNPassenger() {
<b class="nc">&nbsp;        return nPassenger;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void setNPassenger(int pass) {
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * @return The number conventional marines available to vessels for boarding actions.
&nbsp;     */
&nbsp;    public int getNMarines() {
<b class="nc">&nbsp;        return nMarines;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Updates the number of marines aboard
&nbsp;     * @param marines The number of marines to add/subtract
&nbsp;     */
&nbsp;    public void setNMarines(int marines) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Units with a cockpit command console provide an initiative bonus to their side, provided
&nbsp;     * that the commander is not currently functioning as pilot, the unit has advanced fire control,
&nbsp;     * and the unit is heavy or assault weight class.
&nbsp;     *
&nbsp;     * @return Whether the Entity qualifies for initiative bonus from cockpit command console.
&nbsp;     */
&nbsp;    public boolean hasCommandConsoleBonus() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isShutDown() {
<b class="fc">&nbsp;        return shutDown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setShutDown(boolean shutDown) {
<b class="nc">&nbsp;        this.shutDown = shutDown;</b>
<b class="nc">&nbsp;        setShutDownThisPhase(shutDown);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setShutDownThisPhase(boolean shutDown) {
<b class="nc">&nbsp;        shutDownThisPhase = shutDown;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isShutDownThisPhase() {
<b class="nc">&nbsp;        return shutDownThisPhase;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStartupThisPhase(boolean shutDown) {
<b class="nc">&nbsp;        startupThisPhase = shutDown;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isStartupThisPhase() {
<b class="nc">&nbsp;        return startupThisPhase;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isDoomed() {
<b class="nc">&nbsp;        return doomed;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDoomed(boolean doomed) {
&nbsp;        // Doomed entities aren&#39;t in retreat.
<b class="nc">&nbsp;        if (doomed) {</b>
<b class="nc">&nbsp;            setRemovalCondition(IEntityRemovalConditions.REMOVE_SALVAGEABLE);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.doomed = doomed;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isDestroyed() {
<b class="nc">&nbsp;        return destroyed;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDestroyed(boolean destroyed) {
<b class="nc">&nbsp;        this.destroyed = destroyed;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Targetable interface
&nbsp;    @Override
&nbsp;    public int getTargetType() {
<b class="nc">&nbsp;        return Targetable.TYPE_ENTITY;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getTargetId() {
<b class="nc">&nbsp;        return getId();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getHeight() {
<b class="nc">&nbsp;        return height();</b>
&nbsp;    }
&nbsp;
&nbsp;    // End Targetable interface
&nbsp;
&nbsp;    public boolean isDone() {
<b class="nc">&nbsp;        return done;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDone(boolean done) {
<b class="nc">&nbsp;        this.done = done;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This method should &lt;strong&gt;only&lt;/stong&gt; be called when needed to remove a
&nbsp;     * dead swarmer&#39;s game turn.
&nbsp;     */
&nbsp;    public void setUnloaded(boolean unloaded) {
<b class="nc">&nbsp;        unloadedThisTurn = unloaded;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setLoadedThisTurn(boolean loaded) {
<b class="nc">&nbsp;        loadedThisTurn = loaded;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this entity participate in the current game phase.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this entity is not shut down, is not
&nbsp;     * destroyed, has an active crew, and was not unloaded from a
&nbsp;     * transport this turn. &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    public boolean isActive() {
<b class="nc">&nbsp;        return this.isActive(-1);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isActive(int turn) {
<b class="nc">&nbsp;        boolean isActive = !shutDown &amp;&amp; !isManualShutdown() &amp;&amp; !destroyed</b>
<b class="nc">&nbsp;                           &amp;&amp; getCrew().isActive() &amp;&amp; !unloadedThisTurn;</b>
&nbsp;
<b class="nc">&nbsp;        if ((turn &gt; -1) &amp;&amp; isActive) {</b>
<b class="nc">&nbsp;            isActive = !deployed &amp;&amp; shouldDeploy(turn);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            isActive = isActive &amp;&amp; deployed;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return isActive;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this entity is selectable for action. Transported
&nbsp;     * entities can not be selected.
&nbsp;     */
&nbsp;    public boolean isSelectableThisTurn() {
<b class="nc">&nbsp;        return !done &amp;&amp; (conveyance == Entity.NONE) &amp;&amp; !unloadedThisTurn</b>
<b class="nc">&nbsp;               &amp;&amp; !isClearingMinefield() &amp;&amp; !isCarcass();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this entity could potentially be loaded (did not move
&nbsp;     * from starting hex)
&nbsp;     */
&nbsp;    public boolean isLoadableThisTurn() {
<b class="nc">&nbsp;        return (delta_distance == 0) &amp;&amp; (conveyance == Entity.NONE)</b>
<b class="nc">&nbsp;               &amp;&amp; !unloadedThisTurn &amp;&amp; !isClearingMinefield() &amp;&amp; getTractor() == Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this &lt;code&gt;Entity&lt;/code&gt; was unloaded previously this turn.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this entity was unloaded for any reason
&nbsp;     * during this turn.
&nbsp;     */
&nbsp;    public boolean isUnloadedThisTurn() {
<b class="nc">&nbsp;        return unloadedThisTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean wasLoadedThisTurn() {
<b class="nc">&nbsp;        return loadedThisTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this entity is targetable for attacks.  A unit is
&nbsp;     * targetable if it is not destroyed, not doomed, deployed, not off board,
&nbsp;     * not being transported, and not captured.
&nbsp;     */
&nbsp;    public boolean isTargetable() {
<b class="nc">&nbsp;        return !destroyed &amp;&amp; !doomed &amp;&amp; deployed &amp;&amp; !isOffBoard()</b>
&nbsp;               &amp;&amp; (conveyance == Entity.NONE) &amp;&amp; !captured
<b class="nc">&nbsp;               &amp;&amp; (getPosition() != null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isProne() {
<b class="nc">&nbsp;        return prone;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setProne(boolean prone) {
<b class="nc">&nbsp;        this.prone = prone;</b>
<b class="nc">&nbsp;        if (prone) {</b>
<b class="nc">&nbsp;            hullDown = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isHullDown() {
<b class="nc">&nbsp;        return hullDown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setHullDown(boolean down) {
<b class="nc">&nbsp;        hullDown = down;</b>
<b class="nc">&nbsp;        if (hullDown) {</b>
<b class="nc">&nbsp;            prone = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Is this entity shut down or is the crew unconscious?
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isImmobile() {
<b class="nc">&nbsp;        return isImmobile(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this entity shut down, or if applicable is the crew unconscious?
&nbsp;     * @param checkCrew If true, consider the fitness of the crew when determining
&nbsp;     *                  if the entity is immobile.
&nbsp;     */
&nbsp;    public boolean isImmobile(boolean checkCrew) {
<b class="nc">&nbsp;        return isShutDown() || (checkCrew &amp;&amp; (crew != null) &amp;&amp; crew.isUnconscious());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method returns true if a unit is permanently immobilized either
&nbsp;     * because its crew is dead/gone or because of damage
&nbsp;     *
&nbsp;     * @return true if unit is permanently immobile
&nbsp;     */
&nbsp;    public boolean isPermanentlyImmobilized(boolean checkCrew) {
<b class="nc">&nbsp;        if (checkCrew &amp;&amp; ((getCrew() == null) || getCrew().isDead())) {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } else if (((getOriginalWalkMP() &gt; 0) || (getOriginalRunMP() &gt; 0) || (getOriginalJumpMP() &gt; 0))</b>
&nbsp;                /*
&nbsp;                 * Need to make sure here that we&#39;re ignoring heat because
&nbsp;                 * that&#39;s not actually &quot;permanent&quot;:
&nbsp;                 */
<b class="nc">&nbsp;                &amp;&amp; ((getWalkMP(true, true, false) == 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (getRunMP(true, true, false) == 0) &amp;&amp; (getJumpMP() == 0))) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCharging() {
<b class="nc">&nbsp;        return displacementAttack instanceof ChargeAttackAction;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isPushing() {
<b class="nc">&nbsp;        return displacementAttack instanceof PushAttackAction;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isMakingDfa() {
<b class="nc">&nbsp;        return displacementAttack instanceof DfaAttackAction;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasDisplacementAttack() {
<b class="nc">&nbsp;        return displacementAttack != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public DisplacementAttackAction getDisplacementAttack() {
<b class="nc">&nbsp;        return displacementAttack;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDisplacementAttack(
&nbsp;            DisplacementAttackAction displacementAttack) {
<b class="fc">&nbsp;        this.displacementAttack = displacementAttack;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if any other entities this entity knows of are making a
&nbsp;     * displacement attack on this entity.
&nbsp;     */
&nbsp;    public boolean isTargetOfDisplacementAttack() {
<b class="nc">&nbsp;        return findTargetedDisplacement() != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns any known displacement attacks (should only be one) that this
&nbsp;     * entity is a target of.
&nbsp;     */
&nbsp;    public DisplacementAttackAction findTargetedDisplacement() {
<b class="nc">&nbsp;        for (Entity other : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (other.hasDisplacementAttack()</b>
<b class="nc">&nbsp;                &amp;&amp; (other.getDisplacementAttack().getTargetId() == id)) {</b>
<b class="nc">&nbsp;                return other.getDisplacementAttack();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isUnjammingRAC() {
<b class="nc">&nbsp;        return unjammingRAC;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUnjammingRAC(boolean u) {
<b class="fc">&nbsp;        unjammingRAC = u;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isFindingClub() {
<b class="nc">&nbsp;        return findingClub;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setFindingClub(boolean findingClub) {
<b class="fc">&nbsp;        this.findingClub = findingClub;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set whether or not the mech&#39;s arms are flipped to the rear
&nbsp;     */
&nbsp;    public void setArmsFlipped(boolean armsFlipped) {
<b class="fc">&nbsp;        setArmsFlipped(armsFlipped, true);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Set whether or not the mech&#39;s arms are flipped to the rear.
&nbsp;     * Does not fire the game event, useful for when it&#39;s called repeatedly
&nbsp;     * such as during bot turn calculations
&nbsp;     */
&nbsp;    public void setArmsFlipped(boolean armsFlipped, boolean fireEvent) {
<b class="fc">&nbsp;        this.armsFlipped = armsFlipped;</b>
&nbsp;        
<b class="fc">&nbsp;        if (fireEvent) {</b>
<b class="fc">&nbsp;            game.processGameEvent(new GameEntityChangeEvent(this, this));</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the mech&#39;s arms are flipped to the rear
&nbsp;     */
&nbsp;    public boolean getArmsFlipped() {
<b class="nc">&nbsp;        return armsFlipped;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if the VTOL or LAM is making a VTOL strafe or VTOL/AirMech bomb attack
&nbsp;     */
&nbsp;    public boolean isMakingVTOLGroundAttack() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current position of this entity on the board. This is not
&nbsp;     * named getLocation(), since I want the word location to refer to hit
&nbsp;     * locations on a mech or vehicle.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Coords getPosition() {
<b class="fc">&nbsp;        return position;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a set of the coords this Entity occupies
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public HashSet&lt;Coords&gt; getOccupiedCoords() {
<b class="nc">&nbsp;        HashSet&lt;Coords&gt; positions = new HashSet&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        if ((getSecondaryPositions() != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (getSecondaryPositions().size() != 0)) {</b>
<b class="nc">&nbsp;            for (int key : getSecondaryPositions().keySet()) {</b>
<b class="nc">&nbsp;                positions.add(getSecondaryPositions().get(key));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (getPosition() != null) {</b>
<b class="nc">&nbsp;            positions.add(getPosition());</b>
&nbsp;        }
<b class="nc">&nbsp;        return positions;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPosition(Coords position) {
<b class="fc">&nbsp;        setPosition(position, true);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the current position of this entity on the board.
&nbsp;     *
&nbsp;     * @param position the new position.
&nbsp;     */
&nbsp;    public void setPosition(Coords position, boolean gameUpdate) {
<b class="fc">&nbsp;        HashSet&lt;Coords&gt; oldPositions = null;</b>
<b class="fc">&nbsp;        if ((game != null) &amp;&amp; gameUpdate) {</b>
<b class="nc">&nbsp;            oldPositions = getOccupiedCoords();</b>
&nbsp;        }
<b class="fc">&nbsp;        this.position = position;</b>
<b class="fc">&nbsp;        if ((game != null) &amp;&amp; gameUpdate) {</b>
<b class="nc">&nbsp;            game.updateEntityPositionLookup(this, oldPositions);</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return the coords of the second to last position on the passed through
&nbsp;     * vector or the current position if too small
&nbsp;     */
&nbsp;
&nbsp;    public Coords getPriorPosition() {
<b class="nc">&nbsp;        if (passedThrough.size() &lt; 2) {</b>
<b class="nc">&nbsp;            return getPosition();</b>
&nbsp;        }
<b class="nc">&nbsp;        return passedThrough.elementAt(passedThrough.size() - 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the current elevation of this entity above the ground.  This is the
&nbsp;     * number of levels the unit is above the level of the hex.
&nbsp;     *
&nbsp;     * @param elevation an &lt;code&gt;int&lt;/code&gt; representing the new elevation.
&nbsp;     */
&nbsp;    public void setElevation(int elevation) {
<b class="nc">&nbsp;        this.elevation = elevation;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A helper function for fiddling with elevation. Takes the current hex, a
&nbsp;     * hex being moved to, returns the elevation the Entity will be considered
&nbsp;     * to be at w/r/t it&#39;s new hex.
&nbsp;     */
&nbsp;    public int calcElevation(IHex current, IHex next, int assumedElevation,
&nbsp;            boolean climb, boolean wigeEndClimbPrevious) {
<b class="nc">&nbsp;        int retVal = assumedElevation;</b>
<b class="nc">&nbsp;        if (isAero()) {</b>
<b class="nc">&nbsp;            return retVal;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getMovementMode() == EntityMovementMode.WIGE) {</b>
&nbsp;            // Airborne WiGEs remain 1 elevation above underlying terrain, unless climb mode is
&nbsp;            // on, then they maintain current absolute elevation  as long as it is at least
&nbsp;            // one level above the ground.
&nbsp;            // WiGEs treat the tops of buildings as the underlying terrain, but must pay an additional
&nbsp;            // 2 MP to climb.
&nbsp;            // See http://bg.battletech.com/forums/index.php?topic=51081.msg1297747#msg1297747
&nbsp;
&nbsp;            // Find level equivalent of current elevation
<b class="nc">&nbsp;            int level = current.surface() + assumedElevation;</b>
&nbsp;            // For WiGE purposes, the surface of a hex with a building is the roof; otherwise it&#39;s the surface of the hex.
<b class="nc">&nbsp;            int curSurface = current.surface();</b>
<b class="nc">&nbsp;            if (current.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                curSurface += current.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;            }
<b class="nc">&nbsp;            int nextSurface = next.surface();</b>
<b class="nc">&nbsp;            if (next.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                nextSurface += next.terrainLevel(Terrains.BLDG_ELEV);</b>
&nbsp;            }
&nbsp;
&nbsp;            int nextLevel;
<b class="nc">&nbsp;            if (level - curSurface &lt;= 0) {</b>
&nbsp;                // If we are not above the effective surface, we are not airborne and the next level
&nbsp;                // is the effective surface of the next hex.
<b class="nc">&nbsp;                nextLevel = nextSurface;</b>
<b class="nc">&nbsp;            } else if (climb) {</b>
&nbsp;                // If climb mode is on, we maintain the same level unless the next surface requires climbing.
&nbsp;                // is the effective surface of the next hex.
<b class="nc">&nbsp;                nextLevel = Math.max(level, nextSurface + 1);</b>
&nbsp;            } else {
&nbsp;                // Otherwise we move to one elevation level above the effective surface.
<b class="nc">&nbsp;                nextLevel = nextSurface + 1;</b>
&nbsp;            }
&nbsp;            // Elevation is this height of the level above the actual surface elevation of the hex.
<b class="nc">&nbsp;            retVal = nextLevel - next.surface();</b>
<b class="nc">&nbsp;        } else if ((getMovementMode() == EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;            || ((getMovementMode() == EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;                &amp;&amp; next.containsTerrain(Terrains.WATER) &amp;&amp; current</b>
<b class="nc">&nbsp;                .containsTerrain(Terrains.WATER))</b>
<b class="nc">&nbsp;            || (getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;            || ((getMovementMode() == EntityMovementMode.QUAD_SWIM) &amp;&amp; hasUMU())</b>
<b class="nc">&nbsp;            || ((getMovementMode() == EntityMovementMode.BIPED_SWIM) &amp;&amp; hasUMU())) {</b>
<b class="nc">&nbsp;            retVal += current.surface();</b>
<b class="nc">&nbsp;            retVal -= next.surface();</b>
&nbsp;        } else {
&nbsp;            // if we&#39;re a hovercraft, surface ship, WIGE or a &quot;fully amphibious&quot; vehicle, we go on the water surface
&nbsp;            // without adjusting elevation
<b class="nc">&nbsp;            if ((getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;                &amp;&amp; (getMovementMode() != EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                &amp;&amp; (getMovementMode() != EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;                &amp;&amp; !hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS)) {</b>
<b class="nc">&nbsp;                int prevWaterLevel = 0;</b>
<b class="nc">&nbsp;                if (current.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                    prevWaterLevel = current.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;                    if (!(current.containsTerrain(Terrains.ICE))</b>
&nbsp;                        || (assumedElevation &lt; 0)) {
&nbsp;                        // count water, only if the entity isn&#39;t on ice surface
<b class="nc">&nbsp;                        retVal += current.terrainLevel(Terrains.WATER);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (next.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                    int waterLevel = next.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;                    if (next.containsTerrain(Terrains.ICE)) {</b>
&nbsp;                        // a mech can only climb out onto ice in depth 2 or
&nbsp;                        // shallower water
&nbsp;                        // mech on the surface will stay on the surface
&nbsp;
<b class="nc">&nbsp;                        if (((waterLevel == 1) &amp;&amp; (prevWaterLevel == 1))</b>
&nbsp;                            || ((prevWaterLevel &lt;= 2) &amp;&amp; climb)
&nbsp;                            || (assumedElevation &gt;= 0)) {
<b class="nc">&nbsp;                            retVal += waterLevel;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    retVal -= waterLevel;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (next.containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                || current.containsTerrain(Terrains.BUILDING)) {</b>
<b class="nc">&nbsp;                int bldcur = Math.max(-current.depth(true),</b>
<b class="nc">&nbsp;                                      current.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;                int bldnex = Math.max(-next.depth(true),</b>
<b class="nc">&nbsp;                                      next.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;                if (((assumedElevation == bldcur)</b>
&nbsp;                     &amp;&amp; (climb || isJumpingNow) &amp;&amp; (this instanceof Mech))
&nbsp;                    || (retVal &gt; bldnex)) {
<b class="nc">&nbsp;                    retVal = bldnex;</b>
<b class="nc">&nbsp;                } else if ((bldnex + next.surface())</b>
<b class="nc">&nbsp;                        &gt; (bldcur + current.surface())) {</b>
<b class="nc">&nbsp;                    int nextBasement =</b>
<b class="nc">&nbsp;                            next.terrainLevel(Terrains.BLDG_BASEMENT_TYPE);</b>
<b class="nc">&nbsp;                    int collapsedBasement =</b>
<b class="nc">&nbsp;                            next.terrainLevel(Terrains.BLDG_BASE_COLLAPSED);</b>
<b class="nc">&nbsp;                    if (climb || isJumpingNow) {</b>
<b class="nc">&nbsp;                        retVal = bldnex + next.surface();</b>
&nbsp;                    // If the basement is collapsed, there is no level 0
<b class="nc">&nbsp;                    } else if ((assumedElevation == 0)</b>
<b class="nc">&nbsp;                            &amp;&amp; (nextBasement &gt; BasementType.NONE.getValue())</b>
&nbsp;                            &amp;&amp; (collapsedBasement &gt; 0)) {
<b class="nc">&nbsp;                        retVal -= BasementType.getType(</b>
<b class="nc">&nbsp;                                next.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</b>
<b class="nc">&nbsp;                                              .getDepth();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        retVal += current.surface();</b>
<b class="nc">&nbsp;                        retVal -= next.surface();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (elevation == -(current.depth(true))) {</b>
<b class="nc">&nbsp;                    if (climb || isJumpingNow) {</b>
<b class="nc">&nbsp;                        retVal = bldnex + next.surface();</b>
<b class="nc">&nbsp;                    } else if ((current</b>
<b class="nc">&nbsp;                                        .terrainLevel(Terrains.BLDG_BASEMENT_TYPE) &gt; BasementType.NONE</b>
<b class="nc">&nbsp;                                        .getValue())</b>
&nbsp;                               &amp;&amp; (assumedElevation == -BasementType
<b class="nc">&nbsp;                            .getType(</b>
<b class="nc">&nbsp;                                    current.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</b>
<b class="nc">&nbsp;                            .getDepth())) {</b>
<b class="nc">&nbsp;                        retVal = -BasementType.getType(</b>
<b class="nc">&nbsp;                                next.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</b>
<b class="nc">&nbsp;                                              .getDepth();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        retVal += current.surface();</b>
<b class="nc">&nbsp;                        retVal -= next.surface();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if ((getMovementMode() != EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                    &amp;&amp; (getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                    &amp;&amp; (next.containsTerrain(Terrains.BRIDGE) || current</b>
<b class="nc">&nbsp;                            .containsTerrain(Terrains.BRIDGE))) {</b>
&nbsp;                int bridgeElev;
<b class="nc">&nbsp;                if (next.containsTerrain(Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                    bridgeElev = next.terrainLevel(Terrains.BRIDGE_ELEV);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    bridgeElev = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                int elevDiff = Math.abs((next.surface() + bridgeElev)</b>
<b class="nc">&nbsp;                        - (current.surface() + assumedElevation));</b>
<b class="nc">&nbsp;                if (elevDiff &lt;= getMaxElevationChange()) {</b>
&nbsp;                    // bridge is reachable at least
<b class="nc">&nbsp;                    if (climb || !isElevationValid(retVal, next)) {</b>
&nbsp;                        // use bridge if you can&#39;t use the base terrain or if
&nbsp;                        // you prefer to by climb mode
<b class="nc">&nbsp;                        retVal = bridgeElev;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return retVal;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int calcElevation(IHex current, IHex next) {
<b class="nc">&nbsp;        return calcElevation(current, next, elevation, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the elevation of this entity, relative to the current Hex&#39;s
&nbsp;     * surface
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getElevation() {
<b class="nc">&nbsp;        if (Entity.NONE != getTransportId()) {</b>
<b class="nc">&nbsp;            return game.getEntity(getTransportId()).getElevation();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((null == getPosition()) &amp;&amp; (isDeployed())) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Entity #&quot; + getId()</b>
&nbsp;                                            + &quot; does not know its position.&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isOffBoard()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return elevation;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean canGoDown() {
<b class="nc">&nbsp;        return canGoDown(elevation, getPosition());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * is it possible to go down, or are we landed/just above the
&nbsp;     * water/treeline? assuming passed elevation.
&nbsp;     */
&nbsp;    public boolean canGoDown(int assumedElevation, Coords assumedPos) {
<b class="nc">&nbsp;        if (!getGame().getBoard().contains(assumedPos)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex hex = getGame().getBoard().getHex(assumedPos);</b>
<b class="nc">&nbsp;        int assumedAlt = assumedElevation + hex.surface();</b>
<b class="nc">&nbsp;        int minAlt = hex.surface();</b>
<b class="nc">&nbsp;        switch (getMovementMode()) {</b>
&nbsp;            case INF_JUMP:
&nbsp;            case INF_LEG:
&nbsp;            case INF_MOTORIZED:
<b class="nc">&nbsp;                minAlt -= Math.max(</b>
&nbsp;                        0,
<b class="nc">&nbsp;                        BasementType.getType(</b>
<b class="nc">&nbsp;                                hex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</b>
<b class="nc">&nbsp;                                    .getDepth());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WIGE:
&nbsp;                // Per errata, WiGEs have flotation hull, which makes no sense unless it changes the rule
&nbsp;                // in TW that they cannot land on water.
&nbsp;                // See
<b class="nc">&nbsp;                if (isAirborne()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                    minAlt = hex.surface();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                // else fall through
&nbsp;            case VTOL:
<b class="nc">&nbsp;                int minElev = 0;</b>
&nbsp;                // When over a bridge, limit downward movement. Can land on a bridge.
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.BRIDGE_ELEV)</b>
<b class="nc">&nbsp;                        &amp;&amp; (assumedElevation &gt;= hex.terrainLevel(Terrains.BRIDGE_ELEV)) ) {</b>
<b class="nc">&nbsp;                    minElev = hex.terrainLevel(Terrains.BRIDGE_ELEV);</b>
&nbsp;                }
&nbsp;                // Cannot land on woods or water
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                    minElev = Math.max(minElev, hex.terrainLevel(Terrains.FOLIAGE_ELEV) - hex.depth() + 1);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hex.depth() &gt; 0) {</b>
<b class="nc">&nbsp;                    minElev = Math.max(minElev, 1);</b>
&nbsp;                }
&nbsp;                // Can land on buildings
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                    minElev = Math.max(minElev, hex.terrainLevel(Terrains.BLDG_ELEV) - hex.depth());</b>
&nbsp;                }
<b class="nc">&nbsp;                minAlt = minElev + hex.surface();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case AERODYNE:
&nbsp;            case SPHEROID:
<b class="nc">&nbsp;                assumedAlt = assumedElevation;</b>
<b class="nc">&nbsp;                if (game.getBoard().inAtmosphere()) {</b>
<b class="nc">&nbsp;                    minAlt = Math.max(0, hex.ceiling(true)) + 1;</b>
<b class="nc">&nbsp;                } else if (game.getBoard().onGround() &amp;&amp; isAirborne()) {</b>
<b class="nc">&nbsp;                    minAlt = 1;</b>
&nbsp;                }
&nbsp;                // if sensors are damaged then, one higher
<b class="nc">&nbsp;                if (isAero()</b>
<b class="nc">&nbsp;                        &amp;&amp; (((IAero)this).getSensorHits() &gt; 0)) {</b>
<b class="nc">&nbsp;                    minAlt++;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case INF_UMU:
&nbsp;            	/* non-mechanized SCUBA infantry have a maximum depth of 2 */
<b class="nc">&nbsp;            	if (this instanceof Infantry &amp;&amp; ((Infantry)this).hasSpecialization(Infantry.SCUBA)</b>
<b class="nc">&nbsp;            			&amp;&amp; hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            		minAlt = Math.max(hex.floor(), -2);</b>
&nbsp;            	} else {
<b class="nc">&nbsp;            		minAlt = hex.floor();</b>
&nbsp;            	}
<b class="nc">&nbsp;            	break;</b>
&nbsp;            case SUBMARINE:
&nbsp;            case BIPED_SWIM:
&nbsp;            case QUAD_SWIM:
<b class="nc">&nbsp;                minAlt = hex.floor();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case BIPED:
&nbsp;            case QUAD:
<b class="nc">&nbsp;                if (this instanceof Protomech) {</b>
<b class="nc">&nbsp;                    minAlt -= Math</b>
<b class="nc">&nbsp;                            .max(0,</b>
&nbsp;                                 BasementType
<b class="nc">&nbsp;                                         .getType(</b>
<b class="nc">&nbsp;                                                 hex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</b>
<b class="nc">&nbsp;                                         .getDepth());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (assumedAlt &gt; minAlt);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * is it possible to go up, or are we at maximum altitude? assuming passed
&nbsp;     * elevation.
&nbsp;     */
&nbsp;    public boolean canGoUp(int assumedElevation, Coords assumedPos) {
&nbsp;        // Could have a hex off the board
<b class="nc">&nbsp;        if (!getGame().getBoard().contains(assumedPos)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex hex = getGame().getBoard().getHex(assumedPos);</b>
<b class="nc">&nbsp;        int assumedAlt = assumedElevation + hex.surface();</b>
<b class="nc">&nbsp;        int maxAlt = hex.surface();</b>
<b class="nc">&nbsp;        switch (getMovementMode()) {</b>
&nbsp;            case INF_JUMP:
&nbsp;            case INF_LEG:
&nbsp;            case INF_MOTORIZED:
<b class="nc">&nbsp;                maxAlt += Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case VTOL:
<b class="nc">&nbsp;                maxAlt = hex.surface() + 50;</b>
&nbsp;                // When under a bridge, restrict upward movement
&nbsp;                // &quot;- 1&quot; to correct that height() reports one less than the rules (TW p.99) say
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.BRIDGE_ELEV)</b>
<b class="nc">&nbsp;                        &amp;&amp; assumedElevation &lt; hex.terrainLevel(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;                    maxAlt = hex.terrainLevel(Terrains.BRIDGE_ELEV) - height() - 1;   </b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case AERODYNE:
&nbsp;            case SPHEROID:
<b class="nc">&nbsp;                if (!game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                    assumedAlt = assumedElevation;</b>
<b class="nc">&nbsp;                    maxAlt = 10;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case SUBMARINE:
<b class="nc">&nbsp;                maxAlt = hex.surface() - getHeight();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case INF_UMU:
&nbsp;            case BIPED_SWIM:
&nbsp;            case QUAD_SWIM:
&nbsp;                // UMU&#39;s won&#39;t allow the entity to break the surface of the
&nbsp;                // water
<b class="nc">&nbsp;                maxAlt = hex.surface() - (getHeight() + 1);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WIGE:
<b class="nc">&nbsp;                if (this instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                    if (isAirborne()) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    maxAlt = hex.surface() + 25;</b>
<b class="nc">&nbsp;                } else if (this instanceof Protomech) {</b>
<b class="nc">&nbsp;                    maxAlt = hex.surface() + 12;</b>
<b class="nc">&nbsp;                } else if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                    maxAlt = Math.max(hex.surface(), hex.terrainLevel(Terrains.BLDG_ELEV)) + 1;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    maxAlt = hex.surface() + 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case BIPED:
&nbsp;            case QUAD:
<b class="nc">&nbsp;                if (this instanceof Protomech) {</b>
<b class="nc">&nbsp;                    maxAlt += Math.max(0, hex.terrainLevel(Terrains.BLDG_ELEV));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (assumedAlt &lt; maxAlt);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if this entity can legally occupy the requested elevation. Does not
&nbsp;     * check stacking, only terrain limitations
&nbsp;     */
&nbsp;    public boolean isElevationValid(int assumedElevation, IHex hex) {
<b class="nc">&nbsp;        int assumedAlt = assumedElevation + hex.surface();</b>
<b class="nc">&nbsp;        if (getMovementMode() == EntityMovementMode.VTOL) {</b>
<b class="nc">&nbsp;            if ((this instanceof Infantry)</b>
<b class="nc">&nbsp;                    &amp;&amp; (hex.containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                            || hex.containsTerrain(Terrains.WOODS) </b>
<b class="nc">&nbsp;                            || hex.containsTerrain(Terrains.JUNGLE))) {</b>
&nbsp;                // VTOL BA (sylph) can move as ground unit as well
<b class="nc">&nbsp;                return ((assumedElevation &lt;= 50) &amp;&amp; (assumedAlt &gt;= hex.floor()));</b>
&nbsp;            } else {
&nbsp;                // VTOLs can be anywhere on or above ground and fly beneath bridges,
&nbsp;                // land on buildings and ignore planted fields and industrial zone 
&nbsp;                // but cannot land on water or trees
&nbsp;                // As always, height() reports one less than the rules (TW p.99) say
&nbsp;                // Units may move under a bridge if their top is 
&nbsp;                // lower than or equal to the bridge height (TW p.62)
<b class="nc">&nbsp;                boolean allowed = (assumedElevation &lt;= 50) &amp;&amp; (assumedElevation &gt;= 0);</b>
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;                    allowed &amp;= (assumedElevation &gt;= hex.terrainLevel(Terrains.BRIDGE_ELEV))</b>
<b class="nc">&nbsp;                            || (assumedElevation + height() + 1 &lt;= hex.terrainLevel(Terrains.BRIDGE_ELEV));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.FOLIAGE_ELEV)) {</b>
<b class="nc">&nbsp;                    allowed &amp;= (assumedElevation &gt; hex.terrainLevel(Terrains.FOLIAGE_ELEV) - hex.depth());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hex.depth() &gt; 0) {</b>
<b class="nc">&nbsp;                    allowed &amp;= (assumedElevation &gt; 0);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;                    allowed &amp;= (assumedElevation &gt;= hex.terrainLevel(Terrains.BLDG_ELEV) - hex.depth());</b>
&nbsp;                }
<b class="nc">&nbsp;                return allowed;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if ((getMovementMode() == EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;                   || ((getMovementMode() == EntityMovementMode.INF_UMU) &amp;&amp; hex</b>
<b class="nc">&nbsp;                .containsTerrain(Terrains.WATER))</b>
<b class="nc">&nbsp;                   || ((getMovementMode() == EntityMovementMode.QUAD_SWIM) &amp;&amp; hasUMU())</b>
<b class="nc">&nbsp;                   || ((getMovementMode() == EntityMovementMode.BIPED_SWIM) &amp;&amp; hasUMU())) {</b>
<b class="nc">&nbsp;        	if (this instanceof Infantry &amp;&amp; ((Infantry)this).hasSpecialization(Infantry.SCUBA)</b>
<b class="nc">&nbsp;        			&amp;&amp; getMovementMode() == EntityMovementMode.INF_UMU) {</b>
<b class="nc">&nbsp;        		return assumedAlt &gt;= Math.max(hex.floor(), -2)</b>
<b class="nc">&nbsp;        				&amp;&amp; (assumedAlt &lt;= hex.surface());</b>
&nbsp;        	}
<b class="nc">&nbsp;            return ((assumedAlt &gt;= hex.floor()) &amp;&amp; (assumedAlt &lt;= hex.surface()));</b>
<b class="nc">&nbsp;        } else if ((getMovementMode() == EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                   || (getMovementMode() == EntityMovementMode.NAVAL)) {</b>
<b class="nc">&nbsp;            return assumedAlt == hex.surface();</b>
<b class="nc">&nbsp;        } else if (getMovementMode() == EntityMovementMode.WIGE) {</b>
&nbsp;            // WiGEs can possibly be at any location above or on the surface
<b class="nc">&nbsp;            return (assumedAlt &gt;= hex.floor());</b>
&nbsp;        } else {
&nbsp;            // regular ground units
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;                || (((getMovementMode() == EntityMovementMode.HOVER) || hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS)) &amp;&amp;</b>
<b class="nc">&nbsp;                        hex.containsTerrain(Terrains.WATER))) {</b>
&nbsp;                // surface of ice is OK, surface of water is OK for hovers and &quot;fully amphibious&quot; units
<b class="nc">&nbsp;                if (assumedAlt == hex.surface()) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // only mechs can move underwater
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                &amp;&amp; (assumedAlt &lt; hex.surface()) &amp;&amp; !(this instanceof Mech)</b>
&nbsp;                &amp;&amp; !(this instanceof Protomech)) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // can move on the ground unless its underwater
<b class="nc">&nbsp;            if (assumedAlt == hex.floor()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.BRIDGE)) {</b>
&nbsp;                // can move on top of a bridge
<b class="nc">&nbsp;                if (assumedElevation == hex.terrainLevel(Terrains.BRIDGE_ELEV)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.BUILDING)) {</b>
&nbsp;                // Any unit can fall into a basement
<b class="nc">&nbsp;                if ((assumedAlt &lt; 0) &amp;&amp; (hex.depth(true) &gt; 0)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;                // Mechs, protos and infantry can occupy any floor in the
&nbsp;                // building
<b class="nc">&nbsp;                if ((this instanceof Mech) || (this instanceof Protomech)</b>
&nbsp;                    || (this instanceof Infantry)) {
<b class="nc">&nbsp;                    if ((assumedAlt &gt;= (hex.surface() - hex.depth(true)))</b>
<b class="nc">&nbsp;                        &amp;&amp; (assumedAlt &lt;= hex.ceiling())) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the height of the unit, that is, how many levels above its
&nbsp;     * elevation it is for LOS purposes. Default is 0.
&nbsp;     */
&nbsp;    public int height() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the elevation of the entity&#39;s highest point relative to
&nbsp;     * the surface of the hex the entity is in , i.e.
&nbsp;     * relHeight() == getElevation() + getHeight()
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int relHeight() {
<b class="nc">&nbsp;        return getElevation() + height();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Convenience method to determine whether this entity is on a ground map with an atmosphere
&nbsp;     */
&nbsp;    public boolean isOnAtmosphericGroundMap() {
<b class="nc">&nbsp;        return  ((getGame().getPlanetaryConditions().getAtmosphere() != PlanetaryConditions.ATMO_VACUUM) ||</b>
<b class="nc">&nbsp;                (getGame().getPlanetaryConditions().getAtmosphere() != PlanetaryConditions.ATMO_TRACE)) &amp;&amp;</b>
&nbsp;
<b class="nc">&nbsp;                (getGame().getBoard().onGround() ||</b>
&nbsp;                // doesn&#39;t make sense in english, but &quot;atmospheric&quot; map actually
&nbsp;                // covers maps that are within a planet&#39;s gravity well
<b class="nc">&nbsp;                getGame().getBoard().inAtmosphere());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method to determine whether this entity should be treated as an airborne aero on a ground map.
&nbsp;     * @return True if this is an airborne aircraft on a ground map.
&nbsp;     */
&nbsp;    public boolean isAirborneAeroOnGroundMap() {
<b class="nc">&nbsp;        return isAero() &amp;&amp; isAirborne() &amp;&amp; getGame().getBoard().onGround();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the display name for this entity.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="nc">&nbsp;        if (displayName == null) {</b>
<b class="nc">&nbsp;            generateDisplayName();</b>
&nbsp;        }
<b class="nc">&nbsp;        return displayName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates the display name for this entity.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are allowed to override this method. The display name is in
&nbsp;     * the format [Chassis] [Model] ([Player Name]).
&nbsp;     */
&nbsp;    public void generateDisplayName() {
<b class="fc">&nbsp;        StringBuffer nbuf = new StringBuffer();</b>
<b class="fc">&nbsp;        nbuf.append(chassis);</b>
<b class="fc">&nbsp;        if ((model != null) &amp;&amp; (model.length() &gt; 0)) {</b>
<b class="fc">&nbsp;            nbuf.append(&quot; &quot;).append(model);</b>
&nbsp;        }
&nbsp;        // if show unit id is on, append the id
<b class="fc">&nbsp;        if (PreferenceManager.getClientPreferences().getShowUnitId()) {</b>
<b class="nc">&nbsp;            nbuf.append(&quot; ID:&quot;).append(getId());</b>
<b class="fc">&nbsp;        } else if (duplicateMarker &gt; 1) {</b>
&nbsp;            // if not, and a player has more than one unit with the same name,
&nbsp;            // append &quot;#N&quot; after the model to differentiate.
<b class="nc">&nbsp;            nbuf.append(&quot; #&quot; + duplicateMarker);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (getOwner() != null) {</b>
<b class="fc">&nbsp;            nbuf.append(&quot; (&quot;).append(getOwner().getName()).append(&quot;)&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (PreferenceManager.getClientPreferences().getShowUnitId()) {</b>
<b class="nc">&nbsp;            nbuf.append(&quot; ID:&quot;).append(getId());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        displayName = nbuf.toString();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A short name, suitable for displaying above a unit icon. The short name
&nbsp;     * is basically the same as the display name, minus the player name.
&nbsp;     */
&nbsp;    public String getShortName() {
<b class="nc">&nbsp;        if (shortName == null) {</b>
<b class="nc">&nbsp;            generateShortName();</b>
&nbsp;        }
<b class="nc">&nbsp;        return shortName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generate the short name for a unit
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are allowed to override this method. The display name is in
&nbsp;     * the format [Chassis] [Model].
&nbsp;     */
&nbsp;    public void generateShortName() {
<b class="nc">&nbsp;        StringBuffer nbuf = new StringBuffer();</b>
<b class="nc">&nbsp;        nbuf.append(chassis);</b>
<b class="nc">&nbsp;        if ((model != null) &amp;&amp; (model.length() &gt; 0)) {</b>
<b class="nc">&nbsp;            nbuf.append(&quot; &quot;).append(model);</b>
&nbsp;        }
&nbsp;        // if show unit id is on, append the id
<b class="nc">&nbsp;        if (PreferenceManager.getClientPreferences().getShowUnitId()) {</b>
<b class="nc">&nbsp;            nbuf.append(&quot; ID:&quot;).append(getId());</b>
<b class="nc">&nbsp;        } else if (duplicateMarker &gt; 1) {</b>
&nbsp;            // if not, and a player has more than one unit with the same name,
&nbsp;            // append &quot;#N&quot; after the model to differentiate.
<b class="nc">&nbsp;            nbuf.append(&quot; #&quot; + duplicateMarker);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        shortName = nbuf.toString();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getShortNameRaw() {
<b class="fc">&nbsp;        StringBuffer nbuf = new StringBuffer();</b>
<b class="fc">&nbsp;        nbuf.append(chassis);</b>
<b class="fc">&nbsp;        if ((model != null) &amp;&amp; (model.length() &gt; 0)) {</b>
<b class="fc">&nbsp;            nbuf.append(&quot; &quot;).append(model);</b>
&nbsp;        }
<b class="fc">&nbsp;        return nbuf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the primary facing, or -1 if n/a
&nbsp;     */
&nbsp;    public int getFacing() {
<b class="fc">&nbsp;        if (Entity.NONE != conveyance) {</b>
<b class="nc">&nbsp;            Entity transporter = game.getEntity(conveyance);</b>
<b class="nc">&nbsp;            if (transporter == null) {</b>
<b class="nc">&nbsp;                transporter = game.getOutOfGameEntity(conveyance);</b>
&nbsp;            }
<b class="nc">&nbsp;            return transporter.getFacing();</b>
&nbsp;        }
<b class="fc">&nbsp;        return facing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the primary facing.
&nbsp;     */
&nbsp;    public void setFacing(int facing) {
<b class="nc">&nbsp;        this.facing = facing;</b>
<b class="nc">&nbsp;        if (game != null) {</b>
<b class="nc">&nbsp;            game.processGameEvent(new GameEntityChangeEvent(this, this));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the secondary facing, or -1 if n/a
&nbsp;     */
&nbsp;    public int getSecondaryFacing() {
<b class="nc">&nbsp;        return sec_facing;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSecondaryFacing(int sec_facing) {
<b class="fc">&nbsp;        setSecondaryFacing(sec_facing, true);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the secondary facing. 
&nbsp;     * Optionally does not fire a game change event (useful for bot evaluation)
&nbsp;     */
&nbsp;    public void setSecondaryFacing(int sec_facing, boolean fireEvent) {
<b class="fc">&nbsp;        this.sec_facing = sec_facing;</b>
<b class="fc">&nbsp;        if (fireEvent &amp;&amp; (game != null)) {</b>
<b class="fc">&nbsp;            game.processGameEvent(new GameEntityChangeEvent(this, this));</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Utility function that handles situations where a facing change
&nbsp;     * imparts some kind of permanent effect to the entity.
&nbsp;     */
&nbsp;    public void postProcessFacingChange() {
&nbsp;    	
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Can this entity change secondary facing at all?
&nbsp;     */
&nbsp;    public abstract boolean canChangeSecondaryFacing();
&nbsp;
&nbsp;    /**
&nbsp;     * Can this entity torso/turret twist the given direction?
&nbsp;     */
&nbsp;    public abstract boolean isValidSecondaryFacing(int dir);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the closest valid secondary facing to the given direction.
&nbsp;     *
&nbsp;     * @return the the closest valid secondary facing.
&nbsp;     */
&nbsp;    public abstract int clipSecondaryFacing(int dir);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity has an RAC which is jammed and not destroyed
&nbsp;     * As of 5/22/2012 also returns true if there is a jammed and not destroyed
&nbsp;     * Ultra AC and the unofficial options is enabled.  Jammed ACs and LACs can
&nbsp;     * also be unjammed if rapid-fire ACs is turned on.
&nbsp;     */
&nbsp;    public boolean canUnjamRAC() {
<b class="nc">&nbsp;        for (Mounted mounted : getTotalWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="nc">&nbsp;            if ((wtype.getAmmoType() == AmmoType.T_AC_ROTARY)</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.isJammed() &amp;&amp; !mounted.isDestroyed()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</b>
<b class="nc">&nbsp;                 || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</b>
<b class="nc">&nbsp;                 || (wtype.getAmmoType() == AmmoType.T_AC)</b>
<b class="nc">&nbsp;                 || (wtype.getAmmoType() == AmmoType.T_LAC)</b>
<b class="nc">&nbsp;                 || (wtype.getAmmoType() == AmmoType.T_AC_IMP)</b>
<b class="nc">&nbsp;                 || (wtype.getAmmoType() == AmmoType.T_PAC))</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.isJammed()</b>
<b class="nc">&nbsp;                &amp;&amp; !mounted.isDestroyed()</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UNJAM_UAC)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity can flip its arms
&nbsp;     */
&nbsp;    public boolean canFlipArms() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s original walking movement points
&nbsp;     */
&nbsp;    public int getOriginalWalkMP() {
<b class="fc">&nbsp;        return walkMP;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets this entity&#39;s original walking movement points
&nbsp;     */
&nbsp;    public void setOriginalWalkMP(int walkMP) {
<b class="fc">&nbsp;        this.walkMP = walkMP;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s walking/cruising mp, factored for heat and gravity.
&nbsp;     */
&nbsp;
&nbsp;    public int getWalkMP() {
<b class="fc">&nbsp;        return getWalkMP(true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s walking/cruising mp, factored for heat and possibly
&nbsp;     * gravity.
&nbsp;     *
&nbsp;     * @param gravity    Should the movement be factored for gravity
&nbsp;     * @param ignoreheat Should heat be ignored?
&nbsp;     */
&nbsp;    public int getWalkMP(boolean gravity, boolean ignoreheat) {
<b class="fc">&nbsp;        return getWalkMP(gravity, ignoreheat, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getWalkMP(boolean gravity, boolean ignoreheat,
&nbsp;                         boolean ignoremodulararmor) {
<b class="nc">&nbsp;        int mp = getOriginalWalkMP();</b>
&nbsp;
<b class="nc">&nbsp;        if (!ignoreheat) {</b>
<b class="nc">&nbsp;            mp = Math.max(0, mp - getHeatMPReduction());</b>
&nbsp;        }
<b class="nc">&nbsp;        mp = Math.max(mp - getCargoMpReduction(this), 0);</b>
<b class="nc">&nbsp;        if (null != game) {</b>
<b class="nc">&nbsp;            int weatherMod = game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                 .getMovementMods(this);</b>
<b class="nc">&nbsp;            if (weatherMod != 0) {</b>
<b class="nc">&nbsp;                mp = Math.max(mp + weatherMod, 0);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (gravity) {</b>
<b class="nc">&nbsp;            mp = applyGravityEffectsOnMP(mp);</b>
&nbsp;        }
<b class="nc">&nbsp;        return mp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This returns how much MP is removed due to heat
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getHeatMPReduction() {
&nbsp;        int minus;
&nbsp;
<b class="nc">&nbsp;        if ((game != null) &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HEAT)) {</b>
<b class="nc">&nbsp;            if (heat &lt; 30) {</b>
<b class="nc">&nbsp;                minus = (heat / 5);</b>
<b class="nc">&nbsp;            } else if (heat &gt;= 49) {</b>
<b class="nc">&nbsp;                minus = 9;</b>
<b class="nc">&nbsp;            } else if (heat &gt;= 43) {</b>
<b class="nc">&nbsp;                minus = 8;</b>
<b class="nc">&nbsp;            } else if (heat &gt;= 37) {</b>
<b class="nc">&nbsp;                minus = 7;</b>
<b class="nc">&nbsp;            } else if (heat &gt;= 31) {</b>
<b class="nc">&nbsp;                minus = 6;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                minus = 5;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            minus = heat / 5;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return minus;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the heat generated by this Entity when standing still
&nbsp;     */
&nbsp;    public int getStandingHeat() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the heat generated by this Entity when walking/cruising
&nbsp;     */
&nbsp;    public int getWalkHeat() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s unmodified running/flank mp.
&nbsp;     */
&nbsp;    public int getOriginalRunMP() {
<b class="nc">&nbsp;        return (int) Math.ceil(getOriginalWalkMP() * 1.5);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s running/flank mp modified for heat and gravity.
&nbsp;     */
&nbsp;    public int getRunMP() {
<b class="fc">&nbsp;        return getRunMP(true, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getRunMP(boolean gravity, boolean ignoreheat,
&nbsp;                        boolean ignoremodulararmor) {
<b class="fc">&nbsp;        return (int) Math.ceil(getWalkMP(gravity, ignoreheat,</b>
&nbsp;                                         ignoremodulararmor) * 1.5);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns run MP without considering MASC
&nbsp;     */
&nbsp;    public int getRunMPwithoutMASC() {
<b class="nc">&nbsp;        return getRunMPwithoutMASC(true, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns run MP without considering MASC, optionally figuring in gravity
&nbsp;     * and possibly ignoring heat
&nbsp;     */
&nbsp;    public abstract int getRunMPwithoutMASC(boolean gravity,
&nbsp;                                            boolean ignoreheat, boolean ignoremodulararmor);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s running/flank mp as a string.
&nbsp;     */
&nbsp;    public String getRunMPasString() {
<b class="nc">&nbsp;        return Integer.toString(getRunMP());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the heat generated by this Entity when running/flanking
&nbsp;     */
&nbsp;    public int getRunHeat() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s unmodified sprint mp.
&nbsp;     */
&nbsp;    protected int getOriginalSprintMP() {
<b class="nc">&nbsp;        return getOriginalRunMP();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s running/flank mp modified for heat and gravity.
&nbsp;     */
&nbsp;    public int getSprintMP() {
<b class="nc">&nbsp;        return getRunMP();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getSprintMP(boolean gravity, boolean ignoreheat,
&nbsp;                           boolean ignoremodulararmor) {
<b class="nc">&nbsp;        return getRunMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns sprint MP without considering MASC
&nbsp;     */
&nbsp;    public int getSprintMPwithoutMASC() {
<b class="nc">&nbsp;        return getRunMPwithoutMASC();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns sprint MP without considering MASC, optionally figuring in
&nbsp;     * gravity and possibly ignoring heat
&nbsp;     */
&nbsp;    public int getSprintMPwithoutMASC(boolean gravity, boolean ignoreheat,
&nbsp;                                      boolean ignoremodulararmor) {
<b class="nc">&nbsp;        return getRunMPwithoutMASC(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s sprint mp as a string.
&nbsp;     */
&nbsp;    public String getSprintMPasString() {
<b class="nc">&nbsp;        return Integer.toString(getSprintMP());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the heat generated by this Entity when sprinting
&nbsp;     */
&nbsp;    public int getSprintHeat() {
<b class="nc">&nbsp;        return 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the gravity limit for ground movement
&nbsp;     */
&nbsp;    public int getRunningGravityLimit() {
<b class="nc">&nbsp;        return getRunMP(false, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s original jumping mp.
&nbsp;     */
&nbsp;    public int getOriginalJumpMP() {
<b class="nc">&nbsp;    	return getOriginalJumpMP(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getOriginalJumpMP(boolean ignoreModularArmor) {
&nbsp;
<b class="nc">&nbsp;        if (!ignoreModularArmor &amp;&amp; hasModularArmor()) {</b>
<b class="nc">&nbsp;            return Math.max(0, jumpMP - 1);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return jumpMP;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets this entity&#39;s original jump movement points
&nbsp;     */
&nbsp;    public void setOriginalJumpMP(int jumpMP) {
<b class="fc">&nbsp;        this.jumpMP = jumpMP;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s current jumping MP, not affected by terrain,
&nbsp;     * factored for gravity.
&nbsp;     */
&nbsp;    public int getJumpMP() {
<b class="nc">&nbsp;        return getJumpMP(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return this entity&#39;s current jump MP, possibly affected by gravity
&nbsp;     *
&nbsp;     * @param gravity
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getJumpMP(boolean gravity) {
<b class="nc">&nbsp;        if (gravity) {</b>
<b class="nc">&nbsp;            return applyGravityEffectsOnMP(getOriginalJumpMP());</b>
&nbsp;        }
<b class="nc">&nbsp;        return getOriginalJumpMP();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getJumpType() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the heat generated by this Entity when jumping for a certain amount
&nbsp;     * of MP
&nbsp;     *
&nbsp;     * @param movedMP the number of movement points spent
&nbsp;     */
&nbsp;    public int getJumpHeat(int movedMP) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this entity&#39;s current jumping MP, affected by terrain (like
&nbsp;     * water.)
&nbsp;     */
&nbsp;    public int getJumpMPWithTerrain() {
<b class="nc">&nbsp;        return getJumpMP();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tanks and certain other units can get a +1 bonus to MP if their move is entirely on pavement.
&nbsp;     *
&nbsp;     * @return true if the &lt;code&gt;Entity&lt;/code&gt; gets a movement bonus on pavement
&nbsp;     */
&nbsp;    public boolean isEligibleForPavementBonus() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the absolute elevation above ground level 0 that this entity
&nbsp;     * would be on if it were placed into the specified hex.
&nbsp;     * Hovercraft, naval vessels, and hydrofoils move on the
&nbsp;     * surface of the water
&nbsp;     */
&nbsp;    public int elevationOccupied(IHex hex) {
<b class="nc">&nbsp;        return elevationOccupied(hex, getElevation());</b>
&nbsp;    }
&nbsp;
&nbsp;    public int elevationOccupied(IHex hex, int elevation) {
<b class="nc">&nbsp;        if (hex == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((movementMode == EntityMovementMode.VTOL)</b>
&nbsp;            || (movementMode == EntityMovementMode.WIGE)) {
<b class="nc">&nbsp;            return hex.surface() + elevation;</b>
<b class="nc">&nbsp;        } else if (((movementMode == EntityMovementMode.HOVER)</b>
&nbsp;                    || (movementMode == EntityMovementMode.NAVAL)
&nbsp;                    || (movementMode == EntityMovementMode.HYDROFOIL)
<b class="nc">&nbsp;                    || hex.containsTerrain(Terrains.ICE))</b>
<b class="nc">&nbsp;                   &amp;&amp; hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;            return hex.surface();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return hex.floor();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the specified hex contains some sort of prohibited
&nbsp;     * terrain.
&nbsp;     */
&nbsp;    public boolean isLocationProhibited(Coords c) {
<b class="nc">&nbsp;        return isLocationProhibited(c, elevation);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the specified hex contains some sort of prohibited
&nbsp;     * terrain if the Entity is at the specified elevation.  Elevation generally
&nbsp;     * only matters for units like WiGEs or VTOLs.
&nbsp;     *
&nbsp;     * @param c
&nbsp;     * @param currElevation
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isLocationProhibited(Coords c, int currElevation) {
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.IMPASSABLE)) {</b>
<b class="nc">&nbsp;            return !isAirborne();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.SPACE) &amp;&amp; doomedInSpace()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Additional restrictions for hidden units
<b class="nc">&nbsp;        if (isHidden()) {</b>
&nbsp;            // Can&#39;t deploy in paved hexes
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                    || hex.containsTerrain(Terrains.ROAD)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // Can&#39;t deploy on a bridge
<b class="nc">&nbsp;            if ((hex.terrainLevel(Terrains.BRIDGE_ELEV) == currElevation)</b>
<b class="nc">&nbsp;                    &amp;&amp; hex.containsTerrain(Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // Can&#39;t deploy on the surface of water
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WATER) &amp;&amp; (currElevation == 0)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the the given board is prohibited
&nbsp;     */
&nbsp;    public boolean isBoardProhibited(int mapType) {
&nbsp;
<b class="nc">&nbsp;        if ((mapType == Board.T_GROUND) &amp;&amp; doomedOnGround()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((mapType == Board.T_ATMOSPHERE) &amp;&amp; doomedInAtmosphere()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((mapType == Board.T_SPACE) &amp;&amp; doomedInSpace()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of the type of movement used.
&nbsp;     */
&nbsp;    public abstract String getMovementString(EntityMovementType mtype);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the abbreviation of the name of the type of movement used.
&nbsp;     */
&nbsp;    public abstract String getMovementAbbr(EntityMovementType mtype);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of the location specified.
&nbsp;     */
&nbsp;    public String getLocationName(HitData hit) {
<b class="nc">&nbsp;        return getLocationName(hit.getLocation());</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract String[] getLocationNames();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of the location specified.
&nbsp;     */
&nbsp;    public String getLocationName(int loc) {
<b class="fc">&nbsp;        String[] locationNames = getLocationNames();</b>
&nbsp;
<b class="fc">&nbsp;        if ((null == locationNames) || (loc &gt;= locationNames.length)) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (loc &lt; 0) {</b>
<b class="nc">&nbsp;            return &quot;None&quot;;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return locationNames[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract String[] getLocationAbbrs();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the abbreviated name of the location specified.
&nbsp;     */
&nbsp;    public String getLocationAbbr(HitData hit) {
<b class="nc">&nbsp;        return getLocationAbbr(hit.getLocation())</b>
<b class="nc">&nbsp;               + (hit.isRear() &amp;&amp; hasRearArmor(hit.getLocation()) ? &quot;R&quot; : &quot;&quot;)</b>
<b class="nc">&nbsp;               + (((hit.getEffect() &amp; HitData.EFFECT_CRITICAL) == HitData.EFFECT_CRITICAL) ? &quot; (critical)&quot;</b>
<b class="nc">&nbsp;                                                                                           : &quot;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the abbreviated name of the location specified.
&nbsp;     */
&nbsp;    public String getLocationAbbr(int loc) {
<b class="fc">&nbsp;        String[] locationAbbrs = getLocationAbbrs();</b>
&nbsp;
<b class="fc">&nbsp;        if ((null == locationAbbrs) || (loc &gt;= locationAbbrs.length)) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (loc == Entity.LOC_NONE) {</b>
<b class="nc">&nbsp;            return &quot;None&quot;;</b>
&nbsp;        }
<b class="fc">&nbsp;        return locationAbbrs[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the location that the specified abbreviation indicates
&nbsp;     */
&nbsp;    public int getLocationFromAbbr(String abbr) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if (getLocationAbbr(i).equalsIgnoreCase(abbr)) {</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return Entity.LOC_NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls the to-hit number
&nbsp;     */
&nbsp;    public abstract HitData rollHitLocation(int table, int side,
&nbsp;                                            int aimedLocation, int aimingMode, int cover);
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls up a hit location
&nbsp;     */
&nbsp;    public abstract HitData rollHitLocation(int table, int side);
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the location that excess damage transfers to. That is, one location
&nbsp;     * inwards.
&nbsp;     */
&nbsp;    public abstract HitData getTransferLocation(HitData hit);
&nbsp;
&nbsp;    /**
&nbsp;     * int version
&nbsp;     */
&nbsp;    public int getTransferLocation(int loc) {
<b class="nc">&nbsp;        return getTransferLocation(new HitData(loc)).getLocation();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the location that is destroyed recursively. That is, one location
&nbsp;     * outwards.
&nbsp;     */
&nbsp;    public abstract int getDependentLocation(int loc);
&nbsp;
&nbsp;    /**
&nbsp;     * Does this location have rear armor?
&nbsp;     */
&nbsp;    public abstract boolean hasRearArmor(int loc);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of armor in the location specified, or ARMOR_NA, or
&nbsp;     * ARMOR_DESTROYED. Only works on front locations.
&nbsp;     */
&nbsp;    public int getArmor(int loc) {
<b class="fc">&nbsp;        return getArmor(loc, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of armor in the location hit, or IArmorState.ARMOR_NA,
&nbsp;     * or IArmorState.ARMOR_DESTROYED.
&nbsp;     */
&nbsp;    public int getArmor(HitData hit) {
<b class="nc">&nbsp;        return getArmor(hit.getLocation(), hit.isRear());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of armor in the location specified, or
&nbsp;     * IArmorState.ARMOR_NA, or IArmorState.ARMOR_DESTROYED.
&nbsp;     */
&nbsp;    public int getArmor(int loc, boolean rear) {
<b class="nc">&nbsp;        if (loc &gt;= armor.length) {</b>
<b class="nc">&nbsp;            return IArmorState.ARMOR_NA;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getArmorForReal(loc, rear);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getArmorForReal(int loc, boolean rear) {
<b class="fc">&nbsp;        return armor[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getArmorForReal(int loc) {
<b class="nc">&nbsp;        return getArmorForReal(loc, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the original amount of armor in the location specified. Only
&nbsp;     * works on front locations.
&nbsp;     */
&nbsp;    public int getOArmor(int loc) {
<b class="fc">&nbsp;        return getOArmor(loc, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the original amount of armor in the location hit.
&nbsp;     */
&nbsp;    public int getOArmor(HitData hit) {
<b class="nc">&nbsp;        return getOArmor(hit.getLocation(), hit.isRear());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the original amount of armor in the location specified, or
&nbsp;     * ARMOR_NA, or ARMOR_DESTROYED.
&nbsp;     *
&nbsp;     * @param loc  the location to check.
&nbsp;     * @param rear if true inspect the rear armor, else check the front.
&nbsp;     */
&nbsp;    public int getOArmor(int loc, boolean rear) {
<b class="fc">&nbsp;        return orig_armor[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the amount of armor in the location specified.
&nbsp;     */
&nbsp;    public void setArmor(int val, HitData hit) {
<b class="nc">&nbsp;        setArmor(val, hit.getLocation(), hit.isRear());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the amount of armor in the front location specified.
&nbsp;     */
&nbsp;    public void setArmor(int val, int loc) {
<b class="fc">&nbsp;        setArmor(val, loc, false);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the amount of armor in the location specified.
&nbsp;     *
&nbsp;     * @param val  the value of the armor (eg how many armor points)
&nbsp;     * @param loc  the location of the armor
&nbsp;     * @param rear true iff the armor is rear mounted.
&nbsp;     */
&nbsp;    public void setArmor(int val, int loc, boolean rear) {
<b class="fc">&nbsp;        armor[loc] = val;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void refreshLocations() {
<b class="nc">&nbsp;        armor = new int[locations()];</b>
<b class="nc">&nbsp;        internal = new int[locations()];</b>
<b class="nc">&nbsp;        orig_armor = new int[locations()];</b>
<b class="nc">&nbsp;        orig_internal = new int[locations()];</b>
<b class="nc">&nbsp;        crits = new CriticalSlot[locations()][];</b>
<b class="nc">&nbsp;        exposure = new int[locations()];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            crits[i] = new CriticalSlot[getNumberOfCriticals(i)];</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return The index of the first armored location (skipping vehicle body, et. al.)
&nbsp;     */
&nbsp;    public int firstArmorIndex() {
<b class="fc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes the armor on the unit. Sets the original and starting point
&nbsp;     * of the armor to the same number.
&nbsp;     */
&nbsp;    public void initializeArmor(int val, int loc) {
<b class="fc">&nbsp;        orig_armor[loc] = val;</b>
<b class="fc">&nbsp;        setArmor(val, loc);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the total amount of armor on the entity.
&nbsp;     */
&nbsp;    public int getTotalArmor() {
<b class="nc">&nbsp;        int totalArmor = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if (getArmor(i) &gt; 0) {</b>
<b class="nc">&nbsp;                totalArmor += getArmor(i);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hasRearArmor(i) &amp;&amp; (getArmor(i, true) &gt; 0)) {</b>
<b class="nc">&nbsp;                totalArmor += getArmor(i, true);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return totalArmor;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the total amount of armor on the entity.
&nbsp;     */
&nbsp;    public int getTotalOArmor() {
<b class="fc">&nbsp;        int totalArmor = 0;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;            if (getOArmor(i) &gt; 0) {</b>
<b class="fc">&nbsp;                totalArmor += getOArmor(i);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (hasRearArmor(i) &amp;&amp; (getOArmor(i, true) &gt; 0)) {</b>
<b class="fc">&nbsp;                totalArmor += getOArmor(i, true);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return totalArmor;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the percent of the armor remaining
&nbsp;     */
&nbsp;    public double getArmorRemainingPercent() {
<b class="nc">&nbsp;        if (getTotalOArmor() == 0) {</b>
<b class="nc">&nbsp;            return IArmorState.ARMOR_NA;</b>
&nbsp;        }
<b class="nc">&nbsp;        return ((double) getTotalArmor() / (double) getTotalOArmor());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of internal structure in the location hit.
&nbsp;     */
&nbsp;    public int getInternal(HitData hit) {
<b class="nc">&nbsp;        return getInternal(hit.getLocation());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of internal structure in the location specified, or
&nbsp;     * ARMOR_NA, or ARMOR_DESTROYED.
&nbsp;     */
&nbsp;    public int getInternal(int loc) {
<b class="fc">&nbsp;        return getInternalForReal(loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getInternalForReal(int loc) {
<b class="fc">&nbsp;        if ((this instanceof GunEmplacement) &amp;&amp; (loc == Tank.LOC_TURRET)) {</b>
<b class="nc">&nbsp;            return Tank.LOC_TURRET;</b>
&nbsp;        }
<b class="fc">&nbsp;        return internal[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the original amount of internal structure in the location hit.
&nbsp;     */
&nbsp;    public int getOInternal(HitData hit) {
<b class="nc">&nbsp;        return getOInternal(hit.getLocation());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the original amount of internal structure in the location
&nbsp;     * specified, or ARMOR_NA, or ARMOR_DESTROYED.
&nbsp;     */
&nbsp;    public int getOInternal(int loc) {
<b class="nc">&nbsp;        return orig_internal[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the amount of armor in the location specified.
&nbsp;     */
&nbsp;    public void setInternal(int val, HitData hit) {
<b class="nc">&nbsp;        setInternal(val, hit.getLocation());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the amount of armor in the location specified.
&nbsp;     */
&nbsp;    public void setInternal(int val, int loc) {
<b class="fc">&nbsp;        internal[loc] = val;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes the internal structure on the unit. Sets the original and
&nbsp;     * starting point of the internal structure to the same number.
&nbsp;     */
&nbsp;    public void initializeInternal(int val, int loc) {
<b class="fc">&nbsp;        orig_internal[loc] = val;</b>
<b class="fc">&nbsp;        setInternal(val, loc);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set the internal structure to the appropriate value for the mech&#39;s weight
&nbsp;     * class
&nbsp;     */
&nbsp;    public abstract void autoSetInternal();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the total amount of internal structure on the entity.
&nbsp;     */
&nbsp;    public int getTotalInternal() {
<b class="nc">&nbsp;        int totalInternal = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if (getInternal(i) &gt; 0) {</b>
<b class="nc">&nbsp;                totalInternal += getInternal(i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return totalInternal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the total original amount of internal structure on the entity.
&nbsp;     */
&nbsp;    public int getTotalOInternal() {
<b class="nc">&nbsp;        int totalInternal = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if (getOInternal(i) &gt; 0) {</b>
<b class="nc">&nbsp;                totalInternal += getOInternal(i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return totalInternal;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the percent of the armor remaining
&nbsp;     */
&nbsp;    public double getInternalRemainingPercent() {
<b class="nc">&nbsp;        return ((double) getTotalInternal() / (double) getTotalOInternal());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this location destroyed or breached?
&nbsp;     */
&nbsp;    public boolean isLocationBad(int loc) {
<b class="fc">&nbsp;        return (getInternal(loc) == IArmorState.ARMOR_DESTROYED)</b>
<b class="fc">&nbsp;               || (isLocationBlownOff(loc) &amp;&amp; !isLocationBlownOffThisPhase(loc));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isLocationTrulyDestroyed(int loc) {
<b class="nc">&nbsp;        return internal[loc] == IArmorState.ARMOR_DESTROYED;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this location destroyed or breached?
&nbsp;     */
&nbsp;    public boolean isLocationDoomed(int loc) {
<b class="nc">&nbsp;        return (getInternal(loc) == IArmorState.ARMOR_DOOMED)</b>
<b class="nc">&nbsp;               || isLocationBlownOff(loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns exposure or breached flag for location
&nbsp;     */
&nbsp;    public int getLocationStatus(int loc) {
<b class="nc">&nbsp;        return exposure[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * sets location exposure
&nbsp;     *
&nbsp;     * @param loc    the location who&#39;s exposure is to be set
&nbsp;     * @param status the status to set
&nbsp;     */
&nbsp;    public void setLocationStatus(int loc, int status) {
<b class="nc">&nbsp;        setLocationStatus(loc, status, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * sets location exposure
&nbsp;     *
&nbsp;     * @param loc         the location who&#39;s exposure is to be set
&nbsp;     * @param status      the status to set
&nbsp;     * @param allowChange allow change of breached locations
&nbsp;     */
&nbsp;    public void setLocationStatus(int loc, int status, boolean allowChange) {
<b class="nc">&nbsp;        if (allowChange || (exposure[loc] &gt; ILocationExposureStatus.BREACHED)) { // can&#39;t change BREACHED status</b>
<b class="nc">&nbsp;            exposure[loc] = status;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true is the location is a leg
&nbsp;     *
&nbsp;     * @param loc the location to check.
&nbsp;     */
&nbsp;    public boolean locationIsLeg(int loc) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the armor in the location
&nbsp;     */
&nbsp;    public String getArmorString(int loc) {
<b class="nc">&nbsp;        return getArmorString(loc, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the armor in the location
&nbsp;     */
&nbsp;    public String getArmorString(int loc, boolean rear) {
<b class="nc">&nbsp;        return Entity.armorStringFor(getArmor(loc, rear));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the internal structure in the location
&nbsp;     */
&nbsp;    public String getInternalString(int loc) {
<b class="nc">&nbsp;        return Entity.armorStringFor(getInternal(loc));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the game&#39;s internal armor representation into a human-readable
&nbsp;     * string.
&nbsp;     */
&nbsp;    public static String armorStringFor(int value) {
<b class="nc">&nbsp;        if (value == IArmorState.ARMOR_NA) {</b>
<b class="nc">&nbsp;            return &quot;N/A&quot;;</b>
<b class="nc">&nbsp;        } else if ((value == IArmorState.ARMOR_DOOMED)</b>
&nbsp;                   || (value == IArmorState.ARMOR_DESTROYED)) {
<b class="nc">&nbsp;            return &quot;***&quot;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return Integer.toString(value);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the modifier to weapons fire due to heat.
&nbsp;     */
&nbsp;    public int getHeatFiringModifier() {
<b class="nc">&nbsp;        int mod = 0;</b>
<b class="nc">&nbsp;        if (heat &gt;= 8) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (heat &gt;= 13) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (heat &gt;= 17) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (heat &gt;= 24) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean mtHeat = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HEAT);</b>
<b class="nc">&nbsp;        if (mtHeat &amp;&amp; (heat &gt;= 33)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mtHeat &amp;&amp; (heat &gt;= 41)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mtHeat &amp;&amp; (heat &gt;= 48)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((mod &gt; 0) &amp;&amp; (getCrew() != null)</b>
<b class="nc">&nbsp;                &amp;&amp; hasAbility(OptionsConstants.UNOFF_SOME_LIKE_IT_HOT)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new mount for this equipment and adds it in.
&nbsp;     */
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc)
&nbsp;            throws LocationFullException {
<b class="fc">&nbsp;        return addEquipment(etype, loc, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new mount for this equipment and adds it in.
&nbsp;     */
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;                                boolean rearMounted) throws LocationFullException {
<b class="fc">&nbsp;        return addEquipment(etype, loc, rearMounted,</b>
&nbsp;                            BattleArmor.MOUNT_LOC_NONE, false, false, false, false, false);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new mount for this equipment and adds it in.
&nbsp;     */
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;                                boolean rearMounted, int baMountLoc, boolean isArmored,
&nbsp;                                boolean isTurreted) throws LocationFullException {
<b class="nc">&nbsp;        return addEquipment(etype, loc, rearMounted, baMountLoc, isArmored,</b>
&nbsp;                            isTurreted, false, false, false);
&nbsp;    }
&nbsp;
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;                                boolean rearMounted, int baMountLoc, boolean isArmored,
&nbsp;                                boolean isTurreted, boolean isSponsonTurreted)
&nbsp;            throws LocationFullException {
<b class="nc">&nbsp;        return addEquipment(etype, loc, rearMounted, baMountLoc, isArmored,</b>
&nbsp;                            isTurreted, isSponsonTurreted, false, false);
&nbsp;    }
&nbsp;
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;            boolean rearMounted, int baMountLoc, boolean isArmored,
&nbsp;            boolean isTurreted, boolean isSponsonTurreted,
&nbsp;            boolean isPintleTurreted) throws LocationFullException {
<b class="nc">&nbsp;        return addEquipment(etype, loc, rearMounted, baMountLoc, isArmored,</b>
&nbsp;                isTurreted, isSponsonTurreted, isPintleTurreted, false);
&nbsp;    }
&nbsp;
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;                                boolean rearMounted, int baMountLoc, boolean isArmored,
&nbsp;                                boolean isTurreted, boolean isSponsonTurreted,
&nbsp;                                boolean isPintleTurreted, boolean isOmniPodded) throws LocationFullException {
<b class="fc">&nbsp;        Mounted mounted = new Mounted(this, etype);</b>
<b class="fc">&nbsp;        mounted.setArmored(isArmored);</b>
<b class="fc">&nbsp;        mounted.setBaMountLoc(baMountLoc);</b>
<b class="fc">&nbsp;        mounted.setMechTurretMounted(isTurreted);</b>
<b class="fc">&nbsp;        mounted.setSponsonTurretMounted(isSponsonTurreted);</b>
<b class="fc">&nbsp;        mounted.setPintleTurretMounted(isPintleTurreted);</b>
<b class="fc">&nbsp;        mounted.setOmniPodMounted(isOmniPodded);</b>
<b class="fc">&nbsp;        addEquipment(mounted, loc, rearMounted);</b>
<b class="fc">&nbsp;        return mounted;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * mounting weapons needs to take account of ammo
&nbsp;     *
&nbsp;     * @param etype
&nbsp;     * @param loc
&nbsp;     * @param rearMounted
&nbsp;     * @param nAmmo
&nbsp;     * @return
&nbsp;     * @throws LocationFullException
&nbsp;     */
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;                                boolean rearMounted, int nAmmo) throws LocationFullException {
<b class="nc">&nbsp;        Mounted mounted = new Mounted(this, etype);</b>
<b class="nc">&nbsp;        addEquipment(mounted, loc, rearMounted, nAmmo);</b>
<b class="nc">&nbsp;        return mounted;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * indicate whether this is a bomb mount
&nbsp;     */
&nbsp;    public Mounted addBomb(EquipmentType etype, int loc)
&nbsp;            throws LocationFullException {
<b class="nc">&nbsp;        Mounted mounted = new Mounted(this, etype);</b>
<b class="nc">&nbsp;        addBomb(mounted, loc);</b>
<b class="nc">&nbsp;        return mounted;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addBomb(Mounted mounted, int loc)
&nbsp;            throws LocationFullException {
<b class="nc">&nbsp;        mounted.setBombMounted(true);</b>
<b class="nc">&nbsp;        addEquipment(mounted, loc, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Mounted addWeaponGroup(EquipmentType etype, int loc)
&nbsp;            throws LocationFullException {
<b class="nc">&nbsp;        Mounted mounted = new Mounted(this, etype);</b>
<b class="nc">&nbsp;        addEquipment(mounted, loc, false, true);</b>
<b class="nc">&nbsp;        return mounted;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * indicate whether this is bodymounted for BAs
&nbsp;     */
&nbsp;    public Mounted addEquipment(EquipmentType etype, int loc,
&nbsp;                                boolean rearMounted, int baMountLoc, boolean dwpMounted)
&nbsp;            throws LocationFullException {
<b class="nc">&nbsp;        Mounted mounted = new Mounted(this, etype);</b>
<b class="nc">&nbsp;        mounted.setBaMountLoc(baMountLoc);</b>
<b class="nc">&nbsp;        mounted.setDWPMounted(dwpMounted);</b>
<b class="nc">&nbsp;        addEquipment(mounted, loc, rearMounted);</b>
<b class="nc">&nbsp;        return mounted;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addEquipment(Mounted mounted, int loc, boolean rearMounted,
&nbsp;                                int nAmmo) throws LocationFullException {
<b class="nc">&nbsp;        if ((mounted.getType() instanceof AmmoType) &amp;&amp; (nAmmo &gt; 1)) {</b>
<b class="nc">&nbsp;            mounted.setByShot(true);</b>
<b class="nc">&nbsp;            mounted.setShotsLeft(nAmmo);</b>
<b class="nc">&nbsp;            mounted.setOriginalShots(nAmmo);</b>
<b class="nc">&nbsp;            double tonnage = Math.max(1, nAmmo / ((AmmoType) mounted.getType()).getShots()) * mounted.getTonnage();</b>
<b class="nc">&nbsp;            mounted.setAmmoCapacity(tonnage);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addEquipment(mounted, loc, rearMounted);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void addEquipment(Mounted mounted, int loc, boolean rearMounted,
&nbsp;                                boolean isWeaponGroup) throws LocationFullException {
<b class="nc">&nbsp;        mounted.setWeaponGroup(true);</b>
&nbsp;
<b class="nc">&nbsp;        addEquipment(mounted, loc, rearMounted);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addEquipment(Mounted mounted, int loc, boolean rearMounted)
&nbsp;            throws LocationFullException {
<b class="fc">&nbsp;        mounted.setLocation(loc, rearMounted);</b>
<b class="fc">&nbsp;        equipmentList.add(mounted);</b>
&nbsp;
<b class="fc">&nbsp;        compositeTechLevel.addComponent(mounted.getType());</b>
<b class="fc">&nbsp;        if (mounted.isArmored()) {</b>
<b class="fc">&nbsp;            compositeTechLevel.addComponent(TA_ARMORED_COMPONENT);</b>
&nbsp;        }
&nbsp;
&nbsp;        // add it to the proper sub-list
<b class="fc">&nbsp;        if (mounted.getType() instanceof WeaponType) {</b>
<b class="fc">&nbsp;            totalWeaponList.add(mounted);</b>
<b class="fc">&nbsp;            if (mounted.isWeaponGroup()) {</b>
<b class="nc">&nbsp;                weaponGroupList.add(mounted);</b>
<b class="fc">&nbsp;            } else if (mounted.getType() instanceof BayWeapon) {</b>
<b class="nc">&nbsp;                weaponBayList.add(mounted);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                weaponList.add(mounted);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (mounted.getType().hasFlag(WeaponType.F_ARTILLERY)) {</b>
<b class="nc">&nbsp;                aTracker.addWeapon(mounted);</b>
&nbsp;            }
&nbsp;
&nbsp;            // one-shot launchers need their single shot of ammo added.
<b class="fc">&nbsp;            if ((mounted.getType().hasFlag(WeaponType.F_ONESHOT)</b>
<b class="fc">&nbsp;                    || (isSupportVehicle() &amp;&amp; (mounted.getType() instanceof InfantryWeapon)))</b>
<b class="fc">&nbsp;                    &amp;&amp; (AmmoType.getOneshotAmmo(mounted) != null)) {</b>
<b class="fc">&nbsp;                addOneshotAmmo(mounted);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (mounted.getType() instanceof AmmoType) {</b>
<b class="fc">&nbsp;            ammoList.add(mounted);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (mounted.getType() instanceof BombType) {</b>
<b class="nc">&nbsp;            bombList.add(mounted);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (mounted.getType() instanceof MiscType) {</b>
<b class="fc">&nbsp;            miscList.add(mounted);</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void addOneshotAmmo(Mounted mounted) throws LocationFullException {
&nbsp;        EquipmentType ammo;
&nbsp;        int shots;
<b class="fc">&nbsp;        if (mounted.getType() instanceof InfantryWeapon) {</b>
<b class="nc">&nbsp;            ammo = EquipmentType.get(EquipmentTypeLookup.INFANTRY_AMMO);</b>
<b class="nc">&nbsp;            shots = ((InfantryWeapon) mounted.getType()).getShots() * (int) mounted.getSize();</b>
&nbsp;        } else {
<b class="fc">&nbsp;            ammo = AmmoType.getOneshotAmmo(mounted);</b>
<b class="fc">&nbsp;            shots = 1;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ammo == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Equipment lookup failed for ammo for &quot; + mounted.getName());</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="fc">&nbsp;        Mounted m = new Mounted(this, ammo);</b>
<b class="fc">&nbsp;        m.setOmniPodMounted(mounted.isOmniPodMounted());</b>
&nbsp;        // BA pop-up mines can be fired individually and need a shot for each launcher in the squad.
<b class="fc">&nbsp;        if (mounted.getType().hasFlag(WeaponType.F_BA_INDIVIDUAL)) {</b>
<b class="nc">&nbsp;            shots = getTotalInternal();</b>
&nbsp;        }
<b class="fc">&nbsp;        m.setShotsLeft(shots);</b>
<b class="fc">&nbsp;        m.setOriginalShots(shots);</b>
<b class="fc">&nbsp;        mounted.setLinked(m);</b>
<b class="fc">&nbsp;        addEquipment(m, Entity.LOC_NONE, false);</b>
&nbsp;        // Fusillade gets a second round, which can be a different munition type so
&nbsp;        // need to allow for two separate mounts. Some infantry weapons have alternate
&nbsp;        // inferno ammo, which will use the same mechanism but start with zero shots.
<b class="fc">&nbsp;        if (mounted.getType().hasFlag(WeaponType.F_DOUBLE_ONESHOT)) {</b>
<b class="nc">&nbsp;            Mounted m2 = new Mounted(this, m.getType());</b>
<b class="nc">&nbsp;            m2.setOmniPodMounted(mounted.isOmniPodMounted());</b>
<b class="nc">&nbsp;            m2.setShotsLeft(shots);</b>
<b class="nc">&nbsp;            m2.setOriginalShots(shots);</b>
<b class="nc">&nbsp;            m.setLinked(m2);</b>
<b class="nc">&nbsp;            addEquipment(m2, Entity.LOC_NONE, false);</b>
<b class="nc">&nbsp;        } else if ((mounted.getType() instanceof InfantryWeapon)</b>
<b class="nc">&nbsp;                &amp;&amp; ((InfantryWeapon) mounted.getType()).hasInfernoAmmo()) {</b>
<b class="nc">&nbsp;            Mounted m2 = new Mounted(this, EquipmentType.get(EquipmentTypeLookup.INFANTRY_INFERNO_AMMO));</b>
<b class="nc">&nbsp;            m2.setOmniPodMounted(mounted.isOmniPodMounted());</b>
<b class="nc">&nbsp;            m2.setShotsLeft(0);</b>
<b class="nc">&nbsp;            m.setLinked(m2);</b>
<b class="nc">&nbsp;            addEquipment(m2, Entity.LOC_NONE, false);</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addFailedEquipment(String s) {
<b class="nc">&nbsp;        failedEquipmentList.add(s);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the equipment number of the specified equipment, or -1 if
&nbsp;     * equipment is not present.
&nbsp;     */
&nbsp;    public int getEquipmentNum(Mounted mounted) {
<b class="fc">&nbsp;        if (mounted != null) {</b>
<b class="fc">&nbsp;            return equipmentList.indexOf(mounted);</b>
&nbsp;        }
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of all equipment
&nbsp;     */
&nbsp;    public ArrayList&lt;Mounted&gt; getEquipment() {
<b class="fc">&nbsp;        return equipmentList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the equipment, specified by number
&nbsp;     */
&nbsp;    public Mounted getEquipment(int index) {
&nbsp;        try {
<b class="nc">&nbsp;            return equipmentList.get(index);</b>
<b class="nc">&nbsp;        } catch (IndexOutOfBoundsException ex) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public EquipmentType getEquipmentType(CriticalSlot cs) {
<b class="nc">&nbsp;        if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Mounted m = cs.getMount();</b>
<b class="nc">&nbsp;        return m.getType();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration which contains the name of each piece of equipment
&nbsp;     * that failed to load.
&nbsp;     */
&nbsp;    public Iterator&lt;String&gt; getFailedEquipment() {
<b class="fc">&nbsp;        return failedEquipmentList.iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getTotalAmmoOfType(EquipmentType et) {
<b class="fc">&nbsp;        int totalShotsLeft = 0;</b>
<b class="fc">&nbsp;        for (Mounted amounted : getAmmo()) {</b>
&nbsp;            // FIXME: Consider new AmmoType::equals / BombType::equals
<b class="fc">&nbsp;            if (amounted.getType().equals(et) &amp;&amp; !amounted.isDumping()) {</b>
<b class="fc">&nbsp;                totalShotsLeft += amounted.getUsableShotsLeft();</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return totalShotsLeft;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine how much ammunition (of all munition types) remains which is
&nbsp;     * compatible with the given weapon.
&nbsp;     *
&nbsp;     * @param weapon The weapon being considered
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; count of the amount of shots of all
&nbsp;     * munitions available for the given weapon.
&nbsp;     */
&nbsp;    public int getTotalMunitionsOfType(Mounted weapon) {
<b class="nc">&nbsp;        int totalShotsLeft = 0;</b>
&nbsp;        
&nbsp;        // specifically don&#39;t count caseless munitions as being of the same type as non-caseless
<b class="nc">&nbsp;        for (Mounted amounted : getAmmo()) {</b>
<b class="nc">&nbsp;            boolean canSwitchToAmmo = AmmoType.canSwitchToAmmo(weapon, (AmmoType) amounted.getType());</b>
&nbsp;
<b class="nc">&nbsp;            if (canSwitchToAmmo &amp;&amp; !amounted.isDumping()) {</b>
<b class="nc">&nbsp;                totalShotsLeft += amounted.getUsableShotsLeft();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return totalShotsLeft;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the Rules.ARC that the weapon, specified by number, fires into.
&nbsp;     */
&nbsp;    public abstract int getWeaponArc(int wn);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this weapon fires into the secondary facing arc. If
&nbsp;     * false, assume it fires into the primary.
&nbsp;     */
&nbsp;    public abstract boolean isSecondaryArcWeapon(int weaponId);
&nbsp;
&nbsp;    public Iterator&lt;Mounted&gt; getWeapons() {
<b class="nc">&nbsp;        if (usesWeaponBays()) {</b>
<b class="nc">&nbsp;            return weaponBayList.iterator();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isCapitalFighter()) {</b>
<b class="nc">&nbsp;            return weaponGroupList.iterator();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return weaponList.iterator();</b>
&nbsp;    }
&nbsp;    
&nbsp;    public ArrayList&lt;Mounted&gt; getIndividualWeaponList() {
<b class="nc">&nbsp;        return weaponList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ArrayList&lt;Mounted&gt; getWeaponList() {
<b class="fc">&nbsp;        if (usesWeaponBays()) {</b>
<b class="nc">&nbsp;            return weaponBayList;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (isCapitalFighter()) {</b>
<b class="nc">&nbsp;            return weaponGroupList;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return weaponList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Mounted&gt; getTotalWeaponList() {
&nbsp;        // return full weapon list even bay mounts and weapon groups
<b class="fc">&nbsp;        return totalWeaponList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ArrayList&lt;Mounted&gt; getWeaponBayList() {
<b class="nc">&nbsp;        return weaponBayList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ArrayList&lt;Mounted&gt; getWeaponGroupList() {
<b class="nc">&nbsp;        return weaponGroupList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first ready weapon
&nbsp;     *
&nbsp;     * @return the index number of the first available weapon, or -1 if none are
&nbsp;     * ready.
&nbsp;     */
&nbsp;    public int getFirstWeapon() {
&nbsp;        // Now phase appropriate, since we don&#39;t really care to select weapons
&nbsp;        // we can&#39;t use during this phase... do we?
<b class="nc">&nbsp;        for (Mounted mounted : getWeaponList()) {</b>
&nbsp;            // TAG only in the correct phase...
<b class="nc">&nbsp;            if ((mounted.getType().hasFlag(WeaponType.F_TAG) &amp;&amp; (game</b>
<b class="nc">&nbsp;                                                                         .getPhase() != IGame.Phase.PHASE_OFFBOARD))</b>
<b class="nc">&nbsp;                || (!mounted.getType().hasFlag(WeaponType.F_TAG) &amp;&amp; (game</b>
<b class="nc">&nbsp;                                                                             .getPhase() == IGame.Phase.PHASE_OFFBOARD))</b>
&nbsp;                //No AMS, unless it&#39;s in &#39;weapon&#39; mode
<b class="nc">&nbsp;                || (mounted.getType().hasFlag(WeaponType.F_AMS) &amp;&amp; !mounted.curMode().equals(Weapon.MODE_AMS_MANUAL))) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Artillery and Bearings-Only Capital Missiles only in the correct phase...
<b class="nc">&nbsp;            if (!(mounted.getType().hasFlag(WeaponType.F_ARTILLERY)</b>
<b class="nc">&nbsp;                    || mounted.isInBearingsOnlyMode()</b>
<b class="nc">&nbsp;                    || (this.getAltitude() == 0</b>
<b class="nc">&nbsp;                            &amp;&amp; mounted.getType() instanceof CapitalMissileWeapon))) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // No linked MGs...
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(WeaponType.F_MG)) {</b>
<b class="nc">&nbsp;                if (hasLinkedMGA(mounted)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // It must be ready to be used...
<b class="nc">&nbsp;            if (mounted.isReady()) {</b>
<b class="nc">&nbsp;                return getEquipmentNum(mounted);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the weapon, specified as a weapon id, is valid for the
&nbsp;     * current phase.
&nbsp;     *
&nbsp;     * @param weapNum
&nbsp;     * @return True if valid, else false
&nbsp;     */
&nbsp;    public boolean isWeaponValidForPhase(int weapNum) {
<b class="nc">&nbsp;        return isWeaponValidForPhase(equipmentList.get(weapNum));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the weapon, specified as a &lt;code&gt;Mounted&lt;/code&gt;, is
&nbsp;     * valid for the current phase.
&nbsp;     *
&nbsp;     * @param mounted
&nbsp;     * @return True if valid, else false
&nbsp;     */
&nbsp;    public boolean isWeaponValidForPhase(Mounted mounted) {
&nbsp;        // Start reached, now we can attempt to pick a weapon.
<b class="nc">&nbsp;        if ((mounted != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (mounted.isReady())</b>
<b class="nc">&nbsp;            &amp;&amp; (!(mounted.getType().hasFlag(WeaponType.F_AMS) &amp;&amp; mounted.curMode().equals(Weapon.MODE_AMS_ON)))</b>
<b class="nc">&nbsp;            &amp;&amp; (!(mounted.getType().hasFlag(WeaponType.F_AMS) &amp;&amp; mounted.curMode().equals(Weapon.MODE_AMS_OFF)))</b>
<b class="nc">&nbsp;            &amp;&amp; (!mounted.getType().hasFlag(WeaponType.F_AMSBAY))</b>
<b class="nc">&nbsp;            &amp;&amp; (!(mounted.getType().hasModes() &amp;&amp; mounted.curMode().equals(&quot;Point Defense&quot;)))</b>
<b class="nc">&nbsp;            &amp;&amp; ((mounted.getLinked() == null)</b>
<b class="nc">&nbsp;                || mounted.getLinked().getType().hasFlag(MiscType.F_AP_MOUNT)</b>
<b class="nc">&nbsp;                || (mounted.getLinked().getUsableShotsLeft() &gt; 0))) {</b>
&nbsp;
&nbsp;            // TAG only in the correct phase...
<b class="nc">&nbsp;            if ((mounted.getType().hasFlag(WeaponType.F_TAG)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getPhase() != IGame.Phase.PHASE_OFFBOARD))</b>
<b class="nc">&nbsp;                    || (!mounted.getType().hasFlag(WeaponType.F_TAG)</b>
<b class="nc">&nbsp;                            &amp;&amp; (game.getPhase()</b>
&nbsp;                                    == IGame.Phase.PHASE_OFFBOARD))) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Artillery or Bearings-only missiles only in the targeting phase...
<b class="nc">&nbsp;            if (!(mounted.getType().hasFlag(WeaponType.F_ARTILLERY)</b>
<b class="nc">&nbsp;                    || mounted.isInBearingsOnlyMode()</b>
<b class="nc">&nbsp;                    || (this.getAltitude() == 0</b>
<b class="nc">&nbsp;                            &amp;&amp; mounted.getType() instanceof CapitalMissileWeapon))</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_TARGETING)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // No Bearings-only missiles in the firing phase
<b class="nc">&nbsp;            if (mounted.isInBearingsOnlyMode() &amp;&amp; game.getPhase() == IGame.Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // No linked MGs...
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(WeaponType.F_MG)) {</b>
<b class="nc">&nbsp;                if (hasLinkedMGA(mounted)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Attempts to load all weapons with ammo
&nbsp;     */
&nbsp;    public void loadAllWeapons() {
<b class="fc">&nbsp;        for (Mounted mounted : getTotalWeaponList()) {</b>
<b class="fc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="fc">&nbsp;            if (wtype.getAmmoType() != AmmoType.T_NA) {</b>
<b class="fc">&nbsp;                loadWeapon(mounted);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to load the specified weapon with the first available ammo
&nbsp;     */
&nbsp;    public void loadWeapon(Mounted mounted) {
<b class="fc">&nbsp;        for (Mounted mountedAmmo : getAmmo()) {</b>
<b class="fc">&nbsp;            if (loadWeapon(mounted, mountedAmmo)) {</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to load the specified weapon with the first available ammo of the
&nbsp;     * same munition type as currently in use. If this fails, use first ammo.
&nbsp;     * 
&nbsp;     * If this is a weapon bay, try to load the weapon with ammo in the same bay,
&nbsp;     * and if it fails, load with compatible ammo in the same location.
&nbsp;     * 
&nbsp;     * If this unit is part of a train, also check the vehicles directly connected
&nbsp;     * to it for compatible ammo
&nbsp;     */
&nbsp;    public void loadWeaponWithSameAmmo(Mounted mounted) {
<b class="nc">&nbsp;        for (Mounted mountedAmmo : getAmmo()) {</b>
<b class="nc">&nbsp;            if (loadWeaponWithSameAmmo(mounted, mountedAmmo)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        //Check the unit towing this one for ammo
<b class="nc">&nbsp;        if (getTowedBy() != Entity.NONE) {</b>
<b class="nc">&nbsp;            Entity ahead = game.getEntity(getTowedBy());</b>
<b class="nc">&nbsp;            if (ahead != null) {</b>
<b class="nc">&nbsp;                for (Mounted towedByAmmo : ahead.getAmmo()) {</b>
<b class="nc">&nbsp;                    if (loadWeaponWithSameAmmo(mounted, towedByAmmo)) {</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Then check the unit towed by this one for ammo
<b class="nc">&nbsp;        if (getTowing() != Entity.NONE) {</b>
<b class="nc">&nbsp;            Entity behind = game.getEntity(getTowing());</b>
<b class="nc">&nbsp;            if (behind != null) {</b>
<b class="nc">&nbsp;                for (Mounted towingAmmo : behind.getAmmo()) {</b>
<b class="nc">&nbsp;                    if (loadWeaponWithSameAmmo(mounted, towingAmmo)) {</b>
<b class="nc">&nbsp;                        return;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // fall back to use any ammo
<b class="nc">&nbsp;        loadWeapon(mounted);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to load the specified weapon with the specified ammo. Returns true
&nbsp;     * if successful, false otherwise.
&nbsp;     */
&nbsp;    public boolean loadWeapon(Mounted mounted, Mounted mountedAmmo) {
<b class="fc">&nbsp;        boolean success = false;</b>
<b class="fc">&nbsp;        WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="fc">&nbsp;        AmmoType atype = (AmmoType) mountedAmmo.getType();</b>
&nbsp;
<b class="fc">&nbsp;        if (mountedAmmo.isAmmoUsable() &amp;&amp; !wtype.hasFlag(WeaponType.F_ONESHOT)</b>
<b class="fc">&nbsp;            &amp;&amp; (atype.getAmmoType() == wtype.getAmmoType())</b>
<b class="fc">&nbsp;            &amp;&amp; (atype.getRackSize() == wtype.getRackSize())) {</b>
<b class="fc">&nbsp;            mounted.setLinked(mountedAmmo);</b>
<b class="fc">&nbsp;            success = true;</b>
<b class="fc">&nbsp;        } else if ((wtype.hasFlag(WeaponType.F_DOUBLE_ONESHOT)</b>
<b class="fc">&nbsp;                    || (wtype.getAmmoType() == AmmoType.T_INFANTRY))</b>
<b class="nc">&nbsp;                &amp;&amp; (mountedAmmo.getLocation() == Entity.LOC_NONE)) {</b>
&nbsp;            // Make sure this ammo is in the chain, then move it to the head.
<b class="nc">&nbsp;            for (Mounted current = mounted; current != null; current = current.getLinked()) {</b>
<b class="nc">&nbsp;                if (current == mountedAmmo) {</b>
<b class="nc">&nbsp;                    current.getLinkedBy().setLinked(current.getLinked());</b>
<b class="nc">&nbsp;                    current.setLinked(mounted.getLinked());</b>
<b class="nc">&nbsp;                    mounted.setLinked(current);</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return success;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to load the specified weapon with the specified ammo. Returns true
&nbsp;     * if successful, false otherwise.
&nbsp;     */
&nbsp;    public boolean loadWeaponWithSameAmmo(Mounted mounted, Mounted mountedAmmo) {
<b class="nc">&nbsp;        AmmoType atype = (AmmoType) mountedAmmo.getType();</b>
<b class="nc">&nbsp;        Mounted oldammo = mounted.getLinked();</b>
&nbsp;
<b class="nc">&nbsp;        if ((oldammo != null) &amp;&amp; (oldammo.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                &amp;&amp; !((AmmoType) oldammo.getType()).equals(atype)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return loadWeapon(mounted, mountedAmmo);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a weapon has been fired on this unit this turn
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean weaponFired() {
<b class="nc">&nbsp;        boolean fired = false;</b>
<b class="nc">&nbsp;        for (int loc = 0; (loc &lt; locations()) &amp;&amp; !fired; loc++) {</b>
<b class="nc">&nbsp;            fired |= weaponFiredFrom(loc);</b>
&nbsp;        }
<b class="nc">&nbsp;        return fired;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a weapon has been fired from the specified location this
&nbsp;     * turn
&nbsp;     */
&nbsp;    public boolean weaponFiredFrom(int loc) {
&nbsp;        // check critical slots for used weapons
<b class="nc">&nbsp;        for (int i = 0; i &lt; this.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot slot = getCritical(loc, i);</b>
&nbsp;            // ignore empty &amp; system slots
<b class="nc">&nbsp;            if ((slot == null)</b>
<b class="nc">&nbsp;                || (slot.getType() != CriticalSlot.TYPE_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted mounted = slot.getMount();</b>
<b class="nc">&nbsp;            if ((mounted.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.isUsedThisRound()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ArrayList&lt;Mounted&gt; getAmmo() {
<b class="fc">&nbsp;        return ammoList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ArrayList&lt;Mounted&gt; getMisc() {
<b class="fc">&nbsp;        return miscList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Mounted&gt; getBombs() {
<b class="nc">&nbsp;        return bombList;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Mounted&gt; getBombs(BigInteger flag) {
<b class="nc">&nbsp;        Vector&lt;Mounted&gt; bombs = new Vector&lt;Mounted&gt;();</b>
<b class="nc">&nbsp;        for (Mounted bomb : getBombs()) {</b>
<b class="nc">&nbsp;            BombType btype = (BombType) bomb.getType();</b>
<b class="nc">&nbsp;            if (!bomb.isInoperable() &amp;&amp; (bomb.getUsableShotsLeft() &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; btype.hasFlag(flag)) {</b>
<b class="nc">&nbsp;                bombs.add(bomb);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return bombs;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Reset bomb attacks according to what bombs are available.
&nbsp;     */
&nbsp;    protected void resetBombAttacks() {
&nbsp;        // Remove all bomb attacks
<b class="nc">&nbsp;        List&lt;Mounted&gt; bombAttacksToRemove = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        EquipmentType spaceBomb = EquipmentType.get(IBomber.SPACE_BOMB_ATTACK);</b>
<b class="nc">&nbsp;        EquipmentType altBomb = EquipmentType.get(IBomber.ALT_BOMB_ATTACK);</b>
<b class="nc">&nbsp;        EquipmentType diveBomb = EquipmentType.get(IBomber.DIVE_BOMB_ATTACK);</b>
<b class="nc">&nbsp;        for (Mounted eq : equipmentList) {</b>
&nbsp;            // FIXME: Consider new BombType::equals
<b class="nc">&nbsp;            if (eq.getType().equals(spaceBomb) || eq.getType().equals(altBomb)</b>
<b class="nc">&nbsp;                    || eq.getType().equals(diveBomb)) {</b>
<b class="nc">&nbsp;                bombAttacksToRemove.add(eq);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        equipmentList.removeAll(bombAttacksToRemove);</b>
<b class="nc">&nbsp;        weaponList.removeAll(bombAttacksToRemove);</b>
<b class="nc">&nbsp;        totalWeaponList.removeAll(bombAttacksToRemove);</b>
<b class="nc">&nbsp;        weaponGroupList.removeAll(bombAttacksToRemove);</b>
<b class="nc">&nbsp;        weaponBayList.removeAll(bombAttacksToRemove);</b>
&nbsp;
<b class="nc">&nbsp;        boolean foundSpaceBomb = false;</b>
<b class="nc">&nbsp;        int numGroundBombs = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getBombs()) {</b>
&nbsp;            // Add the space bomb attack
<b class="nc">&nbsp;            if (!foundSpaceBomb</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SPACE_BOMB)</b>
<b class="nc">&nbsp;                    &amp;&amp; m.getType().hasFlag(AmmoType.F_SPACE_BOMB)</b>
<b class="nc">&nbsp;                    &amp;&amp; isFighter()</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getBoard().inSpace()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    Mounted bomb = addEquipment(spaceBomb, m.getLocation(), false);</b>
<b class="nc">&nbsp;                    if (hasETypeFlag(ETYPE_FIGHTER_SQUADRON)) {</b>
<b class="nc">&nbsp;                        bomb.setWeaponGroup(true);</b>
<b class="nc">&nbsp;                        weaponGroupList.add(bomb);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (LocationFullException ex) {</b>
&nbsp;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                foundSpaceBomb = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                    &amp;&amp; m.getType().hasFlag(AmmoType.F_GROUND_BOMB)</b>
&nbsp;                    &amp;&amp; !((this instanceof LandAirMech)
<b class="nc">&nbsp;                            &amp;&amp; (getConversionMode() == LandAirMech.CONV_MODE_MECH))) {</b>
<b class="nc">&nbsp;                if (numGroundBombs &lt; 1) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Mounted bomb = addEquipment(diveBomb, m.getLocation(), false);</b>
<b class="nc">&nbsp;                        if (hasETypeFlag(ETYPE_FIGHTER_SQUADRON)) {</b>
<b class="nc">&nbsp;                            bomb.setWeaponGroup(true);</b>
<b class="nc">&nbsp;                            weaponGroupList.add(bomb);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (LocationFullException ex) {</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                if (numGroundBombs &lt; 10 &amp;&amp; isFighter()) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Mounted bomb = addEquipment(altBomb, m.getLocation(), false);</b>
<b class="nc">&nbsp;                        if (hasETypeFlag(ETYPE_FIGHTER_SQUADRON)) {</b>
<b class="nc">&nbsp;                            bomb.setWeaponGroup(true);</b>
<b class="nc">&nbsp;                            weaponGroupList.add(bomb);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (LocationFullException ex) {</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                numGroundBombs++;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the first misc eq. whose name equals the specified string. Used
&nbsp;     * for removing broken tree clubs.
&nbsp;     */
&nbsp;    public void removeMisc(String toRemove) {
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if (mounted.getName().equals(toRemove)) {</b>
<b class="nc">&nbsp;                miscList.remove(mounted);</b>
<b class="nc">&nbsp;                equipmentList.remove(mounted);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeWeapon(String toRemove) {
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if (mounted.getName().equals(toRemove)) {</b>
<b class="nc">&nbsp;                weaponList.remove(mounted);</b>
<b class="nc">&nbsp;                equipmentList.remove(mounted);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Clear all bombs and bomb attacks
&nbsp;     */
&nbsp;    public void clearBombs() {
<b class="nc">&nbsp;        bombList.clear();</b>
<b class="nc">&nbsp;        for (Iterator&lt;Mounted&gt; i = equipmentList.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Mounted m = i.next();</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof BombType)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof DiveBombAttack)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof SpaceBombAttack)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof AltitudeBombAttack)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISAAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLAAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISASMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISASEWMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLASMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLASEWMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISLAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLLAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof BombArrowIV)</b>
&nbsp;                    /*|| m.getType() instanceof CLBombArrowIV*/
<b class="nc">&nbsp;                    || (m.getType() instanceof CLBombTAG)</b>
<b class="nc">&nbsp;                    || (m.getType() instanceof ISBombTAG)</b>
<b class="nc">&nbsp;                    || (m.getType() instanceof BombISRL10)</b>
<b class="nc">&nbsp;                    || (m.getType() instanceof AlamoMissileWeapon)) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Iterator&lt;Mounted&gt; i = weaponList.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Mounted m = i.next();</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof DiveBombAttack)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof SpaceBombAttack)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof AltitudeBombAttack)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISAAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLAAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISASMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISASEWMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLASMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLASEWMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof ISLAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof CLLAAMissileWeapon)</b>
<b class="nc">&nbsp;                || (m.getType() instanceof BombArrowIV)</b>
&nbsp;                    /*|| m.getType() instanceof CLBombArrowIV*/
<b class="nc">&nbsp;                    || (m.getType() instanceof CLBombTAG)</b>
<b class="nc">&nbsp;                    || (m.getType() instanceof ISBombTAG)</b>
<b class="nc">&nbsp;                    || (m.getType() instanceof BombISRL10)</b>
<b class="nc">&nbsp;                    || (m.getType() instanceof AlamoMissileWeapon)) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Iterator&lt;Mounted&gt; i = ammoList.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            Mounted m = i.next();</b>
<b class="nc">&nbsp;            if (m.getType() instanceof BombType) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public List&lt;Mounted&gt; getClubs() {
<b class="nc">&nbsp;        List&lt;Mounted&gt; rv = new ArrayList&lt;Mounted&gt;();</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_CLUB)) {</b>
<b class="nc">&nbsp;                rv.add(m);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return rv;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of misc equipment
&nbsp;     *
&nbsp;     * @param flag A MiscType.F_XXX
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingMisc(BigInteger flag) {
<b class="nc">&nbsp;        return hasWorkingMisc(flag, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of misc equipment
&nbsp;     *
&nbsp;     * @param flag      A MiscType.F_XXX
&nbsp;     * @param secondary A MiscType.S_XXX or -1 for don&#39;t care
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingMisc(BigInteger flag, long secondary) {
<b class="nc">&nbsp;        for (Mounted m : miscList) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType) &amp;&amp; m.isReady()) {</b>
<b class="nc">&nbsp;                MiscType type = (MiscType) m.getType();</b>
<b class="nc">&nbsp;                if (type.hasFlag(flag)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((secondary == -1) || type.hasSubType(secondary))) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasMisc(BigInteger flag) {
<b class="nc">&nbsp;        for (Mounted m : miscList) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)) {</b>
<b class="nc">&nbsp;                MiscType type = (MiscType) m.getType();</b>
<b class="nc">&nbsp;                if (type.hasFlag(flag)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return how many misc equipments with the specified flag the unit has
&nbsp;     *
&nbsp;     * @param flag
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int countWorkingMisc(BigInteger flag) {
<b class="nc">&nbsp;        return countWorkingMisc(flag, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int countWorkingMisc(BigInteger flag, int location) {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        OUTER: for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (!m.isInoperable() &amp;&amp; m.getType().hasFlag(flag)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((location == -1) || (m.getLocation() == location))) {</b>
<b class="nc">&nbsp;                if (m.getType().hasModes()) {</b>
<b class="nc">&nbsp;                    for (Enumeration&lt;EquipmentMode&gt; e = m.getType().getModes(); e.hasMoreElements();) {</b>
<b class="nc">&nbsp;                        if (e.nextElement().equals(&quot;On&quot;) &amp;&amp; !m.curMode().equals(&quot;On&quot;)) {</b>
<b class="nc">&nbsp;                            continue OUTER;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of misc equipment
&nbsp;     *
&nbsp;     * @param name MiscType internal name
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingMisc(String name) {
<b class="nc">&nbsp;        for (Mounted m : miscList) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType) &amp;&amp; m.isReady()) {</b>
<b class="nc">&nbsp;                MiscType type = (MiscType) m.getType();</b>
<b class="nc">&nbsp;                if (type.internalName.equalsIgnoreCase(name)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of misc equipment
&nbsp;     *
&nbsp;     * @param flag      A MiscType.F_XXX
&nbsp;     * @param secondary A MiscType.S_XXX or -1 for don&#39;t care
&nbsp;     * @param location  The location to check e.g. Mech.LOC_LARM
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingMisc(BigInteger flag, long secondary, int location) {
&nbsp;        // go through the location slot by slot, because of misc equipment that
&nbsp;        // is spreadable
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot crit = getCritical(location, slot);</b>
<b class="nc">&nbsp;            if ((null != crit)</b>
<b class="nc">&nbsp;                &amp;&amp; (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                Mounted mount = crit.getMount();</b>
<b class="nc">&nbsp;                if (mount == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((mount.getType() instanceof MiscType) &amp;&amp; mount.isReady()) {</b>
<b class="nc">&nbsp;                    MiscType type = (MiscType) mount.getType();</b>
<b class="nc">&nbsp;                    if (type.hasFlag(flag)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((secondary == -1) || type.hasSubType(secondary))) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of weapon
&nbsp;     *
&nbsp;     * @param flag A WeaponType.F_XXX
&nbsp;     */
&nbsp;    public boolean hasWorkingWeapon(BigInteger flag) {
<b class="nc">&nbsp;        return hasWorkingWeapon(flag, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of weapon
&nbsp;     *
&nbsp;     * @param flag      A WeaponType.F_XXX
&nbsp;     * @param secondary A WeaponType.S_XXX or -1 for don&#39;t care
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingWeapon(BigInteger flag, long secondary) {
<b class="nc">&nbsp;        for (Mounted m : weaponList) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof WeaponType) &amp;&amp; m.isReady()) {</b>
<b class="nc">&nbsp;                WeaponType type = (WeaponType) m.getType();</b>
<b class="nc">&nbsp;                if (type.hasFlag(flag)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((secondary == -1) || type.hasSubType(secondary))) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of weapon
&nbsp;     *
&nbsp;     * @param name internal name of the weapon.
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingWeapon(String name) {
<b class="nc">&nbsp;        for (Mounted m : weaponList) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof WeaponType) &amp;&amp; m.isReady()) {</b>
<b class="nc">&nbsp;                WeaponType type = (WeaponType) m.getType();</b>
<b class="nc">&nbsp;                if (type.getInternalName().equalsIgnoreCase(name)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has an arbitrary type of weapon
&nbsp;     *
&nbsp;     * @param flag      A WeaponType.F_XXX
&nbsp;     * @param secondary A WeaponType.S_XXX or -1 for don&#39;t care
&nbsp;     * @param location  The location to check e.g. Mech.LOC_LARM
&nbsp;     * @return true if at least one ready item.
&nbsp;     */
&nbsp;    public boolean hasWorkingWeapon(BigInteger flag, int secondary, int location) {
&nbsp;        // go through the location slot by slot, because of misc equipment that
&nbsp;        // is spreadable
<b class="nc">&nbsp;        for (int slot = 0; slot &lt; getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;            CriticalSlot crit = getCritical(location, slot);</b>
<b class="nc">&nbsp;            if ((null != crit)</b>
<b class="nc">&nbsp;                &amp;&amp; (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                Mounted mount = crit.getMount();</b>
<b class="nc">&nbsp;                if (mount == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((mount.getType() instanceof WeaponType) &amp;&amp; mount.isReady()) {</b>
<b class="nc">&nbsp;                    WeaponType type = (WeaponType) mount.getType();</b>
<b class="nc">&nbsp;                    if (type.hasFlag(flag)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((secondary == -1) || type.hasSubType(secondary))) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of heat that the entity can sink each turn.
&nbsp;     */
&nbsp;    public int getHeatCapacity() {
<b class="nc">&nbsp;        return getHeatCapacity(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract int getHeatCapacity(boolean radicalHeatSink);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of heat that the entity can sink each turn, factoring
&nbsp;     * in whether the entity is standing in water.
&nbsp;     */
&nbsp;    public abstract int getHeatCapacityWithWater();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns extra heat generated by engine crits
&nbsp;     */
&nbsp;    public abstract int getEngineCritHeat();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a critical hit slot
&nbsp;     */
&nbsp;    public CriticalSlot getCritical(int loc, int slot) {
<b class="fc">&nbsp;        return crits[loc][slot];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets a critical hit slot
&nbsp;     */
&nbsp;    public void setCritical(int loc, int slot, CriticalSlot cs) {
<b class="fc">&nbsp;        crits[loc][slot] = cs;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a critical to the first available slot in the location.
&nbsp;     *
&nbsp;     * @return true if there was room for the critical
&nbsp;     */
&nbsp;    public boolean addCritical(int loc, CriticalSlot cs) {
<b class="fc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="fc">&nbsp;            if (getCritical(loc, i) == null) {</b>
<b class="fc">&nbsp;                crits[loc][i] = cs;</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false; // no slot available :(</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a critical to a critical slot, first trying the supplied slot
&nbsp;     * number, and continuing from there if it&#39;s full
&nbsp;     *
&nbsp;     * @return true if there was room for the critical
&nbsp;     */
&nbsp;    public boolean addCritical(int loc, CriticalSlot cs, int slotNumber) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            if (getCritical(loc, slotNumber) == null) {</b>
<b class="nc">&nbsp;                crits[loc][slotNumber] = cs;</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            slotNumber = (slotNumber + 1) % getNumberOfCriticals(loc);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false; // no slot available :(</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Attempts to set the given slot to the given critical. If the desired slot
&nbsp;     * is full, adds the critical to the first available slot.
&nbsp;     *
&nbsp;     * @return true if the crit was succesfully added to any slot
&nbsp;     */
&nbsp;    public boolean addCritical(int loc, int slot, CriticalSlot cs) {
<b class="nc">&nbsp;        if (getCritical(loc, slot) == null) {</b>
<b class="nc">&nbsp;            setCritical(loc, slot, cs);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return addCritical(loc, cs);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all matching critical slots from the location
&nbsp;     */
&nbsp;    public void removeCriticals(int loc, CriticalSlot cs) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            if ((getCritical(loc, i) != null) &amp;&amp; getCritical(loc, i).equals(cs)) {</b>
<b class="nc">&nbsp;                setCritical(loc, i, null);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of empty critical slots in a location
&nbsp;     */
&nbsp;    public int getEmptyCriticals(int loc) {
<b class="fc">&nbsp;        int empty = 0;</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="fc">&nbsp;            if (getCritical(loc, i) == null) {</b>
<b class="fc">&nbsp;                empty++;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return empty;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of operational critical slots remaining in a location
&nbsp;     */
&nbsp;    public int getHittableCriticals(int loc) {
<b class="nc">&nbsp;        int hittable = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot crit = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((crit != null) &amp;&amp; getCritical(loc, i).isHittable()) {</b>
<b class="nc">&nbsp;                hittable++;</b>
&nbsp;            }
&nbsp;            // Reactive armor criticals in a location with armor should count
&nbsp;            // as hittable, evne though they aren&#39;t actually hittable
<b class="nc">&nbsp;            else if ((crit != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (crit.getType() == CriticalSlot.TYPE_EQUIPMENT)</b>
<b class="nc">&nbsp;                    &amp;&amp; (crit.getMount() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; crit.getMount().getType().hasFlag(MiscType.F_REACTIVE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (getArmor(loc) &gt; 0)) {</b>
<b class="nc">&nbsp;                hittable++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return hittable;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this location should transfer criticals to the next
&nbsp;     * location inwards. Checks to see that every critical in this location is
&nbsp;     * either already totally destroyed (not just hit) or was never hittable to
&nbsp;     * begin with.
&nbsp;     */
&nbsp;    public boolean canTransferCriticals(int loc) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot crit = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((crit != null) &amp;&amp; !crit.isDestroyed() &amp;&amp; crit.isEverHittable()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only Mechs have Gyros but this helps keep the code a bit cleaner.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;-1&lt;/code&gt;
&nbsp;     */
&nbsp;    public int getGyroType() {
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only Mechs have gyros, but this helps keep the code a bit cleaner.
&nbsp;     *
&nbsp;     * @return true if the &lt;code&gt;Entity&lt;/code&gt; is a Mech and has taken enough gyro hits to destroy it
&nbsp;     */
&nbsp;    public boolean isGyroDestroyed() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of operational critical slots of the specified type in
&nbsp;     * the location
&nbsp;     */
&nbsp;    public int getGoodCriticals(CriticalSlot cs, int loc) {
<b class="nc">&nbsp;        return getGoodCriticals(cs.getType(), cs.getIndex(), loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of operational critical slots of the specified type in
&nbsp;     * the location
&nbsp;     */
&nbsp;    public int getGoodCriticals(int type, int index, int loc) {
<b class="fc">&nbsp;        int operational = 0;</b>
<b class="fc">&nbsp;        Mounted m = null;</b>
<b class="fc">&nbsp;        if (type == CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;            m = getEquipment(index);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int numberOfCriticals = getNumberOfCriticals(loc);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; numberOfCriticals; i++) {</b>
<b class="fc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
&nbsp;
&nbsp;            //  Check to see if this crit mounts the supplied item
&nbsp;            //  For systems, we can compare the index, but for equipment we
&nbsp;            //  need to get the Mounted that is mounted in that index and
&nbsp;            //  compare types.  Superheavies may have two Mounted in each crit
<b class="fc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == type)) {</b>
<b class="fc">&nbsp;                if (!ccs.isDestroyed() &amp;&amp; !ccs.isBreached()) {</b>
<b class="fc">&nbsp;                    if ((type == CriticalSlot.TYPE_SYSTEM) &amp;&amp; (ccs.getIndex() == index)) {</b>
<b class="fc">&nbsp;                        operational++;</b>
<b class="fc">&nbsp;                    } else if ((type == CriticalSlot.TYPE_EQUIPMENT) &amp;&amp; (m.equals(ccs.getMount()) || m.equals(ccs</b>
<b class="nc">&nbsp;                                                                                                                      .getMount2()))) {</b>
<b class="nc">&nbsp;                        operational++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return operational;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The number of critical slots that are destroyed or breached in the
&nbsp;     * location or missing along with it (if it was blown off).
&nbsp;     */
&nbsp;    public int getBadCriticals(int type, int index, int loc) {
<b class="nc">&nbsp;        int hits = 0;</b>
<b class="nc">&nbsp;        Mounted m = null;</b>
<b class="nc">&nbsp;        if (type == CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;            m = getEquipment(index);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int numberOfCriticals = getNumberOfCriticals(loc);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; numberOfCriticals; i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
&nbsp;
&nbsp;            //  Check to see if this crit mounts the supplied item
&nbsp;            //  For systems, we can compare the index, but for equipment we
&nbsp;            //  need to get the Mounted that is mounted in that index and
&nbsp;            //  compare types.  Superheavies may have two Mounted in each crit
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == type)) {</b>
<b class="nc">&nbsp;                if (ccs.isDestroyed() || ccs.isBreached() || ccs.isMissing()) {</b>
<b class="nc">&nbsp;                    if ((type == CriticalSlot.TYPE_SYSTEM) &amp;&amp; (ccs.getIndex() == index)) {</b>
<b class="nc">&nbsp;                        hits++;</b>
<b class="nc">&nbsp;                    } else if ((type == CriticalSlot.TYPE_EQUIPMENT) &amp;&amp; (m.equals(ccs.getMount()) || m.equals(ccs</b>
<b class="nc">&nbsp;                                                                                                                      .getMount2()))) {</b>
<b class="nc">&nbsp;                        hits++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return hits;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Number of slots damaged (but not breached) in a location
&nbsp;     */
&nbsp;    public int getDamagedCriticals(int type, int index, int loc) {
<b class="nc">&nbsp;        int hits = 0;</b>
<b class="nc">&nbsp;        Mounted m = null;</b>
<b class="nc">&nbsp;        if (type == CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;            m = getEquipment(index);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int numberOfCriticals = getNumberOfCriticals(loc);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; numberOfCriticals; i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
&nbsp;
&nbsp;            //  Check to see if this crit mounts the supplied item
&nbsp;            //  For systems, we can compare the index, but for equipment we
&nbsp;            //  need to get the Mounted that is mounted in that index and
&nbsp;            //  compare types.  Superheavies may have two Mounted in each crit
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == type)) {</b>
<b class="nc">&nbsp;                if (ccs.isDamaged()) {</b>
<b class="nc">&nbsp;                    if ((type == CriticalSlot.TYPE_SYSTEM) &amp;&amp; (ccs.getIndex() == index)) {</b>
<b class="nc">&nbsp;                        hits++;</b>
<b class="nc">&nbsp;                    } else if ((type == CriticalSlot.TYPE_EQUIPMENT) &amp;&amp; (m.equals(ccs.getMount()) || m.equals(ccs</b>
<b class="nc">&nbsp;                                                                                                                      .getMount2()))) {</b>
<b class="nc">&nbsp;                        hits++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return hits;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Number of slots doomed, missing or destroyed in a location
&nbsp;     */
&nbsp;    public int getHitCriticals(int type, int index, int loc) {
<b class="nc">&nbsp;        int hits = 0;</b>
<b class="nc">&nbsp;        Mounted m = null;</b>
<b class="nc">&nbsp;        if (type == CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;            m = getEquipment(index);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int numberOfCriticals = getNumberOfCriticals(loc);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; numberOfCriticals; i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
&nbsp;
&nbsp;            //  Check to see if this crit mounts the supplied item
&nbsp;            //  For systems, we can compare the index, but for equipment we
&nbsp;            //  need to get the Mounted that is mounted in that index and
&nbsp;            //  compare types.  Superheavies may have two Mounted in each crit
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == type)) {</b>
<b class="nc">&nbsp;                if (ccs.isDamaged() || ccs.isBreached() || ccs.isMissing()) {</b>
<b class="nc">&nbsp;                    if ((type == CriticalSlot.TYPE_SYSTEM) &amp;&amp; (ccs.getIndex() == index)) {</b>
<b class="nc">&nbsp;                        hits++;</b>
<b class="nc">&nbsp;                    } else if ((type == CriticalSlot.TYPE_EQUIPMENT) &amp;&amp; (m.equals(ccs.getMount()) || m.equals(ccs</b>
<b class="nc">&nbsp;                                                                                                                      .getMount2()))) {</b>
<b class="nc">&nbsp;                        hits++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return hits;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected abstract int[] getNoOfSlots();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of total critical slots in a location
&nbsp;     */
&nbsp;    public int getNumberOfCriticals(int loc) {
<b class="fc">&nbsp;        int[] noOfSlots = getNoOfSlots();</b>
<b class="fc">&nbsp;        if ((null == noOfSlots) || (loc &gt;= noOfSlots.length)</b>
&nbsp;            || (loc == LOC_NONE)) {
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        return noOfSlots[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of critical slots present in the section, destroyed or
&nbsp;     * not.
&nbsp;     */
&nbsp;    public int getNumberOfCriticals(int type, int index, int loc) {
<b class="nc">&nbsp;        int num = 0;</b>
<b class="nc">&nbsp;        int numCrits = getNumberOfCriticals(loc);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; numCrits; i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == type)</b>
<b class="nc">&nbsp;                &amp;&amp; (ccs.getIndex() == index)) {</b>
<b class="nc">&nbsp;                num++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return num;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of critical slots present in the section, destroyed or
&nbsp;     * not.
&nbsp;     */
&nbsp;    public int getNumberOfCriticals(EquipmentType etype, int loc) {
<b class="nc">&nbsp;        int num = 0;</b>
<b class="nc">&nbsp;        int numberOfCriticals = getNumberOfCriticals(loc);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; numberOfCriticals; i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (getEquipmentType(ccs) != null)</b>
<b class="nc">&nbsp;                &amp;&amp; getEquipmentType(ccs).equals(etype)) {</b>
<b class="nc">&nbsp;                num++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return num;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of critical slots present in the mech, destroyed or
&nbsp;     * not.
&nbsp;     */
&nbsp;    public int getNumberOfCriticals(EquipmentType etype) {
<b class="nc">&nbsp;        int num = 0;</b>
<b class="nc">&nbsp;        int locations = locations();</b>
<b class="nc">&nbsp;        for (int l = 0; l &lt; locations; l++) {</b>
<b class="nc">&nbsp;            num += getNumberOfCriticals(etype, l);</b>
&nbsp;        }
<b class="nc">&nbsp;        return num;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns how many of the given equipment are present in the mech,
&nbsp;     * destroyed or not.
&nbsp;     */
&nbsp;    public int getNumberOf(EquipmentType etype) {
<b class="nc">&nbsp;        int total = 0;</b>
<b class="nc">&nbsp;        for (Mounted m : equipmentList) {</b>
<b class="nc">&nbsp;            if (m.getType().equals(etype)) {</b>
<b class="nc">&nbsp;                total++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return total;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity has a hip crit. Overridden by sub-classes.
&nbsp;     */
&nbsp;    public boolean hasHipCrit() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity has a leg actuator crit
&nbsp;     */
&nbsp;    public boolean hasLegActuatorCrit() {
<b class="nc">&nbsp;        boolean hasCrit = false;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if (locationIsLeg(i)) {</b>
<b class="nc">&nbsp;                if ((getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                     Mech.ACTUATOR_HIP, i) &gt; 0)
<b class="nc">&nbsp;                    || (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Mech.ACTUATOR_UPPER_LEG, i) &gt; 0)
<b class="nc">&nbsp;                    || (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Mech.ACTUATOR_LOWER_LEG, i) &gt; 0)
<b class="nc">&nbsp;                    || (getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                        Mech.ACTUATOR_FOOT, i) &gt; 0)) {
<b class="nc">&nbsp;                    hasCrit = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return hasCrit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if there is at least 1 functional system of the type
&nbsp;     * specified in the location
&nbsp;     */
&nbsp;    public boolean hasWorkingSystem(int system, int loc) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == CriticalSlot.TYPE_SYSTEM)</b>
<b class="nc">&nbsp;                &amp;&amp; (ccs.getIndex() == system) &amp;&amp; !ccs.isDamaged()</b>
<b class="nc">&nbsp;                &amp;&amp; !ccs.isBreached()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns false if there is at least one non-repairable critical slot for
&nbsp;     * this system in the given location
&nbsp;     */
&nbsp;    public boolean isSystemRepairable(int system, int loc) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == CriticalSlot.TYPE_SYSTEM)</b>
<b class="nc">&nbsp;                &amp;&amp; (ccs.getIndex() == system) &amp;&amp; !ccs.isRepairable()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the the location has a system of the type, whether is
&nbsp;     * destroyed or not
&nbsp;     */
&nbsp;    public boolean hasSystem(int system, int loc) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot ccs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((ccs != null) &amp;&amp; (ccs.getType() == CriticalSlot.TYPE_SYSTEM)</b>
<b class="nc">&nbsp;                &amp;&amp; (ccs.getIndex() == system)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if this entity is wielding any vibroblades
&nbsp;     *
&nbsp;     * @return always returns &lt;code&gt;false&lt;/code&gt; as Only biped mechs can wield
&nbsp;     * vibroblades
&nbsp;     */
&nbsp;    public boolean hasVibroblades() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if any heat is given off by an active vibro blade
&nbsp;     *
&nbsp;     * @param location
&nbsp;     * @return always returns &lt;code&gt;0&lt;/code&gt; as Only biped mechs can wield
&nbsp;     * vibroblades
&nbsp;     */
&nbsp;    public int getActiveVibrobladeHeat(int location) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getActiveVibrobladeHeat(int location, boolean ignoreMode) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have any shields. a mech can have up to 2 shields.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;shieldCount&lt;/code&gt; is greater than 0
&nbsp;     * else &lt;code&gt;false&lt;/code&gt;
&nbsp;     */
&nbsp;    public boolean hasShield() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check to see how many shields of a certian size a mek has. you can have
&nbsp;     * up to shields per mech. However they can be of different size and each
&nbsp;     * size has its own draw backs. So check each size and add modifers based on
&nbsp;     * the number shields of that size.
&nbsp;     */
&nbsp;    public int getNumberOfShields(long size) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have an active shield This should only be called after
&nbsp;     * hasShield has been called.
&nbsp;     */
&nbsp;    public boolean hasActiveShield(int location, boolean rear) {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have an active shield This should only be called by
&nbsp;     * hasActiveShield(location,rear)
&nbsp;     */
&nbsp;    public boolean hasActiveShield(int location) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a passive shield This should only be called after
&nbsp;     * hasShield has been called.
&nbsp;     */
&nbsp;    public boolean hasPassiveShield(int location, boolean rear) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a passive shield This should only be called by
&nbsp;     * hasPassiveShield(location,rear)
&nbsp;     */
&nbsp;    public boolean hasPassiveShield(int location) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have an shield in no defense mode
&nbsp;     */
&nbsp;    public boolean hasNoDefenseShield(int location) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks to see if a unit has Underwater Maneuvering Units
&nbsp;     *
&nbsp;     * @return &lt;code&gt;boolean&lt;/code&gt; if the entity has usable UMU crits.
&nbsp;     */
&nbsp;    public boolean hasUMU() {
<b class="nc">&nbsp;        return getActiveUMUCount() &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This counts the number of UMU&#39;s a Mech has that are still viable
&nbsp;     *
&nbsp;     * @return number &lt;code&gt;int&lt;/code&gt;of useable UMU&#39;s
&nbsp;     */
&nbsp;    public int getActiveUMUCount() {
<b class="nc">&nbsp;        if (hasShield() &amp;&amp; (getNumberOfShields(MiscType.S_SHIELD_LARGE) &gt; 0)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_UMU)</b>
<b class="nc">&nbsp;                &amp;&amp; !(m.isDestroyed() || m.isMissing() || m.isBreached())) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This returns all UMU a mech has.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;int&lt;/code&gt;Total number of UMUs a mech has.
&nbsp;     */
&nbsp;    public int getAllUMUCount() {
<b class="nc">&nbsp;        if (hasShield() &amp;&amp; (getNumberOfShields(MiscType.S_SHIELD_LARGE) &gt; 0)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_UMU)) {</b>
<b class="nc">&nbsp;                count++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a functioning ECM unit?
&nbsp;     */
&nbsp;    public boolean hasActiveECM() {
<b class="nc">&nbsp;        return hasActiveECM(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * check if we have an active ECM unit for stealth armor purposes
&nbsp;     *
&nbsp;     * @param stealth
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasActiveECM(boolean stealth) {
&nbsp;        // no ECM in space unless strat op option enabled
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!isShutDown()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
&nbsp;                // EQ equipment does not count for stealth armor
<b class="nc">&nbsp;                if (stealth &amp;&amp; type.hasFlag(MiscType.F_EW_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // TacOps p. 100 Angle ECM can have 1 ECM and 1 ECCM at the same
&nbsp;                // time
<b class="nc">&nbsp;                if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                    &amp;&amp; type.hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.curMode().equals(&quot;ECM&quot;)</b>
<b class="nc">&nbsp;                        || m.curMode().equals(&quot;ECM &amp; ECCM&quot;) || m</b>
<b class="nc">&nbsp;                        .curMode().equals(&quot;ECM &amp; Ghost Targets&quot;))) {</b>
<b class="nc">&nbsp;                    return !(m.isInoperable());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a functioning ECM unit?
&nbsp;     */
&nbsp;    public boolean hasActiveAngelECM() {
&nbsp;        // no ECM in space unless strat op option enabled
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_ANGEL_ECM)</b>
<b class="nc">&nbsp;            &amp;&amp; !isShutDown()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;                if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                    &amp;&amp; type.hasFlag(MiscType.F_ANGEL_ECM)</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.curMode().equals(&quot;ECM&quot;)</b>
<b class="nc">&nbsp;                        || m.curMode().equals(&quot;ECM &amp; ECCM&quot;) || m</b>
<b class="nc">&nbsp;                        .curMode().equals(&quot;ECM &amp; Ghost Targets&quot;))) {</b>
<b class="nc">&nbsp;                    return !(m.isInoperable());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * WOR Does the mech have a functioning ECM unit?
&nbsp;     */
&nbsp;    public boolean hasActiveNovaECM() {
&nbsp;        // no ECM in space unless strat op option enabled
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!isShutDown()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;                if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_NOVA)</b>
<b class="nc">&nbsp;                    &amp;&amp; m.curMode().equals(&quot;ECM&quot;)) {</b>
<b class="nc">&nbsp;                    return !(m.isInoperable());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a functioning ECM unit, tuned to ghost target
&nbsp;     * generation?
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a functioning ECM unit, tuned to ghost target
&nbsp;     * generation?
&nbsp;     */
&nbsp;    public boolean hasGhostTargets(boolean active) {
&nbsp;        // no Ghost Targets in space unless strat op option enabled
<b class="nc">&nbsp;        if (game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if you failed your ghost target PSR, then it doesn&#39;t matter
<b class="nc">&nbsp;        if ((active &amp;&amp; (getGhostTargetRollMoS() &lt; 0)) || isShutDown()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean hasGhost = false;</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
&nbsp;            // TacOps p. 100 Angle ECM can have ECM/ECCM and Ghost Targets at
&nbsp;            // the same time
<b class="nc">&nbsp;            if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; type.hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;                &amp;&amp; (m.curMode().equals(&quot;Ghost Targets&quot;)</b>
<b class="nc">&nbsp;                    || m.curMode().equals(&quot;ECM &amp; Ghost Targets&quot;) || m</b>
<b class="nc">&nbsp;                    .curMode().equals(&quot;ECCM &amp; Ghost Targets&quot;))</b>
<b class="nc">&nbsp;                &amp;&amp; !(m.isInoperable() || getCrew().isUnconscious())) {</b>
<b class="nc">&nbsp;                hasGhost = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; type.hasFlag(MiscType.F_COMMUNICATIONS)</b>
<b class="nc">&nbsp;                &amp;&amp; m.curMode().equals(&quot;Ghost Targets&quot;)</b>
<b class="nc">&nbsp;                &amp;&amp; (getTotalCommGearTons() &gt;= 7)</b>
<b class="nc">&nbsp;                &amp;&amp; !(m.isInoperable() || getCrew().isUnconscious())) {</b>
<b class="nc">&nbsp;                hasGhost = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return hasGhost;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if this entity has a functional ECM unit that is using
&nbsp;     * ECCM.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity has angelecm and it is in ECCM
&nbsp;     * mode &lt;code&gt;false&lt;/code&gt; if the entity does not have angel ecm or
&nbsp;     * it is not in eccm mode or it is damaged.
&nbsp;     */
&nbsp;    public boolean hasActiveECCM() {
&nbsp;        // no ECM in space unless strat op option enabled
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_ECCM) || game</b>
<b class="nc">&nbsp;                .getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) &amp;&amp; !isShutDown()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
&nbsp;                // TacOps p. 100 Angle ECM can have 1 ECM and 1 ECCM at the same
&nbsp;                // time
<b class="nc">&nbsp;                if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((type.hasFlag(MiscType.F_ECM) &amp;&amp; (m.curMode()</b>
<b class="nc">&nbsp;                                                           .equals(&quot;ECCM&quot;)</b>
<b class="nc">&nbsp;                                                          || m.curMode().equals(&quot;ECM &amp; ECCM&quot;) || m</b>
<b class="nc">&nbsp;                        .curMode().equals(&quot;ECCM &amp; Ghost Targets&quot;))) || (type</b>
<b class="nc">&nbsp;                                                                                .hasFlag(MiscType.F_COMMUNICATIONS) &amp;&amp; m</b>
<b class="nc">&nbsp;                                                                                .curMode().equals(&quot;ECCM&quot;)))) {</b>
<b class="nc">&nbsp;                    return !m.isInoperable();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if this unit has a functional AngelECM unit that is using
&nbsp;     * ECCM.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity has angelecm and it is in ECCM
&nbsp;     * mode &lt;code&gt;false&lt;/code&gt; if the entity does not have angel ecm or
&nbsp;     * it is not in eccm mode or it is damaged.
&nbsp;     */
&nbsp;    public boolean hasActiveAngelECCM() {
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_ANGEL_ECM)</b>
<b class="nc">&nbsp;            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_ECCM)</b>
<b class="nc">&nbsp;            &amp;&amp; !isShutDown()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;                if ((type instanceof MiscType)</b>
<b class="nc">&nbsp;                    &amp;&amp; type.hasFlag(MiscType.F_ANGEL_ECM)</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.curMode().equals(&quot;ECCM&quot;)</b>
<b class="nc">&nbsp;                        || m.curMode().equals(&quot;ECM &amp; ECCM&quot;) || m</b>
<b class="nc">&nbsp;                        .curMode().equals(&quot;ECCM &amp; Ghost Targets&quot;))) {</b>
<b class="nc">&nbsp;                    return !(m.isDestroyed() || m.isMissing() || m.isBreached() || isShutDown());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * What&#39;s the range of the ECM equipment? Infantry can have ECM that just
&nbsp;     * covers their own hex.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; range of this unit&#39;s ECM. This value will be
&nbsp;     * &lt;code&gt;Entity.NONE&lt;/code&gt; if no ECM is active.
&nbsp;     */
&nbsp;    public int getECMRange() {
&nbsp;        // no ECM in space unless strat op option enabled
<b class="nc">&nbsp;        if (game.getBoard().inSpace()</b>
<b class="nc">&nbsp;            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;            return Entity.NONE;</b>
&nbsp;        }
&nbsp;        // If we have stealth up and running, there&#39;s no bubble.
<b class="nc">&nbsp;        if (isStealthOn()) {</b>
<b class="nc">&nbsp;            return Entity.NONE;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!isShutDown()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;                if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;                    &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                    if (type.hasFlag(MiscType.F_SINGLE_HEX_ECM)) {</b>
<b class="nc">&nbsp;                        return 0;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    int toReturn = 6;</b>
<b class="nc">&nbsp;                    if (type.hasFlag(MiscType.F_ANGEL_ECM)</b>
&nbsp;                        &amp;&amp; (this instanceof BattleArmor)) {
<b class="nc">&nbsp;                        toReturn = 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (type.hasFlag(MiscType.F_EW_EQUIPMENT)</b>
<b class="nc">&nbsp;                        || type.hasFlag(MiscType.F_NOVA)</b>
<b class="nc">&nbsp;                        || type.hasFlag(MiscType.F_WATCHDOG)) {</b>
<b class="nc">&nbsp;                        toReturn = 3;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (game.getPlanetaryConditions().hasEMI()) {</b>
<b class="nc">&nbsp;                        return toReturn * 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return toReturn;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the mech have a functioning BAP? This is just for the basic BAP for
&nbsp;     * Beagle BloodHound WatchDog Clan Active or Light.
&nbsp;     */
&nbsp;    public boolean hasBAP() {
<b class="nc">&nbsp;        return hasBAP(true);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Does a unit on the same C3 network have a BAP?
&nbsp;     * Used to share BAP targeting bonuses against targets in woods
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasNetworkBAP() {
<b class="nc">&nbsp;        return networkBAP;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void setNetworkBAP(boolean BAP) {
<b class="nc">&nbsp;        networkBAP = BAP;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean hasBAP(boolean checkECM) {
<b class="nc">&nbsp;        if (((game != null) &amp;&amp; game.getPlanetaryConditions().hasEMI())</b>
<b class="nc">&nbsp;            || isShutDown()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_BAP)) {</b>
&nbsp;
<b class="nc">&nbsp;                if (!m.isInoperable()) {</b>
&nbsp;                    // Beagle Isn&#39;t affected by normal ECM
<b class="nc">&nbsp;                    if (type.getName().equals(&quot;Beagle Active Probe&quot;)) {</b>
&nbsp;
<b class="nc">&nbsp;                        if ((game != null)</b>
&nbsp;                            &amp;&amp; checkECM
<b class="nc">&nbsp;                            &amp;&amp; ComputeECM.isAffectedByAngelECM(this,</b>
<b class="nc">&nbsp;                                                               getPosition(), getPosition())) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return !checkECM</b>
&nbsp;                           || (game == null)
<b class="nc">&nbsp;                           || !ComputeECM.isAffectedByECM(this, getPosition(),</b>
<b class="nc">&nbsp;                                                          getPosition());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // check for Manei Domini implants
<b class="nc">&nbsp;        if (((hasAbility(OptionsConstants.MD_CYBER_IMP_AUDIO)</b>
<b class="nc">&nbsp;        	|| hasAbility(OptionsConstants.MD_CYBER_IMP_VISUAL)</b>
<b class="nc">&nbsp;        	|| hasAbility(OptionsConstants.MD_MM_IMPLANTS))</b>
&nbsp;        		&amp;&amp; (this instanceof Infantry) &amp;&amp; !(this instanceof BattleArmor))
<b class="nc">&nbsp;            || (hasAbility(OptionsConstants.MD_MM_IMPLANTS)</b>
<b class="nc">&nbsp;            		&amp;&amp; (hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;			|| hasAbility(OptionsConstants.MD_BVDNI))))</b>
&nbsp;
&nbsp;        {
<b class="nc">&nbsp;            return !checkECM</b>
<b class="nc">&nbsp;                   || !ComputeECM.isAffectedByECM(this, getPosition(),</b>
<b class="nc">&nbsp;                                                  getPosition());</b>
&nbsp;        }
&nbsp;        // check for quirk
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_IMPROVED_SENSORS)) {</b>
<b class="nc">&nbsp;            return !checkECM</b>
<b class="nc">&nbsp;                   || !ComputeECM.isAffectedByECM(this, getPosition(),</b>
<b class="nc">&nbsp;                                                  getPosition());</b>
&nbsp;        }
&nbsp;        // check for SPA
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.MISC_EAGLE_EYES)) {</b>
<b class="nc">&nbsp;            return !checkECM || !ComputeECM.isAffectedByECM(this, getPosition(), getPosition());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * What&#39;s the range of the BAP equipment?
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; range of this unit&#39;s BAP. This value will be
&nbsp;     * &lt;code&gt;Entity.NONE&lt;/code&gt; if no BAP is active.
&nbsp;     */
&nbsp;    public int getBAPRange() {
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().hasEMI() || isShutDown()) {</b>
<b class="nc">&nbsp;            return Entity.NONE;</b>
&nbsp;        }
&nbsp;        // check for Manei Domini implants
<b class="nc">&nbsp;        int cyberBonus = 0;</b>
<b class="nc">&nbsp;        if (((hasAbility(OptionsConstants.MD_CYBER_IMP_AUDIO)</b>
<b class="nc">&nbsp;        		|| hasAbility(OptionsConstants.MD_MM_IMPLANTS))</b>
<b class="nc">&nbsp;        		|| hasAbility(OptionsConstants.MD_CYBER_IMP_VISUAL)</b>
&nbsp;                	&amp;&amp; (this instanceof Infantry) &amp;&amp; !(this instanceof BattleArmor))
<b class="nc">&nbsp;                || (hasAbility(OptionsConstants.MD_MM_IMPLANTS)</b>
<b class="nc">&nbsp;                	&amp;&amp; (hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;    			|| hasAbility(OptionsConstants.MD_BVDNI)))) {</b>
<b class="nc">&nbsp;            cyberBonus = 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for quirks
<b class="nc">&nbsp;        int quirkBonus = 0;</b>
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_IMPROVED_SENSORS)) {</b>
<b class="nc">&nbsp;            if (isClan()) {</b>
<b class="nc">&nbsp;                quirkBonus = 5;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                quirkBonus = 4;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check for SPA
<b class="nc">&nbsp;        int spaBonus = 0;</b>
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.MISC_EAGLE_EYES)) {</b>
<b class="nc">&nbsp;            spaBonus = 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType type = m.getType();</b>
<b class="nc">&nbsp;            if ((type instanceof MiscType) &amp;&amp; type.hasFlag(MiscType.F_BAP)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.isInoperable()) {</b>
&nbsp;
&nbsp;                // Quirk bonus is only 2 if equiped with BAP
<b class="nc">&nbsp;                if (quirkBonus &gt; 0) {</b>
<b class="nc">&nbsp;                    quirkBonus = 2;</b>
&nbsp;                }
&nbsp;                // System.err.println(&quot;BAP type name: &quot;+m.getName()+&quot;
&nbsp;                // internalName: &quot;+((MiscType)m.getType()).internalName);
&nbsp;                // in space the range of all BAPs is given by the mode
<b class="nc">&nbsp;                if (game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                    if (m.curMode().equals(&quot;Medium&quot;)) {</b>
<b class="nc">&nbsp;                        return 12;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return 6;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (m.getName().equals(&quot;Bloodhound Active Probe (THB)&quot;)</b>
<b class="nc">&nbsp;                    || m.getName().equals(Sensor.BAP)) {</b>
<b class="nc">&nbsp;                    return 8 + cyberBonus + quirkBonus + spaBonus;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((m.getType()).getInternalName().equals(Sensor.CLAN_AP)</b>
<b class="nc">&nbsp;                    || (m.getType()).getInternalName().equals(</b>
&nbsp;                        Sensor.WATCHDOG)
<b class="nc">&nbsp;                    || (m.getType()).getInternalName().equals(Sensor.NOVA)) {</b>
<b class="nc">&nbsp;                    return 5 + cyberBonus + quirkBonus + spaBonus;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((m.getType()).getInternalName().equals(Sensor.LIGHT_AP)</b>
<b class="nc">&nbsp;                    || (m.getType().getInternalName()</b>
<b class="nc">&nbsp;                         .equals(Sensor.CLBALIGHT_AP))</b>
<b class="nc">&nbsp;                    || (m.getType().getInternalName()</b>
<b class="nc">&nbsp;                         .equals(Sensor.ISBALIGHT_AP))) {</b>
<b class="nc">&nbsp;                    return 3 + cyberBonus + quirkBonus + spaBonus;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (m.getType().getInternalName().equals(Sensor.ISIMPROVED)</b>
<b class="nc">&nbsp;                    || (m.getType().getInternalName()</b>
<b class="nc">&nbsp;                         .equals(Sensor.CLIMPROVED))) {</b>
<b class="nc">&nbsp;                    return 2 + cyberBonus + quirkBonus + spaBonus;</b>
&nbsp;                }
<b class="nc">&nbsp;                return 4 + cyberBonus + quirkBonus + spaBonus;// everthing else should be</b>
&nbsp;                // range 4
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if ((cyberBonus + quirkBonus + spaBonus) &gt; 0) {</b>
<b class="nc">&nbsp;            return cyberBonus + quirkBonus + spaBonus;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns wether or not this entity has a Targeting Computer.
&nbsp;     */
&nbsp;    public boolean hasTargComp() {
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_TARGCOMP)) {</b>
<b class="nc">&nbsp;                return !m.isInoperable();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns wether or not this entity has a Targeting Computer that is in
&nbsp;     * aimed shot mode.
&nbsp;     */
&nbsp;    public boolean hasAimModeTargComp() {
<b class="nc">&nbsp;        if (hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;            if (this instanceof Mech) {</b>
<b class="nc">&nbsp;                if (((Mech) this).getCockpitStatus() == Mech.COCKPIT_AIMED_SHOT) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_TARGCOMP)</b>
<b class="nc">&nbsp;                &amp;&amp; m.curMode().equals(&quot;Aimed shot&quot;)) {</b>
<b class="nc">&nbsp;                return !m.isInoperable();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether this &#39;mech has a C3 Slave or not.
&nbsp;     */
&nbsp;    public boolean hasC3S() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getType().hasFlag(MiscType.F_C3S) || m.getType()</b>
<b class="nc">&nbsp;                                                            .hasFlag(MiscType.F_C3SBS)) &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only Meks can have CASE II so all other entites return false.
&nbsp;     *
&nbsp;     * @return true iff the mech has CASE II.
&nbsp;     */
&nbsp;    public boolean hasCASEII() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only Meks have CASE II so all other entites return false.
&nbsp;     *
&nbsp;     * @param location
&nbsp;     * @return true iff the mech has CASE II at this location.
&nbsp;     */
&nbsp;    public boolean hasCASEII(int location) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does this entity have an undamaged HarJel system in this location?
&nbsp;     * (Type-dependent, defaults to false.)
&nbsp;     * Does not include Harjel II or Harjel III, as they do not prevent breach
&nbsp;     * checks like Harjel does.
&nbsp;     *
&nbsp;     * @param location the &lt;code&gt;int&lt;/code&gt; location to check
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; value indicating a present HarJel system
&nbsp;     */
&nbsp;    public boolean hasHarJelIn(int location) {
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if ((mounted.getLocation() == location)</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.isReady()</b>
<b class="nc">&nbsp;                &amp;&amp; (mounted.getType().hasFlag(MiscType.F_HARJEL))) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasBoostedC3() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getType().hasFlag(MiscType.F_C3SBS) || m.getType().hasFlag(</b>
&nbsp;                    WeaponType.F_C3MBS))
<b class="nc">&nbsp;                &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity has a C3 Master.
&nbsp;     *
&nbsp;     * @return true if it has a working C3M computer and has a master.
&nbsp;     */
&nbsp;    public boolean hasC3M() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getType().hasFlag(WeaponType.F_C3M) || m.getType()</b>
<b class="nc">&nbsp;                                                              .hasFlag(WeaponType.F_C3MBS)) &amp;&amp; !m.isInoperable()) {</b>
&nbsp;                // If this unit is configured as a company commander,
&nbsp;                // and if this computer is the company master, then
&nbsp;                // this unit does not have a lance master computer.
<b class="nc">&nbsp;                if (C3MasterIs(this)</b>
<b class="nc">&nbsp;                    &amp;&amp; (c3CompanyMasterIndex == getEquipmentNum(m))) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasC3MM() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Have we already determined that there&#39;s no company command master?
<b class="nc">&nbsp;        if (c3CompanyMasterIndex == LOC_NONE) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Do we need to determine that there&#39;s no company command master?
<b class="nc">&nbsp;        if (c3CompanyMasterIndex == LOC_DESTROYED) {</b>
<b class="nc">&nbsp;            Iterator&lt;Mounted&gt; e = getEquipment().iterator();</b>
<b class="nc">&nbsp;            while ((c3CompanyMasterIndex == LOC_DESTROYED) &amp;&amp; e.hasNext()) {</b>
<b class="nc">&nbsp;                Mounted m = e.next();</b>
<b class="nc">&nbsp;                if ((m.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                    &amp;&amp; (m.getType().hasFlag(WeaponType.F_C3M) || m</b>
<b class="nc">&nbsp;                        .getType().hasFlag(WeaponType.F_C3MBS))</b>
<b class="nc">&nbsp;                    &amp;&amp; !m.isInoperable()) {</b>
&nbsp;                    // Now look for the company command master.
<b class="nc">&nbsp;                    while ((c3CompanyMasterIndex == LOC_DESTROYED)</b>
<b class="nc">&nbsp;                           &amp;&amp; e.hasNext()) {</b>
<b class="nc">&nbsp;                        m = e.next();</b>
<b class="nc">&nbsp;                        if ((m.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                            &amp;&amp; (m.getType().hasFlag(WeaponType.F_C3M) || m</b>
<b class="nc">&nbsp;                                .getType().hasFlag(WeaponType.F_C3MBS))</b>
<b class="nc">&nbsp;                            &amp;&amp; !m.isInoperable()) {</b>
&nbsp;                            // Found the comany command master
<b class="nc">&nbsp;                            c3CompanyMasterIndex = getEquipmentNum(m);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // If we haven&#39;t found the company command master, there is none.
<b class="nc">&nbsp;            if (c3CompanyMasterIndex == LOC_DESTROYED) {</b>
<b class="nc">&nbsp;                c3CompanyMasterIndex = LOC_NONE;</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Mounted m = getEquipment(c3CompanyMasterIndex);</b>
<b class="nc">&nbsp;        if (!m.isDestroyed() &amp;&amp; !m.isBreached()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if it has any type of C3 computer.
&nbsp;     *
&nbsp;     * @return true iff it has a C3 computer.
&nbsp;     */
&nbsp;    public boolean hasC3() {
<b class="nc">&nbsp;        return hasC3S() || hasC3M() || hasC3MM();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if we have nova CEWS that is not offline.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasActiveNovaCEWS() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_NOVA)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.isInoperable() &amp;&amp; !m.curMode().equals(&quot;Off&quot;)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasNovaCEWS() {
<b class="fc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="fc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="fc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_NOVA)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasNavalC3() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_NAVAL_C3) &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasC3i() {
<b class="nc">&nbsp;        if (isShutDown() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_C3I) &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // check for Manei Domini implants
<b class="nc">&nbsp;        if ((this instanceof Infantry) &amp;&amp; (null != crew)</b>
&nbsp;                //Fix for Bug Report #1194
<b class="nc">&nbsp;            &amp;&amp; hasAbility(OptionsConstants.MD_ENH_MM_IMPLANTS)</b>
<b class="nc">&nbsp;            &amp;&amp; hasAbility(OptionsConstants.MD_BOOST_COMM_IMPLANT)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getC3NetId() {
<b class="nc">&nbsp;        if (c3NetIdString == null) {</b>
<b class="nc">&nbsp;            if (hasC3()) {</b>
<b class="nc">&nbsp;                c3NetIdString = &quot;C3.&quot; + getId();</b>
<b class="nc">&nbsp;            } else if (hasC3i()) {</b>
<b class="nc">&nbsp;                c3NetIdString = &quot;C3i.&quot; + getId();</b>
<b class="nc">&nbsp;            } else if (hasActiveNovaCEWS()) {</b>
<b class="nc">&nbsp;                c3NetIdString = &quot;C3Nova.&quot; + getId();</b>
<b class="nc">&nbsp;            } else if (hasNavalC3()) {</b>
<b class="nc">&nbsp;                c3NetIdString = &quot;NC3.&quot; + getId();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return c3NetIdString;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getOriginalNovaC3NetId() {
<b class="nc">&nbsp;        return &quot;C3Nova.&quot; + getId();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Switches the C3 network Id to the new network ID.
&nbsp;     */
&nbsp;    public void newRoundNovaNetSwitch() {
<b class="fc">&nbsp;        if (hasNovaCEWS()) {</b>
&nbsp;            // FIXME: no check for network limit of 3 units
<b class="nc">&nbsp;            c3NetIdString = newC3NetIdString;</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set the C3 network ID to be used on the next turn. Used for reconfiguring
&nbsp;     * a C3 network with Nova CEWS.
&nbsp;     *
&nbsp;     * @param str
&nbsp;     */
&nbsp;    public void setNewRoundNovaNetworkString(String str) {
&nbsp;        // Only allow Nova CEWS to change
<b class="nc">&nbsp;        if (hasNovaCEWS()) {</b>
<b class="nc">&nbsp;            newC3NetIdString = str;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            newC3NetIdString = getOriginalNovaC3NetId();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the C3 network id that will be switched to on the next turn.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public String getNewRoundNovaNetworkString() {
<b class="nc">&nbsp;        if ((newC3NetIdString == null) || newC3NetIdString.isEmpty()) {</b>
<b class="nc">&nbsp;            newC3NetIdString = getOriginalNovaC3NetId();</b>
&nbsp;        }
<b class="nc">&nbsp;        return newC3NetIdString;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setC3NetId(Entity e) {
<b class="fc">&nbsp;        if ((e == null) || isEnemyOf(e)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="fc">&nbsp;        c3NetIdString = e.c3NetIdString;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setC3NetIdSelf() {
<b class="nc">&nbsp;        if (hasActiveNovaCEWS()) {</b>
<b class="nc">&nbsp;            c3NetIdString = &quot;C3Nova.&quot; + getId();</b>
<b class="nc">&nbsp;        } else if (hasNavalC3()) {</b>
<b class="nc">&nbsp;            c3NetIdString = &quot;NC3.&quot; + getId();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            c3NetIdString = &quot;C3i.&quot; + getId();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the remaining number of other C3 Master computers that can
&nbsp;     * connect to this &lt;code&gt;Entity&lt;/code&gt;.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Please note, if this &lt;code&gt;Entity&lt;/code&gt; does not have two C3 Master
&nbsp;     * computers, then it must first be identified as a company commander;
&nbsp;     * otherwise the number of free nodes will be zero.
&nbsp;     *
&nbsp;     * @return a non-negative &lt;code&gt;int&lt;/code&gt; value.
&nbsp;     */
&nbsp;    public int calculateFreeC3MNodes() {
<b class="nc">&nbsp;        int nodes = 0;</b>
<b class="nc">&nbsp;        if (hasC3MM()) {</b>
<b class="nc">&nbsp;            nodes = 2;</b>
<b class="nc">&nbsp;            if (game != null) {</b>
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (e.hasC3M() &amp;&amp; (e != this)) {</b>
<b class="nc">&nbsp;                        final Entity m = e.getC3Master();</b>
<b class="nc">&nbsp;                        if (equals(m)) {</b>
<b class="nc">&nbsp;                            nodes--;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (nodes &lt;= 0) {</b>
<b class="nc">&nbsp;                            return 0;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (hasC3M() &amp;&amp; C3MasterIs(this)) {</b>
<b class="nc">&nbsp;            nodes = 3;</b>
<b class="nc">&nbsp;            if (game != null) {</b>
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (e.hasC3() &amp;&amp; (e != this)) {</b>
<b class="nc">&nbsp;                        final Entity m = e.getC3Master();</b>
<b class="nc">&nbsp;                        if (equals(m)) {</b>
<b class="nc">&nbsp;                            nodes--;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (nodes &lt;= 0) {</b>
<b class="nc">&nbsp;                            return 0;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return nodes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the remaining number of other C3 computers that can connect to
&nbsp;     * this &lt;code&gt;Entity&lt;/code&gt;.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Please note, if this &lt;code&gt;Entity&lt;/code&gt; has two C3 Master computers,
&nbsp;     * then this function only returns the remaining number of &lt;b&gt;C3 Slave&lt;/b&gt;
&nbsp;     * computers that can connect.
&nbsp;     *
&nbsp;     * @return a non-negative &lt;code&gt;int&lt;/code&gt; value.
&nbsp;     */
&nbsp;    public int calculateFreeC3Nodes() {
<b class="nc">&nbsp;        int nodes = 0;</b>
<b class="nc">&nbsp;        if (hasC3i() || hasNavalC3()) {</b>
<b class="nc">&nbsp;            nodes = 5;</b>
<b class="nc">&nbsp;            if (game != null) {</b>
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (!equals(e) &amp;&amp; onSameC3NetworkAs(e)) {</b>
<b class="nc">&nbsp;                        nodes--;</b>
<b class="nc">&nbsp;                        if (nodes &lt;= 0) {</b>
<b class="nc">&nbsp;                            return 0;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (hasC3M()) {</b>
<b class="nc">&nbsp;            nodes = 3;</b>
<b class="nc">&nbsp;            if (game != null) {</b>
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (e.hasC3() &amp;&amp; !equals(e)) {</b>
<b class="nc">&nbsp;                        final Entity m = e.getC3Master();</b>
<b class="nc">&nbsp;                        if (equals(m)) {</b>
&nbsp;                            // If this unit is a company commander, and has two
&nbsp;                            // C3 Master computers, only count C3 Slaves here.
<b class="nc">&nbsp;                            if (!C3MasterIs(this) || !hasC3MM() || e.hasC3S()) {</b>
<b class="nc">&nbsp;                                nodes--;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        if (nodes &lt;= 0) {</b>
<b class="nc">&nbsp;                            return 0;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (hasActiveNovaCEWS()) {</b>
<b class="nc">&nbsp;            nodes = 2;</b>
<b class="nc">&nbsp;            if (game != null) {</b>
<b class="nc">&nbsp;                for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (!equals(e) &amp;&amp; onSameC3NetworkAs(e)) {</b>
<b class="nc">&nbsp;                        nodes--;</b>
<b class="nc">&nbsp;                        if (nodes &lt;= 0) {</b>
<b class="nc">&nbsp;                            return 0;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return nodes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the entity &quot;above&quot; this entity in our c3 network, or this entity
&nbsp;     * itself, if none is above this
&nbsp;     */
&nbsp;    public Entity getC3Top() {
<b class="nc">&nbsp;        Entity m = this;</b>
<b class="nc">&nbsp;        Entity master = m.getC3Master();</b>
<b class="nc">&nbsp;        while ((master != null)</b>
<b class="nc">&nbsp;               &amp;&amp; !master.equals(m)</b>
<b class="nc">&nbsp;               &amp;&amp; master.hasC3()</b>
<b class="nc">&nbsp;               &amp;&amp; ((m.hasBoostedC3() &amp;&amp; !ComputeECM.isAffectedByAngelECM(m,</b>
<b class="nc">&nbsp;                                                                         m.getPosition(),</b>
<b class="nc">&nbsp;                                                                         master.getPosition())) || !(ComputeECM</b>
<b class="nc">&nbsp;                                                                                                             .isAffectedByECM(m, m.getPosition(),</b>
<b class="nc">&nbsp;                                                                                                                              master.getPosition())))</b>
<b class="nc">&nbsp;               &amp;&amp; ((master.hasBoostedC3() &amp;&amp; !ComputeECM.isAffectedByAngelECM(</b>
<b class="nc">&nbsp;                master, master.getPosition(), master.getPosition())) || !(ComputeECM</b>
<b class="nc">&nbsp;                                                                                  .isAffectedByECM(master, master.getPosition(),</b>
<b class="nc">&nbsp;                                                                                                   master.getPosition())))) {</b>
<b class="nc">&nbsp;            m = master;</b>
<b class="nc">&nbsp;            master = m.getC3Master();</b>
&nbsp;        }
<b class="nc">&nbsp;        return m;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the unit that is current master of this unit&#39;s C3 network. If the
&nbsp;     * master unit has been destroyed or had it&#39;s C3 master computer damaged,
&nbsp;     * then this unit is out of the C3 network for the rest of the game. If the
&nbsp;     * master unit has shut down, then this unit may return to the C3 network at
&nbsp;     * a later time.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;Entity&lt;/code&gt; that is the master of this unit&#39;s C3
&nbsp;     * network. This value may be &lt;code&gt;null&lt;/code&gt;. If the value master
&nbsp;     * unit has shut down, then the value will be non-&lt;code&gt;null&lt;/code&gt;
&nbsp;     * after the master unit restarts.
&nbsp;     */
&nbsp;    public Entity getC3Master() {
<b class="nc">&nbsp;        if (c3Master == NONE) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasC3S() &amp;&amp; (c3Master &gt; NONE)) {</b>
&nbsp;            // since we can&#39;t seem to get the check working in setC3Master(),
&nbsp;            // I&#39;ll just do it here, every time. This sucks.
<b class="nc">&nbsp;            Entity eMaster = game.getEntity(c3Master);</b>
&nbsp;            // Have we lost our C3Master?
<b class="nc">&nbsp;            if (eMaster == null) {</b>
<b class="nc">&nbsp;                c3Master = NONE;</b>
&nbsp;            }
&nbsp;            // If our master is shut down, don&#39;t clear this slave&#39;s setting.
<b class="nc">&nbsp;            else if (eMaster.isShutDown()) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;            // Slave computers can&#39;t connect to single-computer company masters.
<b class="nc">&nbsp;            else if (eMaster.C3MasterIs(eMaster) &amp;&amp; !eMaster.hasC3MM()) {</b>
<b class="nc">&nbsp;                c3Master = NONE;</b>
&nbsp;            }
&nbsp;            // Has our lance master lost its computer?
<b class="nc">&nbsp;            else if (!eMaster.hasC3M()) {</b>
<b class="nc">&nbsp;                c3Master = NONE;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (hasC3M() &amp;&amp; (c3Master &gt; NONE)) {</b>
<b class="nc">&nbsp;            Entity eMaster = game.getEntity(c3Master);</b>
&nbsp;            // Have we lost our C3Master?
<b class="nc">&nbsp;            if (eMaster == null) {</b>
<b class="nc">&nbsp;                c3Master = NONE;</b>
&nbsp;            }
&nbsp;            // If our master is shut down, don&#39;t clear this slave&#39;s setting.
<b class="nc">&nbsp;            else if (eMaster.isShutDown()) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;            // Has our company commander lost his company command computer?
<b class="nc">&nbsp;            else if (((eMaster.c3CompanyMasterIndex &gt; LOC_NONE) &amp;&amp; !eMaster</b>
<b class="nc">&nbsp;                    .hasC3MM())</b>
&nbsp;                     || ((eMaster.c3CompanyMasterIndex &lt;= LOC_NONE) &amp;&amp; !eMaster
<b class="nc">&nbsp;                    .hasC3M())) {</b>
<b class="nc">&nbsp;                c3Master = NONE;</b>
&nbsp;            }
&nbsp;            // maximum depth of a c3 network is 2 levels.
<b class="nc">&nbsp;            else if (eMaster != this) {</b>
<b class="nc">&nbsp;                Entity eCompanyMaster = eMaster.getC3Master();</b>
<b class="nc">&nbsp;                if ((eCompanyMaster != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (eCompanyMaster.getC3Master() != eCompanyMaster)) {</b>
<b class="nc">&nbsp;                    c3Master = NONE;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // If we aren&#39;t shut down, and if we don&#39;t have a company master
&nbsp;        // computer, but have a C3Master, then we must have lost our network.
<b class="nc">&nbsp;        else if (!isShutDown() &amp;&amp; !hasC3MM() &amp;&amp; (c3Master &gt; NONE)) {</b>
<b class="nc">&nbsp;            c3Master = NONE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (c3Master == NONE) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return game.getEntity(c3Master);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the ID of the master unit in this unit&#39;s C3 network. If the master
&nbsp;     * unit has shut down, then the ID will still be returned. The only times
&nbsp;     * when the value, &lt;code&gt;Entity.NONE&lt;/code&gt; is returned is when this unit is
&nbsp;     * permanently out of the C3 network, or when it was never in a C3 network.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of the unit that is the master of this
&nbsp;     * unit&#39;s C3 network, or &lt;code&gt;Entity.NONE&lt;/code&gt;.
&nbsp;     */
&nbsp;    public int getC3MasterId() {
&nbsp;        // Make sure that this unit is still on a C3 network.
&nbsp;        // N.B. this call may set this.C3Master to NONE.
<b class="nc">&nbsp;        getC3Master();</b>
<b class="nc">&nbsp;        return c3Master;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the passed &lt;code&gt;Entity&lt;/code&gt; is the C3 Master of this
&nbsp;     * unit.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Please note, that when an &lt;code&gt;Entity&lt;/code&gt; is it&#39;s own C3 Master, then
&nbsp;     * it is a company commander.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Also note that when &lt;code&gt;null&lt;/code&gt; is the master for this
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt;, then it is an independent master.
&nbsp;     *
&nbsp;     * @param e - the &lt;code&gt;Entity&lt;/code&gt; that may be this unit&#39;s C3 Master.
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; when the passed
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt; is this unit&#39;s commander. If the passed unit
&nbsp;     * isn&#39;t this unit&#39;s commander, this routine returns
&nbsp;     * &lt;code&gt;false&lt;/code&gt;.
&nbsp;     */
&nbsp;    public boolean C3MasterIs(Entity e) {
<b class="nc">&nbsp;        if (e == null) {</b>
<b class="nc">&nbsp;            if (c3Master == NONE) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return false; // if this entity has a C3Master then null is not</b>
&nbsp;            // it&#39;s master.
&nbsp;        }
<b class="nc">&nbsp;        return (e.id == c3Master);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set another &lt;code&gt;Entity&lt;/code&gt; as our C3 Master
&nbsp;     *
&nbsp;     * @param e - the &lt;code&gt;Entity&lt;/code&gt; that should be set as our C3 Master.
&nbsp;     */
&nbsp;    public void setC3Master(Entity e, boolean reset) {
<b class="nc">&nbsp;        if (e == null) {</b>
<b class="nc">&nbsp;            setC3Master(NONE, reset);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (isEnemyOf(e)) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            setC3Master(e.id, reset);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param entityId
&nbsp;     */
&nbsp;    public void setC3Master(int entityId, boolean reset) {
<b class="nc">&nbsp;        if (reset &amp;&amp; ((id == entityId) != (id == c3Master))) {</b>
&nbsp;            // this just changed from a company-level to lance-level (or vice
&nbsp;            // versa); have to disconnect all slaved units to maintain
&nbsp;            // integrity.
<b class="nc">&nbsp;            for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                if (e.C3MasterIs(this) &amp;&amp; !equals(e)) {</b>
<b class="nc">&nbsp;                    e.setC3Master(NONE, reset);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasC3()) {</b>
<b class="nc">&nbsp;            c3Master = entityId;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasC3() &amp;&amp; (entityId == NONE)) {</b>
<b class="nc">&nbsp;            c3NetIdString = &quot;C3.&quot; + id;</b>
<b class="nc">&nbsp;        } else if (hasC3i() &amp;&amp; (entityId == NONE)) {</b>
<b class="nc">&nbsp;            c3NetIdString = &quot;C3i.&quot; + id;</b>
<b class="nc">&nbsp;        } else if (hasNavalC3() &amp;&amp; (entityId == NONE)) {</b>
<b class="nc">&nbsp;            c3NetIdString = &quot;NC3.&quot; + id;</b>
<b class="nc">&nbsp;        } else if (hasC3() || hasC3i() || hasNavalC3()) {</b>
<b class="nc">&nbsp;            c3NetIdString = game.getEntity(entityId).getC3NetId();</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entity e : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (e.C3MasterIs(this) &amp;&amp; !equals(e)) {</b>
<b class="nc">&nbsp;                e.c3NetIdString = c3NetIdString;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean onSameC3NetworkAs(Entity e) {
<b class="nc">&nbsp;        return onSameC3NetworkAs(e, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if another entity is on the same c3 network as this entity
&nbsp;     *
&nbsp;     * @param e         The &lt;code&gt;Entity&lt;/code&gt; to check against this entity
&nbsp;     * @param ignoreECM a &lt;code&gt;boolean&lt;/code&gt; indicating if ECM should be ignored, we
&nbsp;     *                  need this for c3i
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if the given
&nbsp;     * entity is on the same network, &lt;code&gt;false&lt;/code&gt; if not.
&nbsp;     */
&nbsp;    public boolean onSameC3NetworkAs(Entity e, boolean ignoreECM) {
<b class="nc">&nbsp;        if (isEnemyOf(e) || isShutDown() || e.isShutDown()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Active Mek Stealth prevents entity from participating in C3.
&nbsp;        // Turn off the stealth, and your back in the network.
<b class="nc">&nbsp;        if (((this instanceof Mech) || (this instanceof Tank))</b>
<b class="nc">&nbsp;            &amp;&amp; isStealthActive()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (((e instanceof Mech) || (e instanceof Tank)) &amp;&amp; e.isStealthActive()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // C3i is easy - if they both have C3i, and their net ID&#39;s match,
&nbsp;        // they&#39;re on the same network!
<b class="nc">&nbsp;        if (hasC3i() &amp;&amp; e.hasC3i() &amp;&amp; getC3NetId().equals(e.getC3NetId())) {</b>
<b class="nc">&nbsp;            if (ignoreECM) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return !(ComputeECM.isAffectedByECM(e, e.getPosition(),</b>
<b class="nc">&nbsp;                                                e.getPosition()))</b>
<b class="nc">&nbsp;                   &amp;&amp; !(ComputeECM.isAffectedByECM(this, getPosition(),</b>
<b class="nc">&nbsp;                                                   getPosition()));</b>
&nbsp;        }
&nbsp;
&nbsp;        // NC3 is easy too - if they both have NC3, and their net ID&#39;s match,
&nbsp;        // they&#39;re on the same network!
<b class="nc">&nbsp;        if (hasNavalC3() &amp;&amp; e.hasNavalC3() &amp;&amp; getC3NetId().equals(e.getC3NetId())) {</b>
<b class="nc">&nbsp;            int distance = Compute.effectiveDistance(game,this,e,false);</b>
&nbsp;            //Naval C3 is not affected by ECM, but nodes must be within 60 hexes of one another
<b class="nc">&nbsp;            if (game.getRoundCount() &gt; 0) {</b>
<b class="nc">&nbsp;                if (distance &gt; 60) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                //Naval C3 only works in space
<b class="nc">&nbsp;                if (!isSpaceborne()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Nova is easy - if they both have Nova, and their net ID&#39;s match,
&nbsp;        // they&#39;re on the same network!
&nbsp;        // At least I hope thats how it works.
<b class="nc">&nbsp;        if (hasActiveNovaCEWS() &amp;&amp; e.hasActiveNovaCEWS()</b>
<b class="nc">&nbsp;            &amp;&amp; getC3NetId().equals(e.getC3NetId())) {</b>
<b class="nc">&nbsp;            if (ignoreECM) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            ECMInfo srcInfo = ComputeECM.getECMEffects(e, e.getPosition(),</b>
<b class="nc">&nbsp;                    e.getPosition(), true, null);</b>
<b class="nc">&nbsp;            ECMInfo dstInfo = ComputeECM.getECMEffects(this, getPosition(),</b>
<b class="nc">&nbsp;                    getPosition(), true, null);</b>
<b class="nc">&nbsp;            return !((srcInfo != null) &amp;&amp; srcInfo.isNovaECM())</b>
<b class="nc">&nbsp;                    &amp;&amp; !((dstInfo != null) &amp;&amp; dstInfo.isNovaECM());</b>
&nbsp;        }
&nbsp;
&nbsp;        // simple sanity check - do they both have C3, and are they both on the
&nbsp;        // same network?
<b class="nc">&nbsp;        if (!hasC3() || !e.hasC3()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((getC3Top() == null) || (e.getC3Top() == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // got the easy part out of the way, now we need to verify that the
&nbsp;        // network isn&#39;t down
<b class="nc">&nbsp;        return (getC3Top().equals(e.getC3Top()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether there is CASE protecting the location.
&nbsp;     */
&nbsp;    public boolean locationHasCase(int loc) {
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if ((mounted.getLocation() == loc)</b>
<b class="nc">&nbsp;                &amp;&amp; mounted.getType().hasFlag(MiscType.F_CASE)|(mounted.getType().hasFlag(MiscType.F_CASEP))) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether there is CASE anywhere on this {@code Entity}.
&nbsp;     */
&nbsp;    public boolean hasCase() {
&nbsp;        // Clan Mechs always have CASE!
<b class="nc">&nbsp;        if (isClan()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(MiscType.F_CASE)||(mounted.getType().hasFlag(MiscType.F_CASEP))</b>
&nbsp;                    ) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hits all criticals of the system occupying the specified critical slot.
&nbsp;     * Used, for example, in a gauss rifle capacitor discharge. Does not apply
&nbsp;     * any special effect of hitting the criticals, like ammo explosion.
&nbsp;     */
&nbsp;    public void hitAllCriticals(int loc, int slot) {
<b class="nc">&nbsp;        CriticalSlot orig = getCritical(loc, slot);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if ((cs != null) &amp;&amp; (cs.getType() == orig.getType())) {</b>
<b class="nc">&nbsp;                Mounted csMount = cs.getMount();</b>
<b class="nc">&nbsp;                if ((csMount != null) &amp;&amp; csMount.equals(orig.getMount())) {</b>
<b class="nc">&nbsp;                    cs.setHit(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Start a new round
&nbsp;     *
&nbsp;     * @param roundNumber the &lt;code&gt;int&lt;/code&gt; number of the new round
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void newRound(int roundNumber) {
<b class="fc">&nbsp;        fell = false;</b>
<b class="fc">&nbsp;        struck = false;</b>
<b class="fc">&nbsp;        unloadedThisTurn = false;</b>
<b class="fc">&nbsp;        loadedThisTurn = false;</b>
<b class="fc">&nbsp;        done = false;</b>
<b class="fc">&nbsp;        delta_distance = 0;</b>
<b class="fc">&nbsp;        mpUsedLastRound = mpUsed;</b>
<b class="fc">&nbsp;        mpUsed = 0;</b>
<b class="fc">&nbsp;        isJumpingNow = false;</b>
<b class="fc">&nbsp;        convertingNow = false;</b>
<b class="fc">&nbsp;        damageThisRound = 0;</b>
<b class="fc">&nbsp;        if (assaultDropInProgress == 2) {</b>
<b class="nc">&nbsp;            assaultDropInProgress = 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        movedLastRound = moved;</b>
<b class="fc">&nbsp;        moved = EntityMovementType.MOVE_NONE;</b>
<b class="fc">&nbsp;        movedBackwards = false;</b>
<b class="fc">&nbsp;        isPowerReverse = false;</b>
<b class="fc">&nbsp;        wigeLiftoffHover = false;</b>
<b class="fc">&nbsp;        gotPavementBonus = false;</b>
<b class="fc">&nbsp;        wigeBonus = 0;</b>
<b class="fc">&nbsp;        hitThisRoundByAntiTSM = false;</b>
<b class="fc">&nbsp;        inReverse = false;</b>
<b class="fc">&nbsp;        hitBySwarmsEntity.clear();</b>
<b class="fc">&nbsp;        hitBySwarmsWeapon.clear();</b>
<b class="fc">&nbsp;        setTaggedBy(-1);</b>
<b class="fc">&nbsp;        setLayingMines(false);</b>
<b class="fc">&nbsp;        setArmsFlipped(false);</b>
<b class="fc">&nbsp;        setDisplacementAttack(null);</b>
<b class="fc">&nbsp;        setFindingClub(false);</b>
<b class="fc">&nbsp;        setSpotting(false);</b>
<b class="fc">&nbsp;        spotTargetId = Entity.NONE;</b>
<b class="fc">&nbsp;        setClearingMinefield(false);</b>
<b class="fc">&nbsp;        setUnjammingRAC(false);</b>
<b class="fc">&nbsp;        crew.setKoThisRound(false);</b>
<b class="fc">&nbsp;        m_lNarcedBy |= m_lPendingNarc;</b>
<b class="fc">&nbsp;        if (pendingINarcPods.size() &gt; 0) {</b>
<b class="nc">&nbsp;            iNarcPods.addAll(pendingINarcPods);</b>
<b class="nc">&nbsp;            pendingINarcPods = new ArrayList&lt;INarcPod&gt;();</b>
&nbsp;        }
<b class="fc">&nbsp;        if (pendingNarcPods.size() &gt; 0) {</b>
<b class="nc">&nbsp;            narcPods.addAll(pendingNarcPods);</b>
<b class="nc">&nbsp;            pendingNarcPods.clear();</b>
&nbsp;        }
&nbsp;
&nbsp;        // update the number of turns we used a blue shield
<b class="fc">&nbsp;        if (hasActiveBlueShield()) {</b>
<b class="nc">&nbsp;            blueShieldRounds++;</b>
&nbsp;        }
&nbsp;
&nbsp;        // for dropping troops, check to see if they are going to land
&nbsp;        // this turn, if so, then set their assault drop status to true
<b class="fc">&nbsp;        if (isAirborne()</b>
<b class="nc">&nbsp;            &amp;&amp; !isAero()</b>
<b class="nc">&nbsp;            &amp;&amp; (getAltitude() &lt;= game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                     .getDropRate())) {</b>
<b class="nc">&nbsp;            setAssaultDropInProgress(true);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="fc">&nbsp;            m.newRound(roundNumber);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        newRoundNovaNetSwitch();</b>
<b class="fc">&nbsp;        doNewRoundIMP();</b>
&nbsp;
&nbsp;        // reset hexes passed through
<b class="fc">&nbsp;        setPassedThrough(new Vector&lt;Coords&gt;());</b>
<b class="fc">&nbsp;        setPassedThroughFacing(new ArrayList&lt;Integer&gt;());</b>
<b class="fc">&nbsp;        if (playerPickedPassThrough == null) {</b>
<b class="nc">&nbsp;            playerPickedPassThrough = new HashMap&lt;&gt;();</b>
&nbsp;        } else {
<b class="fc">&nbsp;            playerPickedPassThrough.clear();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        resetFiringArcs();</b>
&nbsp;
<b class="fc">&nbsp;        resetBays();</b>
&nbsp;
<b class="fc">&nbsp;        if (isBomber()) {</b>
<b class="nc">&nbsp;            resetBombAttacks();</b>
&nbsp;        }
&nbsp;
&nbsp;        // reset evasion
<b class="fc">&nbsp;        setEvading(false);</b>
&nbsp;
&nbsp;        // make sensor checks
<b class="fc">&nbsp;        sensorCheck = Compute.d6(2);</b>
&nbsp;        // if the current sensor is BAP and BAP is critted, then switch to the
&nbsp;        // first
&nbsp;        // thing that works
<b class="fc">&nbsp;        if ((null != nextSensor) &amp;&amp; nextSensor.isBAP() &amp;&amp; !hasBAP(false)) {</b>
<b class="nc">&nbsp;            for (Sensor sensor : getSensors()) {</b>
<b class="nc">&nbsp;                if (!sensor.isBAP()) {</b>
<b class="nc">&nbsp;                    nextSensor = sensor;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // change the active sensor, if requested
<b class="fc">&nbsp;        if (null != nextSensor) {</b>
<b class="fc">&nbsp;            activeSensor = nextSensor;</b>
&nbsp;        }
&nbsp;
&nbsp;        // ghost target roll
<b class="fc">&nbsp;        ghostTargetRoll = Compute.d6(2);</b>
<b class="fc">&nbsp;        ghostTargetOverride = Compute.d6(2);</b>
&nbsp;
&nbsp;        // update fatigue count
<b class="fc">&nbsp;        if ((null != crew) &amp;&amp; isDeployed()) {</b>
<b class="nc">&nbsp;            crew.incrementFatigueCount();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update the inferno tracker.
<b class="fc">&nbsp;        infernos.newRound(roundNumber);</b>
<b class="fc">&nbsp;        if (taserShutdownRounds &gt; 0) {</b>
<b class="nc">&nbsp;            taserShutdownRounds--;</b>
<b class="nc">&nbsp;            if (taserShutdownRounds == 0) {</b>
<b class="nc">&nbsp;                shutdownByBATaser = false;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (taserInterferenceRounds &gt; 0) {</b>
<b class="nc">&nbsp;            taserInterferenceRounds--;</b>
<b class="nc">&nbsp;            if (taserInterferenceRounds == 0) {</b>
<b class="nc">&nbsp;                taserInterference = 0;</b>
<b class="nc">&nbsp;                taserInterferenceHeat = false;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (taserFeedBackRounds &gt; 0) {</b>
<b class="nc">&nbsp;            taserFeedBackRounds--;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we are affected by the TSEMP Shutdown effect, we should remove
&nbsp;        // it now, so we can startup during the end phase
<b class="fc">&nbsp;        if (getTsempEffect() == TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN) {</b>
<b class="nc">&nbsp;            setTsempEffect(TSEMPWeapon.TSEMP_EFFECT_NONE);</b>
&nbsp;            // The TSEMP interference effect shouldn&#39;t be removed until the start
&nbsp;            //  of a round where we didn&#39;t have any TSEMP hits and didn&#39;t fire a
&nbsp;            //  TSEMP, since we need the effect active during the firing phase
<b class="fc">&nbsp;        } else if ((getTsempHitsThisTurn() == 0) &amp;&amp; !isFiredTsempThisTurn()) {</b>
<b class="fc">&nbsp;            setTsempEffect(TSEMPWeapon.TSEMP_EFFECT_NONE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // TSEMPs can fire every other round, so if we didn&#39;t fire last
&nbsp;        //  round and the TSEMP isn&#39;t one-shot, reset it&#39;s fired state
<b class="fc">&nbsp;        if (hasFiredTsemp()) {</b>
<b class="nc">&nbsp;            for (Mounted m : getWeaponList()) {</b>
<b class="nc">&nbsp;                if (m.getType().hasFlag(WeaponType.F_TSEMP)</b>
<b class="nc">&nbsp;                    &amp;&amp; !m.getType().hasFlag(WeaponType.F_ONESHOT)) {</b>
<b class="nc">&nbsp;                    if (m.isTSEMPDowntime()) {</b>
<b class="nc">&nbsp;                        m.setFired(false);</b>
<b class="nc">&nbsp;                        m.setTSEMPDowntime(false);</b>
<b class="nc">&nbsp;                    } else if (m.isFired()) {</b>
<b class="nc">&nbsp;                        m.setTSEMPDowntime(true);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Reset TSEMP hits
<b class="fc">&nbsp;        tsempHitsThisTurn = 0;</b>
&nbsp;        // Reset TSEMP firing flag
<b class="fc">&nbsp;        setFiredTsempThisTurn(false);</b>
&nbsp;
&nbsp;        // Decrement the number of consecutive turns if not used last turn
<b class="fc">&nbsp;        if (!hasActivatedRadicalHS()) {</b>
<b class="fc">&nbsp;            setConsecutiveRHSUses(Math.max(0, getConsecutiveRHSUses() - 1));</b>
&nbsp;        }
&nbsp;        // Reset used RHS flag
<b class="fc">&nbsp;        deactivateRadicalHS();</b>
&nbsp;
<b class="fc">&nbsp;        clearAttackedByThisTurn();</b>
&nbsp;
<b class="fc">&nbsp;        setMadePointblankShot(false);</b>
&nbsp;
<b class="fc">&nbsp;        setSelfDestructedThisTurn(false);</b>
&nbsp;
<b class="fc">&nbsp;        setClimbMode(GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_MOVE_DEFAULT_CLIMB_MODE));</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Applies any damage that the entity has suffered. When anything gets hit
&nbsp;     * it is simply marked as &quot;hit&quot; but does not stop working until this is
&nbsp;     * called.
&nbsp;     */
&nbsp;    public void applyDamage() {
&nbsp;        // mark all damaged equipment destroyed
<b class="nc">&nbsp;        for (Mounted mounted : getEquipment()) {</b>
<b class="nc">&nbsp;            if (mounted.isHit()) {</b>
<b class="nc">&nbsp;                mounted.setDestroyed(true);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // destroy criticals that were hit last phase
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; getNumberOfCriticals(i); j++) {</b>
<b class="nc">&nbsp;                final CriticalSlot cs = getCritical(i, j);</b>
<b class="nc">&nbsp;                if ((cs != null) &amp;&amp; cs.isHit()) {</b>
<b class="nc">&nbsp;                    cs.setDestroyed(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Reset any &quot;blown off this phase&quot; markers.
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            setLocationBlownOffThisPhase(i, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // destroy armor/internals if the section was removed
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if (getInternal(i) == IArmorState.ARMOR_DOOMED) {</b>
<b class="nc">&nbsp;                setArmor(IArmorState.ARMOR_DESTROYED, i);</b>
<b class="nc">&nbsp;                setArmor(IArmorState.ARMOR_DESTROYED, i, true);</b>
<b class="nc">&nbsp;                setInternal(IArmorState.ARMOR_DESTROYED, i);</b>
&nbsp;                // destroy any Narc beacons
<b class="nc">&nbsp;                for (Iterator&lt;NarcPod&gt; iter = narcPods.iterator(); iter</b>
<b class="nc">&nbsp;                        .hasNext(); ) {</b>
<b class="nc">&nbsp;                    NarcPod p = iter.next();</b>
<b class="nc">&nbsp;                    if (p.getLocation() == i) {</b>
<b class="nc">&nbsp;                        iter.remove();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (Iterator&lt;INarcPod&gt; iter = iNarcPods.iterator(); iter</b>
<b class="nc">&nbsp;                        .hasNext(); ) {</b>
<b class="nc">&nbsp;                    INarcPod p = iter.next();</b>
<b class="nc">&nbsp;                    if (p.getLocation() == i) {</b>
<b class="nc">&nbsp;                        iter.remove();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (Iterator&lt;NarcPod&gt; iter = pendingNarcPods.iterator(); iter</b>
<b class="nc">&nbsp;                        .hasNext(); ) {</b>
<b class="nc">&nbsp;                    NarcPod p = iter.next();</b>
<b class="nc">&nbsp;                    if (p.getLocation() == i) {</b>
<b class="nc">&nbsp;                        iter.remove();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (Iterator&lt;INarcPod&gt; iter = pendingINarcPods.iterator(); iter</b>
<b class="nc">&nbsp;                        .hasNext(); ) {</b>
<b class="nc">&nbsp;                    INarcPod p = iter.next();</b>
<b class="nc">&nbsp;                    if (p.getLocation() == i) {</b>
<b class="nc">&nbsp;                        iter.remove();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Attempts to reload any empty weapons with the first ammo found
&nbsp;     */
&nbsp;    public void reloadEmptyWeapons() {
&nbsp;        // try to reload weapons
<b class="nc">&nbsp;        for (Mounted mounted : getTotalWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
&nbsp;
<b class="nc">&nbsp;            if (wtype.getAmmoType() != AmmoType.T_NA) {</b>
<b class="nc">&nbsp;                if ((mounted.getLinked() == null)</b>
<b class="nc">&nbsp;                    || (mounted.getLinked().getUsableShotsLeft() &lt;= 0)</b>
<b class="nc">&nbsp;                    || mounted.getLinked().isDumping()) {</b>
<b class="nc">&nbsp;                    loadWeaponWithSameAmmo(mounted);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Return the currently operable AMS mounted in this Entity.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public List&lt;Mounted&gt; getActiveAMS() {
<b class="nc">&nbsp;        ArrayList&lt;Mounted&gt; ams = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Mounted weapon : getWeaponList()) {</b>
&nbsp;            // Skip anything that&#39;s not AMS
<b class="nc">&nbsp;            if (!weapon.getType().hasFlag(WeaponType.F_AMS)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Make sure the AMS is good to go
<b class="nc">&nbsp;            if (!weapon.isReady() || weapon.isMissing()</b>
<b class="nc">&nbsp;                || !weapon.curMode().equals(Weapon.MODE_AMS_ON)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // AMS blocked by transported units can not fire
<b class="nc">&nbsp;            if (isWeaponBlockedAt(weapon.getLocation(),</b>
<b class="nc">&nbsp;                                  weapon.isRearMounted())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Make sure ammo is loaded
<b class="nc">&nbsp;            boolean baAPDS = (this instanceof BattleArmor)</b>
<b class="nc">&nbsp;                    &amp;&amp; (weapon.getType().getInternalName().equals(&quot;ISBAAPDS&quot;));</b>
<b class="nc">&nbsp;            Mounted ammo = weapon.getLinked();</b>
<b class="nc">&nbsp;            if (!(weapon.getType().hasFlag(WeaponType.F_ENERGY)) &amp;&amp; !baAPDS</b>
<b class="nc">&nbsp;                &amp;&amp; ((ammo == null) || (ammo.getUsableShotsLeft() == 0)</b>
<b class="nc">&nbsp;                    || ammo.isDumping())) {</b>
<b class="nc">&nbsp;                loadWeapon(weapon);</b>
<b class="nc">&nbsp;                ammo = weapon.getLinked();</b>
&nbsp;            }
&nbsp;
&nbsp;            // try again
<b class="nc">&nbsp;            if (!(weapon.getType().hasFlag(WeaponType.F_ENERGY)) &amp;&amp; !baAPDS</b>
<b class="nc">&nbsp;                &amp;&amp; ((ammo == null) || (ammo.getUsableShotsLeft() == 0)</b>
<b class="nc">&nbsp;                    || ammo.isDumping())) {</b>
&nbsp;                // No ammo for this AMS.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            ams.add(weapon);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return ams;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Assign AMS systems to incoming telemissile attacks. This
&nbsp;     * allows AMS bays to work against these modified physical attacks
&nbsp;     */
&nbsp;    public void assignTMAMS(Vector&lt;AttackAction&gt; vTMAttacks) {
<b class="nc">&nbsp;        HashSet&lt;AttackAction&gt; targets = new HashSet&lt;AttackAction&gt;();</b>
<b class="nc">&nbsp;        for (Mounted ams : getActiveAMS()) {</b>
&nbsp;         // make a new vector of only incoming attacks in arc
<b class="nc">&nbsp;            Vector&lt;TeleMissileAttackAction&gt; vTMAttacksInArc = new Vector&lt;TeleMissileAttackAction&gt;(</b>
<b class="nc">&nbsp;                    vTMAttacks.size());</b>
&nbsp;
<b class="nc">&nbsp;            for (AttackAction aa : vTMAttacks) {</b>
&nbsp;                //We already made sure these are all telemissile attacks in Server
<b class="nc">&nbsp;                TeleMissileAttackAction taa = (TeleMissileAttackAction) aa;</b>
<b class="nc">&nbsp;                if (!targets.contains(taa)</b>
<b class="nc">&nbsp;                        &amp;&amp; Compute.isInArc(game, getId(), getEquipmentNum(ams),</b>
<b class="nc">&nbsp;                                game.getEntity(taa.getEntityId()))) {</b>
<b class="nc">&nbsp;                    vTMAttacksInArc.addElement(taa);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            //AMS Bays can fire at all incoming attacks each round
&nbsp;            //Point defense bays are added too. If they haven&#39;t fired
&nbsp;            //at something else already, they can attack now.
<b class="nc">&nbsp;            if (ams.getType().hasFlag(WeaponType.F_AMSBAY)</b>
<b class="nc">&nbsp;                    || (ams.getType().hasFlag(WeaponType.F_PDBAY)</b>
<b class="nc">&nbsp;                            &amp;&amp; !ams.isUsedThisRound())) {</b>
<b class="nc">&nbsp;                for (TeleMissileAttackAction taa : vTMAttacksInArc) {</b>
<b class="nc">&nbsp;                    if (taa != null) {</b>
<b class="nc">&nbsp;                        taa.addCounterEquipment(ams);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Assign AMS systems to the most dangerous incoming missile attacks. This
&nbsp;     * should only be called once per turn, or AMS will get extra attacks
&nbsp;     */
&nbsp;    public void assignAMS(Vector&lt;WeaponHandler&gt; vAttacks) {
&nbsp;
<b class="nc">&nbsp;        HashSet&lt;WeaponAttackAction&gt; targets = new HashSet&lt;WeaponAttackAction&gt;();</b>
<b class="nc">&nbsp;        for (Mounted ams : getActiveAMS()) {</b>
&nbsp;            // Ignore APDS, it gets assigned elsewhere
<b class="nc">&nbsp;            if (ams.isAPDS()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // make a new vector of only incoming attacks in arc
<b class="nc">&nbsp;            Vector&lt;WeaponAttackAction&gt; vAttacksInArc = new Vector&lt;WeaponAttackAction&gt;(</b>
<b class="nc">&nbsp;                    vAttacks.size());</b>
<b class="nc">&nbsp;            for (WeaponHandler wr : vAttacks) {</b>
<b class="nc">&nbsp;                if (wr instanceof CapitalMissileBearingsOnlyHandler) {</b>
<b class="nc">&nbsp;                    if (!targets.contains(wr.waa)</b>
<b class="nc">&nbsp;                            &amp;&amp; Compute.isInArc(game, getId(), getEquipmentNum(ams),</b>
<b class="nc">&nbsp;                                    game.getTarget(wr.waa.getOriginalTargetType(), wr.waa.getOriginalTargetId()))) {</b>
<b class="nc">&nbsp;                        vAttacksInArc.addElement(wr.waa);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    if (!targets.contains(wr.waa)</b>
<b class="nc">&nbsp;                            &amp;&amp; Compute.isInArc(game, getId(), getEquipmentNum(ams),</b>
<b class="nc">&nbsp;                                    game.getEntity(wr.waa.getEntityId()))) {</b>
<b class="nc">&nbsp;                        vAttacksInArc.addElement(wr.waa);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            //AMS Bays can fire at all incoming attacks each round
&nbsp;            //So can standard AMS if the unofficial option is turned on
<b class="nc">&nbsp;            if ((ams.getType().hasFlag(WeaponType.F_AMSBAY))</b>
<b class="nc">&nbsp;                    || (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_MULTI_USE_AMS)</b>
<b class="nc">&nbsp;                            &amp;&amp; ams.getType().hasFlag(WeaponType.F_AMS))) {</b>
<b class="nc">&nbsp;                for (WeaponAttackAction waa : vAttacksInArc) {</b>
<b class="nc">&nbsp;                    if (waa != null) {</b>
<b class="nc">&nbsp;                        waa.addCounterEquipment(ams);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } else if (ams.getType().hasFlag(WeaponType.F_PDBAY)) {</b>
&nbsp;            	//Point defense bays are assigned to the attack with the greatest threat
&nbsp;            	//Unlike single AMS, PD bays can gang up on 1 attack
<b class="nc">&nbsp;                WeaponAttackAction waa = Compute.getHighestExpectedDamage(game,</b>
&nbsp;                        vAttacksInArc, true);
<b class="nc">&nbsp;                    if (waa != null) {</b>
<b class="nc">&nbsp;                    	waa.addCounterEquipment(ams);</b>
&nbsp;                    }
<b class="nc">&nbsp;            } else {</b>
&nbsp;            //Otherwise, find the most dangerous salvo by expected damage and target it
&nbsp;            // this ensures that only 1 AMS targets the strike. Use for non-bays.
<b class="nc">&nbsp;            WeaponAttackAction waa = Compute.getHighestExpectedDamage(game,</b>
&nbsp;                    vAttacksInArc, true);
<b class="nc">&nbsp;                if (waa != null) {</b>
<b class="nc">&nbsp;                waa.addCounterEquipment(ams);</b>
<b class="nc">&nbsp;                targets.add(waa);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * has the team attached a narc pod to me?
&nbsp;     */
&nbsp;    public boolean isNarcedBy(int nTeamID) {
<b class="nc">&nbsp;        for (NarcPod p : narcPods) {</b>
<b class="nc">&nbsp;            if (p.getTeam() == nTeamID) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * add a narc pod from this team to the mech. Unremovable
&nbsp;     *
&nbsp;     * @param pod The &lt;code&gt;NarcPod&lt;/code&gt; to be attached.
&nbsp;     */
&nbsp;    public void attachNarcPod(NarcPod pod) {
<b class="nc">&nbsp;        pendingNarcPods.add(pod);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * attach an iNarcPod
&nbsp;     *
&nbsp;     * @param pod The &lt;code&gt;INarcPod&lt;/code&gt; to be attached.
&nbsp;     */
&nbsp;    public void attachINarcPod(INarcPod pod) {
<b class="nc">&nbsp;        pendingINarcPods.add(pod);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Have we been iNarced with a homing pod from that team?
&nbsp;     *
&nbsp;     * @param nTeamID The id of the team that we are wondering about.
&nbsp;     * @return true if the Entity is narced by that team.
&nbsp;     */
&nbsp;    public boolean isINarcedBy(int nTeamID) {
<b class="nc">&nbsp;        for (INarcPod pod : iNarcPods) {</b>
<b class="nc">&nbsp;            if ((pod.getTeam() == nTeamID)</b>
<b class="nc">&nbsp;                &amp;&amp; (pod.getType() == INarcPod.HOMING)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Have we been iNarced with the named pod from any team?
&nbsp;     *
&nbsp;     * @param type the &lt;code&gt;int&lt;/code&gt; type of iNarc pod.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if we have.
&nbsp;     */
&nbsp;    public boolean isINarcedWith(long type) {
<b class="nc">&nbsp;        for (INarcPod pod : iNarcPods) {</b>
<b class="nc">&nbsp;            if (pod.getType() == type) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove all attached iNarc Pods
&nbsp;     */
&nbsp;    public void removeAllINarcPods() {
<b class="nc">&nbsp;        iNarcPods.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Do we have any iNarc Pods attached?
&nbsp;     *
&nbsp;     * @return true iff one or more iNarcPods are attached.
&nbsp;     */
&nbsp;    public boolean hasINarcPodsAttached() {
<b class="nc">&nbsp;        if (iNarcPods.size() &gt; 0) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;INarcPod&lt;/code&gt;s that are
&nbsp;     * attached to this entity.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;INarcPod&lt;/code&gt;s.
&nbsp;     */
&nbsp;    public Iterator&lt;INarcPod&gt; getINarcPodsAttached() {
<b class="nc">&nbsp;        return iNarcPods.iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove an &lt;code&gt;INarcPod&lt;/code&gt; from this entity.
&nbsp;     *
&nbsp;     * @param pod the &lt;code&gt;INarcPod&lt;/code&gt; to be removed.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the pod was removed, &lt;code&gt;false&lt;/code&gt; if
&nbsp;     * the pod was not attached to this entity.
&nbsp;     */
&nbsp;    public boolean removeINarcPod(INarcPod pod) {
<b class="nc">&nbsp;        return iNarcPods.remove(pod);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the battle value of this entity
&nbsp;     */
&nbsp;    public abstract int calculateBattleValue();
&nbsp;
&nbsp;    public boolean useGeometricMeanBV() {
<b class="nc">&nbsp;        return useGeometricBV || ((game != null)</b>
<b class="nc">&nbsp;                                  &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_GEOMETRIC_MEAN_BV));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean useReducedOverheatModifierBV() {
<b class="nc">&nbsp;        return (useReducedOverheatModifierBV || ((game != null)</b>
<b class="nc">&nbsp;                                                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_REDUCED_OVERHEAT_MODIFIER_BV)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the battle value of this mech. If the parameter is true, then
&nbsp;     * the battle value for c3 will be added whether the mech is currently part
&nbsp;     * of a network or not. This should be overwritten if necessary
&nbsp;     *
&nbsp;     * @param ignoreC3    if the contribution of the C3 computer should be ignored when
&nbsp;     *                    calculating BV.
&nbsp;     * @param ignorePilot if the extra BV due to piloting skill should be ignore, needed
&nbsp;     *                    for c3 bv
&nbsp;     */
&nbsp;    public int calculateBattleValue(boolean ignoreC3, boolean ignorePilot) {
<b class="nc">&nbsp;        if (useManualBV) {</b>
<b class="nc">&nbsp;            return manualBV;</b>
&nbsp;        }
<b class="nc">&nbsp;        return calculateBattleValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a vector containing reports on all useful information about
&nbsp;     * this entity.
&nbsp;     */
&nbsp;    public abstract Vector&lt;Report&gt; victoryReport();
&nbsp;
&nbsp;    /**
&nbsp;     * Two entities are equal if their ids are equal
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="nc">&nbsp;        if(this == obj) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if((null == obj) || (getClass() != obj.getClass())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        final Entity other = (Entity) obj;</b>
<b class="nc">&nbsp;        return (id == other.id);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="nc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the movement mode of the entity
&nbsp;     */
&nbsp;    public EntityMovementMode getMovementMode() {
<b class="fc">&nbsp;        return movementMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the movement mode of the entity as a String.
&nbsp;     */
&nbsp;    public String getMovementModeAsString() {
<b class="nc">&nbsp;        switch (getMovementMode()) {</b>
&nbsp;            case NONE:
<b class="nc">&nbsp;                return &quot;None&quot;;</b>
&nbsp;            case BIPED:
&nbsp;            case BIPED_SWIM:
<b class="nc">&nbsp;                return &quot;Biped&quot;;</b>
&nbsp;            case QUAD:
&nbsp;            case QUAD_SWIM:
<b class="nc">&nbsp;                return &quot;Quad&quot;;</b>
&nbsp;            case TRACKED:
<b class="nc">&nbsp;                return &quot;Tracked&quot;;</b>
&nbsp;            case WHEELED:
<b class="nc">&nbsp;                return &quot;Wheeled&quot;;</b>
&nbsp;            case HOVER:
<b class="nc">&nbsp;                return &quot;Hover&quot;;</b>
&nbsp;            case VTOL:
<b class="nc">&nbsp;                return &quot;VTOL&quot;;</b>
&nbsp;            case NAVAL:
<b class="nc">&nbsp;                return &quot;Naval&quot;;</b>
&nbsp;            case HYDROFOIL:
<b class="nc">&nbsp;                return &quot;Hydrofoil&quot;;</b>
&nbsp;            case SUBMARINE:
<b class="nc">&nbsp;                return &quot;Submarine&quot;;</b>
&nbsp;            case INF_UMU:
<b class="nc">&nbsp;                return &quot;UMU&quot;;</b>
&nbsp;            case INF_LEG:
<b class="nc">&nbsp;                return &quot;Leg&quot;;</b>
&nbsp;            case INF_MOTORIZED:
<b class="nc">&nbsp;                return &quot;Motorized&quot;;</b>
&nbsp;            case INF_JUMP:
<b class="nc">&nbsp;                return &quot;Jump&quot;;</b>
&nbsp;            case WIGE:
<b class="nc">&nbsp;                return &quot;WiGE&quot;;</b>
&nbsp;            case AERODYNE:
<b class="nc">&nbsp;                return &quot;Aerodyne&quot;;</b>
&nbsp;            case SPHEROID:
<b class="nc">&nbsp;                return &quot;Spheroid&quot;;</b>
&nbsp;            case RAIL:
<b class="nc">&nbsp;                return &quot;Rail&quot;;</b>
&nbsp;            case MAGLEV:
<b class="nc">&nbsp;                return &quot;MagLev&quot;;</b>
&nbsp;            case STATION_KEEPING:
<b class="nc">&nbsp;                return &quot;Station-Keeping&quot;;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return &quot;ERROR&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the movement type of the entity
&nbsp;     */
&nbsp;    public void setMovementMode(EntityMovementMode movementMode) {
<b class="nc">&nbsp;        this.movementMode = movementMode;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function to determine if a entity is a biped
&nbsp;     */
&nbsp;    public boolean entityIsBiped() {
<b class="nc">&nbsp;        return (getMovementMode() == EntityMovementMode.BIPED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function to determine if a entity is a quad
&nbsp;     */
&nbsp;    public boolean entityIsQuad() {
<b class="nc">&nbsp;        return (getMovementMode() == EntityMovementMode.QUAD);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true is the entity needs a roll to stand up
&nbsp;     */
&nbsp;    public boolean needsRollToStand() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an entity&#39;s base piloting skill roll needed Only use this version
&nbsp;     * if the entity is through processing movement
&nbsp;     */
&nbsp;    public PilotingRollData getBasePilotingRoll() {
<b class="nc">&nbsp;        return getBasePilotingRoll(moved);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an entity&#39;s base piloting skill roll needed
&nbsp;     */
&nbsp;    public PilotingRollData getBasePilotingRoll(EntityMovementType moveType) {
<b class="nc">&nbsp;        final int entityId = getId();</b>
&nbsp;
&nbsp;        PilotingRollData roll;
&nbsp;
&nbsp;        // Crew dead?
<b class="nc">&nbsp;        if (getCrew().isDead() || getCrew().isDoomed()</b>
<b class="nc">&nbsp;            || (getCrew().getHits() &gt;= 6)) {</b>
&nbsp;            // Following line switched from impossible to automatic failure
&nbsp;            // -- bug fix for dead units taking PSRs
<b class="nc">&nbsp;            return new PilotingRollData(entityId, TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                        &quot;Pilot dead&quot;);
&nbsp;        }
&nbsp;        // pilot awake?
<b class="nc">&nbsp;        else if (!getCrew().isActive()) {</b>
<b class="nc">&nbsp;            return new PilotingRollData(entityId, TargetRoll.IMPOSSIBLE,</b>
&nbsp;                                        &quot;Pilot unconscious&quot;);
&nbsp;        }
&nbsp;        // gyro operational? does not apply if using tracked/quadvee vehicle/lam fighter movement
<b class="nc">&nbsp;        if (isGyroDestroyed() &amp;&amp; canFall()</b>
&nbsp;                &amp;&amp; moveType != EntityMovementType.MOVE_VTOL_WALK
&nbsp;                &amp;&amp; moveType != EntityMovementType.MOVE_VTOL_RUN) {
<b class="nc">&nbsp;            return new PilotingRollData(entityId, TargetRoll.AUTOMATIC_FAIL,</b>
<b class="nc">&nbsp;                                        getCrew().getPiloting() + 6, &quot;Gyro destroyed&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // both legs present?
<b class="nc">&nbsp;        if ((this instanceof BipedMech)</b>
<b class="nc">&nbsp;             &amp;&amp; (((BipedMech) this).countBadLegs() == 2)</b>
&nbsp;             &amp;&amp; (moveType != EntityMovementType.MOVE_VTOL_WALK)
&nbsp;             &amp;&amp; (moveType != EntityMovementType.MOVE_VTOL_RUN)) {
<b class="nc">&nbsp;                return new PilotingRollData(entityId,</b>
&nbsp;                                            TargetRoll.AUTOMATIC_FAIL,
<b class="nc">&nbsp;                                            getCrew().getPiloting() + 10, &quot;Both legs destroyed&quot;);</b>
<b class="nc">&nbsp;        } else if (this instanceof QuadMech) {</b>
<b class="nc">&nbsp;            if (((QuadMech) this).countBadLegs() &gt;= 3) {</b>
<b class="nc">&nbsp;                return new PilotingRollData(entityId,</b>
<b class="nc">&nbsp;                                            TargetRoll.AUTOMATIC_FAIL, getCrew().getPiloting()</b>
<b class="nc">&nbsp;                                                                       + (((Mech) this).countBadLegs() * 5),</b>
<b class="nc">&nbsp;                                            ((Mech) this).countBadLegs() + &quot; legs destroyed&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // entity shut down?
<b class="nc">&nbsp;        if (isShutDown() &amp;&amp; isShutDownThisPhase()) {</b>
<b class="nc">&nbsp;            return new PilotingRollData(entityId, TargetRoll.AUTOMATIC_FAIL,</b>
<b class="nc">&nbsp;                                        getCrew().getPiloting() + 3, &quot;Reactor shut down&quot;);</b>
<b class="nc">&nbsp;        } else if (isShutDown()) {</b>
<b class="nc">&nbsp;            return new PilotingRollData(entityId, TargetRoll.AUTOMATIC_FAIL,</b>
&nbsp;                                        TargetRoll.IMPOSSIBLE, &quot;Reactor shut down&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // okay, let&#39;s figure out the stuff then
<b class="nc">&nbsp;        roll = new PilotingRollData(entityId, getCrew().getPiloting(moveType),</b>
&nbsp;                                    &quot;Base piloting skill&quot;);
&nbsp;
&nbsp;        // Let&#39;s see if we have a modifier to our piloting skill roll. We&#39;ll
&nbsp;        // pass in the roll
&nbsp;        // object and adjust as necessary
<b class="nc">&nbsp;        roll = addEntityBonuses(roll);</b>
&nbsp;
&nbsp;        // add planetary condition modifiers
<b class="nc">&nbsp;        roll = addConditionBonuses(roll, moveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (isCarefulStand() &amp;&amp; ((getWalkMP() - mpUsed) &gt; 2)) {</b>
<b class="nc">&nbsp;            roll.addModifier(-2, &quot;careful stand&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_HARD_PILOT)) {</b>
<b class="nc">&nbsp;            roll.addModifier(+1, &quot;hard to pilot&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getPartialRepairs() != null) {</b>
<b class="nc">&nbsp;            if (getPartialRepairs().booleanOption(&quot;mech_gyro_1_crit&quot;)) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;Partial repair of Gyro (+1)&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (getPartialRepairs().booleanOption(&quot;mech_gyro_2_crit&quot;)) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;Partial repair of Gyro (+2)&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FATIGUE)</b>
<b class="nc">&nbsp;            &amp;&amp; crew.isPilotingFatigued()) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;fatigue&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (taserInterference &gt; 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(taserInterference, &quot;taser interference&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; isPowerReverse()) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;power reverse&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add in any piloting skill mods
&nbsp;     */
&nbsp;    public abstract PilotingRollData addEntityBonuses(PilotingRollData roll);
&nbsp;
&nbsp;    /**
&nbsp;     * Add in any modifiers due to global conditions like light/weather/etc.
&nbsp;     */
&nbsp;    public PilotingRollData addConditionBonuses(PilotingRollData roll,
&nbsp;            EntityMovementType moveType) {
&nbsp;
<b class="nc">&nbsp;        if (moveType == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || moveType == EntityMovementType.MOVE_VTOL_SPRINT) {
<b class="nc">&nbsp;            roll.addModifier(2, &quot;Sprinting&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PlanetaryConditions conditions = game.getPlanetaryConditions();</b>
&nbsp;        // check light conditions for &quot;running&quot; entities
<b class="nc">&nbsp;        if ((moveType == EntityMovementType.MOVE_RUN)</b>
&nbsp;            || (moveType == EntityMovementType.MOVE_SPRINT)
&nbsp;            || (moveType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;            || (moveType == EntityMovementType.MOVE_OVER_THRUST)
&nbsp;            || (moveType == EntityMovementType.MOVE_VTOL_SPRINT)) {
<b class="nc">&nbsp;            int lightPenalty = conditions.getLightPilotPenalty();</b>
<b class="nc">&nbsp;            if (lightPenalty &gt; 0) {</b>
<b class="nc">&nbsp;                roll.addModifier(lightPenalty,</b>
<b class="nc">&nbsp;                        conditions.getLightDisplayableName());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check weather conditions for all entities
<b class="nc">&nbsp;        int weatherMod = conditions.getWeatherPilotPenalty();</b>
<b class="nc">&nbsp;        if ((weatherMod != 0) &amp;&amp; !game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                &amp;&amp; ((null == crew) || !hasAbility(OptionsConstants.UNOFF_ALLWEATHER))) {</b>
<b class="nc">&nbsp;            roll.addModifier(weatherMod, conditions.getWeatherDisplayableName());</b>
&nbsp;        }
&nbsp;
&nbsp;        // check wind conditions for all entities
<b class="nc">&nbsp;        int windMod = conditions.getWindPilotPenalty(this);</b>
<b class="nc">&nbsp;        if ((windMod != 0) &amp;&amp; !game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                &amp;&amp; ((null == crew) || !hasAbility(OptionsConstants.UNOFF_ALLWEATHER))) {</b>
<b class="nc">&nbsp;            roll.addModifier(windMod, conditions.getWindDisplayableName());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is getting up. If so, returns the target roll for
&nbsp;     * the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkGetUp(MoveStep step,
&nbsp;            EntityMovementType moveType) {
&nbsp;
<b class="nc">&nbsp;        if ((step == null)</b>
<b class="nc">&nbsp;            || ((step.getType() != MoveStepType.GET_UP)</b>
<b class="nc">&nbsp;                    &amp;&amp; (step.getType() != MoveStepType.CAREFUL_STAND))) {</b>
<b class="nc">&nbsp;            return new PilotingRollData(id, TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: Entity is not attempting to get up.&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(moveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (this instanceof BipedMech) {</b>
<b class="nc">&nbsp;            if ((((Mech) this).countBadLegs() &gt;= 1)</b>
<b class="nc">&nbsp;                    &amp;&amp; (isLocationBad(Mech.LOC_LARM)</b>
<b class="nc">&nbsp;                            &amp;&amp; isLocationBad(Mech.LOC_RARM))) {</b>
<b class="nc">&nbsp;                roll.addModifier(TargetRoll.IMPOSSIBLE,</b>
&nbsp;                        &quot;can&#39;t get up with destroyed leg and arms&quot;);
<b class="nc">&nbsp;                return roll;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isHullDown() &amp;&amp; (this instanceof QuadMech)) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.AUTOMATIC_SUCCESS,</b>
&nbsp;                    &quot;getting up from hull down&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!needsRollToStand() &amp;&amp; !isGyroDestroyed()) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.AUTOMATIC_SUCCESS, &quot;\n&quot;</b>
<b class="nc">&nbsp;                    + getDisplayName()</b>
&nbsp;                    + &quot; does not need to make a piloting skill check &quot;
&nbsp;                    + &quot;to stand up because it has all four of &quot; + &quot;its legs.&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
&nbsp;        // append the reason modifier
<b class="nc">&nbsp;        roll.append(new PilotingRollData(getId(), 0, &quot;getting up&quot;));</b>
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, step);</b>
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is attempting to run with damage that would force a
&nbsp;     * PSR. If so, returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkRunningWithDamage(
&nbsp;            EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        int gyroDamage = getBadCriticals(CriticalSlot.TYPE_SYSTEM,</b>
&nbsp;                                         Mech.SYSTEM_GYRO, Mech.LOC_CT);
<b class="nc">&nbsp;        if (getGyroType() == Mech.GYRO_HEAVY_DUTY) {</b>
<b class="nc">&nbsp;            gyroDamage--; // HD gyro ignores 1st damage</b>
&nbsp;        }
<b class="nc">&nbsp;        if (((overallMoveType == EntityMovementType.MOVE_RUN)</b>
&nbsp;                || (overallMoveType == EntityMovementType.MOVE_SPRINT))
<b class="nc">&nbsp;            &amp;&amp; canFall() &amp;&amp; ((gyroDamage &gt; 0) || hasHipCrit())) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                                             &quot;running with damaged hip actuator or gyro&quot;));
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                             &quot;Check false: Entity is not attempting to run with damage&quot;);
&nbsp;        }
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll);</b>
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is attempting to sprint with MASC engaged. If so,
&nbsp;     * returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkSprintingWithMASC(
&nbsp;            EntityMovementType overallMoveType, int used) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((overallMoveType == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT)
<b class="nc">&nbsp;            &amp;&amp; (used &gt; ((int) Math.ceil(2.0 * this.getWalkMP())))) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                                             &quot;sprinting with active MASC/Supercharger&quot;));
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                             &quot;Check false: Entity is not attempting to sprint with MASC&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll);</b>
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is attempting to sprint with supercharger engaged.
&nbsp;     * If so, returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkSprintingWithSupercharger(
&nbsp;            EntityMovementType overallMoveType, int used) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((overallMoveType == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT)
<b class="nc">&nbsp;            &amp;&amp; (used &gt; ((int) Math.ceil(2.5 * this.getWalkMP())))) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                                             &quot;sprinting with active MASC/Supercharger&quot;));
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                             &quot;Check false: Entity is not attempting to sprint with Supercharger&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll);</b>
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is attempting to sprint with supercharger engaged.
&nbsp;     * If so, returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkUsingOverdrive (EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((overallMoveType == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT)
&nbsp;                &amp;&amp; (this instanceof Tank
<b class="nc">&nbsp;                        || (this instanceof QuadVee &amp;&amp; getConversionMode() == QuadVee.CONV_MODE_VEHICLE))) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0, &quot;using overdrive&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                             &quot;Check false: Entity is not using overdrive&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is attempting to increase two speed categories.
&nbsp;     * If so, returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkGunningIt (EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ACCELERATION)</b>
&nbsp;                &amp;&amp; (this instanceof Tank
<b class="nc">&nbsp;                        || (this instanceof QuadVee &amp;&amp; getConversionMode() == QuadVee.CONV_MODE_VEHICLE))) {</b>
<b class="nc">&nbsp;            if (((overallMoveType == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                    || overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT)
&nbsp;                    &amp;&amp; (movedLastRound == EntityMovementType.MOVE_WALK
&nbsp;                    || movedLastRound == EntityMovementType.MOVE_VTOL_WALK))
&nbsp;                    || ((overallMoveType == EntityMovementType.MOVE_RUN
&nbsp;                    || overallMoveType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                            &amp;&amp; (movedLastRound == EntityMovementType.MOVE_NONE
&nbsp;                            || movedLastRound == EntityMovementType.MOVE_JUMP
&nbsp;                            || movedLastRound == EntityMovementType.MOVE_SKID))) {
<b class="nc">&nbsp;                roll.append(new PilotingRollData(getId(), 0, &quot;gunning it&quot;));</b>
<b class="nc">&nbsp;                return roll;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                &quot;Check false: Entity is not gunning it&quot;);
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if an entity is passing through certain terrain while not moving
&nbsp;     * carefully
&nbsp;     */
&nbsp;    public PilotingRollData checkRecklessMove(MoveStep step,
&nbsp;            EntityMovementType moveType, IHex curHex, Coords lastPos,
&nbsp;            Coords curPos, IHex prevHex) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(moveType);</b>
&nbsp;        // no need to go further if movement is careful
<b class="nc">&nbsp;        if (step.isCareful()) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;moving carefully&quot;);</b>
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
&nbsp;        // this only applies in fog, night conditions, or if a hex along the
&nbsp;        // move path has ice
<b class="nc">&nbsp;        boolean isFoggy = game.getPlanetaryConditions().getFog() != PlanetaryConditions.FOG_NONE;</b>
<b class="nc">&nbsp;        boolean isDark = game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DUSK;</b>
&nbsp;
&nbsp;        // if we are jumping, then no worries
<b class="nc">&nbsp;        if (moveType == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;jumping is not reckless?&quot;);</b>
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we need to make this check on the first move forward and anytime the
&nbsp;        // hex is not clear or is a level change
<b class="nc">&nbsp;        if ((isFoggy || isDark) &amp;&amp; !lastPos.equals(curPos)</b>
<b class="nc">&nbsp;            &amp;&amp; lastPos.equals(step.getEntity().getPosition())) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0, &quot;moving recklessly&quot;));</b>
&nbsp;        }
&nbsp;        // FIXME: no perfect solution in the current code to determine if hex is
&nbsp;        // clear. I will use movement costs
<b class="nc">&nbsp;        else if ((isFoggy || isDark)</b>
<b class="nc">&nbsp;                 &amp;&amp; !lastPos.equals(curPos)</b>
<b class="nc">&nbsp;                 &amp;&amp; ((curHex.movementCost(this) &gt; 0) || ((null != prevHex) &amp;&amp; (prevHex</b>
<b class="nc">&nbsp;                                                                                       .getLevel() != curHex</b>
<b class="nc">&nbsp;                                                                                       .getLevel())))) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0, &quot;moving recklessly&quot;));</b>
&nbsp;            // ice conditions
<b class="nc">&nbsp;        } else if (curHex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0, &quot;moving recklessly&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;not moving recklessly&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        adjustDifficultTerrainPSRModifier(roll);</b>
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is landing (from a jump) with damage that would
&nbsp;     * force a PSR. If so, returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkLandingWithDamage(
&nbsp;            EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        int gyroHits = getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, Mech.LOC_CT);</b>
&nbsp;        //Heavy duty gyro does not force PSR until second hit
<b class="nc">&nbsp;        if (getGyroType() == Mech.GYRO_HEAVY_DUTY || getGyroType() == Mech.GYRO_SUPERHEAVY) {</b>
<b class="nc">&nbsp;            gyroHits--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (gyroHits &gt; 0 || hasLegActuatorCrit()) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                                             &quot;landing with damaged leg actuator or gyro&quot;));
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(</b>
&nbsp;                    TargetRoll.CHECK_FALSE,
&nbsp;                    &quot;Entity does not have gyro or leg actuator damage -- checking for purposes of determining PSR &quot; +
&nbsp;                    &quot;after jump.&quot;);
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is landing (from a jump) with a prototype JJ If so,
&nbsp;     * returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkLandingWithPrototypeJJ(
&nbsp;            EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (getJumpType() == Mech.JUMP_PROTOTYPE) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 3,</b>
&nbsp;                                             &quot;landing with prototype jump jets&quot;));
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(</b>
&nbsp;                    TargetRoll.CHECK_FALSE,
&nbsp;                    &quot;Entity does not have protype jump jets -- checking for purposes of determining PSR after jump.&quot;);
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if an entity is landing (from a jump) in heavy woods.
&nbsp;     */
&nbsp;    public PilotingRollData checkLandingInHeavyWoods(
&nbsp;            EntityMovementType overallMoveType, IHex curHex) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
<b class="nc">&nbsp;        if (curHex.containsTerrain(Terrains.WOODS, 2)) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                    &quot;landing in heavy woods&quot;));
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll);</b>
<b class="nc">&nbsp;        } else if (curHex.containsTerrain(Terrains.WOODS, 3)) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                    &quot;landing in ultra woods&quot;));
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;hex does not contain heavy or ultra woods&quot;);
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is landing (from a jump) on ice-covered water.
&nbsp;     */
&nbsp;    public PilotingRollData checkLandingOnIce(
&nbsp;            EntityMovementType overallMoveType, IHex curHex) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if (curHex.containsTerrain(Terrains.ICE)</b>
<b class="nc">&nbsp;            &amp;&amp; (curHex.terrainLevel(Terrains.WATER) &gt; 0)) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                                             &quot;landing on ice-covered water&quot;));
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll);</b>
<b class="nc">&nbsp;            adjustDifficultTerrainPSRModifier(roll);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                             &quot;hex is not covered by ice&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return a &lt;code&gt;PilotingRollData&lt;/code&gt; checking for whether this Entity
&nbsp;     * moved too fast due to low gravity
&nbsp;     *
&nbsp;     * @param step
&nbsp;     * @return
&nbsp;     */
&nbsp;    public PilotingRollData checkMovedTooFast(MoveStep step,
&nbsp;            EntityMovementType moveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, step);</b>
<b class="nc">&nbsp;        int maxSafeMP = 0;</b>
<b class="nc">&nbsp;        switch (moveType) {</b>
&nbsp;            case MOVE_JUMP:
<b class="nc">&nbsp;                maxSafeMP = getJumpMP(false);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MOVE_SPRINT:
&nbsp;            case MOVE_VTOL_SPRINT:
<b class="nc">&nbsp;                maxSafeMP = getSprintMP(false, true, true) + wigeBonus;</b>
<b class="nc">&nbsp;                if (isEligibleForPavementBonus() &amp;&amp; gotPavementBonus) {</b>
<b class="nc">&nbsp;                    maxSafeMP++;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
&nbsp;                // Max safe MP is based on whatever is the current maximum.
&nbsp;                // http://bg.battletech.com/forums/index.php?topic=6681.msg154097#msg154097
<b class="nc">&nbsp;                maxSafeMP = getRunMP(false, true, true) + wigeBonus;</b>
<b class="nc">&nbsp;                if (isEligibleForPavementBonus() &amp;&amp; gotPavementBonus) {</b>
<b class="nc">&nbsp;                    maxSafeMP++;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        if (step.getMpUsed() &gt; maxSafeMP) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                    &quot;used more MPs than at 1G possible&quot;));
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: Entity did not use more &quot;
&nbsp;                    + &quot;MPs walking/running than possible at 1G&quot;);
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity might skid on pavement. If so, returns the target
&nbsp;     * roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkSkid(EntityMovementType moveType, IHex prevHex,
&nbsp;            EntityMovementType overallMoveType, MoveStep prevStep, MoveStep currStep,
&nbsp;            int prevFacing, int curFacing, Coords lastPos, Coords curPos,
&nbsp;            boolean isInfantry, int distance) {
&nbsp;
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;        // If we aren&#39;t traveling along a road, apply terrain modifiers
<b class="nc">&nbsp;        if (!((prevStep == null || prevStep.isPavementStep()) &amp;&amp; currStep.isPavementStep())) {</b>
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll, lastPos);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isAirborne() || isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: flying entities don&#39;t skid&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isInfantry) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: infantry don&#39;t skid&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (moveType == EntityMovementType.MOVE_JUMP) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: jumping entities don&#39;t skid&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((null != prevStep) &amp;&amp; prevStep.isHasJustStood()) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: getting up entities don&#39;t skid&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
&nbsp;        /*
&nbsp;         * IHex curHex = null; if (null != curPos) { curHex =
&nbsp;         * game.getBoard().getHex(curPos); }
&nbsp;         */
&nbsp;
&nbsp;        boolean prevStepPavement;
<b class="nc">&nbsp;        if (prevStep != null) {</b>
<b class="nc">&nbsp;            prevStepPavement = prevStep.isPavementStep();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            prevStepPavement = prevHex.hasPavement();</b>
&nbsp;        }
&nbsp;
&nbsp;        // TODO: add check for elevation of pavement, road,
&nbsp;        // or bridge matches entity elevation.
<b class="nc">&nbsp;        if ((prevHex != null) &amp;&amp; prevHex.containsTerrain(Terrains.ICE)</b>
&nbsp;                &amp;&amp; (((movementMode != EntityMovementMode.HOVER)
&nbsp;                        &amp;&amp; (movementMode != EntityMovementMode.WIGE))
&nbsp;                        || (((movementMode == EntityMovementMode.HOVER)
&nbsp;                                || (movementMode == EntityMovementMode.WIGE))
<b class="nc">&nbsp;                                &amp;&amp; ((game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                        .getWeather() == PlanetaryConditions.WE_HEAVY_SNOW)</b>
<b class="nc">&nbsp;                                        || (game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                                .getWeather() == PlanetaryConditions.WE_BLIZZARD)</b>
<b class="nc">&nbsp;                                        || (game.getPlanetaryConditions()</b>
<b class="nc">&nbsp;                                                .getWindStrength() &gt;= PlanetaryConditions.WI_STORM))))</b>
<b class="nc">&nbsp;                &amp;&amp; (prevFacing != curFacing) &amp;&amp; !lastPos.equals(curPos)) {</b>
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(),</b>
<b class="nc">&nbsp;                    getMovementBeforeSkidPSRModifier(distance),</b>
&nbsp;                    &quot;turning on ice&quot;));
<b class="nc">&nbsp;            adjustDifficultTerrainPSRModifier(roll);</b>
<b class="nc">&nbsp;            return roll;</b>
<b class="nc">&nbsp;        } else if ((prevStepPavement</b>
&nbsp;                &amp;&amp; ((overallMoveType == EntityMovementType.MOVE_RUN)
&nbsp;                        || (overallMoveType == EntityMovementType.MOVE_SPRINT))
&nbsp;                &amp;&amp; (movementMode != EntityMovementMode.HOVER)
&nbsp;                &amp;&amp; (movementMode != EntityMovementMode.WIGE))
<b class="nc">&nbsp;                &amp;&amp; (prevFacing != curFacing) &amp;&amp; !lastPos.equals(curPos)) {</b>
<b class="nc">&nbsp;            if (this instanceof Mech) {</b>
<b class="nc">&nbsp;                roll.append(new PilotingRollData(getId(),</b>
<b class="nc">&nbsp;                        getMovementBeforeSkidPSRModifier(distance),</b>
&nbsp;                        &quot;running &amp; turning on pavement&quot;));
&nbsp;            } else {
<b class="nc">&nbsp;                roll.append(new PilotingRollData(getId(),</b>
<b class="nc">&nbsp;                        getMovementBeforeSkidPSRModifier(distance),</b>
&nbsp;                        &quot;reckless driving on pavement&quot;));
&nbsp;            }
<b class="nc">&nbsp;            adjustDifficultTerrainPSRModifier(roll);</b>
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: Entity is not apparently skidding&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is moving into rubble. If so, returns the target
&nbsp;     * roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkRubbleMove(MoveStep step,
&nbsp;            EntityMovementType moveType, IHex curHex, Coords lastPos,
&nbsp;            Coords curPos, boolean isLastStep, boolean isPavementStep) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;        boolean enteringRubble = true;</b>
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, curPos, enteringRubble);</b>
&nbsp;
<b class="nc">&nbsp;        if (!lastPos.equals(curPos)</b>
&nbsp;                &amp;&amp; ((moveType != EntityMovementType.MOVE_JUMP) || isLastStep)
<b class="nc">&nbsp;                &amp;&amp; (curHex.terrainLevel(Terrains.RUBBLE) &gt; 0) &amp;&amp; !isPavementStep</b>
<b class="nc">&nbsp;                &amp;&amp; (step.getElevation() == 0) &amp;&amp; canFall()) {</b>
<b class="nc">&nbsp;            adjustDifficultTerrainPSRModifier(roll);</b>
<b class="nc">&nbsp;            if (hasAbility(OptionsConstants.PILOT_TM_MOUNTAINEER)) {</b>
<b class="nc">&nbsp;                roll.addModifier(-1, &quot;Mountaineer&quot;);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: Entity is not entering rubble&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is moving into a hex that might cause it to bog
&nbsp;     * down. If so, returns the target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkBogDown(MoveStep step,
&nbsp;            EntityMovementType moveType, IHex curHex, Coords lastPos,
&nbsp;            Coords curPos, int lastElev, boolean isPavementStep) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;        int bgMod = curHex.getBogDownModifier(getMovementMode(),</b>
&nbsp;                this instanceof LargeSupportTank);
<b class="nc">&nbsp;        if ((!lastPos.equals(curPos) || (step.getElevation() != lastElev))</b>
&nbsp;                &amp;&amp; (bgMod != TargetRoll.AUTOMATIC_SUCCESS)
&nbsp;                &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;                &amp;&amp; (step.getElevation() == 0) &amp;&amp; !isPavementStep) {</b>
<b class="nc">&nbsp;            roll.append(</b>
<b class="nc">&nbsp;                    new PilotingRollData(getId(), bgMod, &quot;avoid bogging down&quot;));</b>
<b class="nc">&nbsp;            if ((this instanceof Mech) &amp;&amp; ((Mech) this).isSuperHeavy()) {</b>
<b class="nc">&nbsp;                roll.addModifier(1, &quot;superheavy mech avoiding bogging down&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (hasAbility(OptionsConstants.PILOT_TM_SWAMP_BEAST)) {</b>
<b class="nc">&nbsp;                roll.addModifier(-1, &quot;Swamp Beast&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            addPilotingModifierForTerrain(roll, curPos, false);</b>
<b class="nc">&nbsp;            adjustDifficultTerrainPSRModifier(roll);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: Not entering bog-down terrain, &quot;
&nbsp;                    + &quot;or jumping/hovering over such terrain&quot;);
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is moving into depth 1+ water. If so, returns the
&nbsp;     * target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkWaterMove(MoveStep step,
&nbsp;            EntityMovementType moveType, IHex curHex, Coords lastPos,
&nbsp;            Coords curPos, boolean isPavementStep) {
<b class="nc">&nbsp;        if ((curHex.terrainLevel(Terrains.WATER) &gt; 0)</b>
<b class="nc">&nbsp;            &amp;&amp; (step.getElevation() &lt; 0) &amp;&amp; !lastPos.equals(curPos)</b>
&nbsp;            &amp;&amp; (moveType != EntityMovementType.MOVE_JUMP)
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.HOVER)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.SUBMARINE)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.INF_UMU)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.BIPED_SWIM)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.QUAD_SWIM)</b>
<b class="nc">&nbsp;            &amp;&amp; (getMovementMode() != EntityMovementMode.WIGE)</b>
<b class="nc">&nbsp;            &amp;&amp; canFall()</b>
&nbsp;            &amp;&amp; !isPavementStep) {
<b class="nc">&nbsp;            return checkWaterMove(curHex.terrainLevel(Terrains.WATER), moveType);</b>
&nbsp;        }
<b class="nc">&nbsp;        return checkWaterMove(0, moveType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is moving into depth 1+ water. If so, returns the
&nbsp;     * target roll for the piloting skill check.
&nbsp;     */
&nbsp;    public PilotingRollData checkWaterMove(int waterLevel,
&nbsp;            EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
&nbsp;        int mod;
<b class="nc">&nbsp;        if (waterLevel == 1) {</b>
<b class="nc">&nbsp;            mod = -1;</b>
<b class="nc">&nbsp;        } else if (waterLevel == 2) {</b>
<b class="nc">&nbsp;            mod = 0;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            mod = 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((waterLevel &gt; 1) &amp;&amp; hasAbility(OptionsConstants.PILOT_TM_FROGMAN)</b>
&nbsp;                &amp;&amp; ((this instanceof Mech) || (this instanceof Protomech))) {
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), -1, &quot;Frogman&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (waterLevel &gt; 0) {</b>
&nbsp;            // append the reason modifier
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), mod,</b>
&nbsp;                    &quot;entering Depth &quot; + waterLevel + &quot; Water&quot;));
<b class="nc">&nbsp;            adjustDifficultTerrainPSRModifier(roll);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: No water here.&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the entity is being swarmed. If so, returns the target roll for
&nbsp;     * the piloting skill check to dislodge them.
&nbsp;     */
&nbsp;    public PilotingRollData checkDislodgeSwarmers(MoveStep step,
&nbsp;            EntityMovementType moveType) {
&nbsp;
&nbsp;        // If we&#39;re not being swarmed, return CHECK_FALSE
<b class="nc">&nbsp;        if (Entity.NONE == getSwarmAttackerId()) {</b>
<b class="nc">&nbsp;            return new PilotingRollData(getId(), TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: No swarmers attached&quot;);
&nbsp;        }
&nbsp;
&nbsp;        // append the reason modifier
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(moveType);</b>
<b class="nc">&nbsp;        roll.append(new PilotingRollData(getId(), 0,</b>
&nbsp;                &quot;attempting to dislodge swarmers by dropping prone&quot;));
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, step);</b>
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if an entity is moving through building walls. Note: this
&nbsp;     * method returns true/false, unlike the other checkStuff() methods above.
&nbsp;     *
&nbsp;     * @return 0, no eligible building; 1, exiting; 2, entering; 3, both; 4,
&nbsp;     * stepping on roof, 8 changing elevations within a building
&nbsp;     */
&nbsp;    public int checkMovementInBuilding(MoveStep step, MoveStep prevStep,
&nbsp;                                       Coords curPos, Coords prevPos) {
<b class="nc">&nbsp;        if ((prevPos == null)</b>
<b class="nc">&nbsp;            || (prevPos.equals(curPos) &amp;&amp; !(this instanceof Protomech))) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex curHex = game.getBoard().getHex(curPos);</b>
<b class="nc">&nbsp;        IHex prevHex = game.getBoard().getHex(prevPos);</b>
&nbsp;        // ineligible because of movement type or unit type
<b class="nc">&nbsp;        if (isAirborne()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((this instanceof Infantry)</b>
<b class="nc">&nbsp;            &amp;&amp; (step.getMovementType(false) != EntityMovementType.MOVE_JUMP)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((this instanceof Protomech) &amp;&amp; (prevStep != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (prevStep.getMovementType(false) == EntityMovementType.MOVE_JUMP)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check for movement inside a hangar
<b class="nc">&nbsp;        Building curBldg = game.getBoard().getBuildingAt(curPos);</b>
<b class="nc">&nbsp;        if ((null != curBldg)</b>
<b class="nc">&nbsp;            &amp;&amp; curBldg.isIn(prevPos)</b>
<b class="nc">&nbsp;            &amp;&amp; (curBldg.getBldgClass() == Building.HANGAR)</b>
<b class="nc">&nbsp;            &amp;&amp; (curHex.terrainLevel(Terrains.BLDG_ELEV) &gt; height())</b>
<b class="nc">&nbsp;            &amp;&amp; (step.getElevation() &lt; curHex</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.BLDG_ELEV))) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int rv = 0;</b>
&nbsp;        // check current hex for building
<b class="nc">&nbsp;        if (step.getElevation() &lt; curHex.terrainLevel(Terrains.BLDG_ELEV)) {</b>
<b class="nc">&nbsp;            rv += 2;</b>
<b class="nc">&nbsp;        } else if (((step.getElevation() == curHex</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.BLDG_ELEV)) || (step.getElevation() == curHex</b>
<b class="nc">&nbsp;                .terrainLevel(Terrains.BRIDGE_ELEV)))</b>
<b class="nc">&nbsp;                   &amp;&amp; (step.getMovementType(false) != EntityMovementType.MOVE_JUMP)) {</b>
<b class="nc">&nbsp;            rv += 4;</b>
&nbsp;        }
&nbsp;        // check previous hex for building
<b class="nc">&nbsp;        if (prevHex != null) {</b>
<b class="nc">&nbsp;            int prevEl = getElevation();</b>
<b class="nc">&nbsp;            if (prevStep != null) {</b>
<b class="nc">&nbsp;                prevEl = prevStep.getElevation();</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((prevEl &lt; prevHex.terrainLevel(Terrains.BLDG_ELEV))</b>
<b class="nc">&nbsp;                &amp;&amp; ((curHex.terrainLevel(Terrains.BLDG_CLASS) != 1) || (getHeight() &gt;= curHex</b>
<b class="nc">&nbsp;                    .terrainLevel(Terrains.BLDG_ELEV)))) {</b>
<b class="nc">&nbsp;                rv += 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // check to see if its a wall
<b class="nc">&nbsp;        if (rv &gt; 1) {</b>
<b class="nc">&nbsp;            Building bldgEntered = null;</b>
<b class="nc">&nbsp;            bldgEntered = game.getBoard().getBuildingAt(curPos);</b>
<b class="nc">&nbsp;            if (bldgEntered.getType() == Building.WALL) {</b>
<b class="nc">&nbsp;                return 4;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Check for changing levels within a building
<b class="nc">&nbsp;        if (curPos.equals(prevPos)</b>
&nbsp;            &amp;&amp; (curBldg != null)
&nbsp;            &amp;&amp; (prevStep != null)
<b class="nc">&nbsp;            &amp;&amp; (step.getElevation() != prevStep.getElevation())</b>
<b class="nc">&nbsp;            &amp;&amp; ((step.getType() == MoveStepType.UP) || (step.getType() == MoveStepType.DOWN))) {</b>
<b class="nc">&nbsp;            rv = 8;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((this instanceof Infantry) || (this instanceof Protomech)) {</b>
<b class="nc">&nbsp;            if ((rv != 2) &amp;&amp; (rv != 8) &amp;&amp; (rv != 10)) {</b>
<b class="nc">&nbsp;                rv = 0;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return rv;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates and returns the roll for an entity moving in buildings.
&nbsp;     */
&nbsp;    public PilotingRollData rollMovementInBuilding(Building bldg, int distance,
&nbsp;                                                   String why, EntityMovementType overallMoveType) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((this instanceof Mech) &amp;&amp; ((Mech) this).isSuperHeavy()) {</b>
<b class="nc">&nbsp;            roll.addModifier(4, &quot;superheavy mech moving in building&quot;);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (this.hasQuirk(OptionsConstants.QUIRK_NEG_OVERSIZED)) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;oversized unit&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int mod = 0;</b>
&nbsp;        String desc;
&nbsp;
<b class="nc">&nbsp;        if (why.equals(&quot;&quot;)) {</b>
<b class="nc">&nbsp;            desc = &quot;moving through &quot;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            desc = why + &quot; &quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (bldg.getType()) {</b>
&nbsp;            case Building.LIGHT:
<b class="nc">&nbsp;                desc = &quot;Light&quot;;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Building.MEDIUM:
<b class="nc">&nbsp;                if (bldg.getBldgClass() != Building.HANGAR) {</b>
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                    desc = &quot;Medium&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bldg.getBldgClass() &gt;= Building.FORTRESS) {</b>
<b class="nc">&nbsp;                    mod = 2;</b>
<b class="nc">&nbsp;                    desc = desc + &quot; Fortress&quot;;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Building.HEAVY:
<b class="nc">&nbsp;                mod = 2;</b>
<b class="nc">&nbsp;                desc = &quot;Heavy&quot;;</b>
<b class="nc">&nbsp;                if (bldg.getBldgClass() == Building.HANGAR) {</b>
<b class="nc">&nbsp;                    mod = 1;</b>
<b class="nc">&nbsp;                    desc = desc + &quot; Hangar&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bldg.getBldgClass() == Building.FORTRESS) {</b>
<b class="nc">&nbsp;                    mod = 3;</b>
<b class="nc">&nbsp;                    desc = desc + &quot; Fortress&quot;;</b>
&nbsp;                }
&nbsp;                // if(bldg.getBldgClass() == Building.CASTLE_BRIAN) {
&nbsp;                // mod = 4;
&nbsp;                // desc = desc + &quot; Castle Brian&quot;;
&nbsp;                // }
&nbsp;                break;
&nbsp;            case Building.HARDENED:
<b class="nc">&nbsp;                mod = 5;</b>
<b class="nc">&nbsp;                desc = &quot;Hardened&quot;;</b>
<b class="nc">&nbsp;                if (bldg.getBldgClass() == Building.HANGAR) {</b>
<b class="nc">&nbsp;                    mod = 3;</b>
<b class="nc">&nbsp;                    desc = desc + &quot; Hangar&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (bldg.getBldgClass() == Building.FORTRESS) {</b>
<b class="nc">&nbsp;                    mod = 4;</b>
<b class="nc">&nbsp;                    desc = desc + &quot; Fortress&quot;;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case Building.WALL:
<b class="nc">&nbsp;                mod = 12;</b>
<b class="nc">&nbsp;                desc = &quot;&quot;;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        // append the reason modifier
<b class="nc">&nbsp;        roll.append(new PilotingRollData(getId(), mod, &quot;moving through &quot; + desc</b>
<b class="nc">&nbsp;                                                       + &quot; &quot; + bldg.getName()));</b>
<b class="nc">&nbsp;        adjustDifficultTerrainPSRModifier(roll);</b>
&nbsp;
&nbsp;        // Modify the roll by the distance moved so far.
<b class="nc">&nbsp;        if (distance &gt;= 25) {</b>
<b class="nc">&nbsp;            roll.addModifier(6, &quot;moved 25+ hexes&quot;);</b>
<b class="nc">&nbsp;        } else if (distance &gt;= 18) {</b>
<b class="nc">&nbsp;            roll.addModifier(5, &quot;moved 18-24 hexes&quot;);</b>
<b class="nc">&nbsp;        } else if (distance &gt;= 10) {</b>
<b class="nc">&nbsp;            roll.addModifier(4, &quot;moved 10+ hexes&quot;);</b>
<b class="nc">&nbsp;        } else if (distance &gt;= 7) {</b>
<b class="nc">&nbsp;            roll.addModifier(3, &quot;moved 7-9 hexes&quot;);</b>
<b class="nc">&nbsp;        } else if (distance &gt;= 5) {</b>
<b class="nc">&nbsp;            roll.addModifier(2, &quot;moved 5-6 hexes&quot;);</b>
<b class="nc">&nbsp;        } else if (distance &gt;= 3) {</b>
<b class="nc">&nbsp;            roll.addModifier(1, &quot;moved 3-4 hexes&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only check for satisfied turn mode for Tanks or QuadVees in vehicle mode, or LAMs in
&nbsp;     * AirMech mode. Except for LAMs, check whether advanced vehicle ground movement is enabled.
&nbsp;     *
&nbsp;     * @return True if this &lt;code&gt;Entity&lt;/code&gt; must make a driving check for turning too sharply.
&nbsp;     */
&nbsp;    public boolean usesTurnMode() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If using advanced vehicle ground movement, checks whether the unit is required to make
&nbsp;     * a driving roll for turning, and if so whether it succeeds.
&nbsp;     *
&nbsp;     * @param overallMoveType   The type move movement used this turn.
&nbsp;     * @param straightLineHexes The number of hexes that were moved in a straight line before turning.
&nbsp;     * @param mpUsed            The total number of movement points used by the entity during the current turn.
&nbsp;     * @param currPos           The position of the hex where the turn is taking place, which may
&nbsp;     *                          modify a roll for terrain.
&nbsp;     * @return                  True if the entity failed a driving check due to turning too sharply.
&nbsp;     */
&nbsp;    public PilotingRollData checkTurnModeFailure(EntityMovementType overallMoveType,
&nbsp;            int straightLineHexes, int mpUsed, Coords currPos) {
&nbsp;
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;        //Turn mode
<b class="nc">&nbsp;        if (!usesTurnMode()) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: unit does not use turn modes.&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int turnMode = mpUsed / 5;</b>
<b class="nc">&nbsp;        if (straightLineHexes &gt;= turnMode) {</b>
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: unit did not exceed turn mode.&quot;);
<b class="nc">&nbsp;            return roll;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getWeightClass() &lt; EntityWeightClass.WEIGHT_MEDIUM</b>
<b class="nc">&nbsp;                || getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;light vehicle&quot;);</b>
<b class="nc">&nbsp;        } else if (getWeightClass() == EntityWeightClass.WEIGHT_ASSAULT</b>
<b class="nc">&nbsp;                || getWeightClass() == EntityWeightClass.WEIGHT_SUPER_HEAVY) {</b>
<b class="nc">&nbsp;            roll.addModifier(+1, &quot;assault vehicle&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IHex currHex = game.getBoard().getHex(currPos);</b>
<b class="nc">&nbsp;        if (movementMode != EntityMovementMode.HOVER</b>
&nbsp;                &amp;&amp; movementMode != EntityMovementMode.VTOL
&nbsp;                &amp;&amp; movementMode != EntityMovementMode.WIGE) {
<b class="nc">&nbsp;            if (currHex.containsTerrain(Terrains.MUD)) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;mud&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (currHex.containsTerrain(Terrains.ICE)) {</b>
<b class="nc">&nbsp;                roll.addModifier(movementMode == EntityMovementMode.TRACKED? 1 : 2, &quot;ice&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().isSleeting()</b>
<b class="nc">&nbsp;                    || game.getPlanetaryConditions().getFog() == PlanetaryConditions.FOG_HEAVY</b>
<b class="nc">&nbsp;                    || game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_RAIN</b>
<b class="nc">&nbsp;                    || game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_GUSTING_RAIN</b>
<b class="nc">&nbsp;                    || game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_DOWNPOUR) {</b>
<b class="nc">&nbsp;                roll.addModifier(+1, &quot;fog/rain&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_HEAVY_SNOW</b>
<b class="nc">&nbsp;                    || game.getPlanetaryConditions().getWeather() == PlanetaryConditions.WE_BLIZZARD) {</b>
<b class="nc">&nbsp;                roll.addModifier(movementMode == EntityMovementMode.TRACKED? 1 : 2, &quot;snow&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        roll.addModifier(turnMode - straightLineHexes, &quot;did not satisfy turn mode&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate the piloting skill roll modifier, based upon the number of
&nbsp;     * hexes moved this phase. Used for skidding.
&nbsp;     */
&nbsp;    public int getMovementBeforeSkidPSRModifier(int distance) {
<b class="nc">&nbsp;        int mod = -1;</b>
&nbsp;
<b class="nc">&nbsp;        if (distance &gt; 24) {</b>
<b class="nc">&nbsp;            mod = 6;</b>
<b class="nc">&nbsp;        } else if (distance &gt; 17) {</b>
<b class="nc">&nbsp;            mod = 5;</b>
<b class="nc">&nbsp;        } else if (distance &gt; 10) {</b>
<b class="nc">&nbsp;            mod = 4;</b>
<b class="nc">&nbsp;        } else if (distance &gt; 7) {</b>
<b class="nc">&nbsp;            mod = 2;</b>
<b class="nc">&nbsp;        } else if (distance &gt; 4) {</b>
<b class="nc">&nbsp;            mod = 1;</b>
<b class="nc">&nbsp;        } else if (distance &gt; 2) {</b>
<b class="nc">&nbsp;            mod = 0;</b>
&nbsp;        } else {
&nbsp;            // 0-2 hexes
<b class="nc">&nbsp;            mod = -1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.PILOT_MANEUVERING_ACE)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * calculate any changes to the PSR modifier for entering difficult terrain
&nbsp;     */
&nbsp;    private void adjustDifficultTerrainPSRModifier(PilotingRollData psr) {
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT) &amp;&amp; (getCrew().getPiloting() &gt; 3)) {</b>
<b class="nc">&nbsp;            psr.addModifier(-1, &quot;easy to pilot&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_UNBALANCED)) {</b>
<b class="nc">&nbsp;            psr.addModifier(+1, &quot;unbalanced&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The maximum elevation change the entity can cross
&nbsp;     */
&nbsp;    public abstract int getMaxElevationChange();
&nbsp;
&nbsp;    /**
&nbsp;     * by default, entities can move as far down as they can move up
&nbsp;     */
&nbsp;    public int getMaxElevationDown() {
<b class="nc">&nbsp;        return getMaxElevationDown(getElevation());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the maximum number of downard elevation changes a unit can make.
&nbsp;     * For some units (namely, WiGEs), this can depend upon their current
&nbsp;     * elevation (since elevation determines if the WiGEs is using WiGE movement
&nbsp;     * or not).
&nbsp;     *
&nbsp;     * @param currElevation
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getMaxElevationDown(int currElevation) {
<b class="nc">&nbsp;        return getMaxElevationChange();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a transportation component to this Entity. Please note, this method
&nbsp;     * should only be called during this entity&#39;s construction.
&nbsp;     *
&nbsp;     * @param component - One of this new entity&#39;s &lt;code&gt;Transporter&lt;/code&gt;s.
&nbsp;     */
&nbsp;    public void addTransporter(Transporter component) {
<b class="nc">&nbsp;        addTransporter(component, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Add a transportation component to this Entity. Please note, this method
&nbsp;     * should only be called during this entity&#39;s construction.
&nbsp;     *
&nbsp;     * @param component - One of this new entity&#39;s &lt;code&gt;Transporter&lt;/code&gt;s.
&nbsp;     * @param isOmniPod - Whether this is part of an omni unit&#39;s pod space.
&nbsp;     */
&nbsp;    public void addTransporter(Transporter component, boolean isOmniPod) {
<b class="nc">&nbsp;        component.setGame(game);</b>
<b class="nc">&nbsp;        transports.add(component);</b>
<b class="nc">&nbsp;        if (isOmniPod) {</b>
<b class="nc">&nbsp;        	omniPodTransports.add(component);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void removeTransporter(Transporter t) {
<b class="nc">&nbsp;        transports.remove(t);</b>
<b class="nc">&nbsp;        omniPodTransports.remove(t);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Remove all transportation components from this Entity. Should probably
&nbsp;     * only be called during construction.
&nbsp;     */
&nbsp;    public void removeAllTransporters() {
<b class="nc">&nbsp;        transports = new Vector&lt;Transporter&gt;();</b>
<b class="nc">&nbsp;        omniPodTransports.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this object can accept the given unit. The unit may not be
&nbsp;     * of the appropriate type or there may be no room for the unit.
&nbsp;     *
&nbsp;     * @param unit - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit can be loaded, &lt;code&gt;false&lt;/code&gt;
&nbsp;     * otherwise.
&nbsp;     */
&nbsp;    public boolean canLoad(Entity unit, boolean checkElev) {
&nbsp;        // For now, if it&#39;s infantry, it can&#39;t load anything.
&nbsp;        // Period!
<b class="nc">&nbsp;        if (this instanceof Infantry) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // one can only load one&#39;s own team&#39;s units!
<b class="nc">&nbsp;        if (!unit.isEnemyOf(this)) {</b>
&nbsp;
&nbsp;            /* Mechanized BA and protomechs occupy the same space, and if one is already
&nbsp;             * present the other cannot be loaded. It is still possible for a support vee
&nbsp;             * to carry mechanized BA externally and protos in a bay, so we need to check for
&nbsp;             * external units first then check for conflicts only for other external mounts. */
<b class="nc">&nbsp;            boolean hasExternalBA = false;</b>
<b class="nc">&nbsp;            boolean hasExternalProtos = false;</b>
<b class="nc">&nbsp;            boolean hasExternalUltraheavy = false;</b>
<b class="nc">&nbsp;            if (unit.hasETypeFlag(Entity.ETYPE_BATTLEARMOR)</b>
<b class="nc">&nbsp;                    || unit.hasETypeFlag(Entity.ETYPE_PROTOMECH)) {</b>
<b class="nc">&nbsp;                for (Transporter t : transports) {</b>
&nbsp;                    // ProtomechClampMount is a subclass of BattleArmorHandles so we need to check it first
<b class="nc">&nbsp;                    if (t instanceof ProtomechClampMount) {</b>
<b class="nc">&nbsp;                        hasExternalProtos |= t.getUnused() == 0;</b>
<b class="nc">&nbsp;                        hasExternalUltraheavy |= t.getLoadedUnits().stream()</b>
<b class="nc">&nbsp;                                .anyMatch(e -&gt; e.getWeightClass() == EntityWeightClass.WEIGHT_SUPER_HEAVY);</b>
<b class="nc">&nbsp;                    } else if (t instanceof BattleArmorHandles) {</b>
<b class="nc">&nbsp;                        hasExternalBA |= t.getUnused() == 0;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // We can&#39;t mix BA and protos, and we can&#39;t mount an ultraheavy proto if already carrying another.
<b class="nc">&nbsp;            boolean noExternalMount = (unit.hasETypeFlag(Entity.ETYPE_BATTLEARMOR) &amp;&amp; hasExternalProtos)</b>
<b class="nc">&nbsp;                    || (unit.hasETypeFlag(Entity.ETYPE_PROTOMECH) &amp;&amp; hasExternalBA);</b>
&nbsp;
<b class="nc">&nbsp;            if (unit.hasETypeFlag(Entity.ETYPE_PROTOMECH) &amp;&amp; hasExternalProtos) {</b>
<b class="nc">&nbsp;                noExternalMount |= hasExternalUltraheavy</b>
<b class="nc">&nbsp;                        || (unit.getWeightClass() == EntityWeightClass.WEIGHT_SUPER_HEAVY);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (Transporter t : transports) {</b>
<b class="nc">&nbsp;                if (t.canLoad(unit)</b>
<b class="nc">&nbsp;                        &amp;&amp; (!checkElev || unit.getElevation() == getElevation())</b>
&nbsp;                        &amp;&amp; !((t instanceof BattleArmorHandles) &amp;&amp; noExternalMount)) {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we got here, none of our transports can carry the unit.
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canLoad(Entity unit) {
<b class="nc">&nbsp;        return this.canLoad(unit, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Load the given unit.
&nbsp;     *
&nbsp;     * @param unit - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
&nbsp;     * @throws IllegalArgumentException If the unit can&#39;t be loaded
&nbsp;     */
&nbsp;    public void load(Entity unit, boolean checkElev, int bayNumber) {
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // find the one that can load the unit.
&nbsp;        // Stop looking after the first match.
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if (next.canLoad(unit)</b>
<b class="nc">&nbsp;                &amp;&amp; (!checkElev || (unit.getElevation() == getElevation()))</b>
<b class="nc">&nbsp;                &amp;&amp; ((bayNumber == -1) || (((Bay) next).getBayNumber() == bayNumber))) {</b>
<b class="nc">&nbsp;                next.load(unit);</b>
<b class="nc">&nbsp;                unit.setTargetBay(-1); // Reset the target bay for later.</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If we got to this point, then we can&#39;t load the unit.
<b class="nc">&nbsp;        throw new IllegalArgumentException(getShortName() + &quot; can not load &quot;</b>
<b class="nc">&nbsp;                                           + unit.getShortName());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void load(Entity unit, boolean checkElev) {
<b class="nc">&nbsp;        this.load(unit, checkElev, -1);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void load(Entity unit, int bayNumber) {
<b class="nc">&nbsp;        this.load(unit, true, bayNumber);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void load(Entity unit) {
<b class="nc">&nbsp;        this.load(unit, true, -1);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Recover the given unit. Only for ASF and Small Craft
&nbsp;     *
&nbsp;     * @param unit - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
&nbsp;     * @throws IllegalArgumentException If the unit can&#39;t be loaded
&nbsp;     */
&nbsp;    public void recover(Entity unit) {
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // find those that can load the unit.
&nbsp;        // load the unit into the best match.
<b class="nc">&nbsp;    	int choice = 0;</b>
<b class="nc">&nbsp;    	for (Transporter nextbay : transports) {</b>
<b class="nc">&nbsp;    		if (nextbay.canLoad(unit) &amp;&amp; (unit.getElevation() == getElevation())) {</b>
<b class="nc">&nbsp;    			if (nextbay instanceof DockingCollar) {</b>
<b class="nc">&nbsp;    				choice = 3;</b>
&nbsp;    			}
<b class="nc">&nbsp;    			if (nextbay instanceof ASFBay) {</b>
<b class="nc">&nbsp;    				choice = 2;</b>
&nbsp;    			}
<b class="nc">&nbsp;    			if (nextbay instanceof SmallCraftBay) {</b>
<b class="nc">&nbsp;    			choice = 1;</b>
&nbsp;    			}
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
<b class="nc">&nbsp;    	if (choice == 3) {</b>
<b class="nc">&nbsp;    		for (Transporter nextbay : transports) {</b>
<b class="nc">&nbsp;    			while (nextbay instanceof DockingCollar) {</b>
<b class="nc">&nbsp;    				((DockingCollar) nextbay).recover(unit);</b>
<b class="nc">&nbsp;    				return;</b>
&nbsp;    			}
<b class="nc">&nbsp;    		}</b>
<b class="nc">&nbsp;    	}else if (choice == 2) {</b>
<b class="nc">&nbsp;    		for (Bay nextbay : getTransportBays()) {</b>
<b class="nc">&nbsp;    			while (nextbay instanceof ASFBay) {</b>
<b class="nc">&nbsp;    				((ASFBay) nextbay).recover(unit);</b>
<b class="nc">&nbsp;    				return;</b>
&nbsp;    			}
<b class="nc">&nbsp;    		}</b>
<b class="nc">&nbsp;    	} else if (choice == 1) {</b>
<b class="nc">&nbsp;    		for (Bay nextbay : getTransportBays()) {</b>
<b class="nc">&nbsp;    			while (nextbay instanceof SmallCraftBay) {</b>
<b class="nc">&nbsp;    				((SmallCraftBay) nextbay).recover(unit);</b>
<b class="nc">&nbsp;    				return;</b>
&nbsp;    			}
<b class="nc">&nbsp;    		}</b>
&nbsp;    	}
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * cycle through and update Bays
&nbsp;     */
&nbsp;    public void updateBays() {
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if (next instanceof ASFBay) {</b>
<b class="nc">&nbsp;                ASFBay nextBay = (ASFBay) next;</b>
<b class="nc">&nbsp;                nextBay.updateSlots();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (next instanceof SmallCraftBay) {</b>
<b class="nc">&nbsp;                SmallCraftBay nextBay = (SmallCraftBay) next;</b>
<b class="nc">&nbsp;                nextBay.updateSlots();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Damages a randomly determined bay door on the entity, if one exists
&nbsp;     */
&nbsp;    public String damageBayDoor() {
&nbsp;
<b class="nc">&nbsp;        String bayType = &quot;none&quot;;</b>
&nbsp;
&nbsp;        Vector&lt;Bay&gt; potential;
<b class="nc">&nbsp;        potential = new Vector&lt;Bay&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                Bay nextBay = (Bay) next;</b>
<b class="nc">&nbsp;                if (nextBay.getCurrentDoors() &gt; 0) {</b>
<b class="nc">&nbsp;                    potential.add(nextBay);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (potential.size() &gt; 0) {</b>
<b class="nc">&nbsp;            Bay chosenBay = potential.elementAt(Compute.randomInt(potential</b>
<b class="nc">&nbsp;                                                                          .size()));</b>
<b class="nc">&nbsp;            chosenBay.destroyDoor();</b>
<b class="nc">&nbsp;            chosenBay.resetDoors();</b>
<b class="nc">&nbsp;            bayType = chosenBay.getType();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return bayType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * damage the door of the first bay that can load this unit
&nbsp;     */
&nbsp;    public void damageDoorRecovery(Entity en) {
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if ((next instanceof ASFBay) &amp;&amp; next.canLoad(en)) {</b>
<b class="nc">&nbsp;                ((ASFBay) next).destroyDoor();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((next instanceof SmallCraftBay) &amp;&amp; next.canLoad(en)) {</b>
<b class="nc">&nbsp;                ((SmallCraftBay) next).destroyDoor();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Damages a randomly determined docking collar on the entity, if one exists
&nbsp;     */
&nbsp;    public boolean damageDockCollar() {
&nbsp;
<b class="nc">&nbsp;        boolean result = false;</b>
&nbsp;
&nbsp;        Vector&lt;DockingCollar&gt; potential;
<b class="nc">&nbsp;        potential = new Vector&lt;DockingCollar&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if (next instanceof DockingCollar) {</b>
<b class="nc">&nbsp;                DockingCollar nextDC = (DockingCollar) next;</b>
<b class="nc">&nbsp;                if (!nextDC.isDamaged()) {</b>
<b class="nc">&nbsp;                    potential.add(nextDC);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (potential.size() &gt; 0) {</b>
<b class="nc">&nbsp;            DockingCollar chosenDC = potential.elementAt(Compute</b>
<b class="nc">&nbsp;                                                                 .randomInt(potential.size()));</b>
<b class="nc">&nbsp;            chosenDC.setDamaged(true);</b>
<b class="nc">&nbsp;            result = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void pickUp(MechWarrior mw) {
<b class="nc">&nbsp;        pickedUpMechWarriors.addElement(mw.getId());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get a &lt;code&gt;List&lt;/code&gt; of the units currently loaded into this payload.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;List&lt;/code&gt; of loaded &lt;code&gt;Entity&lt;/code&gt; units. This
&nbsp;     * list will never be &lt;code&gt;null&lt;/code&gt;, but it may be empty. The
&nbsp;     * returned &lt;code&gt;List&lt;/code&gt; is independent from the under- lying
&nbsp;     * data structure; modifying one does not affect the other.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public List&lt;Entity&gt; getLoadedUnits() {
<b class="nc">&nbsp;        List&lt;Entity&gt; result = new ArrayList&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
&nbsp;            //Don&#39;t look at trailer hitches here, that&#39;s separate
<b class="nc">&nbsp;            if (next instanceof TankTrailerHitch) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                if(e != null) {</b>
<b class="nc">&nbsp;                    result.add(e);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the number of docking collars
&nbsp;     */
&nbsp;    public int getDocks() {
<b class="nc">&nbsp;        return getDocks(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param forCost Whether this value is being used for cost calculations, in which case
&nbsp;     *                dropshuttle bays count as two collars.
&nbsp;     * @return The number of docking collars
&nbsp;     */
&nbsp;    public int getDocks(boolean forCost) {
<b class="nc">&nbsp;        int n = 0;</b>
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof DockingCollar)</b>
&nbsp;                    || (forCost &amp;&amp; (next instanceof DropshuttleBay))) {
<b class="nc">&nbsp;                n += next.hardpointCost();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * only entities in Bays (for cargo damage to Aero units
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getBayLoadedUnits() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Generate a list of the Ids of entities stored in bays. 
&nbsp;     * Used by MHQ in cases where we can&#39;t get the entities via Game
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public List&lt;Integer&gt; getBayLoadedUnitIds() {
<b class="nc">&nbsp;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                result.addAll(((Bay) next).getLoadedUnitIds());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return the bay that the given entity is loaded into
&nbsp;     *
&nbsp;     * @param loaded
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Bay getBay(Entity loaded) {
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    if (loaded.getId() == e.getId()) {</b>
<b class="nc">&nbsp;                        return (Bay) next;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Bay getBayById(int bayNumber) {
&nbsp;        //TODO: Change transports to a map or other indexed data structure to avoid
&nbsp;        // linear-time algorithm.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                if (((Bay) next).getBayNumber() == bayNumber) {</b>
<b class="nc">&nbsp;                    return (Bay) next;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Nullable
&nbsp;    public DockingCollar getCollarById(int collarNumber) {
&nbsp;        //TODO: Change transports to a map or other indexed data structure to avoid
&nbsp;        // linear-time algorithm.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof DockingCollar) {</b>
<b class="nc">&nbsp;                if (((DockingCollar) next).getCollarNumber() == collarNumber) {</b>
<b class="nc">&nbsp;                    return (DockingCollar) next;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return only entities in ASF Bays
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getLoadedFighters() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
&nbsp;
&nbsp;        // I should only add entities in bays that are functional
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof ASFBay) &amp;&amp; (((ASFBay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return only entities in ASF Bays that can be launched (i.e. not in
&nbsp;     * recovery)
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getLaunchableFighters() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
&nbsp;
&nbsp;        // I should only add entities in bays that are functional
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof ASFBay) &amp;&amp; (((ASFBay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                Bay nextbay = (Bay) next;</b>
<b class="nc">&nbsp;                for (Entity e : nextbay.getLaunchableUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return only entities in that can be combat dropped
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getDroppableUnits() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
&nbsp;
&nbsp;        // I should only add entities in bays that are functional
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof Bay) &amp;&amp; (((Bay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                Bay nextbay = (Bay) next;</b>
<b class="nc">&nbsp;                for (Entity e : nextbay.getDroppableUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return only entities in that can be unloaded on ground
&nbsp;     */
&nbsp;    public Vector&lt;Entity&gt; getUnitsUnloadableFromBays() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
&nbsp;
&nbsp;        // I should only add entities in bays that are functional
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof Bay) &amp;&amp; (((Bay) next).canUnloadUnits())) {</b>
<b class="nc">&nbsp;                Bay nextbay = (Bay) next;</b>
<b class="nc">&nbsp;                for (Entity e : nextbay.getUnloadableUnits()) {</b>
<b class="nc">&nbsp;                    if (!e.wasLoadedThisTurn()) {</b>
<b class="nc">&nbsp;                        result.addElement(e);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Bay getLoadedBay(int bayID) {
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Bay&gt; bays = getFighterBays();</b>
<b class="nc">&nbsp;        for (int nbay = 0; nbay &lt; bays.size(); nbay++) {</b>
<b class="nc">&nbsp;            Bay currentBay = bays.elementAt(nbay);</b>
<b class="nc">&nbsp;            Vector&lt;Entity&gt; currentFighters = currentBay.getLoadedUnits();</b>
<b class="nc">&nbsp;            for (int nfighter = 0; nfighter &lt; currentFighters.size(); nfighter++) {</b>
<b class="nc">&nbsp;                Entity fighter = currentFighters.elementAt(nfighter);</b>
<b class="nc">&nbsp;                if (fighter.getId() == bayID) {</b>
&nbsp;                    // then we are in the right bay
<b class="nc">&nbsp;                    return currentBay;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return get the bays separately
&nbsp;     */
&nbsp;    public Vector&lt;Bay&gt; getFighterBays() {
<b class="nc">&nbsp;        Vector&lt;Bay&gt; result = new Vector&lt;Bay&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (((next instanceof ASFBay) || (next instanceof SmallCraftBay))</b>
<b class="nc">&nbsp;                &amp;&amp; (((Bay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                result.addElement((Bay) next);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return get the bays separately
&nbsp;     */
&nbsp;    public Vector&lt;DockingCollar&gt; getDockingCollars() {
<b class="nc">&nbsp;        Vector&lt;DockingCollar&gt; result = new Vector&lt;DockingCollar&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof DockingCollar) {</b>
<b class="nc">&nbsp;                result.addElement((DockingCollar) next);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns vector of Transports for everything a unit transports
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Vector&lt;Transporter&gt; getTransports() {
<b class="fc">&nbsp;        return transports;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isPodMountedTransport(Transporter t) {
<b class="nc">&nbsp;    	return omniPodTransports.contains(t);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Bay&gt; getTransportBays() {
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Bay&gt; result = new Vector&lt;Bay&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                result.addElement((Bay) next);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * do any damage to bay doors
&nbsp;     */
&nbsp;    public void resetBayDoors() {
&nbsp;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                ((Bay) next).resetDoors();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void resetBays() {
<b class="fc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof Bay) {</b>
<b class="nc">&nbsp;                ((Bay) next).resetCounts();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return the launch rate for fighters
&nbsp;     */
&nbsp;    public int getFighterLaunchRate() {
<b class="nc">&nbsp;        int result = 0;</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof ASFBay) {</b>
<b class="nc">&nbsp;                result += 2 * ((ASFBay) next).getCurrentDoors();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Return the number.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Entity&gt; getLoadedSmallCraft() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof SmallCraftBay)</b>
<b class="nc">&nbsp;                &amp;&amp; (((SmallCraftBay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Entity&gt; getLaunchableSmallCraft() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof SmallCraftBay)</b>
<b class="nc">&nbsp;                &amp;&amp; (((SmallCraftBay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                Bay nextbay = (Bay) next;</b>
<b class="nc">&nbsp;                for (Entity e : nextbay.getLaunchableUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Entity&gt; getLoadedDropships() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof DockingCollar) {</b>
<b class="nc">&nbsp;                for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Entity&gt; getLaunchableDropships() {
<b class="nc">&nbsp;        Vector&lt;Entity&gt; result = new Vector&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their lists to ours.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof DockingCollar) {</b>
<b class="nc">&nbsp;                DockingCollar collar = (DockingCollar) next;</b>
<b class="nc">&nbsp;                for (Entity e : collar.getLaunchableUnits()) {</b>
<b class="nc">&nbsp;                    result.addElement(e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the bays separately
&nbsp;     */
&nbsp;    public Vector&lt;SmallCraftBay&gt; getSmallCraftBays() {
<b class="nc">&nbsp;        Vector&lt;SmallCraftBay&gt; result = new Vector&lt;SmallCraftBay&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof SmallCraftBay)</b>
<b class="nc">&nbsp;                &amp;&amp; (((SmallCraftBay) next).getCurrentDoors() &gt; 0)) {</b>
<b class="nc">&nbsp;                result.addElement((SmallCraftBay) next);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return launch rate for Small Craft
&nbsp;     */
&nbsp;    public int getSmallCraftLaunchRate() {
<b class="nc">&nbsp;        int result = 0;</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof SmallCraftBay) {</b>
<b class="nc">&nbsp;                result += 2 * ((SmallCraftBay) next).getCurrentDoors();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Return the number.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Unload the given unit.
&nbsp;     *
&nbsp;     * @param unit - the &lt;code&gt;Entity&lt;/code&gt; to be unloaded.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit was contained in this space,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean unload(Entity unit) {
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // try to remove the unit from each in turn.
&nbsp;        // Stop after the first match.
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if (next.unload(unit)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If we got here, none of our transports currently carry the unit.
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetTransporter() {
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // and resets them
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            next.resetTransporter();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Return a string that identifies the unused capacity of this transporter.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;String&lt;/code&gt; meant for a human.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getUnusedString() {
<b class="nc">&nbsp;        return getUnusedString(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public double getUnused() {
<b class="nc">&nbsp;        double capacity = 0;</b>
<b class="nc">&nbsp;        for (Transporter transport : transports) {</b>
<b class="nc">&nbsp;            capacity += transport.getUnused();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return capacity;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current amount of cargo space for an entity of the given
&nbsp;     * type.
&nbsp;     *
&nbsp;     * @param e An entity that defines the unit class
&nbsp;     * @return The number of units of the given type that can be loaded in this
&nbsp;     * Entity
&nbsp;     */
&nbsp;    public double getUnused(Entity e) {
<b class="nc">&nbsp;        double capacity = 0;</b>
<b class="nc">&nbsp;        for (Transporter transport : transports) {</b>
<b class="nc">&nbsp;            if (transport.canLoad(e)) {</b>
<b class="nc">&nbsp;                capacity += transport.getUnused();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return capacity;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a string that identifies the unused capacity of this transporter.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;String&lt;/code&gt; meant for a human.
&nbsp;     */
&nbsp;    public String getUnusedString(boolean ishtml) {
<b class="nc">&nbsp;        StringBuffer result = new StringBuffer();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add all of their string to ours.
<b class="nc">&nbsp;        Enumeration&lt;Transporter&gt; iter = transports.elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Transporter next = iter.nextElement();</b>
<b class="nc">&nbsp;            if ((next instanceof Bay) &amp;&amp; ((Bay)next).isQuarters()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((next instanceof DockingCollar) &amp;&amp; ((DockingCollar)next).isDamaged()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ishtml &amp;&amp; (next instanceof Bay) &amp;&amp; (((Bay) next).getBayDamage() &gt; 0)) {</b>
<b class="nc">&nbsp;                result.append(&quot;&lt;font color=&#39;red&#39;&gt;&quot;)</b>
<b class="nc">&nbsp;                    .append(next.getUnusedString())</b>
<b class="nc">&nbsp;                    .append(&quot;&lt;/font&gt;&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                result.append(next.getUnusedString());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (isOmni() &amp;&amp; ((next instanceof TroopSpace)</b>
&nbsp;                    || (next instanceof Bay))) {
<b class="nc">&nbsp;            	if (omniPodTransports.contains(next)) {</b>
<b class="nc">&nbsp;            		result.append(&quot; (Pod)&quot;);</b>
&nbsp;            	} else {
<b class="nc">&nbsp;            		result.append(&quot; (Fixed)&quot;);</b>
&nbsp;            	}
&nbsp;            }
&nbsp;            // Add a newline character between strings.
<b class="nc">&nbsp;            if (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;                if (ishtml) {</b>
<b class="nc">&nbsp;                    result.append(&quot;&lt;br&gt;&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    result.append(&quot;\n&quot;);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the String.
<b class="nc">&nbsp;        return result.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if transported units prevent a weapon in the given location
&nbsp;     * from firing.
&nbsp;     *
&nbsp;     * @param loc    - the &lt;code&gt;int&lt;/code&gt; location attempting to fire.
&nbsp;     * @param isRear - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
&nbsp;     *               is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
&nbsp;     *               facing.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if a transported unit is in the way,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if the weapon can fire.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isWeaponBlockedAt(int loc, boolean isRear) {
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // check each for blockage in turn.
&nbsp;        // Stop after the first match.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next.isWeaponBlockedAt(loc, isRear)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If we got here, none of our transports
&nbsp;        // carry a blocking unit at that location.
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If a unit is being transported on the outside of the transporter, it can
&nbsp;     * suffer damage when the transporter is hit by an attack. Currently, no
&nbsp;     * more than one unit can be at any single location; that same unit can be
&nbsp;     * &quot;spread&quot; over multiple locations.
&nbsp;     *
&nbsp;     * @param loc    - the &lt;code&gt;int&lt;/code&gt; location hit by attack.
&nbsp;     * @param isRear - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
&nbsp;     *               is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
&nbsp;     *               facing.
&nbsp;     * @return The &lt;code&gt;Entity&lt;/code&gt; being transported on the outside at that
&nbsp;     * location. This value will be &lt;code&gt;null&lt;/code&gt; if no unit is
&nbsp;     * transported on the outside at that location.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Entity getExteriorUnitAt(int loc, boolean isRear) {
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // check each for an exterior unit in turn.
&nbsp;        // Stop after the first match.
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            Entity exterior = next.getExteriorUnitAt(loc, isRear);</b>
<b class="nc">&nbsp;            if (null != exterior) {</b>
<b class="nc">&nbsp;                return exterior;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If we got here, none of our transports
&nbsp;        // carry an exterior unit at that location.
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ArrayList&lt;Entity&gt; getExternalUnits() {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; rv = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        for (Transporter t : transports) {</b>
<b class="nc">&nbsp;            rv.addAll(t.getExternalUnits());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return rv;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getCargoMpReduction(Entity carrier) {
<b class="fc">&nbsp;        int rv = 0;</b>
<b class="fc">&nbsp;        for (Transporter t : transports) {</b>
<b class="nc">&nbsp;            rv += t.getCargoMpReduction(carrier);</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        return rv;</b>
&nbsp;    }
&nbsp;
&nbsp;    public HitData getTrooperAtLocation(HitData hit, Entity transport) {
<b class="nc">&nbsp;        return rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Record the ID of the &lt;code&gt;Entity&lt;/code&gt; that has loaded this unit. A
&nbsp;     * unit that is unloaded can neither move nor attack for the rest of the
&nbsp;     * turn.
&nbsp;     *
&nbsp;     * @param transportId - the &lt;code&gt;int&lt;/code&gt; ID of our transport. The ID is
&nbsp;     *                    &lt;b&gt;not&lt;/b&gt; validated. This value should be
&nbsp;     *                    &lt;code&gt;Entity.NONE&lt;/code&gt; if this unit has been unloaded.
&nbsp;     */
&nbsp;    public void setTransportId(int transportId) {
<b class="nc">&nbsp;        conveyance = transportId;</b>
&nbsp;        // If we were unloaded, set the appropriate flags.
<b class="nc">&nbsp;        if (transportId == Entity.NONE) {</b>
<b class="nc">&nbsp;            unloadedThisTurn = true;</b>
<b class="nc">&nbsp;            done = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            loadedThisTurn = true;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return The number of additional crew capacity provided by quarters in transport bays.
&nbsp;     */
&nbsp;    public int getBayPersonnel() {
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (Bay bay : this.getTransportBays()) {</b>
<b class="nc">&nbsp;            count += bay.getPersonnel(isClan());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the ID &lt;code&gt;Entity&lt;/code&gt; that has loaded this one.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of our transport. The ID may be invalid.
&nbsp;     * This value should be &lt;code&gt;Entity.NONE&lt;/code&gt; if this unit has
&nbsp;     * not been loaded.
&nbsp;     */
&nbsp;    public int getTransportId() {
<b class="fc">&nbsp;        return conveyance;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hardpointCost() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active and working stealth system.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a stealth system that is
&nbsp;     * currently active and it&#39;s actually working, &lt;code&gt;false&lt;/code&gt; if
&nbsp;     * there is no stealth system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isStealthActive() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active and working stealth system.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a stealth system that is
&nbsp;     * currently active and it&#39;s actually working, &lt;code&gt;false&lt;/code&gt; if
&nbsp;     * there is no stealth system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isStealthOn() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active null-signature system.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a null signature system that
&nbsp;     * is currently active, &lt;code&gt;false&lt;/code&gt; if there is no stealth
&nbsp;     * system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isNullSigActive() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active null-signature system.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a null signature system that
&nbsp;     * is currently active, &lt;code&gt;false&lt;/code&gt; if there is no stealth
&nbsp;     * system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isNullSigOn() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active void signature system that is
&nbsp;     * providing its benefits.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a void signature system that
&nbsp;     * is currently active, &lt;code&gt;false&lt;/code&gt; if there is no stealth
&nbsp;     * system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isVoidSigActive() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active void signature system.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a void signature system that
&nbsp;     * is currently active, &lt;code&gt;false&lt;/code&gt; if there is no stealth
&nbsp;     * system or if it is turned off.
&nbsp;     */
&nbsp;    public boolean isVoidSigOn() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active chameleon light polarization field.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a void signature system that
&nbsp;     * is currently active, &lt;code&gt;false&lt;/code&gt; if there is no stealth
&nbsp;     * system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isChameleonShieldActive() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if this unit has an active chameleon light polarization field.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this unit has a void signature system that
&nbsp;     * is currently active, &lt;code&gt;false&lt;/code&gt; if there is no stealth
&nbsp;     * system or if it is inactive.
&nbsp;     */
&nbsp;    public boolean isChameleonShieldOn() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the stealth modifier for firing at this unit from the given
&nbsp;     * range. If the value supplied for &lt;code&gt;range&lt;/code&gt; is not one of the
&nbsp;     * &lt;code&gt;Entity&lt;/code&gt; class range constants, an
&nbsp;     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
&nbsp;     * &lt;p/&gt;
&nbsp;     * Sub-classes are encouraged to override this method.
&nbsp;     *
&nbsp;     * @param range - an &lt;code&gt;int&lt;/code&gt; value that must match one of the
&nbsp;     *              &lt;code&gt;Compute&lt;/code&gt; class range constants.
&nbsp;     * @param ae    - the entity making the attack, who maybe immune to certain
&nbsp;     *              kinds of stealth
&nbsp;     * @return a &lt;code&gt;TargetRoll&lt;/code&gt; value that contains the stealth
&nbsp;     * modifier for the given range.
&nbsp;     */
&nbsp;    public TargetRoll getStealthModifier(int range, Entity ae) {
<b class="nc">&nbsp;        TargetRoll result = null;</b>
&nbsp;
&nbsp;        // Stealth must be active.
<b class="nc">&nbsp;        if (!isStealthActive()) {</b>
<b class="nc">&nbsp;            result = new TargetRoll(0, &quot;stealth not active&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Get the range modifier.
<b class="nc">&nbsp;        switch (range) {</b>
&nbsp;            case RangeType.RANGE_MINIMUM:
&nbsp;            case RangeType.RANGE_SHORT:
&nbsp;            case RangeType.RANGE_MEDIUM:
&nbsp;            case RangeType.RANGE_LONG:
&nbsp;            case RangeType.RANGE_EXTREME:
&nbsp;            case RangeType.RANGE_LOS:
&nbsp;            case RangeType.RANGE_OUT:
<b class="nc">&nbsp;                result = new TargetRoll(0, &quot;stealth not installed&quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Unknown range constant: &quot;</b>
&nbsp;                                                   + range);
&nbsp;        }
&nbsp;
&nbsp;        // Return the result.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Record the ID of the &lt;code&gt;Entity&lt;/code&gt; that is the current target of a
&nbsp;     * swarm attack by this unit. A unit that stops swarming can neither move
&nbsp;     * nor attack for the rest of the turn.
&nbsp;     *
&nbsp;     * @param id - the &lt;code&gt;int&lt;/code&gt; ID of the swarm attack&#39;s target. The ID
&nbsp;     *           is &lt;b&gt;not&lt;/b&gt; validated. This value should be
&nbsp;     *           &lt;code&gt;Entity.NONE&lt;/code&gt; if this unit has stopped swarming.
&nbsp;     */
&nbsp;    public void setSwarmTargetId(int id) {
<b class="nc">&nbsp;        swarmTargetId = id;</b>
&nbsp;        // This entity can neither move nor attack for the rest of this turn.
<b class="nc">&nbsp;        if (id == Entity.NONE) {</b>
<b class="nc">&nbsp;            unloadedThisTurn = true;</b>
<b class="nc">&nbsp;            done = true;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the ID of the &lt;code&gt;Entity&lt;/code&gt; that is the current target of a
&nbsp;     * swarm attack by this unit.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of the swarm attack&#39;s target The ID may
&nbsp;     * be invalid. This value should be &lt;code&gt;Entity.NONE&lt;/code&gt; if this
&nbsp;     * unit is not swarming.
&nbsp;     */
&nbsp;    public int getSwarmTargetId() {
<b class="nc">&nbsp;        return swarmTargetId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Record the ID of the &lt;code&gt;Entity&lt;/code&gt; that is attacking this unit with
&nbsp;     * a swarm attack.
&nbsp;     *
&nbsp;     * @param id - the &lt;code&gt;int&lt;/code&gt; ID of the swarm attack&#39;s attacker. The
&nbsp;     *           ID is &lt;b&gt;not&lt;/b&gt; validated. This value should be
&nbsp;     *           &lt;code&gt;Entity.NONE&lt;/code&gt; if the swarm attack has ended.
&nbsp;     */
&nbsp;    public void setSwarmAttackerId(int id) {
<b class="nc">&nbsp;        swarmAttackerId = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the ID of the &lt;code&gt;Entity&lt;/code&gt; that is attacking this unit with a
&nbsp;     * swarm attack.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; ID of the swarm attack&#39;s attacker The ID may
&nbsp;     * be invalid. This value should be &lt;code&gt;Entity.NONE&lt;/code&gt; if this
&nbsp;     * unit is not being swarmed.
&nbsp;     */
&nbsp;    public int getSwarmAttackerId() {
<b class="nc">&nbsp;        return swarmAttackerId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Scans through the ammo on the unit for any inferno rounds.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the unit is still loaded with Inferno
&nbsp;     * rounds. &lt;code&gt;false&lt;/code&gt; if no rounds were ever loaded or if
&nbsp;     * they have all been fired.
&nbsp;     */
&nbsp;    public boolean hasInfernoAmmo() {
<b class="nc">&nbsp;        boolean found = false;</b>
&nbsp;
&nbsp;        // Walk through the unit&#39;s ammo, stop when we find a match.
<b class="nc">&nbsp;        for (Mounted amounted : getAmmo()) {</b>
<b class="nc">&nbsp;            AmmoType atype = (AmmoType) amounted.getType();</b>
<b class="nc">&nbsp;            if (((atype.getAmmoType() == AmmoType.T_SRM) || (atype.getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MML)) &amp;&amp; (atype.getMunitionType() == AmmoType.M_INFERNO)</b>
<b class="nc">&nbsp;                    &amp;&amp; (amounted.getHittableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;                found = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((atype.getAmmoType() == AmmoType.T_IATM) &amp;&amp; (atype.getMunitionType() == AmmoType.M_IATM_IIW)</b>
<b class="nc">&nbsp;                    &amp;&amp; (amounted.getHittableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;                found = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return found;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Record if the unit is just combat-lossed or if it has been utterly
&nbsp;     * destroyed.
&nbsp;     *
&nbsp;     * @param canSalvage - a &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if the unit
&nbsp;     *                   can be repaired (given time and parts); if this value is
&nbsp;     *                   &lt;code&gt;false&lt;/code&gt;, the unit is utterly destroyed.
&nbsp;     */
&nbsp;    public void setSalvage(boolean canSalvage) {
&nbsp;        // Unsalvageable entities aren&#39;t in retreat or salvageable.
<b class="nc">&nbsp;        if (!canSalvage) {</b>
<b class="nc">&nbsp;            setRemovalCondition(IEntityRemovalConditions.REMOVE_DEVASTATED);</b>
&nbsp;        }
<b class="nc">&nbsp;        salvageable = canSalvage;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the unit is just combat-lossed or if it has been utterly
&nbsp;     * destroyed.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if the unit has
&nbsp;     * salvageable components; if this value is &lt;code&gt;false&lt;/code&gt; the
&nbsp;     * unit is utterly destroyed.
&nbsp;     * @see #isRepairable()
&nbsp;     */
&nbsp;    public boolean isSalvage() {
<b class="nc">&nbsp;        return salvageable;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if the unit can be repaired, or only harvested for spares.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if the unit can
&nbsp;     * be repaired (given enough time and parts); if this value is
&nbsp;     * &lt;code&gt;false&lt;/code&gt;, the unit is only a source of spares.
&nbsp;     * @see #isSalvage()
&nbsp;     */
&nbsp;    public boolean isRepairable() {
<b class="nc">&nbsp;        return isSalvage();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for property removalCondition.
&nbsp;     *
&nbsp;     * @return Value of property removalCondition.
&nbsp;     */
&nbsp;    public int getRemovalCondition() {
<b class="nc">&nbsp;        return removalCondition;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for property removalCondition.
&nbsp;     *
&nbsp;     * @param removalCondition New value of property removalCondition.
&nbsp;     */
&nbsp;    public void setRemovalCondition(int removalCondition) {
&nbsp;        // Don&#39;t replace a removal condition with a lesser condition.
<b class="nc">&nbsp;        if (this.removalCondition &lt; removalCondition) {</b>
<b class="nc">&nbsp;            this.removalCondition = removalCondition;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return whether this entity is clearing a minefield.
&nbsp;     */
&nbsp;    public boolean isClearingMinefield() {
<b class="nc">&nbsp;        return clearingMinefield;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param clearingMinefield
&nbsp;     */
&nbsp;    public void setClearingMinefield(boolean clearingMinefield) {
<b class="fc">&nbsp;        this.clearingMinefield = clearingMinefield;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return whether this entity is spotting this round.
&nbsp;     */
&nbsp;    public boolean isSpotting() {
<b class="nc">&nbsp;        return spotting;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param spotting
&nbsp;     */
&nbsp;    public void setSpotting(boolean spotting) {
<b class="fc">&nbsp;        this.spotting = spotting;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Um, basically everything can spot for LRM indirect fire.
&nbsp;     * Except for off-board units and units that sprinted.
&nbsp;     *
&nbsp;     * @return true, if the entity is eligible to spot
&nbsp;     */
&nbsp;    public boolean canSpot() {
<b class="nc">&nbsp;        return isActive() &amp;&amp; !isOffBoard() &amp;&amp; </b>
&nbsp;        		(moved != EntityMovementType.MOVE_SPRINT) &amp;&amp; 
&nbsp;        		(moved != EntityMovementType.MOVE_VTOL_SPRINT);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        return &quot;Entity [&quot; + getDisplayName() + &quot;, &quot; + getId() + &quot;]&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This returns a textual description of the entity for visualy impaired
&nbsp;     * users.
&nbsp;     */
&nbsp;    public String statusToString() {
&nbsp;        // should include additional information like imobile.
<b class="nc">&nbsp;        String str = &quot;Entity [&quot; + getDisplayName() + &quot;, &quot; + getId() + &quot;]: &quot;;</b>
<b class="nc">&nbsp;        if (getPosition() != null) {</b>
<b class="nc">&nbsp;            str = str + &quot;Location: (&quot; + (getPosition().getX() + 1) + &quot;, &quot;</b>
<b class="nc">&nbsp;                  + (getPosition().getY() + 1) + &quot;) &quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        str = str + &quot;Owner: &quot; + owner.getName() + &quot; Armor: &quot; + getTotalArmor()</b>
<b class="nc">&nbsp;              + &quot;/&quot; + getTotalOArmor() + &quot; Internal Structure: &quot;</b>
<b class="nc">&nbsp;              + getTotalInternal() + &quot;/&quot; + getTotalOInternal();</b>
&nbsp;
<b class="nc">&nbsp;        if (!isActive()) {</b>
<b class="nc">&nbsp;            str += &quot; Inactive&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isImmobile()) {</b>
<b class="nc">&nbsp;            str += &quot; Immobile&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isProne()) {</b>
<b class="nc">&nbsp;            str += &quot; Prone&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isDone()) {</b>
<b class="nc">&nbsp;            str += &quot; Done&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This returns a textual description of a specific location of the entity
&nbsp;     * for visualy impaired users.
&nbsp;     *
&nbsp;     * @param loc the location
&nbsp;     * @return a string descibing the status of the location.
&nbsp;     */
&nbsp;    public String statusToString(int loc) {
<b class="nc">&nbsp;        if (loc == LOC_NONE) {</b>
<b class="nc">&nbsp;            return &quot;No location given.&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return getLocationName(loc) + &quot; (&quot; + getLocationAbbr(loc)</b>
<b class="nc">&nbsp;               + &quot;): Armor: &quot; + getArmorString(loc) + &quot;/&quot; + getOArmor(loc)</b>
<b class="nc">&nbsp;               + &quot; Structure: &quot; + getInternalString(loc) + &quot;/&quot;</b>
<b class="nc">&nbsp;               + getOInternal(loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param str a string defining the location
&nbsp;     * @return the status of the given location.
&nbsp;     */
&nbsp;    public String statusToString(String str) {
<b class="nc">&nbsp;        int loc = LOC_NONE;</b>
<b class="nc">&nbsp;        loc = getLocationFromAbbr(str);</b>
&nbsp;
<b class="nc">&nbsp;        if (loc == LOC_NONE) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                loc = Integer.parseInt(str);</b>
<b class="nc">&nbsp;            } catch (NumberFormatException nfe) {</b>
<b class="nc">&nbsp;                loc = LOC_NONE;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return statusToString(loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The round the unit will be deployed. We will deploy at the end of a
&nbsp;     * round. So if depoyRound is set to 5, we will deploy when round 5 is over.
&nbsp;     * Any value of zero or less is automatically set to 1
&nbsp;     *
&nbsp;     * @param deployRound an int
&nbsp;     */
&nbsp;    public void setDeployRound(int deployRound) {
<b class="nc">&nbsp;        this.deployRound = deployRound;</b>
&nbsp;
&nbsp;        // Entity&#39;s that deploy after the start can set their own deploy zone
&nbsp;        // If the deployRound is being set back to 0, make sure we reset the
&nbsp;        // starting position (START_NONE implies inheritance from owning player)
<b class="nc">&nbsp;        if (deployRound == 0) {</b>
<b class="nc">&nbsp;            setStartingPos(Board.START_NONE);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The round the unit will be deployed
&nbsp;     *
&nbsp;     * @return an int
&nbsp;     */
&nbsp;    public int getDeployRound() {
<b class="nc">&nbsp;        return deployRound;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Toggles if an entity has been deployed
&nbsp;     */
&nbsp;    public void setDeployed(boolean deployed) {
<b class="nc">&nbsp;        this.deployed = deployed;</b>
<b class="nc">&nbsp;        if (deployed) {</b>
<b class="nc">&nbsp;            neverDeployed = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if an entity has been deployed
&nbsp;     */
&nbsp;    public boolean isDeployed() {
<b class="fc">&nbsp;        return deployed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if entity was never deployed
&nbsp;     */
&nbsp;    public boolean wasNeverDeployed() {
<b class="nc">&nbsp;        return neverDeployed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Toggles if an entity has been deployed
&nbsp;     */
&nbsp;    public void setNeverDeployed(boolean neverDeployed) {
<b class="nc">&nbsp;        this.neverDeployed = neverDeployed;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the entity should be deployed
&nbsp;     */
&nbsp;    public boolean shouldDeploy(int round) {
<b class="nc">&nbsp;        return !isDeployed() </b>
<b class="nc">&nbsp;            &amp;&amp; (getDeployRound() &lt;= round)</b>
<b class="nc">&nbsp;            &amp;&amp; !isOffBoard();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the offboard entity should be deployed this round.
&nbsp;     * @param round The current round number.
&nbsp;     * @return True if and only if the offboard entity should deploy this
&nbsp;     *         round, otherwise false.
&nbsp;     */
&nbsp;    public boolean shouldOffBoardDeploy(int round) {
<b class="nc">&nbsp;        return isOffBoard() </b>
<b class="nc">&nbsp;            &amp;&amp; !isDeployed() </b>
<b class="nc">&nbsp;            &amp;&amp; (getDeployRound() &lt;= round);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the unit number for this entity.
&nbsp;     *
&nbsp;     * @param unit the number for the low-level unit that this
&nbsp;     *             entity belongs to. This entity can be removed from its unit by
&nbsp;     *             passing the value, &lt;code&gt;{@link Entity#NONE}&lt;/code&gt;.
&nbsp;     */
&nbsp;    public void setUnitNumber(final short unit) {
<b class="nc">&nbsp;        unitNumber = unit;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the unit number of this entity.
&nbsp;     *
&nbsp;     * @return The unit number. If the entity does not belong
&nbsp;     * to a unit, &lt;code&gt;{@link Entity#NONE}&lt;/code&gt; will be returned.
&nbsp;     */
&nbsp;    public short getUnitNumber() {
<b class="nc">&nbsp;        return unitNumber;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether an entity can flee from its current position. Currently
&nbsp;     * returns true if the entity is on the edge of the board.
&nbsp;     */
&nbsp;    public boolean canFlee() {
<b class="nc">&nbsp;        Coords pos = getPosition();</b>
<b class="nc">&nbsp;        return (pos != null)</b>
<b class="nc">&nbsp;               &amp;&amp; ((getWalkMP() &gt; 0) || (this instanceof Infantry))</b>
<b class="nc">&nbsp;               &amp;&amp; !isProne()</b>
<b class="nc">&nbsp;               &amp;&amp; !isStuck()</b>
<b class="nc">&nbsp;               &amp;&amp; !isShutDown()</b>
<b class="nc">&nbsp;               &amp;&amp; !getCrew().isUnconscious()</b>
<b class="nc">&nbsp;               &amp;&amp; ((pos.getX() == 0) || (pos.getX() == (game.getBoard().getWidth() - 1))</b>
<b class="nc">&nbsp;                   || (pos.getY() == 0) || (pos.getY() == (game.getBoard()</b>
<b class="nc">&nbsp;                                                               .getHeight() - 1)));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setEverSeenByEnemy(boolean b) {
<b class="nc">&nbsp;        everSeenByEnemy = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isEverSeenByEnemy() {
<b class="nc">&nbsp;        return everSeenByEnemy;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setVisibleToEnemy(boolean b) {
<b class="nc">&nbsp;        visibleToEnemy = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isVisibleToEnemy() {
&nbsp;        // If double blind isn&#39;t on, the unit is always visible
<b class="nc">&nbsp;        if ((game != null) &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return visibleToEnemy;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDetectedByEnemy(boolean b) {
<b class="nc">&nbsp;        detectedByEnemy = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isDetectedByEnemy() {
&nbsp;        // If double blind isn&#39;t on, the unit is always detected
<b class="nc">&nbsp;        if ((game != null) &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return detectedByEnemy;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addBeenSeenBy(IPlayer p) {
<b class="nc">&nbsp;        if ((p != null) &amp;&amp; !entitySeenBy.contains(p)) {</b>
<b class="nc">&nbsp;            entitySeenBy.add(p);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Vector&lt;IPlayer&gt; getWhoCanSee() {
<b class="nc">&nbsp;        return entitySeenBy;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWhoCanSee(Vector&lt;IPlayer&gt; entitySeenBy) {
<b class="nc">&nbsp;        this.entitySeenBy = entitySeenBy;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearSeenBy() {
<b class="nc">&nbsp;        entitySeenBy.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the the given player can see this Entity, including
&nbsp;     * teammates if team_vision is on.
&nbsp;     *
&nbsp;     */
&nbsp;    public boolean hasSeenEntity(IPlayer p) {
&nbsp;        // No double blind - everyone sees everything
<b class="nc">&nbsp;        if ((game == null) || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        // Null players see nothing
<b class="nc">&nbsp;        if (p == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // A Player can always see their own &#39;mechs
<b class="nc">&nbsp;        if (getOwner().equals(p)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If a player can see all, it sees this
<b class="nc">&nbsp;        if (p.canSeeAll()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Observers can see units spotted by an enemy
<b class="nc">&nbsp;        if (p.isObserver()) {</b>
<b class="nc">&nbsp;            for (IPlayer other : entitySeenBy) {</b>
<b class="nc">&nbsp;                if (other.isEnemyOf(getOwner())) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entitySeenBy.contains(p)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        // If team vision, see if any players on team can see
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION)) {</b>
<b class="nc">&nbsp;            for (IPlayer teammate : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;                if ((teammate.getTeam() == p.getTeam())</b>
<b class="nc">&nbsp;                        &amp;&amp; entitySeenBy.contains(teammate)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // Can&#39;t see
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addBeenDetectedBy(IPlayer p) {
&nbsp;        // This is for saved-game backwards compatibility
<b class="nc">&nbsp;        if (entityDetectedBy == null) {</b>
<b class="nc">&nbsp;            entityDetectedBy = new Vector&lt;IPlayer&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((p != null) &amp;&amp; !entityDetectedBy.contains(p)) {</b>
<b class="nc">&nbsp;            entityDetectedBy.add(p);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Vector&lt;IPlayer&gt; getWhoCanDetect() {
<b class="nc">&nbsp;        return entityDetectedBy;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWhoCanDetect(Vector&lt;IPlayer&gt; entityDetectedBy) {
<b class="nc">&nbsp;        this.entityDetectedBy = entityDetectedBy;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearDetectedBy() {
&nbsp;        // This is for saved-game backwards compatibility
<b class="nc">&nbsp;        if (entityDetectedBy == null) {</b>
<b class="nc">&nbsp;            entityDetectedBy = new Vector&lt;IPlayer&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        entityDetectedBy.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the the given player can see this Entity, including
&nbsp;     * teammates if team_vision is on.
&nbsp;     *
&nbsp;     */
&nbsp;    public boolean hasDetectedEntity(IPlayer p) {
&nbsp;        // No sensors - no one detects anything
<b class="nc">&nbsp;        if ((game == null)</b>
<b class="nc">&nbsp;                || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // Null players detect nothing
<b class="nc">&nbsp;        if (p == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // This is for saved-game backwards compatibility
<b class="nc">&nbsp;        if (entityDetectedBy == null) {</b>
<b class="nc">&nbsp;            entityDetectedBy = new Vector&lt;IPlayer&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Observers can detect units detected by an enemy
<b class="nc">&nbsp;        if (p.isObserver()) {</b>
<b class="nc">&nbsp;            for (IPlayer other : entityDetectedBy) {</b>
<b class="nc">&nbsp;                if (other.isEnemyOf(getOwner())) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entityDetectedBy.contains(p)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        // If team vision, see if any players on team can see
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION)) {</b>
<b class="nc">&nbsp;            for (IPlayer teammate : game.getPlayersVector()) {</b>
<b class="nc">&nbsp;                if ((teammate.getTeam() == p.getTeam())</b>
<b class="nc">&nbsp;                        &amp;&amp; entityDetectedBy.contains(teammate)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        // Can&#39;t see
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether this Entity is a sensor return to the given player.
&nbsp;     *
&nbsp;     * @param spotter
&nbsp;     *            The player trying to view this unit
&nbsp;     * @return True if the given player can only see this Entity as a sensor
&nbsp;     *         return
&nbsp;     */
&nbsp;    public boolean isSensorReturn(IPlayer spotter) {
<b class="nc">&nbsp;        boolean alliedUnit =</b>
<b class="nc">&nbsp;                !getOwner().isEnemyOf(spotter)</b>
<b class="nc">&nbsp;                || (getOwner().getTeam() == spotter.getTeam()</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_TEAM_VISION));</b>
&nbsp;
<b class="nc">&nbsp;        boolean sensors = (game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVANCED_TACOPS_SENSORS)
<b class="nc">&nbsp;                || game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS));</b>
<b class="nc">&nbsp;        boolean sensorsDetectAll = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVANCED_SENSORS_DETECT_ALL);
<b class="nc">&nbsp;        boolean doubleBlind = game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVANCED_DOUBLE_BLIND);
&nbsp;
<b class="nc">&nbsp;        return sensors &amp;&amp; doubleBlind &amp;&amp; !alliedUnit &amp;&amp; !sensorsDetectAll</b>
<b class="nc">&nbsp;                &amp;&amp; !hasSeenEntity(spotter) &amp;&amp; hasDetectedEntity(spotter);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int applyGravityEffectsOnMP(int MP) {
<b class="fc">&nbsp;        int result = MP;</b>
<b class="fc">&nbsp;        if (game != null) {</b>
<b class="nc">&nbsp;            float fMP = MP / game.getPlanetaryConditions().getGravity();</b>
<b class="nc">&nbsp;            fMP = (Math.abs((Math.round(fMP) - fMP)) == 0.5) ? (float) Math</b>
<b class="nc">&nbsp;                    .floor(fMP) : Math.round(fMP); // the</b>
&nbsp;            // rule
&nbsp;            // requires
&nbsp;            // rounding down on .5
<b class="nc">&nbsp;            result = (int) fMP;</b>
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Whether this type of unit can perform charges
&nbsp;     */
&nbsp;    public boolean canCharge() {
<b class="nc">&nbsp;        return !isImmobile() &amp;&amp; (getWalkMP() &gt; 0) &amp;&amp; !isStuck() &amp;&amp; !isProne();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Whether this type of unit can perform DFA attacks
&nbsp;     */
&nbsp;    public boolean canDFA() {
<b class="nc">&nbsp;        return !isImmobile() &amp;&amp; (getJumpMP() &gt; 0) &amp;&amp; !isStuck() &amp;&amp; !isProne();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Whether this type of unit can perform Ramming attacks
&nbsp;     */
&nbsp;    public boolean canRam() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isUsingManAce() {
<b class="nc">&nbsp;        return hasAbility(OptionsConstants.PILOT_MANEUVERING_ACE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Enumeration&lt;Entity&gt; getKills() {
<b class="nc">&nbsp;        final int killer = id;</b>
<b class="nc">&nbsp;        return game.getSelectedOutOfGameEntities(new EntitySelector() {</b>
&nbsp;            @Override
&nbsp;            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                if (killer == entity.killerId) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public int getKillNumber() {
<b class="nc">&nbsp;        final int killer = id;</b>
<b class="nc">&nbsp;        return game.getSelectedOutOfGameEntityCount(new EntitySelector() {</b>
&nbsp;            @Override
&nbsp;            public boolean accept(Entity entity) {
<b class="nc">&nbsp;                if (killer == entity.killerId) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public void addKill(Entity kill) {
<b class="nc">&nbsp;        kill.killerId = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getGaveKillCredit() {
<b class="nc">&nbsp;        return killerId != Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getKillerId() {
<b class="nc">&nbsp;        return killerId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if an entity is eligible for a phase.
&nbsp;     */
&nbsp;    public boolean isEligibleFor(IGame.Phase phase) {
&nbsp;        // only deploy in deployment phase
<b class="nc">&nbsp;        if ((phase == IGame.Phase.PHASE_DEPLOYMENT) == isDeployed()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // carcass can&#39;t do anything
<b class="nc">&nbsp;        if (isCarcass()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Hidden units shouldn&#39;t be counted for turn order, unless deploying
<b class="nc">&nbsp;        if (isHidden() &amp;&amp; phase != Phase.PHASE_DEPLOYMENT</b>
&nbsp;                &amp;&amp; phase != Phase.PHASE_FIRING) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (phase) {</b>
&nbsp;            case PHASE_MOVEMENT:
<b class="nc">&nbsp;                return isEligibleForMovement();</b>
&nbsp;            case PHASE_FIRING:
<b class="nc">&nbsp;                return isEligibleForFiring();</b>
&nbsp;            case PHASE_PHYSICAL:
<b class="nc">&nbsp;                return isEligibleForPhysical();</b>
&nbsp;            case PHASE_TARGETING:
<b class="nc">&nbsp;                return isEligibleForTargetingPhase();</b>
&nbsp;            case PHASE_OFFBOARD:
<b class="nc">&nbsp;                return isEligibleForOffboard();</b>
&nbsp;            default:
<b class="nc">&nbsp;                return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if an entity is eligible for a phase. Called only if at least
&nbsp;     * one entity returned true to isEligibleFor() This is for using
&nbsp;     * searchlights in physical&amp;offboard phase, without forcing the phase to be
&nbsp;     * played when not needed. However it could be used for other things in the
&nbsp;     * future
&nbsp;     */
&nbsp;    public boolean canAssist(IGame.Phase phase) {
<b class="nc">&nbsp;        if ((phase != IGame.Phase.PHASE_PHYSICAL)</b>
&nbsp;            &amp;&amp; (phase != IGame.Phase.PHASE_FIRING)
&nbsp;            &amp;&amp; (phase != IGame.Phase.PHASE_OFFBOARD)) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // if you&#39;re charging or finding a club, it&#39;s already declared
<b class="nc">&nbsp;        if (isUnjammingRAC() || isCharging() || isMakingDfa() || isRamming()</b>
<b class="nc">&nbsp;            || isFindingClub() || isOffBoard()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // must be active
<b class="nc">&nbsp;        if (!isActive()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // If we have a searchlight, we can use it to assist
<b class="nc">&nbsp;        if (isUsingSpotlight()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An entity is eligible for firing if it&#39;s not taking some kind of action
&nbsp;     * that prevents it from firing, such as a full-round physical attack
&nbsp;     * or sprinting.
&nbsp;     */
&nbsp;    public boolean isEligibleForFiring() {
&nbsp;        // if you&#39;re charging, no shooting
<b class="nc">&nbsp;        if (isUnjammingRAC() || isCharging() || isMakingDfa() || isRamming()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if you&#39;re offboard, no shooting
<b class="nc">&nbsp;        if (isOffBoard() || isAssaultDropInProgress()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check game options
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.BASE_SKIP_INELIGABLE_FIRING)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // must be active
<b class="nc">&nbsp;        if (!isActive()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Pretty much anybody&#39;s eligible for movement. If the game option is
&nbsp;     * toggled on, inactive and immobile entities are not eligible. OffBoard
&nbsp;     * units are always ineligible
&nbsp;     *
&nbsp;     * @return whether or not the entity is allowed to move
&nbsp;     */
&nbsp;    public boolean isEligibleForMovement() {
&nbsp;        // check if entity is offboard
<b class="nc">&nbsp;        if (isOffBoard() || (isAssaultDropInProgress()</b>
&nbsp;                &amp;&amp; !(movementMode == EntityMovementMode.WIGE))) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // Prevent ejected crews from moving when advanced movement rule is off
<b class="nc">&nbsp;        if (!game.useVectorMove() &amp;&amp; isSpaceborne() &amp;&amp; this instanceof EjectedCrew) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // check game options
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.BASE_SKIP_INELIGABLE_MOVEMENT)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        // Must be active: this is slightly different  from isActive();
&nbsp;        //   we don&#39;t want to skip manually shutdown units (so they can restart)
<b class="nc">&nbsp;        boolean isActive = (!shutDown || isManualShutdown()) &amp;&amp; !destroyed</b>
<b class="nc">&nbsp;                &amp;&amp; getCrew().isActive() &amp;&amp; !unloadedThisTurn &amp;&amp; deployed;</b>
<b class="nc">&nbsp;        if (!isActive</b>
<b class="nc">&nbsp;            || (isImmobile() &amp;&amp; !isManualShutdown() &amp;&amp; !canUnjamRAC() &amp;&amp;</b>
<b class="nc">&nbsp;                !game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLES_CAN_EJECT))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEligibleForOffboard() {
&nbsp;
&nbsp;        // if you&#39;re charging, no shooting
<b class="nc">&nbsp;        if (isUnjammingRAC() || isCharging() || isMakingDfa()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if you&#39;re offboard, no shooting
<b class="nc">&nbsp;        if (isOffBoard() || isAssaultDropInProgress()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted mounted : getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="nc">&nbsp;            if ((wtype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (wtype.hasFlag(WeaponType.F_TAG) &amp;&amp; mounted.isReady())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;// only things w/ tag are</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isAttackingThisTurn() {
<b class="nc">&nbsp;        List&lt;EntityAction&gt; actions = game.getActionsVector();</b>
<b class="nc">&nbsp;        for (EntityAction ea : actions) {</b>
<b class="nc">&nbsp;            if ((ea.getEntityId() == getId())</b>
&nbsp;                &amp;&amp; (ea instanceof AbstractAttackAction)) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the entity has any valid targets for physical attacks.
&nbsp;     */
&nbsp;    public boolean isEligibleForPhysical() {
<b class="nc">&nbsp;        boolean canHit = false;</b>
<b class="nc">&nbsp;        boolean friendlyFire = game.getOptions().booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE);</b>
&nbsp;
<b class="nc">&nbsp;        if ((this instanceof Infantry)</b>
<b class="nc">&nbsp;                &amp;&amp; hasWorkingMisc(MiscType.F_TOOLS,</b>
&nbsp;                        MiscType.S_DEMOLITION_CHARGE)) {
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;            return hex.containsTerrain(Terrains.BUILDING);</b>
&nbsp;        }
&nbsp;        // only mechs and protos have physical attacks (except tank charges)
<b class="nc">&nbsp;        if (!((this instanceof Mech) || (this instanceof Protomech) || (this instanceof Infantry))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if you&#39;re charging or finding a club, it&#39;s already declared
<b class="nc">&nbsp;        if (isUnjammingRAC() || isCharging() || isMakingDfa() || isRamming()</b>
<b class="nc">&nbsp;            || isFindingClub() || isOffBoard() || isAssaultDropInProgress()</b>
<b class="nc">&nbsp;            || isDropping()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // check game options
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ALLOWED_NO_CLAN_PHYSICAL) &amp;&amp; isClan()</b>
<b class="nc">&nbsp;            &amp;&amp; !hasINarcPodsAttached() &amp;&amp; (getSwarmAttackerId() == NONE)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Issue with Vibroblades only being turned on/off during Physical phase
&nbsp;        // -- Torren
<b class="nc">&nbsp;        if (hasVibroblades()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.BASE_SKIP_INELIGABLE_PHYSICAL)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // dead mek walking
<b class="nc">&nbsp;        if (!isActive()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // sprinted?
<b class="nc">&nbsp;        if (moved == EntityMovementType.MOVE_SPRINT</b>
&nbsp;                || moved == EntityMovementType.MOVE_VTOL_SPRINT) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getPosition() == null) {</b>
<b class="nc">&nbsp;            return false; // not on board?</b>
&nbsp;        }
&nbsp;
&nbsp;        // check if we have iNarc pods attached that can be brushed off
<b class="nc">&nbsp;        if (hasINarcPodsAttached() &amp;&amp; (this instanceof Mech)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Try to find a valid entity target.
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; e = game.getEntities();</b>
<b class="nc">&nbsp;        while (!canHit &amp;&amp; e.hasNext()) {</b>
<b class="nc">&nbsp;            Entity target = e.next();</b>
&nbsp;
&nbsp;            // don&#39;t shoot at friendlies unless you are into that sort of thing
&nbsp;            // and do not shoot yourself even then
<b class="nc">&nbsp;            if (!(isEnemyOf(target) || (friendlyFire &amp;&amp; (getId() != target</b>
<b class="nc">&nbsp;                    .getId())))) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!target.isDeployed()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            // No physical attack works at distances &gt; 1.
<b class="nc">&nbsp;            if ((target.getPosition() != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (Compute.effectiveDistance(game, this, target) &gt; 1)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            canHit |= Compute.canPhysicalTarget(game, getId(), target);</b>
&nbsp;            // check if we can dodge and target can attack us,
&nbsp;            // then we are eligible.
<b class="nc">&nbsp;            canHit |= ((this instanceof Mech) &amp;&amp; !isProne()</b>
<b class="nc">&nbsp;                       &amp;&amp; hasAbility(OptionsConstants.PILOT_DODGE_MANEUVER) &amp;&amp; Compute</b>
<b class="nc">&nbsp;                    .canPhysicalTarget(game, target.getId(), this));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // If there are no valid Entity targets, check for add valid buildings.
<b class="nc">&nbsp;        Enumeration&lt;Building&gt; bldgs = game.getBoard().getBuildings();</b>
<b class="nc">&nbsp;        while (!canHit &amp;&amp; bldgs.hasMoreElements()) {</b>
<b class="nc">&nbsp;            final Building bldg = bldgs.nextElement();</b>
&nbsp;
&nbsp;            // Walk through the hexes of the building.
<b class="nc">&nbsp;            Enumeration&lt;Coords&gt; hexes = bldg.getCoords();</b>
<b class="nc">&nbsp;            while (!canHit &amp;&amp; hexes.hasMoreElements()) {</b>
<b class="nc">&nbsp;                final Coords coords = hexes.nextElement();</b>
&nbsp;
&nbsp;                // No physical attack works at distances &gt; 1.
<b class="nc">&nbsp;                if (getPosition().distance(coords) &gt; 1) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Can the entity target *this* hex of the building?
<b class="nc">&nbsp;                final BuildingTarget target = new BuildingTarget(coords,</b>
<b class="nc">&nbsp;                                                                 game.getBoard(), false);</b>
<b class="nc">&nbsp;                canHit |= Compute.canPhysicalTarget(game, getId(), target);</b>
&nbsp;
<b class="nc">&nbsp;            } // Check the next hex of the building</b>
&nbsp;
<b class="nc">&nbsp;        } // Check the next building</b>
&nbsp;
<b class="nc">&nbsp;        return canHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this Entity is eligible to pre-designate hexes as
&nbsp;     * auto-hits. Per TacOps pg 180, if a player has offboard artillery they get
&nbsp;     * 5 pre- designated hexes per mapsheet.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isEligibleForArtyAutoHitHexes() {
<b class="nc">&nbsp;        return isEligibleForTargetingPhase()</b>
<b class="nc">&nbsp;               &amp;&amp; (isOffBoard() || game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_ON_MAP_PREDESIGNATE));
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEligibleForTargetingPhase() {
<b class="nc">&nbsp;        if (isAssaultDropInProgress()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted mounted : getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) mounted.getType();</b>
<b class="nc">&nbsp;            if ((wtype != null) &amp;&amp; (wtype.hasFlag(WeaponType.F_ARTILLERY))) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            //Bearings-only capital missiles fire during the targeting phase
<b class="nc">&nbsp;            if ((wtype instanceof TeleOperatedMissileBayWeapon)</b>
&nbsp;                    || (wtype instanceof CapitalMissileBayWeapon)
&nbsp;                    || (wtype instanceof AR10BayWeapon)) {
<b class="nc">&nbsp;                if (mounted.isInBearingsOnlyMode()) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            //Surface to surface capital missiles count as artillery
<b class="nc">&nbsp;            if  (this.getAltitude() == 0</b>
&nbsp;                    &amp;&amp; wtype instanceof CapitalMissileWeapon) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public double getTroopCarryingSpace() {
<b class="nc">&nbsp;        double space = 0;</b>
<b class="nc">&nbsp;        for (Transporter t : transports) {</b>
<b class="nc">&nbsp;            if (t instanceof TroopSpace) {</b>
<b class="nc">&nbsp;                space += ((TroopSpace) t).totalSpace;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return space;</b>
&nbsp;    }
&nbsp;
&nbsp;    public double getPodMountedTroopCarryingSpace() {
<b class="nc">&nbsp;        double space = 0;</b>
<b class="nc">&nbsp;        for (Transporter t : omniPodTransports) {</b>
<b class="nc">&nbsp;            if (t instanceof TroopSpace) {</b>
<b class="nc">&nbsp;                space += ((TroopSpace) t).totalSpace;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return space;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasBattleArmorHandles() {
<b class="nc">&nbsp;        for (Transporter t : transports) {</b>
<b class="nc">&nbsp;            if (t instanceof BattleArmorHandles) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this unit has a ClampMountMech or ClampMountTank that
&nbsp;     * is currently unloaded.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasUnloadedClampMount() {
<b class="nc">&nbsp;        for (Transporter t : transports) {</b>
<b class="nc">&nbsp;            if (((t instanceof ClampMountTank) || (t instanceof ClampMountMech))</b>
<b class="nc">&nbsp;                    &amp;&amp; (t.getUnused() &gt; 0)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     *
&nbsp;     * @see megamek.common.Targetable#isOffBoard()
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isOffBoard() {
<b class="nc">&nbsp;        return offBoardDistance &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the unit as an offboard deployment. If a non-zero distance is chosen,
&nbsp;     * the direction must &lt;b&gt;not&lt;/b&gt; be &lt;code&gt;Entity.NONE&lt;/code&gt;. If a direction
&nbsp;     * other than &lt;code&gt;Entity.NONE&lt;/code&gt; is chosen, the distance must
&nbsp;     * &lt;b&gt;not&lt;/b&gt; be zero (0).
&nbsp;     *
&nbsp;     * @param distance  the &lt;code&gt;int&lt;/code&gt; distance in hexes that the unit will be
&nbsp;     *                  deployed from the board; this value must not be negative.
&nbsp;     * @param direction the &lt;code&gt;int&lt;/code&gt; direction from the board that the unit
&nbsp;     *                  will be deployed; a valid value must be selected from: NONE,
&nbsp;     *                  NORTH, SOUTH, EAST, or WEST.
&nbsp;     * @throws IllegalArgumentException if a negative distance, an invalid direction is selected, or
&nbsp;     *                                  the distance does not match the direction.
&nbsp;     */
&nbsp;    public void setOffBoard(int distance, OffBoardDirection direction) {
<b class="nc">&nbsp;        if (distance &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;negative number given for distance offboard&quot;);
&nbsp;        }
<b class="nc">&nbsp;        if ((0 == distance) &amp;&amp; (OffBoardDirection.NONE != direction)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;onboard unit was given an offboard direction&quot;);
&nbsp;        }
<b class="nc">&nbsp;        if ((0 != distance) &amp;&amp; (OffBoardDirection.NONE == direction)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;offboard unit was not given an offboard direction&quot;);
&nbsp;        }
<b class="nc">&nbsp;        switch (direction) {</b>
&nbsp;            case NORTH:
<b class="nc">&nbsp;                setFacing(3);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SOUTH:
<b class="nc">&nbsp;                setFacing(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WEST:
<b class="nc">&nbsp;                setFacing(2);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case EAST:
<b class="nc">&nbsp;                setFacing(4);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        offBoardDistance = distance;</b>
<b class="nc">&nbsp;        offBoardDirection = direction;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the distance in hexes from the board that the unit will be deployed.
&nbsp;     * If the unit is to be deployed onboard, the distance will be zero (0).
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; distance from the board the unit will be
&nbsp;     * deployed (in hexes); this value will never be negative.
&nbsp;     */
&nbsp;    public int getOffBoardDistance() {
<b class="nc">&nbsp;        return offBoardDistance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the direction the board that the unit will be deployed. If the unit
&nbsp;     * is to be deployed onboard, the distance will be
&nbsp;     * &lt;code&gt;IOffBoardDirections.NONE&lt;/code&gt;, otherwise it will be one of the
&nbsp;     * values:
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;&lt;code&gt;IOffBoardDirections.NORTH&lt;/code&gt;&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;code&gt;IOffBoardDirections.SOUTH&lt;/code&gt;&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;code&gt;IOffBoardDirections.EAST&lt;/code&gt;&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;code&gt;IOffBoardDirections.WEST&lt;/code&gt;&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; direction from the board the unit will be
&nbsp;     * deployed. Only valid values will be returned.
&nbsp;     */
&nbsp;    public OffBoardDirection getOffBoardDirection() {
<b class="nc">&nbsp;        return offBoardDirection;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deploy this offboard entity at the previously specified distance and
&nbsp;     * direction. This should only be invoked by the &lt;code&gt;Server&lt;/code&gt; after
&nbsp;     * the board has been selected and all the players are ready to start. The
&nbsp;     * side effects of this methods set the unit&#39;s position and facing as
&nbsp;     * appropriate (as well as deploying the unit).
&nbsp;     * &lt;p/&gt;
&nbsp;     * Onboard units (units with an offboard distance of zero and a direction of
&nbsp;     * &lt;code&gt;Entity.NONE&lt;/code&gt;) will be unaffected by this method.
&nbsp;     * @param round The current round number.
&nbsp;     */
&nbsp;    public void deployOffBoard(int round) {
<b class="nc">&nbsp;        if (null == game) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(</b>
&nbsp;                    &quot;game not set; possible serialization error&quot;);
&nbsp;        }
&nbsp;        // N.B. 17 / 2 = 8, but the middle of 1..17 is 9, so we
&nbsp;        // add a bit (because 17 % 2 == 1 and 16 % 2 == 0).
<b class="nc">&nbsp;        switch (offBoardDirection) {</b>
&nbsp;            case NONE:
<b class="nc">&nbsp;                return;</b>
&nbsp;            case NORTH:
<b class="nc">&nbsp;                setPosition(new Coords((game.getBoard().getWidth() / 2)</b>
<b class="nc">&nbsp;                        + (game.getBoard().getWidth() % 2),</b>
<b class="nc">&nbsp;                        -getOffBoardDistance()));</b>
<b class="nc">&nbsp;                setFacing(3);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case SOUTH:
<b class="nc">&nbsp;                setPosition(new Coords((game.getBoard().getWidth() / 2)</b>
<b class="nc">&nbsp;                        + (game.getBoard().getWidth() % 2), game.getBoard()</b>
<b class="nc">&nbsp;                        .getHeight() + getOffBoardDistance()));</b>
<b class="nc">&nbsp;                setFacing(0);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case EAST:
<b class="nc">&nbsp;                setPosition(new Coords(game.getBoard().getWidth()</b>
<b class="nc">&nbsp;                        + getOffBoardDistance(),</b>
<b class="nc">&nbsp;                        (game.getBoard().getHeight() / 2)</b>
<b class="nc">&nbsp;                                + (game.getBoard().getHeight() % 2)));</b>
<b class="nc">&nbsp;                setFacing(5);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case WEST:
<b class="nc">&nbsp;                setPosition(new Coords(-getOffBoardDistance(), (game.getBoard()</b>
<b class="nc">&nbsp;                        .getHeight() / 2) + (game.getBoard().getHeight() % 2)));</b>
<b class="nc">&nbsp;                setFacing(1);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        // deploy the unit, but only if it should be deployed this round
<b class="nc">&nbsp;        setDeployed(shouldOffBoardDeploy(round));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Vector&lt;Integer&gt; getPickedUpMechWarriors() {
<b class="nc">&nbsp;        return pickedUpMechWarriors;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Has this entity been captured?
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if it has.
&nbsp;     */
&nbsp;    public boolean isCaptured() {
<b class="nc">&nbsp;        return captured &amp;&amp; !isDestroyed();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that this entity has been captured.
&nbsp;     *
&nbsp;     * @param arg the &lt;code&gt;boolean&lt;/code&gt; value to assign.
&nbsp;     */
&nbsp;    public void setCaptured(boolean arg) {
<b class="nc">&nbsp;        captured = arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setExternalSpotlight(boolean arg) {
<b class="nc">&nbsp;        hasExternalSpotlight = arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns state of hasExternalSpotlight, does not consider mounted
&nbsp;     * spotlights.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasExternaSpotlight() {
<b class="nc">&nbsp;        return hasExternalSpotlight;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the unit has a usable spotlight. It considers both
&nbsp;     * externally mounted spotlights as well as internally mounted ones.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasSpotlight() {
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_SEARCHLIGHT)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return hasExternalSpotlight;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to destroy a single spotlight on an entity. Spotlights can be
&nbsp;     * destroyed on a roll of 7+ on a torso hit on a mek or on a front/side hit
&nbsp;     * on a combat vehicle.
&nbsp;     */
&nbsp;    public void destroyOneSpotlight() {
<b class="nc">&nbsp;        if (!hasSpotlight()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // A random spotlight should be destroyed, but this is easier...
<b class="nc">&nbsp;        if (hasExternalSpotlight) {</b>
<b class="nc">&nbsp;            hasExternalSpotlight = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_SEARCHLIGHT)</b>
<b class="nc">&nbsp;                &amp;&amp; !m.isInoperable()) {</b>
<b class="nc">&nbsp;                m.setDestroyed(true);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Turn off the light all spot lights were destroyed
<b class="nc">&nbsp;        if (!hasSpotlight()) {</b>
<b class="nc">&nbsp;            setSpotlightState(false);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setSpotlightState(boolean arg) {
<b class="nc">&nbsp;        if (hasSpotlight()) {</b>
<b class="nc">&nbsp;            spotlightIsActive = arg;</b>
<b class="nc">&nbsp;            if (arg) {</b>
<b class="nc">&nbsp;                illuminated = true;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            spotlightIsActive = false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isIlluminated() {
&nbsp;        // Regardless of illuminated state, if we have a spotlight active we
&nbsp;        //  are illuminated
<b class="nc">&nbsp;        return illuminated || spotlightIsActive;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setIlluminated(boolean arg) {
<b class="nc">&nbsp;        illuminated = spotlightIsActive || arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isUsingSpotlight() {
<b class="nc">&nbsp;        return hasSpotlight() &amp;&amp; spotlightIsActive;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUsedSearchlight(boolean arg) {
<b class="nc">&nbsp;        usedSearchlight = arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean usedSearchlight() {
<b class="nc">&nbsp;        return usedSearchlight;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is the Entity stuck in a swamp?
&nbsp;     */
&nbsp;    public boolean isStuck() {
<b class="nc">&nbsp;        return stuckInSwamp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set weather this Entity is stuck in a swamp or not
&nbsp;     *
&nbsp;     * @param arg the &lt;code&gt;boolean&lt;/code&gt; value to assign
&nbsp;     */
&nbsp;    public void setStuck(boolean arg) {
<b class="nc">&nbsp;        stuckInSwamp = arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Is the Entity stuck in a swamp?
&nbsp;     */
&nbsp;    public boolean canUnstickByJumping() {
<b class="nc">&nbsp;        return canUnstickByJumping;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set wether this Enity is stuck in a swamp or not
&nbsp;     *
&nbsp;     * @param arg the &lt;code&gt;boolean&lt;/code&gt; value to assign
&nbsp;     */
&nbsp;    public void setCanUnstickByJumping(boolean arg) {
<b class="nc">&nbsp;        canUnstickByJumping = arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * The following methods support the eventual refactoring into the Entity
&nbsp;     * class of a lot of the Server logic surrounding entity damage and death.
&nbsp;     * They are not currently called in Server anywhere, and so may as well not
&nbsp;     * exist.
&nbsp;     */
&nbsp;
&nbsp;    public String destroy(String reason, boolean survivable, boolean canSalvage) {
<b class="nc">&nbsp;        StringBuffer sb = new StringBuffer();</b>
&nbsp;
<b class="nc">&nbsp;        int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;</b>
<b class="nc">&nbsp;        if (!canSalvage) {</b>
<b class="nc">&nbsp;            setSalvage(canSalvage);</b>
<b class="nc">&nbsp;            condition = IEntityRemovalConditions.REMOVE_DEVASTATED;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isDoomed() || isDestroyed()) {</b>
<b class="nc">&nbsp;            return sb.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        // working under the assumption that entity was neither doomed or
&nbsp;        // destroyed before from here on out
&nbsp;
<b class="nc">&nbsp;        setDoomed(true);</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;Integer&gt; iter = getPickedUpMechWarriors().elements();</b>
<b class="nc">&nbsp;        while (iter.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Integer mechWarriorId = iter.nextElement();</b>
<b class="nc">&nbsp;            Entity mw = game.getEntity(mechWarriorId.intValue());</b>
<b class="nc">&nbsp;            mw.setDestroyed(true);</b>
<b class="nc">&nbsp;            game.removeEntity(mw.getId(), condition);</b>
<b class="nc">&nbsp;            sb.append(&quot;\n*** &quot;).append(</b>
<b class="nc">&nbsp;                    mw.getDisplayName() + &quot; died in the wreckage. ***\n&quot;);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a targeting by a swarm volley from a specified entity
&nbsp;     *
&nbsp;     * @param entityId The &lt;code&gt;int&lt;/code&gt; id of the shooting entity
&nbsp;     * @param weaponId The &lt;code&gt;int&lt;/code&gt; id of the shooting lrm launcher
&nbsp;     */
&nbsp;    public void addTargetedBySwarm(int entityId, int weaponId) {
<b class="nc">&nbsp;        hitBySwarmsEntity.addElement(entityId);</b>
<b class="nc">&nbsp;        hitBySwarmsWeapon.addElement(weaponId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Were we targeted by a certain swarm/swarm-i volley this turn?
&nbsp;     *
&nbsp;     * @param entityId The &lt;code&gt;int&lt;/code&gt; id of the shooting entity we are checking
&nbsp;     * @param weaponId The &lt;code&gt;int&lt;/code&gt; id of the launcher to check
&nbsp;     * @return a fitting &lt;code&gt;boolean&lt;/code&gt; value
&nbsp;     */
&nbsp;    public boolean getTargetedBySwarm(int entityId, int weaponId) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; hitBySwarmsEntity.size(); i++) {</b>
<b class="nc">&nbsp;            Integer entityIdToTest = hitBySwarmsEntity.elementAt(i);</b>
<b class="nc">&nbsp;            Integer weaponIdToTest = hitBySwarmsWeapon.elementAt(i);</b>
<b class="nc">&nbsp;            if ((entityId == entityIdToTest.intValue())</b>
<b class="nc">&nbsp;                &amp;&amp; (weaponId == weaponIdToTest.intValue())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getShortRangeModifier() {
<b class="nc">&nbsp;        int mod = 0;</b>
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_RANGE_MASTER, Crew.RANGEMASTER_MEDIUM)) {</b>
<b class="nc">&nbsp;            mod = 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_RANGE_MASTER, Crew.RANGEMASTER_LONG)) {</b>
<b class="nc">&nbsp;            mod = 4;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_RANGE_MASTER, Crew.RANGEMASTER_EXTREME)) {</b>
<b class="nc">&nbsp;            mod = 6;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_SNIPER) &amp;&amp; (mod &gt; 0)) {</b>
<b class="nc">&nbsp;            mod = mod / 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_S)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_S)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMediumRangeModifier() {
<b class="nc">&nbsp;        int mod = 2;</b>
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_RANGE_MASTER, Crew.RANGEMASTER_MEDIUM)) {</b>
<b class="nc">&nbsp;            mod = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_SNIPER) &amp;&amp; (mod &gt; 0)) {</b>
<b class="nc">&nbsp;            mod = mod / 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_M)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_M)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getLongRangeModifier() {
<b class="nc">&nbsp;        int mod = 4;</b>
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_RANGE_MASTER, Crew.RANGEMASTER_LONG)) {</b>
<b class="nc">&nbsp;            mod = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_SNIPER) &amp;&amp; (mod &gt; 0)) {</b>
<b class="nc">&nbsp;            mod = mod / 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_L)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_L)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) {</b>
<b class="nc">&nbsp;            mod--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) {</b>
<b class="nc">&nbsp;            mod++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getExtremeRangeModifier() {
<b class="nc">&nbsp;        int mod = 6;</b>
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_RANGE_MASTER, Crew.RANGEMASTER_EXTREME)) {</b>
<b class="nc">&nbsp;            mod = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.GUNNERY_SNIPER) &amp;&amp; (mod &gt; 0)) {</b>
<b class="nc">&nbsp;            mod = mod / 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getLOSRangeModifier() {
<b class="nc">&nbsp;        int mod = 8;</b>
&nbsp;
<b class="nc">&nbsp;        return mod;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setArmorType(int armType) {
<b class="fc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;            armorType[i] = armType;</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setArmorType(int armType, int loc) {
<b class="nc">&nbsp;        armorType[loc] = armType;</b>
<b class="nc">&nbsp;        recalculateTechAdvancement();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setStructureType(int strucType) {
<b class="fc">&nbsp;        structureType = strucType;</b>
<b class="fc">&nbsp;        structureTechLevel = getTechLevel();</b>
<b class="fc">&nbsp;        recalculateTechAdvancement();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setStructureTechLevel(int level) {
<b class="nc">&nbsp;        structureTechLevel = level;</b>
<b class="nc">&nbsp;        recalculateTechAdvancement();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setArmorType(String armType) {
<b class="fc">&nbsp;        if (!(armType.startsWith(&quot;Clan &quot;) || armType.startsWith(&quot;IS &quot;))) {</b>
<b class="fc">&nbsp;            armType = TechConstants.isClan(getArmorTechLevel(0)) ? &quot;Clan &quot;</b>
<b class="nc">&nbsp;                                                                   + armType : &quot;IS &quot; + armType;</b>
&nbsp;        }
<b class="fc">&nbsp;        EquipmentType et = EquipmentType.get(armType);</b>
<b class="fc">&nbsp;        if (et == null) {</b>
<b class="fc">&nbsp;            setArmorType(EquipmentType.T_ARMOR_UNKNOWN);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            setArmorType(EquipmentType.getArmorType(et));</b>
&nbsp;            // TODO: Is this needed? WTF is the point of it?
<b class="fc">&nbsp;            if (et.getCriticals(this) == 0) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    this.addEquipment(et, LOC_NONE);</b>
<b class="nc">&nbsp;                } catch (LocationFullException e) {</b>
&nbsp;                    // can&#39;t happen
<b class="nc">&nbsp;                    e.printStackTrace();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        recalculateTechAdvancement();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setArmorType(String armType, int loc) {
<b class="nc">&nbsp;        if (!(armType.startsWith(&quot;Clan &quot;) || armType.startsWith(&quot;IS &quot;))) {</b>
<b class="nc">&nbsp;            armType = TechConstants.isClan(getArmorTechLevel(0)) ? &quot;Clan &quot;</b>
<b class="nc">&nbsp;                                                                   + armType : &quot;IS &quot; + armType;</b>
&nbsp;        }
<b class="nc">&nbsp;        EquipmentType et = EquipmentType.get(armType);</b>
<b class="nc">&nbsp;        if (et == null) {</b>
<b class="nc">&nbsp;            setArmorType(EquipmentType.T_ARMOR_UNKNOWN, loc);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setArmorType(EquipmentType.getArmorType(et), loc);</b>
&nbsp;            // TODO: Is this needed? WTF is the point of it?
<b class="nc">&nbsp;            if (et.getCriticals(this) == 0) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    this.addEquipment(et, LOC_NONE);</b>
<b class="nc">&nbsp;                } catch (LocationFullException e) {</b>
&nbsp;                    // can&#39;t happen
<b class="nc">&nbsp;                    e.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        recalculateTechAdvancement();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setStructureType(String strucType) {
<b class="fc">&nbsp;        if (!(strucType.startsWith(&quot;Clan &quot;) || strucType.startsWith(&quot;IS &quot;))) {</b>
<b class="fc">&nbsp;            strucType = isClan() ? &quot;Clan &quot; + strucType : &quot;IS &quot; + strucType;</b>
&nbsp;        }
<b class="fc">&nbsp;        EquipmentType et = EquipmentType.get(strucType);</b>
<b class="fc">&nbsp;        setStructureType(EquipmentType.getStructureType(et));</b>
<b class="fc">&nbsp;        if (et == null) {</b>
<b class="fc">&nbsp;            structureTechLevel = TechConstants.T_TECH_UNKNOWN;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            structureTechLevel = et.getTechLevel(year);</b>
&nbsp;            // TODO: Is this needed? WTF is the point of it?
<b class="fc">&nbsp;            if (et.getCriticals(this) == 0) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    this.addEquipment(et, LOC_NONE);</b>
<b class="nc">&nbsp;                } catch (LocationFullException e) {</b>
&nbsp;                    // can&#39;t happen
<b class="nc">&nbsp;                    e.printStackTrace();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        recalculateTechAdvancement();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getArmorType(int loc) {
<b class="fc">&nbsp;        if ((loc &gt;= 0 ) &amp;&amp; (loc &lt; armorType.length)) {</b>
<b class="fc">&nbsp;            return armorType[loc];</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return EquipmentType.T_ARMOR_UNKNOWN;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setArmorTechLevel(int newTL) {
<b class="fc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;            armorTechLevel[i] = newTL;</b>
&nbsp;        }
<b class="fc">&nbsp;        recalculateTechAdvancement();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setArmorTechLevel(int newTL, int loc) {
<b class="nc">&nbsp;        armorTechLevel[loc] = newTL;</b>
<b class="nc">&nbsp;        recalculateTechAdvancement();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getArmorTechLevel(int loc) {
<b class="fc">&nbsp;        return armorTechLevel[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getStructureType() {
<b class="fc">&nbsp;        return structureType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getStructureTechLevel() {
<b class="nc">&nbsp;        return structureTechLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWeaponHit(Mounted which) {
<b class="nc">&nbsp;        if (weaponList.contains(which)) {</b>
<b class="nc">&nbsp;            which.setHit(true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setTaggedBy(int tagger) {
<b class="fc">&nbsp;        taggedBy = tagger;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getTaggedBy() {
<b class="nc">&nbsp;        return taggedBy;</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract double getCost(boolean ignoreAmmo);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a multiplier that combines multiplicative construction cost modifiers for this Entity.
&nbsp;     *
&nbsp;     * This includes only modifiers that apply to an Entity&#39;s final, total cost (e.g. - the 1.25x modifier for being
&nbsp;     * an omni-unit, or the 32.0x for being an aerodyne dropship). It does NOT include multipliers that only apply to
&nbsp;     * a sub-part of the unit (e.g. the weight based multiplier that applies to a vehicle&#39;s internal structure cost).
&nbsp;     *
&nbsp;     * This allows MekHQ to scale the price of a Unit&#39;s Parts in a more appropriate manner.
&nbsp;     *
&nbsp;     * Defaults to 1.0
&nbsp;     */
&nbsp;    public double getPriceMultiplier() {
<b class="nc">&nbsp;        return 1.0;</b>
&nbsp;    };
&nbsp;
&nbsp;    public long getWeaponsAndEquipmentCost(boolean ignoreAmmo) {
&nbsp;        // bvText = new StringBuffer();
<b class="nc">&nbsp;        long cost = 0;</b>
&nbsp;
<b class="nc">&nbsp;        NumberFormat commafy = NumberFormat.getInstance();</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted mounted : getEquipment()) {</b>
<b class="nc">&nbsp;            if (ignoreAmmo</b>
<b class="nc">&nbsp;                &amp;&amp; (mounted.getType() instanceof AmmoType)</b>
<b class="nc">&nbsp;                &amp;&amp; (!(((AmmoType) mounted.getType()).getAmmoType() == AmmoType.T_COOLANT_POD))) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (mounted.isWeaponGroup()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            long itemCost = (long) mounted.getCost();</b>
<b class="nc">&nbsp;            if (!ignoreAmmo &amp;&amp; isSupportVehicle() &amp;&amp; (mounted.getSize() &gt; 1)</b>
<b class="nc">&nbsp;                    &amp;&amp; (mounted.getType() instanceof InfantryWeapon)) {</b>
<b class="nc">&nbsp;                itemCost += (mounted.getSize() - 1)</b>
<b class="nc">&nbsp;                        * ((InfantryWeapon) mounted.getType()).getAmmoCost();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            cost += itemCost;</b>
<b class="nc">&nbsp;            if ((bvText != null) &amp;&amp; (itemCost &gt; 0)) {</b>
<b class="nc">&nbsp;                bvText.append(startRow);</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(mounted.getName());</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
&nbsp;
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(commafy.format(itemCost));</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(endRow);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        int count = implicitClanCASE();</b>
<b class="nc">&nbsp;        if (count &gt; 0) {</b>
<b class="nc">&nbsp;            long itemCost = 50000;</b>
<b class="nc">&nbsp;            cost += count * itemCost;</b>
<b class="nc">&nbsp;            if (null != bvText) {</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;                    bvText.append(startColumn);</b>
<b class="nc">&nbsp;                    bvText.append(&quot;CASE&quot;);</b>
<b class="nc">&nbsp;                    bvText.append(endColumn);</b>
<b class="nc">&nbsp;                    bvText.append(startColumn);</b>
<b class="nc">&nbsp;                    bvText.append(commafy.format(itemCost));</b>
<b class="nc">&nbsp;                    bvText.append(endColumn);</b>
<b class="nc">&nbsp;                    bvText.append(endRow);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // Large craft have a separate section for bays
<b class="nc">&nbsp;        if (!isLargeCraft()) {</b>
<b class="nc">&nbsp;            long seatCost = 0;</b>
<b class="nc">&nbsp;            long quartersCost = 0;</b>
<b class="nc">&nbsp;            long bayCost = 0;</b>
<b class="nc">&nbsp;            for (Bay bay : getTransportBays()) {</b>
<b class="nc">&nbsp;                if (bay instanceof StandardSeatCargoBay) {</b>
<b class="nc">&nbsp;                    seatCost += bay.getCost();</b>
<b class="nc">&nbsp;                } else if (bay.isQuarters()) {</b>
<b class="nc">&nbsp;                    quartersCost += bay.getCost();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    bayCost += bay.getCost() + 1000L * bay.getDoors();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (null != bvText &amp;&amp; seatCost &gt; 0) {</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(&quot;Seating&quot;);</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(commafy.format(seatCost));</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(endRow);</b>
<b class="nc">&nbsp;                cost += seatCost;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (null != bvText &amp;&amp; quartersCost &gt; 0) {</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(&quot;Quarters&quot;);</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(commafy.format(quartersCost));</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(endRow);</b>
<b class="nc">&nbsp;                cost += quartersCost;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (null != bvText &amp;&amp; bayCost &gt; 0) {</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(&quot;Bays&quot;);</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(startColumn);</b>
<b class="nc">&nbsp;                bvText.append(commafy.format(bayCost));</b>
<b class="nc">&nbsp;                bvText.append(endColumn);</b>
<b class="nc">&nbsp;                bvText.append(endRow);</b>
<b class="nc">&nbsp;                cost += bayCost;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return cost;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to for cost calculations. Though the TM rules allow a Clan unit to be designed without CASE,
&nbsp;     * MM assumes that CASE is present in any location that has explosive equipment.
&nbsp;     *
&nbsp;     * @return The number of locations protected by Clan CASE beyond what is explicitly mounted.
&nbsp;     */
&nbsp;    protected int implicitClanCASE() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean removePartialCoverHits(int location, int cover, int side) {
<b class="nc">&nbsp;        if (cover &gt; LosEffects.COVER_NONE) {</b>
<b class="nc">&nbsp;            switch (cover) {</b>
&nbsp;                case LosEffects.COVER_LOWLEFT:
<b class="nc">&nbsp;                    if (location == Mech.LOC_LLEG) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case LosEffects.COVER_LOWRIGHT:
<b class="nc">&nbsp;                    if (location == Mech.LOC_RLEG) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case LosEffects.COVER_LEFT:
<b class="nc">&nbsp;                    if ((location == Mech.LOC_LLEG)</b>
&nbsp;                        || (location == Mech.LOC_LARM)
&nbsp;                        || (location == Mech.LOC_LT)) {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case LosEffects.COVER_RIGHT:
<b class="nc">&nbsp;                    if ((location == Mech.LOC_RLEG)</b>
&nbsp;                        || (location == Mech.LOC_RARM)
&nbsp;                        || (location == Mech.LOC_RT)) {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case LosEffects.COVER_HORIZONTAL:
<b class="nc">&nbsp;                    if ((location == Mech.LOC_LLEG)</b>
&nbsp;                        || (location == Mech.LOC_RLEG)) {
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case LosEffects.COVER_UPPER:
<b class="nc">&nbsp;                    if ((location == Mech.LOC_LLEG)</b>
&nbsp;                        || (location == Mech.LOC_RLEG)) {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                case LosEffects.COVER_FULL:
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                case LosEffects.COVER_75LEFT:
<b class="nc">&nbsp;                    if ((location == Mech.LOC_RARM)</b>
&nbsp;                        || (location == Mech.LOC_RLEG)) {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                case LosEffects.COVER_75RIGHT:
<b class="nc">&nbsp;                    if ((location == Mech.LOC_LLEG)</b>
&nbsp;                        || (location == Mech.LOC_LARM)) {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public abstract boolean doomedInExtremeTemp();
&nbsp;
&nbsp;    public abstract boolean doomedInVacuum();
&nbsp;
&nbsp;    public abstract boolean doomedOnGround();
&nbsp;
&nbsp;    public abstract boolean doomedInAtmosphere();
&nbsp;
&nbsp;    public abstract boolean doomedInSpace();
&nbsp;
&nbsp;    /**
&nbsp;     * Prior to TacOps errata 3.3, armor was rounded up to the nearest half ton
&nbsp;     * As of TacOps errata 3.3, patchwork armor is not rounded by location. Previous editions
&nbsp;     * of the rules required it to be rounded up to the nearest half ton by location.
&nbsp;     * Note:
&nbsp;     * Unless overridden, this should &lt;em&gt;only&lt;/em&gt; be called on units with
&nbsp;     * patchwork armor, as rounding behavior is not guaranteed to be correct or
&nbsp;     * even the same for others and units with a single overall armor type have
&nbsp;     * no real reason to specifically care about weight per location anyway.
&nbsp;     *
&nbsp;     * @param loc The code value for the location in question (unit
&nbsp;     *            type-specific).
&nbsp;     * @return The weight of the armor in the location in tons.
&nbsp;     */
&nbsp;    public double getArmorWeight(int loc) {
<b class="nc">&nbsp;        double armorPerTon = 16.0 * EquipmentType.getArmorPointMultiplier(</b>
&nbsp;                armorType[loc], armorTechLevel[loc]);
<b class="nc">&nbsp;        double points = getOArmor(loc)</b>
<b class="nc">&nbsp;                        + (hasRearArmor(loc) ? getOArmor(loc, true) : 0);</b>
<b class="nc">&nbsp;        return points / armorPerTon;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The total weight of the armor on this unit. This is guaranteed to be
&nbsp;     * rounded properly for both single-type and patchwork armor.
&nbsp;     *
&nbsp;     * @return The armor weight in tons.
&nbsp;     */
&nbsp;    public double getArmorWeight() {
<b class="fc">&nbsp;        if (hasPatchworkArmor()) {</b>
<b class="nc">&nbsp;            double total = 0;</b>
<b class="nc">&nbsp;            for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;                total += getArmorWeight(loc);</b>
&nbsp;            }
<b class="nc">&nbsp;            return RoundWeight.standard(total, this);</b>
<b class="fc">&nbsp;        } else if (isSupportVehicle()</b>
<b class="nc">&nbsp;                    &amp;&amp; getArmorType(firstArmorIndex()) == EquipmentType.T_ARMOR_STANDARD) {</b>
<b class="nc">&nbsp;            double total = getTotalOArmor()</b>
<b class="nc">&nbsp;                    * EquipmentType.getSupportVehicleArmorWeightPerPoint(getBARRating(firstArmorIndex()), getArmorTechRating());</b>
<b class="nc">&nbsp;            return RoundWeight.standard(total, this);</b>
&nbsp;        } else {
&nbsp;            // this roundabout method is actually necessary to avoid rounding
&nbsp;            // weirdness. Yeah, it&#39;s dumb.
<b class="fc">&nbsp;            double armorPerTon = 16.0 * EquipmentType.getArmorPointMultiplier(</b>
&nbsp;                    armorType[0], armorTechLevel[0]);
<b class="fc">&nbsp;            return RoundWeight.standard(getTotalOArmor() / armorPerTon, this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasTAG() {
<b class="nc">&nbsp;        for (Mounted m : getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType equip = (WeaponType) (m.getType());</b>
<b class="nc">&nbsp;            if ((equip != null) &amp;&amp; (equip.hasFlag(WeaponType.F_TAG))) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCanon() {
<b class="nc">&nbsp;        return canon;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCanon(boolean canon) {
<b class="fc">&nbsp;        this.canon = canon;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get the entity&#39;s &quot;climbing mode&quot;
&nbsp;     * @return True or false, where true = climb up and false = go through
&nbsp;     */
&nbsp;    public boolean climbMode() {
<b class="nc">&nbsp;        return climbMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setClimbMode(boolean state) {
<b class="fc">&nbsp;        climbMode = state;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean usedTag() {
<b class="nc">&nbsp;        for (Mounted weapon : getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;            if (weapon.isUsedThisRound() &amp;&amp; wtype.hasFlag(WeaponType.F_TAG)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasEiCockpit() {
<b class="nc">&nbsp;        return ((game != null) &amp;&amp; game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVANCED_ALL_HAVE_EI_COCKPIT));
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasActiveEiCockpit() {
<b class="nc">&nbsp;        return (hasEiCockpit() &amp;&amp; hasAbility(OptionsConstants.UNOFF_EI_IMPLANT));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isLayingMines() {
<b class="nc">&nbsp;        return layingMines;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLayingMines(boolean laying) {
<b class="fc">&nbsp;        layingMines = laying;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean canLayMine() {
<b class="nc">&nbsp;        for (Object oMount : miscList) {</b>
<b class="nc">&nbsp;            Mounted mount = (Mounted) oMount;</b>
<b class="nc">&nbsp;            EquipmentType type = mount.getType();</b>
<b class="nc">&nbsp;            if (!mount.isMissing()</b>
<b class="nc">&nbsp;                &amp;&amp; (type.hasFlag(MiscType.F_MINE) || type</b>
<b class="nc">&nbsp;                    .hasFlag(MiscType.F_VEHICLE_MINE_DISPENSER))</b>
<b class="nc">&nbsp;                &amp;&amp; !isLayingMines()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int sideTable(Coords src) {
<b class="nc">&nbsp;        return sideTable(src, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int sideTable(Coords src, boolean usePrior) {
<b class="nc">&nbsp;        return sideTable(src, usePrior, facing);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int sideTable(Coords src, boolean usePrior, int face) {
<b class="nc">&nbsp;        return sideTable(src, usePrior, face, getPosition());</b>
&nbsp;    }
&nbsp;
&nbsp;    public int sideTable(Coords src, boolean usePrior, int face,
&nbsp;                         Coords effectivePos) {
<b class="nc">&nbsp;        if (usePrior) {</b>
<b class="nc">&nbsp;            effectivePos = getPriorPosition();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (src.equals(effectivePos)) {</b>
&nbsp;            // most places handle 0 range explicitly,
&nbsp;            // this is a safe default (calculation gives SIDE_RIGHT)
<b class="nc">&nbsp;            return ToHitData.SIDE_FRONT;</b>
&nbsp;        }
&nbsp;
&nbsp;        // calculate firing angle
<b class="nc">&nbsp;        int fa = (effectivePos.degree(src) + ((6 - face) * 60)) % 360;</b>
&nbsp;
<b class="nc">&nbsp;        int leftBetter = 2;</b>
&nbsp;        // if we&#39;re right on the line, we need to special case this
&nbsp;        // defender would choose along which hex the LOS gets drawn, and that
&nbsp;        // side also determines the side we hit in
<b class="nc">&nbsp;        if ((fa % 30) == 0) {</b>
<b class="nc">&nbsp;            IHex srcHex = game.getBoard().getHex(src);</b>
<b class="nc">&nbsp;            IHex curHex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;            if ((srcHex != null) &amp;&amp; (curHex != null)) {</b>
<b class="nc">&nbsp;                LosEffects.AttackInfo ai = LosEffects.buildAttackInfo(src,</b>
<b class="nc">&nbsp;                                                                      getPosition(), 1, getElevation(), srcHex.floor(),</b>
<b class="nc">&nbsp;                                                                      curHex.floor());</b>
<b class="nc">&nbsp;                ArrayList&lt;Coords&gt; in = Coords.intervening(ai.attackPos,</b>
&nbsp;                                                          ai.targetPos, true);
<b class="nc">&nbsp;                leftBetter = LosEffects.dividedLeftBetter(in, game, ai,</b>
<b class="nc">&nbsp;                                                          Compute.isInBuilding(game, this), new LosEffects());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean targetIsTank = (this instanceof Tank)</b>
<b class="nc">&nbsp;                               || (game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS) &amp;&amp; (this instanceof QuadMech));
<b class="nc">&nbsp;        if (targetIsTank) {</b>
<b class="nc">&nbsp;            if ((leftBetter == 1) &amp;&amp; (fa == 150)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;            } else if ((leftBetter == 1) &amp;&amp; (fa == 30)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;            } else if ((leftBetter == 0) &amp;&amp; (fa == 330)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;            } else if ((leftBetter == 0) &amp;&amp; (fa == 210)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;            } else if ((fa &gt; 30) &amp;&amp; (fa &lt;= 150)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;            } else if ((fa &gt; 150) &amp;&amp; (fa &lt; 210)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;            } else if ((fa &gt;= 210) &amp;&amp; (fa &lt; 330)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return ToHitData.SIDE_FRONT;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (isAero()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) this;</b>
&nbsp;            // Handle spheroids in atmosphere or on the ground differently
<b class="nc">&nbsp;            if (a.isSpheroid() &amp;&amp; (game != null) &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                if ((fa &gt;= 0) &amp;&amp; (fa &lt; 180)) {</b>
<b class="nc">&nbsp;                    return ToHitData.SIDE_RIGHT;</b>
&nbsp;                }
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((leftBetter == 1) &amp;&amp; (fa == 150)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;            } else if ((leftBetter == 1) &amp;&amp; (fa == 30)) {</b>
<b class="nc">&nbsp;                if (a.isRolled()) {</b>
<b class="nc">&nbsp;                    return ToHitData.SIDE_LEFT;</b>
&nbsp;                }
<b class="nc">&nbsp;                return ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;            } else if ((leftBetter == 0) &amp;&amp; (fa == 330)) {</b>
<b class="nc">&nbsp;                if (a.isRolled()) {</b>
<b class="nc">&nbsp;                    return ToHitData.SIDE_RIGHT;</b>
&nbsp;                }
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;            } else if ((leftBetter == 0) &amp;&amp; (fa == 210)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;            } else if ((fa &gt; 30) &amp;&amp; (fa &lt;= 150)) {</b>
<b class="nc">&nbsp;                if (a.isRolled()) {</b>
<b class="nc">&nbsp;                    return ToHitData.SIDE_LEFT;</b>
&nbsp;                }
<b class="nc">&nbsp;                return ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;            } else if ((fa &gt; 150) &amp;&amp; (fa &lt; 210)) {</b>
<b class="nc">&nbsp;                return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;            } else if ((fa &gt;= 210) &amp;&amp; (fa &lt; 330)) {</b>
<b class="nc">&nbsp;                if (a.isRolled()) {</b>
<b class="nc">&nbsp;                    return ToHitData.SIDE_RIGHT;</b>
&nbsp;                }
<b class="nc">&nbsp;                return ToHitData.SIDE_LEFT;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return ToHitData.SIDE_FRONT;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((fa == 90) &amp;&amp; (leftBetter == 1)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;        } else if (((fa == 150) &amp;&amp; (leftBetter == 1))</b>
&nbsp;                   || ((leftBetter == 0) &amp;&amp; (fa == 210))) {
<b class="nc">&nbsp;            return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;        } else if ((leftBetter == 0) &amp;&amp; (fa == 270)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_LEFT;</b>
<b class="nc">&nbsp;        } else if ((fa &gt; 90) &amp;&amp; (fa &lt;= 150)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_RIGHT;</b>
<b class="nc">&nbsp;        } else if ((fa &gt; 150) &amp;&amp; (fa &lt; 210)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_REAR;</b>
<b class="nc">&nbsp;        } else if ((fa &gt;= 210) &amp;&amp; (fa &lt; 270)) {</b>
<b class="nc">&nbsp;            return ToHitData.SIDE_LEFT;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return ToHitData.SIDE_FRONT;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to determine if an entity is currently capable of going hull-down.
&nbsp;     * Note, this is *not* whether the entity can ever go hull-down.
&nbsp;     *
&nbsp;     * @return True if the entity is able to go hull-down, else false.
&nbsp;     */
&nbsp;    public boolean canGoHullDown() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean canAssaultDrop() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setAssaultDropInProgress(boolean flag) {
<b class="nc">&nbsp;        assaultDropInProgress = flag ? 1 : 0;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setLandedAssaultDrop() {
<b class="nc">&nbsp;        assaultDropInProgress = 2;</b>
<b class="nc">&nbsp;        moved = EntityMovementType.MOVE_JUMP;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isAssaultDropInProgress() {
<b class="nc">&nbsp;        return assaultDropInProgress != 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Apply PSR modifier for difficult terrain at the specified coordinates
&nbsp;     *
&nbsp;     * @param roll the PSR to modify
&nbsp;     * @param c    the coordinates where the PSR happens
&nbsp;     */
&nbsp;    public void addPilotingModifierForTerrain(PilotingRollData roll, Coords c) {
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, c, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply PSR modifier for difficult terrain at the specified coordinates
&nbsp;     *
&nbsp;     * @param roll the PSR to modify
&nbsp;     * @param c    the coordinates where the PSR happens
&nbsp;     * @param enteringRubble True if entering rubble, else false
&nbsp;     */
&nbsp;    public void addPilotingModifierForTerrain(PilotingRollData roll, Coords c,
&nbsp;            boolean enteringRubble) {
<b class="nc">&nbsp;        if ((c == null) || (roll == null)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isOffBoard() || !(isDeployed())) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(c);</b>
<b class="nc">&nbsp;        hex.terrainPilotingModifier(getMovementMode(), roll, enteringRubble);</b>
&nbsp;
<b class="nc">&nbsp;        if (hex.containsTerrain(Terrains.JUNGLE) &amp;&amp; hasAbility(OptionsConstants.PILOT_TM_FOREST_RANGER)) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;Forest Ranger&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply PSR modifier for difficult terrain at the move step position
&nbsp;     *
&nbsp;     * @param roll the PSR to modify
&nbsp;     * @param step the move step the PSR occurs at
&nbsp;     */
&nbsp;    public void addPilotingModifierForTerrain(PilotingRollData roll,
&nbsp;            MoveStep step) {
<b class="nc">&nbsp;        if (step.getElevation() &gt; 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, step.getPosition());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Apply PSR modifier for difficult terrain in the current position
&nbsp;     *
&nbsp;     * @param roll the PSR to modify
&nbsp;     */
&nbsp;    public void addPilotingModifierForTerrain(PilotingRollData roll) {
<b class="nc">&nbsp;        if (getElevation() &gt; 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        addPilotingModifierForTerrain(roll, getPosition());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * defensively check and correct elevation
&nbsp;     */
&nbsp;    public boolean fixElevation() {
<b class="nc">&nbsp;        if (!isDeployed() || isOffBoard()</b>
<b class="nc">&nbsp;            || !game.getBoard().contains(getPosition())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!isElevationValid(getElevation(),</b>
<b class="nc">&nbsp;                              game.getBoard().getHex(getPosition()))) {</b>
<b class="nc">&nbsp;            System.err.println(getDisplayName() + &quot; in hex &quot;</b>
<b class="nc">&nbsp;                               + HexTarget.coordsToId(getPosition())</b>
<b class="nc">&nbsp;                               + &quot; is at invalid elevation: &quot; + getElevation());</b>
<b class="nc">&nbsp;            setElevation(0 - game.getBoard()</b>
<b class="nc">&nbsp;                                 .getHex(getPosition()).depth());</b>
<b class="nc">&nbsp;            System.err.println(&quot;   moved to elevation &quot; + getElevation());</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Engine getEngine() {
<b class="fc">&nbsp;        return engine;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasEngine() {
<b class="fc">&nbsp;        return (null != engine);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setEngine(Engine e) {
<b class="fc">&nbsp;        engine = e;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean itemOppositeTech(String s) {
<b class="nc">&nbsp;        if (isClan()) { // Clan base</b>
<b class="nc">&nbsp;            if ((s.toLowerCase().indexOf(&quot;(is)&quot;) != -1)</b>
<b class="nc">&nbsp;                || (s.toLowerCase().indexOf(&quot;inner sphere&quot;) != -1)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((s.toLowerCase().indexOf(&quot;(c)&quot;) != -1)</b>
<b class="nc">&nbsp;            || (s.toLowerCase().indexOf(&quot;clan&quot;) != -1)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return Returns the retreatedDirection.
&nbsp;     */
&nbsp;    public OffBoardDirection getRetreatedDirection() {
<b class="nc">&nbsp;        return retreatedDirection;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param retreatedDirection The retreatedDirection to set.
&nbsp;     */
&nbsp;    public void setRetreatedDirection(OffBoardDirection retreatedDirection) {
<b class="nc">&nbsp;        this.retreatedDirection = retreatedDirection;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setLastTarget(int id) {
<b class="nc">&nbsp;        lastTarget = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getLastTarget() {
<b class="nc">&nbsp;        return lastTarget;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLastTargetDisplayName(String name) {
<b class="nc">&nbsp;        lastTargetDisplayName = name;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getLastTargetDisplayName() {
<b class="nc">&nbsp;        return lastTargetDisplayName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @returns whether or not the unit is suffering from Electromagnetic
&nbsp;     * Interference
&nbsp;     */
&nbsp;    public boolean isSufferingEMI() {
<b class="nc">&nbsp;        return _isEMId;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setEMI(boolean inVal) {
<b class="nc">&nbsp;        _isEMId = inVal;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The attack direction modifier for rolls on the motive system hits table
&nbsp;     * for the given side (as defined in {@link ToHitData}). This will return 0
&nbsp;     * if Tactical Operations vehicle effectiveness rules are in effect or if
&nbsp;     * the side parameter falls outside ToHitData&#39;s range of &quot;fixed&quot; side
&nbsp;     * values; in particular, it will return 0 if handed
&nbsp;     * {@link ToHitData#SIDE_RANDOM}.
&nbsp;     *
&nbsp;     * @param side
&nbsp;     *            The attack direction as specified above.
&nbsp;     * @return The appropriate directional roll modifier.
&nbsp;     */
&nbsp;    public int getMotiveSideMod(int side) {
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_VEHICLE_EFFECTIVE)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (side) {</b>
&nbsp;            case ToHitData.SIDE_LEFT:
&nbsp;            case ToHitData.SIDE_RIGHT:
&nbsp;            case ToHitData.SIDE_FRONTLEFT:
&nbsp;            case ToHitData.SIDE_FRONTRIGHT:
&nbsp;            case ToHitData.SIDE_REARLEFT:
&nbsp;            case ToHitData.SIDE_REARRIGHT:
<b class="nc">&nbsp;                return 2;</b>
&nbsp;            case ToHitData.SIDE_REAR:
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the unit is hardened agaist nuclear strikes.
&nbsp;     *
&nbsp;     * @return true if this is a hardened unit.
&nbsp;     */
&nbsp;    public abstract boolean isNuclearHardened();
&nbsp;
&nbsp;    /**
&nbsp;     * Set the isHidden state of this entity (used for hidden units rules, TW
&nbsp;     * pg 259).
&nbsp;     * @param inVal
&nbsp;     */
&nbsp;    public void setHidden(boolean inVal) {
<b class="nc">&nbsp;        isHidden = inVal;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setMadePointblankShot(boolean inVal) {
<b class="fc">&nbsp;        madePointblankShot = inVal;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set a phase for this hidden unit to become active in.
&nbsp;     *
&nbsp;     * @param phase
&nbsp;     */
&nbsp;    public void setHiddeActivationPhase(IGame.Phase phase) {
<b class="nc">&nbsp;        hiddenActivationPhase = phase;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this unit is currently hidden (hidden units, TW pg 259).
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isHidden() {
<b class="nc">&nbsp;        return isHidden;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this unit has already made a pointblank shot this round.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean madePointblankShot() {
<b class="nc">&nbsp;        return madePointblankShot;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this unit should be considering a hidden unit that is
&nbsp;     * activating.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isHiddenActivating() {
<b class="nc">&nbsp;        return getHiddenActivationPhase() != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the phase that this hidden unit will activate in (generally this
&nbsp;     * will be null, indicating that the unit isn&#39;t activating).
&nbsp;     * @return
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    public IGame.Phase getHiddenActivationPhase() {
<b class="nc">&nbsp;        return hiddenActivationPhase;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this unit a carcass, a carcass can take no action
&nbsp;     */
&nbsp;    public boolean isCarcass() {
<b class="nc">&nbsp;        return carcass;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets if this unit is a carcass.
&nbsp;     *
&nbsp;     * @param carcass true if this unit should be a carcass, false otherwise.
&nbsp;     * @see megamek.common.Entity#isCarcass
&nbsp;     */
&nbsp;    public void setCarcass(boolean carcass) {
<b class="nc">&nbsp;        this.carcass = carcass;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Marks all equipment in a location on this entity as destroyed.
&nbsp;     *
&nbsp;     * @param loc The location that is destroyed.
&nbsp;     */
&nbsp;
&nbsp;    public void destroyLocation(int loc) {
<b class="nc">&nbsp;        destroyLocation(loc, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Marks all equipment in a location on this entity as destroyed.
&nbsp;     *
&nbsp;     * @param loc      The location that is destroyed.
&nbsp;     * @param blownOff true if the location was blown off
&nbsp;     */
&nbsp;    public void destroyLocation(int loc, boolean blownOff) {
&nbsp;        // if it&#39;s already marked as destroyed, don&#39;t bother
<b class="nc">&nbsp;        if (getInternal(loc) &lt; 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (blownOff) {</b>
<b class="nc">&nbsp;            setLocationBlownOff(loc, true);</b>
<b class="nc">&nbsp;            setLocationBlownOffThisPhase(loc, true);</b>
&nbsp;        } else {
&nbsp;            // mark armor, internal as doomed
<b class="nc">&nbsp;            setArmor(IArmorState.ARMOR_DOOMED, loc, false);</b>
<b class="nc">&nbsp;            setInternal(IArmorState.ARMOR_DOOMED, loc);</b>
<b class="nc">&nbsp;            if (hasRearArmor(loc)) {</b>
<b class="nc">&nbsp;                setArmor(IArmorState.ARMOR_DOOMED, loc, true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // all critical slots set as missing
&nbsp;        // while we&#39;re here, if something is mounted in those crits, set it as hit, 
&nbsp;        // instead of looping through all equipment in the unit
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            final CriticalSlot cs = getCritical(loc, i);</b>
<b class="nc">&nbsp;            if (cs != null) {</b>
&nbsp;                // count engine hits for maxtech engine explosions
<b class="nc">&nbsp;                if ((cs.getType() == CriticalSlot.TYPE_SYSTEM)</b>
<b class="nc">&nbsp;                    &amp;&amp; (cs.getIndex() == Mech.SYSTEM_ENGINE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !cs.isDamaged()) {</b>
<b class="nc">&nbsp;                    engineHitsThisPhase++;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                final boolean mountOneIsHittable = (cs.getMount() != null) &amp;&amp; cs.getMount().getType().isHittable();</b>
<b class="nc">&nbsp;                final boolean mountTwoIsHittable = (cs.getMount2() != null) &amp;&amp; cs.getMount2().getType().isHittable();</b>
&nbsp;                
<b class="nc">&nbsp;                if (blownOff) {</b>
<b class="nc">&nbsp;                    cs.setMissing(true);</b>
&nbsp;                    
<b class="nc">&nbsp;                    if (mountOneIsHittable) {</b>
<b class="nc">&nbsp;                        cs.getMount().setMissing(true);</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if (mountTwoIsHittable) {</b>
<b class="nc">&nbsp;                        cs.getMount2().setMissing(true);</b>
&nbsp;                    }
&nbsp;                    
&nbsp;                } else {
<b class="nc">&nbsp;                    cs.setHit(true);</b>
&nbsp;                    
<b class="nc">&nbsp;                    if (mountOneIsHittable) {</b>
<b class="nc">&nbsp;                        cs.getMount().setHit(true);</b>
&nbsp;                    }
&nbsp;                    
<b class="nc">&nbsp;                    if (mountTwoIsHittable) {</b>
<b class="nc">&nbsp;                        cs.getMount2().setHit(true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // dependent locations destroyed, unless they are already destroyed
<b class="nc">&nbsp;        if ((getDependentLocation(loc) != Entity.LOC_NONE)</b>
<b class="nc">&nbsp;            &amp;&amp; !(getInternal(getDependentLocation(loc)) &lt; 0)) {</b>
<b class="nc">&nbsp;            destroyLocation(getDependentLocation(loc), true);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Iterates over all Narc and iNarc pods attached to this entity and removes
&nbsp;     * those still &#39;stuck&#39; to destroyed or missing locations.
&nbsp;     */
&nbsp;    public void clearDestroyedNarcPods() {
<b class="nc">&nbsp;        for (Iterator&lt;NarcPod&gt; i = pendingNarcPods.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            if (!locationCanHoldNarcPod(i.next().getLocation())) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (Iterator&lt;NarcPod&gt; i = narcPods.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            if (!locationCanHoldNarcPod(i.next().getLocation())) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (Iterator&lt;INarcPod&gt; i = pendingINarcPods.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            if (!locationCanHoldNarcPod(i.next().getLocation())) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (Iterator&lt;INarcPod&gt; i = iNarcPods.iterator(); i.hasNext(); ) {</b>
<b class="nc">&nbsp;            if (!locationCanHoldNarcPod(i.next().getLocation())) {</b>
<b class="nc">&nbsp;                i.remove();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private boolean locationCanHoldNarcPod(int location) {
<b class="nc">&nbsp;        return (getInternal(location) &gt; 0)</b>
<b class="nc">&nbsp;               &amp;&amp; !isLocationBlownOff(location)</b>
<b class="nc">&nbsp;               &amp;&amp; !isLocationBlownOffThisPhase(location);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PilotingRollData checkSideSlip(EntityMovementType moveType,
&nbsp;                                          IHex prevHex, EntityMovementType overallMoveType,
&nbsp;                                          MoveStep prevStep, int prevFacing, int curFacing, Coords lastPos,
&nbsp;                                          Coords curPos, int distance) {
<b class="nc">&nbsp;        PilotingRollData roll = getBasePilotingRoll(overallMoveType);</b>
&nbsp;
<b class="nc">&nbsp;        if ((moveType != EntityMovementType.MOVE_JUMP)</b>
&nbsp;                &amp;&amp; (prevHex != null)
&nbsp;                &amp;&amp; (distance &gt; 1)
&nbsp;                &amp;&amp; ((overallMoveType == EntityMovementType.MOVE_RUN)
&nbsp;                        || (overallMoveType == EntityMovementType.MOVE_VTOL_RUN)
&nbsp;                        || (overallMoveType == EntityMovementType.MOVE_SPRINT)
&nbsp;                        || (overallMoveType == EntityMovementType.MOVE_VTOL_SPRINT))
<b class="nc">&nbsp;                &amp;&amp; (prevFacing != curFacing) &amp;&amp; !lastPos.equals(curPos)</b>
&nbsp;                &amp;&amp; !(this instanceof Infantry)
&nbsp;                &amp;&amp; !(this instanceof Protomech)) {
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0, &quot;flanking and turning&quot;));</b>
<b class="nc">&nbsp;            if (isUsingManAce()) {</b>
<b class="nc">&nbsp;                roll.addModifier(-1, &quot;Maneuvering Ace&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((getMovementMode() == EntityMovementMode.VTOL) &amp;&amp; isMASCUsed()</b>
<b class="nc">&nbsp;                    &amp;&amp; hasWorkingMisc(MiscType.F_JET_BOOSTER)) {</b>
<b class="nc">&nbsp;                roll.addModifier(3, &quot;used VTOL Jet Booster&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (moveType != EntityMovementType.MOVE_JUMP</b>
<b class="nc">&nbsp;                &amp;&amp; prevFacing == curFacing &amp;&amp; !lastPos.equals(curPos)</b>
<b class="nc">&nbsp;                &amp;&amp; lastPos.direction(curPos) % 3 != curFacing % 3</b>
<b class="nc">&nbsp;                &amp;&amp; !(isUsingManAce() &amp;&amp; (overallMoveType == EntityMovementType.MOVE_WALK</b>
&nbsp;                || overallMoveType == EntityMovementType.MOVE_VTOL_WALK))) {
<b class="nc">&nbsp;            roll.append(new PilotingRollData(getId(), 0, &quot;controlled sideslip&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll.addModifier(TargetRoll.CHECK_FALSE,</b>
&nbsp;                    &quot;Check false: not apparently sideslipping&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isAirborneVTOLorWIGE() {
&nbsp;        // stuff that moves like a VTOL is flying unless at elevation 0 or on
&nbsp;        // top of/in a building,
<b class="nc">&nbsp;        if ((getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                || (getMovementMode() == EntityMovementMode.WIGE)) {</b>
<b class="nc">&nbsp;            if ((game != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getBoard() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (getPosition() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getBoard().getHex(getPosition()) != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((game.getBoard().getHex(getPosition())</b>
<b class="nc">&nbsp;                            .terrainLevel(Terrains.BLDG_ELEV) &gt;= getElevation()) || (game</b>
<b class="nc">&nbsp;                            .getBoard().getHex(getPosition())</b>
<b class="nc">&nbsp;                            .terrainLevel(Terrains.BRIDGE_ELEV) &gt;= getElevation()))) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            return getElevation() &gt; 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSpotTargetId(int targetId) {
<b class="nc">&nbsp;        spotTargetId = targetId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getSpotTargetId() {
<b class="nc">&nbsp;        return spotTargetId;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCommander(boolean arg) {
<b class="nc">&nbsp;        isCommander = arg;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isCommander() {
<b class="nc">&nbsp;        return isCommander;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasLinkedMGA(Mounted mounted) {
<b class="fc">&nbsp;        for (Mounted m : getWeaponList()) {</b>
<b class="fc">&nbsp;            if ((m.getLocation() == mounted.getLocation())</b>
<b class="fc">&nbsp;                &amp;&amp; m.getType().hasFlag(WeaponType.F_MGA)</b>
<b class="fc">&nbsp;                &amp;&amp; !(m.isDestroyed() || m.isBreached())</b>
<b class="fc">&nbsp;                &amp;&amp; m.getBayWeapons().contains(getEquipmentNum(mounted))</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasModes() &amp;&amp; m.curMode().equals(&quot;Linked&quot;)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setReckless(boolean b) {
<b class="nc">&nbsp;        reckless = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isReckless() {
<b class="nc">&nbsp;        return reckless;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function to test whether an entity should be treated as an Aero unit (includes
&nbsp;     * LAMs in fighter mode)
&nbsp;     */
&nbsp;    public boolean isAero() {
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function to determine whether an entity is an aero unit but not Small Craft/
&nbsp;     * DropShip/JumpShip/WarShip.
&nbsp;     */
&nbsp;    public boolean isFighter() {
<b class="fc">&nbsp;        return isAero();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCapitalFighter() {
<b class="fc">&nbsp;        return isCapitalFighter(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCapitalFighter(boolean lounge) {
<b class="fc">&nbsp;        if (null == game) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we&#39;re using the unofficial option for single fighters staying
&nbsp;        // standard scale &amp; we&#39;re not a member of a squadron... then false.
<b class="fc">&nbsp;        if (!lounge &amp;&amp; isFighter()</b>
<b class="nc">&nbsp;            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_SINGLE_NO_CAP)</b>
<b class="nc">&nbsp;            &amp;&amp; !isPartOfFighterSquadron()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_CAPITAL_FIGHTER)</b>
<b class="nc">&nbsp;               &amp;&amp; isFighter();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * a function that let&#39;s us know if this entity has capital-scale armor
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isCapitalScale() {
&nbsp;
<b class="nc">&nbsp;        if ((this instanceof Jumpship) || (this instanceof FighterSquadron)</b>
<b class="nc">&nbsp;            || isCapitalFighter()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * a function that let&#39;s us know if this entity is using weapons bays
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean usesWeaponBays() {
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return the bay of the current weapon
&nbsp;     *
&nbsp;     * @param bayID
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Mounted whichBay(int bayID) {
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getWeaponBayList()) {</b>
<b class="nc">&nbsp;            for (int wId : m.getBayWeapons()) {</b>
&nbsp;                // find the weapon and determine if it is there
<b class="nc">&nbsp;                if (wId == bayID) {</b>
<b class="nc">&nbsp;                    return m;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return the first bay of the right type in the right location with enough
&nbsp;     * damage to spare
&nbsp;     *
&nbsp;     * @param wtype
&nbsp;     * @param loc
&nbsp;     * @param rearMount
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Mounted getFirstBay(WeaponType wtype, int loc, boolean rearMount) {
&nbsp;
<b class="nc">&nbsp;        int weapDamage = wtype.getRoundShortAV();</b>
<b class="nc">&nbsp;        if (wtype.isCapital()) {</b>
<b class="nc">&nbsp;            weapDamage *= 10;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getWeaponBayList()) {</b>
<b class="nc">&nbsp;            BayWeapon bay = (BayWeapon) m.getType();</b>
<b class="nc">&nbsp;            int damage = bay.getRoundShortAV() + weapDamage;</b>
<b class="nc">&nbsp;            if ((bay.getAtClass() == wtype.getAtClass())</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getLocation() == loc)</b>
<b class="nc">&nbsp;                &amp;&amp; (m.isRearMounted() == rearMount) &amp;&amp; (damage &lt;= 700)) {</b>
<b class="nc">&nbsp;                return m;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getHeatInArc(int location, boolean rearMount) {
&nbsp;
<b class="nc">&nbsp;        int arcHeat = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted mounted : getTotalWeaponList()) {</b>
&nbsp;            // is the weapon usable?
<b class="nc">&nbsp;            if (mounted.isDestroyed() || mounted.isJammed()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((mounted.getLocation() == location)</b>
<b class="nc">&nbsp;                &amp;&amp; (mounted.isRearMounted() == rearMount)) {</b>
<b class="nc">&nbsp;                arcHeat += mounted.getCurrentHeat();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return arcHeat;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int[] getVectors() {
<b class="nc">&nbsp;        return vectors;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setVectors(int[] v) {
<b class="nc">&nbsp;        if ((v == null) || (v.length != 6)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        vectors = v;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getVector(int vectorFacing) {
<b class="nc">&nbsp;        if (vectorFacing &lt; 6) {</b>
<b class="nc">&nbsp;            return vectors[vectorFacing];</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getVelocity() {
&nbsp;
<b class="nc">&nbsp;        int total = 0;</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            total += getVector(dir);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return total;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int chooseSide(Coords attackPos, boolean usePrior) {
&nbsp;        // loop through directions and if we have a non-zero vector, then
&nbsp;        // compute
&nbsp;        // the targetsidetable. If we come to a higher vector, then replace. If
&nbsp;        // we come to an equal vector then take it if it is better
<b class="nc">&nbsp;        int thrust = 0;</b>
<b class="nc">&nbsp;        int high = -1;</b>
<b class="nc">&nbsp;        int side = -1;</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            thrust = getVector(dir);</b>
<b class="nc">&nbsp;            if (thrust == 0) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (thrust &gt; high) {</b>
<b class="nc">&nbsp;                high = thrust;</b>
<b class="nc">&nbsp;                side = sideTable(attackPos, usePrior, dir);</b>
&nbsp;            }
&nbsp;
&nbsp;            // what if they tie
<b class="nc">&nbsp;            if (thrust == high) {</b>
<b class="nc">&nbsp;                int newside = sideTable(attackPos, usePrior, dir);</b>
&nbsp;                // choose the best
<b class="nc">&nbsp;                if ((newside == ToHitData.SIDE_LEFT)</b>
&nbsp;                    || (newside == ToHitData.SIDE_RIGHT)) {
<b class="nc">&nbsp;                    newside = side;</b>
&nbsp;                }
&nbsp;                // that should be the only case, because it can&#39;t shift you from
&nbsp;                // front
&nbsp;                // to aft or vice-versa
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        return side;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * return the heading of the unit based on its active vectors if vectors are
&nbsp;     * tied then return two headings
&nbsp;     */
&nbsp;    public Vector&lt;Integer&gt; getHeading() {
&nbsp;
<b class="nc">&nbsp;        Vector&lt;Integer&gt; heading = new Vector&lt;Integer&gt;();</b>
<b class="nc">&nbsp;        int high = 0;</b>
<b class="nc">&nbsp;        int curDir = getFacing();</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            int thrust = getVector(dir);</b>
<b class="nc">&nbsp;            if ((thrust &gt;= high) &amp;&amp; (thrust &gt; 0)) {</b>
&nbsp;                // if they were equal then add the last direction to the
&nbsp;                // vector before moving on
<b class="nc">&nbsp;                if (thrust == high) {</b>
<b class="nc">&nbsp;                    heading.addElement(curDir);</b>
&nbsp;                }
<b class="nc">&nbsp;                high = getVector(dir);</b>
<b class="nc">&nbsp;                curDir = dir;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        heading.addElement(curDir);</b>
<b class="nc">&nbsp;        return heading;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPlayerPickedPassThrough(int attackerId, Coords c) {
<b class="nc">&nbsp;        if (playerPickedPassThrough == null) {</b>
<b class="nc">&nbsp;            playerPickedPassThrough = new HashMap&lt;&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        playerPickedPassThrough.put(attackerId, c);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public @Nullable Coords getPlayerPickedPassThrough(int attackerId) {
<b class="nc">&nbsp;        if (playerPickedPassThrough == null) {</b>
<b class="nc">&nbsp;            playerPickedPassThrough = new HashMap&lt;&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        return playerPickedPassThrough.get(attackerId);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPassedThrough(Vector&lt;Coords&gt; pass) {
<b class="fc">&nbsp;        passedThrough = pass;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Vector&lt;Coords&gt; getPassedThrough() {
<b class="nc">&nbsp;        return passedThrough;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPassedThroughFacing(List&lt;Integer&gt; passFacing) {
<b class="fc">&nbsp;        passedThroughFacing = passFacing;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public List&lt;Integer&gt; getPassedThroughFacing() {
<b class="nc">&nbsp;        return passedThroughFacing;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addPassedThrough(Coords c) {
<b class="nc">&nbsp;        passedThrough.add(c);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Method that determines if this Entity passed over another entity during
&nbsp;     * its current path
&nbsp;     *
&nbsp;     * @param t
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean passedOver(Targetable t) {
<b class="nc">&nbsp;        for (Coords crd : passedThrough) {</b>
<b class="nc">&nbsp;            if (crd.equals(t.getPosition())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Coords secondary : t.getSecondaryPositions().values()) {</b>
<b class="nc">&nbsp;                if (crd.equals(secondary)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean passedThrough(Coords c) {
<b class="nc">&nbsp;        for (Coords crd : passedThrough) {</b>
<b class="nc">&nbsp;            if (crd.equals(c)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Did the entity pass within a certain number of hexes of these coords?
&nbsp;     */
&nbsp;    public boolean passedWithin(Coords c, int dist) {
<b class="nc">&nbsp;        for (Coords crd : passedThrough) {</b>
<b class="nc">&nbsp;            if (crd.distance(c) &lt;= dist) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * What coords were passed through previous to the given one
&nbsp;     */
&nbsp;    public Coords passedThroughPrevious(Coords c) {
<b class="nc">&nbsp;        if (passedThrough.size() == 0) {</b>
<b class="nc">&nbsp;            return getPosition();</b>
&nbsp;        }
<b class="nc">&nbsp;        Coords prevCrd = passedThrough.get(0);</b>
<b class="nc">&nbsp;        for (Coords crd : passedThrough) {</b>
<b class="nc">&nbsp;            if (crd.equals(c)) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            prevCrd = crd;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return prevCrd;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setRamming(boolean b) {
<b class="nc">&nbsp;        ramming = b;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isRamming() {
<b class="nc">&nbsp;        return ramming;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void resetFiringArcs() {
<b class="fc">&nbsp;        frontArcFired = new boolean[locations()];</b>
<b class="fc">&nbsp;        rearArcFired = new boolean[locations()];</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;            frontArcFired[i] = false;</b>
<b class="fc">&nbsp;            rearArcFired[i] = false;</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean hasArcFired(int location, boolean rearMount) {
<b class="nc">&nbsp;        if ((null == frontArcFired) || (null == rearArcFired)) {</b>
<b class="nc">&nbsp;            resetFiringArcs();</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((location &gt; locations()) || (location &lt; 0)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (rearMount) {</b>
<b class="nc">&nbsp;            return rearArcFired[location];</b>
&nbsp;        }
<b class="nc">&nbsp;        return frontArcFired[location];</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setArcFired(int location, boolean rearMount) {
<b class="nc">&nbsp;        if ((null == frontArcFired) || (null == rearArcFired)) {</b>
<b class="nc">&nbsp;            resetFiringArcs();</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((location &gt; locations()) || (location &lt; 0)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (rearMount) {</b>
<b class="nc">&nbsp;            rearArcFired[location] = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            frontArcFired[location] = true;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Force rapid fire mode to the highest level on RAC and UAC - this is for
&nbsp;     * aeros
&nbsp;     */
&nbsp;    public void setRapidFire() {
<b class="nc">&nbsp;        for (Mounted m : getTotalWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wtype = (WeaponType) m.getType();</b>
<b class="nc">&nbsp;            if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</b>
<b class="nc">&nbsp;                m.setMode(&quot;6-shot&quot;);</b>
<b class="nc">&nbsp;                m.setModeSwitchable(false);</b>
<b class="nc">&nbsp;            } else if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA) {</b>
<b class="nc">&nbsp;                m.setMode(&quot;Ultra&quot;);</b>
<b class="nc">&nbsp;                m.setModeSwitchable(false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Set the retractable blade in the given location as extended Takes the
&nbsp;     * first piece of appropriate equipment
&nbsp;     */
&nbsp;    public void extendBlade(int loc) {
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            if ((m.getLocation() == loc) &amp;&amp; !m.isDestroyed() &amp;&amp; !m.isBreached()</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_CLUB)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasSubType(MiscType.S_RETRACTABLE_BLADE)) {</b>
<b class="nc">&nbsp;                m.setMode(&quot;extended&quot;);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * destroys the first retractable blade critical slot found
&nbsp;     */
&nbsp;    public void destroyRetractableBlade(int loc) {
&nbsp;        // check critical slots
<b class="nc">&nbsp;        for (int i = 0; i &lt; this.getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot slot = getCritical(loc, i);</b>
&nbsp;            // ignore empty &amp; system slots
<b class="nc">&nbsp;            if ((slot == null)</b>
<b class="nc">&nbsp;                || (slot.getType() != CriticalSlot.TYPE_EQUIPMENT)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted m = slot.getMount();</b>
<b class="nc">&nbsp;            if ((m.getLocation() == loc) &amp;&amp; !m.isHit() &amp;&amp; !m.isBreached()</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasFlag(MiscType.F_CLUB)</b>
<b class="nc">&nbsp;                &amp;&amp; m.getType().hasSubType(MiscType.S_RETRACTABLE_BLADE)) {</b>
<b class="nc">&nbsp;                slot.setHit(true);</b>
<b class="nc">&nbsp;                m.setHit(true);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public TeleMissileTracker getTMTracker() {
<b class="nc">&nbsp;        return tmTracker;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setGrappled(int id, boolean attacker) {
&nbsp;        // This is implemented in subclasses.  Do nothing in general.
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isGrappleAttacker() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getGrappled() {
<b class="nc">&nbsp;        return Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isChainWhipGrappled() {
<b class="nc">&nbsp;        return getGrappleSide() != Entity.GRAPPLE_BOTH;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isGrappledThisRound() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setGrappledThisRound(boolean grappled) {
&nbsp;        // Do nothing here, set in base classes
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setGameOptions() {
&nbsp;
<b class="fc">&nbsp;        if (game == null) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final GameOptions gameOpts = game.getOptions();</b>
&nbsp;
&nbsp;        // if the small craft does not already have ECM, then give them a single
&nbsp;        // hex ECM so they can change the mode
&nbsp;        // FIXME: This is a really hacky way to to do it that results in small
&nbsp;        // craft having
&nbsp;        // ECM when the rule is not in effect and in non-space maps
<b class="fc">&nbsp;        if ((this instanceof SmallCraft) &amp;&amp; !(this instanceof Dropship)</b>
<b class="nc">&nbsp;            &amp;&amp; !hasActiveECM() &amp;&amp; isMilitary()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                String prefix = isClan() ? &quot;CL&quot; : &quot;IS&quot;;</b>
<b class="nc">&nbsp;                this.addEquipment(</b>
<b class="nc">&nbsp;                        EquipmentType.get(prefix + BattleArmor.SINGLE_HEX_ECM),</b>
&nbsp;                        Aero.LOC_NOSE, false);
<b class="nc">&nbsp;            } catch (LocationFullException ex) {</b>
&nbsp;                // ignore
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (Mounted mounted : getWeaponList()) {</b>
<b class="fc">&nbsp;            if (mounted.getType() instanceof Weapon)</b>
<b class="fc">&nbsp;                ((Weapon) mounted.getType()).adaptToGameOptions(game.getOptions());</b>
<b class="fc">&nbsp;                mounted.setModesForMapType();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for (Mounted misc : getMisc()) {</b>
<b class="fc">&nbsp;            if (misc.getType().hasFlag(MiscType.F_BAP)</b>
&nbsp;                &amp;&amp; (this instanceof Aero || this instanceof LandAirMech)
<b class="nc">&nbsp;                &amp;&amp; gameOpts.booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;                ArrayList&lt;String&gt; modes = new ArrayList&lt;String&gt;();</b>
<b class="nc">&nbsp;                String[] stringArray = {};</b>
<b class="nc">&nbsp;                modes.add(&quot;Short&quot;);</b>
<b class="nc">&nbsp;                modes.add(&quot;Medium&quot;);</b>
<b class="nc">&nbsp;                ((MiscType) misc.getType())</b>
<b class="nc">&nbsp;                        .setModes(modes.toArray(stringArray));</b>
<b class="nc">&nbsp;                ((MiscType) misc.getType()).setInstantModeSwitch(false);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (misc.getType().hasFlag(MiscType.F_ECM)) {</b>
<b class="fc">&nbsp;                ArrayList&lt;String&gt; modes = new ArrayList&lt;String&gt;();</b>
<b class="fc">&nbsp;                modes.add(&quot;ECM&quot;);</b>
<b class="fc">&nbsp;                String[] stringArray = {};</b>
<b class="fc">&nbsp;                if (gameOpts.booleanOption(OptionsConstants.ADVANCED_TACOPS_ECCM)) {</b>
<b class="fc">&nbsp;                    modes.add(&quot;ECCM&quot;);</b>
<b class="fc">&nbsp;                    if (misc.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="fc">&nbsp;                        modes.add(&quot;ECM &amp; ECCM&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (gameOpts.booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)</b>
&nbsp;                           &amp;&amp; (this instanceof Aero || this instanceof LandAirMech)) {
<b class="nc">&nbsp;                    modes.add(&quot;ECCM&quot;);</b>
<b class="nc">&nbsp;                    if (misc.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="nc">&nbsp;                        modes.add(&quot;ECM &amp; ECCM&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                if (gameOpts.booleanOption(OptionsConstants.ADVANCED_TACOPS_GHOST_TARGET)) {</b>
<b class="nc">&nbsp;                    if (misc.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="nc">&nbsp;                        modes.add(&quot;ECM &amp; Ghost Targets&quot;);</b>
<b class="nc">&nbsp;                        if (gameOpts.booleanOption(OptionsConstants.ADVANCED_TACOPS_ECCM)) {</b>
<b class="nc">&nbsp;                            modes.add(&quot;ECCM &amp; Ghost Targets&quot;);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        modes.add(&quot;Ghost Targets&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                ((MiscType) misc.getType())</b>
<b class="fc">&nbsp;                        .setModes(modes.toArray(stringArray));</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setGrappleSide(int side) {
&nbsp;        // This is implemented in subclasses, do nothing in general
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getGrappleSide() {
<b class="nc">&nbsp;        return Entity.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasFunctionalArmAES(int location) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasFunctionalLegAES() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEvading() {
<b class="nc">&nbsp;        return evading;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setEvading(boolean evasion) {
<b class="fc">&nbsp;        evading = evasion;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getEvasionBonus() {
<b class="nc">&nbsp;        if (isProne()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (this instanceof SmallCraft) {</b>
<b class="nc">&nbsp;            return 2;</b>
<b class="nc">&nbsp;        } else if (this instanceof Jumpship) {</b>
<b class="nc">&nbsp;            return 1;</b>
<b class="nc">&nbsp;        } else if (isAero()) {</b>
<b class="nc">&nbsp;            return 3;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_SKILLED_EVASION)) {</b>
<b class="nc">&nbsp;                int piloting = crew.getPiloting();</b>
<b class="nc">&nbsp;                if (piloting &lt; 2) {</b>
<b class="nc">&nbsp;                    return 3;</b>
<b class="nc">&nbsp;                } else if (piloting &lt; 4) {</b>
<b class="nc">&nbsp;                    return 2;</b>
<b class="nc">&nbsp;                } else if (piloting &lt; 6) {</b>
<b class="nc">&nbsp;                    return 1;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCarefulStand(boolean stand) {
<b class="nc">&nbsp;        isCarefulStanding = stand;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isCarefulStand() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Sensor&gt; getSensors() {
<b class="fc">&nbsp;        return sensors;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Sensor getActiveSensor() {
<b class="nc">&nbsp;        return activeSensor;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Sensor getNextSensor() {
<b class="nc">&nbsp;        return nextSensor;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setNextSensor(Sensor s) {
<b class="fc">&nbsp;        nextSensor = s;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getSensorCheck() {
<b class="nc">&nbsp;        return sensorCheck;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to determine if an aero has suffered 3 sensor hits.
&nbsp;     * When double-blind is on, this affects both standard visibility and sensor rolls
&nbsp;     */
&nbsp;    public boolean isAeroSensorDestroyed() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasModularArmor() {
<b class="fc">&nbsp;        return hasModularArmor(-1);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasModularArmor(int loc) {
<b class="fc">&nbsp;        for (Mounted mount : this.getEquipment()) {</b>
<b class="fc">&nbsp;            if ((loc == -1) || (mount.getLocation() == loc)) {</b>
<b class="fc">&nbsp;                if (!mount.isDestroyed()</b>
<b class="fc">&nbsp;                    &amp;&amp; (mount.getType() instanceof MiscType)</b>
<b class="fc">&nbsp;                    &amp;&amp; ((MiscType) mount.getType())</b>
<b class="fc">&nbsp;                        .hasFlag(MiscType.F_MODULAR_ARMOR)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getDamageReductionFromModularArmor(HitData hit, int damage,
&nbsp;                                                  Vector&lt;Report&gt; vDesc) {
<b class="nc">&nbsp;        int loc = hit.getLocation();</b>
<b class="nc">&nbsp;        if (!hasModularArmor(loc)) {</b>
<b class="nc">&nbsp;            return damage;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Mounted mount : this.getEquipment()) {</b>
<b class="nc">&nbsp;            if ((mount.getLocation() == loc)</b>
<b class="nc">&nbsp;                &amp;&amp; !mount.isDestroyed()</b>
<b class="nc">&nbsp;                &amp;&amp; (mount.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;                &amp;&amp; ((MiscType) mount.getType())</b>
<b class="nc">&nbsp;                    .hasFlag(MiscType.F_MODULAR_ARMOR)</b>
&nbsp;                // On &#39;Mech torsos only, modular armor covers either front
&nbsp;                // or rear, as mounted.
&nbsp;                &amp;&amp; (!(this instanceof Mech)
&nbsp;                    || !((loc == Mech.LOC_CT) || (loc == Mech.LOC_LT) || (loc == Mech.LOC_RT)) || (hit
<b class="nc">&nbsp;                                                                                                           .isRear()</b>
&nbsp;                                                                                                   == mount
<b class="nc">&nbsp;                    .isRearMounted()))) {</b>
&nbsp;
<b class="nc">&nbsp;                int damageAbsorption = mount.getBaseDamageCapacity()</b>
<b class="nc">&nbsp;                                       - mount.getDamageTaken();</b>
<b class="nc">&nbsp;                if (damageAbsorption &gt; damage) {</b>
<b class="nc">&nbsp;                    mount.damageTaken += damage;</b>
<b class="nc">&nbsp;                    Report r = new Report(3535);</b>
<b class="nc">&nbsp;                    r.subject = getId();</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    r.indent(1);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
&nbsp;
<b class="nc">&nbsp;                    return 0;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (damageAbsorption == damage) {</b>
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                    Report r = new Report(3535);</b>
<b class="nc">&nbsp;                    r.subject = getId();</b>
<b class="nc">&nbsp;                    r.add(damage);</b>
<b class="nc">&nbsp;                    r.indent(1);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    r = new Report(3536);</b>
<b class="nc">&nbsp;                    r.subject = getId();</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                    mount.damageTaken += damage;</b>
<b class="nc">&nbsp;                    mount.setHit(true);</b>
<b class="nc">&nbsp;                    return 0;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (damageAbsorption &lt; damage) {</b>
<b class="nc">&nbsp;                    Report.addNewline(vDesc);</b>
<b class="nc">&nbsp;                    Report r = new Report(3535);</b>
<b class="nc">&nbsp;                    r.subject = getId();</b>
<b class="nc">&nbsp;                    r.add(damageAbsorption);</b>
<b class="nc">&nbsp;                    r.indent(1);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    r = new Report(3536);</b>
<b class="nc">&nbsp;                    r.subject = getId();</b>
<b class="nc">&nbsp;                    r.indent(1);</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                    damage -= mount.baseDamageAbsorptionRate</b>
&nbsp;                              - mount.damageTaken;
<b class="nc">&nbsp;                    mount.damageTaken = mount.baseDamageAbsorptionRate;</b>
<b class="nc">&nbsp;                    mount.setDestroyed(true);</b>
<b class="nc">&nbsp;                    mount.setHit(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return damage;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getGhostTargetRoll() {
<b class="nc">&nbsp;        return ghostTargetRoll;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getGhostTargetRollMoS() {
<b class="nc">&nbsp;        return ghostTargetRoll - (getCrew().getSensorOps() + 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getGhostTargetOverride() {
<b class="nc">&nbsp;        return ghostTargetOverride;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getCoolantFailureAmount() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addCoolantFailureAmount(int amount) {
&nbsp;        // This is implemented in subclasses, do nothing in general
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void resetCoolantFailureAmount() {
&nbsp;        // This is implemented in subclasses, do nothing in general
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return the tonnage of additional mounted communications equipment
&nbsp;     */
&nbsp;    public int getExtraCommGearTons() {
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        for (Mounted mounted : miscList) {</b>
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(MiscType.F_COMMUNICATIONS)</b>
<b class="nc">&nbsp;                &amp;&amp; !mounted.isInoperable()) {</b>
<b class="nc">&nbsp;                i += mounted.getTonnage();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return i;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns information (range, location, strength) about ECM if the unit
&nbsp;     * has active ECM or null if it doesn&#39;t.  In the case of multiple ECCM
&nbsp;     * system, the best one takes precendence, as a unit can only have one
&nbsp;     * active ECCM at a time.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public ECMInfo getECMInfo() {
&nbsp;        // If we don&#39;t have a position, ECM doesn&#39;t have an effect
<b class="fc">&nbsp;        if ((getPosition() == null) || isShutDown() || isStealthOn()</b>
<b class="fc">&nbsp;            || (getTransportId() != Entity.NONE)) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // E(C)CM operates differently in space (SO pg 110)
<b class="fc">&nbsp;        if (game.getBoard().inSpace()) {</b>
&nbsp;            // No ECM in space unless SO rule is on
<b class="nc">&nbsp;            if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            int range = getECMRange();</b>
<b class="nc">&nbsp;            if ((range &gt;= 0) &amp;&amp; hasActiveECM()) {</b>
<b class="nc">&nbsp;                return new ECMInfo(range, 1, this);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // ASF ECM only has an effect if the unit is NOE
<b class="fc">&nbsp;        if (isAirborne() &amp;&amp; !isNOE()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        ECMInfo bestInfo = null;</b>
&nbsp;        Comparator&lt;ECMInfo&gt; ecmComparator;
<b class="fc">&nbsp;        ecmComparator = new ECMInfo.ECCMComparator();</b>
<b class="fc">&nbsp;        for (Mounted m : getMisc()) {</b>
&nbsp;            // Ignore if inoperable
<b class="fc">&nbsp;            if (m.isInoperable()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="fc">&nbsp;            ECMInfo newInfo = null;</b>
&nbsp;            // Angel ECM
<b class="fc">&nbsp;            if (m.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="fc">&nbsp;                if (m.curMode().equals(&quot;ECM&quot;)) {</b>
<b class="fc">&nbsp;                    newInfo = new ECMInfo(6, 0, this);</b>
<b class="fc">&nbsp;                    newInfo.setAngelECMStrength(1);</b>
<b class="fc">&nbsp;                } else if (m.curMode().equals(&quot;ECM &amp; ECCM&quot;)</b>
<b class="nc">&nbsp;                           || m.curMode().equals(&quot;ECM &amp; Ghost Targets&quot;)) {</b>
<b class="fc">&nbsp;                    newInfo = new ECMInfo(6, 1, this);</b>
&nbsp;                    // Doesn&#39;t count as Angel ECM
&nbsp;                }
&nbsp;                // BA Angel ECM has a shorter range
<b class="fc">&nbsp;                if ((newInfo != null) &amp;&amp; (this instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    newInfo.setRange(2);</b>
&nbsp;                }
&nbsp;                // Anything that&#39;s not Angel ECM
<b class="fc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_ECM)</b>
<b class="fc">&nbsp;                       &amp;&amp; m.curMode().equals(&quot;ECM&quot;)) {</b>
<b class="fc">&nbsp;                int range = 6;</b>
<b class="fc">&nbsp;                if (m.getType().hasFlag(MiscType.F_SINGLE_HEX_ECM)) {</b>
<b class="nc">&nbsp;                    range = 0;</b>
<b class="fc">&nbsp;                } else if (m.getType().hasFlag(MiscType.F_EW_EQUIPMENT)</b>
<b class="fc">&nbsp;                           || m.getType().hasFlag(MiscType.F_NOVA)</b>
<b class="fc">&nbsp;                           || m.getType().hasFlag(MiscType.F_WATCHDOG)) {</b>
<b class="nc">&nbsp;                    range = 3;</b>
&nbsp;                }
<b class="fc">&nbsp;                newInfo = new ECMInfo(range, 1, this);</b>
<b class="fc">&nbsp;                newInfo.setECMNova(m.getType().hasFlag(MiscType.F_NOVA));</b>
&nbsp;            }
&nbsp;            // In some type of ECM mode...
<b class="fc">&nbsp;            if (newInfo != null) {</b>
<b class="fc">&nbsp;                if ((bestInfo == null)</b>
<b class="fc">&nbsp;                    || (ecmComparator.compare(newInfo, bestInfo) &gt; 0)) {</b>
<b class="fc">&nbsp;                    bestInfo = newInfo;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return bestInfo;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns information (range, location, strength) about ECCM if the unit
&nbsp;     * has active ECCM or null if it doesn&#39;t.  In the case of multiple ECCM
&nbsp;     * system, the best one takes precendence, as a unit can only have one
&nbsp;     * active ECCM at a time.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public ECMInfo getECCMInfo() {
&nbsp;        // If we don&#39;t have a position, ECM doesn&#39;t have an effect
<b class="fc">&nbsp;        if ((getPosition() == null) || isShutDown() || isStealthOn()</b>
<b class="fc">&nbsp;            || (getTransportId() != Entity.NONE)) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // E(C)CM operates differently in space (SO pg 110)
<b class="fc">&nbsp;        if (game.getBoard().inSpace()) {</b>
&nbsp;            // No ECCM in space unless SO rule is on
<b class="nc">&nbsp;            if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            int bapRange = getBAPRange();</b>
<b class="nc">&nbsp;            int range = getECMRange();</b>
<b class="nc">&nbsp;            ECMInfo eccmInfo = new ECMInfo(0, 0, this);</b>
<b class="nc">&nbsp;            eccmInfo.setECCMStrength(1);</b>
<b class="nc">&nbsp;            if (bapRange &gt; 0) {</b>
<b class="nc">&nbsp;                eccmInfo.setRange(bapRange);</b>
&nbsp;                // Medium range band only effects the nose, so set direction
<b class="nc">&nbsp;                if (bapRange &gt; 6) {</b>
<b class="nc">&nbsp;                    eccmInfo.setDirection(getFacing());</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if ((range &gt;= 0) &amp;&amp; hasActiveECCM()) {</b>
<b class="nc">&nbsp;                eccmInfo.setRange(range);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                eccmInfo = null;</b>
&nbsp;            }
<b class="nc">&nbsp;            return eccmInfo;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        ECMInfo bestInfo = null;</b>
&nbsp;        Comparator&lt;ECMInfo&gt; ecmComparator;
<b class="fc">&nbsp;        ecmComparator = new ECMInfo.ECCMComparator();</b>
<b class="fc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="fc">&nbsp;            ECMInfo newInfo = null;</b>
<b class="fc">&nbsp;            if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)</b>
<b class="nc">&nbsp;                &amp;&amp; m.curMode().equals(&quot;ECCM&quot;)) {</b>
<b class="nc">&nbsp;                if ((getTotalCommGearTons() &gt; 3)) {</b>
<b class="nc">&nbsp;                    newInfo = new ECMInfo(6, 0.5, this);</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((getTotalCommGearTons() &gt; 6)) {</b>
<b class="nc">&nbsp;                    newInfo = new ECMInfo(6, 1, this);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Angel ECM
<b class="fc">&nbsp;            if (m.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="fc">&nbsp;                if (m.curMode().equals(&quot;ECCM&quot;)) {</b>
<b class="nc">&nbsp;                    newInfo = new ECMInfo(6, 0, this);</b>
<b class="nc">&nbsp;                    newInfo.setAngelECCMStrength(1);</b>
<b class="fc">&nbsp;                } else if (m.curMode().equals(&quot;ECM &amp; ECCM&quot;)</b>
<b class="fc">&nbsp;                           || m.curMode().equals(&quot;ECCM &amp; Ghost Targets&quot;)) {</b>
<b class="fc">&nbsp;                    newInfo = new ECMInfo(6, 1, this);</b>
&nbsp;                    // Doesn&#39;t count as Angel
&nbsp;                }
&nbsp;                // BA Angel ECM has a shorter range
<b class="fc">&nbsp;                if ((newInfo != null) &amp;&amp; (this instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                    newInfo.setRange(2);</b>
&nbsp;                }
&nbsp;                // Anything that&#39;s not Angel ECM
<b class="fc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_ECM)</b>
<b class="fc">&nbsp;                       &amp;&amp; m.curMode().equals(&quot;ECCM&quot;)) {</b>
<b class="fc">&nbsp;                int range = 6;</b>
<b class="fc">&nbsp;                if (m.getType().hasFlag(MiscType.F_SINGLE_HEX_ECM)) {</b>
<b class="nc">&nbsp;                    range = 0;</b>
<b class="fc">&nbsp;                } else if (m.getType().hasFlag(MiscType.F_EW_EQUIPMENT)</b>
<b class="fc">&nbsp;                           || m.getType().hasFlag(MiscType.F_NOVA)</b>
<b class="fc">&nbsp;                           || m.getType().hasFlag(MiscType.F_WATCHDOG)) {</b>
<b class="nc">&nbsp;                    range = 3;</b>
&nbsp;                }
<b class="fc">&nbsp;                newInfo = new ECMInfo(range, 0, this);</b>
<b class="fc">&nbsp;                newInfo.setECCMStrength(1);</b>
&nbsp;            }
&nbsp;            // In some type of ECCM mode...
<b class="fc">&nbsp;            if (newInfo != null) {</b>
<b class="fc">&nbsp;                if ((bestInfo == null)</b>
<b class="fc">&nbsp;                    || (ecmComparator.compare(newInfo, bestInfo) &gt; 0)) {</b>
<b class="fc">&nbsp;                    bestInfo = newInfo;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return bestInfo;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the strength of the ECM field this unit emits
&nbsp;     */
&nbsp;    public double getECMStrength() {
<b class="nc">&nbsp;        int strength = 0;</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="nc">&nbsp;                if (m.curMode().equals(&quot;ECM&quot;)) {</b>
<b class="nc">&nbsp;                    strength = 2;</b>
<b class="nc">&nbsp;                } else if ((strength &lt; 1)</b>
<b class="nc">&nbsp;                           &amp;&amp; (m.curMode().equals(&quot;ECM &amp; ECCM&quot;) || m.curMode()</b>
<b class="nc">&nbsp;                                                                    .equals(&quot;ECM &amp; Ghost Targets&quot;))) {</b>
<b class="nc">&nbsp;                    strength = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;                       &amp;&amp; m.curMode().equals(&quot;ECM&quot;) &amp;&amp; (strength &lt; 1)) {</b>
<b class="nc">&nbsp;                strength = 1;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return strength;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the strength of the ECCM field this unit emits
&nbsp;     */
&nbsp;    public double getECCMStrength() {
<b class="nc">&nbsp;        double strength = 0;</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {</b>
<b class="nc">&nbsp;                if ((getTotalCommGearTons() &gt; 3) &amp;&amp; (strength &lt; 0.5)) {</b>
<b class="nc">&nbsp;                    strength = 0.5;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((getTotalCommGearTons() &gt; 6) &amp;&amp; (strength &lt; 1)) {</b>
<b class="nc">&nbsp;                    strength = 1;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="nc">&nbsp;                if (m.curMode().equals(&quot;ECM&quot;)) {</b>
<b class="nc">&nbsp;                    strength = 2;</b>
<b class="nc">&nbsp;                } else if ((strength &lt; 1)</b>
<b class="nc">&nbsp;                           &amp;&amp; (m.curMode().equals(&quot;ECM &amp; ECCM&quot;) || m.curMode()</b>
<b class="nc">&nbsp;                                                                    .equals(&quot;ECCM &amp; Ghost Targets&quot;))) {</b>
<b class="nc">&nbsp;                    strength = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_ECM)</b>
<b class="nc">&nbsp;                       &amp;&amp; m.curMode().equals(&quot;ECCM&quot;) &amp;&amp; (strength &lt; 1)) {</b>
<b class="nc">&nbsp;                strength = 1;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return strength;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the total tonnage of communications gear in this entity
&nbsp;     */
&nbsp;    public abstract int getTotalCommGearTons();
&nbsp;
&nbsp;    /**
&nbsp;     * @return the initiative bonus this Entity grants for HQ
&nbsp;     */
&nbsp;    public int getHQIniBonus() {
<b class="nc">&nbsp;        int bonus = 0;</b>
<b class="nc">&nbsp;        for (Mounted misc : getMisc()) {</b>
<b class="nc">&nbsp;            if (misc.getType().hasFlag(MiscType.F_COMMUNICATIONS)</b>
<b class="nc">&nbsp;                &amp;&amp; misc.curMode().equals(&quot;Default&quot;) &amp;&amp; !misc.isInoperable()) {</b>
<b class="nc">&nbsp;                if (getTotalCommGearTons() &gt;= 3) {</b>
<b class="nc">&nbsp;                    bonus += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (getTotalCommGearTons() &gt;= 7) {</b>
<b class="nc">&nbsp;                    bonus += 1;</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return bonus;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the initiative bonus this Entity grants for MD implants
&nbsp;     */
&nbsp;	/*
&nbsp;	 * This has been removed in IO see pg 78
&nbsp;	 *
&nbsp;	 * public int getMDIniBonus() { if
&nbsp;	 * (crew.getOptions().booleanOption(OptionsConstants.MD_COMM_IMPLANT) ||
&nbsp;	 * crew.getOptions().booleanOption(OptionsConstants.MD_BOOST_COMM_IMPLANT))
&nbsp;	 * { return 1; } return 0; }
&nbsp;	 */
&nbsp;
&nbsp;    /**
&nbsp;     * @return the initiative bonus this Entity grants for quirks
&nbsp;     */
&nbsp;    public int getQuirkIniBonus() {
&nbsp;        // command battlemech and and battle computer are not cumulative
<b class="nc">&nbsp;        if (hasQuirk(OptionsConstants.QUIRK_POS_BATTLE_COMP) &amp;&amp; !getCrew().isDead()</b>
<b class="nc">&nbsp;            &amp;&amp; !getCrew().isUnconscious()) {</b>
<b class="nc">&nbsp;            return 2;</b>
<b class="nc">&nbsp;        } else if (hasQuirk(OptionsConstants.QUIRK_POS_COMMAND_MECH) &amp;&amp; !getCrew().isDead()</b>
<b class="nc">&nbsp;                   &amp;&amp; !getCrew().isUnconscious()) {</b>
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the bay that ammo is associated with
&nbsp;     *
&nbsp;     * @param mammo
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Mounted getBayByAmmo(Mounted mammo) {
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getWeaponBayList()) {</b>
<b class="nc">&nbsp;            for (int bayAmmoId : m.getBayAmmo()) {</b>
<b class="nc">&nbsp;                Mounted bayammo = getEquipment(bayAmmoId);</b>
<b class="nc">&nbsp;                if (bayammo == mammo) {</b>
<b class="nc">&nbsp;                    return m;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return how many BA vibroclaws this &lt;code&gt;Entity&lt;/code&gt; is equipped with
&nbsp;     */
&nbsp;    public int getVibroClaws() {
&nbsp;        // generic entities can&#39;t carry vibroclaws
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * shut this unit down due to a Taser attack
&nbsp;     *
&nbsp;     * @param turns   - the amount of rounds for which this Entity should be
&nbsp;     *                shutdown
&nbsp;     * @param baTaser - was this due to a BA taser?
&nbsp;     */
&nbsp;    public void taserShutdown(int turns, boolean baTaser) {
<b class="nc">&nbsp;        setShutDown(true);</b>
<b class="nc">&nbsp;        taserShutdownRounds = turns;</b>
<b class="nc">&nbsp;        shutdownByBATaser = baTaser;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * get the number of rounds for which this unit should be shutdown by taser
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getTaserShutdownRounds() {
<b class="nc">&nbsp;        return taserShutdownRounds;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setTaserShutdownRounds(int rounds) {
<b class="nc">&nbsp;        taserShutdownRounds = rounds;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isBATaserShutdown() {
<b class="nc">&nbsp;        return shutdownByBATaser;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setBATaserShutdown(boolean value) {
<b class="nc">&nbsp;        shutdownByBATaser = value;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getTaserInterferenceHeat() {
<b class="nc">&nbsp;        return taserInterferenceHeat;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * set this entity to suffer from taser feedback
&nbsp;     *
&nbsp;     * @param rounds - the number of rounds to suffer from taserfeedback
&nbsp;     */
&nbsp;    public void setTaserFeedback(int rounds) {
<b class="nc">&nbsp;        taserFeedBackRounds = rounds;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * get the rounds for which this entity suffers from taser feedback
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getTaserFeedBackRounds() {
<b class="nc">&nbsp;        return taserFeedBackRounds;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setTaserInterference(int value, int rounds, boolean heat) {
<b class="nc">&nbsp;        taserInterference = value;</b>
<b class="nc">&nbsp;        taserInterferenceRounds = rounds;</b>
<b class="nc">&nbsp;        taserInterferenceHeat = heat;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getTaserInterference() {
<b class="nc">&nbsp;        return taserInterference;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getTaserInterferenceRounds() {
<b class="nc">&nbsp;        return taserInterferenceRounds;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addIMPHits(int missiles) {
&nbsp;        // effects last for only one turn.
<b class="nc">&nbsp;        impThisTurn += missiles;</b>
<b class="nc">&nbsp;        int heatAdd = missiles + impThisTurnHeatHelp;</b>
<b class="nc">&nbsp;        impThisTurnHeatHelp = heatAdd % 3;</b>
<b class="nc">&nbsp;        heatAdd = heatAdd - impThisTurnHeatHelp;</b>
<b class="nc">&nbsp;        heatAdd = heatAdd / 3;</b>
<b class="nc">&nbsp;        heatFromExternal += heatAdd;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void doNewRoundIMP() {
<b class="fc">&nbsp;        impLastTurn = impThisTurn;</b>
<b class="fc">&nbsp;        impThisTurn = 0;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getIMPMoveMod() {
&nbsp;        // this function needs to be added to the MP
&nbsp;        // calculating functions
&nbsp;        //however, since no function calls super, it seems unneccesary complicated
&nbsp;        // really.
<b class="nc">&nbsp;        int max = 2;</b>
<b class="nc">&nbsp;        int modifier = impThisTurn + impLastTurn;</b>
<b class="nc">&nbsp;        modifier = modifier - (modifier % 3);</b>
<b class="nc">&nbsp;        modifier = modifier / 3;</b>
<b class="nc">&nbsp;        return (modifier &gt; max) ? -max : -modifier;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getIMPTHMod() {
<b class="nc">&nbsp;        int max = 2;</b>
<b class="nc">&nbsp;        int modifier = impThisTurn + impLastTurn;</b>
<b class="nc">&nbsp;        modifier = modifier - (modifier % 3);</b>
<b class="nc">&nbsp;        modifier = modifier / 3;</b>
<b class="nc">&nbsp;        return (modifier &gt; max) ? max : modifier;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns whether the unit is a military unit (as opposed to a civilian
&nbsp;     * unit).
&nbsp;     */
&nbsp;    public boolean isMilitary() {
<b class="nc">&nbsp;        return military;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * is this entity a large craft? (dropship, jumpship, warship, or space
&nbsp;     * station)
&nbsp;     */
&nbsp;    public boolean isLargeCraft() {
<b class="nc">&nbsp;        return (this instanceof Dropship) || (this instanceof Jumpship);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do units loaded onto this entity still have active ECM/ECCM/etc.?
&nbsp;     */
&nbsp;    public boolean loadedUnitsHaveActiveECM() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * is this entity loaded into a fighter squadron?
&nbsp;     */
&nbsp;    public boolean isPartOfFighterSquadron() {
<b class="nc">&nbsp;        if (game == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (conveyance == Entity.NONE) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return game.getEntity(conveyance) instanceof FighterSquadron;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a HTML string that describes the BV calculations
&nbsp;     *
&nbsp;     * @return a &lt;code&gt;String&lt;/code&gt; explaining the BV calculation
&nbsp;     */
&nbsp;    public String getBVText() {
<b class="nc">&nbsp;        if (bvText == null) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return bvText.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the BAR-rating of this Entity&#39;s armor
&nbsp;     *
&nbsp;     * @return the BAR rating
&nbsp;     */
&nbsp;    public int getBARRating(int loc) {
&nbsp;        // normal armor has a BAR rating of 10
<b class="nc">&nbsp;        return 10;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * does this Entity have BAR armor?
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasBARArmor(int loc) {
<b class="nc">&nbsp;        return getBARRating(loc) &lt; 10;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the barrier armor rating for support vehicles. Has no effect on other unit types.
&nbsp;     * @param rating
&nbsp;     */
<b class="nc">&nbsp;    public void setBARRating(int rating) {}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * does this entity have an armored chassis?
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasArmoredChassis() {
&nbsp;        // normal entities don&#39;t, subclasses should
&nbsp;        // override
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * does this &lt;code&gt;Entity&lt;/code&gt; have Environmental sealing? (only Support
&nbsp;     * Vehicles or IndustrialMechs should mount this)
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasEnvironmentalSealing() {
<b class="nc">&nbsp;        for (Mounted misc : miscList) {</b>
<b class="nc">&nbsp;            if (misc.getType().hasFlag(MiscType.F_ENVIRONMENTAL_SEALING)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Possibly do a ICE-Engine stall PSR (only intended for Mechs, both
&nbsp;     * Industrial and Battle).
&nbsp;     *
&nbsp;     * @param vPhaseReport the &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing the phase reports
&nbsp;     * @return a Vector&lt;Report&gt; containing the passed in reports, and any
&nbsp;     * additional ones
&nbsp;     */
&nbsp;    public Vector&lt;Report&gt; doCheckEngineStallRoll(Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        return vPhaseReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for unstalling of this Entity&#39;s engine (only used for ICE-powered
&nbsp;     * &#39;Mechs).
&nbsp;     *
&nbsp;     * @param vPhaseReport the &lt;code&gt;Vector&lt;Report&gt;&lt;/code&gt; containing the phase reports
&nbsp;     */
&nbsp;    public void checkUnstall(Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        return;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasArmoredEngine() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this Entity&#39;s ICE Engine stalled?
&nbsp;     *
&nbsp;     * @return if this Entity&#39;s ICE engine is stalled
&nbsp;     */
&nbsp;    public boolean isStalled() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * is this a naval vessel on the surface of the water?
&nbsp;     */
&nbsp;    public boolean isSurfaceNaval() {
&nbsp;        // TODO: assuming submarines on the surface act like surface naval
&nbsp;        // vessels until rules clarified
&nbsp;        // http://www.classicbattletech.com/forums/index.php/topic,48987.0.html
<b class="nc">&nbsp;        return (getElevation() == 0) &amp;&amp; isNaval();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this a naval vessel?
&nbsp;     * @return Whether it is or not.
&nbsp;     */
&nbsp;    public boolean isNaval() {
<b class="nc">&nbsp;        return (getMovementMode() == EntityMovementMode.NAVAL)</b>
<b class="nc">&nbsp;                || (getMovementMode() == EntityMovementMode.HYDROFOIL)</b>
<b class="nc">&nbsp;                || (getMovementMode() == EntityMovementMode.SUBMARINE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * used to set the source of the creation of this entity, i.e RS PPU Custom
&nbsp;     * what not Fluff for MMLab
&nbsp;     *
&nbsp;     * @param source
&nbsp;     */
&nbsp;    public void setSource(String source) {
<b class="fc">&nbsp;        if (source != null) {</b>
<b class="fc">&nbsp;            this.source = source;</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getSource() {
<b class="nc">&nbsp;        if (source == null) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return source;</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void setQuirks(Quirks quirks) {
<b class="nc">&nbsp;        this.quirks = quirks;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves the quirks object for entity. DO NOT USE this to check boolean
&nbsp;     * options, as it will not check game options for quirks. Use
&nbsp;     * entity#hasQuirk instead
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public synchronized Quirks getQuirks() {
<b class="nc">&nbsp;        return quirks;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasQuirk(String name) {
<b class="nc">&nbsp;        if ((null == game)</b>
<b class="nc">&nbsp;            || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return quirks.booleanOption(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PartialRepairs getPartialRepairs() {
<b class="nc">&nbsp;        return partReps;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void clearPartialRepairs() {
<b class="nc">&nbsp;        for (Enumeration&lt;IOptionGroup&gt; i = partReps.getGroups(); i</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            IOptionGroup group = i.nextElement();</b>
<b class="nc">&nbsp;            for (Enumeration&lt;IOption&gt; j = group.getOptions(); j</b>
<b class="nc">&nbsp;                    .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                IOption option = j.nextElement();</b>
<b class="nc">&nbsp;                option.clearValue();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * count all the quirks for this unit, positive and negative
&nbsp;     */
&nbsp;    public int countQuirks() {
<b class="nc">&nbsp;        if ((null == game)</b>
<b class="nc">&nbsp;            || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return quirks.count();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int countWeaponQuirks() {
<b class="nc">&nbsp;        int count = 0;</b>
&nbsp;
<b class="nc">&nbsp;        if ((null == game)</b>
<b class="nc">&nbsp;            || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return count;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            count += m.countQuirks();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int countPartialRepairs() {
<b class="nc">&nbsp;        if((null == game) ||</b>
<b class="nc">&nbsp;                !game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return partReps.count();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * count the quirks for this unit, for a given group name
&nbsp;     */
&nbsp;    public int countQuirks(String grpKey) {
<b class="nc">&nbsp;        if ((null == game)</b>
<b class="nc">&nbsp;            || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return quirks.count(grpKey);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string of all the quirk &quot;codes&quot; for this entity, using sep as
&nbsp;     * the separator
&nbsp;     */
&nbsp;    public String getQuirkList(String sep) {
<b class="nc">&nbsp;        if ((null == game)</b>
<b class="nc">&nbsp;            || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return quirks.getOptionList(sep);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the forward firing arc for this entity - overrided by some units
&nbsp;     */
&nbsp;    public int getForwardArc() {
<b class="nc">&nbsp;        return Compute.ARC_FORWARD;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the rear firing arc for this entity - overrided by some units
&nbsp;     */
&nbsp;    public int getRearArc() {
<b class="nc">&nbsp;        return Compute.ARC_REAR;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns a description to the current sensing range of the active sensor
&nbsp;     */
&nbsp;    public String getSensorDesc() {
<b class="nc">&nbsp;        if (null == getActiveSensor()) {</b>
<b class="nc">&nbsp;            return &quot;none&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        int bracket = Compute.getSensorBracket(getSensorCheck());</b>
<b class="nc">&nbsp;        if (isSpaceborne()) {</b>
<b class="nc">&nbsp;            bracket = Compute.getSensorBracket(7);</b>
&nbsp;        }
<b class="nc">&nbsp;        int range = getActiveSensor().getRangeByBracket();</b>
<b class="nc">&nbsp;        int groundRange = 0;</b>
<b class="nc">&nbsp;        if (getActiveSensor().isBAP()) {</b>
<b class="nc">&nbsp;            groundRange = 2;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            groundRange = 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        //ASF sensors change range when in space, so we do that here
<b class="nc">&nbsp;        if (isSpaceborne()) {</b>
<b class="nc">&nbsp;            if (getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</b>
<b class="nc">&nbsp;                range = Sensor.ASF_RADAR_MAX_RANGE;</b>
&nbsp;            }
&nbsp;
&nbsp;            //If Aero/Spacecraft sensors are destroyed while in space, the range is 0.
<b class="nc">&nbsp;            if (isAeroSensorDestroyed()) {</b>
<b class="nc">&nbsp;                range = 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //Dropships using radar in an atmosphere need a range that&#39;s a bit more sensible
<b class="nc">&nbsp;        if (hasETypeFlag(Entity.ETYPE_DROPSHIP) &amp;&amp; !isSpaceborne()) {</b>
<b class="nc">&nbsp;            if (getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR) {</b>
<b class="nc">&nbsp;                range = Sensor.LC_RADAR_GROUND_RANGE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int maxSensorRange = bracket * range;</b>
<b class="nc">&nbsp;        int minSensorRange = Math.max((bracket - 1) * range, 0);</b>
<b class="nc">&nbsp;        int maxGroundSensorRange = bracket * groundRange;</b>
<b class="nc">&nbsp;        int minGroundSensorRange = Math.max((maxGroundSensorRange - 1), 0);</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</b>
<b class="nc">&nbsp;            minSensorRange = 0;</b>
<b class="nc">&nbsp;            minGroundSensorRange = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isAirborne() &amp;&amp; game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            return getActiveSensor().getDisplayName() + &quot; (&quot; + minSensorRange + &quot;-&quot;</b>
&nbsp;                    + maxSensorRange + &quot;)&quot; + &quot; {&quot; + ENTITY_AIR_TO_GROUND_SENSOR_RANGE + &quot; (&quot; + minGroundSensorRange + &quot;-&quot;
&nbsp;                    + maxGroundSensorRange + &quot;)}&quot;;
&nbsp;        }
<b class="nc">&nbsp;        return getActiveSensor().getDisplayName() + &quot; (&quot; + minSensorRange + &quot;-&quot;</b>
&nbsp;               + maxSensorRange + &quot;)&quot;;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isAirborne() {
<b class="fc">&nbsp;        return (getAltitude() &gt; 0)</b>
<b class="fc">&nbsp;               || (getMovementMode() == EntityMovementMode.AERODYNE)</b>
<b class="fc">&nbsp;               || (getMovementMode() == EntityMovementMode.SPHEROID);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isSpaceborne() {
&nbsp;        // for now if you are in space, you are spaceborne, but this will become
&nbsp;        // more complicated when
&nbsp;        // we start adding multiple maps to the same game and so I should try to
&nbsp;        // replace most calls to
&nbsp;        // game.getBoard().inSpace() with this one
<b class="fc">&nbsp;        return game != null &amp;&amp; game.getBoard().inSpace();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * is the unit flying Nape of the Earth? (i.e. one elevation above ground)
&nbsp;     */
&nbsp;    public boolean isNOE() {
&nbsp;
<b class="nc">&nbsp;        if (!isAirborne()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getBoard().inAtmosphere()) {</b>
<b class="nc">&nbsp;            return (1 == (getAltitude() - game.getBoard().getHex(getPosition())</b>
<b class="nc">&nbsp;                    .ceiling(true)));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getBoard().onGround()) {</b>
<b class="nc">&nbsp;            return 1 == getAltitude();</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getStartingPos() {
<b class="nc">&nbsp;        return getStartingPos(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getStartingPos(boolean inheritFromOwner) {
<b class="nc">&nbsp;        if (inheritFromOwner &amp;&amp; startingPos == Board.START_NONE) {</b>
<b class="nc">&nbsp;            return owner.getStartingPos();</b>
&nbsp;        }
<b class="nc">&nbsp;        return startingPos;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStartingPos(int i) {
<b class="nc">&nbsp;        startingPos = i;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int getAltitude() {
<b class="fc">&nbsp;        return altitude;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setAltitude(int a) {
<b class="nc">&nbsp;        altitude = a;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getUseManualBV() {
<b class="fc">&nbsp;        return useManualBV;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUseManualBV(boolean bv) {
<b class="nc">&nbsp;        useManualBV = bv;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getManualBV() {
<b class="nc">&nbsp;        return manualBV;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setManualBV(int bv) {
<b class="nc">&nbsp;        manualBV = bv;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the initial BV of a unit.
&nbsp;     *
&nbsp;     * Useful for comparisons with the current BV.
&nbsp;     * @return The initial BV of a unit.
&nbsp;     */
&nbsp;    public int getInitialBV() {
<b class="nc">&nbsp;        return initialBV;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the initial BV for a unit.
&nbsp;     *
&nbsp;     * Called when the game is initialized.
&nbsp;     * @param bv The initial BV of a unit.
&nbsp;     */
&nbsp;    public void setInitialBV(int bv) {
<b class="nc">&nbsp;            initialBV = bv;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * produce an int array of the number of bombs of each type based on the
&nbsp;     * current bomblist
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int[] getBombLoadout() {
<b class="nc">&nbsp;        int[] loadout = new int[BombType.B_NUM];</b>
<b class="nc">&nbsp;        for (Mounted bomb : getBombs()) {</b>
<b class="nc">&nbsp;            if ((bomb.getUsableShotsLeft() &gt; 0)</b>
<b class="nc">&nbsp;                &amp;&amp; (bomb.getType() instanceof BombType)) {</b>
<b class="nc">&nbsp;                int type = ((BombType) bomb.getType()).getBombType();</b>
<b class="nc">&nbsp;                loadout[type] = loadout[type] + 1;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return loadout;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Start of Battle Force Conversion Methods
&nbsp;     */
&nbsp;
&nbsp;    public int getBattleForcePoints() {
<b class="nc">&nbsp;    	double bv = calculateBattleValue(true, true);</b>
<b class="nc">&nbsp;    	int points = (int) Math.round(bv / 100);</b>
<b class="nc">&nbsp;    	return Math.max(1, points);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the movement mode of the entity and return it as a battle force
&nbsp;     * string.
&nbsp;     */
&nbsp;    public String getMovementModeAsBattleForceString() {
<b class="nc">&nbsp;    	switch (getMovementMode()) {</b>
&nbsp;    	case NONE:
&nbsp;    	case BIPED:
&nbsp;    	case BIPED_SWIM:
&nbsp;    	case QUAD:
&nbsp;    	case QUAD_SWIM:
<b class="nc">&nbsp;    		return &quot;&quot;;</b>
&nbsp;    	case TRACKED:
<b class="nc">&nbsp;    		return &quot;t&quot;;</b>
&nbsp;    	case WHEELED:
<b class="nc">&nbsp;    		return &quot;w&quot;;</b>
&nbsp;    	case HOVER:
<b class="nc">&nbsp;    		return &quot;h&quot;;</b>
&nbsp;    	case VTOL:
<b class="nc">&nbsp;    		return &quot;v&quot;;</b>
&nbsp;    	case NAVAL:
&nbsp;    	case HYDROFOIL:
<b class="nc">&nbsp;    		return &quot;n&quot;;</b>
&nbsp;    	case SUBMARINE:
&nbsp;    	case INF_UMU:
<b class="nc">&nbsp;    		return &quot;s&quot;;</b>
&nbsp;    	case INF_LEG:
<b class="nc">&nbsp;    		return &quot;f&quot;;</b>
&nbsp;    	case INF_MOTORIZED:
<b class="nc">&nbsp;    		return &quot;m&quot;;</b>
&nbsp;    	case INF_JUMP:
<b class="nc">&nbsp;    		return &quot;j&quot;;</b>
&nbsp;    	case WIGE:
<b class="nc">&nbsp;    		return &quot;g&quot;;</b>
&nbsp;    	case AERODYNE:
<b class="nc">&nbsp;    		return &quot;a&quot;;</b>
&nbsp;    	case SPHEROID:
<b class="nc">&nbsp;    		return &quot;p&quot;;</b>
&nbsp;    	default:
<b class="nc">&nbsp;    		return &quot;ERROR&quot;;</b>
&nbsp;    	}
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Certain unit types can increase this with MASC, supercharger, or jet booster.
&nbsp;     * AlphaStrike needs the fraction retained because it doubles the movement for ground units,
&nbsp;     * while BattleForce rounds this to the nearest integer.
&nbsp;     */
&nbsp;    public double getBaseBattleForceMovement() {
<b class="nc">&nbsp;    	return getOriginalWalkMP();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handles base, jump, and underwater movement.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public void setBattleForceMovement(Map&lt;String,Integer&gt; movement) {
<b class="nc">&nbsp;    	int baseMove = (int)Math.round(getBaseBattleForceMovement());</b>
<b class="nc">&nbsp;    	int jumpMove = getOriginalJumpMP();</b>
<b class="nc">&nbsp;    	if (jumpMove == baseMove &amp;&amp; getMovementModeAsBattleForceString().length() == 0) {</b>
<b class="nc">&nbsp;    		movement.put(&quot;j&quot;, baseMove);</b>
&nbsp;    	} else {
<b class="nc">&nbsp;    		movement.put(getMovementModeAsBattleForceString(), baseMove);</b>
<b class="nc">&nbsp;    		if (jumpMove &gt;= baseMove) {</b>
<b class="nc">&nbsp;    			movement.put(&quot;j&quot;, jumpMove);</b>
<b class="nc">&nbsp;    		} else if (jumpMove &gt; 0) {</b>
<b class="nc">&nbsp;    			movement.put(&quot;j&quot;, (int)Math.round(jumpMove * 0.66));</b>
&nbsp;    		}
&nbsp;    	}
<b class="nc">&nbsp;    	int umu = getAllUMUCount();</b>
<b class="nc">&nbsp;    	if (umu &gt; 0) {</b>
<b class="nc">&nbsp;    		movement.put(&quot;s&quot;, umu);</b>
&nbsp;    	}
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Doubles base movement. Aero overrides this.
&nbsp;     */
&nbsp;    public void setAlphaStrikeMovement(Map&lt;String,Integer&gt; movement) {
<b class="nc">&nbsp;    	int baseMove = (int)Math.round(getBaseBattleForceMovement() * 2);</b>
<b class="nc">&nbsp;    	int jumpMove = getOriginalJumpMP();</b>
<b class="nc">&nbsp;    	if (jumpMove == baseMove) {</b>
<b class="nc">&nbsp;    		movement.put(&quot;j&quot;, baseMove);</b>
&nbsp;    	} else {
<b class="nc">&nbsp;    		movement.put(getMovementModeAsBattleForceString(), baseMove);</b>
<b class="nc">&nbsp;    		if (jumpMove &gt; 0) {</b>
<b class="nc">&nbsp;    			movement.put(&quot;j&quot;, jumpMove * 2);</b>
&nbsp;    		}
&nbsp;    	}
<b class="nc">&nbsp;    	int umu = getAllUMUCount();</b>
<b class="nc">&nbsp;    	if (umu &gt; 0) {</b>
<b class="nc">&nbsp;    		movement.put(&quot;s&quot;, umu * 2);</b>
&nbsp;    	}
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getBattleForceArmorPoints() {
<b class="nc">&nbsp;    	return (int)Math.round(getBattleForceArmorPointsRaw());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the intermediate value for armor points (retaining fractional amounts)
&nbsp;     * and adds any special abilities conferred by armor.
&nbsp;     *
&nbsp;     * @return      The armor value of this entity
&nbsp;     */
&nbsp;    public double getBattleForceArmorPointsRaw() {
<b class="nc">&nbsp;    	double armorPoints = 0;</b>
&nbsp;
<b class="nc">&nbsp;    	for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;    		double armorMod = 1;</b>
<b class="nc">&nbsp;    		switch (getArmorType(loc)) {</b>
&nbsp;    		case EquipmentType.T_ARMOR_COMMERCIAL:
<b class="nc">&nbsp;    			armorMod = .5;</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_INDUSTRIAL:
&nbsp;    		case EquipmentType.T_ARMOR_HEAVY_INDUSTRIAL:
<b class="nc">&nbsp;    			armorMod = getBARRating(0) / 10;</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_FERRO_LAMELLOR:
<b class="nc">&nbsp;    			armorMod = 1.2;</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_HARDENED:
<b class="nc">&nbsp;    			armorMod = 1.5;</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_REFLECTIVE:
&nbsp;    		case EquipmentType.T_ARMOR_REACTIVE:
<b class="nc">&nbsp;    			armorMod = .75;</b>
&nbsp;    			break;
&nbsp;    		}
<b class="nc">&nbsp;    		armorPoints += Math.ceil(getArmor(loc) * armorMod);</b>
&nbsp;
&nbsp;    	}
<b class="nc">&nbsp;    	if (this.hasModularArmor()) {</b>
&nbsp;    		// Modular armor is always &quot;regular&quot; armor
<b class="nc">&nbsp;    		for (Mounted mount : this.getEquipment()) {</b>
<b class="nc">&nbsp;    			if (!mount.isDestroyed()</b>
<b class="nc">&nbsp;    					&amp;&amp; (mount.getType() instanceof MiscType)</b>
<b class="nc">&nbsp;    					&amp;&amp; ((MiscType) mount.getType())</b>
<b class="nc">&nbsp;    					.hasFlag(MiscType.F_MODULAR_ARMOR)) {</b>
<b class="nc">&nbsp;    				armorPoints += 10;</b>
&nbsp;    			}
<b class="nc">&nbsp;    		}</b>
&nbsp;    	}
&nbsp;
<b class="nc">&nbsp;    	if (isCapitalScale()) {</b>
<b class="nc">&nbsp;    		return (int)Math.round(armorPoints * 0.33);</b>
&nbsp;    	}
<b class="nc">&nbsp;    	return (int) Math.round(armorPoints / 30);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * only used for Aerospace and Dropships
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public String getBattleForceDamageThresholdString() {
<b class="nc">&nbsp;    	return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * this will be unit specific
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getBattleForceStructurePoints() {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some units have separate damage values for various locations (turrets, large craft firing arcs)
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getNumBattleForceWeaponsLocations() {
<b class="nc">&nbsp;    	return 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNumAlphaStrikeWeaponsLocations() {
<b class="nc">&nbsp;    	return getNumBattleForceWeaponsLocations();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param index - indicates which set of damage values is being calculated
&nbsp;     * @param location - one of the entity&#39;s LOC_* constants
&nbsp;     * @return - the damage multiplier for this location; 0 for exclusion
&nbsp;     */
&nbsp;    public double getBattleForceLocationMultiplier(int index, int location, boolean rearMounted) {
<b class="nc">&nbsp;    	return 1.0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Weapon calculations are the same for BF and AS except for turrets, which are not separated
&nbsp;     * in AS, and warships, which have only four arcs in AS.
&nbsp;     */
&nbsp;    public double getAlphaStrikeLocationMultiplier(int index, int location, boolean rearMounted) {
<b class="nc">&nbsp;    	return getBattleForceLocationMultiplier(index, location, rearMounted);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isBattleForceTurretLocation(int index) {
<b class="nc">&nbsp;    	return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isBattleForceRearLocation(int index) {
<b class="nc">&nbsp;    	return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Units with separate weapon locations (turrets or firing arcs) return the name of the location
&nbsp;     * @param index
&nbsp;     * @return
&nbsp;     */
&nbsp;    public String getBattleForceLocationName(int index) {
<b class="nc">&nbsp;    	if (isBattleForceTurretLocation(index)) {</b>
<b class="nc">&nbsp;    		return &quot;TUR&quot;;</b>
&nbsp;    	}
<b class="nc">&nbsp;    	return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getAlphaStrikeLocationName(int index) {
<b class="nc">&nbsp;    	return getBattleForceLocationName(index);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean useForAlphaStrikePointCalc(int loc) {
<b class="nc">&nbsp;    	return loc == 0 || isBattleForceTurretLocation(loc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only used by Mechs and ASFs, which require different approaches to determining rear mountings
&nbsp;     * @param allowRear - Use rear-mounted weapons instead of forward
&nbsp;     * @return - total heat generated by firing all weapons
&nbsp;     */
&nbsp;    public int getBattleForceTotalHeatGeneration(boolean allowRear) {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used by small craft, dropships, jumpships, and warships to compute heat for a specific firing arc
&nbsp;     *
&nbsp;     * @param location
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getBattleForceTotalHeatGeneration(int location) {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addBattleForceSpecialAbilities(Map&lt;BattleForceSPA,Integer&gt; specialAbilities) {
<b class="nc">&nbsp;    	for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;    		if (!(m.getType() instanceof MiscType)) {</b>
<b class="nc">&nbsp;    			continue;</b>
&nbsp;    		}
<b class="nc">&nbsp;    		if (m.getType().hasFlag(MiscType.F_BAP)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.RCN, null);</b>
<b class="nc">&nbsp;    			if (m.getType().hasFlag(MiscType.F_BLOODHOUND)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.BH, null);</b>
<b class="nc">&nbsp;    			} else if (m.getType().hasFlag(MiscType.F_BA_EQUIPMENT)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.LPRB, null);</b>
<b class="nc">&nbsp;    			} else if (m.getType().hasFlag(MiscType.F_WATCHDOG)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.WAT, null);</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.LPRB, null);</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.ECM, null);</b>
&nbsp;    			} else {
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.PRB, null);</b>
&nbsp;    			}
<b class="nc">&nbsp;    			if (m.getType().hasFlag(MiscType.F_NOVA)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.NOVA, null);</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.ECM, null);</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.MHQ, 3); // count half-tons</b>
&nbsp;    			}
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_ECM)) {</b>
<b class="nc">&nbsp;    			if (m.getType().hasFlag(MiscType.F_ANGEL_ECM)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.AECM, null);</b>
<b class="nc">&nbsp;    			} else if (m.getType().hasFlag(MiscType.F_SINGLE_HEX_ECM)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.LECM, null);</b>
&nbsp;    			} else {
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.ECM, null);</b>
&nbsp;    			}
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_BOOBY_TRAP)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.BT, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_LIGHT_BRIDGE_LAYER)</b>
<b class="nc">&nbsp;    				|| m.getType().hasFlag(MiscType.F_MEDIUM_BRIDGE_LAYER)</b>
<b class="nc">&nbsp;    				|| m.getType().hasFlag(MiscType.F_HEAVY_BRIDGE_LAYER)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.BRID, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_C3S)) {</b>
<b class="nc">&nbsp;    			if (m.getType().hasFlag(MiscType.F_C3SBS)) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.C3BSS, null);</b>
<b class="nc">&nbsp;    				specialAbilities.merge(BattleForceSPA.MHQ, 4, Integer::sum);</b>
<b class="nc">&nbsp;    			} else if (m.getType().hasFlag(MiscType.F_C3EM)) {</b>
<b class="nc">&nbsp;    				specialAbilities.merge(BattleForceSPA.C3EM, 1, Integer::sum);</b>
<b class="nc">&nbsp;    				specialAbilities.merge(BattleForceSPA.MHQ, 4, Integer::sum);</b>
&nbsp;    			} else {
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.C3S, null);</b>
<b class="nc">&nbsp;    				specialAbilities.merge(BattleForceSPA.MHQ, 2, Integer::sum);</b>
&nbsp;    			}
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_C3I)) {</b>
<b class="nc">&nbsp;    			if ((getEntityType() &amp; ETYPE_AERO) == ETYPE_AERO) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.NC3, null);</b>
&nbsp;    			} else {
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.C3I, null);</b>
<b class="nc">&nbsp;    				if (m.getType().hasFlag(MiscType.F_BA_EQUIPMENT)) {</b>
<b class="nc">&nbsp;    					specialAbilities.merge(BattleForceSPA.MHQ, 4, Integer::sum);</b>
&nbsp;    				} else {
<b class="nc">&nbsp;    					specialAbilities.merge(BattleForceSPA.MHQ, 5, Integer::sum);</b>
&nbsp;    				}
&nbsp;    			}
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_CASE)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.CASE, null);</b>
<b class="nc">&nbsp;            } else if (m.getType().hasFlag(MiscType.F_CASEP)) { //in BF seems to work the same as CASE</b>
<b class="nc">&nbsp;                specialAbilities.put(BattleForceSPA.CASE, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_CASEII)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.CASEII, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_DRONE_OPERATING_SYSTEM)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.DRO, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_DRONE_CARRIER_CONTROL)) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.DCC, (int) m.getSize(), Integer::sum);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_EJECTION_SEAT)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.ES, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_ECM)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.ECM, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_BULLDOZER)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.ENG, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_CLUB)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MEL, null);</b>
<b class="nc">&nbsp;    			if ((m.getType().getSubType() &amp;</b>
&nbsp;    					(MiscType.S_BACKHOE | MiscType.S_PILE_DRIVER
&nbsp;    							| MiscType.S_MINING_DRILL | MiscType.S_ROCK_CUTTER
&nbsp;    							| MiscType.S_WRECKING_BALL)) != 0) {
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.ENG, null);</b>
<b class="nc">&nbsp;    			} else if ((m.getType().getSubType() &amp;</b>
&nbsp;    					(MiscType.S_DUAL_SAW | MiscType.S_CHAINSAW
&nbsp;    							| MiscType.S_BUZZSAW)) != 0) {
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.SAW, null);</b>
&nbsp;    			}
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_FIRE_RESISTANT)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.FR, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_MOBILE_HPG)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.HPG, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.MHQ, (int) m.getTonnage() * 2,</b>
&nbsp;    					Integer::sum);
<b class="nc">&nbsp;    			if (m.getTonnage() &gt;= getWeight() / 20.0) {</b>
<b class="nc">&nbsp;    				specialAbilities.put(BattleForceSPA.RCN, null);</b>
&nbsp;    			}
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_SENSOR_DISPENSER)) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.RSD, 1, Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.RCN, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_LOOKDOWN_RADAR)</b>
<b class="nc">&nbsp;    				|| m.getType().hasFlag(MiscType.F_RECON_CAMERA)</b>
<b class="nc">&nbsp;    				|| m.getType().hasFlag(MiscType.F_HIRES_IMAGER)</b>
<b class="nc">&nbsp;    				|| m.getType().hasFlag(MiscType.F_HYPERSPECTRAL_IMAGER)</b>
<b class="nc">&nbsp;    				|| m.getType().hasFlag(MiscType.F_INFRARED_IMAGER)) {</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_SEARCHLIGHT)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.SRCH, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.RHS, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_EMERGENCY_COOLANT_SYSTEM)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.ECS, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_VIRAL_JAMMER_DECOY)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.DJ, null);</b>
<b class="nc">&nbsp;    		} else if (m.getType().hasFlag(MiscType.F_VIRAL_JAMMER_HOMING)) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.HJ, null);</b>
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
&nbsp;
<b class="nc">&nbsp;    	if (isOmni()) {</b>
<b class="nc">&nbsp;    		specialAbilities.put(BattleForceSPA.OMNI, null);</b>
&nbsp;    	}
&nbsp;
&nbsp;    	//TODO: Variable Range targeting is not implemented
&nbsp;
<b class="nc">&nbsp;    	if (!hasPatchworkArmor()) {</b>
<b class="nc">&nbsp;    		switch (getArmorType(0)) {</b>
&nbsp;    		case EquipmentType.T_ARMOR_COMMERCIAL:
&nbsp;    		case EquipmentType.T_ARMOR_INDUSTRIAL:
&nbsp;    		case EquipmentType.T_ARMOR_HEAVY_INDUSTRIAL:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.BAR, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_FERRO_LAMELLOR:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.CR, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_STEALTH:
&nbsp;    		case EquipmentType.T_ARMOR_STEALTH_VEHICLE:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.STL, null);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.ECM, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_BA_STEALTH:
&nbsp;    		case EquipmentType.T_ARMOR_BA_STEALTH_BASIC:
&nbsp;    		case EquipmentType.T_ARMOR_BA_STEALTH_IMP:
&nbsp;    		case EquipmentType.T_ARMOR_BA_STEALTH_PROTOTYPE:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.STL, null);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.LECM, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_ANTI_PENETRATIVE_ABLATION:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.ABA, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_BALLISTIC_REINFORCED:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.BRA, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_BA_FIRE_RESIST:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.FR, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_IMPACT_RESISTANT:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.IRA, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_REACTIVE:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.RCA, null);</b>
<b class="nc">&nbsp;    			break;</b>
&nbsp;    		case EquipmentType.T_ARMOR_REFLECTIVE:
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.RFA, null);</b>
&nbsp;    			break;
&nbsp;    		}
&nbsp;    	}
&nbsp;
<b class="nc">&nbsp;    	if (getAmmo().size() &gt; 0) {</b>
<b class="nc">&nbsp;    		if (isClan()) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.CASE, null);</b>
&nbsp;    		}
&nbsp;    	} else {
<b class="nc">&nbsp;    		specialAbilities.put(BattleForceSPA.ENE, null);</b>
&nbsp;    	}
&nbsp;
<b class="nc">&nbsp;    	if (getAmmo().stream().map(m -&gt; (AmmoType)m.getType())</b>
<b class="nc">&nbsp;    			.anyMatch(at -&gt; at.hasFlag(AmmoType.F_TELE_MISSILE))) {</b>
<b class="nc">&nbsp;    		specialAbilities.put(BattleForceSPA.TELE, null);</b>
&nbsp;    	}
&nbsp;
<b class="nc">&nbsp;    	if (hasEngine()) {</b>
<b class="nc">&nbsp;    		if (getEngine().getEngineType() == Engine.STEAM</b>
<b class="nc">&nbsp;    				&amp;&amp; getEngine().getEngineType() == Engine.FUEL_CELL) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.EE, null);</b>
<b class="nc">&nbsp;    		} else if (getEngine().getEngineType() == Engine.STEAM) {</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.FC, null);</b>
&nbsp;    		} else {
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.EEE, null);</b>
&nbsp;    		}
&nbsp;    	}
&nbsp;
<b class="nc">&nbsp;    	for (Transporter t : getTransports()) {</b>
<b class="nc">&nbsp;    		if (t instanceof ASFBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.AT, (int)((ASFBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.ATxD, ((ASFBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MFB, null);</b>
<b class="nc">&nbsp;    		} else if (t instanceof CargoBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.CT, (int)((CargoBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.CTxD, ((CargoBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    		} else if (t instanceof DockingCollar) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.DT, 1, Integer::sum);</b>
<b class="nc">&nbsp;    		} else if (t instanceof InfantryBay) {</b>
&nbsp;    			// We do not record number of doors for infantry
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.IT, (int)((InfantryBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    		} else if (t instanceof MechBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.MT, (int)((MechBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.MTxD, ((MechBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MFB, null);</b>
<b class="nc">&nbsp;    		} else if (t instanceof ProtomechBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.PT, (int)((ProtomechBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.PTxD, ((ProtomechBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MFB, null);</b>
<b class="nc">&nbsp;    		} else if (t instanceof SmallCraftBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.ST, (int)((SmallCraftBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.STxD, ((SmallCraftBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MFB, null);</b>
<b class="nc">&nbsp;    		} else if (t instanceof LightVehicleBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.VTM, (int)((LightVehicleBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.VTMxD, ((LightVehicleBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MFB, null);</b>
<b class="nc">&nbsp;    		} else if (t instanceof HeavyVehicleBay) {</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.VTH, (int)((HeavyVehicleBay)t).getCapacity(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.merge(BattleForceSPA.VTHxD, ((HeavyVehicleBay)t).getDoors(), Integer::sum);</b>
<b class="nc">&nbsp;    			specialAbilities.put(BattleForceSPA.MFB, null);</b>
&nbsp;    		}
<b class="nc">&nbsp;    	}</b>
&nbsp;
<b class="nc">&nbsp;    	topLoop: for (int location = 0; location &lt; locations(); location++) {</b>
<b class="nc">&nbsp;    		for (int slot = 0; slot &lt; getNumberOfCriticals(location); slot++) {</b>
<b class="nc">&nbsp;    			CriticalSlot crit = getCritical(location, slot);</b>
<b class="nc">&nbsp;    			if (null != crit) {</b>
<b class="nc">&nbsp;    				if (crit.isArmored()) {</b>
<b class="nc">&nbsp;    					specialAbilities.put(BattleForceSPA.ARM, null);</b>
<b class="nc">&nbsp;    					break topLoop;</b>
<b class="nc">&nbsp;    				} else if (crit.getType() == CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;    					Mounted mount = crit.getMount();</b>
<b class="nc">&nbsp;    					if (mount.isArmored()) {</b>
<b class="nc">&nbsp;    						specialAbilities.put(BattleForceSPA.ARM, null);</b>
<b class="nc">&nbsp;    						break topLoop;</b>
&nbsp;    					}
&nbsp;    				}
&nbsp;    			}
&nbsp;    		}
&nbsp;    	}
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getBattleForceSize() {
&nbsp;    	// the default BF Size is for ground Combat elements. Other types will
&nbsp;    	// need to override this
&nbsp;    	// The tables are on page 356 of StartOps
<b class="nc">&nbsp;    	if (getWeight() &lt; 40) {</b>
<b class="nc">&nbsp;    		return 1;</b>
&nbsp;    	}
<b class="nc">&nbsp;    	if (getWeight() &lt; 60) {</b>
<b class="nc">&nbsp;    		return 2;</b>
&nbsp;    	}
<b class="nc">&nbsp;    	if (getWeight() &lt; 80) {</b>
<b class="nc">&nbsp;    		return 3;</b>
&nbsp;    	}
&nbsp;
<b class="nc">&nbsp;    	return 4;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Map&lt;Integer, Coords&gt; getSecondaryPositions() {
<b class="nc">&nbsp;        return secondaryPositions;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if this unit has a functional Blue Shield Particle Field
&nbsp;     * Damper that is turned on
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the entity has a working, switched on blue
&nbsp;     * field &lt;code&gt;false&lt;/code&gt; otherwise
&nbsp;     */
&nbsp;    public boolean hasActiveBlueShield() {
<b class="fc">&nbsp;        if (!isShutDown()) {</b>
<b class="fc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="fc">&nbsp;                EquipmentType type = m.getType();</b>
<b class="fc">&nbsp;                if ((type instanceof MiscType)</b>
<b class="fc">&nbsp;                    &amp;&amp; type.hasFlag(MiscType.F_BLUE_SHIELD)</b>
<b class="nc">&nbsp;                    &amp;&amp; m.curMode().equals(&quot;On&quot;)) {</b>
<b class="nc">&nbsp;                    return !(m.isDestroyed() || m.isMissing() || m.isBreached() || isShutDown());</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getBlueShieldRounds() {
<b class="nc">&nbsp;        return blueShieldRounds;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isDropping() {
<b class="nc">&nbsp;        return isAirborne() &amp;&amp; !(isAero());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * does this unit have stealth armor?
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasStealth() {
&nbsp;        // only non-patchwork stealth actually works as stealth
<b class="nc">&nbsp;        if (((getArmorType(1) == EquipmentType.T_ARMOR_STEALTH) || (getArmorType(1) == EquipmentType</b>
&nbsp;                .T_ARMOR_STEALTH_VEHICLE))
<b class="nc">&nbsp;            &amp;&amp; !hasPatchworkArmor()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes and returns the power amplifier weight for this entity, if any.
&nbsp;     * Returns 0.0 if the entity needs no amplifiers due to engine type or not
&nbsp;     * carrying any weapons requiring them.
&nbsp;     *
&nbsp;     * @return the power amplifier weight in tons.
&nbsp;     */
&nbsp;    public double getPowerAmplifierWeight() {
&nbsp;        // If we&#39;re fusion- or fission-powered, we need no amplifiers to begin
&nbsp;        // with.
<b class="nc">&nbsp;        if (hasEngine() &amp;&amp; (getEngine().isFusion() || (getEngine().getEngineType() == Engine.FISSION))) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;        // Small support vehicles do not need power amplifiers.
<b class="nc">&nbsp;        if (getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;        // Otherwise we need to iterate over our weapons, find out which of them
&nbsp;        // require amplification, and keep a running weight total of those.
<b class="nc">&nbsp;        double total = 0.0;</b>
<b class="nc">&nbsp;        for (Mounted m : getWeaponList()) {</b>
<b class="nc">&nbsp;            WeaponType wt = (WeaponType) m.getType();</b>
<b class="nc">&nbsp;            if ((wt.hasFlag(WeaponType.F_LASER) &amp;&amp; (wt.getAmmoType() == AmmoType.T_NA))</b>
<b class="nc">&nbsp;                    || wt.hasFlag(WeaponType.F_PPC)</b>
<b class="nc">&nbsp;                    || wt.hasFlag(WeaponType.F_PLASMA)</b>
<b class="nc">&nbsp;                    || wt.hasFlag(WeaponType.F_PLASMA_MFUK)</b>
<b class="nc">&nbsp;                    || (wt.hasFlag(WeaponType.F_FLAMER) &amp;&amp; (wt.getAmmoType() == AmmoType.T_NA))) {</b>
<b class="nc">&nbsp;                total += m.getTonnage();</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((m.getLinkedBy() != null) &amp;&amp; (m.getLinkedBy().getType() instanceof</b>
<b class="nc">&nbsp;                    MiscType) &amp;&amp; m.getLinkedBy().getType().</b>
<b class="nc">&nbsp;                    hasFlag(MiscType.F_PPC_CAPACITOR)) {</b>
<b class="nc">&nbsp;                total += m.getLinkedBy().getTonnage();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            if (m.getType().hasFlag(MiscType.F_CLUB) &amp;&amp; m.getType().hasSubType(MiscType.S_SPOT_WELDER)) {</b>
<b class="nc">&nbsp;                total += m.getTonnage();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // Finally use that total to compute and return the actual power
&nbsp;        // amplifier weight.
<b class="nc">&nbsp;        return RoundWeight.nextHalfTon(total);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Vector&lt;Integer&gt; getLoadedKeepers() {
<b class="nc">&nbsp;        return loadedKeepers;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLoadedKeepers(Vector&lt;Integer&gt; v) {
<b class="nc">&nbsp;        loadedKeepers = v;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getExtraC3BV(int baseBV) {
&nbsp;        // extra from c3 networks. a valid network requires at least 2 members
&nbsp;        // some hackery and magic numbers here. could be better
&nbsp;        // also, each &#39;has&#39; loops through all equipment. inefficient to do it 3
&nbsp;        // times
<b class="nc">&nbsp;        int xbv = 0;</b>
<b class="nc">&nbsp;        if ((game != null)</b>
<b class="nc">&nbsp;            &amp;&amp; ((hasC3MM() &amp;&amp; (calculateFreeC3MNodes() &lt; 2))</b>
<b class="nc">&nbsp;                || (hasC3M() &amp;&amp; (calculateFreeC3Nodes() &lt; 3))</b>
<b class="nc">&nbsp;                || (hasC3S() &amp;&amp; (c3Master &gt; NONE)) || ((hasC3i() || hasNavalC3()) &amp;&amp; (calculateFreeC3Nodes() &lt; 5)))) {</b>
<b class="nc">&nbsp;            int totalForceBV = 0;</b>
<b class="nc">&nbsp;            totalForceBV += baseBV;</b>
<b class="nc">&nbsp;            for (Entity e : game.getC3NetworkMembers(this)) {</b>
<b class="nc">&nbsp;                if (!equals(e) &amp;&amp; onSameC3NetworkAs(e)) {</b>
<b class="nc">&nbsp;                    totalForceBV += e.calculateBattleValue(true, true);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            double multiplier = 0.05;</b>
<b class="nc">&nbsp;            if (hasBoostedC3()) {</b>
<b class="nc">&nbsp;                multiplier = 0.07;</b>
&nbsp;            }
<b class="nc">&nbsp;            xbv += totalForceBV * multiplier;</b>
&nbsp;        }
<b class="nc">&nbsp;        return xbv;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasUnloadedUnitsFromBays() {
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if ((next instanceof Bay)</b>
<b class="nc">&nbsp;                &amp;&amp; (((Bay) next).getNumberUnloadedThisTurn() &gt; 0)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean getMovedBackwards() {
<b class="nc">&nbsp;        return movedBackwards;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setMovedBackwards(boolean back) {
<b class="nc">&nbsp;        movedBackwards = back;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isPowerReverse() {
<b class="nc">&nbsp;        return isPowerReverse;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPowerReverse(boolean isPowerReverse) {
<b class="nc">&nbsp;        this.isPowerReverse = isPowerReverse;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tracks whether a WiGE lifted off this turn (or a LAM hovered). Needed to track state
&nbsp;     * in case movement is continued from an interruption, so that the unit does not have a minimum
&nbsp;     * movement for the turn.
&nbsp;     *
&nbsp;     * @return whether a WiGE lifted off during this turn&#39;s movement
&nbsp;     */
&nbsp;    public boolean wigeLiftoffHover() {
<b class="nc">&nbsp;        return wigeLiftoffHover;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWigeLiftoffHover(boolean lifted) {
<b class="nc">&nbsp;        wigeLiftoffHover = lifted;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setHardenedArmorDamaged(HitData hit, boolean damaged) {
<b class="nc">&nbsp;        hardenedArmorDamaged[hit.getLocation()] = damaged;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * do we have a half-hit hardened armor point in the location struck by
&nbsp;     * this?
&nbsp;     *
&nbsp;     * @param hit
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isHardenedArmorDamaged(HitData hit) {
<b class="nc">&nbsp;        return hardenedArmorDamaged[hit.getLocation()];</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLocationBlownOff(int loc, boolean damaged) {
<b class="nc">&nbsp;        locationBlownOff[loc] = damaged;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isLocationBlownOff(int loc) {
<b class="fc">&nbsp;        return locationBlownOff[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks the location as blown off in the current phase. This should be
&nbsp;     * called together with {@link #setLocationBlownOff(int, boolean) } whenever
&nbsp;     * a location gets blown off &lt;em&gt;during play&lt;/em&gt;, to allow relevant methods
&nbsp;     * (notably {@link #isLocationBad(int) }) to distinguish between fresh and
&nbsp;     * preexisting damage. A location&#39;s &quot;newly blown off&quot; status resets with the
&nbsp;     * next call to {@link #applyDamage() }.
&nbsp;     *
&nbsp;     * @param loc     Subclass-dependent code for the location.
&nbsp;     * @param damaged The location&#39;s &quot;recently blown off&quot; status.
&nbsp;     */
&nbsp;    public void setLocationBlownOffThisPhase(int loc, boolean damaged) {
<b class="nc">&nbsp;        locationBlownOffThisPhase[loc] = damaged;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Has the indicated location been blown off this phase (as opposed to
&nbsp;     * either earlier or not at all)?
&nbsp;     *
&nbsp;     * @param loc Subclass-dependent code for the location.
&nbsp;     * @return The locations &quot;recently blown off&quot; status.
&nbsp;     */
&nbsp;    public boolean isLocationBlownOffThisPhase(int loc) {
<b class="nc">&nbsp;        return locationBlownOffThisPhase[loc];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * does this entity have patchwork armor?
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasPatchworkArmor() {
<b class="fc">&nbsp;        int type = armorType[0];</b>
<b class="fc">&nbsp;        int level = armorTechLevel[0];</b>
<b class="fc">&nbsp;        for (int i = 1; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;            if ((armorType[i] != type) || (armorTechLevel[i] != level)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasHardenedArmor() {
<b class="nc">&nbsp;        for (int i = 0; i &lt; locations(); i++) {</b>
<b class="nc">&nbsp;            if ((armorType[i] == EquipmentType.T_ARMOR_HARDENED)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the number of turns MASC has been used continuously.
&nbsp;     * &lt;p/&gt;
&nbsp;     * This method should &lt;strong&gt;only&lt;/strong&gt; be used during serialization.
&nbsp;     *
&nbsp;     * @return the &lt;code&gt;int&lt;/code&gt; number of turns MASC has been used.
&nbsp;     */
&nbsp;    public int getMASCTurns() {
<b class="nc">&nbsp;        return nMASCLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the number of turns MASC has been used continuously.
&nbsp;     * &lt;p/&gt;
&nbsp;     * This method should &lt;strong&gt;only&lt;/strong&gt; be used during deserialization.
&nbsp;     *
&nbsp;     * @param turns The &lt;code&gt;int&lt;/code&gt; number of turns MASC has been used.
&nbsp;     */
&nbsp;    public void setMASCTurns(int turns) {
<b class="nc">&nbsp;        nMASCLevel = turns;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if MASC has been used this turn.
&nbsp;     *
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if MASC has been used.
&nbsp;     */
&nbsp;    public boolean isMASCUsed() {
<b class="nc">&nbsp;        return usedMASC;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set whether MASC has been used.
&nbsp;     * &lt;p/&gt;
&nbsp;     * This method should &lt;strong&gt;only&lt;/strong&gt; be used during deserialization.
&nbsp;     *
&nbsp;     * @param used The &lt;code&gt;boolean&lt;/code&gt; whether MASC has been used.
&nbsp;     */
&nbsp;    public void setMASCUsed(boolean used) {
<b class="nc">&nbsp;        usedMASC = used;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getMASCTarget() {
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_ALTERNATE_MASC_ENHANCED)) {</b>
<b class="nc">&nbsp;            return ALTERNATE_MASC_FAILURE_ENHANCED[nMASCLevel];</b>
<b class="nc">&nbsp;        } else if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_ALTERNATE_MASC)) {</b>
<b class="nc">&nbsp;            return ALTERNATE_MASC_FAILURE[nMASCLevel];</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return MASC_FAILURE[nMASCLevel];</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This function cheks for masc failure.
&nbsp;     *
&nbsp;     * @param md         the movement path.
&nbsp;     * @param vDesc      the description off the masc failure. used as output.
&nbsp;     * @param vCriticals contains tuple of intiger and critical slot. used as output.
&nbsp;     * @return true if there was a masc failure.
&nbsp;     */
&nbsp;    public boolean checkForMASCFailure(MovePath md, Vector&lt;Report&gt; vDesc,
&nbsp;                                       HashMap&lt;Integer, List&lt;CriticalSlot&gt;&gt; vCriticals) {
<b class="nc">&nbsp;        if (md.hasActiveMASC()) {</b>
<b class="nc">&nbsp;            boolean bFailure = false;</b>
&nbsp;
&nbsp;            // If usedMASC is already set, then we&#39;ve already checked MASC
&nbsp;            // this turn. If we succeded before, return false.
&nbsp;            // If we failed before, the MASC was destroyed, and we wouldn&#39;t
&nbsp;            // have gotten here (hasActiveMASC would return false)
<b class="nc">&nbsp;            if (!usedMASC) {</b>
<b class="nc">&nbsp;                Mounted masc = getMASC();</b>
<b class="nc">&nbsp;                Mounted superCharger = getSuperCharger();</b>
<b class="nc">&nbsp;                bFailure = doMASCCheckFor(masc, vDesc, vCriticals);</b>
<b class="nc">&nbsp;                boolean bSuperChargeFailure = doMASCCheckFor(superCharger,</b>
&nbsp;                                                             vDesc, vCriticals);
<b class="nc">&nbsp;                usedMASC = true;</b>
<b class="nc">&nbsp;                return bFailure || bSuperChargeFailure;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * check one masc system for failure
&nbsp;     *
&nbsp;     * @param masc
&nbsp;     * @param vDesc
&nbsp;     * @param vCriticals
&nbsp;     * @return
&nbsp;     */
&nbsp;    private boolean doMASCCheckFor(Mounted masc, Vector&lt;Report&gt; vDesc,
&nbsp;                                   HashMap&lt;Integer, List&lt;CriticalSlot&gt;&gt; vCriticals) {
<b class="nc">&nbsp;        if ((masc != null) &amp;&amp; masc.curMode().equals(&quot;Armed&quot;)) {</b>
<b class="nc">&nbsp;            boolean bFailure = false;</b>
<b class="nc">&nbsp;            int nRoll = Compute.d6(2);</b>
<b class="nc">&nbsp;            if (masc.getType().hasSubType(MiscType.S_SUPERCHARGER)</b>
<b class="nc">&nbsp;                &amp;&amp; (((this instanceof Mech) &amp;&amp; ((Mech) this).isIndustrial())</b>
&nbsp;                    || (this instanceof SupportTank) || (this instanceof SupportVTOL))) {
<b class="nc">&nbsp;                nRoll -= 1;</b>
&nbsp;            }
<b class="nc">&nbsp;            usedMASC = true;</b>
<b class="nc">&nbsp;            Report r = new Report(2365);</b>
<b class="nc">&nbsp;            r.subject = getId();</b>
<b class="nc">&nbsp;            r.addDesc(this);</b>
<b class="nc">&nbsp;            r.add(masc.getName());</b>
<b class="nc">&nbsp;            vDesc.addElement(r);</b>
<b class="nc">&nbsp;            r = new Report(2370);</b>
<b class="nc">&nbsp;            r.subject = getId();</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.add(getMASCTarget());</b>
<b class="nc">&nbsp;            r.add(nRoll);</b>
&nbsp;
<b class="nc">&nbsp;            if (nRoll &lt; getMASCTarget()) {</b>
&nbsp;                // uh oh
<b class="nc">&nbsp;                bFailure = true;</b>
<b class="nc">&nbsp;                r.choose(false);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;                if (((MiscType) (masc.getType()))</b>
<b class="nc">&nbsp;                        .hasSubType(MiscType.S_SUPERCHARGER)) {</b>
&nbsp;                    // do the damage - engine crits
<b class="nc">&nbsp;                    int hits = 0;</b>
<b class="nc">&nbsp;                    int roll = Compute.d6(2);</b>
<b class="nc">&nbsp;                    r = new Report(6310);</b>
<b class="nc">&nbsp;                    r.subject = getId();</b>
<b class="nc">&nbsp;                    r.add(roll);</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    if (roll &lt;= 7) {</b>
&nbsp;                        // no effect
<b class="nc">&nbsp;                        r = new Report(6005);</b>
<b class="nc">&nbsp;                        r.subject = getId();</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    } else if ((roll &gt;= 8) &amp;&amp; (roll &lt;= 9)) {</b>
<b class="nc">&nbsp;                        hits = 1;</b>
<b class="nc">&nbsp;                        r = new Report(6315);</b>
<b class="nc">&nbsp;                        r.subject = getId();</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    } else if ((roll &gt;= 10) &amp;&amp; (roll &lt;= 11)) {</b>
<b class="nc">&nbsp;                        hits = 2;</b>
<b class="nc">&nbsp;                        r = new Report(6320);</b>
<b class="nc">&nbsp;                        r.subject = getId();</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
<b class="nc">&nbsp;                    } else if (roll == 12) {</b>
<b class="nc">&nbsp;                        hits = 3;</b>
<b class="nc">&nbsp;                        r = new Report(6325);</b>
<b class="nc">&nbsp;                        r.subject = getId();</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vDesc.addElement(r);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (this instanceof Mech) {</b>
<b class="nc">&nbsp;                        vCriticals.put(Mech.LOC_CT,</b>
&nbsp;                                       new LinkedList&lt;CriticalSlot&gt;());
<b class="nc">&nbsp;                        for (int i = 0; (i &lt; 12) &amp;&amp; (hits &gt; 0); i++) {</b>
<b class="nc">&nbsp;                            CriticalSlot cs = getCritical(Mech.LOC_CT, i);</b>
<b class="nc">&nbsp;                            if ((cs.getType() == CriticalSlot.TYPE_SYSTEM)</b>
<b class="nc">&nbsp;                                &amp;&amp; (cs.getIndex() == Mech.SYSTEM_ENGINE)</b>
<b class="nc">&nbsp;                                &amp;&amp; cs.isHittable()) {</b>
<b class="nc">&nbsp;                                vCriticals.get(Mech.LOC_CT)</b>
<b class="nc">&nbsp;                                          .add(cs);</b>
<b class="nc">&nbsp;                                hits--;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // this must be a Tank
<b class="nc">&nbsp;                        Tank tank = (Tank) this;</b>
<b class="nc">&nbsp;                        boolean vtolStabilizerHit = (this instanceof VTOL)</b>
<b class="nc">&nbsp;                                                    &amp;&amp; tank.isStabiliserHit(VTOL.LOC_ROTOR);</b>
<b class="nc">&nbsp;                        boolean minorMovementDamage = tank</b>
<b class="nc">&nbsp;                                .hasMinorMovementDamage();</b>
<b class="nc">&nbsp;                        boolean moderateMovementDamage = tank</b>
<b class="nc">&nbsp;                                .hasModerateMovementDamage();</b>
<b class="nc">&nbsp;                        boolean heavyMovementDamage = tank</b>
<b class="nc">&nbsp;                                .hasHeavyMovementDamage();</b>
<b class="nc">&nbsp;                        vCriticals.put(Tank.LOC_BODY, new LinkedList&lt;&gt;());</b>
<b class="nc">&nbsp;                        vCriticals.put(-1, new LinkedList&lt;&gt;());</b>
<b class="nc">&nbsp;                        if (tank instanceof VTOL) {</b>
<b class="nc">&nbsp;                            vCriticals.put(VTOL.LOC_ROTOR, new LinkedList&lt;&gt;());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        for (int i = 0; i &lt; hits; i++) {</b>
<b class="nc">&nbsp;                            if (tank instanceof VTOL) {</b>
<b class="nc">&nbsp;                                if (vtolStabilizerHit) {</b>
<b class="nc">&nbsp;                                    vCriticals.get(Tank.LOC_BODY).add(new CriticalSlot(</b>
&nbsp;                                                      CriticalSlot.TYPE_SYSTEM,
&nbsp;                                                      Tank.CRIT_ENGINE));
&nbsp;                                } else {
<b class="nc">&nbsp;                                    vCriticals</b>
<b class="nc">&nbsp;                                            .get(VTOL.LOC_ROTOR).add(new CriticalSlot(</b>
&nbsp;                                                    CriticalSlot.TYPE_SYSTEM,
&nbsp;                                                    VTOL.CRIT_FLIGHT_STABILIZER));
<b class="nc">&nbsp;                                    vtolStabilizerHit = true;</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (heavyMovementDamage) {</b>
<b class="nc">&nbsp;                                    vCriticals.get(Tank.LOC_BODY).add(new CriticalSlot(</b>
&nbsp;                                                      CriticalSlot.TYPE_SYSTEM,
&nbsp;                                                      Tank.CRIT_ENGINE));
<b class="nc">&nbsp;                                } else if (moderateMovementDamage) {</b>
&nbsp;                                    // HACK: we abuse the criticalslot item to
&nbsp;                                    // signify the calling function to deal
&nbsp;                                    // movement damage
<b class="nc">&nbsp;                                    vCriticals</b>
<b class="nc">&nbsp;                                            .get(-1).add(new CriticalSlot(</b>
&nbsp;                                                    CriticalSlot.TYPE_SYSTEM, 3));
<b class="nc">&nbsp;                                    heavyMovementDamage = true;</b>
<b class="nc">&nbsp;                                } else if (minorMovementDamage) {</b>
&nbsp;                                    // HACK: we abuse the criticalslot item to
&nbsp;                                    // signify the calling function to deal
&nbsp;                                    // movement damage
<b class="nc">&nbsp;                                    vCriticals</b>
<b class="nc">&nbsp;                                            .get(-1).add(new CriticalSlot(</b>
&nbsp;                                                    CriticalSlot.TYPE_SYSTEM, 2));
<b class="nc">&nbsp;                                    moderateMovementDamage = true;</b>
&nbsp;                                } else {
&nbsp;                                    // HACK: we abuse the criticalslot item to
&nbsp;                                    // signify the calling function to deal
&nbsp;                                    // movement damage
<b class="nc">&nbsp;                                    vCriticals</b>
<b class="nc">&nbsp;                                            .get(-1).add(new CriticalSlot(</b>
&nbsp;                                                    CriticalSlot.TYPE_SYSTEM, 1));
<b class="nc">&nbsp;                                    minorMovementDamage = true;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // do the damage.
&nbsp;                    // random crit on each leg, but MASC is not destroyed
<b class="nc">&nbsp;                    for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;                        if (locationIsLeg(loc)</b>
<b class="nc">&nbsp;                            &amp;&amp; (getHittableCriticals(loc) &gt; 0)) {</b>
<b class="nc">&nbsp;                            CriticalSlot slot = null;</b>
&nbsp;                            do {
<b class="nc">&nbsp;                                int slotIndex = Compute</b>
<b class="nc">&nbsp;                                        .randomInt(getNumberOfCriticals(loc));</b>
<b class="nc">&nbsp;                                slot = getCritical(loc, slotIndex);</b>
<b class="nc">&nbsp;                            } while ((slot == null) || !slot.isHittable());</b>
<b class="nc">&nbsp;                            vCriticals.put(loc, new LinkedList&lt;&gt;());</b>
<b class="nc">&nbsp;                            vCriticals.get(loc).add(slot);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                // failed a PSR, check for stalling
<b class="nc">&nbsp;                doCheckEngineStallRoll(vDesc);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.choose(true);</b>
<b class="nc">&nbsp;                vDesc.addElement(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            return bFailure;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get non-supercharger MASC mounted on this entity
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Mounted getMASC() {
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            MiscType mtype = (MiscType) m.getType();</b>
<b class="nc">&nbsp;            if (mtype.hasFlag(MiscType.F_MASC) &amp;&amp; m.isReady()</b>
<b class="nc">&nbsp;                &amp;&amp; !mtype.hasSubType(MiscType.S_SUPERCHARGER)</b>
<b class="nc">&nbsp;                &amp;&amp; !mtype.hasSubType(MiscType.S_JETBOOSTER)) {</b>
<b class="nc">&nbsp;                return m;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get a supercharger mounted on this mech
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Mounted getSuperCharger() {
<b class="nc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;            MiscType mtype = (MiscType) m.getType();</b>
<b class="nc">&nbsp;            if (mtype.hasFlag(MiscType.F_MASC) &amp;&amp; m.isReady()</b>
<b class="nc">&nbsp;                &amp;&amp; mtype.hasSubType(MiscType.S_SUPERCHARGER)) {</b>
<b class="nc">&nbsp;                return m;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract int getEngineHits();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of destroyed jump jets.
&nbsp;     */
&nbsp;    public int damagedJumpJets() {
<b class="nc">&nbsp;        int jumpJets = 0;</b>
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            EquipmentType etype = mounted.getType();</b>
<b class="nc">&nbsp;            if (!mounted.isDestroyed()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (etype.hasFlag(MiscType.F_JUMP_JET)) {</b>
<b class="nc">&nbsp;                jumpJets++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return jumpJets;</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract String getLocationDamage(int loc);
&nbsp;
&nbsp;    /**
&nbsp;     * This method returns a true if the unit can reasonably escape from the
&nbsp;     * board. It can be used to determine whether some non-destroyed units
&nbsp;     * should be considered possible salvage.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean canEscape() {
<b class="nc">&nbsp;        if(null == getCrew()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        //if the crew is unconscious, dead, or ejected, no escape
<b class="nc">&nbsp;        if(getCrew().isUnconscious()</b>
<b class="nc">&nbsp;                || getCrew().isDead()</b>
<b class="nc">&nbsp;                || (getCrew().isEjected() &amp;&amp; !(this instanceof EjectedCrew))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //what else? If its permaneantly immobilized or shutdown it can&#39;t escape
&nbsp;        //TODO: should stalled and stuck be here?
<b class="nc">&nbsp;        return !isPermanentlyImmobilized(false) &amp;&amp; !isShutDown();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns TRUE if the entity meets the requirements for crippling damage as
&nbsp;     * detailed in TW pg 258.
&nbsp;     *
&nbsp;     * @return boolean
&nbsp;     */
&nbsp;    public abstract boolean isCrippled();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns TRUE if the entity meets the requirements for crippling damage as
&nbsp;     * detailed in TW pg 258. Excepting dead or non-existing crew issues
&nbsp;     *
&nbsp;     * @return boolean
&nbsp;     */
&nbsp;    public abstract boolean isCrippled(boolean checkCrew);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns TRUE if the entity has been heavily damaged.
&nbsp;     *
&nbsp;     * @return boolean
&nbsp;     */
&nbsp;    public abstract boolean isDmgHeavy();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns TRUE if the entity has been moderately damaged.
&nbsp;     *
&nbsp;     * @return boolean
&nbsp;     */
&nbsp;    public abstract boolean isDmgModerate();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns TRUE if the entity has been lightly damaged.
&nbsp;     *
&nbsp;     * @return boolean
&nbsp;     */
&nbsp;    public abstract boolean isDmgLight();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity&#39;s current damage level.
&nbsp;     *
&nbsp;     * @return DMG_CRIPLED, DMG_HEAVY, DMG_MODERATE, DMG_LIGHT or DMG_NONE.
&nbsp;     */
&nbsp;    public int getDamageLevel() {
<b class="nc">&nbsp;        return getDamageLevel(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity&#39;s current damage level.
&nbsp;     *
&nbsp;     * @return DMG_CRIPLED, DMG_HEAVY, DMG_MODERATE, DMG_LIGHT or DMG_NONE.
&nbsp;     */
&nbsp;    public int getDamageLevel(boolean checkCrew) {
<b class="nc">&nbsp;        if (isCrippled(checkCrew)) {</b>
<b class="nc">&nbsp;            return DMG_CRIPPLED;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isDmgHeavy()) {</b>
<b class="nc">&nbsp;            return DMG_HEAVY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isDmgModerate()) {</b>
<b class="nc">&nbsp;            return DMG_MODERATE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isDmgLight()) {</b>
<b class="nc">&nbsp;            return DMG_LIGHT;</b>
&nbsp;        }
<b class="nc">&nbsp;        return DMG_NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Make a UUID for this entity and assign it to entity&#39;s String c3UUID
&nbsp;    public void setC3UUID() {
<b class="nc">&nbsp;        UUID id = UUID.randomUUID();</b>
&nbsp;
<b class="nc">&nbsp;        setC3UUIDAsString(id.toString());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setC3UUIDAsString(String c3id) {
<b class="nc">&nbsp;        c3UUID = c3id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getC3UUIDAsString() {
<b class="nc">&nbsp;        return c3UUID;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setC3MasterIsUUIDAsString(String c3id) {
<b class="nc">&nbsp;        c3MasterIsUUID = c3id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getC3MasterIsUUIDAsString() {
<b class="nc">&nbsp;        return c3MasterIsUUID;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setC3iNextUUIDAsString(int pos, String c3id) {
<b class="nc">&nbsp;        c3iUUIDs[pos] = c3id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getC3iNextUUIDAsString(int pos) {
<b class="nc">&nbsp;        return c3iUUIDs[pos];</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFreeC3iUUID() {
<b class="nc">&nbsp;        int pos = 0;</b>
<b class="nc">&nbsp;        while (c3iUUIDs[pos] != null) {</b>
<b class="nc">&nbsp;            pos++;</b>
<b class="nc">&nbsp;            if (pos &gt;= MAX_C3i_NODES) {</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return pos;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setNC3NextUUIDAsString(int pos, String c3id) {
<b class="nc">&nbsp;        NC3UUIDs[pos] = c3id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getNC3NextUUIDAsString(int pos) {
<b class="nc">&nbsp;        return NC3UUIDs[pos];</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getFreeNC3UUID() {
<b class="nc">&nbsp;        int pos = 0;</b>
<b class="nc">&nbsp;        while (NC3UUIDs[pos] != null) {</b>
<b class="nc">&nbsp;            pos++;</b>
<b class="nc">&nbsp;            if (pos &gt;= MAX_C3i_NODES) {</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return pos;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if a unit was physically struck (punch, kick, DFA, etc).
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean wasStruck() {
<b class="nc">&nbsp;        return struck;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if a unit was physically struck (punch, kick, DFA, etc).
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public void setStruck(boolean struck) {
<b class="nc">&nbsp;        this.struck = struck;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if a unit has falling in the current phase.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean hasFallen() {
<b class="nc">&nbsp;        return fell;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if a unit has falling in the current phase.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public void setFallen(boolean fell) {
<b class="nc">&nbsp;        this.fell = fell;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This is used to get an alternative cost that will be added to the
&nbsp;     * MechSummaryCache - at the moment it is primarily used to rework infantry
&nbsp;     * costs for MekHQ, but it could be applied to other unit types as well -
&nbsp;     * defaults to -1, so there is no confusion
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public double getAlternateCost() {
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Are we trapped inside of a destroyed transport? If so we shouldn&#39;t count
&nbsp;     * for BV, which is why we have this check.
&nbsp;     */
&nbsp;    public boolean isTrapped() {
<b class="nc">&nbsp;        if (getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;            Entity transport = game.getEntity(getTransportId());</b>
<b class="nc">&nbsp;            if (transport == null) {</b>
<b class="nc">&nbsp;                transport = game.getOutOfGameEntity(getTransportId());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (transport.isDestroyed()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Deal with per entity camo
&nbsp;    public Camouflage getCamouflage() {
<b class="nc">&nbsp;        return camouflage;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Camouflage getCamouflageOrElse(Camouflage camouflage) {
<b class="nc">&nbsp;        return getCamouflage().hasDefaultCategory() ? camouflage : getCamouflage();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCamouflage(Camouflage camouflage) {
<b class="nc">&nbsp;        this.camouflage = camouflage;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public void setCamoCategory(String name) {
<b class="nc">&nbsp;        getCamouflage().setCategory(name);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public String getCamoCategory() {
<b class="nc">&nbsp;        return getCamouflage().getCategory();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public void setCamoFileName(String name) {
<b class="nc">&nbsp;        getCamouflage().setFilename(name);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public String getCamoFileName() {
<b class="nc">&nbsp;        return getCamouflage().getFilename();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean getSelfDestructing() {
<b class="nc">&nbsp;        return selfDestructing;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSelfDestructing(boolean tf) {
<b class="nc">&nbsp;        selfDestructing = tf;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getSelfDestructInitiated() {
<b class="nc">&nbsp;        return selfDestructInitiated;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSelfDestructInitiated(boolean tf) {
<b class="nc">&nbsp;        selfDestructInitiated = tf;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getSelfDestructedThisTurn() {
<b class="nc">&nbsp;        return selfDestructedThisTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSelfDestructedThisTurn(boolean tf) {
<b class="fc">&nbsp;        selfDestructedThisTurn = tf;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setIsJumpingNow(boolean jumped) {
<b class="nc">&nbsp;        isJumpingNow = jumped;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean getIsJumpingNow() {
<b class="nc">&nbsp;        return isJumpingNow;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setConvertingNow(boolean converting) {
<b class="nc">&nbsp;        convertingNow = converting;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isConvertingNow() {
<b class="nc">&nbsp;        return convertingNow;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getConversionMode() {
<b class="nc">&nbsp;        return conversionMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Units capable of converting mode should override this to perform any other necessary changes.
&nbsp;     * @param mode
&nbsp;     */
&nbsp;    public void setConversionMode(int mode) {
<b class="nc">&nbsp;        conversionMode = mode;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Entities that can convert movement modes (LAMs, QuadVees) report the next mode to assume
&nbsp;     * when a convert movement command is processed. This provides a set order for cycling through
&nbsp;     * available modes.
&nbsp;     *
&nbsp;     * @param afterMode The movement mode to convert from.
&nbsp;     * @return          The next movement mode in the sequence.
&nbsp;     */
&nbsp;    public EntityMovementMode nextConversionMode(EntityMovementMode afterMode) {
<b class="nc">&nbsp;        return movementMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the movement mode to the next in the conversion sequence for QuadVees, LAMs, and Mechs
&nbsp;     * with tracks. In most cases this switches between two available modes, but LAMs that start
&nbsp;     * the turn in AirMech mode have three available.
&nbsp;     */
&nbsp;    public void toggleConversionMode() {
<b class="nc">&nbsp;        setMovementMode(nextConversionMode(movementMode));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Only applicable to Mechs, but here for convenience. Mechs that are already prone, or
&nbsp;     * QuadVees and LAMs in non-leg mode are not subject to PSRs for falling. Note that PSRs
&nbsp;     * are sometimes required for other reasons.
&nbsp;     *
&nbsp;     * @param gyroLegDamage Whether the potential fall is due to damage to gyro or leg actuators,
&nbsp;     *                      in which case Mechs using tracks are not subject to falls.
&nbsp;     * @return              Whether the &lt;code&gt;Entity&lt;/code&gt; is required to make PSRs to avoid falling.
&nbsp;     */
&nbsp;    public boolean canFall(boolean gyroLegDamage) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only applicable to Mechs, but here for convenience. Mechs that are already prone, or
&nbsp;     * QuadVees and LAMs in fighter mode are not subject to PSRs for falling. Note that PSRs
&nbsp;     * are sometimes required for other reasons.
&nbsp;     *
&nbsp;     * @return Whether the &lt;code&gt;Entity&lt;/code&gt; is required to make PSRs to avoid falling.
&nbsp;     */
&nbsp;    public boolean canFall() {
<b class="nc">&nbsp;        return canFall(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setTraitorId(int id) {
<b class="nc">&nbsp;        traitorId = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getTraitorId() {
<b class="nc">&nbsp;        return traitorId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine net velocity of ramming attack
&nbsp;     */
&nbsp;    public int sideTableRam(Coords src) {
<b class="nc">&nbsp;        return sideTableRam(src, facing);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int sideTableRam(Coords src, int facing) {
<b class="nc">&nbsp;        int fa = (getPosition().degree(src) + ((6 - facing) * 60)) % 360;</b>
<b class="nc">&nbsp;        if (((fa &gt; 30) &amp;&amp; (fa &lt;= 90)) || ((fa &lt; 330) &amp;&amp; (fa &gt;= 270))) {</b>
<b class="nc">&nbsp;            return Aero.RAM_TOWARD_OBL;</b>
<b class="nc">&nbsp;        } else if ((fa &gt; 150) &amp;&amp; (fa &lt; 210)) {</b>
<b class="nc">&nbsp;            return Aero.RAM_AWAY_DIR;</b>
<b class="nc">&nbsp;        } else if (((fa &gt; 90) &amp;&amp; (fa &lt;= 150)) || ((fa &lt; 270) &amp;&amp; (fa &gt;= 210))) {</b>
<b class="nc">&nbsp;            return Aero.RAM_AWAY_OBL;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return Aero.RAM_TOWARD_DIR;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setArmorTonnage(double ton) {
<b class="fc">&nbsp;        armorTonnage = ton;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public double getLabArmorTonnage() {
<b class="nc">&nbsp;        return armorTonnage;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getLabTotalArmorPoints() {
<b class="nc">&nbsp;        if (isSupportVehicle() &amp;&amp; (getArmorType(firstArmorIndex()) == EquipmentType.T_ARMOR_STANDARD)</b>
<b class="nc">&nbsp;            &amp;&amp; !hasPatchworkArmor()) {</b>
<b class="nc">&nbsp;            return (int) Math.floor(armorTonnage</b>
<b class="nc">&nbsp;                    / EquipmentType.getSupportVehicleArmorWeightPerPoint(getBARRating(firstArmorIndex()),</b>
<b class="nc">&nbsp;                    getArmorTechRating()));</b>
&nbsp;        }
<b class="nc">&nbsp;        double armorPerTon = 16.0 * EquipmentType.getArmorPointMultiplier(</b>
&nbsp;                armorType[0], armorTechLevel[0]);
<b class="nc">&nbsp;        return (int) Math.floor(armorPerTon * armorTonnage);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void loadDefaultCustomWeaponOrder() {
<b class="fc">&nbsp;        WeaponOrderHandler.WeaponOrder weapOrder = WeaponOrderHandler.getWeaponOrder(</b>
<b class="fc">&nbsp;                getChassis(), getModel());</b>
&nbsp;
<b class="fc">&nbsp;        if (weapOrder != null) {</b>
<b class="nc">&nbsp;            setWeaponSortOrder(weapOrder.orderType);</b>
<b class="nc">&nbsp;            setCustomWeaponOrder(weapOrder.customWeaponOrderMap);</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void loadDefaultQuirks() {
&nbsp;
&nbsp;        // Get a list of quirks for this entity.
<b class="fc">&nbsp;        List&lt;QuirkEntry&gt; quirks = QuirksHandler.getQuirks(this);</b>
&nbsp;
&nbsp;        // If this unit has no quirks, we do not need to proceed further.
<b class="fc">&nbsp;        if ((quirks == null) || quirks.isEmpty()) {</b>
<b class="fc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // System.out.println(&quot;Loading quirks for &quot; + getChassis() + &quot; &quot; +
&nbsp;        // getModel());
&nbsp;
&nbsp;        // Load all the unit&#39;s quirks.
<b class="nc">&nbsp;        for (QuirkEntry q : quirks) {</b>
&nbsp;
&nbsp;            // System.out.print(&quot;  &quot; + q.toLog() + &quot;... &quot;);
&nbsp;
&nbsp;            // If the quirk doesn&#39;t have a location, then it is a unit quirk,
&nbsp;            // not a weapon quirk.
<b class="nc">&nbsp;            if (StringUtil.isNullOrEmpty(q.getLocation())) {</b>
&nbsp;
&nbsp;                // Activate the unit quirk.
<b class="nc">&nbsp;                if (getQuirks().getOption(q.getQuirk()) == null) {</b>
<b class="nc">&nbsp;                    System.out.println(q.toLog() + &quot; failed for &quot;</b>
<b class="nc">&nbsp;                                       + getChassis() + &quot; &quot; + getModel()</b>
&nbsp;                                       + &quot; - Invalid quirk!&quot;);
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                getQuirks().getOption(q.getQuirk()).setValue(true);</b>
&nbsp;                // System.out.println(&quot;Loaded.&quot;);
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Get the weapon in the indicated location and slot.
&nbsp;            // System.out.print(&quot;Getting CriticalSlot... &quot;);
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(getLocationFromAbbr(q.getLocation()),</b>
<b class="nc">&nbsp;                                          q.getSlot());</b>
<b class="nc">&nbsp;            if (cs == null) {</b>
<b class="nc">&nbsp;                System.out.println(q.toLog() + &quot; failed for &quot; + getChassis()</b>
<b class="nc">&nbsp;                                   + &quot; &quot; + getModel() + &quot; - Critical slot (&quot;</b>
<b class="nc">&nbsp;                                   + q.getLocation() + &quot;-&quot; + q.getSlot()</b>
&nbsp;                                   + &quot;) did not load!&quot;);
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted m = cs.getMount();</b>
<b class="nc">&nbsp;            if (m == null) {</b>
<b class="nc">&nbsp;                System.out.println(q.toLog() + &quot; failed for &quot; + getChassis()</b>
<b class="nc">&nbsp;                                   + &quot; &quot; + getModel() + &quot; - Critical slot (&quot;</b>
<b class="nc">&nbsp;                                   + q.getLocation() + &quot;-&quot; + q.getSlot() + &quot;) is empty!&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Make sure this is a weapon.
&nbsp;            // System.out.print(&quot;Getting WeaponType... &quot;);
<b class="nc">&nbsp;            if (!(m.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(m.getType().hasFlag(MiscType.F_CLUB))) {</b>
<b class="nc">&nbsp;                System.out.println(q.toLog() + &quot; failed for &quot; + getChassis()</b>
<b class="nc">&nbsp;                                   + &quot; &quot; + getModel() + &quot; - &quot; + m.getName()</b>
&nbsp;                                   + &quot; is not a weapon!&quot;);
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Make sure it is the weapon we expect.
&nbsp;            // System.out.print(&quot;Matching weapon... &quot;);
<b class="nc">&nbsp;            boolean matchFound = false;</b>
<b class="nc">&nbsp;            Enumeration&lt;String&gt; typeNames = m.getType().getNames();</b>
<b class="nc">&nbsp;            while (typeNames.hasMoreElements()) {</b>
<b class="nc">&nbsp;                String typeName = typeNames.nextElement();</b>
&nbsp;                // System.out.print(typeName + &quot;... &quot;);
<b class="nc">&nbsp;                if (typeName.equals(q.getWeaponName())) {</b>
<b class="nc">&nbsp;                    matchFound = true;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!matchFound) {</b>
<b class="nc">&nbsp;                System.out.println(q.toLog() + &quot; failed for &quot; + getChassis()</b>
<b class="nc">&nbsp;                                   + &quot; &quot; + getModel() + &quot; - &quot; + m.getType().getName()</b>
<b class="nc">&nbsp;                                   + &quot; != &quot; + q.getWeaponName());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Activate the weapon quirk.
&nbsp;            // System.out.print(&quot;Activating quirk... &quot;);
<b class="nc">&nbsp;            if (m.getQuirks().getOption(q.getQuirk()) == null) {</b>
<b class="nc">&nbsp;                System.out.println(q.toLog() + &quot; failed for &quot; + getChassis()</b>
<b class="nc">&nbsp;                                   + &quot; &quot; + getModel() + &quot; - Invalid quirk!&quot;);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            m.getQuirks().getOption(q.getQuirk()).setValue(true);</b>
&nbsp;            // System.out.println(&quot;Loaded.&quot;);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void newPhase(IGame.Phase phase) {
<b class="nc">&nbsp;        for (Mounted m : getEquipment()) {</b>
<b class="nc">&nbsp;            m.newPhase(phase);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (getCrew().isDoomed()) {</b>
<b class="nc">&nbsp;            getCrew().setDoomed(false);</b>
<b class="nc">&nbsp;            getCrew().setDead(true);</b>
<b class="nc">&nbsp;            if (this instanceof Tank) {</b>
<b class="nc">&nbsp;                setCarcass(true);</b>
<b class="nc">&nbsp;                ((Tank) this).immobilize();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                setDestroyed(true);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        setIsJumpingNow(false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if the entities&#39; elevation is below the surface of a water
&nbsp;     * hex.
&nbsp;     *
&nbsp;     * @return True if the entity is underwater, else false.
&nbsp;     */
&nbsp;    public boolean isUnderwater() {
<b class="nc">&nbsp;        IHex occupiedHex = game.getBoard().getHex(getPosition());</b>
<b class="nc">&nbsp;        if (occupiedHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;            &amp;&amp; (relHeight() &lt; occupiedHex.surface())) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getTechLevelYear() {
<b class="fc">&nbsp;        if (game != null) {</b>
<b class="nc">&nbsp;            return game.getOptions().intOption(OptionsConstants.ALLOWED_YEAR);</b>
&nbsp;        }
<b class="fc">&nbsp;        return year;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getTargetBay() {
<b class="nc">&nbsp;        return targetBay;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setTargetBay(int tb) {
<b class="nc">&nbsp;        targetBay = tb;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public abstract long getEntityType();
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that checks whether a bit is set in the entity type field.
&nbsp;     *
&nbsp;     * @param flag An ETYPE_* value
&nbsp;     * @return     true if getEntityType() has the flag set
&nbsp;     */
&nbsp;    public boolean hasETypeFlag(long flag) {
<b class="fc">&nbsp;        return (getEntityType() &amp; flag) == flag;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given an Entity type, return the name of the major class it belongs to
&nbsp;     * (eg: Mech, Aero, Tank, Infantry).
&nbsp;     *
&nbsp;     * @param typeId The type Id to get a major name for
&nbsp;     * @return The major class name for the given type id
&nbsp;     */
&nbsp;    public static String getEntityMajorTypeName(long typeId) {
<b class="nc">&nbsp;        if ((typeId &amp; ETYPE_MECH) == ETYPE_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_AERO) == ETYPE_AERO) {</b>
<b class="nc">&nbsp;            return &quot;Aero&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_VTOL) == ETYPE_VTOL) {</b>
<b class="nc">&nbsp;            return &quot;VTOL&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_TANK) == ETYPE_TANK) {</b>
<b class="nc">&nbsp;            return &quot;Tank&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_INFANTRY) == ETYPE_INFANTRY) {</b>
<b class="nc">&nbsp;            return &quot;Infantry&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_PROTOMECH) == ETYPE_PROTOMECH) {</b>
<b class="nc">&nbsp;            return &quot;Protomech&quot;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return &quot;Unknown&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the specific entity type name for the given type id
&nbsp;     * (eg: Biped Mech, Conventional Fighter, VTOL).
&nbsp;     *
&nbsp;     * @param typeId
&nbsp;     * @return
&nbsp;     */
&nbsp;    public static String getEntityTypeName(long typeId) {
&nbsp;
<b class="nc">&nbsp;        if ((typeId &amp; ETYPE_BIPED_MECH) == ETYPE_BIPED_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Biped Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_LAND_AIR_MECH) == ETYPE_LAND_AIR_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Landair Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_QUAD_MECH) == ETYPE_QUAD_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Quad Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_TRIPOD_MECH) == ETYPE_TRIPOD_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Tripod Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_ARMLESS_MECH) == ETYPE_ARMLESS_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Armless Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_MECH) == ETYPE_MECH) {</b>
<b class="nc">&nbsp;            return &quot;Mech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_JUMPSHIP) == ETYPE_JUMPSHIP) {</b>
<b class="nc">&nbsp;            return &quot;JumpShip&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_WARSHIP) == ETYPE_WARSHIP) {</b>
<b class="nc">&nbsp;            return &quot;WarShip&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_SPACE_STATION) == ETYPE_SPACE_STATION) {</b>
<b class="nc">&nbsp;            return &quot;Space Station&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_CONV_FIGHTER) == ETYPE_CONV_FIGHTER) {</b>
<b class="nc">&nbsp;            return &quot;Conventional Fighter&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_FIXED_WING_SUPPORT) == ETYPE_FIXED_WING_SUPPORT) {</b>
<b class="nc">&nbsp;            return &quot;Fixed Wing Support&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_FIGHTER_SQUADRON) == ETYPE_FIGHTER_SQUADRON) {</b>
<b class="nc">&nbsp;            return &quot;Fighter Squadron&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_SMALL_CRAFT) == ETYPE_SMALL_CRAFT) {</b>
<b class="nc">&nbsp;            return &quot;Small Craft&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_DROPSHIP) == ETYPE_DROPSHIP) {</b>
<b class="nc">&nbsp;            return &quot;DropShip&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_TELEMISSILE) == ETYPE_TELEMISSILE) {</b>
<b class="nc">&nbsp;            return &quot;Telemissile&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_AERO) == ETYPE_AERO) {</b>
<b class="nc">&nbsp;            return &quot;Aerospace fighter&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_BATTLEARMOR) == ETYPE_BATTLEARMOR) {</b>
<b class="nc">&nbsp;            return &quot;Battlearmor&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_MECHWARRIOR) == ETYPE_MECHWARRIOR) {</b>
<b class="nc">&nbsp;            return &quot;Mechwarrior&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_PROTOMECH) == ETYPE_PROTOMECH) {</b>
<b class="nc">&nbsp;            return &quot;ProtoMech&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_INFANTRY) == ETYPE_INFANTRY) {</b>
<b class="nc">&nbsp;            return &quot;Infantry&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_GUN_EMPLACEMENT) == ETYPE_GUN_EMPLACEMENT) {</b>
<b class="nc">&nbsp;            return &quot;Gun Emplacement&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_SUPER_HEAVY_TANK) == ETYPE_SUPER_HEAVY_TANK) {</b>
<b class="nc">&nbsp;            return &quot;Superheavy Tank&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_SUPPORT_TANK) == ETYPE_SUPPORT_TANK) {</b>
<b class="nc">&nbsp;            return &quot;Support Tank&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_LARGE_SUPPORT_TANK) == ETYPE_LARGE_SUPPORT_TANK) {</b>
<b class="nc">&nbsp;            return &quot;Large Support Tank&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_VTOL) == ETYPE_VTOL) {</b>
<b class="nc">&nbsp;            return &quot;VTOL&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_SUPPORT_VTOL) == ETYPE_SUPPORT_VTOL) {</b>
<b class="nc">&nbsp;            return &quot;Support VTOL&quot;;</b>
<b class="nc">&nbsp;        } else if ((typeId &amp; ETYPE_TANK) == ETYPE_TANK) {</b>
<b class="nc">&nbsp;            return &quot;Tank&quot;;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return &quot;Unknown&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void damageSystem(int type, int slot, int hits) {
<b class="nc">&nbsp;        for (int loc = 0; loc &lt; locations(); loc++) {</b>
<b class="nc">&nbsp;            damageSystem(type, slot, loc, hits);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void damageSystem(int type, int slot, int loc, int hits) {
<b class="nc">&nbsp;        int nhits = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; getNumberOfCriticals(loc); i++) {</b>
<b class="nc">&nbsp;            CriticalSlot cs = getCritical(loc, i);</b>
&nbsp;            // ignore empty &amp; system slots
<b class="nc">&nbsp;            if ((cs == null) || (cs.getType() != type)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            Mounted m = null;</b>
<b class="nc">&nbsp;            if (type == CriticalSlot.TYPE_EQUIPMENT) {</b>
<b class="nc">&nbsp;                m = getEquipment(slot);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((type == CriticalSlot.TYPE_SYSTEM) &amp;&amp; (cs.getIndex() == slot))</b>
&nbsp;                || ((type == CriticalSlot.TYPE_EQUIPMENT)
<b class="nc">&nbsp;                    &amp;&amp; (m.equals(cs.getMount()) || m.equals(cs.getMount2())))) {</b>
<b class="nc">&nbsp;                if (nhits &lt; hits) {</b>
<b class="nc">&nbsp;                    cs.setHit(true);</b>
<b class="nc">&nbsp;                    cs.setDestroyed(true);</b>
<b class="nc">&nbsp;                    nhits++;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    cs.setHit(false);</b>
<b class="nc">&nbsp;                    cs.setDestroyed(false);</b>
<b class="nc">&nbsp;                    cs.setRepairable(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Most units cannot eject.
&nbsp;    // ToDo Look up ejection rules for ASF.
&nbsp;    public boolean isEjectionPossible() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAllowedPhysicalAttacks() {
<b class="nc">&nbsp;        if ((null != crew) &amp;&amp; hasAbility(OptionsConstants.PILOT_MELEE_MASTER)) {</b>
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The max weapons range of this entity, taking into account whether or not
&nbsp;     * we&#39;re on an air/space map, using extreme range. Assumes target is not airborne
&nbsp;     * if we are on a ground map.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getMaxWeaponRange() {
<b class="nc">&nbsp;        return getMaxWeaponRange(false);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * The max weapons range of this entity, taking into account whether or not
&nbsp;     * we&#39;re on an air/space map, using extreme range, and whether or not the target is
&nbsp;     * air borne.
&nbsp;     * @param targetIsAirborne
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getMaxWeaponRange(boolean targetIsAirborne) {
&nbsp;        // Aeros on the ground map must shoot along their flight path, giving
&nbsp;        // them effectively 0 range
<b class="nc">&nbsp;        if (isAirborneAeroOnGroundMap() &amp;&amp; !targetIsAirborne) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int maxRange = 0;</b>
<b class="nc">&nbsp;        if ((ETYPE_MECH == getEntityType())</b>
<b class="nc">&nbsp;                || (ETYPE_INFANTRY == getEntityType())</b>
<b class="nc">&nbsp;                || (ETYPE_PROTOMECH == getEntityType())) {</b>
&nbsp;            // account for physical attacks.
<b class="nc">&nbsp;            maxRange = 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Mounted weapon : getWeaponList()) {</b>
<b class="nc">&nbsp;            if (!weapon.isReady()) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            WeaponType type = (WeaponType) weapon.getType();</b>
&nbsp;            int range;
&nbsp;            
<b class="nc">&nbsp;            if(isAirborne()) {</b>
<b class="nc">&nbsp;                int rangeMultiplier = type.isCapital() ? 2 : 1;</b>
<b class="nc">&nbsp;                rangeMultiplier *= isAirborneAeroOnGroundMap() ? 8 : 1;</b>
&nbsp;                
<b class="nc">&nbsp;                range = WeaponType.AIRBORNE_WEAPON_RANGES[type.getMaxRange(weapon)] * rangeMultiplier;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                range = (game.getOptions().booleanOption(</b>
<b class="nc">&nbsp;                    OptionsConstants.ADVCOMBAT_TACOPS_RANGE) ? type.getExtremeRange()</b>
<b class="nc">&nbsp;                    : type.getLongRange());</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (range &gt; maxRange) {</b>
<b class="nc">&nbsp;                maxRange = range;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return maxRange;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getHeat() {
<b class="nc">&nbsp;        return heat;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getTsempHitsThisTurn() {
<b class="fc">&nbsp;        return tsempHitsThisTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addTsempHitThisTurn() {
<b class="nc">&nbsp;        tsempHitsThisTurn++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getTsempEffect() {
<b class="fc">&nbsp;        return tsempEffect;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setTsempEffect(int tsempEffect) {
<b class="fc">&nbsp;        this.tsempEffect = tsempEffect;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isFiredTsempThisTurn() {
<b class="fc">&nbsp;        return firedTsempThisTurn;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setFiredTsempThisTurn(boolean firedTsempThisTurn) {
<b class="fc">&nbsp;        this.firedTsempThisTurn = firedTsempThisTurn;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean hasFiredTsemp() {
<b class="fc">&nbsp;        return hasFiredTsemp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setHasFiredTsemp(boolean hasFiredTSEMP) {
<b class="nc">&nbsp;        hasFiredTsemp = hasFiredTSEMP;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Sets the number of rounds that the entity is affected by an ASEW missile
&nbsp;     * @param turns - integer specifying the number of end phases that the effects last through
&nbsp;     * Technically, about 1.5 turns elapse per the rules for ASEW missiles in TO
&nbsp;     */
&nbsp;    public void setASEWAffected(int turns) {
<b class="nc">&nbsp;        asewAffectedTurns = turns;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Returns the number of rounds that the entity is affected by an ASEW missile
&nbsp;     */
&nbsp;    public int getASEWAffected() {
<b class="nc">&nbsp;        return asewAffectedTurns;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasActivatedRadicalHS() {
<b class="fc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="fc">&nbsp;            if (m.getType().hasFlag(MiscType.F_RADICAL_HEATSINK)</b>
<b class="nc">&nbsp;                &amp;&amp; m.curMode().equals(&quot;On&quot;)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void deactivateRadicalHS() {
<b class="fc">&nbsp;        for (Mounted m : getMisc()) {</b>
<b class="fc">&nbsp;            if (m.getType().hasFlag(MiscType.F_RADICAL_HEATSINK)) {</b>
<b class="nc">&nbsp;                m.setMode(&quot;Off&quot;);</b>
&nbsp;                // Can only have one radical heat sink
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getConsecutiveRHSUses() {
<b class="fc">&nbsp;        return consecutiveRHSUses;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setConsecutiveRHSUses(int consecutiveRHSUses) {
<b class="fc">&nbsp;        this.consecutiveRHSUses = consecutiveRHSUses;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean hasDamagedRHS() {
<b class="nc">&nbsp;        return hasDamagedRHS;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setHasDamagedRHS(boolean hasDamagedRHS) {
<b class="nc">&nbsp;        this.hasDamagedRHS = hasDamagedRHS;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isUseGeometricBV() {
<b class="nc">&nbsp;        return useGeometricBV;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUseGeometricBV(boolean useGeometricBV) {
<b class="nc">&nbsp;        this.useGeometricBV = useGeometricBV;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isUseReducedOverheatModifierBV() {
<b class="nc">&nbsp;        return useReducedOverheatModifierBV;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUseReducedOverheatModifierBV(boolean useReducedOverheatModifierBV) {
<b class="nc">&nbsp;        this.useReducedOverheatModifierBV = useReducedOverheatModifierBV;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addAttackedByThisTurn(int entityId) {
<b class="nc">&nbsp;        attackedByThisTurn.add(entityId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearAttackedByThisTurn() {
<b class="fc">&nbsp;        attackedByThisTurn.clear();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Collection&lt;Integer&gt; getAttackedByThisTurn() {
<b class="nc">&nbsp;        return new HashSet&lt;&gt;(attackedByThisTurn);</b>
&nbsp;    }
&nbsp;
&nbsp;    public WeaponSortOrder getWeaponSortOrder() {
<b class="nc">&nbsp;        if (weaponSortOrder == null) {</b>
<b class="nc">&nbsp;            return WeaponSortOrder.DEFAULT;</b>
&nbsp;        }
<b class="nc">&nbsp;        return weaponSortOrder;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWeaponSortOrder(WeaponSortOrder weaponSortOrder) {
<b class="nc">&nbsp;        if (weaponSortOrder != this.weaponSortOrder) {</b>
<b class="nc">&nbsp;            setWeapOrderChanged(true);</b>
&nbsp;        }
&nbsp;        // If sort mode is custom, and the custom order is null, create it
&nbsp;        // and make the order the same as default (based on eqId)
<b class="nc">&nbsp;        if ((weaponSortOrder == WeaponSortOrder.CUSTOM)</b>
&nbsp;            &amp;&amp; (customWeapOrder == null)) {
<b class="nc">&nbsp;            customWeapOrder = new HashMap&lt;Integer, Integer&gt;();</b>
<b class="nc">&nbsp;            for (Mounted weap : weaponList) {</b>
<b class="nc">&nbsp;                int eqId = getEquipmentNum(weap);</b>
<b class="nc">&nbsp;                customWeapOrder.put(eqId, eqId);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        this.weaponSortOrder = weaponSortOrder;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Map&lt;Integer, Integer&gt; getCustomWeaponOrder() {
<b class="nc">&nbsp;        return customWeapOrder;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCustomWeaponOrder(Map&lt;Integer, Integer&gt; customWeapOrder) {
<b class="nc">&nbsp;        this.customWeapOrder = customWeapOrder;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getCustomWeaponOrder(Mounted weapon) {
<b class="nc">&nbsp;        int eqId = getEquipmentNum(weapon);</b>
<b class="nc">&nbsp;        if (customWeapOrder == null) {</b>
<b class="nc">&nbsp;            return eqId;</b>
&nbsp;        }
<b class="nc">&nbsp;        Integer order = customWeapOrder.get(eqId);</b>
<b class="nc">&nbsp;        if (order == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return order;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setCustomWeaponOrder(Mounted weapon, int order) {
<b class="nc">&nbsp;        setWeapOrderChanged(true);</b>
<b class="nc">&nbsp;        int eqId = getEquipmentNum(weapon);</b>
<b class="nc">&nbsp;        if (eqId == -1) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        customWeapOrder.put(eqId, order);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isWeapOrderChanged() {
<b class="nc">&nbsp;        return weapOrderChanged;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWeapOrderChanged(boolean weapOrderChanged) {
<b class="nc">&nbsp;        this.weapOrderChanged = weapOrderChanged;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getMpUsedLastRound() {
<b class="nc">&nbsp;        return mpUsedLastRound;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setMpUsedLastRound(int mpUsedLastRound) {
<b class="nc">&nbsp;        this.mpUsedLastRound = mpUsedLastRound;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag that determines if the Entity is a support vehicle.
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isSupportVehicle() {
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return Whether the unit uses primitive or retrotech construction rules
&nbsp;     */
&nbsp;    public boolean isPrimitive() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getStructuralTechRating() {
<b class="nc">&nbsp;        return structuralTechRating;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStructuralTechRating(int structuralTechRating) {
<b class="nc">&nbsp;        this.structuralTechRating = structuralTechRating;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the base engine value for support vehicles, see TM pg 120.  Non
&nbsp;     * support vehicle Entities will return 0.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public double getBaseEngineValue() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the base chassis value for support vehicles, see TM pg 120.  Non
&nbsp;     * support vehicle Entities will return 0.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public double getBaseChassisValue() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getArmorTechRating() {
<b class="nc">&nbsp;        if (armorTechRating == USE_STRUCTURAL_RATING) {</b>
<b class="nc">&nbsp;            return structuralTechRating;</b>
&nbsp;        }
<b class="nc">&nbsp;        return armorTechRating;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setArmorTechRating(int armorTechRating) {
<b class="nc">&nbsp;        this.armorTechRating = armorTechRating;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getEngineTechRating() {
<b class="nc">&nbsp;        if (engineTechRating == USE_STRUCTURAL_RATING) {</b>
<b class="nc">&nbsp;            return structuralTechRating;</b>
&nbsp;        }
<b class="nc">&nbsp;        return engineTechRating;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setEngineTechRating(int engineTechRating) {
<b class="nc">&nbsp;        this.engineTechRating = engineTechRating;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used by omni support vehicles to track the weight of fire control systems.
&nbsp;     * This limits the tonnage that can be devoted to weapons in pods.
&nbsp;     *
&nbsp;     * @return The fixed weight of fire control systems.
&nbsp;     */
&nbsp;    public double getBaseChassisFireConWeight() {
<b class="nc">&nbsp;        return baseChassisFireConWeight;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Used by omni support vehicles to set the weight of fixed fire control systems in the base chassis.
&nbsp;     *
&nbsp;     * @param weight The weight of fixed fire control systems.
&nbsp;     */
&nbsp;    public void setBaseChassisFireConWeight(double weight) {
<b class="nc">&nbsp;        baseChassisFireConWeight = weight;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Units with construction data that varies by year (such as engine and control system weight
&nbsp;     * for some primitive aerospace units) require tracking the original build year separately
&nbsp;     * from the intro year for the model to account for refits that don&#39;t affect the core components.
&nbsp;     *
&nbsp;     * @return The year to use for core component construction data.
&nbsp;     */
&nbsp;    public int getOriginalBuildYear() {
<b class="nc">&nbsp;        if (originalBuildYear &lt; 0) {</b>
<b class="nc">&nbsp;            return year;</b>
&nbsp;        }
<b class="nc">&nbsp;        return originalBuildYear;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOriginalBuildYear(int year) {
<b class="nc">&nbsp;        originalBuildYear = year;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This method (and getActiveSubEntities()) is meant for groups of entities handled as a
&nbsp;     * singular one. Examples include fighter squadrons on space maps or lances in BattleForce
&nbsp;     * game modes.
&nbsp;     * &lt;p&gt;
&nbsp;     * To check if a given entity consists of multiple sub-entities, use
&nbsp;     * &lt;pre&gt;
&nbsp;     * if(entity.getSubEntities().isPresent()) {
&nbsp;     *     ...
&nbsp;     * }
&nbsp;     * &lt;/pre&gt;
&nbsp;     * To iterate over entities (if present), use:
&nbsp;     * &lt;pre&gt;
&nbsp;     * entity.getSubEntities().ifPresent(entities -&gt; entities.forEach(
&nbsp;     *     subEntity -&gt; {
&nbsp;     *         ...
&nbsp;     *     });
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @return an optional collection of sub-entities, if this entity is considered a grouping of them.
&nbsp;     */
&nbsp;    public Optional&lt;List&lt;Entity&gt;&gt; getSubEntities() {
<b class="nc">&nbsp;        return Optional.empty();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The default implementation calls getSubEntities(), then filters them. This might not be
&nbsp;     * the optimal code for many applications, so feel free to override both if needed.
&nbsp;     *
&nbsp;     * @return an optional collection of sub-entities, if this entity is considered a grouping of them,
&nbsp;     *         pre-filtered to only contain active (non-destroyed and non-doomed) entities.
&nbsp;     */
&nbsp;    public Optional&lt;List&lt;Entity&gt;&gt; getActiveSubEntities() {
<b class="nc">&nbsp;        return getSubEntities().map(</b>
<b class="nc">&nbsp;            ents -&gt; ents.stream().filter(</b>
<b class="nc">&nbsp;                ent -&gt; !(ent.isDestroyed() || ent.isDoomed())).collect(Collectors.toList()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine the draw priority of different Entity subclasses.
&nbsp;     * This allows different unit types to always be draw above/below other
&nbsp;     * types.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getSpriteDrawPriority() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Entities that use different sprites for different modes should override this
&nbsp;     * @return a code identifying the mode, or an empty string for the default sprite
&nbsp;     */
&nbsp;    public String getTilesetModeString() {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    //Tractors and trailers, tugs, etc
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine if this vehicle can be towed by a tractor
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isTrailer() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to determine if this vehicle can be the engine/tractor
&nbsp;     * for a bunch of trailers
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public boolean isTractor() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of Coords that need to be checked for entities that can be towed
&nbsp;     * This accounts for the hexes occupied by each entity in the &#39;train&#39;, plus hexes
&nbsp;     * in front of or behind each trailer hitch
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public Set&lt;Coords&gt; getHitchLocations() {
<b class="nc">&nbsp;        Set&lt;Coords&gt; trailerPos = new HashSet&lt;Coords&gt;();</b>
&nbsp;        //First, set up a list of all the entities in this train
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; thisTrain = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        thisTrain.add(this);</b>
<b class="nc">&nbsp;        for (int id : getAllTowedUnits()) {</b>
<b class="nc">&nbsp;            Entity trailer = game.getEntity(id);</b>
<b class="nc">&nbsp;            thisTrain.add(trailer);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        //Check each Entity in the train for working hitches. When found, add the hex
&nbsp;        // that Entity is in and the hex the hitch faces.
<b class="nc">&nbsp;        for (Entity e : thisTrain) {</b>
<b class="nc">&nbsp;            for (Transporter t : e.getTransports()) {</b>
<b class="nc">&nbsp;                if ((t instanceof TankTrailerHitch) &amp;&amp; (t.getUnused() &gt; 0)) {</b>
<b class="nc">&nbsp;                    trailerPos.add(e.getPosition());</b>
<b class="nc">&nbsp;                    int dir = e.getFacing();</b>
<b class="nc">&nbsp;                    if (((TankTrailerHitch) t).getRearMounted()) {</b>
<b class="nc">&nbsp;                        dir = (dir + 3) % 6;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    trailerPos.add(e.getPosition().translated(dir));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return trailerPos;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches up a trailer hitch transporter with its Id #
&nbsp;     *
&nbsp;     * @param bayNumber - the index of the transporter we&#39;re trying to find.
&nbsp;     * @returns the trailerhitch corresponding to the passed-in value
&nbsp;     */
&nbsp;    public TankTrailerHitch getHitchById(int bayNumber) {
<b class="nc">&nbsp;        Transporter transporter = transports.get(bayNumber);</b>
<b class="nc">&nbsp;        if (transporter instanceof TankTrailerHitch) {</b>
<b class="nc">&nbsp;            return (TankTrailerHitch) transporter;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds the trailer hitch transporter that is carrying a given entityId
&nbsp;     * Hitches move around in Transports on loading a saved game
&nbsp;     *
&nbsp;     * @param id - the id of the loaded Entity we&#39;re trying to find
&nbsp;     * @returns the trailerhitch corresponding to the passed-in value
&nbsp;     */
&nbsp;    public TankTrailerHitch getHitchCarrying(int id) {
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            if (next instanceof TankTrailerHitch) {</b>
<b class="nc">&nbsp;                if (next.getLoadedUnits().contains(game.getEntity(id))) {</b>
<b class="nc">&nbsp;                    return (TankTrailerHitch) next;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a trailer hitch to any tracked or wheeled military vehicle, or SupportVee with
&nbsp;     * Tractor chassis mod that doesn&#39;t already have one
&nbsp;     */
&nbsp;    public void addTrailerHitchEquipment() {
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this vehicle is currently able to tow designated trailer.
&nbsp;     *
&nbsp;     * @param trailerId - the ID of the &lt;code&gt;Entity&lt;/code&gt; to be towed.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the trailer can be towed, &lt;code&gt;false&lt;/code&gt;
&nbsp;     * otherwise.
&nbsp;     */
&nbsp;    public boolean canTow(int trailerId) {
<b class="nc">&nbsp;        Entity trailer = game.getEntity(trailerId);</b>
&nbsp;
&nbsp;        //Null check
<b class="nc">&nbsp;        if (trailer == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Shouldn&#39;t be using this method if Trailer isn&#39;t a trailer
<b class="nc">&nbsp;        if (!trailer.isTrailer()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Can&#39;t tow if we aren&#39;t a tractor
<b class="nc">&nbsp;        if (!isTractor()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //If this entity is in a transport bay, it can&#39;t tow another
<b class="nc">&nbsp;        if (getTransportId() != Entity.NONE) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //If Trailer moved or is already being towed, discard it
<b class="nc">&nbsp;        if (!trailer.isLoadableThisTurn()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t tow yourself, either.
<b class="nc">&nbsp;        if (trailer.equals(this)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // one can only tow friendly units!
<b class="nc">&nbsp;        if (trailer.isEnemyOf(this)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Can&#39;t tow if hitch and trailer aren&#39;t at the same elevation
<b class="nc">&nbsp;        if (trailer.getElevation() != getElevation()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //If none of the above happen, assume that we can&#39;t tow the trailer...
<b class="nc">&nbsp;        boolean result = false;</b>
&nbsp;
&nbsp;        //First, set up a list of all the entities in this train
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; thisTrain = new ArrayList&lt;Entity&gt;();</b>
<b class="nc">&nbsp;        thisTrain.add(this);</b>
<b class="nc">&nbsp;        for (int id : getAllTowedUnits()) {</b>
<b class="nc">&nbsp;            Entity tr = game.getEntity(id);</b>
<b class="nc">&nbsp;            thisTrain.add(tr);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        //Add up the weight of all carried trailers. A tractor can tow a total tonnage equal to its own.
<b class="nc">&nbsp;        double tractorWeight = getWeight();</b>
<b class="nc">&nbsp;        double trailerWeight = 0;</b>
&nbsp;        //Add up what the tractor&#39;s already towing
<b class="nc">&nbsp;        for (int id : getAllTowedUnits()) {</b>
<b class="nc">&nbsp;            Entity tr = game.getEntity(id);</b>
<b class="nc">&nbsp;            trailerWeight += tr.getWeight();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (trailerWeight + trailer.getWeight() &gt; tractorWeight) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        //Next, look for an empty hitch somewhere in the train
<b class="nc">&nbsp;        boolean hitchFound = false;</b>
<b class="nc">&nbsp;        for (Entity e : thisTrain) {</b>
&nbsp;            //Quit looking if we&#39;ve already found a valid hitch
<b class="nc">&nbsp;            if (hitchFound) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Transporter t : e.getTransports()) {</b>
<b class="nc">&nbsp;                if (t.canTow(trailer)) {</b>
<b class="nc">&nbsp;                    result = true;</b>
<b class="nc">&nbsp;                    hitchFound = true;</b>
&nbsp;                    //stop looking
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Used with MoveStep.TOW to find and update the correct entity when adding it to a train
&nbsp;     */
<b class="fc">&nbsp;    private int isTowing = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entity to be towed
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getTowing() {
<b class="nc">&nbsp;        return isTowing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Change the towed status of this entity
&nbsp;     *
&nbsp;     * @param id - the ID of the entity being towed
&nbsp;     */
&nbsp;    public void setTowing(int id) {
<b class="nc">&nbsp;        isTowing = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The id of the powered tractor towing the whole train
&nbsp;     * this entity is part of. This will often be the same
&nbsp;     * entity as towedBy
&nbsp;     */
<b class="fc">&nbsp;    private int tractor = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the tractor towing the train this entity is part of
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getTractor() {
<b class="nc">&nbsp;        return tractor;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tractor towing the train this entity is part of
&nbsp;     *
&nbsp;     * @param id - id of the tractor towing this train
&nbsp;     */
&nbsp;    public void setTractor(int id) {
<b class="nc">&nbsp;        tractor = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The ID of the entity directly towing this one
&nbsp;     * Used to find and set the correct Transporter
&nbsp;     */
<b class="fc">&nbsp;    private int towedBy = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the Entity that is directly towing this one
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getTowedBy() {
<b class="nc">&nbsp;        return towedBy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the Entity that is directly towing this one
&nbsp;     *
&nbsp;     * @param id - the id of the Entity towing this trailer
&nbsp;     */
&nbsp;    public void setTowedBy(int id) {
<b class="nc">&nbsp;        towedBy = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of entity IDs being towed behind this entity, if present
&nbsp;     *
&nbsp;     * Used to ensure all following trailers are disconnected if the train
&nbsp;     * is broken at this entity.
&nbsp;     */
<b class="fc">&nbsp;    private List&lt;Integer&gt; connectedUnits = new ArrayList&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the entities towed behind this entity
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public List&lt;Integer&gt; getConnectedUnits() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(connectedUnits);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Attaches a trailer to this train
&nbsp;     *
&nbsp;     * @param id - if of the entity to be added to this train
&nbsp;     */
&nbsp;    public void towUnit(int id) {
<b class="nc">&nbsp;        Entity towed = game.getEntity(id);</b>
&nbsp;        //Add this trailer to the connected list for all trailers already in this train
<b class="nc">&nbsp;        for (int tr : getAllTowedUnits()) {</b>
<b class="nc">&nbsp;            Entity trailer = game.getEntity(tr);</b>
<b class="nc">&nbsp;            trailer.connectedUnits.add(id);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        addTowedUnit(id);</b>
<b class="nc">&nbsp;        towed.setTractor(this.getId());</b>
&nbsp;        //Now, find the transporter and the actual towing entity (trailer or tractor)
<b class="nc">&nbsp;        Entity towingEnt = game.getEntity(towed.towedBy);</b>
<b class="nc">&nbsp;        if (towingEnt != null) {</b>
<b class="nc">&nbsp;            Transporter hitch = towingEnt.getHitchById(towed.getTargetBay());</b>
<b class="nc">&nbsp;            if (hitch != null) {</b>
<b class="nc">&nbsp;                hitch.load(towed);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Detaches an entity from this entity&#39;s towing mechanism
&nbsp;     * also detaches all trailers behind this one from the whole
&nbsp;     * train
&nbsp;     *
&nbsp;     * @param id - the id of entity to be detached
&nbsp;     */
&nbsp;    public void disconnectUnit(int id) {
<b class="nc">&nbsp;        Entity towed = game.getEntity(id);</b>
<b class="nc">&nbsp;        Entity tractor = game.getEntity(towed.getTractor());</b>
&nbsp;        //Remove the designated trailer from the tractor&#39;s carried units
<b class="nc">&nbsp;        removeTowedUnit(id);</b>
&nbsp;        //Now, find and empty the transporter on the actual towing entity (trailer or tractor)
<b class="nc">&nbsp;        Entity towingEnt = game.getEntity(towed.getTowedBy());</b>
<b class="nc">&nbsp;        towingEnt.connectedUnits.clear();</b>
<b class="nc">&nbsp;        if (towingEnt != null) {</b>
<b class="nc">&nbsp;            Transporter hitch = towingEnt.getHitchCarrying(id);</b>
<b class="nc">&nbsp;            if (hitch != null) {</b>
<b class="nc">&nbsp;                hitch.unload(towed);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        //If there are other trailers behind the one being dropped, disconnect all of them
&nbsp;        //from the tractor and from each other, so they can be picked up again later
<b class="nc">&nbsp;        for (int i : towed.getConnectedUnits()) {</b>
<b class="nc">&nbsp;            Entity trailer = game.getEntity(i);</b>
<b class="nc">&nbsp;            trailer.setTractor(Entity.NONE);</b>
<b class="nc">&nbsp;            tractor.removeTowedUnit(i);</b>
<b class="nc">&nbsp;            towingEnt = game.getEntity(trailer.getTowedBy());</b>
<b class="nc">&nbsp;            if (towingEnt != null) {</b>
<b class="nc">&nbsp;                Transporter hitch = towingEnt.getHitchCarrying(i);</b>
<b class="nc">&nbsp;                if (hitch != null) {</b>
<b class="nc">&nbsp;                    hitch.unload(trailer);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            trailer.setTowedBy(Entity.NONE);</b>
<b class="nc">&nbsp;            trailer.connectedUnits.clear();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        //Update these last, or we get concurrency issues
<b class="nc">&nbsp;        towed.setTractor(Entity.NONE);</b>
<b class="nc">&nbsp;        towed.setTowedBy(Entity.NONE);</b>
<b class="nc">&nbsp;        towed.setTowing(Entity.NONE);</b>
<b class="nc">&nbsp;        towed.connectedUnits.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of all the entity IDs towed by this entity,
&nbsp;     * including those connected to other towed trailers
&nbsp;     *
&nbsp;     * Use this for the tractor/engine/tug
&nbsp;     */
<b class="fc">&nbsp;    private List&lt;Integer&gt; isTractorFor = new ArrayList&lt;Integer&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of all entities towed behind this tractor.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    public List&lt;Integer&gt; getAllTowedUnits() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(isTractorFor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an entity to this tractor&#39;s train
&nbsp;     */
&nbsp;    public void addTowedUnit(int id) {
<b class="nc">&nbsp;        isTractorFor.add(id);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Removes an entity from this tractor&#39;s train
&nbsp;     */
&nbsp;    public void removeTowedUnit(int id) {
<b class="nc">&nbsp;        isTractorFor.remove(isTractorFor.indexOf(id));</b>
<b class="nc">&nbsp;        if (getTowing() == id) {</b>
<b class="nc">&nbsp;            setTowing(Entity.NONE);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get a &lt;code&gt;List&lt;/code&gt; of the trailers currently loaded into this payload.
&nbsp;     *
&nbsp;     * @return A &lt;code&gt;List&lt;/code&gt; of loaded &lt;code&gt;Entity&lt;/code&gt; units. This
&nbsp;     * list will never be &lt;code&gt;null&lt;/code&gt;, but it may be empty. The
&nbsp;     * returned &lt;code&gt;List&lt;/code&gt; is independant from the under- lying
&nbsp;     * data structure; modifying one does not affect the other.
&nbsp;     *
&nbsp;     * This will only return loaded trailers
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getLoadedTrailers() {
<b class="nc">&nbsp;        List&lt;Entity&gt; result = new ArrayList&lt;Entity&gt;();</b>
&nbsp;
&nbsp;        // Walk through this entity&#39;s transport components;
&nbsp;        // add any trailers we find there
<b class="nc">&nbsp;        for (Transporter next : transports) {</b>
<b class="nc">&nbsp;            for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                if (e.isTrailer()) {</b>
<b class="nc">&nbsp;                    result.add(e);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        //Now do the same for any additional trailers being carried by those trailers
<b class="nc">&nbsp;        for (int id : getAllTowedUnits()) {</b>
<b class="nc">&nbsp;            Entity trailer = game.getEntity(id);</b>
<b class="nc">&nbsp;            for (Transporter next : trailer.transports) {</b>
<b class="nc">&nbsp;                for (Entity e : next.getLoadedUnits()) {</b>
<b class="nc">&nbsp;                    if (e.isTrailer()) {</b>
<b class="nc">&nbsp;                        result.add(e);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Return the list.
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if a connected tractor/trailer prevents a weapon in the given location
&nbsp;     * from firing.
&nbsp;     *
&nbsp;     * @param loc    - the &lt;code&gt;int&lt;/code&gt; location attempting to fire.
&nbsp;     * @param secondaryFacing    - the &lt;code&gt;int&lt;/code&gt; direction the turret is facing if the weapon is mounted there.
&nbsp;     * @param isRear - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
&nbsp;     *               is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
&nbsp;     *               facing.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if a tractor/trailer unit is in the way,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if the weapon can fire.
&nbsp;     */
&nbsp;    public boolean isWeaponBlockedByTowing(int loc, int secondaryFacing, boolean isRear) {
&nbsp;        //Per TW p205, assume our trailer is being towed from the front.
<b class="nc">&nbsp;        if (getTowedBy() != Entity.NONE) {</b>
<b class="nc">&nbsp;            if (loc == Tank.LOC_FRONT ||</b>
&nbsp;                    ((loc == Tank.LOC_TURRET
&nbsp;                            || loc == Tank.LOC_TURRET_2
&nbsp;                            || loc == SuperHeavyTank.LOC_TURRET
&nbsp;                            || loc == SuperHeavyTank.LOC_TURRET_2)
<b class="nc">&nbsp;                            &amp;&amp; (secondaryFacing == getFacing()))) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!getAllTowedUnits().isEmpty() || !getConnectedUnits().isEmpty()) {</b>
&nbsp;            //If we&#39;re towing something, check for a front or rear hitch
<b class="nc">&nbsp;            Entity towed = null;</b>
<b class="nc">&nbsp;            if (!getAllTowedUnits().isEmpty()) {</b>
<b class="nc">&nbsp;                towed = game.getEntity(getAllTowedUnits().get(0));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                towed = game.getEntity(getConnectedUnits().get(0));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (towed == null) {</b>
&nbsp;                //shouldn&#39;t happen, but just in case
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            TankTrailerHitch hitch = getHitchCarrying(towed.getId());</b>
<b class="nc">&nbsp;            if (hitch != null) {</b>
<b class="nc">&nbsp;                if ((hitch.getRearMounted()) &amp;&amp; loc == Tank.LOC_REAR</b>
&nbsp;                        || isRear
&nbsp;                        || loc == SuperHeavyTank.LOC_REAR ||
&nbsp;                        ((loc == Tank.LOC_TURRET
&nbsp;                                || loc == Tank.LOC_TURRET_2
&nbsp;                                || loc == SuperHeavyTank.LOC_TURRET
&nbsp;                                || loc == SuperHeavyTank.LOC_TURRET_2)
<b class="nc">&nbsp;                                &amp;&amp; (secondaryFacing == ((getFacing() + 3) % 6)))) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (!hitch.getRearMounted() &amp;&amp; (loc == Tank.LOC_FRONT ||</b>
&nbsp;                        ((loc == Tank.LOC_TURRET
&nbsp;                        || loc == Tank.LOC_TURRET_2
&nbsp;                        || loc == SuperHeavyTank.LOC_TURRET
&nbsp;                        || loc == SuperHeavyTank.LOC_TURRET_2)
<b class="nc">&nbsp;                        &amp;&amp; (secondaryFacing == getFacing())))) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * determine if an entity has an ability that is identified by its presence or absence only.
&nbsp;     * The entity may gain this ability from different places, not exclusively the crew.
&nbsp;     * @param name - name of the ability as recorded in the options
&nbsp;     * @return true if the entity has this ability from some source
&nbsp;     */
&nbsp;    public boolean hasAbility(String name) {
<b class="nc">&nbsp;        if(null != getCrew()) {</b>
<b class="nc">&nbsp;            return getCrew().getOptions().booleanOption(name);</b>
&nbsp;        }
&nbsp;        //TODO: look for the ability at the player level
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * determine if an entity has an ability at a given level.
&nbsp;     * The entity may gain this ability from different places, not exclusively the crew.
&nbsp;     * @param name - name of the ability as recorded in the optionsme
&nbsp;     * @param choice - A string indicating the given level being asked about
&nbsp;     * @return true if the entity has this ability at the given choice from some source
&nbsp;     */
&nbsp;    public boolean hasAbility(String name, String choice) {
<b class="nc">&nbsp;        if(null != getCrew()) {</b>
<b class="nc">&nbsp;            return getCrew().getOptions().stringOption(name).equals(choice);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int modifyPhysicalDamageForMeleeSpecialist() {
<b class="nc">&nbsp;        if (!hasAbility(OptionsConstants.PILOT_MELEE_SPECIALIST)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    }
&nbsp;    
&nbsp;    
&nbsp;    //Getters and setters for sensor contacts and firing solutions. Currently only used in space combat
&nbsp;    /**
&nbsp;     * Retrieves the IDs of all entities that this entity has detected with sensors
&nbsp;     * @return the contents of this entity&#39;s sensorContacts set
&nbsp;     */
&nbsp;    public Set&lt;Integer&gt; getSensorContacts() {
<b class="nc">&nbsp;        return sensorContacts;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Checks the sensorContacts set for a specific target&#39;s ID number
&nbsp;     * @param targetId the ID number of the target entity to check for
&nbsp;     * @return true if the entity&#39;s sensorContacts set contains the passed-in target ID
&nbsp;     */
&nbsp;    public boolean hasSensorContactFor(int targetId) {
<b class="nc">&nbsp;        return sensorContacts.contains(targetId);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Adds the specified target entity&#39;s ID to this entity&#39;s sensorContacts
&nbsp;     * @param targetId the ID number of the target entity to add
&nbsp;     */
&nbsp;    public void addSensorContact(int targetId) {
<b class="nc">&nbsp;        sensorContacts.add(targetId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Removes the specified target entity&#39;s ID from this entity&#39;s sensorContacts
&nbsp;     * @param targetIds the ID number of the target entity to remove
&nbsp;     */
&nbsp;    public void removeSensorContact(Collection&lt;Integer&gt; targetIds) {
<b class="nc">&nbsp;        sensorContacts.removeAll(targetIds);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Empties this entity&#39;s sensorContacts
&nbsp;     * Used when it dies or moves offboard
&nbsp;     */
&nbsp;    public void clearSensorContacts() {
<b class="nc">&nbsp;        sensorContacts.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Retrieves the IDs of all entities that this entity has established firing solutions on
&nbsp;     * @return the contents of this entity&#39;s firingSolutions set
&nbsp;     */
&nbsp;    public Set&lt;Integer&gt; getFiringSolutions() {
<b class="nc">&nbsp;        return firingSolutions;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Checks the firingSolutions set for a specific target&#39;s ID number
&nbsp;     * @param targetId the ID number of the target entity to check for
&nbsp;     * @return true if the entity&#39;s firingSolutions set contains the passed-in target ID
&nbsp;     */
&nbsp;    public boolean hasFiringSolutionFor(int targetId) {
<b class="nc">&nbsp;        return firingSolutions.contains(targetId);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Adds the specified target entity&#39;s ID to this entity&#39;s firingSolutions
&nbsp;     * @param targetId the ID number of the target entity to add
&nbsp;     */
&nbsp;    public void addFiringSolution(int targetId) {
<b class="nc">&nbsp;        firingSolutions.add(targetId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Removes the specified target entity&#39;s ID from this entity&#39;s firingSolutions
&nbsp;     * @param targetIds the ID number of the target entity to remove
&nbsp;     */
&nbsp;    public void removeFiringSolution(Collection&lt;Integer&gt; targetIds) {
<b class="nc">&nbsp;        firingSolutions.removeAll(targetIds);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Empties this entity&#39;s firingSolutions
&nbsp;     * Used when it dies or moves offboard
&nbsp;     */
&nbsp;    public void clearFiringSolutions() {
<b class="nc">&nbsp;        firingSolutions.clear();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Indicate that an off-board artillery attack by this entity has been observed by a particular team
&nbsp;     */
&nbsp;    public void addOffBoardObserver(int teamID) {
<b class="nc">&nbsp;        offBoardShotObservers.add(teamID);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Has the given team observed an off-board artillery attack by this entity?
&nbsp;     */
&nbsp;    public boolean isOffBoardObserved(int teamID) {
<b class="nc">&nbsp;        return offBoardShotObservers.contains(teamID);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
