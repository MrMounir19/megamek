


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > WeaponAttackAction</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common.actions</a>
</div>

<h1>Coverage Summary for Class: WeaponAttackAction (megamek.common.actions)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">WeaponAttackAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2217)
  </span>
</td>
</tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$12sONqt5</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$1BK8ZqZz</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$2nWaI9ll</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$2qMenO16</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$34CwEEXA</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$4Tn7D8yj</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$5P0bcAiP</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$5vhgnWd5</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$885MxzyD</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$8I0Vqkbv</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$8u6Q1uYU</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$95KHiWRo</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$9NdMBdyS</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$9xaWiQy6</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$AEyduJUN</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$aIRNpPqv</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$bpat3SgW</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$CDk90dzm</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$cPmK8Lxl</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$D9oHUu1G</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$DUewFUpz</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$DxvsKsxQ</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$ef9PspVt</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$eQTMz8hJ</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$fcEgQx0U</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$Gch6SQoQ</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$gmcBTbPI</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$haXI7wDR</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$hFJVW0PM</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$hZQqkefn</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$I8DCYaJw</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$iR44j10N</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$JHEv0sZc</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$KAKy30yK</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$KCyPCJ0M</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$kJauSrA1</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$klu5fkZG</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$KMmJYDzC</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$kxGx5jzc</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$l1ITpc42</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$m05JKFXO</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$McEwpGjM</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$mMjCo9Zn</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$NcMsY1vq</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$prwTRnRb</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$tCJ2xY4O</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$TqWVjN1C</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$trupohbZ</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$U4UYLAkw</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$UVSphnJ4</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$vnB0UbcM</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$VnspLvsm</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$vU87QxpT</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$x917IZY4</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$xtg8U6n3</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$Xw3kt7mi</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$YapUsr2C</td>
  </tr>
  <tr>
    <td class="name">WeaponAttackAction$MockitoMock$1830011068$auxiliary$YKMXGSMx</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2217)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2000,2001,2002,2003,2004 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.common.actions;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.List;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.client.ui.Messages;
&nbsp;import megamek.common.Aero;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.BipedMech;
&nbsp;import megamek.common.Board;
&nbsp;import megamek.common.BombType;
&nbsp;import megamek.common.CalledShot;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.ComputeECM;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Crew;
&nbsp;import megamek.common.CriticalSlot;
&nbsp;import megamek.common.Dropship;
&nbsp;import megamek.common.ECMInfo;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementMode;
&nbsp;import megamek.common.EntityMovementType;
&nbsp;import megamek.common.EquipmentType;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.HexTarget;
&nbsp;import megamek.common.IAero;
&nbsp;import megamek.common.IAimingModes;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.ILocationExposureStatus;
&nbsp;import megamek.common.INarcPod;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.Jumpship;
&nbsp;import megamek.common.LandAirMech;
&nbsp;import megamek.common.LosEffects;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MechWarrior;
&nbsp;import megamek.common.MinefieldTarget;
&nbsp;import megamek.common.MiscType;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.PlanetaryConditions;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.QuadMech;
&nbsp;import megamek.common.QuadVee;
&nbsp;import megamek.common.RangeType;
&nbsp;import megamek.common.SpaceStation;
&nbsp;import megamek.common.SpecialResolutionTracker;
&nbsp;import megamek.common.SupportTank;
&nbsp;import megamek.common.SupportVTOL;
&nbsp;import megamek.common.TagInfo;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.TripodMech;
&nbsp;import megamek.common.VTOL;
&nbsp;import megamek.common.Warship;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.weapons.DiveBombAttack;
&nbsp;import megamek.common.weapons.InfantryAttack;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.artillery.ArtilleryCannonWeapon;
&nbsp;import megamek.common.weapons.artillery.ArtilleryWeapon;
&nbsp;import megamek.common.weapons.bayweapons.LaserBayWeapon;
&nbsp;import megamek.common.weapons.bayweapons.PPCBayWeapon;
&nbsp;import megamek.common.weapons.bayweapons.PulseLaserBayWeapon;
&nbsp;import megamek.common.weapons.bayweapons.ScreenLauncherBayWeapon;
&nbsp;import megamek.common.weapons.capitalweapons.CapitalMissileWeapon;
&nbsp;import megamek.common.weapons.gaussrifles.GaussWeapon;
&nbsp;import megamek.common.weapons.gaussrifles.ISHGaussRifle;
&nbsp;import megamek.common.weapons.lasers.ISBombastLaser;
&nbsp;import megamek.common.weapons.lasers.VariableSpeedPulseLaserWeapon;
&nbsp;import megamek.common.weapons.lrms.LRTWeapon;
&nbsp;import megamek.common.weapons.mortars.MekMortarWeapon;
&nbsp;import megamek.common.weapons.other.TSEMPWeapon;
&nbsp;import megamek.common.weapons.srms.SRTWeapon;
&nbsp;
&nbsp;/**
&nbsp; * Represents intention to fire a weapon at the target.
&nbsp; */
&nbsp;public class WeaponAttackAction extends AbstractAttackAction implements Serializable {
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = -9096603813317359351L;
&nbsp;    
&nbsp;    public static final int STRATOPS_SENSOR_SHADOW_WEIGHT_DIFF = 100000;
&nbsp;    
&nbsp;    private int weaponId;
<b class="nc">&nbsp;    private int ammoId = -1;</b>
<b class="nc">&nbsp;    private int ammoCarrier = -1;</b>
<b class="nc">&nbsp;    private int aimedLocation = Entity.LOC_NONE;</b>
<b class="nc">&nbsp;    private int aimMode = IAimingModes.AIM_MODE_NONE;</b>
<b class="nc">&nbsp;    private int otherAttackInfo = -1; //</b>
&nbsp;    private boolean nemesisConfused;
&nbsp;    private boolean swarmingMissiles;
<b class="nc">&nbsp;    protected int launchVelocity = 50;</b>
&nbsp;    /**
&nbsp;     * Keeps track of the ID of the current primary target for a swarm missile
&nbsp;     * attack.
&nbsp;     */
<b class="nc">&nbsp;    private int oldTargetId = -1;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the Targetable type for the current primary target for a
&nbsp;     * swarm missile attack.
&nbsp;     */
&nbsp;    private int oldTargetType;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the ID of the original target for a swarm missile attack.
&nbsp;     */
<b class="nc">&nbsp;    private int originalTargetId = Entity.NONE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps track of the type of the original target for a swarm missile
&nbsp;     * attack.
&nbsp;     */
&nbsp;    private int originalTargetType;
&nbsp;
<b class="nc">&nbsp;    private int swarmMissiles = 0;</b>
&nbsp;
&nbsp;    // bomb stuff
<b class="nc">&nbsp;    private int[] bombPayload = new int[BombType.B_NUM];</b>
&nbsp;
&nbsp;    // equipment that affects this attack (AMS, ECM?, etc)
&nbsp;    // only used server-side
&nbsp;    private transient ArrayList&lt;Mounted&gt; vCounterEquipment;
&nbsp;
&nbsp;    /**
&nbsp;     * Boolean flag that determines whether or not this attack is part of a
&nbsp;     * strafing run.
&nbsp;     */
<b class="nc">&nbsp;    private boolean isStrafing = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Boolean flag that determines if this shot was the first one by a
&nbsp;     * particular weapon in a strafing run. Used to ensure that heat is only
&nbsp;     * added once.
&nbsp;     */
<b class="nc">&nbsp;    protected boolean isStrafingFirstShot = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Boolean flag that determines if this shot was fired as part of a
&nbsp;     * pointblank shot from a hidden unit. In this case, to-hit numbers should
&nbsp;     * not be modified for terrain or movement. See TW pg 260
&nbsp;     */
<b class="nc">&nbsp;    protected boolean isPointblankShot = false;</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Boolean flag that determines if this shot was fired using homing ammunition.
&nbsp;     * Can be checked to allow casting of attack handlers to the proper homing handler.
&nbsp;     */
<b class="nc">&nbsp;    protected boolean isHomingShot = false;</b>
&nbsp;
&nbsp;    // default to attacking an entity
&nbsp;    public WeaponAttackAction(int entityId, int targetId, int weaponId) {
<b class="nc">&nbsp;        super(entityId, targetId);</b>
<b class="nc">&nbsp;        this.weaponId = weaponId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public WeaponAttackAction(int entityId, int targetType, int targetId, int weaponId) {
<b class="nc">&nbsp;        super(entityId, targetType, targetId);</b>
<b class="nc">&nbsp;        this.weaponId = weaponId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getWeaponId() {
<b class="nc">&nbsp;        return weaponId;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAmmoId() {
<b class="nc">&nbsp;        return ammoId;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns the entity id of the unit carrying the ammo used by this attack
&nbsp;     * @return
&nbsp;     */
&nbsp;    public int getAmmoCarrier() {
<b class="nc">&nbsp;        return ammoCarrier;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAimedLocation() {
<b class="nc">&nbsp;        return aimedLocation;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAimingMode() {
<b class="nc">&nbsp;        return aimMode;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ArrayList&lt;Mounted&gt; getCounterEquipment() {
<b class="nc">&nbsp;        return vCounterEquipment;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setWeaponId(int weaponId) {
<b class="nc">&nbsp;        this.weaponId = weaponId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setAmmoId(int ammoId) {
<b class="nc">&nbsp;        this.ammoId = ammoId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the entity id of the ammo carrier for this shot, if different than the firing entity
&nbsp;     * @param entityId
&nbsp;     */
&nbsp;    public void setAmmoCarrier(int entityId) {
<b class="nc">&nbsp;        this.ammoCarrier = entityId;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setAimedLocation(int aimedLocation) {
<b class="nc">&nbsp;        this.aimedLocation = aimedLocation;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setAimingMode(int aimMode) {
<b class="nc">&nbsp;        this.aimMode = aimMode;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void addCounterEquipment(Mounted m) {
<b class="nc">&nbsp;        if (vCounterEquipment == null) {</b>
<b class="nc">&nbsp;            vCounterEquipment = new ArrayList&lt;Mounted&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        vCounterEquipment.add(m);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setOtherAttackInfo(int newInfo) {
<b class="nc">&nbsp;        otherAttackInfo = newInfo;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOtherAttackInfo() {
<b class="nc">&nbsp;        return otherAttackInfo;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isAirToGround(IGame game) {
<b class="nc">&nbsp;        return Compute.isAirToGround(getEntity(game), getTarget(game));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isAirToAir(IGame game) {
<b class="nc">&nbsp;        return Compute.isAirToAir(getEntity(game), getTarget(game));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isGroundToAir(IGame game) {
<b class="nc">&nbsp;        return Compute.isGroundToAir(getEntity(game), getTarget(game));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isDiveBomb(IGame game) {
<b class="nc">&nbsp;        return ((WeaponType) getEntity(game).getEquipment(getWeaponId()).getType()).hasFlag(WeaponType.F_DIVE_BOMB);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getAltitudeLoss(IGame game) {
<b class="nc">&nbsp;        if (isAirToGround(game)) {</b>
<b class="nc">&nbsp;            if (((WeaponType) getEntity(game).getEquipment(getWeaponId()).getType()).hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
<b class="nc">&nbsp;                return 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((WeaponType) getEntity(game).getEquipment(getWeaponId()).getType()).hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (isStrafing) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return 1;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ToHitData toHit(IGame game) {
<b class="nc">&nbsp;        return WeaponAttackAction.toHit(game, getEntityId(), game.getTarget(getTargetType(), getTargetId()),</b>
<b class="nc">&nbsp;                getWeaponId(), getAimedLocation(), getAimingMode(), nemesisConfused, swarmingMissiles,</b>
<b class="nc">&nbsp;                game.getTarget(getOldTargetType(), getOldTargetId()),</b>
<b class="nc">&nbsp;                game.getTarget(getOriginalTargetType(), getOriginalTargetId()), isStrafing(), isPointblankShot());</b>
&nbsp;    }
&nbsp;
&nbsp;    public ToHitData toHit(IGame game, List&lt;ECMInfo&gt; allECMInfo) {
<b class="nc">&nbsp;        return WeaponAttackAction.toHit(game, getEntityId(), game.getTarget(getTargetType(), getTargetId()),</b>
<b class="nc">&nbsp;                getWeaponId(), getAimedLocation(), getAimingMode(), nemesisConfused, swarmingMissiles,</b>
<b class="nc">&nbsp;                game.getTarget(getOldTargetType(), getOldTargetId()),</b>
<b class="nc">&nbsp;                game.getTarget(getOriginalTargetType(), getOriginalTargetId()), isStrafing(), isPointblankShot(),</b>
&nbsp;                allECMInfo);
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData toHit(IGame game, int attackerId, Targetable target, int weaponId, boolean isStrafing) {
<b class="nc">&nbsp;        return WeaponAttackAction.toHit(game, attackerId, target, weaponId, Entity.LOC_NONE, IAimingModes.AIM_MODE_NONE,</b>
&nbsp;                false, false, null, null, isStrafing, false);
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData toHit(IGame game, int attackerId, Targetable target, int weaponId, int aimingAt,
&nbsp;            int aimingMode, boolean isStrafing) {
<b class="nc">&nbsp;        return WeaponAttackAction.toHit(game, attackerId, target, weaponId, aimingAt, aimingMode, false, false, null,</b>
&nbsp;                null, isStrafing, false);
&nbsp;    }
&nbsp;
&nbsp;    public static ToHitData toHit(IGame game, int attackerId, Targetable target, int weaponId, int aimingAt,
&nbsp;            int aimingMode, boolean isNemesisConfused, boolean exchangeSwarmTarget, Targetable oldTarget,
&nbsp;            Targetable originalTarget, boolean isStrafing, boolean isPointblankShot) {
<b class="nc">&nbsp;        return WeaponAttackAction.toHit(game, attackerId, target, weaponId, aimingAt, aimingMode, isNemesisConfused,</b>
&nbsp;                exchangeSwarmTarget, oldTarget, originalTarget, isStrafing, isPointblankShot, null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * To-hit number for attacker firing a weapon at the target.
&nbsp;     */
&nbsp;    private static ToHitData toHit(IGame game, int attackerId, Targetable target, int weaponId, int aimingAt,
&nbsp;            int aimingMode, boolean isNemesisConfused, boolean exchangeSwarmTarget, Targetable oldTarget,
&nbsp;            Targetable originalTarget, boolean isStrafing, boolean isPointblankShot, List&lt;ECMInfo&gt; allECMInfo) {
<b class="nc">&nbsp;        final Entity ae = game.getEntity(attackerId);</b>
<b class="nc">&nbsp;        final Mounted weapon = ae.getEquipment(weaponId);</b>
&nbsp;        
<b class="nc">&nbsp;        final WeaponType wtype = (WeaponType) weapon.getType();</b>
&nbsp;        
&nbsp;        // This is ok to keep here. No need to process anything further if we&#39;re not using a weapon somehow
<b class="nc">&nbsp;        if (!(wtype instanceof WeaponType)) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_FAIL, Messages.getString(&quot;WeaponAttackAction.NotAWeapon&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Targetable swarmSecondaryTarget = target;</b>
<b class="nc">&nbsp;        Targetable swarmPrimaryTarget = oldTarget;</b>
<b class="nc">&nbsp;        if (exchangeSwarmTarget) {</b>
&nbsp;            // this is a swarm attack against a new target
&nbsp;            // first, exchange original and new targets to get all mods
&nbsp;            // as if firing against original target.
&nbsp;            // at the end of this function, we remove target terrain
&nbsp;            // and movement mods, and add those for the new target
<b class="nc">&nbsp;            Targetable tempTarget = target;</b>
<b class="nc">&nbsp;            target = originalTarget;</b>
<b class="nc">&nbsp;            originalTarget = tempTarget;</b>
&nbsp;        }
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean isAttackerInfantry = ae instanceof Infantry;</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY) &amp;&amp; !ae.isSupportVehicle();</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isWeaponFieldGuns = isAttackerInfantry &amp;&amp; (weapon.getLocation() == Infantry.LOC_FIELD_GUNS);</b>
&nbsp;        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.
&nbsp;        // 2002-09-16 Infantry weapons have unlimited ammo.
&nbsp;        
<b class="nc">&nbsp;        final boolean usesAmmo = (wtype.getAmmoType() != AmmoType.T_NA) &amp;&amp; !isWeaponInfantry;</b>
&nbsp;        
<b class="nc">&nbsp;        final Mounted ammo = usesAmmo ? weapon.getLinked() : null;</b>
&nbsp;        
<b class="nc">&nbsp;        final AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();</b>
&nbsp;        
<b class="nc">&nbsp;        long munition = AmmoType.M_STANDARD;</b>
<b class="nc">&nbsp;        if (atype != null) {</b>
<b class="nc">&nbsp;            munition = atype.getMunitionType();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game, te);</b>
&nbsp;        
<b class="nc">&nbsp;        boolean bMekTankStealthActive = false;</b>
<b class="nc">&nbsp;        if ((ae instanceof Mech) || (ae instanceof Tank)) {</b>
<b class="nc">&nbsp;            bMekTankStealthActive = ae.isStealthActive();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        boolean isFlakAttack = !game.getBoard().inSpace() &amp;&amp; (te != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isAirborne() || te.isAirborneVTOLorWIGE()) &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((((atype.getAmmoType() == AmmoType.T_AC_LBX) || (atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</b>
&nbsp;                        &amp;&amp; (munition == AmmoType.M_CLUSTER))
<b class="nc">&nbsp;                        || (munition == AmmoType.M_FLAK) || (atype.getAmmoType() == AmmoType.T_HAG));</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isIndirect = (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_MISSILE_INDIRECT));</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isInferno = ((atype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_MML))</b>
<b class="nc">&nbsp;                &amp;&amp; (atype.getMunitionType() == AmmoType.M_INFERNO))</b>
<b class="nc">&nbsp;                || (isWeaponInfantry &amp;&amp; (wtype.hasFlag(WeaponType.F_INFERNO)));</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isArtilleryDirect = (wtype.hasFlag(WeaponType.F_ARTILLERY) ||</b>
&nbsp;                (wtype instanceof CapitalMissileWeapon
<b class="nc">&nbsp;                        &amp;&amp; Compute.isGroundToGround(ae, target)))</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_FIRING);</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isArtilleryIndirect = (wtype.hasFlag(WeaponType.F_ARTILLERY) ||</b>
&nbsp;                (wtype instanceof CapitalMissileWeapon
<b class="nc">&nbsp;                        &amp;&amp; Compute.isGroundToGround(ae, target)))</b>
<b class="nc">&nbsp;                &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                        || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD));</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isBearingsOnlyMissile = (weapon.isInBearingsOnlyMode())</b>
<b class="nc">&nbsp;                            &amp;&amp; ((game.getPhase() == IGame.Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                                    || (game.getPhase() == IGame.Phase.PHASE_FIRING));</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isCruiseMissile = (weapon.getType().hasFlag(WeaponType.F_CRUISE_MISSILE)</b>
&nbsp;                        || (wtype instanceof CapitalMissileWeapon
<b class="nc">&nbsp;                                &amp;&amp; Compute.isGroundToGround(ae, target)));</b>
&nbsp;        
&nbsp;        // hack, otherwise when actually resolves shot labeled impossible.
<b class="nc">&nbsp;        boolean isArtilleryFLAK = isArtilleryDirect &amp;&amp; (te != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((((te.getMovementMode() == EntityMovementMode.VTOL)</b>
<b class="nc">&nbsp;                        || (te.getMovementMode() == EntityMovementMode.WIGE)) &amp;&amp; te.isAirborneVTOLorWIGE())</b>
<b class="nc">&nbsp;                        || (te.isAirborne()))</b>
<b class="nc">&nbsp;                &amp;&amp; (atype != null) &amp;&amp; (usesAmmo &amp;&amp; (atype.getMunitionType() == AmmoType.M_STANDARD));</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isHaywireINarced = ae.isINarcedWith(INarcPod.HAYWIRE);</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isINarcGuided = false;</b>
&nbsp;        
&nbsp;        // for attacks where ECM along flight path makes a difference
<b class="nc">&nbsp;        boolean isECMAffected = ComputeECM.isAffectedByECM(ae, ae.getPosition(), target.getPosition(), allECMInfo);</b>
&nbsp;        
&nbsp;        // for attacks where only ECM on the target hex makes a difference
<b class="nc">&nbsp;        boolean isTargetECMAffected = ComputeECM.isAffectedByECM(ae, target.getPosition(), target.getPosition(),</b>
&nbsp;                allECMInfo);
&nbsp;        
<b class="nc">&nbsp;        boolean isTAG = wtype.hasFlag(WeaponType.F_TAG);</b>
&nbsp;        
&nbsp;        // target type checked later because its different for
&nbsp;        // direct/indirect (BMRr p77 on board arrow IV)
<b class="nc">&nbsp;        boolean isHoming = ammo != null &amp;&amp; ammo.isHomingAmmoInHomingMode();</b>
&nbsp;
<b class="nc">&nbsp;        boolean bHeatSeeking = (atype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_LRM_IMP))</b>
&nbsp;                &amp;&amp; (munition == AmmoType.M_HEAT_SEEKING);
&nbsp;        
<b class="nc">&nbsp;        boolean bFTL = (atype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_MML) </b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_LRM_IMP))</b>
&nbsp;                &amp;&amp; (munition == AmmoType.M_FOLLOW_THE_LEADER);
&nbsp;
<b class="nc">&nbsp;        Mounted mLinker = weapon.getLinkedBy();</b>
&nbsp;               
<b class="nc">&nbsp;        boolean bApollo = ((mLinker != null) &amp;&amp; (mLinker.getType() instanceof MiscType) &amp;&amp; !mLinker.isDestroyed()</b>
<b class="nc">&nbsp;                &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp; mLinker.getType().hasFlag(MiscType.F_APOLLO))</b>
<b class="nc">&nbsp;                &amp;&amp; (atype != null) &amp;&amp; (atype.getAmmoType() == AmmoType.T_MRM);</b>
&nbsp;        
<b class="nc">&nbsp;        boolean bArtemisV = ((mLinker != null) &amp;&amp; (mLinker.getType() instanceof MiscType) &amp;&amp; !mLinker.isDestroyed()</b>
<b class="nc">&nbsp;                &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp; mLinker.getType().hasFlag(MiscType.F_ARTEMIS_V)</b>
&nbsp;                &amp;&amp; !isECMAffected &amp;&amp; !bMekTankStealthActive &amp;&amp; (atype != null)
&nbsp;                &amp;&amp; (munition == AmmoType.M_ARTEMIS_V_CAPABLE));
&nbsp;        
<b class="nc">&nbsp;        if (ae.usesWeaponBays()) {</b>
<b class="nc">&nbsp;            for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                Mounted bayW = ae.getEquipment(wId);</b>
<b class="nc">&nbsp;                Mounted bayWAmmo = bayW.getLinked();</b>
&nbsp;
<b class="nc">&nbsp;                if (bayWAmmo == null) {</b>
&nbsp;                    //At present, all weapons below using mLinker use ammo, so this won&#39;t be a problem
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                AmmoType bAmmo = (AmmoType) bayWAmmo.getType();</b>
&nbsp;                
&nbsp;                //If we&#39;re using optional rules and firing Arrow Homing missiles from a bay...
<b class="nc">&nbsp;                isHoming = bAmmo != null &amp;&amp; bAmmo.getMunitionType() == AmmoType.M_HOMING;</b>
&nbsp;                
&nbsp;                //If the artillery bay is firing cruise missiles, they have some special rules
&nbsp;                //It is possible to combine cruise missiles and other artillery in a bay, so
&nbsp;                //set this to true if any of the weapons are cruise missile launchers.
<b class="nc">&nbsp;                if (bayW.getType().hasFlag(WeaponType.F_CRUISE_MISSILE)) {</b>
<b class="nc">&nbsp;                    isCruiseMissile = true;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                mLinker = bayW.getLinkedBy();</b>
<b class="nc">&nbsp;                bApollo = ((mLinker != null) &amp;&amp; (mLinker.getType() instanceof MiscType) &amp;&amp; !mLinker.isDestroyed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp; mLinker.getType().hasFlag(MiscType.F_APOLLO))</b>
<b class="nc">&nbsp;                        &amp;&amp; (bAmmo != null) &amp;&amp; (bAmmo.getAmmoType() == AmmoType.T_MRM);</b>
&nbsp;                
<b class="nc">&nbsp;                bArtemisV = ((mLinker != null) &amp;&amp; (mLinker.getType() instanceof MiscType) &amp;&amp; !mLinker.isDestroyed()</b>
<b class="nc">&nbsp;                        &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp; mLinker.getType().hasFlag(MiscType.F_ARTEMIS_V)</b>
&nbsp;                        &amp;&amp; !isECMAffected &amp;&amp; !bMekTankStealthActive &amp;&amp; (atype != null)
<b class="nc">&nbsp;                        &amp;&amp; (bAmmo != null) &amp;&amp; (bAmmo.getMunitionType() == AmmoType.M_ARTEMIS_V_CAPABLE));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        boolean inSameBuilding = Compute.isInSameBuilding(game, ae, te);</b>
&nbsp;        
&nbsp;        //Set up the target&#39;s relative elevation/depth
&nbsp;        int targEl;
&nbsp;
<b class="nc">&nbsp;        if (te == null) {</b>
<b class="nc">&nbsp;            targEl = -game.getBoard().getHex(target.getPosition()).depth();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            targEl = te.relHeight();</b>
&nbsp;        }
&nbsp;
&nbsp;        // is this attack originating from underwater
&nbsp;        // TODO: assuming that torpedoes are underwater attacks even if fired
&nbsp;        // from surface vessel, awaiting rules clarification
&nbsp;        // http://www.classicbattletech.com/forums/index.php/topic,48744.0.html
<b class="nc">&nbsp;        boolean underWater = (ae.getLocationStatus(weapon.getLocation()) == ILocationExposureStatus.WET)</b>
&nbsp;                || (wtype instanceof SRTWeapon) || (wtype instanceof LRTWeapon);
&nbsp;
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            if (!isTargetECMAffected &amp;&amp; te.isINarcedBy(ae.getOwner().getTeam()) &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_SRM_IMP) </b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_NLRM))</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_NARC_CAPABLE)) {
<b class="nc">&nbsp;                isINarcGuided = true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        int toSubtract = 0;</b>
&nbsp;        
&nbsp;        //Convenience variable to test the targetable type value
<b class="nc">&nbsp;        final int ttype = target.getTargetType();</b>
&nbsp;      
&nbsp;        // if we&#39;re doing indirect fire, find a spotter
<b class="nc">&nbsp;        Entity spotter = null;</b>
<b class="nc">&nbsp;        boolean narcSpotter = false;</b>
<b class="nc">&nbsp;        if (isIndirect &amp;&amp; !ae.hasAbility(OptionsConstants.GUNNERY_OBLIQUE_ATTACKER)) {</b>
<b class="nc">&nbsp;            if ((target instanceof Entity) &amp;&amp; !isTargetECMAffected &amp;&amp; (te != null) &amp;&amp; (atype != null) &amp;&amp; usesAmmo</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_NARC_CAPABLE)
<b class="nc">&nbsp;                    &amp;&amp; (te.isNarcedBy(ae.getOwner().getTeam()) || te.isINarcedBy(ae.getOwner().getTeam()))) {</b>
<b class="nc">&nbsp;                spotter = te;</b>
<b class="nc">&nbsp;                narcSpotter = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                spotter = Compute.findSpotter(game, ae, target);</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((spotter == null) &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_NLRM)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_MEK_MORTAR))</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_SEMIGUIDED)) {
<b class="nc">&nbsp;                for (TagInfo ti : game.getTagInfo()) {</b>
<b class="nc">&nbsp;                    if (target.getTargetId() == ti.target.getTargetId()) {</b>
<b class="nc">&nbsp;                        spotter = game.getEntity(ti.attackerId);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // EI system
&nbsp;        // 0 if no EI (or switched off)
&nbsp;        // 1 if no intervening light woods
&nbsp;        // 2 if intervening light woods (because target in woods + intervening
&nbsp;        // woods is only +1 total)
<b class="nc">&nbsp;        int eistatus = 0;</b>
&nbsp;
<b class="nc">&nbsp;        boolean mpMelevationHack = false;</b>
<b class="nc">&nbsp;        if (usesAmmo </b>
<b class="nc">&nbsp;                &amp;&amp; ((wtype.getAmmoType() == AmmoType.T_LRM) || (wtype.getAmmoType() == AmmoType.T_LRM_IMP))  </b>
&nbsp;                &amp;&amp; (atype != null)
&nbsp;                &amp;&amp; (munition == AmmoType.M_MULTI_PURPOSE) 
<b class="nc">&nbsp;                &amp;&amp; (ae.getElevation() == -1)</b>
<b class="nc">&nbsp;                &amp;&amp; (ae.getLocationStatus(weapon.getLocation()) == ILocationExposureStatus.WET)) {</b>
<b class="nc">&nbsp;            mpMelevationHack = true;</b>
&nbsp;            // surface to fire
<b class="nc">&nbsp;            ae.setElevation(0);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // check LOS (indirect LOS is from the spotter)
&nbsp;        LosEffects los;
&nbsp;        ToHitData losMods;
<b class="nc">&nbsp;        if (isIndirect &amp;&amp; ae.hasAbility(OptionsConstants.GUNNERY_OBLIQUE_ATTACKER)</b>
&nbsp;                &amp;&amp; !underWater) {
<b class="nc">&nbsp;            los = new LosEffects();</b>
<b class="nc">&nbsp;            losMods = new ToHitData();</b>
<b class="nc">&nbsp;        } else if (!isIndirect || (spotter == null)) {</b>
<b class="nc">&nbsp;            if (!exchangeSwarmTarget) {</b>
<b class="nc">&nbsp;                los = LosEffects.calculateLos(game, attackerId, target);</b>
&nbsp;            } else {
&nbsp;                // Swarm should draw LoS between targets, not attacker, since
&nbsp;                // we don&#39;t want LoS to be blocked
<b class="nc">&nbsp;                if (swarmPrimaryTarget.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;                    los = LosEffects.calculateLos(game, swarmPrimaryTarget.getTargetId(), swarmSecondaryTarget);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    los = LosEffects.calculateLos(game, swarmSecondaryTarget.getTargetId(), swarmPrimaryTarget);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (ae.hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;                if (los.getLightWoods() &gt; 0) {</b>
<b class="nc">&nbsp;                    eistatus = 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    eistatus = 1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((wtype instanceof MekMortarWeapon) &amp;&amp; isIndirect) {</b>
<b class="nc">&nbsp;                los.setArcedAttack(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            losMods = los.losModifiers(game, eistatus, underWater);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (exchangeSwarmTarget) {</b>
&nbsp;                // Swarm should draw LoS between targets, not attacker, since
&nbsp;                // we don&#39;t want LoS to be blocked
<b class="nc">&nbsp;                if (swarmPrimaryTarget.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;                    los = LosEffects.calculateLos(game, swarmPrimaryTarget.getTargetId(), swarmSecondaryTarget);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    los = LosEffects.calculateLos(game, swarmSecondaryTarget.getTargetId(), swarmPrimaryTarget);</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                //For everything else, set up a plain old LOS
<b class="nc">&nbsp;                los = LosEffects.calculateLos(game, spotter.getId(), target, true);</b>
&nbsp;            }
&nbsp;
&nbsp;            // do not count attacker partial cover in indirect fire
<b class="nc">&nbsp;            los.setAttackerCover(LosEffects.COVER_NONE);</b>
&nbsp;
<b class="nc">&nbsp;            if (!narcSpotter &amp;&amp; spotter.hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;                if (los.getLightWoods() &gt; 0) {</b>
<b class="nc">&nbsp;                    eistatus = 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    eistatus = 1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (wtype instanceof MekMortarWeapon) {</b>
<b class="nc">&nbsp;                los.setArcedAttack(true);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            losMods = los.losModifiers(game, underWater);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (mpMelevationHack) {</b>
&nbsp;            // return to depth 1
<b class="nc">&nbsp;            ae.setElevation(-1);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // determine some more variables
<b class="nc">&nbsp;        int aElev = ae.getElevation();</b>
<b class="nc">&nbsp;        int tElev = target.getElevation();</b>
<b class="nc">&nbsp;        int distance = Compute.effectiveDistance(game, ae, target);</b>
&nbsp;        
&nbsp;        //Set up our initial toHit data
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData();</b>
&nbsp;        
&nbsp;        //Check to see if this attack is impossible and return the reason code
<b class="nc">&nbsp;        String reasonImpossible = WeaponAttackAction.toHitIsImpossible(game, ae, attackerId, target, ttype, los, losMods,</b>
&nbsp;                toHit, distance, spotter, wtype, weapon, weaponId, atype, ammo, munition,
&nbsp;                isArtilleryDirect, isArtilleryFLAK, isArtilleryIndirect, isAttackerInfantry, isBearingsOnlyMissile,
&nbsp;                isCruiseMissile, exchangeSwarmTarget, isHoming, isInferno, isIndirect, isStrafing, isTAG,  
&nbsp;                targetInBuilding, usesAmmo, underWater);
<b class="nc">&nbsp;        if (reasonImpossible != null) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.IMPOSSIBLE, reasonImpossible);</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Check to see if this attack is automatically successful and return the reason code
<b class="nc">&nbsp;        String reasonAutoHit = WeaponAttackAction.toHitIsAutomatic(game, ae, target, ttype, los, distance,</b>
&nbsp;                wtype, weapon, isBearingsOnlyMissile);
<b class="nc">&nbsp;        if (reasonAutoHit != null) {</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, reasonAutoHit);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        SpecialResolutionTracker srt = new SpecialResolutionTracker();</b>
<b class="nc">&nbsp;        srt.setSpecialResolution(false);</b>
&nbsp;        //Is this an infantry leg/swarm attack?
<b class="nc">&nbsp;        toHit = handleInfantrySwarmAttacks(game, ae, target, ttype, toHit, wtype, srt);</b>
<b class="nc">&nbsp;        if (srt.isSpecialResolution()) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Check to see if this attack was made with a weapon that has special to-hit rules
<b class="nc">&nbsp;        toHit = handleSpecialWeaponAttacks(game, ae, target, ttype, los, toHit, wtype, atype, srt);</b>
<b class="nc">&nbsp;        if (srt.isSpecialResolution()) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
&nbsp;        //This attack has now tested possible and doesn&#39;t follow any weird special rules,
&nbsp;        //so let&#39;s start adding up the to-hit numbers
&nbsp;        
&nbsp;        //Start with the attacker&#39;s weapon skill
<b class="nc">&nbsp;        toHit = new ToHitData(ae.getCrew().getGunnery(), Messages.getString(&quot;WeaponAttackAction.GunSkill&quot;));</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.RPG_RPG_GUNNERY)) {</b>
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_ENERGY)) {</b>
<b class="nc">&nbsp;                toHit = new ToHitData(ae.getCrew().getGunneryL(), Messages.getString(&quot;WeaponAttackAction.GunLSkill&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                toHit = new ToHitData(ae.getCrew().getGunneryM(), Messages.getString(&quot;WeaponAttackAction.GunMSkill&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_BALLISTIC)) {</b>
<b class="nc">&nbsp;                toHit = new ToHitData(ae.getCrew().getGunneryB(), Messages.getString(&quot;WeaponAttackAction.GunBSkill&quot;));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_ARTILLERY) &amp;&amp; game.getOptions().booleanOption(OptionsConstants.RPG_ARTILLERY_SKILL)) {</b>
<b class="nc">&nbsp;            toHit = new ToHitData(ae.getCrew().getArtillery(), Messages.getString(&quot;WeaponAttackAction.ArtySkill&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Is this an Artillery attack?
<b class="nc">&nbsp;        if (isArtilleryDirect || isArtilleryIndirect) {</b>
<b class="nc">&nbsp;            toHit = handleArtilleryAttacks(game, ae, target, ttype, losMods, toHit, wtype, weapon, atype, isArtilleryDirect,</b>
&nbsp;                    isArtilleryFLAK, isArtilleryIndirect, isHoming, usesAmmo, srt);
&nbsp;        }
<b class="nc">&nbsp;        if (srt.isSpecialResolution()) {</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Mine launchers have their own base to-hit, but can still be affected by terrain and movement modifiers
&nbsp;        //thus, they don&#39;t qualify for special weapon handling
<b class="nc">&nbsp;        if (BattleArmor.MINE_LAUNCHER.equals(wtype.getInternalName())) {</b>
<b class="nc">&nbsp;            toHit = new ToHitData(8, Messages.getString(&quot;WeaponAttackAction.MagMine&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // TODO: mech making DFA could be higher if DFA target hex is higher
&nbsp;        // BMRr pg. 43, &quot;attacking unit is considered to be in the air
&nbsp;        // above the hex, standing on an elevation 1 level higher than
&nbsp;        // the target hex or the elevation of the hex the attacker is
&nbsp;        // in, whichever is higher.&quot;
&nbsp;            // Ancient rules - have we implemented this per TW?
&nbsp;        
&nbsp;        // Store the thruBldg state, for later processing
<b class="nc">&nbsp;        toHit.setThruBldg(los.getThruBldg());</b>
&nbsp;        
&nbsp;        // Collect the modifiers for the environment
<b class="nc">&nbsp;        toHit = compileEnvironmentalToHitMods(game, ae, target, wtype, atype, toHit, isArtilleryIndirect);</b>
&nbsp;        
&nbsp;        // Collect the modifiers for the crew/pilot
<b class="nc">&nbsp;        toHit = compileCrewToHitMods(game, ae, te, toHit, wtype);</b>
&nbsp;        
&nbsp;        // Collect the modifiers for the attacker&#39;s condition/actions
<b class="nc">&nbsp;        if (ae != null) {</b>
&nbsp;            //Conventional fighter, Aerospace and fighter LAM attackers
<b class="nc">&nbsp;            if (ae.isAero()) {</b>
<b class="nc">&nbsp;                toHit = compileAeroAttackerToHitMods(game, ae, target, ttype, toHit, aimingAt, aimingMode, eistatus,</b>
&nbsp;                            wtype, weapon, atype, munition, isArtilleryIndirect, isFlakAttack, isNemesisConfused, isStrafing,
&nbsp;                            usesAmmo);
&nbsp;            //Everyone else
&nbsp;            } else {
<b class="nc">&nbsp;                toHit = compileAttackerToHitMods(game, ae, target, los, toHit, toSubtract, aimingAt, aimingMode, wtype,</b>
&nbsp;                        weapon, weaponId, atype, munition, isFlakAttack, isHaywireINarced, isNemesisConfused,
&nbsp;                        isWeaponFieldGuns, usesAmmo);
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Collect the modifiers for the target&#39;s condition/actions 
<b class="nc">&nbsp;        toHit = compileTargetToHitMods(game, ae, target, ttype, los, toHit, toSubtract, aimingAt, aimingMode, distance,</b>
&nbsp;                    wtype, weapon, atype, munition, isArtilleryDirect, isArtilleryIndirect, isAttackerInfantry,
&nbsp;                    exchangeSwarmTarget, isIndirect, isPointblankShot, usesAmmo);
&nbsp;        
&nbsp;        // Collect the modifiers for terrain and line-of-sight. This includes any related to-hit table changes
<b class="nc">&nbsp;        toHit = compileTerrainAndLosToHitMods(game, ae, target, ttype, aElev, tElev, targEl, distance, los, toHit,</b>
&nbsp;                    losMods, toSubtract, eistatus, wtype, weapon, weaponId, atype, munition, isAttackerInfantry,
&nbsp;                    inSameBuilding, isIndirect, isPointblankShot, underWater);
&nbsp;        
&nbsp;        // If this is a swarm LRM secondary attack, remove old target movement and terrain mods, then
&nbsp;        // add those for new target.
<b class="nc">&nbsp;        if (exchangeSwarmTarget) {</b>
<b class="nc">&nbsp;            toHit = handleSwarmSecondaryAttacks(game, ae, target, swarmPrimaryTarget, swarmSecondaryTarget, toHit,</b>
&nbsp;                    toSubtract, eistatus, aimingAt, aimingMode, weapon, atype, munition, isECMAffected,
&nbsp;                    inSameBuilding, underWater);
&nbsp;        }
&nbsp;
&nbsp;        // Collect the modifiers specific to the weapon the attacker is using
<b class="nc">&nbsp;        toHit = compileWeaponToHitMods(game, ae, spotter, target, ttype, toHit, wtype, weapon, atype, munition,</b>
&nbsp;                    isFlakAttack, isIndirect, narcSpotter);
&nbsp;        
&nbsp;        // Collect the modifiers specific to the ammo the attacker is using
<b class="nc">&nbsp;        toHit = compileAmmoToHitMods(game, ae, target, ttype, toHit, wtype, weapon, atype, munition, bApollo,</b>
&nbsp;                    bArtemisV, bFTL, bHeatSeeking, isECMAffected, isINarcGuided);
&nbsp;        
&nbsp;        // okay!
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * To-hit number for attacker firing a generic weapon at the target. Does
&nbsp;     * not factor in any special weapon or ammo considerations, including range
&nbsp;     * modifiers. Also does not include gunnery skill.
&nbsp;     */
&nbsp;    public static ToHitData toHit(IGame game, int attackerId, Targetable target) {
<b class="nc">&nbsp;        final Entity ae = game.getEntity(attackerId);</b>
&nbsp;
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        int ttype = target.getTargetType();</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int aElev = ae.getElevation();</b>
<b class="nc">&nbsp;        int tElev = target.getElevation();</b>
&nbsp;        int targEl;
<b class="nc">&nbsp;        if (te == null) {</b>
<b class="nc">&nbsp;            targEl = game.getBoard().getHex(target.getPosition()).floor();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            targEl = te.relHeight();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        int toSubtract = 0;</b>
<b class="nc">&nbsp;        int distance = Compute.effectiveDistance(game, ae, target);</b>
&nbsp;        
&nbsp;        // EI system
&nbsp;        // 0 if no EI (or switched off)
&nbsp;        // 1 if no intervening light woods
&nbsp;        // 2 if intervening light woods (because target in woods + intervening
&nbsp;        // woods is only +1 total)
<b class="nc">&nbsp;        int eistatus = 0;</b>
&nbsp;        
&nbsp;        // Bogus value, since this method doesn&#39;t account for weapons but some of its calls do
<b class="nc">&nbsp;        int weaponId = WeaponType.WEAPON_NA;</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isAttackerInfantry = ae instanceof Infantry;</b>
<b class="nc">&nbsp;        boolean inSameBuilding = Compute.isInSameBuilding(game, ae, te);</b>
&nbsp;
&nbsp;        // check LOS
<b class="nc">&nbsp;        LosEffects los = LosEffects.calculateLos(game, attackerId, target);</b>
&nbsp;
<b class="nc">&nbsp;        if (ae.hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;            if (los.getLightWoods() &gt; 0) {</b>
<b class="nc">&nbsp;                eistatus = 2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                eistatus = 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ToHitData losMods = los.losModifiers(game, eistatus, ae.isUnderwater());</b>
<b class="nc">&nbsp;        ToHitData toHit = new ToHitData(0, Messages.getString(&quot;WeaponAttackAction.BaseToHit&quot;));</b>
&nbsp;        
&nbsp;        // Collect the modifiers for the environment
<b class="nc">&nbsp;        toHit = compileEnvironmentalToHitMods(game, ae, target, null, null, toHit, false);</b>
&nbsp;        
&nbsp;        // Collect the modifiers for the crew/pilot
<b class="nc">&nbsp;        toHit = compileCrewToHitMods(game, ae, te, toHit, null);</b>
&nbsp;        
&nbsp;        // Collect the modifiers for the attacker&#39;s condition/actions
<b class="nc">&nbsp;        if (ae != null) {</b>
&nbsp;            //Conventional fighter, Aerospace and fighter LAM attackers
<b class="nc">&nbsp;            if (ae.isAero()) {</b>
<b class="nc">&nbsp;                toHit = compileAeroAttackerToHitMods(game, ae, target, ttype, toHit, Entity.LOC_NONE,</b>
&nbsp;                            IAimingModes.AIM_MODE_NONE, eistatus,
&nbsp;                            null, null, null, AmmoType.M_STANDARD, false, false, false, false,
&nbsp;                            false);
&nbsp;            //Everyone else
&nbsp;            } else {
<b class="nc">&nbsp;                toHit = compileAttackerToHitMods(game, ae, target, los, toHit, toSubtract, Entity.LOC_NONE,</b>
&nbsp;                            IAimingModes.AIM_MODE_NONE, null,
&nbsp;                            null, weaponId, null, AmmoType.M_STANDARD, false, false, false,
&nbsp;                        false, false);
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Collect the modifiers for the target&#39;s condition/actions 
<b class="nc">&nbsp;        toHit = compileTargetToHitMods(game, ae, target, ttype, los, toHit, toSubtract, Entity.LOC_NONE,</b>
&nbsp;                    IAimingModes.AIM_MODE_NONE, distance,
&nbsp;                    null, null, null, AmmoType.M_STANDARD, false, false, isAttackerInfantry,
&nbsp;                    false, false, false, false);
&nbsp;        
&nbsp;        // Collect the modifiers for terrain and line-of-sight. This includes any related to-hit table changes
<b class="nc">&nbsp;        toHit = compileTerrainAndLosToHitMods(game, ae, target, ttype, aElev, tElev, targEl, distance, los, toHit,</b>
&nbsp;                    losMods, toSubtract, eistatus, null, null, weaponId, null, AmmoType.M_STANDARD, isAttackerInfantry,
&nbsp;                    inSameBuilding, false, false, false);
&nbsp;
&nbsp;        // okay!
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    
&nbsp;    /**
&nbsp;     * Method that tests each attack to see if it&#39;s impossible.
&nbsp;     * If so, a reason string will be returned. A null return means we can continue
&nbsp;     * processing the attack
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param attackerId  The ID number of the attacking entity
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param los The calculated LOS between attacker and target
&nbsp;     * @param losMods ToHitData calculated from the spotter for indirect fire scenarios
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param distance  The distance in hexes from attacker to target
&nbsp;     * @param spotter  The spotting entity for indirect fire, if present
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param ammo The Mounted ammo being used
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param isArtilleryDirect  flag that indicates whether this is a direct-fire artillery attack
&nbsp;     * @param isArtilleryFLAK  flag that indicates whether or not this is an artillery flak attack against an entity
&nbsp;     * @param isArtilleryIndirect  flag that indicates whether this is an indirect-fire artillery attack
&nbsp;     * @param isAttackerInfantry  flag that indicates whether the attacker is an infantry/BA unit
&nbsp;     * @param isBearingsOnlyMissile  flag that indicates whether this is a bearings-only capital missile attack
&nbsp;     * @param isCruiseMissile  flag that indicates whether this is a cruise missile artillery attack
&nbsp;     * @param exchangeSwarmTarget  flag that indicates whether this is the secondary target of Swarm LRMs
&nbsp;     * @param isHoming  flag that indicates whether this is a homing artillery attack
&nbsp;     * @param isIndirect  flag that indicates whether this is an indirect attack (LRM, mortar...)
&nbsp;     * @param isInferno  flag that indicates whether this is an inferno munition attack
&nbsp;     * @param isStrafing  flag that indicates whether this is an aero strafing attack
&nbsp;     * @param isTAG  flag that indicates whether this is a TAG attack
&nbsp;     * @param targetInBuilding  flag that indicates whether or not the target occupies a building hex
&nbsp;     * @param usesAmmo  flag that indicates whether or not the WeaponType being used is ammo-fed
&nbsp;     * @param underWater  flag that indicates whether or not the weapon being used is underwater
&nbsp;     */
&nbsp;    private static String toHitIsImpossible(IGame game, Entity ae, int attackerId, Targetable target, int ttype,
&nbsp;            LosEffects los, ToHitData losMods, ToHitData toHit, int distance, Entity spotter,
&nbsp;            WeaponType wtype, Mounted weapon, int weaponId, AmmoType atype, Mounted ammo, long munition,
&nbsp;            boolean isArtilleryDirect, boolean isArtilleryFLAK, boolean isArtilleryIndirect, boolean isAttackerInfantry,
&nbsp;            boolean isBearingsOnlyMissile, boolean isCruiseMissile, boolean exchangeSwarmTarget, boolean isHoming,
&nbsp;            boolean isInferno, boolean isIndirect, boolean isStrafing, boolean isTAG, boolean targetInBuilding,
&nbsp;            boolean usesAmmo, boolean underWater) {
&nbsp;        
&nbsp;        // Block the shot if the attacker is null
<b class="nc">&nbsp;        if (ae == null) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.NoAttacker&quot;);</b>
&nbsp;        }
&nbsp;        // Or if the target is null
<b class="nc">&nbsp;        if (target == null) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.NoTarget&quot;);</b>
&nbsp;        }
&nbsp;        // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;        if (toHit == null) {</b>
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some weapons only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If the attacker and target are in the same building &amp; hex, they can
&nbsp;        // always attack each other, TW pg 175.
<b class="nc">&nbsp;        if ((los.getThruBldg() != null) &amp;&amp; los.getTargetPosition().equals(ae.getPosition())) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // got ammo?
<b class="nc">&nbsp;        if (usesAmmo &amp;&amp; ((ammo == null) || (ammo.getUsableShotsLeft() == 0))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.OutOfAmmo&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Ammo-specific Reasons
<b class="nc">&nbsp;        if (atype != null) {</b>
&nbsp;            // Are we dumping that ammo?
<b class="nc">&nbsp;            if (usesAmmo &amp;&amp; ammo != null &amp;&amp; ammo.isDumping()) {</b>
<b class="nc">&nbsp;                ae.loadWeaponWithSameAmmo(weapon);</b>
<b class="nc">&nbsp;                if ((ammo.getUsableShotsLeft() == 0) || ammo.isDumping()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.DumpingAmmo&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // make sure weapon can deliver flares
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_FLARE_DELIVER) &amp;&amp; !(usesAmmo</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) </b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_MEK_MORTAR))</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_FLARE))) {
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoFlares&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // These ammo types can only target hexes for flare delivery
<b class="nc">&nbsp;            if (((atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MML))</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLARE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (target.getTargetType() != Targetable.TYPE_FLARE_DELIVER)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.OnlyFlare&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Aeros must have enough ammo for the maximum rate of fire because
&nbsp;            // they cannot lower it
<b class="nc">&nbsp;            if (ae.isAero() &amp;&amp; usesAmmo &amp;&amp; ammo != null &amp;&amp; weapon != null</b>
<b class="nc">&nbsp;                    &amp;&amp; (ae.getTotalAmmoOfType(ammo.getType()) &lt; weapon.getCurrentShots())) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.InsufficientAmmo&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Some Mek mortar ammo types can only be aimed at a hex
<b class="nc">&nbsp;            if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MEK_MORTAR)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getMunitionType() == AmmoType.M_AIRBURST) || (atype.getMunitionType() == AmmoType.M_FLARE)</b>
<b class="nc">&nbsp;                            || (atype.getMunitionType() == AmmoType.M_SMOKE_WARHEAD))) {</b>
<b class="nc">&nbsp;                if (!(target instanceof HexTarget)) {</b>
<b class="nc">&nbsp;                    return String.format(Messages.getString(&quot;WeaponAttackAction.AmmoAtHexOnly&quot;), atype.getSubMunitionName());</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // make sure weapon can deliver minefield
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER) </b>
<b class="nc">&nbsp;                    &amp;&amp; !AmmoType.canDeliverMinefield(atype)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoMinefields&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // These ammo types can only target hexes for minefield delivery
<b class="nc">&nbsp;            if (((atype.getAmmoType() == AmmoType.T_LRM) </b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MEK_MORTAR))</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getMunitionType() == AmmoType.M_THUNDER)</b>
<b class="nc">&nbsp;                            || (atype.getMunitionType() == AmmoType.M_THUNDER_ACTIVE)</b>
<b class="nc">&nbsp;                            || (atype.getMunitionType() == AmmoType.M_THUNDER_INFERNO)</b>
<b class="nc">&nbsp;                            || (atype.getMunitionType() == AmmoType.M_THUNDER_VIBRABOMB)</b>
<b class="nc">&nbsp;                            || (atype.getMunitionType() == AmmoType.M_THUNDER_AUGMENTED))</b>
<b class="nc">&nbsp;                    &amp;&amp; (target.getTargetType() != Targetable.TYPE_MINEFIELD_DELIVER)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.OnlyMinefields&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Attacker Action Reasons
&nbsp;
&nbsp;        // If the attacker is actively using a shield, weapons in the same location are blocked
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; ae.hasShield() &amp;&amp; ae.hasActiveShield(weapon.getLocation(), weapon.isRearMounted())) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.ActiveShieldBlocking&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //is the attacker even active?
<b class="nc">&nbsp;        if (ae.isShutDown() || !ae.getCrew().isActive()) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.AttackerNotReady&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If the attacker is involved in a grapple
<b class="nc">&nbsp;        if (ae.getGrappled() != Entity.NONE) {</b>
<b class="nc">&nbsp;            int grapple = ae.getGrappled();</b>
&nbsp;            // It can only target the unit it is grappling with
<b class="nc">&nbsp;            if (grapple != target.getTargetId()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.MustTargetGrappled&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (weapon != null) {</b>
<b class="nc">&nbsp;                int loc = weapon.getLocation();</b>
&nbsp;                // Can&#39;t fire arm and leg-mounted weapons while grappling
<b class="nc">&nbsp;                if (((ae instanceof Mech) &amp;&amp; (ae.getGrappleSide() == Entity.GRAPPLE_BOTH)</b>
&nbsp;                        &amp;&amp; ((loc != Mech.LOC_CT) &amp;&amp; (loc != Mech.LOC_LT) &amp;&amp; (loc != Mech.LOC_RT) &amp;&amp; (loc != Mech.LOC_HEAD)))
<b class="nc">&nbsp;                        || weapon.isRearMounted()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantFireWhileGrappled&quot;);</b>
&nbsp;                }
&nbsp;                // If caught by a chain whip, can&#39;t use weapons in the affected arm
<b class="nc">&nbsp;                if ((ae instanceof Mech) &amp;&amp; (ae.getGrappleSide() == Entity.GRAPPLE_LEFT) &amp;&amp; (loc == Mech.LOC_LARM)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantShootWhileChained&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((ae instanceof Mech) &amp;&amp; (ae.getGrappleSide() == Entity.GRAPPLE_RIGHT) &amp;&amp; (loc == Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantShootWhileChained&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Only large spacecraft can shoot while evading
<b class="nc">&nbsp;        if (ae.isEvading() &amp;&amp; !(ae instanceof Dropship) &amp;&amp; !(ae instanceof Jumpship)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.AeEvading&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //If we&#39;re lying mines, we can&#39;t shoot.
<b class="nc">&nbsp;        if (ae.isLayingMines()) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.BusyLayingMines&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Attacker prone and unable to fire?
<b class="nc">&nbsp;        ToHitData ProneMods = Compute.getProneMods(game, ae, weaponId);</b>
<b class="nc">&nbsp;        if ((ProneMods != null) &amp;&amp; ProneMods.getValue() == ToHitData.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            return ProneMods.getDesc();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // WiGE vehicles cannot fire at 0-range targets as they fly overhead
<b class="nc">&nbsp;        if ((ae.getMovementMode() == EntityMovementMode.WIGE) &amp;&amp; (ae.getPosition() == target.getPosition())) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.ZeroRangeTarget&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Crew Related Reasons
&nbsp;
&nbsp;        // Stunned vehicle crews can&#39;t make attacks
<b class="nc">&nbsp;        if (ae instanceof Tank &amp;&amp; ((Tank) ae).getStunnedTurns() &gt; 0) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.CrewStunned&quot;);</b>
&nbsp;        }
&nbsp;        // Vehicles with a single crewman can&#39;t shoot and unjam a RAC in the same turn (like mechs...) 
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_TANK_CREWS) </b>
<b class="nc">&nbsp;                &amp;&amp; (ae instanceof Tank) &amp;&amp; ae.isUnjammingRAC()</b>
<b class="nc">&nbsp;                &amp;&amp; (ae.getCrew().getSize() == 1)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.VeeSingleCrew&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Critical Damage Reasons
&nbsp;
&nbsp;
&nbsp;        // Aerospace units can&#39;t fire if the FCS/CIC is destroyed
<b class="nc">&nbsp;        if (ae instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero aero = (Aero) ae;</b>
&nbsp;            // FCS hits
<b class="nc">&nbsp;            int fcs = aero.getFCSHits();</b>
<b class="nc">&nbsp;            if (fcs &gt; 2) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.FCSDestroyed&quot;);</b>
&nbsp;            }
&nbsp;            // JS/WS/SS have CIC instead of FCS
<b class="nc">&nbsp;            if (aero instanceof Jumpship) {</b>
<b class="nc">&nbsp;                Jumpship js = (Jumpship) aero;</b>
<b class="nc">&nbsp;                int cic = js.getCICHits();</b>
<b class="nc">&nbsp;                if (cic &gt; 2) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CICDestroyed&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // Are the sensors operational?
&nbsp;        // Battlemech sensors are destroyed after 2 hits, unless they have a torso-mounted cockpit
<b class="nc">&nbsp;        int sensorHits = ae.getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_SENSORS, Mech.LOC_HEAD);</b>
<b class="nc">&nbsp;        if ((ae instanceof Mech) &amp;&amp; (((Mech) ae).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)) {</b>
<b class="nc">&nbsp;            sensorHits += ae.getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_SENSORS, Mech.LOC_CT);</b>
<b class="nc">&nbsp;            if (sensorHits &gt; 2) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.SensorsDestroyed&quot;);</b>
&nbsp;            }
&nbsp;        // Vehicles Sensor Hits
<b class="nc">&nbsp;        } else if (ae instanceof Tank) {</b>
<b class="nc">&nbsp;            sensorHits = ((Tank) ae).getSensorHits();</b>
<b class="nc">&nbsp;            if (sensorHits &gt; 3) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.SensorsDestroyed&quot;);</b>
&nbsp;            }
&nbsp;        // Industrialmechs and other unit types have destroyed sensors with 2 or more hits
<b class="nc">&nbsp;        } else if ((sensorHits &gt; 1)</b>
<b class="nc">&nbsp;                || ((ae instanceof Mech) &amp;&amp; (((Mech) ae).isIndustrial() &amp;&amp; (sensorHits == 1)))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.SensorsDestroyed&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Invalid Target Reasons
&nbsp;        
&nbsp;        //a friendly unit can never be the target of a direct attack.
&nbsp;        // but we do allow vehicle flamers to cool. Also swarm missile secondary targets and strafing are exempt.
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE) &amp;&amp; !isStrafing &amp;&amp; !exchangeSwarmTarget) {</b>
<b class="nc">&nbsp;            if (te != null &amp;&amp; !te.getOwner().isEnemyOf(ae.getOwner())) {</b>
<b class="nc">&nbsp;                if (!(usesAmmo &amp;&amp; atype != null &amp;&amp; (atype.getMunitionType() == AmmoType.M_COOLANT))) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoFriendlyTarget&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Can&#39;t fire at hidden targets
<b class="nc">&nbsp;        if ((target instanceof Entity) &amp;&amp; ((Entity)target).isHidden()) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.NoFireAtHidden&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Infantry can&#39;t clear woods.
<b class="nc">&nbsp;        if (isAttackerInfantry &amp;&amp; (Targetable.TYPE_HEX_CLEAR == target.getTargetType())) {</b>
<b class="nc">&nbsp;            IHex hexTarget = game.getBoard().getHex(target.getPosition());</b>
<b class="nc">&nbsp;            if (hexTarget.containsTerrain(Terrains.WOODS)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoInfantryWoodsClearing&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Can&#39;t target infantry with Inferno rounds (BMRr, pg. 141).
&nbsp;        // Also, enforce options for keeping vehicles and protos safe
&nbsp;        // if those options are checked.
<b class="nc">&nbsp;        if (isInferno &amp;&amp; (((te instanceof Tank)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_SAFE_FROM_INFERNOS))</b>
&nbsp;                || ((te instanceof Protomech)
<b class="nc">&nbsp;                        &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_PROTOS_SAFE_FROM_INFERNOS)))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.CantShootWithInferno&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Only weapons allowed to clear minefields can target a hex for minefield clearance
<b class="nc">&nbsp;        if ((target.getTargetType() == Targetable.TYPE_MINEFIELD_CLEAR) &amp;&amp; </b>
<b class="nc">&nbsp;                ((atype == null) || !AmmoType.canClearMinefield(atype))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.CantClearMines&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Mine Clearance munitions can only target hexes for minefield clearance
<b class="nc">&nbsp;        if (!(target instanceof HexTarget) &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (atype.getMunitionType() == AmmoType.M_MINE_CLEARANCE)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.MineClearHexOnly&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Only screen launchers may target a hex for screen launch
<b class="nc">&nbsp;        if (Targetable.TYPE_HEX_SCREEN == target.getTargetType()) {</b>
<b class="nc">&nbsp;            if (wtype != null &amp;&amp; </b>
<b class="nc">&nbsp;                    (!((wtype.getAmmoType() == AmmoType.T_SCREEN_LAUNCHER) || (wtype instanceof ScreenLauncherBayWeapon)))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.ScreenLauncherOnly&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Screen Launchers can only target hexes
<b class="nc">&nbsp;        if ((Targetable.TYPE_HEX_SCREEN != target.getTargetType())</b>
<b class="nc">&nbsp;                &amp;&amp; (wtype != null &amp;&amp; ((wtype.getAmmoType() == AmmoType.T_SCREEN_LAUNCHER)</b>
&nbsp;                        || (wtype instanceof ScreenLauncherBayWeapon)))) {
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.ScreenHexOnly&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Can&#39;t target an entity conducting a swarm attack.
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; (Entity.NONE != te.getSwarmTargetId())) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.TargetSwarming&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Tasers must target units and can&#39;t target flying units
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_TASER)) {</b>
<b class="nc">&nbsp;            if (te != null) {</b>
<b class="nc">&nbsp;                if (te.isAirborne() || te.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoTaserAtAirborne&quot;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TaserOnlyAtUnit&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // can&#39;t target yourself intentionally, but swarm missiles can come back to bite you
<b class="nc">&nbsp;        if (!exchangeSwarmTarget &amp;&amp; te != null &amp;&amp; ae.equals(te)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.NoSelfTarget&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Line of Sight and Range Reasons
&nbsp;
&nbsp;
&nbsp;        //attacker partial cover means no leg weapons
<b class="nc">&nbsp;        if (los.isAttackerCover() &amp;&amp; weapon != null &amp;&amp; ae.locationIsLeg(weapon.getLocation()) &amp;&amp; !underWater) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.LegBlockedByTerrain&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Must target infantry in buildings from the inside.
<b class="nc">&nbsp;        if (targetInBuilding &amp;&amp; (te instanceof Infantry)</b>
<b class="nc">&nbsp;                &amp;&amp; (null == los.getThruBldg())) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.CantShootThruBuilding&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //if LOS is blocked, block the shot except in the case of indirect artillery fire
<b class="nc">&nbsp;        if ((losMods.getValue() == TargetRoll.IMPOSSIBLE) &amp;&amp; !isArtilleryIndirect) {</b>
<b class="nc">&nbsp;                return losMods.getDesc();</b>
&nbsp;        }
&nbsp;
&nbsp;        //If using SO advanced sensors, the firing unit or one on its NC3 network must have a valid firing solution
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                &amp;&amp; ae.isSpaceborne()) {</b>
<b class="nc">&nbsp;            boolean networkFiringSolution = false;</b>
&nbsp;            //Check to see if the attacker has a firing solution. Naval C3 networks share targeting data
<b class="nc">&nbsp;            if (ae.hasNavalC3()) {</b>
<b class="nc">&nbsp;                for (Entity en : game.getC3NetworkMembers(ae)) {</b>
<b class="nc">&nbsp;                    if (te != null &amp;&amp; en.hasFiringSolutionFor(te.getId())) {</b>
<b class="nc">&nbsp;                        networkFiringSolution = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!networkFiringSolution) {</b>
&nbsp;                //If we don&#39;t check for target type here, we can&#39;t fire screens and missiles at hexes...
<b class="nc">&nbsp;                if (target.getTargetType() == Targetable.TYPE_ENTITY &amp;&amp; (te != null &amp;&amp; !ae.hasFiringSolutionFor(te.getId())))  {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoFiringSolution&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // http://www.classicbattletech.com/forums/index.php/topic,47618.0.html
&nbsp;        // anything outside of visual range requires a &quot;sensor lock&quot; in order to
&nbsp;        // direct fire. Note that this is for ground combat with tacops sensors rules
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                &amp;&amp; !ae.isSpaceborne()</b>
<b class="nc">&nbsp;                &amp;&amp; !Compute.inVisualRange(game, ae, target)</b>
<b class="nc">&nbsp;                &amp;&amp; !(Compute.inSensorRange(game, ae, target, null) </b>
&nbsp;                        // Can shoot at something in sensor range if it has
&nbsp;                        // been spotted by another unit
<b class="nc">&nbsp;                        &amp;&amp; (te != null) &amp;&amp; te.hasSeenEntity(ae.getOwner())) </b>
&nbsp;                &amp;&amp; !isArtilleryIndirect &amp;&amp; !isIndirect &amp;&amp; !isBearingsOnlyMissile) {
<b class="nc">&nbsp;            boolean networkSee = false;</b>
<b class="nc">&nbsp;            if (ae.hasC3() || ae.hasC3i() || ae.hasActiveNovaCEWS()) {</b>
&nbsp;                // c3 units can fire if any other unit in their network is in
&nbsp;                // visual or sensor range
<b class="nc">&nbsp;                for (Entity en : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (!en.isEnemyOf(ae) &amp;&amp; en.onSameC3NetworkAs(ae) &amp;&amp; Compute.canSee(game, en, target)) {</b>
<b class="nc">&nbsp;                        networkSee = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!networkSee) {</b>
<b class="nc">&nbsp;                if (!Compute.inSensorRange(game, ae, target, null)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoSensorTarget&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TargetNotSpotted&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //Torpedos must remain in the water over their whole path to the target
<b class="nc">&nbsp;        if ((atype != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SRM_TORPEDO)</b>
<b class="nc">&nbsp;                        || (((atype.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_SRM_IMP)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_MRM)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_MML)) &amp;&amp; (atype.getMunitionType() == AmmoType.M_TORPEDO)))</b>
<b class="nc">&nbsp;                &amp;&amp; (los.getMinimumWaterDepth() &lt; 1)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.TorpOutOfWater&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //Is the weapon blocked by a passenger?
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; (ae.isWeaponBlockedAt(weapon.getLocation(), weapon.isRearMounted()))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.PassengerBlock&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        //Is the weapon blocked by a tractor/trailer?
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; (ae.getTowing() != Entity.NONE || ae.getTowedBy() != Entity.NONE)) {</b>
<b class="nc">&nbsp;            if (ae.isWeaponBlockedByTowing(weapon.getLocation(), ae.getSecondaryFacing(), weapon.isRearMounted())) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TrailerBlock&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Phase Reasons
&nbsp;
&nbsp;        // Only bearings-only capital missiles and indirect fire artillery can be fired in the targeting phase
<b class="nc">&nbsp;        if ((game.getPhase() == IGame.Phase.PHASE_TARGETING) &amp;&amp; (!(isArtilleryIndirect || isBearingsOnlyMissile))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.NotValidForTargPhase&quot;);</b>
&nbsp;        }
&nbsp;        // Only TAG can be fired in the offboard phase
<b class="nc">&nbsp;        if ((game.getPhase() == IGame.Phase.PHASE_OFFBOARD) &amp;&amp; !isTAG) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.OnlyTagInOffboard&quot;);</b>
&nbsp;        }
&nbsp;        // TAG can&#39;t be fired in any phase but offboard
<b class="nc">&nbsp;        if ((game.getPhase() != IGame.Phase.PHASE_OFFBOARD) &amp;&amp; isTAG) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.TagOnlyInOffboard&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Unit-specific Reasons
&nbsp;        
&nbsp;        // Airborne units cannot tag and attack
&nbsp;        // http://bg.battletech.com/forums/index.php?topic=17613.new;topicseen#new
<b class="nc">&nbsp;        if (ae.isAirborne() &amp;&amp; ae.usedTag()) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.AeroCantTAGAndShoot&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Hull Down
&nbsp;
&nbsp;        // Hull down mechs cannot fire any leg weapons
<b class="nc">&nbsp;        if (ae.isHullDown() &amp;&amp; weapon != null) {</b>
<b class="nc">&nbsp;            if (((ae instanceof BipedMech)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((weapon.getLocation() == Mech.LOC_LLEG) || (weapon.getLocation() == Mech.LOC_RLEG)))</b>
<b class="nc">&nbsp;                    || ((ae instanceof QuadMech) &amp;&amp; ((weapon.getLocation() == Mech.LOC_LLEG)</b>
<b class="nc">&nbsp;                            || (weapon.getLocation() == Mech.LOC_RLEG) || (weapon.getLocation() == Mech.LOC_LARM)</b>
<b class="nc">&nbsp;                            || (weapon.getLocation() == Mech.LOC_RARM)))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoLegHullDown&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // hull down vees can&#39;t fire front weapons
<b class="nc">&nbsp;        if ((ae instanceof Tank) &amp;&amp; ae.isHullDown() &amp;&amp; weapon != null &amp;&amp; (weapon.getLocation() == Tank.LOC_FRONT)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.FrontBlockedByTerrain&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // LAMs in fighter mode are restricted to only the ammo types that Aeros can use
<b class="nc">&nbsp;        if ((ae instanceof LandAirMech) &amp;&amp; (ae.getConversionMode() == LandAirMech.CONV_MODE_FIGHTER)</b>
&nbsp;                &amp;&amp; usesAmmo &amp;&amp; ammo != null 
<b class="nc">&nbsp;                &amp;&amp; !((AmmoType)ammo.getType()).canAeroUse(game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_ARTILLERY_MUNITIONS))) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.InvalidAmmoForFighter&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // LAMs carrying certain types of bombs that require a weapon have attacks that cannot
&nbsp;        // be used in mech mode.
<b class="nc">&nbsp;        if ((ae instanceof LandAirMech)</b>
&nbsp;                &amp;&amp; wtype != null
<b class="nc">&nbsp;                &amp;&amp; (ae.getConversionMode() == LandAirMech.CONV_MODE_MECH)</b>
<b class="nc">&nbsp;                &amp;&amp; wtype.hasFlag(WeaponType.F_BOMB_WEAPON)</b>
<b class="nc">&nbsp;                &amp;&amp; wtype.getAmmoType() != AmmoType.T_RL_BOMB</b>
<b class="nc">&nbsp;                &amp;&amp; !wtype.hasFlag(WeaponType.F_TAG)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.NoBombInMechMode&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // limit large craft to zero net heat and to heat by arc
<b class="nc">&nbsp;        final int heatcap = ae.getHeatCapacity();</b>
<b class="nc">&nbsp;        if (ae.usesWeaponBays() &amp;&amp; weapon != null &amp;&amp; (weapon.getBayWeapons().size() &gt; 0)) {</b>
<b class="nc">&nbsp;            int totalheat = 0;</b>
&nbsp;
&nbsp;            // first check to see if there are any usable weapons
<b class="nc">&nbsp;            boolean useable = false;</b>
<b class="nc">&nbsp;            for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                Mounted m = ae.getEquipment(wId);</b>
<b class="nc">&nbsp;                WeaponType bayWType = ((WeaponType) m.getType());</b>
<b class="nc">&nbsp;                boolean bayWUsesAmmo = (bayWType.getAmmoType() != AmmoType.T_NA);</b>
<b class="nc">&nbsp;                if (m.canFire()) {</b>
<b class="nc">&nbsp;                    if (bayWUsesAmmo) {</b>
<b class="nc">&nbsp;                        if ((m.getLinked() != null) &amp;&amp; (m.getLinked().getUsableShotsLeft() &gt; 0)) {</b>
<b class="nc">&nbsp;                            useable = true;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        useable = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!useable) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.BayNotReady&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // create an array of booleans of locations
<b class="nc">&nbsp;            boolean[] usedFrontArc = new boolean[ae.locations()];</b>
<b class="nc">&nbsp;            boolean[] usedRearArc = new boolean[ae.locations()];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; ae.locations(); i++) {</b>
<b class="nc">&nbsp;                usedFrontArc[i] = false;</b>
<b class="nc">&nbsp;                usedRearArc[i] = false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                Object o = i.nextElement();</b>
<b class="nc">&nbsp;                if (!(o instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                WeaponAttackAction prevAttack = (WeaponAttackAction) o;</b>
&nbsp;                // Strafing attacks only count heat for first shot
<b class="nc">&nbsp;                if (prevAttack.isStrafing() &amp;&amp; !prevAttack.isStrafingFirstShot()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((prevAttack.getEntityId() == attackerId) &amp;&amp; (weaponId != prevAttack.getWeaponId())) {</b>
<b class="nc">&nbsp;                    Mounted prevWeapon = ae.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                    if (prevWeapon != null) {</b>
<b class="nc">&nbsp;                        int loc = prevWeapon.getLocation();</b>
<b class="nc">&nbsp;                        boolean rearMount = prevWeapon.isRearMounted();</b>
<b class="nc">&nbsp;                        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_HEAT_BY_BAY)) {</b>
<b class="nc">&nbsp;                            for (int bwId : prevWeapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                                totalheat += ae.getEquipment(bwId).getCurrentHeat();</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (!rearMount) {</b>
<b class="nc">&nbsp;                                if (!usedFrontArc[loc]) {</b>
<b class="nc">&nbsp;                                    totalheat += ae.getHeatInArc(loc, rearMount);</b>
<b class="nc">&nbsp;                                    usedFrontArc[loc] = true;</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (!usedRearArc[loc]) {</b>
<b class="nc">&nbsp;                                    totalheat += ae.getHeatInArc(loc, rearMount);</b>
<b class="nc">&nbsp;                                    usedRearArc[loc] = true;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // now check the current heat
<b class="nc">&nbsp;            int loc = weapon.getLocation();</b>
<b class="nc">&nbsp;            boolean rearMount = weapon.isRearMounted();</b>
<b class="nc">&nbsp;            int currentHeat = ae.getHeatInArc(loc, rearMount);</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_HEAT_BY_BAY)) {</b>
<b class="nc">&nbsp;                currentHeat = 0;</b>
<b class="nc">&nbsp;                for (int bwId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                    currentHeat += ae.getEquipment(bwId).getCurrentHeat();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // check to see if this is currently the only arc being fired
<b class="nc">&nbsp;            boolean onlyArc = true;</b>
<b class="nc">&nbsp;            for (int nLoc = 0; nLoc &lt; ae.locations(); nLoc++) {</b>
<b class="nc">&nbsp;                if (nLoc == loc) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (usedFrontArc[nLoc] || usedRearArc[nLoc]) {</b>
<b class="nc">&nbsp;                    onlyArc = false;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_HEAT_BY_BAY)) {</b>
<b class="nc">&nbsp;                if ((totalheat + currentHeat) &gt; heatcap) {</b>
&nbsp;                    // FIXME: This is causing weird problems (try firing all the
&nbsp;                    // Suffen&#39;s nose weapons)
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.HeatOverCap&quot;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (!rearMount) {</b>
<b class="nc">&nbsp;                    if (!usedFrontArc[loc] &amp;&amp; ((totalheat + currentHeat) &gt; heatcap) &amp;&amp; !onlyArc) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.HeatOverCap&quot;);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    if (!usedRearArc[loc] &amp;&amp; ((totalheat + currentHeat) &gt; heatcap) &amp;&amp; !onlyArc) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.HeatOverCap&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (ae instanceof Dropship) {</b>
<b class="nc">&nbsp;            int totalheat = 0;</b>
&nbsp;
<b class="nc">&nbsp;            for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                Object o = i.nextElement();</b>
<b class="nc">&nbsp;                if (!(o instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                WeaponAttackAction prevAttack = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                if ((prevAttack.getEntityId() == attackerId) &amp;&amp; (weaponId != prevAttack.getWeaponId())) {</b>
<b class="nc">&nbsp;                    Mounted prevWeapon = ae.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                    totalheat += prevWeapon.getCurrentHeat();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (weapon != null &amp;&amp; ((totalheat + weapon.getCurrentHeat()) &gt; heatcap)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.HeatOverCap&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Protomechs can&#39;t fire energy weapons while charging EDP armor
<b class="nc">&nbsp;        if ((ae instanceof Protomech) &amp;&amp; ((Protomech) ae).isEDPCharging() </b>
<b class="nc">&nbsp;                &amp;&amp; wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY)) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.ChargingEDP&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // for spheroid dropships in atmosphere (and on ground), the rules about
&nbsp;        // firing arcs are more complicated
&nbsp;        // TW errata 2.1
<b class="nc">&nbsp;        if ((Compute.useSpheroidAtmosphere(game, ae) ||</b>
<b class="nc">&nbsp;                (ae.isAero() &amp;&amp; ((IAero) ae).isSpheroid() &amp;&amp; (ae.getAltitude() == 0) &amp;&amp; game.getBoard().onGround()))</b>
&nbsp;                &amp;&amp; weapon != null) {
<b class="nc">&nbsp;            int altDif = target.getAltitude() - ae.getAltitude();</b>
<b class="nc">&nbsp;            int range = Compute.effectiveDistance(game, ae, target, false);</b>
&nbsp;            // Only aft-mounted weapons can be fired at range 0 (targets directly underneath)
<b class="nc">&nbsp;            if (!ae.isAirborne() &amp;&amp; (range == 0) &amp;&amp; (weapon.getLocation() != Aero.LOC_AFT)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.OnlyAftAtZero&quot;);</b>
&nbsp;            }
&nbsp;            // Nose-mounted weapons can only be fired at targets at least 1 altitude higher
<b class="nc">&nbsp;            if ((weapon.getLocation() == Aero.LOC_NOSE) &amp;&amp; (altDif &lt; 1)</b>
&nbsp;                    &amp;&amp; wtype != null
&nbsp;                    // Unless the weapon is used as artillery
<b class="nc">&nbsp;                    &amp;&amp; (!(wtype instanceof ArtilleryWeapon || wtype.hasFlag(WeaponType.F_ARTILLERY)</b>
<b class="nc">&nbsp;                            || (ae.getAltitude() == 0 &amp;&amp; wtype instanceof CapitalMissileWeapon)))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TooLowForNose&quot;);</b>
&nbsp;            }
&nbsp;            // Front-side-mounted weapons can only be fired at targets at the same altitude or higher
<b class="nc">&nbsp;            if ((!weapon.isRearMounted() &amp;&amp; (weapon.getLocation() != Aero.LOC_AFT)) &amp;&amp; (altDif &lt; 0)</b>
&nbsp;                    &amp;&amp; wtype != null
<b class="nc">&nbsp;                    &amp;&amp; !((wtype instanceof ArtilleryWeapon) || wtype.hasFlag(WeaponType.F_ARTILLERY))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TooLowForFrontSide&quot;);</b>
&nbsp;            }
&nbsp;            // Aft-mounted weapons can only be fired at targets at least 1 altitude lower
&nbsp;            // For grounded spheroids, weapons can only be fired at targets in occupied hexes, 
&nbsp;            // but it&#39;s not actually possible for a unit to occupy the same hex as a grounded spheroid so
&nbsp;            // we simplify the calculation a bit
<b class="nc">&nbsp;            if (weapon.getLocation() == Aero.LOC_AFT) {</b>
<b class="nc">&nbsp;                if(altDif &gt; -1) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TooHighForAft&quot;);</b>
&nbsp;                } 
&nbsp;                
&nbsp;                // if both targets are on the ground
&nbsp;                // and the target is below the attacker 
&nbsp;                // and the attacker is in one of the target&#39;s occupied hexes
&nbsp;                // then we can shoot aft weapons at it
&nbsp;                // note that this cannot actually happen in MegaMek currently but is left here for the possible eventuality
&nbsp;                // that overhanging dropships are implemented
<b class="nc">&nbsp;                if(!ae.isAirborne() &amp;&amp; !target.isAirborne()) {</b>
<b class="nc">&nbsp;                    boolean targetInAttackerHex = ae.getOccupiedCoords().contains(target.getPosition()) ||</b>
<b class="nc">&nbsp;                            ae.getPosition().equals(target.getPosition());</b>
<b class="nc">&nbsp;                    boolean targetBelowAttacker = game.getBoard().getHex(ae.getPosition()).surface() &gt;</b>
<b class="nc">&nbsp;                            game.getBoard().getHex(target.getPosition()).surface() + target.getElevation();</b>
&nbsp;                    
<b class="nc">&nbsp;                    if(!targetInAttackerHex || !targetBelowAttacker) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.GroundedSpheroidDropshipAftWeaponRestriction&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // and aft-side-mounted weapons can only be fired at targets at the same or lower altitude
<b class="nc">&nbsp;            if ((weapon.isRearMounted()) &amp;&amp; (altDif &gt; 0)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TooHighForAftSide&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (Compute.inDeadZone(game, ae, target)) {</b>
&nbsp;                // Only nose weapons can fire at targets in the dead zone at higher altitude
<b class="nc">&nbsp;                if ((altDif &gt; 0) &amp;&amp; (weapon.getLocation() != Aero.LOC_NOSE)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OnlyNoseInDeadZone&quot;);</b>
&nbsp;                }
&nbsp;                // and only aft weapons can fire at targets in the dead zone at lower altitude
<b class="nc">&nbsp;                if ((altDif &lt; 0) &amp;&amp; (weapon.getLocation() != Aero.LOC_AFT)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OnlyAftInDeadZone&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;        
&nbsp;        // Weapon-specific Reasons
&nbsp;        
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; wtype != null) {</b>
&nbsp;            // Variable setup
&nbsp;            
&nbsp;            // &quot;Cool&quot; mode for vehicle flamer requires coolant ammo
<b class="nc">&nbsp;            boolean vf_cool = false;</b>
<b class="nc">&nbsp;            if (atype != null &amp;&amp; ammo != null &amp;&amp; (((AmmoType) ammo.getType()).getMunitionType() == AmmoType.M_COOLANT)) {</b>
<b class="nc">&nbsp;                vf_cool = true;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Anti-Infantry weapons can only target infantry
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_INFANTRY_ONLY)) {</b>
<b class="nc">&nbsp;                if ((te != null) &amp;&amp; !(te instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TargetOnlyInf&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Air-to-ground attacks
<b class="nc">&nbsp;            if (Compute.isAirToGround(ae, target) &amp;&amp; !isArtilleryIndirect &amp;&amp; !ae.isDropping()) {</b>
&nbsp;                // Can&#39;t strike from above altitude 5. Dive bombing uses a different test below
<b class="nc">&nbsp;                if ((ae.getAltitude() &gt; 5) </b>
<b class="nc">&nbsp;                        &amp;&amp; !wtype.hasFlag(WeaponType.F_DIVE_BOMB) &amp;&amp; !wtype.hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.AttackerTooHigh&quot;);</b>
&nbsp;                }
&nbsp;                // Can&#39;t strafe from above altitude 3
<b class="nc">&nbsp;                if ((ae.getAltitude() &gt; 3) &amp;&amp; isStrafing) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.AttackerTooHigh&quot;);</b>
&nbsp;                }
&nbsp;                // Additional Nape-of-Earth restrictions for strafing
<b class="nc">&nbsp;                if (ae.getAltitude() == 1 &amp;&amp; isStrafing) {</b>
<b class="nc">&nbsp;                    Vector&lt;Coords&gt; passedThrough = ae.getPassedThrough();</b>
<b class="nc">&nbsp;                    if ((passedThrough.size() == 0) || passedThrough.get(0).equals(target.getPosition())) {</b>
&nbsp;                        // TW pg 243 says units flying at NOE have a harder time
&nbsp;                        // establishing LoS while strafing and hence have to
&nbsp;                        // consider the adjacent hex along the flight place in the
&nbsp;                        // direction of the attack. What if there is no adjacent
&nbsp;                        // hex? The rules don&#39;t address this. We could
&nbsp;                        // theoretically consider last turns movement, but that&#39;s
&nbsp;                        // cumbersome, so we&#39;ll just assume it&#39;s impossible - Arlith
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.TooCloseForStrafe&quot;);</b>
&nbsp;                    }
&nbsp;                    // Otherwise, check for a dead-zone, TW pg 243
<b class="nc">&nbsp;                    Coords prevCoords = ae.passedThroughPrevious(target.getPosition());</b>
<b class="nc">&nbsp;                    IHex prevHex = game.getBoard().getHex(prevCoords);</b>
<b class="nc">&nbsp;                    IHex currHex = game.getBoard().getHex(target.getPosition());</b>
<b class="nc">&nbsp;                    int prevElev = prevHex.getLevel();</b>
<b class="nc">&nbsp;                    int currElev = currHex.getLevel();</b>
<b class="nc">&nbsp;                    if ((prevElev - currElev - target.relHeight()) &gt; 2) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.DeadZone&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Only direct-fire energy weapons can strafe
<b class="nc">&nbsp;                boolean isDirectFireEnergy = (wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</b>
<b class="nc">&nbsp;                        &amp;&amp; (wtype.hasFlag(WeaponType.F_LASER) || wtype.hasFlag(WeaponType.F_PPC)</b>
<b class="nc">&nbsp;                                || wtype.hasFlag(WeaponType.F_PLASMA) || wtype.hasFlag(WeaponType.F_PLASMA_MFUK)))</b>
<b class="nc">&nbsp;                        || wtype.hasFlag(WeaponType.F_FLAMER);</b>
&nbsp;                // Note: flamers are direct fire energy, but don&#39;t have the flag,
&nbsp;                // so they won&#39;t work with targeting computers
<b class="nc">&nbsp;                boolean isEnergyBay = (wtype instanceof LaserBayWeapon) || (wtype instanceof PPCBayWeapon)</b>
&nbsp;                        || (wtype instanceof PulseLaserBayWeapon);
<b class="nc">&nbsp;                if (isStrafing &amp;&amp; !isDirectFireEnergy &amp;&amp; !isEnergyBay) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.StrafeDirectEnergyOnly&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // only certain weapons can be used for air to ground attacks
<b class="nc">&nbsp;                if (ae.isAero()) {</b>
&nbsp;                    // Spheroids can&#39;t strafe
<b class="nc">&nbsp;                    if (isStrafing &amp;&amp; ((IAero) ae).isSpheroid()) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.NoSpheroidStrafing&quot;);</b>
&nbsp;                    }
&nbsp;                    // Spheroid craft can only use aft or aft-side mounted weapons for strike attacks
<b class="nc">&nbsp;                    if (((IAero) ae).isSpheroid()) {</b>
<b class="nc">&nbsp;                        if ((weapon.getLocation() != Aero.LOC_AFT) &amp;&amp; !weapon.isRearMounted()) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.InvalidDSAtgArc&quot;);</b>
&nbsp;                        }
&nbsp;                    // LAMs can&#39;t use leg or rear-mounted weapons
<b class="nc">&nbsp;                    } else if (ae instanceof LandAirMech) {</b>
<b class="nc">&nbsp;                        if ((weapon.getLocation() == Mech.LOC_LLEG)</b>
<b class="nc">&nbsp;                                || (weapon.getLocation() == Mech.LOC_RLEG)</b>
<b class="nc">&nbsp;                                || weapon.isRearMounted()) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.InvalidAeroDSAtgArc&quot;);</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // and other types of aero can&#39;t use aft or rear-mounted weapons
<b class="nc">&nbsp;                        if ((weapon.getLocation() == Aero.LOC_AFT) || weapon.isRearMounted()) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.InvalidAeroDSAtgArc&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // for air to ground attacks, the target&#39;s position must be within
&nbsp;                // the flight path, unless it is an artillery weapon in the nose.
&nbsp;                // http://www.classicbattletech.com/forums/index.php?topic=65110.0
<b class="nc">&nbsp;                if (!ae.passedOver(target)) {</b>
<b class="nc">&nbsp;                    if (!wtype.hasFlag(WeaponType.F_ARTILLERY)) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.NotOnFlightPath&quot;);</b>
<b class="nc">&nbsp;                    } else if (weapon.getLocation() != Aero.LOC_NOSE) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.NotOnFlightPath&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Strike attacks cost the attacker 1 altitude
<b class="nc">&nbsp;                int altitudeLoss = 1;</b>
&nbsp;                // Dive bombing costs 2 altitude
<b class="nc">&nbsp;                if (wtype.hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
<b class="nc">&nbsp;                    altitudeLoss = 2;</b>
&nbsp;                }
&nbsp;                // Altitude bombing and strafing cost nothing
<b class="nc">&nbsp;                if (wtype.hasFlag(WeaponType.F_ALT_BOMB) || isStrafing) {</b>
<b class="nc">&nbsp;                    altitudeLoss = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                int altLossThisRound = 0;</b>
<b class="nc">&nbsp;                if (ae.isAero()) {</b>
<b class="nc">&nbsp;                    altLossThisRound = ((IAero) ae).getAltLossThisRound();</b>
&nbsp;                }
&nbsp;                // you cant make attacks that would lower you to zero altitude
<b class="nc">&nbsp;                if (altitudeLoss &gt;= (ae.getAltitude() + altLossThisRound)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TooMuchAltLoss&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // can only make a strike attack against a single target
<b class="nc">&nbsp;                if (!isStrafing) {</b>
<b class="nc">&nbsp;                    for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                        EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;                        if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        WeaponAttackAction prevAttk = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                        if ((prevAttk.getEntityId() == ae.getId()) &amp;&amp; (prevAttk.getTargetId() != target.getTargetId())</b>
<b class="nc">&nbsp;                                &amp;&amp; !wtype.hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.CantSplitFire&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            // VTOL Strafing
<b class="nc">&nbsp;            } else if ((ae instanceof VTOL) &amp;&amp; isStrafing) {</b>
<b class="nc">&nbsp;                if (!(wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</b>
<b class="nc">&nbsp;                        &amp;&amp; (wtype.hasFlag(WeaponType.F_LASER) || wtype.hasFlag(WeaponType.F_PPC)</b>
<b class="nc">&nbsp;                                || wtype.hasFlag(WeaponType.F_PLASMA) || wtype.hasFlag(WeaponType.F_PLASMA_MFUK)))</b>
<b class="nc">&nbsp;                        || wtype.hasFlag(WeaponType.F_FLAMER)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.StrafeDirectEnergyOnly&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.getLocation() != VTOL.LOC_FRONT</b>
<b class="nc">&nbsp;                        &amp;&amp; weapon.getLocation() != VTOL.LOC_TURRET</b>
<b class="nc">&nbsp;                        &amp;&amp; weapon.getLocation() != VTOL.LOC_TURRET_2) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.InvalidStrafingArc&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Artillery
&nbsp;            
&nbsp;            // Arty shots have to be with arty, non arty shots with non arty.
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_ARTILLERY)) {</b>
&nbsp;                // check artillery is targeted appropriately for its ammo
&nbsp;                // Artillery only targets hexes unless making a direct fire flak shot or using
&nbsp;                // homing ammo.
&nbsp;                
<b class="nc">&nbsp;                if ((ttype != Targetable.TYPE_HEX_ARTILLERY) &amp;&amp; (ttype != Targetable.TYPE_MINEFIELD_CLEAR)</b>
<b class="nc">&nbsp;                        &amp;&amp; !isArtilleryFLAK &amp;&amp; !isHoming &amp;&amp; !target.isOffBoard()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.ArtyAttacksOnly&quot;);</b>
&nbsp;                }
&nbsp;                // Airborne units can&#39;t make direct-fire artillery attacks
<b class="nc">&nbsp;                if (ae.isAirborne()) {</b>
<b class="nc">&nbsp;                    if (isArtilleryDirect) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.NoAeroDirectArty&quot;);</b>
<b class="nc">&nbsp;                    } else if (isArtilleryIndirect) {</b>
&nbsp;                        // and can only make indirect artillery attacks at altitude 9 or below
<b class="nc">&nbsp;                        if (ae.getAltitude() &gt; 9) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.TooHighForArty&quot;);</b>
&nbsp;                        }
&nbsp;                        // and finally, can only use Arrow IV artillery
<b class="nc">&nbsp;                        if (ae.usesWeaponBays()) {</b>
&nbsp;                            //For Dropships
<b class="nc">&nbsp;                            for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                                Mounted bayW = ae.getEquipment(wId);</b>
&nbsp;                                // check the loaded ammo for the Arrow IV flag
<b class="nc">&nbsp;                                Mounted bayWAmmo = bayW.getLinked();</b>
<b class="nc">&nbsp;                                AmmoType bAType = (AmmoType) bayWAmmo.getType();</b>
<b class="nc">&nbsp;                                if (bAType.getAmmoType() != AmmoType.T_ARROW_IV) {</b>
<b class="nc">&nbsp;                                    return Messages.getString(&quot;WeaponAttackAction.OnlyArrowArty&quot;);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } else if (wtype.getAmmoType() != AmmoType.T_ARROW_IV) {</b>
&nbsp;                            //For Fighters, LAMs, Small Craft and VTOLs
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.OnlyArrowArty&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (weapon.isInBearingsOnlyMode()) {</b>
&nbsp;                // We don&#39;t really need to do anything here. This just prevents these weapons
&nbsp;                // from passing the next test erroneously.
<b class="nc">&nbsp;            } else if (wtype instanceof CapitalMissileWeapon</b>
<b class="nc">&nbsp;                        &amp;&amp; Compute.isGroundToGround(ae, target)) {</b>
&nbsp;                // Grounded units firing capital missiles at ground targets must do so as artillery
<b class="nc">&nbsp;                if (ttype != Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.ArtyAttacksOnly&quot;);</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // weapon is not artillery
<b class="nc">&nbsp;                if (ttype == Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoArtyAttacks&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Direct-fire artillery attacks.
<b class="nc">&nbsp;            if (isArtilleryDirect) {</b>
&nbsp;                // Cruise missiles cannot make direct-fire attacks
<b class="nc">&nbsp;                if (isCruiseMissile) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoDirectCruiseMissile&quot;);</b>
&nbsp;                }
&nbsp;                // Direct fire artillery cannot be fired at less than 6 hexes
<b class="nc">&nbsp;                if (isArtilleryDirect &amp;&amp; !target.isAirborne() &amp;&amp; (Compute.effectiveDistance(game, ae, target) &lt;= 6)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TooShortForDirectArty&quot;);</b>
&nbsp;                }
&nbsp;                // ...or more than 17 hexes
<b class="nc">&nbsp;                if (distance &gt; Board.DEFAULT_BOARD_HEIGHT) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TooLongForDirectArty&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (isHoming) {</b>
<b class="nc">&nbsp;                    if ((te == null) || (te.getTaggedBy() == -1)) {</b>
&nbsp;                        // Homing missiles must target a tagged entity
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.MustTargetTagged&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Indirect artillery attacks
<b class="nc">&nbsp;            if (isArtilleryIndirect) {</b>
<b class="nc">&nbsp;                int boardRange = (int) Math.ceil(distance / 17f);</b>
<b class="nc">&nbsp;                int maxRange = wtype.getLongRange();</b>
&nbsp;                // Capital/subcapital missiles have a board range equal to their max space hex range
<b class="nc">&nbsp;                if (wtype instanceof CapitalMissileWeapon) {</b>
<b class="nc">&nbsp;                    if (wtype.getMaxRange(weapon) == WeaponType.RANGE_EXT) {</b>
<b class="nc">&nbsp;                        maxRange = 50;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (wtype.getMaxRange(weapon) == WeaponType.RANGE_LONG) {</b>
<b class="nc">&nbsp;                        maxRange = 40;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (wtype.getMaxRange(weapon) == WeaponType.RANGE_MED) {</b>
<b class="nc">&nbsp;                        maxRange = 24;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (wtype.getMaxRange(weapon) == WeaponType.RANGE_SHORT) {</b>
<b class="nc">&nbsp;                        maxRange = 12;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // Maximum range is measured in mapsheets
<b class="nc">&nbsp;                if (boardRange &gt; maxRange) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OutOfRange&quot;);</b>
&nbsp;                }
&nbsp;                // Indirect shots cannot be made at less than 17 hexes range unless
&nbsp;                // the attacker is airborne or has no line-of-sight
<b class="nc">&nbsp;                if (((distance &lt;= Board.DEFAULT_BOARD_HEIGHT) &amp;&amp; !ae.isAirborne()) </b>
<b class="nc">&nbsp;                        &amp;&amp; !(losMods.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TooShortForIndirectArty&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (isHoming) {</b>
&nbsp;                    // Homing missiles must target a hex (mapsheet)
<b class="nc">&nbsp;                    if (ttype != Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.HomingMapsheetOnly&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Ballistic and Missile weapons are subject to wind conditions
<b class="nc">&nbsp;            int windCond = game.getPlanetaryConditions().getWindStrength();</b>
<b class="nc">&nbsp;            if ((windCond == PlanetaryConditions.WI_TORNADO_F13) &amp;&amp; wtype.hasFlag(WeaponType.F_MISSILE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoMissileTornado&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((windCond == PlanetaryConditions.WI_TORNADO_F4) &amp;&amp; !game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                    &amp;&amp; (wtype.hasFlag(WeaponType.F_MISSILE) || wtype.hasFlag(WeaponType.F_BALLISTIC))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.F4Tornado&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Battle Armor
&nbsp;            
&nbsp;            // BA can only make one AP attack
<b class="nc">&nbsp;            if ((ae instanceof BattleArmor) &amp;&amp; wtype.hasFlag(WeaponType.F_INFANTRY)) {</b>
<b class="nc">&nbsp;                final int weapId = ae.getEquipmentNum(weapon);</b>
&nbsp;                // See if this unit has made a previous AP attack
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    Object o = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(o instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) o;</b>
&nbsp;                    // Is this an attack from this entity
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == ae.getId()) {</b>
<b class="nc">&nbsp;                        Mounted prevWeapon = ae.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                        WeaponType prevWtype = (WeaponType) prevWeapon.getType();</b>
<b class="nc">&nbsp;                        if (prevWtype.hasFlag(WeaponType.F_INFANTRY) &amp;&amp; (prevAttack.getWeaponId() != weapId)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.OnlyOneBAAPAttack&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            
&nbsp;            // BA compact narc: we have one weapon for each trooper, but you
&nbsp;            // can fire only at one target at a time
<b class="nc">&nbsp;            if (wtype.getName().equals(&quot;Compact Narc&quot;)) {</b>
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == attackerId) {</b>
<b class="nc">&nbsp;                        Mounted prevWeapon = ae.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                        if (prevWeapon.getType().getName().equals(&quot;Compact Narc&quot;)) {</b>
<b class="nc">&nbsp;                            if (prevAttack.getTargetId() != target.getTargetId()) {</b>
<b class="nc">&nbsp;                                return Messages.getString(&quot;WeaponAttackAction.OneTargetForCNarc&quot;);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            
&nbsp;            // BA Mine launchers can not hit infantry
<b class="nc">&nbsp;            if (BattleArmor.MINE_LAUNCHER.equals(wtype.getInternalName())) {</b>
<b class="nc">&nbsp;                if (te instanceof Infantry) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantShootInfantry&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // BA NARCs and Tasers can only fire at one target in a round
<b class="nc">&nbsp;            if ((ae instanceof BattleArmor)</b>
<b class="nc">&nbsp;                    &amp;&amp; (wtype.hasFlag(WeaponType.F_TASER) || wtype.getAmmoType() == AmmoType.T_NARC)) {</b>
&nbsp;                // Go through all of the current actions to see if a NARC or Taser
&nbsp;                // has been fired
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    Object o = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(o instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) o;</b>
&nbsp;                    // Is this an attack from this entity to a different target?
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == ae.getId() &amp;&amp; prevAttack.getTargetId() != target.getTargetId()) {</b>
<b class="nc">&nbsp;                        Mounted prevWeapon = ae.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                        WeaponType prevWtype = (WeaponType) prevWeapon.getType();</b>
<b class="nc">&nbsp;                        if (prevWeapon.getType().hasFlag(WeaponType.F_TASER)</b>
<b class="nc">&nbsp;                                &amp;&amp; weapon.getType().hasFlag(WeaponType.F_TASER)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.BATaserSameTarget&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (prevWtype.getAmmoType() == AmmoType.T_NARC &amp;&amp; wtype.getAmmoType() == AmmoType.T_NARC) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.BANarcSameTarget&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            
&nbsp;            // BA squad support weapons require that Trooper 1 be alive to use
<b class="nc">&nbsp;            if (weapon.isSquadSupportWeapon() &amp;&amp; (ae instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                if (!((BattleArmor) ae).isTrooperActive(BattleArmor.LOC_TROOPER_1)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoSquadSupport&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Bombs and such
&nbsp;            
&nbsp;            // Anti ship missiles can&#39;t be launched from altitude 3 or lower
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_ANTI_SHIP) &amp;&amp; !game.getBoard().inSpace() &amp;&amp; (ae.getAltitude() &lt; 4)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TooLowForASM&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // ASEW Missiles cannot be launched in an atmosphere
<b class="nc">&nbsp;            if ((wtype.getAmmoType() == AmmoType.T_ASEW_MISSILE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !ae.isSpaceborne()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.ASEWAtmo&quot;);</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (ae.isAero()) {</b>
&nbsp;                // Can&#39;t mix bombing with other attack types
&nbsp;                // also for altitude bombing, the target hex must either be the first in a line
&nbsp;                // adjacent to a prior one
<b class="nc">&nbsp;                boolean adjacentAltBomb = false;</b>
<b class="nc">&nbsp;                boolean firstAltBomb = true;</b>
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    Object o = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(o instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == attackerId) {</b>
&nbsp;                        // You also can&#39;t mix and match the 3 different types of bombing:  Space, Dive and Altitude
<b class="nc">&nbsp;                        if ((weaponId != prevAttack.getWeaponId())</b>
<b class="nc">&nbsp;                                &amp;&amp; ae.getEquipment(prevAttack.getWeaponId()).getType().hasFlag(WeaponType.F_SPACE_BOMB)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.BusySpaceBombing&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if ((weaponId != prevAttack.getWeaponId())</b>
<b class="nc">&nbsp;                                &amp;&amp; ae.getEquipment(prevAttack.getWeaponId()).getType().hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.BusyDiveBombing&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if ((weaponId != prevAttack.getWeaponId())</b>
<b class="nc">&nbsp;                                &amp;&amp; ae.getEquipment(prevAttack.getWeaponId()).getType().hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                            if (!wtype.hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                                return Messages.getString(&quot;WeaponAttackAction.BusyAltBombing&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            firstAltBomb = false;</b>
<b class="nc">&nbsp;                            int bombDistance = prevAttack.getTarget(game).getPosition().distance(target.getPosition());</b>
<b class="nc">&nbsp;                            if (bombDistance == 1) {</b>
<b class="nc">&nbsp;                                adjacentAltBomb = true;</b>
&nbsp;                            }
&nbsp;                            // For altitude bombing, prevent targeting the same hex twice
<b class="nc">&nbsp;                            if (bombDistance == 0) {</b>
<b class="nc">&nbsp;                                return Messages.getString(&quot;WeaponAttackAction.AlreadyBombingHex&quot;);</b>
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (wtype.hasFlag(WeaponType.F_ALT_BOMB) &amp;&amp; !firstAltBomb &amp;&amp; !adjacentAltBomb) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.BombNotInLine&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Altitude and dive bombing attacks...
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_DIVE_BOMB) || wtype.hasFlag(WeaponType.F_ALT_BOMB)) {</b>
&nbsp;                // Can&#39;t fire if the unit is out of bombs
<b class="nc">&nbsp;                if (ae.getBombs(AmmoType.F_GROUND_BOMB).isEmpty()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OutOfBombs&quot;);</b>
&nbsp;                }
&nbsp;                // Spheroid Aeros can&#39;t bomb
<b class="nc">&nbsp;                if (ae.isAero() &amp;&amp; ((IAero) ae).isSpheroid()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoSpheroidBombing&quot;);</b>
&nbsp;                }
&nbsp;                // Grounded Aeros can&#39;t bomb
<b class="nc">&nbsp;                if (!ae.isAirborne() &amp;&amp; !ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.GroundedAeroCantBomb&quot;);</b>
&nbsp;                }
&nbsp;                // Bomb attacks can only target hexes
<b class="nc">&nbsp;                if (target.getTargetType() != Targetable.TYPE_HEX_AERO_BOMB) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.BombTargetHexOnly&quot;);</b>
&nbsp;                }
&nbsp;                // Can&#39;t target a hex that isn&#39;t on the flight path
<b class="nc">&nbsp;                if (!ae.passedOver(target)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantBombOffFlightPath&quot;);</b>
&nbsp;                }
&nbsp;                // Dive Bombing can only be conducted if starting between altitude 5 and altitude 3
<b class="nc">&nbsp;                if (wtype.hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
<b class="nc">&nbsp;                    if (ae.getAltitude() &gt; DiveBombAttack.DIVE_BOMB_MAX_ALTITUDE) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.TooHighForDiveBomb&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (ae.isAero()) {</b>
<b class="nc">&nbsp;                        int altLoss = ((IAero) ae).getAltLossThisRound();</b>
<b class="nc">&nbsp;                        if ((ae.getAltitude() + altLoss) &lt; DiveBombAttack.DIVE_BOMB_MIN_ALTITUDE) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.TooLowForDiveBomb&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Can&#39;t attack bomb hex targets with weapons other than alt/dive bombs
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB) &amp;&amp; !wtype.hasFlag(WeaponType.F_DIVE_BOMB)</b>
<b class="nc">&nbsp;                    &amp;&amp; !wtype.hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.InvalidForBombing&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // BA Micro bombs only when flying
<b class="nc">&nbsp;            if ((atype != null) &amp;&amp; (atype.getAmmoType() == AmmoType.T_BA_MICRO_BOMB)) {</b>
<b class="nc">&nbsp;                if (!ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.MinimumAlt1&quot;);</b>
&nbsp;                // and can only target hexes
<b class="nc">&nbsp;                } else if (target.getTargetType() != Targetable.TYPE_HEX_BOMB) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.BombTargetHexOnly&quot;);</b>
&nbsp;                // and can only be dropped at exactly altitude 1
<b class="nc">&nbsp;                } else if (ae.getElevation() != 1) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.ExactlyAlt1&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Can&#39;t attack a Micro Bomb hex target with other weapons
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_HEX_BOMB)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(usesAmmo &amp;&amp; atype != null &amp;&amp; (atype.getAmmoType() == AmmoType.T_BA_MICRO_BOMB))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.InvalidForBombing&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Space bombing attacks
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_SPACE_BOMB) &amp;&amp; te != null) {</b>
<b class="nc">&nbsp;                toHit = Compute.getSpaceBombBaseToHit(ae, te, game);</b>
&nbsp;                // Return if the attack is impossible.
<b class="nc">&nbsp;                if (TargetRoll.IMPOSSIBLE == toHit.getValue()) {</b>
<b class="nc">&nbsp;                    return toHit.getDesc();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // B-Pods
&nbsp;
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_B_POD)) {</b>
&nbsp;                // B-Pods are only effective against infantry
<b class="nc">&nbsp;                if (!(target instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.BPodOnlyAtInf&quot;);</b>
&nbsp;                }
&nbsp;                // Leg-mounted B-Pods can be fired at infantry in the attacker&#39;s hex, other locations
&nbsp;                // can only be fired in response to leg/swarm attacks
<b class="nc">&nbsp;                if (ae instanceof BipedMech) {</b>
<b class="nc">&nbsp;                    if (!((weapon.getLocation() == Mech.LOC_LLEG) || (weapon.getLocation() == Mech.LOC_RLEG))) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.OnlyLegBPod&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (ae instanceof QuadMech) {</b>
<b class="nc">&nbsp;                    if (!((weapon.getLocation() == Mech.LOC_LLEG) || (weapon.getLocation() == Mech.LOC_RLEG)</b>
<b class="nc">&nbsp;                            || (weapon.getLocation() == Mech.LOC_LARM) || (weapon.getLocation() == Mech.LOC_RARM))) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.OnlyLegBPod&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Called shots
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CALLED_SHOTS)) {</b>
<b class="nc">&nbsp;                String reason = weapon.getCalledShot().isValid(target);</b>
<b class="nc">&nbsp;                if (reason != null) {</b>
<b class="nc">&nbsp;                    return reason;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Capital Mass Drivers can only fire at targets directly in front of the attacker
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_ENTITY) &amp;&amp; wtype.hasFlag(WeaponType.F_MASS_DRIVER)</b>
&nbsp;                    &amp;&amp; (ae instanceof SpaceStation)) {
<b class="nc">&nbsp;                if (!ae.getPosition().translated(ae.getFacing(), Compute.effectiveDistance(game, ae, target)).equals(target.getPosition())) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.MassDriverFrontOnly&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Capital missiles in bearings-only mode
<b class="nc">&nbsp;            if (isBearingsOnlyMissile) {</b>
&nbsp;                //Can&#39;t target anything beyond max range of 5,000 hexes
&nbsp;                //This is an arbitrary number. If your map size is really this large, you&#39;ll probably crash the game
<b class="nc">&nbsp;                if (distance &gt; RangeType.RANGE_BEARINGS_ONLY_OUT) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OutOfRange&quot;);</b>
&nbsp;                }
&nbsp;                // Can&#39;t fire in bearings-only mode within direct-fire range (50 hexes)
<b class="nc">&nbsp;                if (game.getPhase() == IGame.Phase.PHASE_TARGETING &amp;&amp; distance &lt; RangeType.RANGE_BEARINGS_ONLY_MINIMUM) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.BoMissileMinRange&quot;);</b>
&nbsp;                } 
&nbsp;                // Can&#39;t target anything but hexes
<b class="nc">&nbsp;                if (ttype != Targetable.TYPE_HEX_ARTILLERY) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.BOHexOnly&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Capital weapons fire by grounded units
<b class="nc">&nbsp;            if (wtype.isSubCapital() || wtype.isCapital()) {</b>
&nbsp;                // Can&#39;t fire any but capital/subcapital missiles surface to surface
<b class="nc">&nbsp;                if (Compute.isGroundToGround(ae, target)</b>
&nbsp;                        &amp;&amp; !(wtype instanceof CapitalMissileWeapon)) {
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoS2SCapWeapons&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Causing Fires
&nbsp;            
&nbsp;            // Some weapons can&#39;t cause fires, but Infernos always can.
<b class="nc">&nbsp;            if ((vf_cool || (wtype.hasFlag(WeaponType.F_NO_FIRES) &amp;&amp; !isInferno))</b>
<b class="nc">&nbsp;                    &amp;&amp; (Targetable.TYPE_HEX_IGNITE == target.getTargetType())) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.WeaponCantIgnite&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // only woods and buildings can be set intentionally on fire
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_HEX_IGNITE)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_NO_IGNITE_CLEAR)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(game.getBoard().getHex(((HexTarget) target).getPosition()).containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(((HexTarget) target).getPosition()).containsTerrain(Terrains.JUNGLE)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(((HexTarget) target).getPosition())</b>
<b class="nc">&nbsp;                                    .containsTerrain(Terrains.FUEL_TANK)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(((HexTarget) target).getPosition())</b>
<b class="nc">&nbsp;                                    .containsTerrain(Terrains.BUILDING))) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.CantIntentionallyBurn&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Conventional Infantry Attacks
&nbsp;            
<b class="nc">&nbsp;            if (isAttackerInfantry &amp;&amp; !(ae instanceof BattleArmor)) {</b>
&nbsp;                // 0 MP infantry units: move or shoot, except for anti-mech attacks,
&nbsp;                // those are handled above
<b class="nc">&nbsp;                if ((ae.getMovementMode() == EntityMovementMode.INF_LEG) &amp;&amp; (ae.getWalkMP() == 0)</b>
&nbsp;                        &amp;&amp; (ae.moved != EntityMovementType.MOVE_NONE)) {
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.0MPInf&quot;);</b>
&nbsp;                }
&nbsp;                // Can&#39;t shoot if platoon used fast movement
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_FAST_INFANTRY_MOVE)</b>
&nbsp;                        &amp;&amp; (ae.moved == EntityMovementType.MOVE_RUN)) {
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantShootAndFastMove&quot;);</b>
&nbsp;                }
&nbsp;                // check for trying to fire field gun after moving
<b class="nc">&nbsp;                if ((weapon.getLocation() == Infantry.LOC_FIELD_GUNS) &amp;&amp; (ae.moved != EntityMovementType.MOVE_NONE)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantMoveAndFieldGun&quot;);</b>
&nbsp;                }
&nbsp;                // check for mixing infantry and field gun attacks
<b class="nc">&nbsp;                double fieldGunWeight = 0.0;</b>
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == attackerId) {</b>
<b class="nc">&nbsp;                        Mounted prevWeapon = ae.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                        if ((prevWeapon.getType().hasFlag(WeaponType.F_INFANTRY)</b>
<b class="nc">&nbsp;                                &amp;&amp; (weapon.getLocation() == Infantry.LOC_FIELD_GUNS))</b>
<b class="nc">&nbsp;                                || (weapon.getType().hasFlag(WeaponType.F_INFANTRY)</b>
<b class="nc">&nbsp;                                        &amp;&amp; (prevWeapon.getLocation() == Infantry.LOC_FIELD_GUNS))) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.FieldGunOrSAOnly&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if ((weapon.getLocation() == Infantry.LOC_FIELD_GUNS) &amp;&amp; (weaponId != prevAttack.getWeaponId())) {</b>
<b class="nc">&nbsp;                            fieldGunWeight += prevWeapon.getTonnage();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // the total tonnage of field guns fired has to be less than or
&nbsp;                // equal to the men in the platoon
<b class="nc">&nbsp;                if (weapon.getLocation() == Infantry.LOC_FIELD_GUNS) {</b>
<b class="nc">&nbsp;                    if (((Infantry) ae).getShootingStrength() &lt; Math.ceil(fieldGunWeight + weapon.getTonnage())) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.NoFieldGunCrew&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Extinguishing Fires
&nbsp;
&nbsp;            // You can use certain types of flamer/sprayer ammo or infantry firefighting engineers
&nbsp;            // to extinguish burning hexes (and units).
&nbsp;            // TODO: This functionality does not appear to be implemented
<b class="nc">&nbsp;            if (Targetable.TYPE_HEX_EXTINGUISH == target.getTargetType()) {</b>
<b class="nc">&nbsp;                if (!wtype.hasFlag(WeaponType.F_EXTINGUISHER) &amp;&amp; !vf_cool) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.InvalidForFirefighting&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                IHex hexTarget = game.getBoard().getHex(target.getPosition());</b>
<b class="nc">&nbsp;                if (!hexTarget.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TargetNotBurning&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (wtype.hasFlag(WeaponType.F_EXTINGUISHER)) {</b>
<b class="nc">&nbsp;                if (!(((target instanceof Tank) &amp;&amp; ((Tank) target).isOnFire())</b>
<b class="nc">&nbsp;                        || ((target instanceof Entity) &amp;&amp; (((Entity) target).infernos.getTurnsLeftToBurn() &gt; 0)))) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.TargetNotBurning&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Gauss weapons using the TacOps powered down rule can&#39;t fire
<b class="nc">&nbsp;            if ((wtype instanceof GaussWeapon) </b>
<b class="nc">&nbsp;                    &amp;&amp; wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_GAUSS_POWERED_DOWN)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.WeaponNotReady&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Ground-to-air attacks
&nbsp;            
&nbsp;            // air2air and air2ground cannot be combined by any aerospace units
<b class="nc">&nbsp;            if (Compute.isAirToAir(ae, target) || Compute.isAirToGround(ae, target)) {</b>
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() != ae.getId()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (Compute.isAirToAir(ae, target) &amp;&amp; prevAttack.isAirToGround(game)) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.AlreadyAtgAttack&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (Compute.isAirToGround(ae, target) &amp;&amp; prevAttack.isAirToAir(game)) {</b>
<b class="nc">&nbsp;                        return Messages.getString(&quot;WeaponAttackAction.AlreadyAtaAttack&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Can&#39;t make ground-to-air attacks against a target above altitude 8
<b class="nc">&nbsp;            if ((target.getAltitude() &gt; 8) &amp;&amp; Compute.isGroundToAir(ae, target)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.AeroTooHighForGta&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Infantry can&#39;t make ground-to-air attacks, unless using field guns, specialized AA infantry weapons,
&nbsp;            // or direct-fire artillery flak attacks
<b class="nc">&nbsp;            boolean isWeaponFieldGuns = isAttackerInfantry &amp;&amp; (weapon.getLocation() == Infantry.LOC_FIELD_GUNS);</b>
<b class="nc">&nbsp;            if ((ae instanceof Infantry) &amp;&amp; Compute.isGroundToAir(ae, target) &amp;&amp; !wtype.hasFlag(WeaponType.F_INF_AA)</b>
&nbsp;                    &amp;&amp; !isArtilleryFLAK
&nbsp;                    &amp;&amp; !isWeaponFieldGuns) {
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoInfantryGta&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // only one ground-to-air attack allowed per turn
&nbsp;            // grounded spheroid dropships dont have this limitation
<b class="nc">&nbsp;            if (!ae.isAirborne() &amp;&amp; !((ae instanceof Dropship) &amp;&amp; ((Aero) ae).isSpheroid())) {</b>
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == ae.getId()) {</b>
<b class="nc">&nbsp;                        if (prevAttack.isGroundToAir(game) &amp;&amp; !Compute.isGroundToAir(ae, target)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.AlreadyGtaAttack&quot;);</b>
&nbsp;                        }
&nbsp;                        // Can&#39;t mix ground-to-air and ground-to-ground attacks either
<b class="nc">&nbsp;                        if (!prevAttack.isGroundToAir(game) &amp;&amp; Compute.isGroundToAir(ae, target)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.AlreadyGtgAttack&quot;);</b>
&nbsp;                        }
&nbsp;                        // Or split ground-to-air fire across multiple targets
<b class="nc">&nbsp;                        if (prevAttack.isGroundToAir(game) &amp;&amp; Compute.isGroundToAir(ae, target) &amp;&amp; (null != te)</b>
<b class="nc">&nbsp;                                &amp;&amp; (prevAttack.getTargetId() != te.getId())) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.OneTargetForGta&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Indirect Fire (LRMs)
&nbsp;            
&nbsp;            // Can&#39;t fire Indirect LRM with direct LOS
<b class="nc">&nbsp;            if (isIndirect &amp;&amp; game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)</b>
<b class="nc">&nbsp;                    &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_INDIRECT_ALWAYS_POSSIBLE)</b>
<b class="nc">&nbsp;                    &amp;&amp; LosEffects.calculateLos(game, ae.getId(), target).canSee()</b>
<b class="nc">&nbsp;                    &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                            || Compute.canSee(game, ae, target))</b>
&nbsp;                    &amp;&amp; !(wtype instanceof ArtilleryCannonWeapon) &amp;&amp; !(wtype instanceof MekMortarWeapon)) {
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoIndirectWithLOS&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Can&#39;t fire Indirect LRMs if the option is turned off
<b class="nc">&nbsp;            if (isIndirect &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.IndirectFireOff&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Can&#39;t fire an MML indirectly when loaded with SRM munitions
<b class="nc">&nbsp;            if (isIndirect &amp;&amp; usesAmmo </b>
<b class="nc">&nbsp;                    &amp;&amp; atype != null &amp;&amp; (atype.getAmmoType() == AmmoType.T_MML) &amp;&amp; !atype.hasFlag(AmmoType.F_MML_LRM)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoIndirectSRM&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Can&#39;t fire anything but Mech Mortars and Artillery Cannons indirectly without a spotter 
&nbsp;            // unless the attack has the Oblique Attacker SPA
<b class="nc">&nbsp;            if (isIndirect) {</b>
<b class="nc">&nbsp;                if ((spotter == null) &amp;&amp; !(wtype instanceof MekMortarWeapon) &amp;&amp; !(wtype instanceof ArtilleryCannonWeapon)</b>
<b class="nc">&nbsp;                        &amp;&amp; !ae.hasAbility(OptionsConstants.GUNNERY_OBLIQUE_ATTACKER)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoSpotter&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Infantry Leg attacks and Swarm attacks
<b class="nc">&nbsp;            if (Infantry.LEG_ATTACK.equals(wtype.getInternalName()) &amp;&amp; te != null) {</b>
<b class="nc">&nbsp;                toHit = Compute.getLegAttackBaseToHit(ae, te, game);</b>
&nbsp;
&nbsp;                // Return if the attack is impossible.
<b class="nc">&nbsp;                if (TargetRoll.IMPOSSIBLE == toHit.getValue()) {</b>
<b class="nc">&nbsp;                    return toHit.getDesc();</b>
&nbsp;                }
&nbsp;                // Out of range?
<b class="nc">&nbsp;                if (Compute.effectiveDistance(game, ae, target) &gt; 0) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OutOfRange&quot;);</b>
&nbsp;                }
&nbsp;                // Can&#39;t combine leg attacks with other attacks
<b class="nc">&nbsp;                if (!WeaponAttackAction.isOnlyAttack(game, ae, Infantry.LEG_ATTACK, te)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.LegAttackOnly&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (Infantry.SWARM_MEK.equals(wtype.getInternalName()) &amp;&amp; te != null) {</b>
<b class="nc">&nbsp;                toHit = Compute.getSwarmMekBaseToHit(ae, te, game);</b>
&nbsp;
&nbsp;                // Return if the attack is impossible.
<b class="nc">&nbsp;                if (TargetRoll.IMPOSSIBLE == toHit.getValue()) {</b>
<b class="nc">&nbsp;                    return toHit.getDesc();</b>
&nbsp;                }
&nbsp;                // Out of range?
<b class="nc">&nbsp;                if (Compute.effectiveDistance(game, ae, target) &gt; 0) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.OutOfRange&quot;);</b>
&nbsp;                }
&nbsp;                // Can&#39;t combine swarm attacks with other attacks
<b class="nc">&nbsp;                if (!WeaponAttackAction.isOnlyAttack(game, ae, Infantry.SWARM_MEK, te)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.SwarmAttackOnly&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (Infantry.STOP_SWARM.equals(wtype.getInternalName())) {</b>
&nbsp;                // Can&#39;t stop if we&#39;re not swarming, otherwise automatic.
<b class="nc">&nbsp;                if (Entity.NONE == ae.getSwarmTargetId()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NotSwarming&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (Infantry.SWARM_WEAPON_MEK.equals(wtype.getInternalName())) {</b>
&nbsp;                // Can&#39;t stop if we&#39;re not swarming, otherwise automatic.
<b class="nc">&nbsp;                if (Entity.NONE == ae.getSwarmTargetId()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NotSwarming&quot;);</b>
&nbsp;                }
&nbsp;            } 
&nbsp;            // Swarming infantry always hit their target, but
&nbsp;            // they can only target the Mek they&#39;re swarming.
<b class="nc">&nbsp;            if ((te != null) &amp;&amp; (ae.getSwarmTargetId() == te.getId())) {</b>
&nbsp;                // Weapons that do no damage cannot be used in swarm attacks
<b class="nc">&nbsp;                if (wtype.getDamage() == 0) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.0DamageWeapon&quot;);</b>
&nbsp;                }
&nbsp;                // Missiles and BA body-mounted weapons cannot be used when swarming
<b class="nc">&nbsp;                if (wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoMissileWhenSwarming&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (weapon.isBodyMounted()) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoBodyWhenSwarming&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (Entity.NONE != ae.getSwarmTargetId()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.MustTargetSwarmed&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // MG arrays
&nbsp;            
&nbsp;            // Can&#39;t fire one if none of the component MGs are functional
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_MGA) &amp;&amp; (weapon.getCurrentShots() == 0)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.NoWorkingMGs&quot;);</b>
&nbsp;            }
&nbsp;            // Or if the array is off
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_MGA) &amp;&amp; wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_AMS_OFF)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.MGArrayOff&quot;);</b>
<b class="nc">&nbsp;            } else if (wtype.hasFlag(WeaponType.F_MG)) {</b>
&nbsp;                // and you can&#39;t fire an individual MG if it&#39;s in an array
<b class="nc">&nbsp;                if (ae.hasLinkedMGA(weapon)) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.MGPartOfArray&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // Protomech can fire MGA only into front arc, TW page 137
<b class="nc">&nbsp;            if (!Compute.isInArc(ae.getPosition(), ae.getFacing(), target, Compute.ARC_FORWARD)</b>
<b class="nc">&nbsp;                    &amp;&amp; wtype.hasFlag(WeaponType.F_MGA) &amp;&amp; (ae instanceof Protomech)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.ProtoMGAOnlyFront&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // NARC and iNARC
<b class="nc">&nbsp;            if ((wtype.getAmmoType() == AmmoType.T_NARC) || (wtype.getAmmoType() == AmmoType.T_INARC)) {</b>
&nbsp;                // Cannot be used against targets inside buildings
<b class="nc">&nbsp;                if (targetInBuilding) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.NoNarcInBuilding&quot;);</b>
&nbsp;                }
&nbsp;                // and can&#39;t be fired at infantry
<b class="nc">&nbsp;                if (target instanceof Infantry) {</b>
<b class="nc">&nbsp;                    return Messages.getString(&quot;WeaponAttackAction.CantNarcInfantry&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // PPCs linked to capacitors can&#39;t fire while charging
<b class="nc">&nbsp;            if (weapon.getType().hasFlag(WeaponType.F_PPC) &amp;&amp; (weapon.getLinkedBy() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; weapon.getLinkedBy().getType().hasFlag(MiscType.F_PPC_CAPACITOR)</b>
<b class="nc">&nbsp;                    &amp;&amp; weapon.getLinkedBy().pendingMode().equals(Weapon.MODE_PPC_CHARGE)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.PPCCharging&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Some weapons can only be fired by themselves
&nbsp;            
&nbsp;            // Check to see if another solo weapon was fired
<b class="nc">&nbsp;            boolean hasSoloAttack = false;</b>
<b class="nc">&nbsp;            String soloWeaponName = &quot;&quot;;</b>
<b class="nc">&nbsp;            for (EntityAction ea : game.getActionsVector()) {</b>
<b class="nc">&nbsp;                if ((ea.getEntityId() == attackerId) &amp;&amp; (ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                    WeaponAttackAction otherWAA = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    final Mounted otherWeapon = ae.getEquipment(otherWAA.getWeaponId());</b>
&nbsp;
<b class="nc">&nbsp;                    if (!(otherWeapon.getType() instanceof WeaponType)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final WeaponType otherWtype = (WeaponType) otherWeapon.getType();</b>
<b class="nc">&nbsp;                    hasSoloAttack |= (otherWtype.hasFlag(WeaponType.F_SOLO_ATTACK) &amp;&amp; otherWAA.getWeaponId() != weaponId);</b>
<b class="nc">&nbsp;                    if (hasSoloAttack) {</b>
<b class="nc">&nbsp;                        soloWeaponName = otherWeapon.getName();</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (hasSoloAttack) {</b>
<b class="nc">&nbsp;                return String.format(Messages.getString(&quot;WeaponAttackAction.CantFireWithOtherWeapons&quot;), soloWeaponName);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Handle solo attack weapons.
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_SOLO_ATTACK)) {</b>
<b class="nc">&nbsp;                for (EntityAction ea : game.getActionsVector()) {</b>
<b class="nc">&nbsp;                    if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == attackerId) {</b>
&nbsp;                        // If the attacker fires another weapon, this attack fails.
<b class="nc">&nbsp;                        if (weaponId != prevAttack.getWeaponId()) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.CantMixAttacks&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // Protomechs cannot fire arm weapons and main gun in the same turn
<b class="nc">&nbsp;            if ((ae instanceof Protomech)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((weapon.getLocation() == Protomech.LOC_MAINGUN)</b>
<b class="nc">&nbsp;                    || (weapon.getLocation() == Protomech.LOC_RARM)</b>
<b class="nc">&nbsp;                    || (weapon.getLocation() == Protomech.LOC_LARM))) {</b>
<b class="nc">&nbsp;                final boolean firingMainGun = weapon.getLocation() == Protomech.LOC_MAINGUN;</b>
<b class="nc">&nbsp;                for (EntityAction ea : game.getActionsVector()) {</b>
<b class="nc">&nbsp;                    if ((ea.getEntityId() == attackerId) &amp;&amp; (ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        WeaponAttackAction otherWAA = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                        final Mounted otherWeapon = ae.getEquipment(otherWAA.getWeaponId());</b>
<b class="nc">&nbsp;                        if ((firingMainGun &amp;&amp; ((otherWeapon.getLocation() == Protomech.LOC_RARM)</b>
<b class="nc">&nbsp;                                || (otherWeapon.getLocation() == Protomech.LOC_LARM)))</b>
<b class="nc">&nbsp;                                || !firingMainGun &amp;&amp; (otherWeapon.getLocation() == Protomech.LOC_MAINGUN)) {</b>
<b class="nc">&nbsp;                            return Messages.getString(&quot;WeaponAttackAction.CantFireArmsAndMainGun&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // TAG
&nbsp;            
&nbsp;            // The TAG system cannot target Airborne Aeros.
<b class="nc">&nbsp;            if (isTAG &amp;&amp; (te != null) &amp;&amp; (te.isAirborne() || te.isSpaceborne())) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.CantTAGAero&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // The TAG system cannot target infantry.
<b class="nc">&nbsp;            if (isTAG &amp;&amp; (te != null) &amp;&amp; (te instanceof Infantry)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.CantTAGInf&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // TSEMPs
&nbsp;            
&nbsp;            // Can&#39;t fire a one-shot TSEMP more than once
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_TSEMP) &amp;&amp; wtype.hasFlag(WeaponType.F_ONESHOT) &amp;&amp; weapon.isFired()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.OneShotTSEMP&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Can&#39;t fire a regular TSEMP while it is recharging
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_TSEMP) &amp;&amp; weapon.isFired()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TSEMPRecharging&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Weapon Bays
&nbsp;            
&nbsp;            // Large Craft weapon bays cannot bracket small craft at short range
<b class="nc">&nbsp;            if (wtype.hasModes()</b>
<b class="nc">&nbsp;                    &amp;&amp; (weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_80) || weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_60)</b>
<b class="nc">&nbsp;                            || weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_40))</b>
<b class="nc">&nbsp;                    &amp;&amp; target.isAero() &amp;&amp; te!= null &amp;&amp; !te.isLargeCraft()</b>
<b class="nc">&nbsp;                    &amp;&amp; (RangeType.rangeBracket(ae.getPosition().distance(target.getPosition()), wtype.getRanges(weapon),</b>
&nbsp;                            true, false) == RangeType.RANGE_SHORT)) {
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.TooCloseForSCBracket&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // you must have enough weapons in your bay to be able to use bracketing
<b class="nc">&nbsp;            if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_80) &amp;&amp; (weapon.getBayWeapons().size() &lt; 2)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.BayTooSmallForBracket&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_60) &amp;&amp; (weapon.getBayWeapons().size() &lt; 3)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.BayTooSmallForBracket&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_40) &amp;&amp; (weapon.getBayWeapons().size() &lt; 4)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.BayTooSmallForBracket&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // If you&#39;re an aero, can&#39;t fire an AMS Bay at all or a Point Defense bay that&#39;s in PD Mode
<b class="nc">&nbsp;            if (wtype.hasFlag(WeaponType.F_AMSBAY)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.AutoWeapon&quot;);</b>
<b class="nc">&nbsp;            } else if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_POINT_DEFENSE)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.PDWeapon&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Weapon in arc?
<b class="nc">&nbsp;            if (!Compute.isInArc(game, attackerId, weaponId, target)</b>
<b class="nc">&nbsp;                    &amp;&amp; (!Compute.isAirToGround(ae, target) || isArtilleryIndirect)</b>
<b class="nc">&nbsp;                    &amp;&amp; !ae.isMakingVTOLGroundAttack()</b>
<b class="nc">&nbsp;                    &amp;&amp; !ae.isOffBoard()) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.OutOfArc&quot;);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Weapon operational?
<b class="nc">&nbsp;            if (!weapon.canFire(isStrafing)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.WeaponNotReady&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // If we get here, the shot is possible
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method that tests each attack to see if it would automatically hit.
&nbsp;     * If so, a reason string will be returned. A null return means we can continue
&nbsp;     * processing the attack
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param los The calculated LOS between attacker and target
&nbsp;     * 
&nbsp;     * @param distance  The distance in hexes from attacker to target
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * 
&nbsp;     * @param isBearingsOnlyMissile  flag that indicates whether this is a bearings-only capital missile attack
&nbsp;     */
&nbsp;    private static String toHitIsAutomatic(IGame game, Entity ae, Targetable target, int ttype, LosEffects los,
&nbsp;            int distance, WeaponType wtype, Mounted weapon, boolean isBearingsOnlyMissile) {
&nbsp;        
&nbsp;        // Buildings
&nbsp;        
&nbsp;        // Attacks against adjacent buildings automatically hit.
<b class="nc">&nbsp;        if ((distance == 1) &amp;&amp; ((ttype == Targetable.TYPE_BUILDING)</b>
&nbsp;                || (ttype == Targetable.TYPE_BLDG_IGNITE)
&nbsp;                || (ttype == Targetable.TYPE_FUEL_TANK)
&nbsp;                || (ttype == Targetable.TYPE_FUEL_TANK_IGNITE)
&nbsp;                || (target instanceof GunEmplacement))) {
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.AdjBuilding&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Attacks against buildings from inside automatically hit.
<b class="nc">&nbsp;        if ((null != los.getThruBldg()) &amp;&amp; ((ttype == Targetable.TYPE_BUILDING)</b>
&nbsp;                || (ttype == Targetable.TYPE_BLDG_IGNITE)
&nbsp;                || (ttype == Targetable.TYPE_FUEL_TANK)
&nbsp;                || (ttype == Targetable.TYPE_FUEL_TANK_IGNITE)
&nbsp;                || (target instanceof GunEmplacement))) {
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.InsideBuilding&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Special Weapon Rules
&nbsp;        
&nbsp;        // B-Pod firing at infantry in the same hex autohit
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_B_POD) &amp;&amp; (target instanceof Infantry)</b>
<b class="nc">&nbsp;                &amp;&amp; target.getPosition().equals(ae.getPosition())) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.BPodAtInf&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Capital Missiles in bearings-only mode target hexes and always hit them
<b class="nc">&nbsp;        if (isBearingsOnlyMissile) {</b>
<b class="nc">&nbsp;            if (game.getPhase() == IGame.Phase.PHASE_TARGETING &amp;&amp; distance &gt;= RangeType.RANGE_BEARINGS_ONLY_MINIMUM) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.BoMissileHex&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Screen launchers target hexes and hit automatically (if in range)
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; ((wtype.getAmmoType() == AmmoType.T_SCREEN_LAUNCHER)</b>
<b class="nc">&nbsp;                || (wtype instanceof ScreenLauncherBayWeapon)) &amp;&amp; distance &lt;= wtype.getExtremeRange()) {</b>
<b class="nc">&nbsp;            return Messages.getString(&quot;WeaponAttackAction.ScreenAutoHit&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Vehicular grenade launchers
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; weapon.getType().hasFlag(WeaponType.F_VGL)) {</b>
<b class="nc">&nbsp;            int facing = weapon.getFacing();</b>
<b class="nc">&nbsp;            if (ae.isSecondaryArcWeapon(ae.getEquipmentNum(weapon))) {</b>
<b class="nc">&nbsp;                facing = (facing + ae.getSecondaryFacing()) % 6;</b>
&nbsp;            }
<b class="nc">&nbsp;            Coords c = ae.getPosition().translated(facing);</b>
<b class="nc">&nbsp;            if ((target instanceof HexTarget) &amp;&amp; target.getPosition().equals(c)) {</b>
<b class="nc">&nbsp;                return Messages.getString(&quot;WeaponAttackAction.Vgl&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // If we get here, the shot isn&#39;t an auto-hit
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some attacks are the only actions that a particular entity can make
&nbsp;     * during its turn Also, only this unit can make that particular attack.
&nbsp;     */
&nbsp;    private static boolean isOnlyAttack(IGame game, Entity attacker, String attackType, Entity target) {
&nbsp;        // mechs can only be the target of one leg or swarm attack
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions.hasMoreElements();) {</b>
<b class="nc">&nbsp;            EntityAction ea = actions.nextElement();</b>
<b class="nc">&nbsp;            if (ea instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                Entity waaAE = waa.getEntity(game);</b>
<b class="nc">&nbsp;                if (waaAE == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (waaAE.equals(attacker)) {</b>
&nbsp;                    // If there is an attack by this unit that is not the attack
&nbsp;                    // type, fail.
<b class="nc">&nbsp;                    if (!waaAE.getEquipment(waa.getWeaponId()).getType().getInternalName().equals(attackType)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                Targetable waaTarget = waa.getTarget(game);</b>
<b class="nc">&nbsp;                EquipmentType weapType = waaAE.getEquipment(waa.getWeaponId()).getType();</b>
<b class="nc">&nbsp;                if (weapType.getInternalName().equals(attackType) &amp;&amp; (waaTarget != null) &amp;&amp; waaTarget.equals(target)) {</b>
<b class="nc">&nbsp;                    if (!waaAE.equals(attacker)) {</b>
&nbsp;                        // If there is an attack by another unit that has this
&nbsp;                        // attack type against the same target, fail.
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return Returns the nemesisConfused.
&nbsp;     */
&nbsp;    public boolean isNemesisConfused() {
<b class="nc">&nbsp;        return nemesisConfused;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param nemesisConfused
&nbsp;     *            The nemesisConfused to set.
&nbsp;     */
&nbsp;    public void setNemesisConfused(boolean nemesisConfused) {
<b class="nc">&nbsp;        this.nemesisConfused = nemesisConfused;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isSwarmingMissiles() {
<b class="nc">&nbsp;        return swarmingMissiles;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSwarmingMissiles(boolean swarmingMissiles) {
<b class="nc">&nbsp;        this.swarmingMissiles = swarmingMissiles;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setOldTargetId(int id) {
<b class="nc">&nbsp;        oldTargetId = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOldTargetId() {
<b class="nc">&nbsp;        return oldTargetId;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOldTargetType(int t) {
<b class="nc">&nbsp;        oldTargetType = t;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOldTargetType() {
<b class="nc">&nbsp;        return oldTargetType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOriginalTargetId(int id) {
<b class="nc">&nbsp;        originalTargetId = id;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOriginalTargetId() {
<b class="nc">&nbsp;        return originalTargetId;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOriginalTargetType(int t) {
<b class="nc">&nbsp;        originalTargetType = t;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getOriginalTargetType() {
<b class="nc">&nbsp;        return originalTargetType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getSwarmMissiles() {
<b class="nc">&nbsp;        return swarmMissiles;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSwarmMissiles(int swarmMissiles) {
<b class="nc">&nbsp;        this.swarmMissiles = swarmMissiles;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int[] getBombPayload() {
<b class="nc">&nbsp;        return bombPayload;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * 
&nbsp;     * @param load This is the &quot;bomb payload&quot;. It&#39;s an array indexed by the constants declared in BombType.
&nbsp;     * Each element indicates how many types of that bomb should be fired.
&nbsp;     */
&nbsp;    public void setBombPayload(int[] load) {
<b class="nc">&nbsp;        bombPayload = load;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isStrafing() {
<b class="nc">&nbsp;        return isStrafing;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStrafing(boolean isStrafing) {
<b class="nc">&nbsp;        this.isStrafing = isStrafing;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isStrafingFirstShot() {
<b class="nc">&nbsp;        return isStrafingFirstShot;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStrafingFirstShot(boolean isStrafingFirstShot) {
<b class="nc">&nbsp;        this.isStrafingFirstShot = isStrafingFirstShot;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isPointblankShot() {
<b class="nc">&nbsp;        return isPointblankShot;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setPointblankShot(boolean isPointblankShot) {
<b class="nc">&nbsp;        this.isPointblankShot = isPointblankShot;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isHomingShot() {
<b class="nc">&nbsp;        return isHomingShot;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setHomingShot(boolean isHomingShot) {
<b class="nc">&nbsp;        this.isHomingShot = isHomingShot;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Needed by teleoperated missiles
&nbsp;     * @param velocity - an integer representing initial velocity
&nbsp;     */
&nbsp;    public void setLaunchVelocity(int velocity) {
<b class="nc">&nbsp;        this.launchVelocity = velocity;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    //This is a stub. ArtilleryAttackActions actually need to use it
&nbsp;    public void updateTurnsTilHit(IGame game) {        
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the weather or other special environmental
&nbsp;     * effects. These affect everyone on the board.
&nbsp;     * @param game  The current game
&nbsp;     * @param ae    The attacking entity
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * 
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param isArtilleryIndirect  flag that indicates whether this is an indirect-fire artillery attack
&nbsp;     */
&nbsp;    private static ToHitData compileEnvironmentalToHitMods(IGame game, Entity ae, Targetable target, WeaponType wtype, 
&nbsp;                AmmoType atype, ToHitData toHit, boolean isArtilleryIndirect) {
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Night combat modifiers
<b class="nc">&nbsp;        if (!isArtilleryIndirect) {</b>
<b class="nc">&nbsp;            toHit.append(AbstractAttackAction.nightModifiers(game, target, atype, ae, true));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        TargetRoll weatherToHitMods = new TargetRoll();</b>
&nbsp;
&nbsp;        // weather mods (not in space)
<b class="nc">&nbsp;        int weatherMod = game.getPlanetaryConditions().getWeatherHitPenalty(ae);</b>
<b class="nc">&nbsp;        if ((weatherMod != 0) &amp;&amp; !game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            weatherToHitMods.addModifier(weatherMod, game.getPlanetaryConditions().getWeatherDisplayableName());</b>
&nbsp;        }
&nbsp;
&nbsp;        // wind mods (not in space)
<b class="nc">&nbsp;        if (!game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            int windCond = game.getPlanetaryConditions().getWindStrength();</b>
<b class="nc">&nbsp;            if (windCond == PlanetaryConditions.WI_MOD_GALE) {</b>
<b class="nc">&nbsp;                if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(1, PlanetaryConditions.getWindDisplayableName(windCond));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (windCond == PlanetaryConditions.WI_STRONG_GALE) {</b>
<b class="nc">&nbsp;                if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC)) {</b>
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(1, PlanetaryConditions.getWindDisplayableName(windCond));</b>
<b class="nc">&nbsp;                } else if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(2, PlanetaryConditions.getWindDisplayableName(windCond));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (windCond == PlanetaryConditions.WI_STORM) {</b>
<b class="nc">&nbsp;                if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC)) {</b>
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(2, PlanetaryConditions.getWindDisplayableName(windCond));</b>
<b class="nc">&nbsp;                } else if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(3, PlanetaryConditions.getWindDisplayableName(windCond));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (windCond == PlanetaryConditions.WI_TORNADO_F13) {</b>
<b class="nc">&nbsp;                if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY)) {</b>
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(2, PlanetaryConditions.getWindDisplayableName(windCond));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    weatherToHitMods.addModifier(3, PlanetaryConditions.getWindDisplayableName(windCond));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (windCond == PlanetaryConditions.WI_TORNADO_F4) {</b>
<b class="nc">&nbsp;                weatherToHitMods.addModifier(3, PlanetaryConditions.getWindDisplayableName(windCond));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // fog mods (not in space)
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY) &amp;&amp; !game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPlanetaryConditions().getFog() == PlanetaryConditions.FOG_HEAVY)) {</b>
<b class="nc">&nbsp;            weatherToHitMods.addModifier(1, Messages.getString(&quot;WeaponAttackAction.HeavyFog&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // blowing sand mods
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY) &amp;&amp; !game.getBoard().inSpace()</b>
<b class="nc">&nbsp;                &amp;&amp; game.getPlanetaryConditions().isSandBlowing()</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getPlanetaryConditions().getWindStrength() &gt; PlanetaryConditions.WI_LIGHT_GALE)) {</b>
<b class="nc">&nbsp;            weatherToHitMods.addModifier(1, Messages.getString(&quot;WeaponAttackAction.BlowingSand&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (weatherToHitMods.getValue() &gt; 0) {</b>
<b class="nc">&nbsp;            if ((ae.getCrew() != null) &amp;&amp; ae.hasAbility(OptionsConstants.UNOFF_WEATHERED)) {</b>
<b class="nc">&nbsp;                weatherToHitMods.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.Weathered&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            toHit.append(weatherToHitMods);</b>
&nbsp;        }
&nbsp;
&nbsp;        // gravity mods (not in space)
<b class="nc">&nbsp;        if (!game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;            int mod = (int) Math.floor(Math.abs((game.getPlanetaryConditions().getGravity() - 1.0f) / 0.2f));</b>
<b class="nc">&nbsp;            if ((mod != 0) &amp;&amp; wtype != null &amp;&amp; </b>
<b class="nc">&nbsp;                    (wtype.hasFlag(WeaponType.F_BALLISTIC) || wtype.hasFlag(WeaponType.F_MISSILE))) {</b>
<b class="nc">&nbsp;                toHit.addModifier(mod, Messages.getString(&quot;WeaponAttackAction.Gravity&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Electro-Magnetic Interference
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().hasEMI() &amp;&amp; !((ae instanceof Infantry) &amp;&amp; !(ae instanceof BattleArmor))) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.EMI&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the weapon being fired
&nbsp;     * Got a heavy large laser that gets a +1 TH penalty?  You&#39;ll find that here.
&nbsp;     * Bonuses related to the attacker&#39;s condition?  Ammunition being used?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae    The attacking entity
&nbsp;     * @param spotter   The spotting entity, if using indirect fire
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The Targetable object type
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used for this attack
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param isFlakAttack  flag that indicates whether the attacker is using Flak against an airborne target
&nbsp;     * @param isIndirect  flag that indicates whether this is an indirect attack (LRM, mortar...)
&nbsp;     * @param narcSpotter  flag that indicates whether this spotting entity is using NARC equipment
&nbsp;     */
&nbsp;    private static ToHitData compileWeaponToHitMods(IGame game, Entity ae, Entity spotter, Targetable target,
&nbsp;                int ttype, ToHitData toHit, WeaponType wtype, Mounted weapon, AmmoType atype, long munition, 
&nbsp;                boolean isFlakAttack, boolean isIndirect, boolean narcSpotter) {
<b class="nc">&nbsp;        if (ae == null || wtype == null || weapon == null) {</b>
&nbsp;            // Can&#39;t calculate weapon mods without a valid weapon and an attacker to fire it
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some of these weapons only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // +4 for trying to fire ASEW or antiship missile at a target of &lt; 500 tons
<b class="nc">&nbsp;        if ((wtype.hasFlag(WeaponType.F_ANTI_SHIP) || wtype.getAmmoType() == AmmoType.T_ASEW_MISSILE)</b>
<b class="nc">&nbsp;                &amp;&amp; (te != null) &amp;&amp; (te.getWeight() &lt; 500)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(4, Messages.getString(&quot;WeaponAttackAction.TeTooSmallForASM&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // AAA mode makes targeting large craft more difficult
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAP_LASER_AAA) &amp;&amp; te != null &amp;&amp; te.isLargeCraft()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.AAALaserAtShip&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Bombast Lasers
<b class="nc">&nbsp;        if (wtype instanceof ISBombastLaser) {</b>
<b class="nc">&nbsp;            double damage = Compute.dialDownDamage(weapon, wtype);</b>
<b class="nc">&nbsp;            damage = Math.ceil((damage - 7) / 2);</b>
&nbsp;
<b class="nc">&nbsp;            if (damage &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier((int) damage, Messages.getString(&quot;WeaponAttackAction.WeaponMod&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Bracketing modes
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_80)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.Bracket80&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_60)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.Bracket60&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAPITAL_BRACKET_40)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-3, Messages.getString(&quot;WeaponAttackAction.Bracket40&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Capital ship mass driver penalty. YOU try hitting a maneuvering target with a spinal-mount weapon!
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_MASS_DRIVER)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.MassDriver&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Capital missiles in waypoint launch mode
<b class="nc">&nbsp;        if (weapon.isInWaypointLaunchMode()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.WaypointLaunch&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Capital weapon (except missiles) penalties at small targets
<b class="nc">&nbsp;        if (wtype.isCapital() &amp;&amp; (wtype.getAtClass() != WeaponType.CLASS_CAPITAL_MISSILE)</b>
<b class="nc">&nbsp;                &amp;&amp; (wtype.getAtClass() != WeaponType.CLASS_AR10) &amp;&amp; te != null &amp;&amp; !te.isLargeCraft()) {</b>
&nbsp;            // Capital Lasers have an AAA mode for shooting at small targets
<b class="nc">&nbsp;            int aaaMod = 0;</b>
<b class="nc">&nbsp;            if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(Weapon.MODE_CAP_LASER_AAA)) {</b>
<b class="nc">&nbsp;                aaaMod = 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (wtype.isSubCapital()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(3 - aaaMod, Messages.getString(&quot;WeaponAttackAction.SubCapSmallTe&quot;));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(5 - aaaMod, Messages.getString(&quot;WeaponAttackAction.CapSmallTe&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Check whether we&#39;re eligible for a flak bonus...
<b class="nc">&nbsp;        if (isFlakAttack) {</b>
&nbsp;            // ...and if so, which one (HAGs get an extra -1 as per TW p. 136
&nbsp;            // that&#39;s not covered by anything else).
<b class="nc">&nbsp;            if (atype != null &amp;&amp; atype.getAmmoType() == AmmoType.T_HAG) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-3, Messages.getString(&quot;WeaponAttackAction.HagFlak&quot;));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.Flak&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Flat to hit modifiers defined in WeaponType  
<b class="nc">&nbsp;        if (wtype.getToHitModifier() != 0) {</b>
<b class="nc">&nbsp;            int modifier = wtype.getToHitModifier();</b>
<b class="nc">&nbsp;            if (wtype instanceof VariableSpeedPulseLaserWeapon) {</b>
<b class="nc">&nbsp;                int nRange = ae.getPosition().distance(target.getPosition());</b>
<b class="nc">&nbsp;                int[] nRanges = wtype.getRanges(weapon);</b>
&nbsp;
<b class="nc">&nbsp;                if (nRange &lt;= nRanges[RangeType.RANGE_SHORT]) {</b>
<b class="nc">&nbsp;                    modifier += RangeType.RANGE_SHORT;</b>
<b class="nc">&nbsp;                } else if (nRange &lt;= nRanges[RangeType.RANGE_MEDIUM]) {</b>
<b class="nc">&nbsp;                    modifier += RangeType.RANGE_MEDIUM;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    modifier += RangeType.RANGE_LONG;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            toHit.addModifier(modifier, Messages.getString(&quot;WeaponAttackAction.WeaponMod&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Indirect fire (LRMs, mortars and the like) has a +1 mod
<b class="nc">&nbsp;        if (isIndirect) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.Indirect&quot;));</b>
&nbsp;            // Unless the attacker has the Oblique Attacker SPA
<b class="nc">&nbsp;            if (ae.hasAbility(OptionsConstants.GUNNERY_OBLIQUE_ATTACKER)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.ObliqueAttacker&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Indirect fire suffers a +1 penalty if the spotter is making attacks of its own
<b class="nc">&nbsp;        if (isIndirect) {</b>
&nbsp;            // semiguided ammo negates this modifier, if TAG succeeded
<b class="nc">&nbsp;            if ((atype != null) &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_NLRM) </b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MEK_MORTAR))</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_SEMIGUIDED)) {
&nbsp;
<b class="nc">&nbsp;                if (Compute.isTargetTagged(target, game)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.SemiGuidedIndirect&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (!narcSpotter &amp;&amp; (spotter != null)) {</b>
&nbsp;                // Unless the target has been tagged, or the spotter has an active command console
<b class="nc">&nbsp;                toHit.append(Compute.getSpotterMovementModifier(game, spotter.getId()));</b>
<b class="nc">&nbsp;                if (spotter.isAttackingThisTurn() &amp;&amp; !spotter.getCrew().hasActiveCommandConsole() &amp;&amp; </b>
<b class="nc">&nbsp;                        !Compute.isTargetTagged(target, game)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.SpotterAttacking&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // And if this is a Mech Mortar
<b class="nc">&nbsp;        if (wtype instanceof MekMortarWeapon) {</b>
<b class="nc">&nbsp;            if (isIndirect) {</b>
&nbsp;                // +2 penalty if there&#39;s no spotting entity
<b class="nc">&nbsp;                if (spotter == null) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.NoSpotter&quot;));</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // +3 penalty for a direct-fire shot
<b class="nc">&nbsp;                toHit.addModifier(3, Messages.getString(&quot;WeaponAttackAction.DirectMortar&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // +1 to hit if the Kinder Rapid-Fire ACs optional rule is turned on, but only Jams on a 2.
&nbsp;        // See TacOps Autocannons for the rest of the rules
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_KIND_RAPID_AC) </b>
<b class="nc">&nbsp;                &amp;&amp; weapon.curMode().equals(Weapon.MODE_AC_RAPID)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.AcRapid&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // VSP Lasers
&nbsp;        // quirks
&nbsp;        
&nbsp;        // Flat -1 for Accurate Weapon
<b class="nc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_POS_ACCURATE)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.AccWeapon&quot;));</b>
&nbsp;        }
&nbsp;        // Flat +1 for Inaccurate Weapon
<b class="nc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_NEG_INACCURATE)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.InAccWeapon&quot;));</b>
&nbsp;        }
&nbsp;        // Stable Weapon - Reduces running/flanking penalty by 1
<b class="nc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_POS_STABLE_WEAPON) &amp;&amp; (ae.moved == EntityMovementType.MOVE_RUN)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.StableWeapon&quot;));</b>
&nbsp;        }
&nbsp;        // +1 for a Misrepaired Weapon - See StratOps Partial Repairs 
<b class="nc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_NEG_MISREPAIRED)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.MisrepairedWeapon&quot;));</b>
&nbsp;        }
&nbsp;        // +1 for a Misreplaced Weapon - See StratOps Partial Repairs
<b class="nc">&nbsp;        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_NEG_MISREPLACED)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.MisreplacedWeapon&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the ammunition being used
&nbsp;     * Using precision AC rounds that get a -1 TH bonus?  You&#39;ll find that here.
&nbsp;     * Bonuses related to the attacker&#39;s condition?  Using a weapon with a TH penalty?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param bApollo flag that indicates whether the attacker is using an Apollo FCS for MRMs
&nbsp;     * @param bArtemisV flag that indicates whether the attacker is using an Artemis V FCS
&nbsp;     * @param bFTL flag that indicates whether the attacker is using FTL missiles
&nbsp;     * @param bHeatSeeking flag that indicates whether the attacker is using Heat Seeking missiles
&nbsp;     * @param isECMAffected flag that indicates whether the target is inside an ECM bubble
&nbsp;     * @param isINarcGuided flag that indicates whether the target is broadcasting an iNarc beacon
&nbsp;     */
&nbsp;    private static ToHitData compileAmmoToHitMods(IGame game, Entity ae, Targetable target, int ttype, ToHitData toHit,
&nbsp;                WeaponType wtype, Mounted weapon, AmmoType atype, long munition, boolean bApollo, boolean bArtemisV,
&nbsp;                boolean bFTL, boolean bHeatSeeking, boolean isECMAffected, boolean isINarcGuided) {
<b class="nc">&nbsp;        if (ae == null || atype == null) {</b>
&nbsp;            // Can&#39;t calculate ammo mods without valid ammo and an attacker to fire it
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some ammo can only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Autocannon Munitions
&nbsp;        
&nbsp;        // Armor Piercing ammo is a flat +1
<b class="nc">&nbsp;        if (((atype.getAmmoType() == AmmoType.T_AC) </b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_LAC)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_AC_IMP)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_PAC))</b>
&nbsp;                &amp;&amp; (munition == AmmoType.M_ARMOR_PIERCING)) {
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.ApAmmo&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Bombs
&nbsp;        
&nbsp;        // Air-to-air Arrow and Light Air-to-air missiles
<b class="nc">&nbsp;        if (((atype.getAmmoType() == AmmoType.T_AAA_MISSILE) || (atype.getAmmoType() == AmmoType.T_LAA_MISSILE))</b>
<b class="nc">&nbsp;                &amp;&amp; Compute.isAirToGround(ae, target)) {</b>
&nbsp;            // +4 penalty if trying to use one against a ground target
<b class="nc">&nbsp;            toHit.addModifier(+4, Messages.getString(&quot;WeaponAttackAction.AaaGroundAttack&quot;));</b>
&nbsp;            // +3 additional if the attacker is flying at Altitude 3 or less
<b class="nc">&nbsp;            if (ae.getAltitude() &lt; 4) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.AaaLowAlt&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Flat modifiers defined in AmmoType
<b class="nc">&nbsp;        if (atype.getToHitModifier() != 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(atype.getToHitModifier(),</b>
<b class="nc">&nbsp;                    atype.getSubMunitionName() + Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Missile Munitions
&nbsp;        
&nbsp;        // Apollo FCS for MRMs
<b class="nc">&nbsp;        if (bApollo) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.ApolloFcs&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // add Artemis V bonus
<b class="nc">&nbsp;        if (bArtemisV) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.ArtemisV&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Follow-the-leader LRMs
<b class="nc">&nbsp;        if (bFTL) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2,atype.getSubMunitionName()</b>
<b class="nc">&nbsp;                    + Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Heat Seeking Missles
<b class="nc">&nbsp;        if (bHeatSeeking) {</b>
<b class="nc">&nbsp;            IHex hexTarget = game.getBoard().getHex(target.getPosition());</b>
&nbsp;            // -2 bonus if shooting at burning hexes or buildings
<b class="nc">&nbsp;            if (te == null &amp;&amp; hexTarget.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (te != null) {</b>
&nbsp;                // -2 bonus if the target is on fire
<b class="nc">&nbsp;                if (te.infernos.isStillBurning()) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                if ((te.isAirborne())</b>
<b class="nc">&nbsp;                        &amp;&amp; (toHit.getSideTable() == ToHitData.SIDE_REAR)) {</b>
&nbsp;                    // -2 bonus if shooting an Aero through the rear arc
<b class="nc">&nbsp;                    toHit.addModifier(-2, atype.getSubMunitionName()</b>
<b class="nc">&nbsp;                            + Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
<b class="nc">&nbsp;                } else if (te.heat == 0) {</b>
&nbsp;                    // +1 penalty if shooting at a non-heat-tracking unit or a heat-tracking unit at 0 heat
<b class="nc">&nbsp;                    toHit.addModifier(1, atype.getSubMunitionName()</b>
<b class="nc">&nbsp;                            + Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;                } else {
&nbsp;                    // +1 bonus for each -1MP the target would get due to heat
<b class="nc">&nbsp;                    toHit.addModifier(-te.getHeatMPReduction(),</b>
<b class="nc">&nbsp;                            atype.getSubMunitionName()</b>
<b class="nc">&nbsp;                                    + Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // +2 penalty if shooting into or through a burning hex
<b class="nc">&nbsp;            if (LosEffects.hasFireBetween(ae.getPosition(),</b>
<b class="nc">&nbsp;                    target.getPosition(), game)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.HsmThruFire&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Narc-capable missiles homing on an iNarc beacon
<b class="nc">&nbsp;        if (isINarcGuided) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.iNarcHoming&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Listen-Kill ammo from War of 3039 sourcebook?
<b class="nc">&nbsp;        if (!isECMAffected</b>
<b class="nc">&nbsp;                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) </b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SRM)</b>
<b class="nc">&nbsp;                        || (atype.getAmmoType() == AmmoType.T_SRM_IMP))</b>
<b class="nc">&nbsp;                &amp;&amp; (munition == AmmoType.M_LISTEN_KILL) &amp;&amp; !((te != null) &amp;&amp; te.isClan())) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.ListenKill&quot;));</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the attacker&#39;s condition
&nbsp;     * Attacker has damaged sensors?  You&#39;ll find that here.
&nbsp;     * Defender&#39;s a superheavy mech?  Using a weapon with a TH penalty?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param los The calculated LOS between attacker and target
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * @param toSubtract An int value representing a running total of mods to disregard - used for some special attacks
&nbsp;     * 
&nbsp;     * @param aimingAt  An int value representing the location being aimed at
&nbsp;     * @param aimingMode  An int value that determines the reason aiming is allowed
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param weaponId  The id number of the weapon being used - used by some external calculations
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param isFlakAttack  flag that indicates whether the attacker is using Flak against an airborne target
&nbsp;     * @param isHaywireINarced  flag that indicates whether the attacker is affected by an iNarc Haywire pod
&nbsp;     * @param isNemesisConfused  flag that indicates whether the attack is affected by an iNarc Nemesis pod
&nbsp;     * @param isWeaponFieldGuns  flag that indicates whether the attack is being made with infantry field guns
&nbsp;     * @param usesAmmo  flag that indicates if the WeaponType being used is ammo-fed
&nbsp;     */
&nbsp;    private static ToHitData compileAttackerToHitMods(IGame game, Entity ae, Targetable target, LosEffects los, ToHitData toHit,
&nbsp;                int toSubtract, int aimingAt, int aimingMode, WeaponType wtype, Mounted weapon, int weaponId, AmmoType atype,
&nbsp;                long munition, boolean isFlakAttack, boolean isHaywireINarced, boolean isNemesisConfused, boolean isWeaponFieldGuns,
&nbsp;                boolean usesAmmo) {
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Modifiers related to an action the attacker is taking
&nbsp;        
&nbsp;        // attacker movement
<b class="nc">&nbsp;        toHit.append(Compute.getAttackerMovementModifier(game, ae.getId()));</b>
&nbsp;        
&nbsp;        // attacker prone
<b class="nc">&nbsp;        if (weaponId &gt; WeaponType.WEAPON_NA) {</b>
<b class="nc">&nbsp;            toHit.append(Compute.getProneMods(game, ae, weaponId));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // add penalty for called shots and change hit table, if necessary
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CALLED_SHOTS)</b>
&nbsp;                &amp;&amp; weapon != null) {
<b class="nc">&nbsp;            int call = weapon.getCalledShot().getCall();</b>
<b class="nc">&nbsp;            if ((call &gt; CalledShot.CALLED_NONE) &amp;&amp; (aimingMode != IAimingModes.AIM_MODE_NONE)) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.IMPOSSIBLE, Messages.getString(&quot;WeaponAttackAction.CantAimAndCallShots&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            switch (call) {</b>
&nbsp;            case CalledShot.CALLED_NONE:
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CalledShot.CALLED_HIGH:
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.CalledHigh&quot;));</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_ABOVE);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CalledShot.CALLED_LOW:
<b class="nc">&nbsp;                if (los.getTargetCover() == LosEffects.COVER_HORIZONTAL) {</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.IMPOSSIBLE, Messages.getString(&quot;WeaponAttackAction.CalledLowPartCover&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.CalledLow&quot;));</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_BELOW);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CalledShot.CALLED_LEFT:
&nbsp;                // handled by Compute#targetSideTable
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.CalledLeft&quot;));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case CalledShot.CALLED_RIGHT:
&nbsp;                // handled by Compute#targetSideTable
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.CalledRight&quot;));</b>
&nbsp;                break;
&nbsp;            }
&nbsp;            // If we&#39;re making a called shot with swarm LRMs, then the penalty
&nbsp;            // only applies to the original attack.
<b class="nc">&nbsp;            if (call != CalledShot.CALLED_NONE) {</b>
<b class="nc">&nbsp;                toSubtract += 3;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Dropping units get hit with a +2 dropping penalty AND the +3 Jumping penalty (SO p22) 
<b class="nc">&nbsp;        if (ae.isAirborne() &amp;&amp; !ae.isAero()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.Dropping&quot;));</b>
<b class="nc">&nbsp;            toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.Jumping&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Infantry taking cover suffer a +1 penalty
<b class="nc">&nbsp;        if ((ae instanceof Infantry) &amp;&amp; ((Infantry) ae).isTakingCover()) {</b>
<b class="nc">&nbsp;            if (ae.getPosition().direction(target.getPosition()) == ae.getFacing()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.FireThruCover&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Quadvee converting to a new mode
<b class="nc">&nbsp;        if (ae instanceof QuadVee &amp;&amp; ae.isConvertingNow()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.QuadVeeConverting&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Secondary targets modifier,
&nbsp;        // if this is not a iNarc Nemesis confused attack
&nbsp;        // Inf field guns don&#39;t get secondary target mods, TO pg 311
<b class="nc">&nbsp;        if (!isNemesisConfused &amp;&amp; !isWeaponFieldGuns) {</b>
<b class="nc">&nbsp;            toHit.append(Compute.getSecondaryTargetMod(game, ae, target));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if we&#39;re spotting for indirect fire, add +1
<b class="nc">&nbsp;        if (ae.isSpotting() &amp;&amp; !ae.getCrew().hasActiveCommandConsole()</b>
<b class="nc">&nbsp;                &amp;&amp; game.getTagInfo().stream().noneMatch(inf -&gt; inf.attackerId == ae.getId())) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.AeSpotting&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Special effects (like tasers) affecting the attacker
&nbsp;        
&nbsp;        // Attacker is battle armor and affected by BA taser feedback
<b class="nc">&nbsp;        if (ae.getTaserFeedBackRounds() &gt; 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.AeTaserFeedback&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If a unit is suffering from electromagnetic interference, they get a
&nbsp;        // blanket +2. Sucks to be them.
<b class="nc">&nbsp;        if (ae.isSufferingEMI()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.EMI&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // heat
<b class="nc">&nbsp;        if (ae.getHeatFiringModifier() != 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(ae.getHeatFiringModifier(), Messages.getString(&quot;WeaponAttackAction.Heat&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Attacker hit with an iNarc Haywire pod
<b class="nc">&nbsp;        if (isHaywireINarced) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.iNarcHaywire&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Attacker affected by Taser interference
<b class="nc">&nbsp;        if (ae.getTaserInterferenceRounds() &gt; 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(ae.getTaserInterference(), Messages.getString(&quot;WeaponAttackAction.AeHitByTaser&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Attacker affected by TSEMP interference
<b class="nc">&nbsp;        if (ae.getTsempEffect() == TSEMPWeapon.TSEMP_EFFECT_INTERFERENCE) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.AeTsemped&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Special Equipment that that attacker possesses
&nbsp;        
&nbsp;        // Attacker has an AES system
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; ae.hasFunctionalArmAES(weapon.getLocation()) &amp;&amp; !weapon.isSplit()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.AES&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Heavy infantry have +1 penalty
<b class="nc">&nbsp;        if ((ae instanceof Infantry) &amp;&amp; ae.hasWorkingMisc(MiscType.F_TOOLS, MiscType.S_HEAVY_ARMOR)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.HeavyArmor&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // industrial cockpit: +1 to hit
<b class="nc">&nbsp;        if ((ae instanceof Mech) &amp;&amp; (((Mech) ae).getCockpitType() == Mech.COCKPIT_INDUSTRIAL)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.IndustrialNoAfc&quot;));</b>
&nbsp;        }
&nbsp;        // primitive industrial cockpit: +2 to hit
<b class="nc">&nbsp;        if ((ae instanceof Mech) &amp;&amp; (((Mech) ae).getCockpitType() == Mech.COCKPIT_PRIMITIVE_INDUSTRIAL)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.PrimIndustrialNoAfc&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // primitive industrial cockpit with advanced firing control: +1 to hit
<b class="nc">&nbsp;        if ((ae instanceof Mech) &amp;&amp; (((Mech) ae).getCockpitType() == Mech.COCKPIT_PRIMITIVE)</b>
<b class="nc">&nbsp;                &amp;&amp; ((Mech) ae).isIndustrial()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.PrimIndustrialAfc&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Support vehicle basic/advanced fire control systems
<b class="nc">&nbsp;        if ((ae instanceof SupportTank) || (ae instanceof SupportVTOL)) {</b>
<b class="nc">&nbsp;            if (!ae.hasWorkingMisc(MiscType.F_BASIC_FIRECONTROL)</b>
<b class="nc">&nbsp;                    &amp;&amp; !ae.hasWorkingMisc(MiscType.F_ADVANCED_FIRECONTROL)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.SupVeeNoFc&quot;));</b>
<b class="nc">&nbsp;            } else if (ae.hasWorkingMisc(MiscType.F_BASIC_FIRECONTROL)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(ae.hasWorkingMisc(MiscType.F_ADVANCED_FIRECONTROL))) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.SupVeeBfc&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Is the attacker hindered by a shield?
<b class="nc">&nbsp;        if (ae.hasShield() &amp;&amp; weapon != null) {</b>
&nbsp;            // active shield has already been checked as it makes shots
&nbsp;            // impossible
&nbsp;            // time to check passive defense and no defense
&nbsp;
<b class="nc">&nbsp;            if (ae.hasPassiveShield(weapon.getLocation(), weapon.isRearMounted())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.PassiveShield&quot;));</b>
<b class="nc">&nbsp;            } else if (ae.hasNoDefenseShield(weapon.getLocation())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.Shield&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // add targeting computer (except with LBX cluster ammo)
<b class="nc">&nbsp;        if ((aimingMode == IAimingModes.AIM_MODE_TARG_COMP) &amp;&amp; (aimingAt != Entity.LOC_NONE)) {</b>
<b class="nc">&nbsp;            if (ae.hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;                if (ae.hasTargComp()) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.AimWithTCompEi&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(6, Messages.getString(&quot;WeaponAttackAction.AimWithEiOnly&quot;));</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(3, Messages.getString(&quot;WeaponAttackAction.AimWithTCompOnly&quot;));</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // LB-X cluster, HAG flak, flak ammo ineligible for TC bonus
<b class="nc">&nbsp;            boolean usesLBXCluster = usesAmmo &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getAmmoType() == AmmoType.T_AC_LBX || atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
&nbsp;                    &amp;&amp; munition == AmmoType.M_CLUSTER;
<b class="nc">&nbsp;            boolean usesHAGFlak = usesAmmo &amp;&amp; (atype != null) &amp;&amp; atype.getAmmoType() == AmmoType.T_HAG &amp;&amp; isFlakAttack;</b>
<b class="nc">&nbsp;            boolean isSBGauss = usesAmmo &amp;&amp; (atype != null) &amp;&amp; atype.getAmmoType() == AmmoType.T_SBGAUSS;</b>
<b class="nc">&nbsp;            boolean isFlakAmmo = usesAmmo &amp;&amp; (atype != null) &amp;&amp; (munition == AmmoType.M_FLAK);</b>
<b class="nc">&nbsp;            if (ae.hasTargComp() &amp;&amp; wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE) &amp;&amp; !wtype.hasFlag(WeaponType.F_CWS)</b>
<b class="nc">&nbsp;                    &amp;&amp; !wtype.hasFlag(WeaponType.F_TASER)</b>
&nbsp;                    &amp;&amp; (!usesAmmo || !(usesLBXCluster || usesHAGFlak || isSBGauss || isFlakAmmo))) {
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.TComp&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // penalty for an active void signature system
<b class="nc">&nbsp;        if (ae.isVoidSigActive()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.AeVoidSig&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Critical damage effects
&nbsp;        
&nbsp;        // actuator &amp; sensor damage to attacker (includes partial repairs)
<b class="nc">&nbsp;        if (weapon != null) {</b>
<b class="nc">&nbsp;            toHit.append(Compute.getDamageWeaponMods(ae, weapon));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Vehicle criticals
<b class="nc">&nbsp;        if (ae instanceof Tank) {</b>
<b class="nc">&nbsp;            Tank tank = (Tank) ae;</b>
<b class="nc">&nbsp;            int sensors = tank.getSensorHits();</b>
<b class="nc">&nbsp;            if (sensors &gt; 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(sensors, Messages.getString(&quot;WeaponAttackAction.SensorDamage&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (weapon != null &amp;&amp; tank.isStabiliserHit(weapon.getLocation())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(Compute.getAttackerMovementModifier(game, tank.getId()).getValue(),</b>
&nbsp;                        &quot;stabiliser damage&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Quirks
&nbsp;        
&nbsp;        // Anti-air targeting quirk vs airborne unit
<b class="nc">&nbsp;        if (ae.hasQuirk(OptionsConstants.QUIRK_POS_ANTI_AIR) &amp;&amp; (target instanceof Entity)) {</b>
<b class="nc">&nbsp;            if (target.isAirborneVTOLorWIGE() || target.isAirborne()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.AaVsAir&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Sensor ghosts quirk
<b class="nc">&nbsp;        if (ae.hasQuirk(OptionsConstants.QUIRK_NEG_SENSOR_GHOSTS)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.SensorGhosts&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the attacker&#39;s condition, 
&nbsp;     * if the attacker is an aero
&nbsp;     * Attacker has damaged sensors?  You&#39;ll find that here.
&nbsp;     * Defender&#39;s a superheavy mech?  Using a weapon with a TH penalty?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param aimingAt  An int value representing the location being aimed at
&nbsp;     * @param aimingMode  An int value that determines the reason aiming is allowed
&nbsp;     * @param eistatus An int value representing the ei cockpit/pilot upgrade status
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param isArtilleryIndirect  flag that indicates whether this is an indirect-fire artillery attack
&nbsp;     * @param isFlakAttack  flag that indicates whether the attacker is using Flak against an airborne target
&nbsp;     * @param isNemesisConfused  flag that indicates whether the attack is affected by an iNarc Nemesis pod
&nbsp;     * @param isStrafing    flag that indicates whether this is an aero strafing attack
&nbsp;     * @param usesAmmo  flag that indicates if the WeaponType being used is ammo-fed
&nbsp;     */
&nbsp;    private static ToHitData compileAeroAttackerToHitMods(IGame game, Entity ae, Targetable target, int ttype,
&nbsp;                ToHitData toHit, int aimingAt, int aimingMode, int eistatus, WeaponType wtype, Mounted weapon,
&nbsp;                AmmoType atype, long munition, boolean isArtilleryIndirect, boolean isFlakAttack, boolean isNemesisConfused,
&nbsp;                boolean isStrafing, boolean usesAmmo) {
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some of these weapons only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Generic modifiers that apply to airborne and ground attackers
&nbsp;        
&nbsp;        // actuator &amp; sensor damage to attacker (includes partial repairs)
<b class="nc">&nbsp;        if (weapon != null) {</b>
<b class="nc">&nbsp;            toHit.append(Compute.getDamageWeaponMods(ae, weapon));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // heat
<b class="nc">&nbsp;        if (ae.getHeatFiringModifier() != 0) {</b>
<b class="nc">&nbsp;            toHit.addModifier(ae.getHeatFiringModifier(), Messages.getString(&quot;WeaponAttackAction.Heat&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Secondary targets modifier, if this is not a iNarc Nemesis confused attack
&nbsp;        // Also does not apply for altitude bombing or strafing
<b class="nc">&nbsp;        if (!isNemesisConfused &amp;&amp; wtype != null &amp;&amp; !wtype.hasFlag(WeaponType.F_ALT_BOMB) &amp;&amp; !isStrafing) {</b>
<b class="nc">&nbsp;            toHit.append(Compute.getSecondaryTargetMod(game, ae, target));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // add targeting computer (except with LBX cluster ammo)
<b class="nc">&nbsp;        if ((aimingMode == IAimingModes.AIM_MODE_TARG_COMP) &amp;&amp; (aimingAt != Entity.LOC_NONE)) {</b>
<b class="nc">&nbsp;            if (ae.hasActiveEiCockpit()) {</b>
<b class="nc">&nbsp;                if (ae.hasTargComp()) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.AimWithTCompEi&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(6, Messages.getString(&quot;WeaponAttackAction.AimWithEiOnly&quot;));</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(3, Messages.getString(&quot;WeaponAttackAction.AimWithTCompOnly&quot;));</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // LB-X cluster, HAG flak, flak ammo ineligible for TC bonus
<b class="nc">&nbsp;            boolean usesLBXCluster = usesAmmo &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (atype.getAmmoType() == AmmoType.T_AC_LBX || atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</b>
&nbsp;                    &amp;&amp; munition == AmmoType.M_CLUSTER;
<b class="nc">&nbsp;            boolean usesHAGFlak = usesAmmo &amp;&amp; (atype != null) &amp;&amp; atype.getAmmoType() == AmmoType.T_HAG &amp;&amp; isFlakAttack;</b>
<b class="nc">&nbsp;            boolean isSBGauss = usesAmmo &amp;&amp; (atype != null) &amp;&amp; atype.getAmmoType() == AmmoType.T_SBGAUSS;</b>
<b class="nc">&nbsp;            boolean isFlakAmmo = usesAmmo &amp;&amp; (atype != null) &amp;&amp; (munition == AmmoType.M_FLAK);</b>
<b class="nc">&nbsp;            if (ae.hasTargComp() &amp;&amp; wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE) &amp;&amp; !wtype.hasFlag(WeaponType.F_CWS)</b>
<b class="nc">&nbsp;                    &amp;&amp; !wtype.hasFlag(WeaponType.F_TASER)</b>
&nbsp;                    &amp;&amp; (!usesAmmo || !(usesLBXCluster || usesHAGFlak || isSBGauss || isFlakAmmo))) {
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.TComp&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Modifiers for aero units, including fighter LAMs
<b class="nc">&nbsp;        if (ae.isAero()) {</b>
<b class="nc">&nbsp;            IAero aero = (IAero) ae;</b>
&nbsp;
&nbsp;            // check for heavy gauss rifle on fighter of small craft
&nbsp;            // Arguably a weapon effect, except that it only applies when used by a fighter (isn&#39;t recoil fun?)
&nbsp;            // So it&#39;s here instead of with other weapon mods that apply across the board
<b class="nc">&nbsp;            if ((wtype instanceof ISHGaussRifle) &amp;&amp; !(ae instanceof Dropship)</b>
&nbsp;                    &amp;&amp; !(ae instanceof Jumpship)) {
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.FighterHeavyGauss&quot;));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Space ECM
<b class="nc">&nbsp;            if (game.getBoard().inSpace() &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</b>
<b class="nc">&nbsp;                int ecm = ComputeECM.getLargeCraftECM(ae, ae.getPosition(), target.getPosition());</b>
<b class="nc">&nbsp;                if (!ae.isLargeCraft()) {</b>
<b class="nc">&nbsp;                    ecm += ComputeECM.getSmallCraftECM(ae, ae.getPosition(), target.getPosition());</b>
&nbsp;                }
<b class="nc">&nbsp;                ecm = Math.min(4, ecm);</b>
<b class="nc">&nbsp;                int eccm = 0;</b>
<b class="nc">&nbsp;                if (ae.isLargeCraft()) {</b>
<b class="nc">&nbsp;                    eccm = ((Aero) ae).getECCMBonus();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (ecm &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(ecm, Messages.getString(&quot;WeaponAttackAction.ECM&quot;));</b>
<b class="nc">&nbsp;                    if (eccm &gt; 0) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(-1 * Math.min(ecm, eccm), Messages.getString(&quot;WeaponAttackAction.ECCM&quot;));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // +4 attack penalty for locations hit by ASEW missiles
<b class="nc">&nbsp;            if (ae instanceof Dropship) {</b>
<b class="nc">&nbsp;                Dropship d = (Dropship) ae;</b>
<b class="nc">&nbsp;                if (weapon != null) {</b>
<b class="nc">&nbsp;                    int loc = weapon.getLocation();</b>
<b class="nc">&nbsp;                    if (d.getASEWAffected(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(4, Messages.getString(&quot;WeaponAttackAction.AeArcAsewAffected&quot;));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (ae instanceof Jumpship) {</b>
<b class="nc">&nbsp;                Jumpship j = (Jumpship) ae;</b>
<b class="nc">&nbsp;                if (weapon != null) {</b>
<b class="nc">&nbsp;                    int loc = weapon.getLocation();</b>
<b class="nc">&nbsp;                    if (j.getASEWAffected(loc) &gt; 0) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(4, Messages.getString(&quot;WeaponAttackAction.AeArcAsewAffected&quot;));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                if (ae.getASEWAffected() &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(4, Messages.getString(&quot;WeaponAttackAction.AeAsewAffected&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Altitude-related mods for air-to-air combat
<b class="nc">&nbsp;            if (Compute.isAirToAir(ae, target)) {</b>
<b class="nc">&nbsp;                if (target.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+5, Messages.getString(&quot;WeaponAttackAction.TeNonAeroAirborne&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (ae.isNOE()) {</b>
<b class="nc">&nbsp;                    if (ae.isOmni()) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.AeOmniNoe&quot;));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.AeNoe&quot;));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            
&nbsp;            // air-to-ground strikes
<b class="nc">&nbsp;            if (Compute.isAirToGround(ae, target)</b>
<b class="nc">&nbsp;                    || (ae.isMakingVTOLGroundAttack())) {</b>
&nbsp;                // When altitude bombing, add the altitude as a modifier
<b class="nc">&nbsp;                if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ALT_BOMB)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(ae.getAltitude(), Messages.getString(&quot;WeaponAttackAction.BombAltitude&quot;));</b>
&nbsp;                    // -2 for the Golden Goose SPA
<b class="nc">&nbsp;                    if (ae.hasAbility(OptionsConstants.GUNNERY_GOLDEN_GOOSE)) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.GoldenGoose&quot;));</b>
&nbsp;                    }
&nbsp;                // +4 Modifier for strafing
<b class="nc">&nbsp;                } else if (isStrafing) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+4, Messages.getString(&quot;WeaponAttackAction.Strafing&quot;));</b>
&nbsp;                    // Additional +2 if flying at Nape-of-Earth
<b class="nc">&nbsp;                    if (ae.getAltitude() == 1) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.StrafingNoe&quot;));</b>
&nbsp;                    }
&nbsp;                    // Additional Nape-of-Earth restrictions for strafing
<b class="nc">&nbsp;                    if (ae.getAltitude() == 1) {</b>
<b class="nc">&nbsp;                        Coords prevCoords = ae.passedThroughPrevious(target.getPosition());</b>
<b class="nc">&nbsp;                        IHex prevHex = game.getBoard().getHex(prevCoords);</b>
<b class="nc">&nbsp;                        toHit.append(Compute.getStrafingTerrainModifier(game, eistatus, prevHex));</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
&nbsp;                    // +2 modifier for striking
<b class="nc">&nbsp;                    toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.AtgStrike&quot;));</b>
<b class="nc">&nbsp;                    if (ae.hasAbility(OptionsConstants.GUNNERY_GOLDEN_GOOSE)) {</b>
<b class="nc">&nbsp;                        if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
&nbsp;                            // -2 for the Golden Goose SPA if dive bombing
<b class="nc">&nbsp;                            toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.GoldenGoose&quot;));</b>
&nbsp;                        } else {
&nbsp;                            // -1 for the Golden Goose SPA on strike attacks
<b class="nc">&nbsp;                            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.GoldenGoose&quot;));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // units making air to ground attacks are easier to hit by air-to-air
&nbsp;            // attacks
<b class="nc">&nbsp;            if (Compute.isAirToAir(ae, target)) {</b>
<b class="nc">&nbsp;                for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    EntityAction ea = i.nextElement();</b>
<b class="nc">&nbsp;                    if (!(ea instanceof WeaponAttackAction)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</b>
<b class="nc">&nbsp;                    if ((te != null &amp;&amp; prevAttack.getEntityId() == te.getId()) &amp;&amp; prevAttack.isAirToGround(game)) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(-3, Messages.getString(&quot;WeaponAttackAction.TeGroundAttack&quot;));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // grounded aero
<b class="nc">&nbsp;            if (!ae.isAirborne() &amp;&amp; !ae.isSpaceborne()) {</b>
<b class="nc">&nbsp;                if (!(ae instanceof Dropship)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.GroundedAero&quot;));</b>
<b class="nc">&nbsp;                } else if (!target.isAirborne() &amp;&amp; !isArtilleryIndirect) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.GroundedDs&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // out of control
<b class="nc">&nbsp;            if (aero.isOutControlTotal()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.AeroOoc&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Situational modifiers for aero units, not including LAMs.
<b class="nc">&nbsp;        if (ae instanceof Aero) {</b>
<b class="nc">&nbsp;            Aero aero = (Aero) ae;</b>
&nbsp;
&nbsp;            // sensor hits
<b class="nc">&nbsp;            int sensors = aero.getSensorHits();</b>
&nbsp;
<b class="nc">&nbsp;            if (!ae.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                if ((sensors &gt; 0) &amp;&amp; (sensors &lt; 3)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(sensors, Messages.getString(&quot;WeaponAttackAction.SensorDamage&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (sensors &gt; 2) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+5, Messages.getString(&quot;WeaponAttackAction.SensorDestroyed&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // FCS hits
<b class="nc">&nbsp;            int fcs = aero.getFCSHits();</b>
&nbsp;
<b class="nc">&nbsp;            if ((fcs &gt; 0) &amp;&amp; !aero.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(fcs * 2, Messages.getString(&quot;WeaponAttackAction.FcsDamage&quot;));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // CIC hits
<b class="nc">&nbsp;            if (aero instanceof Jumpship) {</b>
<b class="nc">&nbsp;                Jumpship js = (Jumpship) aero;</b>
<b class="nc">&nbsp;                int cic = js.getCICHits();</b>
<b class="nc">&nbsp;                if (cic &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(cic * 2, Messages.getString(&quot;WeaponAttackAction.CicDamage&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // targeting mods for evasive action by large craft
&nbsp;            // Per TW, this does not apply when firing Capital Missiles
<b class="nc">&nbsp;            if (aero.isEvading() &amp;&amp; wtype != null &amp;&amp; </b>
<b class="nc">&nbsp;                    (!(wtype.getAtClass() == WeaponType.CLASS_CAPITAL_MISSILE</b>
<b class="nc">&nbsp;                            || wtype.getAtClass() == WeaponType.CLASS_AR10</b>
<b class="nc">&nbsp;                            || wtype.getAtClass() == WeaponType.CLASS_TELE_MISSILE))) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.AeEvading&quot;));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // stratops page 113: ECHO maneuvers for large craft
<b class="nc">&nbsp;            if (((aero instanceof Warship) || (aero instanceof Dropship)) &amp;&amp;</b>
<b class="nc">&nbsp;                    (aero.getFacing() != aero.getSecondaryFacing())) {</b>
&nbsp;                // if we&#39;re computing this for an &quot;attack preview&quot;, then we add 2 MP to 
&nbsp;                // the mp used, as we haven&#39;t used the MP yet. If we&#39;re actually processing
&nbsp;                // the attack, then the entity will be marked as &#39;done&#39; and we have already added
&nbsp;                // the 2 MP, so we don&#39;t need to double-count it
<b class="nc">&nbsp;                int extraMP = aero.isDone() ? 0 : 2;</b>
<b class="nc">&nbsp;                boolean willUseRunMP = aero.mpUsed + extraMP &gt; aero.getWalkMP();</b>
<b class="nc">&nbsp;                int mod = willUseRunMP ? 2 : 1;</b>
<b class="nc">&nbsp;                toHit.addModifier(mod, Messages.getString(&quot;WeaponAttackAction.LargeCraftEcho&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for particular kinds of weapons in weapon bays
<b class="nc">&nbsp;            if (ae.usesWeaponBays() &amp;&amp; wtype != null &amp;&amp; weapon != null) {</b>
&nbsp;
&nbsp;                // any heavy lasers
<b class="nc">&nbsp;                if (wtype.getAtClass() == WeaponType.CLASS_LASER) {</b>
<b class="nc">&nbsp;                    for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                        Mounted bweap = ae.getEquipment(wId);</b>
<b class="nc">&nbsp;                        WeaponType bwtype = (WeaponType) bweap.getType();</b>
<b class="nc">&nbsp;                        if ((bwtype.getInternalName().contains(&quot;Heavy&quot;))</b>
<b class="nc">&nbsp;                                &amp;&amp; (bwtype.getInternalName().contains(&quot;Laser&quot;))) {</b>
<b class="nc">&nbsp;                            toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.HeavyLaserInBay&quot;));</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // barracuda missiles
<b class="nc">&nbsp;                else if (wtype.getAtClass() == WeaponType.CLASS_CAPITAL_MISSILE) {</b>
<b class="nc">&nbsp;                    boolean onlyBarracuda = true;</b>
<b class="nc">&nbsp;                    for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                        Mounted bweap = ae.getEquipment(wId);</b>
<b class="nc">&nbsp;                        Mounted bammo = bweap.getLinked();</b>
<b class="nc">&nbsp;                        if (bammo != null) {</b>
<b class="nc">&nbsp;                            AmmoType batype = (AmmoType) bammo.getType();</b>
<b class="nc">&nbsp;                            if (batype.getAmmoType() != AmmoType.T_BARRACUDA) {</b>
<b class="nc">&nbsp;                                onlyBarracuda = false;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (onlyBarracuda) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.Barracuda&quot;));</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // barracuda missiles in an AR10 launcher (must all be
&nbsp;                // barracuda)
<b class="nc">&nbsp;                else if (wtype.getAtClass() == WeaponType.CLASS_AR10) {</b>
<b class="nc">&nbsp;                    boolean onlyBarracuda = true;</b>
<b class="nc">&nbsp;                    for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                        Mounted bweap = ae.getEquipment(wId);</b>
<b class="nc">&nbsp;                        Mounted bammo = bweap.getLinked();</b>
<b class="nc">&nbsp;                        if (bammo != null) {</b>
<b class="nc">&nbsp;                            AmmoType batype = (AmmoType) bammo.getType();</b>
<b class="nc">&nbsp;                            if (!batype.hasFlag(AmmoType.F_AR10_BARRACUDA)) {</b>
<b class="nc">&nbsp;                                onlyBarracuda = false;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (onlyBarracuda) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.Barracuda&quot;));</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // LBX cluster
<b class="nc">&nbsp;                else if (wtype.getAtClass() == WeaponType.CLASS_LBX_AC) {</b>
<b class="nc">&nbsp;                    boolean onlyCluster = true;</b>
<b class="nc">&nbsp;                    for (int wId : weapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                        Mounted bweap = ae.getEquipment(wId);</b>
<b class="nc">&nbsp;                        Mounted bammo = bweap.getLinked();</b>
<b class="nc">&nbsp;                        if (bammo != null) {</b>
<b class="nc">&nbsp;                            AmmoType batype = (AmmoType) bammo.getType();</b>
<b class="nc">&nbsp;                            if (batype.getMunitionType() != AmmoType.M_CLUSTER) {</b>
<b class="nc">&nbsp;                                onlyCluster = false;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (onlyCluster) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.ClusterAmmo&quot;));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the attacker&#39;s crew/pilot
&nbsp;     * Pilot wounded?  Has an SPA?  You&#39;ll find that here.
&nbsp;     * Defender&#39;s a superheavy mech?  Using a weapon with a TH penalty?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param te The target Entity
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * 
&nbsp;     */
&nbsp;    private static ToHitData compileCrewToHitMods(IGame game, Entity ae, Entity te, ToHitData toHit, WeaponType wtype) {
&nbsp;        
<b class="nc">&nbsp;        if (ae == null) {</b>
&nbsp;            // These checks won&#39;t work without a valid attacker
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Now for modifiers affecting the attacker&#39;s crew
&nbsp;        
&nbsp;        // Bonuses for dual cockpits, etc
&nbsp;        // Bonus to gunnery if both crew members are active; a pilot who takes the gunner&#39;s role get +1.
<b class="nc">&nbsp;        if (ae instanceof Mech &amp;&amp; ((Mech)ae).getCockpitType() == Mech.COCKPIT_DUAL) {</b>
<b class="nc">&nbsp;            if (!ae.getCrew().isActive(ae.getCrew().getCrewType().getGunnerPos())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.GunnerHit&quot;));                </b>
<b class="nc">&nbsp;            } else if (ae.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.DualCockpit&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // The pilot or technical officer can take over the gunner&#39;s duties but suffers a +2 penalty.
<b class="nc">&nbsp;        if ((ae instanceof TripodMech || ae instanceof QuadVee) &amp;&amp; !ae.getCrew().hasDedicatedGunner()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.GunnerHit&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Fatigue
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_FATIGUE)</b>
<b class="nc">&nbsp;                &amp;&amp; ae.getCrew().isGunneryFatigued()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.Fatigue&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Injuries
&nbsp;        
&nbsp;        // Aero unit pilot/crew hits
<b class="nc">&nbsp;        if (ae instanceof Aero) {</b>
<b class="nc">&nbsp;            int pilothits = ae.getCrew().getHits();</b>
<b class="nc">&nbsp;            if ((pilothits &gt; 0) &amp;&amp; !ae.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(pilothits, Messages.getString(&quot;WeaponAttackAction.PilotHits&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Vehicle crew hits
<b class="nc">&nbsp;        if (ae instanceof Tank) {</b>
<b class="nc">&nbsp;            Tank tank = (Tank) ae;</b>
<b class="nc">&nbsp;            if (tank.isCommanderHit()) {</b>
<b class="nc">&nbsp;                if (ae instanceof VTOL) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.CopilotHit&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.CmdrHit&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Manei Domini Upgrades
&nbsp;        
&nbsp;        // VDNI
<b class="nc">&nbsp;        if (ae.hasAbility(OptionsConstants.MD_VDNI)</b>
<b class="nc">&nbsp;                || ae.hasAbility(OptionsConstants.MD_BVDNI)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.Vdni&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((ae instanceof Infantry) &amp;&amp; !(ae instanceof BattleArmor)) {</b>
&nbsp;            // check for pl-masc
&nbsp;            // the rules are a bit vague, but assume that if the infantry didn&#39;t
&nbsp;            // move or jumped, then they shouldn&#39;t get the penalty
<b class="nc">&nbsp;            if (ae.hasAbility(OptionsConstants.MD_PL_MASC)</b>
&nbsp;                    &amp;&amp; ((ae.moved == EntityMovementType.MOVE_WALK) || (ae.moved == EntityMovementType.MOVE_RUN))) {
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.PlMasc&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for cyber eye laser sighting on ranged attacks
<b class="nc">&nbsp;            if (ae.hasAbility(OptionsConstants.MD_CYBER_IMP_LASER)</b>
&nbsp;                    &amp;&amp; !(wtype instanceof InfantryAttack)) {
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.MdEye&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // SPAs
&nbsp;        
&nbsp;        // Unofficial weapon class specialist - Does not have an unspecialized penalty 
<b class="nc">&nbsp;        if (ae.hasAbility(OptionsConstants.UNOFF_GUNNERY_LASER)</b>
<b class="nc">&nbsp;                &amp;&amp; wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.GunLSkill&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ae.hasAbility(OptionsConstants.UNOFF_GUNNERY_BALLISTIC)</b>
<b class="nc">&nbsp;                &amp;&amp; wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.GunBSkill&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ae.hasAbility(OptionsConstants.UNOFF_GUNNERY_MISSILE)</b>
<b class="nc">&nbsp;                &amp;&amp; wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.GunMSkill&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is the pilot a weapon specialist?
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; ae.hasAbility(OptionsConstants.GUNNERY_WEAPON_SPECIALIST, wtype.getName())) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.WeaponSpec&quot;));</b>
<b class="nc">&nbsp;        } else if (ae.hasAbility(OptionsConstants.GUNNERY_SPECIALIST)) {</b>
&nbsp;            // aToW style gunnery specialist: -1 to specialized weapon and +1 to
&nbsp;            // all other weapons
&nbsp;            // Note that weapon specialist supersedes gunnery specialization, so
&nbsp;            // if you have
&nbsp;            // a specialization in Medium Lasers and a Laser specialization, you
&nbsp;            // only get the -2 specialization mod
<b class="nc">&nbsp;            if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY)) {</b>
<b class="nc">&nbsp;                if (ae.hasAbility(OptionsConstants.GUNNERY_SPECIALIST, Crew.SPECIAL_ENERGY)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.EnergySpec&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.Unspec&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC)) {</b>
<b class="nc">&nbsp;                if (ae.hasAbility(OptionsConstants.GUNNERY_SPECIALIST, Crew.SPECIAL_BALLISTIC)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.BallisticSpec&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.Unspec&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MISSILE)) {</b>
<b class="nc">&nbsp;                if (ae.hasAbility(OptionsConstants.GUNNERY_SPECIALIST, Crew.SPECIAL_MISSILE)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.MissileSpec&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.Unspec&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Target SPAs
<b class="nc">&nbsp;        if (te != null) {</b>
&nbsp;            // Shaky Stick -  Target gets a +1 bonus against Ground-to-Air attacks
<b class="nc">&nbsp;            if (te.hasAbility(OptionsConstants.PILOT_SHAKY_STICK) &amp;&amp; te.isAirborne()</b>
<b class="nc">&nbsp;                    &amp;&amp; !ae.isAirborne() &amp;&amp; !ae.isAirborneVTOLorWIGE()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.ShakyStick&quot;));</b>
&nbsp;            }
&nbsp;            // Urban Guerrilla - Target gets a +1 bonus in any sort of urban terrain
<b class="nc">&nbsp;            if (te.hasAbility(OptionsConstants.INFANTRY_URBAN_GUERRILLA)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.ROAD)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.RUBBLE)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                            || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.ROUGH))) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.UrbanGuerilla&quot;));</b>
&nbsp;            }
&nbsp;            // Forest Ranger - Target gets a +1 bonus in wooded terrain when moving at walking speed or greater
<b class="nc">&nbsp;            if (te.hasAbility(OptionsConstants.PILOT_TM_FOREST_RANGER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                       || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.JUNGLE))</b>
&nbsp;                    &amp;&amp; te.moved == EntityMovementType.MOVE_WALK) {
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.ForestRanger&quot;));</b>
&nbsp;            }
&nbsp;            // Swamp Beast - Target gets a +1 bonus in mud/swamp terrain when running/flanking
<b class="nc">&nbsp;            if (te.hasAbility(OptionsConstants.PILOT_TM_SWAMP_BEAST)</b>
<b class="nc">&nbsp;                    &amp;&amp; (game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.MUD)</b>
<b class="nc">&nbsp;                        || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.SWAMP))</b>
&nbsp;                    &amp;&amp; te.moved == EntityMovementType.MOVE_RUN) {
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.SwampBeast&quot;));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the defender&#39;s condition and actions
&nbsp;     * -4 for shooting at an immobile target?  You&#39;ll find that here.
&nbsp;     * Attacker strafing?  Using a weapon with a TH penalty?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param los The calculated LOS between attacker and target
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * @param toSubtract An int value representing a running total of mods to disregard - used for some special attacks
&nbsp;     * 
&nbsp;     * @param aimingAt  An int value representing the location being aimed at - used by immobile target calculations
&nbsp;     * @param aimingMode  An int value that determines the reason aiming is allowed - used by immobile target calculations
&nbsp;     * @param distance  The distance in hexes from attacker to target
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param isArtilleryDirect  flag that indicates whether this is a direct-fire artillery attack
&nbsp;     * @param isArtilleryIndirect  flag that indicates whether this is an indirect-fire artillery attack
&nbsp;     * @param isAttackerInfantry  flag that indicates whether the attacker is an infantry/BA unit
&nbsp;     * @param exchangeSwarmTarget  flag that indicates whether this is the secondary target of Swarm LRMs
&nbsp;     * @param isIndirect  flag that indicates whether this is an indirect attack (LRM, mortar...)
&nbsp;     * @param isPointBlankShot  flag that indicates whether or not this is a PBS by a hidden unit
&nbsp;     * @param usesAmmo  flag that indicates whether or not the WeaponType being used is ammo-fed
&nbsp;     */
&nbsp;    private static ToHitData compileTargetToHitMods(IGame game, Entity ae, Targetable target, int ttype, LosEffects los,
&nbsp;                ToHitData toHit, int toSubtract, int aimingAt, int aimingMode, int distance, WeaponType wtype,
&nbsp;                Mounted weapon, AmmoType atype, long munition, boolean isArtilleryDirect, boolean isArtilleryIndirect,
&nbsp;                boolean isAttackerInfantry, boolean exchangeSwarmTarget, boolean isIndirect,
&nbsp;                boolean isPointBlankShot, boolean usesAmmo) {
<b class="nc">&nbsp;        if (ae == null || target == null) {</b>
&nbsp;            // Can&#39;t handle these attacks without a valid attacker and target
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Target&#39;s hex
<b class="nc">&nbsp;        IHex targHex = game.getBoard().getHex(target.getPosition());</b>
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some weapons only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Modifiers related to a special action the target is taking
&nbsp;        
&nbsp;        // evading bonuses
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; te.isEvading()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(te.getEvasionBonus(), Messages.getString(&quot;WeaponAttackAction.TeEvading&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Hull Down
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; te.isHullDown()) {</b>
<b class="nc">&nbsp;            if ((te instanceof Mech) &amp;&amp; !(te instanceof QuadVee &amp;&amp; te.getConversionMode() == QuadVee.CONV_MODE_VEHICLE)</b>
<b class="nc">&nbsp;                    &amp;&amp; (los.getTargetCover() &gt; LosEffects.COVER_NONE)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.HullDown&quot;));</b>
&nbsp;            }
&nbsp;            // tanks going Hull Down is different rules then &#39;Mechs, the
&nbsp;            // direction the attack comes from matters
<b class="nc">&nbsp;            else if ((te instanceof Tank || (te instanceof QuadVee &amp;&amp; te.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</b>
<b class="nc">&nbsp;                    &amp;&amp; targHex.containsTerrain(Terrains.FORTIFIED)) {</b>
&nbsp;                // TODO make this a LoS mod so that attacks will come in from
&nbsp;                // directions that grant Hull Down Mods
&nbsp;                int moveInDirection;
&nbsp;
<b class="nc">&nbsp;                if (!((Tank) te).isBackedIntoHullDown()) {</b>
<b class="nc">&nbsp;                    moveInDirection = ToHitData.SIDE_FRONT;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    moveInDirection = ToHitData.SIDE_REAR;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if ((te.sideTable(ae.getPosition()) == moveInDirection)</b>
<b class="nc">&nbsp;                        || (te.sideTable(ae.getPosition()) == ToHitData.SIDE_LEFT)</b>
<b class="nc">&nbsp;                        || (te.sideTable(ae.getPosition()) == ToHitData.SIDE_RIGHT)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.HullDown&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Infantry taking cover per TacOps special rules
<b class="nc">&nbsp;        if (te != null &amp;&amp; (te instanceof Infantry) &amp;&amp; ((Infantry) te).isTakingCover()) {</b>
<b class="nc">&nbsp;            if (te.getPosition().direction(ae.getPosition()) == te.getFacing()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.FireThruCover&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // target prone
<b class="nc">&nbsp;        ToHitData proneMod = null;</b>
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; te.isProne()) {</b>
&nbsp;            // easier when point-blank
<b class="nc">&nbsp;            if (distance &lt;= 1) {</b>
&nbsp;                // TW, pg. 221: Swarm Mek attacks apply prone/immobile mods as
&nbsp;                // normal.
<b class="nc">&nbsp;                proneMod = new ToHitData(-2, Messages.getString(&quot;WeaponAttackAction.ProneAdj&quot;));</b>
&nbsp;            } else {
&nbsp;                // Harder at range.
<b class="nc">&nbsp;                proneMod = new ToHitData(1, Messages.getString(&quot;WeaponAttackAction.ProneRange&quot;));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (proneMod != null) {</b>
<b class="nc">&nbsp;            toHit.append(proneMod);</b>
<b class="nc">&nbsp;            toSubtract += proneMod.getValue();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Special effects affecting the target
&nbsp;        
&nbsp;        // Target grappled?
<b class="nc">&nbsp;        if (te != null) {</b>
<b class="nc">&nbsp;            int grapple = te.getGrappled();</b>
<b class="nc">&nbsp;            if (grapple != Entity.NONE) {</b>
&nbsp;                // -4 bonus if attacking the entity you&#39;re grappling
<b class="nc">&nbsp;                if ((grapple == ae.getId()) &amp;&amp; (te.getGrappleSide() == Entity.GRAPPLE_BOTH)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-4, Messages.getString(&quot;WeaponAttackAction.Grappled&quot;));</b>
&nbsp;                // -2 bonus if grappling the target at range with a chain whip
<b class="nc">&nbsp;                } else if ((grapple == ae.getId()) &amp;&amp; (te.getGrappleSide() != Entity.GRAPPLE_BOTH)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.GrappledByChain&quot;));</b>
&nbsp;                // +1 penalty if firing at a target grappled by another unit. This does not apply to Swarm LRMs
<b class="nc">&nbsp;                } else if (!exchangeSwarmTarget) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.FireIntoMelee&quot;));</b>
&nbsp;                } else {
&nbsp;                    // this -1 cancels the original +1
<b class="nc">&nbsp;                    toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.FriendlyFire&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Special Equipment and Quirks that the target possesses
&nbsp;        
&nbsp;        // ECM suite generating Ghost Targets
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_GHOST_TARGET) &amp;&amp; !isIndirect</b>
&nbsp;                &amp;&amp; !isArtilleryIndirect &amp;&amp; !isArtilleryDirect) {
<b class="nc">&nbsp;            int ghostTargetMod = Compute.getGhostTargetNumber(ae, ae.getPosition(), target.getPosition());</b>
<b class="nc">&nbsp;            if ((ghostTargetMod &gt; -1) &amp;&amp; !((ae instanceof Infantry) &amp;&amp; !(ae instanceof BattleArmor))) {</b>
<b class="nc">&nbsp;                int bapMod = 0;</b>
<b class="nc">&nbsp;                if (ae.hasBAP()) {</b>
<b class="nc">&nbsp;                    bapMod = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                int tcMod = 0;</b>
<b class="nc">&nbsp;                if (ae.hasTargComp() &amp;&amp; wtype != null </b>
<b class="nc">&nbsp;                        &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE) &amp;&amp; !wtype.hasFlag(WeaponType.F_CWS)</b>
<b class="nc">&nbsp;                        &amp;&amp; !wtype.hasFlag(WeaponType.F_TASER) &amp;&amp; (atype != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (!usesAmmo || !(((atype.getAmmoType() == AmmoType.T_AC_LBX)</b>
<b class="nc">&nbsp;                                || (atype.getAmmoType() == AmmoType.T_AC_LBX_THB))</b>
&nbsp;                                &amp;&amp; (munition == AmmoType.M_CLUSTER)))) {
<b class="nc">&nbsp;                    tcMod = 2;</b>
&nbsp;                }
<b class="nc">&nbsp;                int ghostTargetMoF = (ae.getCrew().getSensorOps() + ghostTargetMod)</b>
<b class="nc">&nbsp;                        - (ae.getGhostTargetOverride() + bapMod + tcMod);</b>
<b class="nc">&nbsp;                if (ghostTargetMoF &gt; 1) {</b>
&nbsp;                    // according to this rules clarification the +4 max is on
&nbsp;                    // the PSR not on the to-hit roll
&nbsp;                    // http://www.classicbattletech.com/forums/index.php?topic=66036.0
&nbsp;                    // unofficial rule to cap the ghost target to-hit penalty
<b class="nc">&nbsp;                    int mod = ghostTargetMoF / 2;</b>
<b class="nc">&nbsp;                    if (game.getOptions().intOption(OptionsConstants.ADVANCED_GHOST_TARGET_MAX) &gt; 0) {</b>
<b class="nc">&nbsp;                        mod = Math.min(mod, game.getOptions().intOption(OptionsConstants.ADVANCED_GHOST_TARGET_MAX));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    toHit.addModifier(mod, Messages.getString(&quot;WeaponAttackAction.GhostTargets&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Movement and Position modifiers
&nbsp;        
&nbsp;        // target movement - ignore for pointblank shots from hidden units
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; !isPointBlankShot) {</b>
<b class="nc">&nbsp;            ToHitData thTemp = Compute.getTargetMovementModifier(game, target.getTargetId());</b>
<b class="nc">&nbsp;            toHit.append(thTemp);</b>
<b class="nc">&nbsp;            toSubtract += thTemp.getValue();</b>
&nbsp;
&nbsp;            // semiguided ammo negates this modifier, if TAG succeeded
<b class="nc">&nbsp;            if ((atype != null) &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) </b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MML)</b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_NLRM) </b>
<b class="nc">&nbsp;                    || (atype.getAmmoType() == AmmoType.T_MEK_MORTAR))</b>
<b class="nc">&nbsp;                    &amp;&amp; (munition == AmmoType.M_SEMIGUIDED) &amp;&amp; (te.getTaggedBy() != -1)) {</b>
<b class="nc">&nbsp;                int nAdjust = thTemp.getValue();</b>
<b class="nc">&nbsp;                if (nAdjust &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.append(new ToHitData(-nAdjust, Messages.getString(&quot;WeaponAttackAction.SemiGuidedTag&quot;)));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // precision ammo reduces this modifier
<b class="nc">&nbsp;            else if ((atype != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC) </b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_LAC)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_AC_IMP)</b>
<b class="nc">&nbsp;                            || (atype.getAmmoType() == AmmoType.T_PAC))</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_PRECISION)) {
<b class="nc">&nbsp;                int nAdjust = Math.min(2, thTemp.getValue());</b>
<b class="nc">&nbsp;                if (nAdjust &gt; 0) {</b>
<b class="nc">&nbsp;                    toHit.append(new ToHitData(-nAdjust, Messages.getString(&quot;WeaponAttackAction.Precision&quot;)));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Ground-to-air attacks against a target flying at NOE
<b class="nc">&nbsp;        if (Compute.isGroundToAir(ae, target) &amp;&amp; (null != te) &amp;&amp; te.isNOE()) {</b>
<b class="nc">&nbsp;            if (te.passedWithin(ae.getPosition(), 1)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.TeNoe&quot;));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.addModifier(+3, Messages.getString(&quot;WeaponAttackAction.TeNoe&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Ground-to-air attacks against a target flying at any other altitude (if StratOps Velocity mods are on)
<b class="nc">&nbsp;        if (Compute.isGroundToAir(ae, target)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_AA_FIRE) &amp;&amp; (null != te)</b>
<b class="nc">&nbsp;                &amp;&amp; (te.isAero())) {</b>
<b class="nc">&nbsp;            int vMod = ((IAero) te).getCurrentVelocity();</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AA_MOVE_MOD)) {</b>
<b class="nc">&nbsp;                vMod = Math.min(vMod / 2, 4);</b>
&nbsp;            }
<b class="nc">&nbsp;            toHit.addModifier(vMod, Messages.getString(&quot;WeaponAttackAction.TeVelocity&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // target immobile
<b class="nc">&nbsp;        boolean mekMortarMunitionsIgnoreImmobile = wtype != null &amp;&amp; wtype.hasFlag(WeaponType.F_MEK_MORTAR) </b>
&nbsp;                &amp;&amp; (atype != null) &amp;&amp; (munition == AmmoType.M_AIRBURST);
<b class="nc">&nbsp;        if (wtype != null &amp;&amp; !(wtype instanceof ArtilleryCannonWeapon) &amp;&amp; !mekMortarMunitionsIgnoreImmobile) {</b>
<b class="nc">&nbsp;            ToHitData immobileMod = Compute.getImmobileMod(target, aimingAt, aimingMode);</b>
&nbsp;            // grounded dropships are treated as immobile as well for purpose of
&nbsp;            // the mods
<b class="nc">&nbsp;            if ((null != te) &amp;&amp; !te.isAirborne() &amp;&amp; !te.isSpaceborne() &amp;&amp; (te instanceof Dropship)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((Aero) te).isSpheroid()) {</b>
<b class="nc">&nbsp;                immobileMod = new ToHitData(-4, Messages.getString(&quot;WeaponAttackAction.ImmobileDs&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (immobileMod != null) {</b>
<b class="nc">&nbsp;                toHit.append(immobileMod);</b>
<b class="nc">&nbsp;                toSubtract += immobileMod.getValue();</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Unit-specific modifiers
&nbsp;        
&nbsp;        // -1 to hit a SuperHeavy mech
<b class="nc">&nbsp;        if (te != null &amp;&amp; (te instanceof Mech) &amp;&amp; ((Mech) te).isSuperHeavy()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.TeSuperheavyMech&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Battle Armor targets are hard for Meks and Tanks to hit.
<b class="nc">&nbsp;        if (!isAttackerInfantry &amp;&amp; (te != null) &amp;&amp; (te instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.BaTarget&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // infantry squads are also hard to hit
<b class="nc">&nbsp;        if (te != null &amp;&amp; (te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor) &amp;&amp; ((Infantry) te).isSquad()) {</b>
<b class="nc">&nbsp;            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.SquadTarget&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        // Ejected MechWarriors are harder to hit
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; (te instanceof MechWarrior)) {</b>
<b class="nc">&nbsp;            toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.MwTarget&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Aerospace target modifiers
<b class="nc">&nbsp;        if (te != null &amp;&amp; te.isAero() &amp;&amp; te.isAirborne()) {</b>
<b class="nc">&nbsp;            IAero a = (IAero) te;</b>
&nbsp;
&nbsp;            // is the target at zero velocity
<b class="nc">&nbsp;            if ((a.getCurrentVelocity() == 0) &amp;&amp; !(a.isSpheroid() &amp;&amp; !game.getBoard().inSpace())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.ImmobileAero&quot;));</b>
&nbsp;            }
&nbsp;            
&nbsp;            // get mods for direction of attack
<b class="nc">&nbsp;            if (!(a.isSpheroid() &amp;&amp; !game.getBoard().inSpace())) {</b>
<b class="nc">&nbsp;                int side = Compute.targetSideTable(ae.getPosition(), te);</b>
&nbsp;                
&nbsp;                // +1 if shooting at an aero approaching nose-on
<b class="nc">&nbsp;                if (side == ToHitData.SIDE_FRONT) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.AeroNoseAttack&quot;));</b>
&nbsp;                }
&nbsp;                // +2 if shooting at the side as it flashes by
<b class="nc">&nbsp;                if ((side == ToHitData.SIDE_LEFT) || (side == ToHitData.SIDE_RIGHT)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.AeroSideAttack&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Target hidden in the sensor shadow of a larger spacecraft
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getBoard().inSpace()) {</b>
<b class="nc">&nbsp;                for (Entity en : Compute.getAdjacentEntitiesAlongAttack(ae.getPosition(), target.getPosition(), game)) {</b>
<b class="nc">&nbsp;                    if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() </b>
<b class="nc">&nbsp;                            &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -STRATOPS_SENSOR_SHADOW_WEIGHT_DIFF)) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.SensorShadow&quot;));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (Entity en : game.getEntitiesVector(target.getPosition())) {</b>
<b class="nc">&nbsp;                    if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) a)</b>
<b class="nc">&nbsp;                            &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -STRATOPS_SENSOR_SHADOW_WEIGHT_DIFF)) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.SensorShadow&quot;));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to the terrain and line of sight (LOS)
&nbsp;     * Woods along the LOS?  Target Underwater?  Partial cover? You&#39;ll find that here.
&nbsp;     * Also, if the to-hit table is changed due to cover/angle/elevation, look here.
&nbsp;     * -4 for shooting at an immobile target?  Using a weapon with a TH penalty?  Those are in other methods.
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param aElev An int value representing the attacker&#39;s elevation
&nbsp;     * @param tElev An int value representing the target&#39;s elevation
&nbsp;     * @param targEl An int value representing the target&#39;s relative elevation
&nbsp;     * @param distance  The distance in hexes from attacker to target
&nbsp;     * @param los The calculated LOS between attacker and target
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * @param losMods A cached set of LOS-related modifiers
&nbsp;     * @param toSubtract An int value representing a running total of mods to disregard - used for some special attacks
&nbsp;     * 
&nbsp;     * @param eistatus An int value representing the ei cockpit/pilot upgrade status
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param weaponId  The id number of the weapon being used - used by some external calculations 
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param inSameBuilding  flag that indicates whether this attack originates from within the same building
&nbsp;     * @param isIndirect  flag that indicates whether this is an indirect attack (LRM, mortar...)
&nbsp;     * @param isPointBlankShot  flag that indicates whether or not this is a PBS by a hidden unit
&nbsp;     * @param underWater  flag that indicates whether the weapon being used is underwater
&nbsp;     */
&nbsp;    private static ToHitData compileTerrainAndLosToHitMods(IGame game, Entity ae, Targetable target, int ttype, int aElev, int tElev,
&nbsp;                int targEl, int distance, LosEffects los, ToHitData toHit, ToHitData losMods, int toSubtract, int eistatus,
&nbsp;                WeaponType wtype, Mounted weapon, int weaponId, AmmoType atype, long munition, boolean isAttackerInfantry,
&nbsp;                boolean inSameBuilding, boolean isIndirect, boolean isPointBlankShot, boolean underWater) {
<b class="nc">&nbsp;        if (ae == null || target == null) {</b>
&nbsp;            // Can&#39;t handle these attacks without a valid attacker and target
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Target&#39;s hex
<b class="nc">&nbsp;        IHex targHex = game.getBoard().getHex(target.getPosition());</b>
&nbsp;        
<b class="nc">&nbsp;        boolean targetHexContainsWater = targHex != null &amp;&amp; targHex.containsTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;        boolean targetHexContainsFortified = targHex != null &amp;&amp; targHex.containsTerrain(Terrains.FORTIFIED);</b>
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some of these weapons only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Add range mods - If the attacker and target are in the same building
&nbsp;        // &amp; hex, range mods don&#39;t apply (and will cause the shot to fail)
&nbsp;        // Don&#39;t apply this to bomb attacks either, which are going to be at 0 range of necessity
<b class="nc">&nbsp;        if (((los.getThruBldg() == null) || !los.getTargetPosition().equals(ae.getPosition()))</b>
&nbsp;                &amp;&amp; (wtype != null 
<b class="nc">&nbsp;                    &amp;&amp; (!(wtype.hasFlag(WeaponType.F_ALT_BOMB) || wtype.hasFlag(WeaponType.F_DIVE_BOMB))))</b>
&nbsp;                &amp;&amp; weaponId &gt; WeaponType.WEAPON_NA) {
<b class="nc">&nbsp;            toHit.append(Compute.getRangeMods(game, ae, weaponId, target));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // add in LOS mods that we&#39;ve been keeping
<b class="nc">&nbsp;        toHit.append(losMods);</b>
&nbsp;        
&nbsp;        // Attacker Terrain
<b class="nc">&nbsp;        toHit.append(Compute.getAttackerTerrainModifier(game, ae.getId()));</b>
&nbsp;        
&nbsp;        // Target Terrain
&nbsp;        
&nbsp;        // BMM p. 31, semi-guided indirect missile attacks vs tagged targets ignore terrain modifiers
<b class="nc">&nbsp;        boolean semiGuidedIndirectVsTaggedTarget = isIndirect &amp;&amp; </b>
<b class="nc">&nbsp;                (atype != null) &amp;&amp; atype.getMunitionType() == AmmoType.M_SEMIGUIDED &amp;&amp; </b>
<b class="nc">&nbsp;                        Compute.isTargetTagged(target, game);</b>
&nbsp;        
&nbsp;        // Base terrain calculations, not applicable when delivering minefields or bombs
&nbsp;        // also not applicable in pointblank shots from hidden units
<b class="nc">&nbsp;        if ((ttype != Targetable.TYPE_MINEFIELD_DELIVER) &amp;&amp; !isPointBlankShot &amp;&amp; !semiGuidedIndirectVsTaggedTarget) {</b>
<b class="nc">&nbsp;            toHit.append(Compute.getTargetTerrainModifier(game, target, eistatus, inSameBuilding, underWater));</b>
<b class="nc">&nbsp;            toSubtract += Compute.getTargetTerrainModifier(game, target, eistatus, inSameBuilding, underWater)</b>
<b class="nc">&nbsp;                    .getValue();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Fortified/Dug-In Infantry
<b class="nc">&nbsp;        if ((target instanceof Infantry) &amp;&amp; wtype != null &amp;&amp; !wtype.hasFlag(WeaponType.F_FLAMER)) {</b>
<b class="nc">&nbsp;            if (targetHexContainsFortified</b>
<b class="nc">&nbsp;                    || (((Infantry) target).getDugIn() == Infantry.DUG_IN_COMPLETE)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.DugInInf&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // target in water?
<b class="nc">&nbsp;        int partialWaterLevel = 1;</b>
<b class="nc">&nbsp;        if (te != null &amp;&amp; (te instanceof Mech) &amp;&amp; ((Mech) te).isSuperHeavy()) {</b>
<b class="nc">&nbsp;            partialWaterLevel = 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((te != null) &amp;&amp; targetHexContainsWater</b>
&nbsp;                // target in partial water
<b class="nc">&nbsp;                &amp;&amp; (targHex.terrainLevel(Terrains.WATER) == partialWaterLevel) &amp;&amp; (targEl == 0) &amp;&amp; (te.height() &gt; 0)) { </b>
<b class="nc">&nbsp;            los.setTargetCover(los.getTargetCover() | LosEffects.COVER_HORIZONTAL);</b>
<b class="nc">&nbsp;            losMods = los.losModifiers(game, eistatus, underWater);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Change hit table for partial cover, accomodate for partial
&nbsp;        // underwater(legs)
<b class="nc">&nbsp;        if (los.getTargetCover() != LosEffects.COVER_NONE) {</b>
<b class="nc">&nbsp;            if (underWater &amp;&amp; (targetHexContainsWater &amp;&amp; (targEl == 0) </b>
<b class="nc">&nbsp;                    &amp;&amp; (te != null &amp;&amp; te.height() &gt; 0))) {</b>
&nbsp;                // weapon underwater, target in partial water
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_PARTIAL_COVER);</b>
<b class="nc">&nbsp;                toHit.setCover(LosEffects.COVER_UPPER);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PARTIAL_COVER)) {</b>
<b class="nc">&nbsp;                    toHit.setHitTable(ToHitData.HIT_PARTIAL_COVER);</b>
<b class="nc">&nbsp;                    toHit.setCover(los.getTargetCover());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.setHitTable(ToHitData.HIT_PARTIAL_COVER);</b>
<b class="nc">&nbsp;                    toHit.setCover(LosEffects.COVER_HORIZONTAL);</b>
&nbsp;                }
&nbsp;                // Set damagable cover state information
<b class="nc">&nbsp;                toHit.setDamagableCoverTypePrimary(los.getDamagableCoverTypePrimary());</b>
<b class="nc">&nbsp;                toHit.setCoverLocPrimary(los.getCoverLocPrimary());</b>
<b class="nc">&nbsp;                toHit.setCoverDropshipPrimary(los.getCoverDropshipPrimary());</b>
<b class="nc">&nbsp;                toHit.setCoverBuildingPrimary(los.getCoverBuildingPrimary());</b>
<b class="nc">&nbsp;                toHit.setDamagableCoverTypeSecondary(los.getDamagableCoverTypeSecondary());</b>
<b class="nc">&nbsp;                toHit.setCoverLocSecondary(los.getCoverLocSecondary());</b>
<b class="nc">&nbsp;                toHit.setCoverDropshipSecondary(los.getCoverDropshipSecondary());</b>
<b class="nc">&nbsp;                toHit.setCoverBuildingSecondary(los.getCoverBuildingSecondary());</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Special Equipment
&nbsp;        
&nbsp;        // if we have BAP and there are woods in the
&nbsp;        // way, and we are within BAP range, we reduce the BTH by 1
&nbsp;        // Per TacOps errata, this bonus also applies to all units on the same C3 network
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_BAP) &amp;&amp; !isIndirect &amp;&amp; (te != null)</b>
<b class="nc">&nbsp;                &amp;&amp; ae.hasBAP() &amp;&amp; (ae.getBAPRange() &gt;= Compute.effectiveDistance(game, ae, te))</b>
<b class="nc">&nbsp;                &amp;&amp; !ComputeECM.isAffectedByECM(ae, ae.getPosition(), te.getPosition())</b>
<b class="nc">&nbsp;                &amp;&amp; (game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                        || game.getBoard().getHex(te.getPosition()).containsTerrain(Terrains.JUNGLE)</b>
<b class="nc">&nbsp;                        || (los.getLightWoods() &gt; 0) || (los.getHeavyWoods() &gt; 0) || (los.getUltraWoods() &gt; 0))</b>
<b class="nc">&nbsp;                || ae.hasNetworkBAP()) {</b>
<b class="nc">&nbsp;            if (ae.hasBAP()) {</b>
&nbsp;                // If you want the bonus, the entity with the BAP should fire first. 
&nbsp;                // Not sure how to get around this
<b class="nc">&nbsp;                for (Entity en : game.getC3NetworkMembers(ae)) {</b>
<b class="nc">&nbsp;                    en.setNetworkBAP(true);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.BAPInWoods&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // To-hit table changes with no to-hit modifiers
&nbsp;        
&nbsp;        // Aeros in air-to-air combat can hit above and below
<b class="nc">&nbsp;        if (Compute.isAirToAir(ae, target)) {</b>
<b class="nc">&nbsp;            if ((ae.getAltitude() - target.getAltitude()) &gt; 2) {</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_ABOVE);</b>
<b class="nc">&nbsp;            } else if ((target.getAltitude() - ae.getAltitude()) &gt; 2) {</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_BELOW);</b>
<b class="nc">&nbsp;            } else if (((ae.getAltitude() - target.getAltitude()) &gt; 0) </b>
<b class="nc">&nbsp;                    &amp;&amp; te != null &amp;&amp; (te.isAero() &amp;&amp; ((IAero) te).isSpheroid())) {</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_ABOVE);</b>
<b class="nc">&nbsp;            } else if (((ae.getAltitude() - target.getAltitude()) &lt; 0) </b>
<b class="nc">&nbsp;                    &amp;&amp; te != null &amp;&amp; (te.isAero() &amp;&amp; ((IAero) te).isSpheroid())) {</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_BELOW);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Change hit table for elevation differences inside building.
<b class="nc">&nbsp;        if ((null != los.getThruBldg()) &amp;&amp; (aElev != tElev)) {</b>
&nbsp;
&nbsp;            // Tanks get hit in a random side.
<b class="nc">&nbsp;            if (target instanceof Tank) {</b>
<b class="nc">&nbsp;                toHit.setSideTable(ToHitData.SIDE_RANDOM);</b>
<b class="nc">&nbsp;            } else if (target instanceof Mech) {</b>
&nbsp;                // Meks have special tables for shots from above and below.
<b class="nc">&nbsp;                if (aElev &gt; tElev) {</b>
<b class="nc">&nbsp;                    toHit.setHitTable(ToHitData.HIT_ABOVE);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit.setHitTable(ToHitData.HIT_BELOW);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Ground-to-air attacks always hit from below
<b class="nc">&nbsp;        if (Compute.isGroundToAir(ae, target) &amp;&amp; ((ae.getAltitude() - target.getAltitude()) &gt; 2)) {</b>
<b class="nc">&nbsp;            toHit.setHitTable(ToHitData.HIT_BELOW);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // factor in target side
<b class="nc">&nbsp;        if (isAttackerInfantry &amp;&amp; (0 == distance)) {</b>
&nbsp;            // Infantry attacks from the same hex are resolved against the
&nbsp;            // front.
<b class="nc">&nbsp;            toHit.setSideTable(ToHitData.SIDE_FRONT);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (weapon != null) {</b>
<b class="nc">&nbsp;                toHit.setSideTable(Compute.targetSideTable(ae, target, weapon.getCalledShot().getCall()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // Change hit table for surface naval vessels hit by underwater attacks
<b class="nc">&nbsp;        if (underWater &amp;&amp; targetHexContainsWater &amp;&amp; (null != te) &amp;&amp; te.isSurfaceNaval()) {</b>
<b class="nc">&nbsp;            toHit.setHitTable(ToHitData.HIT_UNDERWATER);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * If you&#39;re using a weapon that does something totally special and doesn&#39;t apply mods like everything else, look here
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param los The calculated LOS between attacker and target
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param srt  Class that stores whether or not this WAA should return a special resolution
&nbsp;     */
&nbsp;    private static ToHitData handleSpecialWeaponAttacks(IGame game, Entity ae, Targetable target, int ttype,
&nbsp;                LosEffects los, ToHitData toHit, WeaponType wtype, AmmoType atype, SpecialResolutionTracker srt) {
<b class="nc">&nbsp;        if (ae == null) {</b>
&nbsp;            //*Should* be impossible at this point in the process
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Some of these weapons only target valid entities
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Battle Armor bomb racks (Micro bombs) use gunnery skill and no other mods per TWp228 2018 errata
<b class="nc">&nbsp;        if ((atype != null) &amp;&amp; (atype.getAmmoType() == AmmoType.T_BA_MICRO_BOMB)) {</b>
<b class="nc">&nbsp;            if (ae.getPosition().equals(target.getPosition())) {</b>
<b class="nc">&nbsp;                toHit = new ToHitData(ae.getCrew().getPiloting(), Messages.getString(&quot;WeaponAttackAction.GunSkill&quot;));</b>
&nbsp;            } else { 
<b class="nc">&nbsp;                toHit = new ToHitData(TargetRoll.IMPOSSIBLE, Messages.getString(&quot;WeaponAttackAction.OutOfRange&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Engineer&#39;s fire extinguisher has fixed to hit number,
&nbsp;        // Note that coolant trucks make a regular attack.
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_EXTINGUISHER)) {</b>
<b class="nc">&nbsp;            toHit = new ToHitData(8, Messages.getString(&quot;WeaponAttackAction.FireExt&quot;));</b>
<b class="nc">&nbsp;            if (((target instanceof Entity) &amp;&amp; ((Entity) target).infernos.isStillBurning())</b>
<b class="nc">&nbsp;                    || ((target instanceof Tank) &amp;&amp; ((Tank) target).isInfernoFire())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.PutOutInferno&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((target.getTargetType() == Targetable.TYPE_HEX_EXTINGUISH)</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getBoard().isInfernoBurning(target.getPosition())) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.PutOutInferno&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // if this is a space bombing attack then get the to hit and return
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_SPACE_BOMB)) {</b>
<b class="nc">&nbsp;            if (te != null) {</b>
<b class="nc">&nbsp;                toHit = Compute.getSpaceBombBaseToHit(ae, te, game);</b>
<b class="nc">&nbsp;                srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;                return toHit;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        //If we get here, no special weapons apply. Return the input data and continue on
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to infantry/BA swarm attacks
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param srt  Class that stores whether or not this WAA should return a special resolution
&nbsp;     */
&nbsp;    private static ToHitData handleInfantrySwarmAttacks(IGame game, Entity ae, Targetable target,
&nbsp;                int ttype, ToHitData toHit, WeaponType wtype, SpecialResolutionTracker srt)  {
<b class="nc">&nbsp;        if (ae == null) {</b>
&nbsp;            //*Should* be impossible at this point in the process
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (target == null || ttype != Targetable.TYPE_ENTITY) {</b>
&nbsp;            //Can only swarm a valid entity target
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Entity te = (Entity) target;</b>
&nbsp;        // Leg attacks and Swarm attacks have their own base toHit values
<b class="nc">&nbsp;        if (Infantry.LEG_ATTACK.equals(wtype.getInternalName())) {</b>
<b class="nc">&nbsp;            toHit = Compute.getLegAttackBaseToHit(ae, te, game);</b>
<b class="nc">&nbsp;            if ((te instanceof Mech) &amp;&amp; ((Mech) te).isSuperHeavy()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.TeSuperheavyMech&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;
<b class="nc">&nbsp;        } else if (Infantry.SWARM_MEK.equals(wtype.getInternalName())) {</b>
<b class="nc">&nbsp;            toHit = Compute.getSwarmMekBaseToHit(ae, te, game);</b>
<b class="nc">&nbsp;            if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;                return toHit;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (te instanceof Tank) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.TeVehicle&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((te instanceof Mech) &amp;&amp; ((Mech) te).isSuperHeavy()) {</b>
<b class="nc">&nbsp;                toHit.addModifier(-1, Messages.getString(&quot;WeaponAttackAction.TeSuperheavyMech&quot;));</b>
&nbsp;            }
&nbsp;
&nbsp;            // If the defender carries mechanized BA, they can fight off the
&nbsp;            // swarm
<b class="nc">&nbsp;            for (Entity e : te.getExternalUnits()) {</b>
<b class="nc">&nbsp;                if (e instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                    BattleArmor ba = (BattleArmor) e;</b>
<b class="nc">&nbsp;                    int def = ba.getShootingStrength();</b>
<b class="nc">&nbsp;                    int att = ((Infantry) ae).getShootingStrength();</b>
<b class="nc">&nbsp;                    if (!(ae instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;                        if (att &gt;= 28) {</b>
<b class="nc">&nbsp;                            att = 5;</b>
<b class="nc">&nbsp;                        } else if (att &gt;= 24) {</b>
<b class="nc">&nbsp;                            att = 4;</b>
<b class="nc">&nbsp;                        } else if (att &gt;= 21) {</b>
<b class="nc">&nbsp;                            att = 3;</b>
<b class="nc">&nbsp;                        } else if (att &gt;= 18) {</b>
<b class="nc">&nbsp;                            att = 2;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            att = 1;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    def = (def + 2) - att;</b>
<b class="nc">&nbsp;                    if (def &gt; 0) {</b>
<b class="nc">&nbsp;                        toHit.addModifier(def, Messages.getString(&quot;WeaponAttackAction.DefendingBA&quot;));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return toHit;</b>
<b class="nc">&nbsp;        } else if (Infantry.STOP_SWARM.equals(wtype.getInternalName())) {</b>
&nbsp;            // Can&#39;t stop if we&#39;re not swarming, otherwise automatic.
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, Messages.getString(&quot;WeaponAttackAction.EndSwarm&quot;));</b>
&nbsp;        }
&nbsp;        // Swarming infantry always hit their target, but
&nbsp;        // they can only target the Mek they&#39;re swarming.
<b class="nc">&nbsp;        else if ((ae.getSwarmTargetId() == te.getId())) {</b>
<b class="nc">&nbsp;            int side = te instanceof Tank ? ToHitData.SIDE_RANDOM : ToHitData.SIDE_FRONT;</b>
<b class="nc">&nbsp;            if (ae instanceof BattleArmor) {</b>
<b class="nc">&nbsp;                if (!Infantry.SWARM_WEAPON_MEK.equals(wtype.getInternalName()) &amp;&amp; !(wtype instanceof InfantryAttack)) {</b>
<b class="nc">&nbsp;                    srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;                    return new ToHitData(TargetRoll.IMPOSSIBLE, Messages.getString(&quot;WeaponAttackAction.WrongSwarmUse&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, Messages.getString(&quot;WeaponAttackAction.SwarmingAutoHit&quot;), ToHitData.HIT_SWARM,</b>
&nbsp;                        side);
&nbsp;            }
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, Messages.getString(&quot;WeaponAttackAction.SwarmingAutoHit&quot;), ToHitData.HIT_SWARM_CONVENTIONAL, side);</b>
&nbsp;        }
&nbsp;        //If we get here, no swarm attack applies
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method to handle modifiers for swarm missile secondary targets
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param swarmPrimaryTarget The original Targetable object being attacked
&nbsp;     * @param swarmSecondaryTarget The current Targetable object being attacked
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * @param toSubtract An int value representing a running total of mods to disregard
&nbsp;     * 
&nbsp;     * @param eistatus An int value representing the ei cockpit/pilot upgrade status - used for terrain calculation
&nbsp;     * @param aimingAt  An int value representing the location being aimed at - used for immobile target
&nbsp;     * @param aimingMode  An int value that determines the reason aiming is allowed - used for immobile target
&nbsp;     * 
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * @param munition  Long indicating the munition type flag being used, if applicable
&nbsp;     * 
&nbsp;     * @param isECMAffected flag that indicates whether the target is inside an ECM bubble
&nbsp;     * @param inSameBuilding  flag that indicates whether this attack originates from within the same building
&nbsp;     * @param underWater  flag that indicates whether the weapon being used is underwater
&nbsp;     */
&nbsp;    private static ToHitData handleSwarmSecondaryAttacks(IGame game, Entity ae, Targetable target,
&nbsp;                Targetable swarmPrimaryTarget, Targetable swarmSecondaryTarget, ToHitData toHit,
&nbsp;                int toSubtract, int eistatus, int aimingAt, int aimingMode, Mounted weapon, AmmoType atype,
&nbsp;                long munition, boolean isECMAffected, boolean inSameBuilding, boolean underWater) {
&nbsp;        
<b class="nc">&nbsp;        if (ae == null || swarmPrimaryTarget == null || swarmSecondaryTarget == null) {</b>
&nbsp;            // This method won&#39;t work without these 3 things
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        toHit.addModifier(-toSubtract, Messages.getString(&quot;WeaponAttackAction.OriginalTargetMods&quot;));</b>
<b class="nc">&nbsp;        toHit.append(Compute.getImmobileMod(swarmSecondaryTarget, aimingAt, aimingMode));</b>
<b class="nc">&nbsp;        toHit.append(Compute.getTargetTerrainModifier(game,</b>
<b class="nc">&nbsp;                game.getTarget(swarmSecondaryTarget.getTargetType(), swarmSecondaryTarget.getTargetId()), eistatus,</b>
&nbsp;                inSameBuilding, underWater));
<b class="nc">&nbsp;        toHit.setCover(LosEffects.COVER_NONE);</b>
&nbsp;        
<b class="nc">&nbsp;        IHex targHex = game.getBoard().getHex(swarmSecondaryTarget.getPosition());</b>
<b class="nc">&nbsp;        int targEl = swarmSecondaryTarget.relHeight();</b>
<b class="nc">&nbsp;        int distance = Compute.effectiveDistance(game, ae, swarmSecondaryTarget);</b>
&nbsp;        
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (swarmSecondaryTarget.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;
&nbsp;        // We might not attack the new target from the same side as the
&nbsp;        // old, so recalculate; the attack *direction* is still traced from
&nbsp;        // the original source.
<b class="nc">&nbsp;        toHit.setSideTable(Compute.targetSideTable(ae, swarmSecondaryTarget));</b>
&nbsp;
&nbsp;        // Secondary swarm LRM attacks are never called shots even if the
&nbsp;        // initial one was.
<b class="nc">&nbsp;        if (weapon != null &amp;&amp; weapon.getCalledShot().getCall() != CalledShot.CALLED_NONE) {</b>
<b class="nc">&nbsp;            weapon.getCalledShot().reset();</b>
<b class="nc">&nbsp;            toHit.setHitTable(ToHitData.HIT_NORMAL);</b>
&nbsp;        }
&nbsp;
&nbsp;        LosEffects swarmlos;
&nbsp;        // TO makes it seem like the terrain modifers should be between the
&nbsp;        // attacker and the secondary target, but we have received rules
&nbsp;        // clarifications on the old forums indicating that this is correct
<b class="nc">&nbsp;        if (swarmPrimaryTarget.getTargetType() != Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            swarmlos = LosEffects.calculateLos(game, swarmSecondaryTarget.getTargetId(), target);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            swarmlos = LosEffects.calculateLos(game, swarmPrimaryTarget.getTargetId(), swarmSecondaryTarget);</b>
&nbsp;        }
&nbsp;
&nbsp;        // reset cover
<b class="nc">&nbsp;        if (swarmlos.getTargetCover() != LosEffects.COVER_NONE) {</b>
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PARTIAL_COVER)) {</b>
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_PARTIAL_COVER);</b>
<b class="nc">&nbsp;                toHit.setCover(swarmlos.getTargetCover());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                toHit.setHitTable(ToHitData.HIT_PARTIAL_COVER);</b>
<b class="nc">&nbsp;                toHit.setCover(LosEffects.COVER_HORIZONTAL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // target in water?
<b class="nc">&nbsp;        if (swarmSecondaryTarget.getTargetType() == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            Entity oldEnt = game.getEntity(swarmSecondaryTarget.getTargetId());</b>
<b class="nc">&nbsp;            toHit.append(Compute.getTargetMovementModifier(game, oldEnt.getId()));</b>
&nbsp;            // target in partial water - depth 1 for most units
<b class="nc">&nbsp;            int partialWaterLevel = 1;</b>
&nbsp;            // Depth 2 for superheavy mechs
<b class="nc">&nbsp;            if (te != null &amp;&amp; (te instanceof Mech) &amp;&amp; ((Mech) te).isSuperHeavy()) {</b>
<b class="nc">&nbsp;                partialWaterLevel = 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (targHex.containsTerrain(Terrains.WATER)</b>
<b class="nc">&nbsp;                    &amp;&amp; (targHex.terrainLevel(Terrains.WATER) == partialWaterLevel) &amp;&amp; (targEl == 0)</b>
<b class="nc">&nbsp;                    &amp;&amp; (oldEnt.height() &gt; 0)) {</b>
<b class="nc">&nbsp;                toHit.setCover(toHit.getCover() | LosEffects.COVER_HORIZONTAL);</b>
&nbsp;            }
&nbsp;            // Prone
<b class="nc">&nbsp;            ToHitData proneMod = new ToHitData();</b>
<b class="nc">&nbsp;            if (oldEnt.isProne()) {</b>
&nbsp;                // easier when point-blank
<b class="nc">&nbsp;                if (distance &lt;= 1) {</b>
<b class="nc">&nbsp;                    proneMod = new ToHitData(-2, Messages.getString(&quot;WeaponAttackAction.ProneAdj&quot;));</b>
&nbsp;                } else {
&nbsp;                    // Harder at range.
<b class="nc">&nbsp;                    proneMod = new ToHitData(1, Messages.getString(&quot;WeaponAttackAction.ProneRange&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // I-Swarm bonus
<b class="nc">&nbsp;            toHit.append(proneMod);</b>
<b class="nc">&nbsp;            if (!isECMAffected &amp;&amp; (atype != null) &amp;&amp; !oldEnt.isEnemyOf(ae)</b>
<b class="nc">&nbsp;                    &amp;&amp; !(oldEnt.getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_SENSORS, Mech.LOC_HEAD) &gt; 0)</b>
&nbsp;                    &amp;&amp; (munition == AmmoType.M_SWARM_I)) {
<b class="nc">&nbsp;                toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.SwarmIFriendly&quot;));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that compiles the ToHit modifiers applicable to artillery attacks
&nbsp;     * 
&nbsp;     * @param game The current game
&nbsp;     * @param ae The Entity making this attack
&nbsp;     * @param target The Targetable object being attacked
&nbsp;     * @param ttype  The targetable object type
&nbsp;     * @param toHit The running total ToHitData for this WeaponAttackAction
&nbsp;     * 
&nbsp;     * @param wtype The WeaponType of the weapon being used
&nbsp;     * @param weapon The Mounted weapon being used
&nbsp;     * @param atype The AmmoType being used for this attack
&nbsp;     * 
&nbsp;     * @param isArtilleryDirect  flag that indicates whether this is a direct-fire artillery attack
&nbsp;     * @param isArtilleryFLAK   flag that indicates whether this is a flak artillery attack
&nbsp;     * @param isArtilleryIndirect  flag that indicates whether this is an indirect-fire artillery attack
&nbsp;     * @param isHoming flag that indicates whether this is a homing missile/copperhead shot
&nbsp;     * @param usesAmmo  flag that indicates if the WeaponType being used is ammo-fed
&nbsp;     * @param srt  Class that stores whether or not this WAA should return a special resolution
&nbsp;     */
&nbsp;    private static ToHitData handleArtilleryAttacks(IGame game, Entity ae, Targetable target, int ttype, 
&nbsp;                ToHitData losMods, ToHitData toHit, WeaponType wtype, Mounted weapon, AmmoType atype, 
&nbsp;                boolean isArtilleryDirect, boolean isArtilleryFLAK, boolean isArtilleryIndirect, boolean isHoming,
&nbsp;                boolean usesAmmo, SpecialResolutionTracker srt) {
<b class="nc">&nbsp;        Entity te = null;</b>
<b class="nc">&nbsp;        if (ttype == Targetable.TYPE_ENTITY) {</b>
<b class="nc">&nbsp;            te = (Entity) target;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (toHit == null) {</b>
&nbsp;            // Without valid toHit data, the rest of this will fail
<b class="nc">&nbsp;            toHit = new ToHitData();</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Homing warheads just need a flat 4 to seek out a successful TAG
<b class="nc">&nbsp;        if (isHoming) {  </b>
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return new ToHitData(4, Messages.getString(&quot;WeaponAttackAction.HomingArty&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        //Don&#39;t bother adding up modifiers if the target hex has been hit before
<b class="nc">&nbsp;        if (game.getEntity(ae.getId()).getOwner().getArtyAutoHitHexes().contains(target.getPosition())</b>
&nbsp;                &amp;&amp; !isArtilleryFLAK) {
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return new ToHitData(TargetRoll.AUTOMATIC_SUCCESS, Messages.getString(&quot;WeaponAttackAction.ArtyDesTarget&quot;));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Handle direct artillery attacks.
<b class="nc">&nbsp;        if (isArtilleryDirect) {</b>
&nbsp;            //If an airborne unit occupies the target hex, standard artillery ammo makes a flak attack against it
&nbsp;            //TN is a flat 3 + the altitude mod + the attacker&#39;s weapon skill
<b class="nc">&nbsp;            if (isArtilleryFLAK &amp;&amp; te != null) {</b>
<b class="nc">&nbsp;                toHit.addModifier(3, Messages.getString(&quot;WeaponAttackAction.ArtyFlak&quot;));</b>
<b class="nc">&nbsp;                if (te.isAirborne()) {</b>
<b class="nc">&nbsp;                    if (te.getAltitude() &gt; 3) {</b>
<b class="nc">&nbsp;                        if (te.getAltitude() &gt; 9) {</b>
<b class="nc">&nbsp;                            toHit.addModifier(3, Messages.getString(&quot;WeaponAttackAction.AeroTeAlt10&quot;));</b>
<b class="nc">&nbsp;                        } else if (te.getAltitude() &gt; 6) {</b>
<b class="nc">&nbsp;                            toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.AeroTeAlt79&quot;));</b>
<b class="nc">&nbsp;                        } else if (te.getAltitude() &gt; 3) {</b>
<b class="nc">&nbsp;                            toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.AeroTeAlt46&quot;));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;                return toHit;</b>
&nbsp;            } else {
&nbsp;                //All other direct fire artillery attacks
<b class="nc">&nbsp;                toHit.addModifier(4, Messages.getString(&quot;WeaponAttackAction.DirectArty&quot;));</b>
<b class="nc">&nbsp;                toHit.append(Compute.getAttackerMovementModifier(game, ae.getId()));</b>
<b class="nc">&nbsp;                toHit.append(losMods);</b>
<b class="nc">&nbsp;                toHit.append(Compute.getSecondaryTargetMod(game, ae, target));</b>
&nbsp;                // actuator &amp; sensor damage to attacker
<b class="nc">&nbsp;                if (weapon != null) {</b>
<b class="nc">&nbsp;                    toHit.append(Compute.getDamageWeaponMods(ae, weapon));</b>
&nbsp;                }
&nbsp;                // heat
<b class="nc">&nbsp;                if (ae.getHeatFiringModifier() != 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(ae.getHeatFiringModifier(), Messages.getString(&quot;WeaponAttackAction.Heat&quot;));</b>
&nbsp;                }
&nbsp;                // weapon to-hit modifier
<b class="nc">&nbsp;                if (wtype.getToHitModifier() != 0) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(wtype.getToHitModifier(), Messages.getString(&quot;WeaponAttackAction.WeaponMod&quot;));</b>
&nbsp;                }
&nbsp;                // ammo to-hit modifier
<b class="nc">&nbsp;                if (usesAmmo &amp;&amp; (atype != null) &amp;&amp; (atype.getToHitModifier() != 0)) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(atype.getToHitModifier(),</b>
<b class="nc">&nbsp;                            atype.getSubMunitionName()</b>
<b class="nc">&nbsp;                                    + Messages.getString(&quot;WeaponAttackAction.AmmoMod&quot;));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        //And now for indirect artillery fire
<b class="nc">&nbsp;        if (isArtilleryIndirect) {</b>
<b class="nc">&nbsp;            int mod = 7;</b>
<b class="nc">&nbsp;            if (ae.hasAbility(OptionsConstants.GUNNERY_OBLIQUE_ATTACKER)) {</b>
<b class="nc">&nbsp;                mod--;</b>
&nbsp;            }
<b class="nc">&nbsp;            toHit.addModifier(mod, Messages.getString(&quot;WeaponAttackAction.IndirectArty&quot;));</b>
<b class="nc">&nbsp;            int adjust = 0;</b>
<b class="nc">&nbsp;            if (weapon != null) {        </b>
<b class="nc">&nbsp;                adjust = ae.aTracker.getModifier(weapon, target.getPosition());</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean spotterIsForwardObserver = ae.aTracker.getSpotterHasForwardObs();</b>
<b class="nc">&nbsp;            if (adjust == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;                return new ToHitData(TargetRoll.AUTOMATIC_SUCCESS,</b>
&nbsp;                        &quot;Artillery firing at target that&#39;s been hit before.&quot;);
<b class="nc">&nbsp;            } else if (adjust != 0) {</b>
<b class="nc">&nbsp;                toHit.addModifier(adjust, Messages.getString(&quot;WeaponAttackAction.AdjustedFire&quot;));</b>
<b class="nc">&nbsp;                if (spotterIsForwardObserver) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(-2, Messages.getString(&quot;WeaponAttackAction.FooSpotter&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Capital missiles used for surface to surface artillery attacks
&nbsp;            // See SO p110
&nbsp;            // Start with a flat +2 modifier
<b class="nc">&nbsp;            if (wtype instanceof CapitalMissileWeapon</b>
<b class="nc">&nbsp;                    &amp;&amp; Compute.isGroundToGround(ae, target)) {</b>
<b class="nc">&nbsp;                toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.SubCapArtillery&quot;));</b>
&nbsp;                // +3 additional modifier if fired underwater
<b class="nc">&nbsp;                if (ae.isUnderwater()) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(3, Messages.getString(&quot;WeaponAttackAction.SubCapUnderwater&quot;));</b>
&nbsp;                }
&nbsp;                // +1 modifier if attacker cruised/walked
<b class="nc">&nbsp;                if (ae.moved == EntityMovementType.MOVE_WALK) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(1, Messages.getString(&quot;WeaponAttackAction.Walked&quot;));</b>
<b class="nc">&nbsp;                } else if (ae.moved == EntityMovementType.MOVE_RUN) {</b>
&nbsp;                    // +2 modifier if attacker ran
<b class="nc">&nbsp;                    toHit.addModifier(2, Messages.getString(&quot;WeaponAttackAction.Ran&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (ae.isAirborne()) {</b>
<b class="nc">&nbsp;                if (ae.getAltitude() &gt; 6) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+2, Messages.getString(&quot;WeaponAttackAction.Altitude&quot;));</b>
<b class="nc">&nbsp;                } else if (ae.getAltitude() &gt; 3) {</b>
<b class="nc">&nbsp;                    toHit.addModifier(+1, Messages.getString(&quot;WeaponAttackAction.Altitude&quot;));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            srt.setSpecialResolution(true);</b>
<b class="nc">&nbsp;            return toHit;</b>
&nbsp;        }
&nbsp;        //If we get here, this isn&#39;t an artillery attack
<b class="nc">&nbsp;        return toHit;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
