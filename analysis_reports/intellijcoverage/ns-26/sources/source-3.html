


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > BoardUtilities</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common.util</a>
</div>

<h1>Coverage Summary for Class: BoardUtilities (megamek.common.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BoardUtilities</td>
<td class="coverageStat">
  <span class="percent">
    5.4%
  </span>
  <span class="absValue">
    (2/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.4%
  </span>
  <span class="absValue">
    (12/837)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BoardUtilities$Point</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    5%
  </span>
  <span class="absValue">
    (2/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.4%
  </span>
  <span class="absValue">
    (12/845)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;* MegaMek -
&nbsp;* Copyright (C) 2005 Ben Mazur (bmazur@sev.org)
&nbsp;* Copyright (C) 2018 The MegaMek Team
&nbsp;*
&nbsp;* This program is free software; you can redistribute it and/or modify it under
&nbsp;* the terms of the GNU General Public License as published by the Free Software
&nbsp;* Foundation; either version 2 of the License, or (at your option) any later
&nbsp;* version.
&nbsp;*
&nbsp;* This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp;* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
&nbsp;* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
&nbsp;* details.
&nbsp;*/
&nbsp;
&nbsp;package megamek.common.util;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.ListIterator;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;import megamek.client.bot.princess.CardinalEdge;
&nbsp;import megamek.common.Board;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.Hex;
&nbsp;import megamek.common.IBoard;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.ITerrain;
&nbsp;import megamek.common.ITerrainFactory;
&nbsp;import megamek.common.MapSettings;
&nbsp;import megamek.common.OffBoardDirection;
&nbsp;import megamek.common.PlanetaryConditions;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.util.generator.ElevationGenerator;
&nbsp;import megamek.common.util.generator.SimplexGenerator;
&nbsp;
<b class="nc">&nbsp;public class BoardUtilities {</b>
<b class="fc">&nbsp;    private static List&lt;ElevationGenerator&gt; elevationGenerators = new ArrayList&lt;ElevationGenerator&gt;();</b>
&nbsp;    static {
&nbsp;        // TODO: make this externally accessible via registerElevationGenerator()
<b class="fc">&nbsp;        elevationGenerators.add(new SimplexGenerator());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** @return how many elevation generator algorithms there are; three built-in */
&nbsp;    public static int getAmountElevationGenerators() {
<b class="nc">&nbsp;        return 3 + elevationGenerators.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Combines one or more boards into one huge megaboard!
&nbsp;     *
&nbsp;     * @param width the width of each individual board, before the combine
&nbsp;     * @param height the height of each individual board, before the combine
&nbsp;     * @param sheetWidth how many sheets wide the combined map is
&nbsp;     * @param sheetHeight how many sheets tall the combined map is
&nbsp;     * @param boards an array of the boards to be combined
&nbsp;     * @param isRotated Flag that determines if any of the maps are rotated
&nbsp;     * @param medium Sets the medium the map is in (ie., ground, atmo, space)
&nbsp;     */
&nbsp;    public static IBoard combine(int width, int height, int sheetWidth,
&nbsp;            int sheetHeight, IBoard[] boards, List&lt;Boolean&gt; isRotated,
&nbsp;            int medium) {
&nbsp;
<b class="nc">&nbsp;        int resultWidth = width * sheetWidth;</b>
<b class="nc">&nbsp;        int resultHeight = height * sheetHeight;</b>
&nbsp;
<b class="nc">&nbsp;        IHex[] resultData = new IHex[resultWidth * resultHeight];</b>
<b class="nc">&nbsp;        boolean roadsAutoExit = true;</b>
<b class="nc">&nbsp;        boolean boardListContainsBackground = false;</b>
&nbsp;        // Copy the data from the sub-boards.
<b class="nc">&nbsp;        for (int i = 0; i &lt; sheetHeight; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; sheetWidth; j++) {</b>
<b class="nc">&nbsp;                IBoard b = boards[i * sheetWidth + j];</b>
<b class="nc">&nbsp;                if ((b.getWidth() != width) || (b.getHeight() != height)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(</b>
&nbsp;                            &quot;board is the wrong size, expected &quot; + width + &quot;x&quot;
<b class="nc">&nbsp;                                    + height + &quot;, got &quot; + b.getWidth() + &quot;x&quot;</b>
<b class="nc">&nbsp;                                    + b.getHeight());</b>
&nbsp;                }
<b class="nc">&nbsp;                copyBoardInto(resultData, resultWidth, j * width, i * height,</b>
&nbsp;                        boards[i * sheetWidth + j]);
&nbsp;                // Copy in the other board&#39;s options.
<b class="nc">&nbsp;                if (boards[i * sheetWidth + j].getRoadsAutoExit() == false) {</b>
<b class="nc">&nbsp;                    roadsAutoExit = false;</b>
&nbsp;                }
<b class="nc">&nbsp;                boardListContainsBackground |= b.hasBoardBackground();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IBoard result = new Board();</b>
<b class="nc">&nbsp;        result.setRoadsAutoExit(roadsAutoExit);</b>
&nbsp;        // Initialize all hexes - buildings, exits, etc
<b class="nc">&nbsp;        result.newData(resultWidth, resultHeight, resultData, null);</b>
<b class="nc">&nbsp;        if (boardListContainsBackground) {</b>
<b class="nc">&nbsp;            result.setNumBoardsHeight(sheetHeight);</b>
<b class="nc">&nbsp;            result.setNumBoardsWidth(sheetWidth);</b>
<b class="nc">&nbsp;            result.setSubBoardHeight(height);</b>
<b class="nc">&nbsp;            result.setSubBoardWidth(width);</b>
<b class="nc">&nbsp;            ListIterator&lt;Boolean&gt; flipIt = isRotated.listIterator();</b>
<b class="nc">&nbsp;            for (IBoard b : boards) {</b>
<b class="nc">&nbsp;                boolean flip = flipIt.next();</b>
<b class="nc">&nbsp;                result.addBackgroundPath(b.getBackgroundPath(), flip, flip);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //assuming that the map setting and board types match
<b class="nc">&nbsp;        result.setType(medium);</b>
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies the data of another board into given array of Hexes, offset by the
&nbsp;     * specified x and y.
&nbsp;     */
&nbsp;    protected static void copyBoardInto(IHex[] dest, int destWidth, int x,
&nbsp;            int y, IBoard copied) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; copied.getHeight(); i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; copied.getWidth(); j++) {</b>
<b class="nc">&nbsp;                dest[(i + y) * destWidth + j + x] = copied.getHex(j, i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a Random Board
&nbsp;     *
&nbsp;     * @param mapSettings The parameters for random board creation.
&nbsp;     */
&nbsp;    public static IBoard generateRandom(MapSettings mapSettings) {
<b class="nc">&nbsp;        int elevationMap[][] = new int[mapSettings.getBoardWidth()][mapSettings</b>
<b class="nc">&nbsp;                .getBoardHeight()];</b>
<b class="nc">&nbsp;        double sizeScale = (double) (mapSettings.getBoardWidth() * mapSettings</b>
<b class="nc">&nbsp;                .getBoardHeight())</b>
&nbsp;                / ((double) (16 * 17));
&nbsp;
<b class="nc">&nbsp;        generateElevation(mapSettings.getHilliness(), mapSettings</b>
<b class="nc">&nbsp;                .getBoardWidth(), mapSettings.getBoardHeight(), mapSettings</b>
<b class="nc">&nbsp;                .getRange() + 1, mapSettings.getProbInvert(), mapSettings</b>
<b class="nc">&nbsp;                .getInvertNegativeTerrain(), elevationMap, mapSettings</b>
<b class="nc">&nbsp;                .getAlgorithmToUse());</b>
&nbsp;
<b class="nc">&nbsp;        IHex[] nb = new IHex[mapSettings.getBoardWidth()</b>
<b class="nc">&nbsp;                * mapSettings.getBoardHeight()];</b>
<b class="nc">&nbsp;        int index = 0;</b>
<b class="nc">&nbsp;        for (int h = 0; h &lt; mapSettings.getBoardHeight(); h++) {</b>
<b class="nc">&nbsp;            for (int w = 0; w &lt; mapSettings.getBoardWidth(); w++) {</b>
<b class="nc">&nbsp;                if(mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {</b>
<b class="nc">&nbsp;                    nb[index++] = new Hex(0,&quot;space:1&quot;,mapSettings.getTheme(), new Coords(w,h));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    nb[index++] = new Hex(elevationMap[w][h], &quot;&quot;, mapSettings</b>
<b class="nc">&nbsp;                            .getTheme(), new Coords(w,h));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IBoard result = new Board(mapSettings.getBoardWidth(), mapSettings</b>
<b class="nc">&nbsp;                .getBoardHeight(), nb);</b>
&nbsp;
<b class="nc">&nbsp;        if(mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {</b>
<b class="nc">&nbsp;            result.setType(Board.T_SPACE);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* initalize reverseHex */
<b class="nc">&nbsp;        HashMap&lt;IHex, Point&gt; reverseHex = new HashMap&lt;IHex, Point&gt;(2</b>
<b class="nc">&nbsp;                * mapSettings.getBoardWidth() * mapSettings.getBoardHeight());</b>
<b class="nc">&nbsp;        for (int y = 0; y &lt; mapSettings.getBoardHeight(); y++) {</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; mapSettings.getBoardWidth(); x++) {</b>
<b class="nc">&nbsp;                reverseHex.put(result.getHex(x, y), new Point(x, y));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int peaks = mapSettings.getMountainPeaks();</b>
<b class="nc">&nbsp;        while (peaks &gt; 0) {</b>
<b class="nc">&nbsp;            peaks--;</b>
<b class="nc">&nbsp;            int mountainHeight = mapSettings.getMountainHeightMin()</b>
<b class="nc">&nbsp;                    + Compute.randomInt(1 + mapSettings.getMountainHeightMax()</b>
<b class="nc">&nbsp;                            - mapSettings.getMountainHeightMin());</b>
<b class="nc">&nbsp;            int mountainWidth = mapSettings.getMountainWidthMin()</b>
<b class="nc">&nbsp;                    + Compute.randomInt(1 + mapSettings.getMountainWidthMax()</b>
<b class="nc">&nbsp;                            - mapSettings.getMountainWidthMin());</b>
<b class="nc">&nbsp;            int mapWidth = result.getWidth();</b>
<b class="nc">&nbsp;            int mapHeight = result.getHeight();</b>
&nbsp;
&nbsp;            // put the peak somewhere in the middle of the map...
<b class="nc">&nbsp;            Coords peak = new Coords(mapWidth / 4</b>
<b class="nc">&nbsp;                    + Compute.randomInt((mapWidth + 1) / 2), mapHeight / 4</b>
<b class="nc">&nbsp;                    + Compute.randomInt((mapHeight + 1) / 2));</b>
&nbsp;
<b class="nc">&nbsp;            generateMountain(result, mountainWidth, peak, mountainHeight,</b>
<b class="nc">&nbsp;                    mapSettings.getMountainStyle());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (mapSettings.getCliffs() &gt; 0) {</b>
<b class="nc">&nbsp;            addCliffs(result, mapSettings.getCliffs());</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Add the woods */
<b class="nc">&nbsp;        int count = mapSettings.getMinForestSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxForestSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxForestSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.WOODS,</b>
<b class="nc">&nbsp;                    mapSettings.getProbHeavy(), mapSettings.getMinForestSize(),</b>
<b class="nc">&nbsp;                    mapSettings.getMaxForestSize(), reverseHex, true);</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* Add foliage (1 elevation high woods) */
<b class="nc">&nbsp;        count = mapSettings.getMinFoliageSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxFoliageSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxFoliageSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeFoliage(result, Terrains.WOODS,</b>
<b class="nc">&nbsp;                    mapSettings.getProbFoliageHeavy(), mapSettings.getMinFoliageSize(),</b>
<b class="nc">&nbsp;                    mapSettings.getMaxFoliageSize(), reverseHex, true);</b>
&nbsp;        }
&nbsp;        
&nbsp;        /* Add the rough */
<b class="nc">&nbsp;        count = mapSettings.getMinRoughSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxRoughSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxRoughSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.ROUGH, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinRoughSize(), mapSettings.getMaxRoughSize(),</b>
&nbsp;                    reverseHex, true);
&nbsp;        }
&nbsp;        /* Add the sand */
<b class="nc">&nbsp;        count = mapSettings.getMinSandSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxSandSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxSandSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.SAND, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinSandSize(), mapSettings.getMaxSandSize(),</b>
&nbsp;                    reverseHex, true);
&nbsp;        }
&nbsp;        /* Add the planted field */
<b class="nc">&nbsp;        count = mapSettings.getMinPlantedFieldSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxPlantedFieldSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxPlantedFieldSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.FIELDS, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinPlantedFieldSize(), mapSettings.getMaxPlantedFieldSize(),</b>
&nbsp;                    reverseHex, true);
&nbsp;        }
&nbsp;        /* Add the swamp */
<b class="nc">&nbsp;        count = mapSettings.getMinSwampSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxSwampSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxSwampSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.SWAMP, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinSwampSize(), mapSettings.getMaxSwampSize(),</b>
&nbsp;                    reverseHex, false); // can stack with woods or roughs
&nbsp;        }
&nbsp;
&nbsp;        // Add the Fortified hexes
<b class="nc">&nbsp;        count = mapSettings.getMinFortifiedSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxFortifiedSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxFortifiedSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.FORTIFIED, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinFortifiedSize(), mapSettings.getMaxFortifiedSize(),</b>
&nbsp;                    reverseHex, false);
&nbsp;        }
&nbsp;
&nbsp;        // Add the rubble
<b class="nc">&nbsp;        count = mapSettings.getMinRubbleSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxRubbleSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxRubbleSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.RUBBLE, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinRubbleSize(), mapSettings.getMaxRubbleSize(),</b>
&nbsp;                    reverseHex, true);
&nbsp;        }
&nbsp;
&nbsp;        /* Add the water */
<b class="nc">&nbsp;        count = mapSettings.getMinWaterSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxWaterSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxWaterSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.WATER, mapSettings.getProbDeep(),</b>
<b class="nc">&nbsp;                    mapSettings.getMinWaterSize(), mapSettings</b>
<b class="nc">&nbsp;                            .getMaxWaterSize(), reverseHex, true);</b>
&nbsp;        }
&nbsp;        /* Add the pavements */
<b class="nc">&nbsp;        count = mapSettings.getMinPavementSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxPavementSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxPavementSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.PAVEMENT, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinPavementSize(), mapSettings.getMaxPavementSize(),</b>
&nbsp;                    reverseHex, true);
&nbsp;        }
&nbsp;
&nbsp;        /* Add the ice */
<b class="nc">&nbsp;        count = mapSettings.getMinIceSpots();</b>
<b class="nc">&nbsp;        if (mapSettings.getMaxIceSpots() &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(mapSettings.getMaxIceSpots());</b>
&nbsp;        }
<b class="nc">&nbsp;        count *= sizeScale;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            placeSomeTerrain(result, Terrains.ICE, 0, mapSettings</b>
<b class="nc">&nbsp;                    .getMinIceSize(), mapSettings.getMaxIceSize(), reverseHex,</b>
&nbsp;                    true);
&nbsp;        }
&nbsp;
&nbsp;        /* Add the craters */
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbCrater()) {</b>
<b class="nc">&nbsp;            addCraters(result, mapSettings.getMinRadius(), mapSettings.getMaxRadius(),</b>
<b class="nc">&nbsp;                    (int) (mapSettings.getMinCraters() * sizeScale),</b>
<b class="nc">&nbsp;                    (int) (mapSettings.getMaxCraters() * sizeScale));</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Add the river */
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbRiver()) {</b>
<b class="nc">&nbsp;            addRiver(result, reverseHex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Add special effects */
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbFlood()) {</b>
<b class="nc">&nbsp;            postProcessFlood(nb, mapSettings.getFxMod());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbDrought()) {</b>
<b class="nc">&nbsp;            postProcessDrought(nb, mapSettings.getFxMod());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbFreeze()) {</b>
<b class="nc">&nbsp;            postProcessDeepFreeze(nb, mapSettings.getFxMod());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbForestFire()) {</b>
<b class="nc">&nbsp;            postProcessForestFire(nb, mapSettings.getFxMod());</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Add the road */
<b class="nc">&nbsp;        boolean roadNeeded = false;</b>
<b class="nc">&nbsp;        if (Compute.randomInt(100) &lt; mapSettings.getProbRoad()) {</b>
<b class="nc">&nbsp;            roadNeeded = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // add buildings
<b class="nc">&nbsp;        ArrayList&lt;BuildingTemplate&gt; buildings = mapSettings.getBoardBuildings();</b>
<b class="nc">&nbsp;        CityBuilder cityBuilder = new CityBuilder(mapSettings, result);</b>
<b class="nc">&nbsp;        if (buildings.size() == 0) {</b>
<b class="nc">&nbsp;            buildings = cityBuilder.generateCity(roadNeeded);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; buildings.size(); i++) {</b>
<b class="nc">&nbsp;            placeBuilding(result, (buildings.get(i)));</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void placeBuilding(IBoard board, BuildingTemplate building) {
<b class="nc">&nbsp;        int type = building.getType();</b>
<b class="nc">&nbsp;        int cf = building.getCF();</b>
<b class="nc">&nbsp;        int height = building.getHeight();</b>
<b class="nc">&nbsp;        ITerrainFactory tf = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        ArrayList&lt;IHex&gt; hexes = new ArrayList&lt;IHex&gt;();</b>
<b class="nc">&nbsp;        int level = 0;</b>
<b class="nc">&nbsp;        for (Iterator&lt;Coords&gt; i = building.getCoords(); i.hasNext();) {</b>
<b class="nc">&nbsp;            Coords c = i.next();</b>
<b class="nc">&nbsp;            IHex hex = board.getHex(c);</b>
&nbsp;            // work out exits...
<b class="nc">&nbsp;            int exits = 0;</b>
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                if (building.containsCoords(c.translated(dir))) {</b>
<b class="nc">&nbsp;                    exits |= (1 &lt;&lt; dir);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // remove everything
<b class="nc">&nbsp;            hex.removeAllTerrains();</b>
<b class="nc">&nbsp;            hex.addTerrain(tf.createTerrain(Terrains.PAVEMENT, 1));</b>
<b class="nc">&nbsp;            hex.addTerrain(tf.createTerrain(Terrains.BUILDING, type, true,</b>
&nbsp;                    exits));
<b class="nc">&nbsp;            hex.addTerrain(tf.createTerrain(Terrains.BLDG_CF, cf));</b>
<b class="nc">&nbsp;            hex.addTerrain(tf.createTerrain(Terrains.BLDG_ELEV, height));</b>
&nbsp;            // hex.addTerrain(tf.createTerrain(Terrains.BLDG_BASEMENT,
&nbsp;            // building.getBasement()));
<b class="nc">&nbsp;            hexes.add(hex);</b>
<b class="nc">&nbsp;            level += hex.getLevel();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // set everything to the same level
<b class="nc">&nbsp;        for (int j = 0; j &lt; hexes.size(); j++) {</b>
<b class="nc">&nbsp;            hexes.get(j).setLevel(level / hexes.size());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Places randomly some connected Woods.
&nbsp;     *
&nbsp;     * @param board The board the terrain goes on.
&nbsp;     * @param terrainType The type of terrain to place {@link Terrains}.
&nbsp;     * @param probMore
&nbsp;     * @param maxHexes Maximum number of hexes this terrain can cover.
&nbsp;     * @param reverseHex
&nbsp;     * @param exclusive Set TRUE if this terrain cannot be combined with any other terrain types.
&nbsp;     */
&nbsp;    protected static void placeSomeTerrain(IBoard board, int terrainType, int probMore, int minHexes, int maxHexes,
&nbsp;            HashMap&lt;IHex, Point&gt; reverseHex, boolean exclusive) {
<b class="nc">&nbsp;        Point p = new Point(Compute.randomInt(board.getWidth()), Compute</b>
<b class="nc">&nbsp;                .randomInt(board.getHeight()));</b>
<b class="nc">&nbsp;        int count = minHexes;</b>
<b class="nc">&nbsp;        if ((maxHexes - minHexes) &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(maxHexes - minHexes);</b>
&nbsp;        }
&nbsp;        IHex field;
&nbsp;
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; alreadyUsed = new HashSet&lt;IHex&gt;();</b>
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; unUsed = new HashSet&lt;IHex&gt;();</b>
<b class="nc">&nbsp;        field = board.getHex(p.x, p.y);</b>
<b class="nc">&nbsp;        if (!field.containsTerrain(terrainType)) {</b>
<b class="nc">&nbsp;            unUsed.add(field);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            findAllUnused(board, terrainType, alreadyUsed, unUsed, field,</b>
&nbsp;                    reverseHex);
&nbsp;        }
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            if (unUsed.isEmpty()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            int which = Compute.randomInt(unUsed.size());</b>
<b class="nc">&nbsp;            Iterator&lt;IHex&gt; iter = unUsed.iterator();</b>
<b class="nc">&nbsp;            for (int n = 0; n &lt; (which - 1); n++) {</b>
<b class="nc">&nbsp;                iter.next();</b>
&nbsp;            }
<b class="nc">&nbsp;            field = iter.next();</b>
<b class="nc">&nbsp;            if (exclusive) {</b>
<b class="nc">&nbsp;                field.removeAllTerrains();</b>
&nbsp;            }
<b class="nc">&nbsp;            int tempInt = (Compute.randomInt(100) &lt; probMore) ? 2 : 1;</b>
<b class="nc">&nbsp;            ITerrain tempTerrain = f.createTerrain(terrainType, tempInt);</b>
<b class="nc">&nbsp;            field.addTerrain(tempTerrain);</b>
<b class="nc">&nbsp;            if (terrainType == Terrains.WOODS) {</b>
<b class="nc">&nbsp;                field.addTerrain(f.createTerrain(Terrains.FOLIAGE_ELEV, 2));</b>
&nbsp;            }
<b class="nc">&nbsp;            unUsed.remove(field);</b>
<b class="nc">&nbsp;            findAllUnused(board, terrainType, alreadyUsed, unUsed, field,</b>
&nbsp;                    reverseHex);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (terrainType == Terrains.WATER) {</b>
&nbsp;            /*
&nbsp;             * if next to an Water Hex is an lower lvl lower the hex. First we
&nbsp;             * search for lowest Hex next to the lake
&nbsp;             */
<b class="nc">&nbsp;            int min = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;            Iterator&lt;IHex&gt; iter = unUsed.iterator();</b>
<b class="nc">&nbsp;            while (iter.hasNext()) {</b>
<b class="nc">&nbsp;                field = iter.next();</b>
<b class="nc">&nbsp;                if (field.getLevel() &lt; min) {</b>
<b class="nc">&nbsp;                    min = field.getLevel();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            iter = alreadyUsed.iterator();</b>
<b class="nc">&nbsp;            while (iter.hasNext()) {</b>
<b class="nc">&nbsp;                field = iter.next();</b>
<b class="nc">&nbsp;                field.setLevel(min);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Places randomly some connected Woods.
&nbsp;     *
&nbsp;     * @param board The board the terrain goes on.
&nbsp;     * @param terrainType The type of terrain to place {@link Terrains}.
&nbsp;     * @param probMore
&nbsp;     * @param maxHexes Maximum number of hexes this terrain can cover.
&nbsp;     * @param reverseHex
&nbsp;     * @param exclusive Set TRUE if this terrain cannot be combined with any other terrain types.
&nbsp;     */
&nbsp;    protected static void placeFoliage(IBoard board, int terrainType, int probMore, int minHexes, int maxHexes,
&nbsp;            HashMap&lt;IHex, Point&gt; reverseHex, boolean exclusive) {
<b class="nc">&nbsp;        Point p = new Point(Compute.randomInt(board.getWidth()), Compute</b>
<b class="nc">&nbsp;                .randomInt(board.getHeight()));</b>
<b class="nc">&nbsp;        int count = minHexes;</b>
<b class="nc">&nbsp;        if ((maxHexes - minHexes) &gt; 0) {</b>
<b class="nc">&nbsp;            count += Compute.randomInt(maxHexes - minHexes);</b>
&nbsp;        }
&nbsp;        IHex field;
&nbsp;
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; alreadyUsed = new HashSet&lt;IHex&gt;();</b>
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; unUsed = new HashSet&lt;IHex&gt;();</b>
<b class="nc">&nbsp;        field = board.getHex(p.x, p.y);</b>
<b class="nc">&nbsp;        if (!field.containsTerrain(terrainType)) {</b>
<b class="nc">&nbsp;            unUsed.add(field);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            findAllUnused(board, terrainType, alreadyUsed, unUsed, field,</b>
&nbsp;                    reverseHex);
&nbsp;        }
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc">&nbsp;            if (unUsed.isEmpty()) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            int which = Compute.randomInt(unUsed.size());</b>
<b class="nc">&nbsp;            Iterator&lt;IHex&gt; iter = unUsed.iterator();</b>
<b class="nc">&nbsp;            for (int n = 0; n &lt; (which - 1); n++) {</b>
<b class="nc">&nbsp;                iter.next();</b>
&nbsp;            }
<b class="nc">&nbsp;            field = iter.next();</b>
<b class="nc">&nbsp;            if (exclusive) {</b>
<b class="nc">&nbsp;                field.removeAllTerrains();</b>
&nbsp;            }
<b class="nc">&nbsp;            int tempInt = (Compute.randomInt(100) &lt; probMore) ? 2 : 1;</b>
<b class="nc">&nbsp;            ITerrain tempTerrain = f.createTerrain(terrainType, tempInt);</b>
<b class="nc">&nbsp;            field.addTerrain(tempTerrain);</b>
<b class="nc">&nbsp;            field.addTerrain(f.createTerrain(Terrains.FOLIAGE_ELEV, 1));</b>
<b class="nc">&nbsp;            unUsed.remove(field);</b>
<b class="nc">&nbsp;            findAllUnused(board, terrainType, alreadyUsed, unUsed, field,</b>
&nbsp;                    reverseHex);
&nbsp;        }
&nbsp;
&nbsp;        
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Searching starting from one Hex, all Terrains not matching terrainType,
&nbsp;     * next to one of terrainType.
&nbsp;     *
&nbsp;     * @param terrainType The terrainType which the searching hexes should not
&nbsp;     *            have.
&nbsp;     * @param alreadyUsed The hexes which should not looked at (because they are
&nbsp;     *            already supposed to visited in some way)
&nbsp;     * @param unUsed In this set the resulting hexes are stored. They are stored
&nbsp;     *            in addition to all previously stored.
&nbsp;     * @param searchFrom The Hex where to start
&nbsp;     */
&nbsp;    private static void findAllUnused(IBoard board, int terrainType,
&nbsp;            HashSet&lt;IHex&gt; alreadyUsed, HashSet&lt;IHex&gt; unUsed, IHex searchFrom,
&nbsp;            HashMap&lt;IHex, Point&gt; reverseHex) {
&nbsp;        IHex field;
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; notYetUsed = new HashSet&lt;IHex&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        notYetUsed.add(searchFrom);</b>
&nbsp;        do {
<b class="nc">&nbsp;            Iterator&lt;IHex&gt; iter = notYetUsed.iterator();</b>
<b class="nc">&nbsp;            field = iter.next();</b>
<b class="nc">&nbsp;            if (field == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;                Point loc = reverseHex.get(field);</b>
<b class="nc">&nbsp;                IHex newHex = board.getHexInDir(loc.x, loc.y, dir);</b>
<b class="nc">&nbsp;                if ((newHex != null) &amp;&amp; (!alreadyUsed.contains(newHex))</b>
<b class="nc">&nbsp;                        &amp;&amp; (!notYetUsed.contains(newHex))</b>
<b class="nc">&nbsp;                        &amp;&amp; (!unUsed.contains(newHex))) {</b>
<b class="nc">&nbsp;                    ((newHex.containsTerrain(terrainType)) ? notYetUsed</b>
<b class="nc">&nbsp;                            : unUsed).add(newHex);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            notYetUsed.remove(field);</b>
<b class="nc">&nbsp;            alreadyUsed.add(field);</b>
<b class="nc">&nbsp;        } while (!notYetUsed.isEmpty());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * add a crater to the board
&nbsp;     */
&nbsp;    public static void addCraters(IBoard board, int minRadius, int maxRadius,
&nbsp;            int minCraters, int maxCraters) {
&nbsp;
&nbsp;        // Calculate number of craters to generate.
<b class="nc">&nbsp;        int numberCraters = minCraters;</b>
<b class="nc">&nbsp;        if (maxCraters &gt; minCraters) {</b>
<b class="nc">&nbsp;            numberCraters += Compute.randomInt(maxCraters - minCraters);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Stay within the board boundaries.
<b class="nc">&nbsp;        int width = board.getWidth();</b>
<b class="nc">&nbsp;        int height = board.getHeight();</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;Coords, Integer&gt; usedHexes = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // Generate each crater.
<b class="nc">&nbsp;        for (int i = 0; i &lt; numberCraters; i++) {</b>
&nbsp;
&nbsp;            // Locate the center of the crater.
<b class="nc">&nbsp;            Point center = new Point(Compute.randomInt(width), Compute.randomInt(height));</b>
&nbsp;
&nbsp;            // What is the diameter of this crater?
<b class="nc">&nbsp;            int radius = Compute.randomInt(maxRadius - minRadius) + minRadius;</b>
&nbsp;
&nbsp;            // Terrestrial crater depth to radius ratio is typically 1:5 to 1:7.
&nbsp;            // Hexes are 30m across and levels are 6m high.
&nbsp;            // This ends up with rather deep craters (a 6-diameter crater can have a depth of 4-6).  For gamability
&nbsp;            // and verisimilitude, we&#39;re making crater&#39;s more shallow than is typical (1:8 to 1:10 ratio).
<b class="nc">&nbsp;            int divisor = Compute.randomInt(2) + 8;</b>
<b class="nc">&nbsp;            int radiusM = radius * 30;</b>
<b class="nc">&nbsp;            int maxDepthM = Math.max(6, radiusM / divisor);</b>
<b class="nc">&nbsp;            int maxDepth = maxDepthM / 6;</b>
&nbsp;
&nbsp;            /* generate CraterProfile */
<b class="nc">&nbsp;            int cratDepth[] = new int[radius];</b>
<b class="nc">&nbsp;            for (int x = 0; x &lt; radius; x++) {</b>
<b class="nc">&nbsp;                cratDepth[x] = craterProfile(x, radius, maxDepth);</b>
&nbsp;            }
&nbsp;
&nbsp;            /*
&nbsp;             * btw, I am interested if someone actually reads this comments, so
&nbsp;             * send me and email to f.stock@tu-bs.de, if you do ;-)
&nbsp;             */
&nbsp;            /* now recalculate every hex */
<b class="nc">&nbsp;            for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;                    int distance = (int) distance(center, new Point(w, h));</b>
<b class="nc">&nbsp;                    if (distance &lt; radius) {</b>
<b class="nc">&nbsp;                        IHex field = board.getHex(w, h);</b>
&nbsp;                        int baseElevation;
&nbsp;
&nbsp;                        // If we&#39;ve already placed a crater here, find it&#39;s original elevation.
<b class="nc">&nbsp;                        if (usedHexes.containsKey(field.getCoords())) {</b>
<b class="nc">&nbsp;                            baseElevation = usedHexes.get(field.getCoords());</b>
&nbsp;                        } else {
&nbsp;                            // If no crater has been placed here, add this hex&#39;s original elevation to our list.
<b class="nc">&nbsp;                            baseElevation = field.getLevel();</b>
<b class="nc">&nbsp;                            usedHexes.put(field.getCoords(), baseElevation);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        // Calculate the crater depth based on the original hex elevation.
<b class="nc">&nbsp;                        int newElevation = baseElevation + cratDepth[distance];</b>
&nbsp;
&nbsp;                        // If the new elevation is deeper, use it, otherwise keep what we&#39;ve already calculated.
<b class="nc">&nbsp;                        field.setLevel(Math.min(newElevation, field.getLevel()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static int craterProfile(int distanceFromCenter, int fullRadius, int maxDepth) {
&nbsp;        double depth;
&nbsp;
&nbsp;        // If we&#39;re at the center, we should use the max depth.
<b class="fc">&nbsp;        if (distanceFromCenter == 0) {</b>
<b class="fc">&nbsp;            return -maxDepth;</b>
<b class="fc">&nbsp;        } else if (distanceFromCenter == fullRadius) { // The edge should have no depth.</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // The crater&#39;s floor should be a relatively shallow parabola.
<b class="fc">&nbsp;        double radiusPercent = (double) distanceFromCenter / fullRadius;</b>
<b class="fc">&nbsp;        if (radiusPercent &lt; 0.75) {</b>
<b class="fc">&nbsp;            depth = 0.02 * Math.pow(distanceFromCenter, 2) - maxDepth;</b>
&nbsp;
&nbsp;        } else { // The parabola should get steeper the closer to the crater wall you are.
<b class="fc">&nbsp;            depth = 0.04 * Math.pow(distanceFromCenter, 2) - maxDepth;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return (int) Math.round(depth);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The profile of a crater: interior is exp-function, exterior cos function.
&nbsp;     *
&nbsp;     * @param x The x value of the function. range 0..1. 0=center of crater.
&nbsp;     *            1=border of outer wall.
&nbsp;     * @param scale Apply this scale before returning the result (recommend
&nbsp;     *            instead of afterwards scale, cause this way the intern
&nbsp;     *            floating values are scaled, instead of int result).
&nbsp;     * @return The height of the crater at the position x from center. Unscaled,
&nbsp;     *         the results are between -0.5 and 1 (that means, if no scale is
&nbsp;     *         applied -1, 0 or 1).
&nbsp;     */
&nbsp;//    public static int craterProfile(double x, int scale) {
&nbsp;//        double result = 0;
&nbsp;//
&nbsp;//        result = (x &lt; 0.75) ? ((Math.exp(x * 5.0 / 0.75 - 3) - 0.04979) * 1.5 / 7.33926) - 0.5
&nbsp;//                : ((Math.cos((x - 0.75) * 4.0) + 1.0) / 2.0);
&nbsp;//
&nbsp;//        return (int) (result * scale);
&nbsp;//    }
&nbsp;
&nbsp;    /**
&nbsp;     * calculate the distance between two points
&nbsp;     *
&nbsp;     * @param p1
&nbsp;     * @param p2
&nbsp;     */
&nbsp;    private static double distance(Point p1, Point p2) {
<b class="nc">&nbsp;        double x = p1.x - p2.x;</b>
<b class="nc">&nbsp;        double y = p1.y - p2.y;</b>
<b class="nc">&nbsp;        return Math.sqrt(x * x + y * y);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an River to the map (if the map is at least 5x5 hexes big). The
&nbsp;     * river has an width of 1-3 hexes (everything else is no more a river). The
&nbsp;     * river goes from one border to another. Nor Params, no results.
&nbsp;     */
&nbsp;    public static void addRiver(IBoard board, HashMap&lt;IHex, Point&gt; reverseHex) {
<b class="nc">&nbsp;        int minElevation = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; riverHexes = new HashSet&lt;IHex&gt;();</b>
&nbsp;        IHex field;
<b class="nc">&nbsp;        Point p = null;</b>
<b class="nc">&nbsp;        int direction = 0;</b>
<b class="nc">&nbsp;        int nextLeft = 0;</b>
<b class="nc">&nbsp;        int nextRight = 0;</b>
&nbsp;
<b class="nc">&nbsp;        int width = board.getWidth();</b>
<b class="nc">&nbsp;        int height = board.getHeight();</b>
&nbsp;
&nbsp;        /* if map is smaller than 5x5 no real space for an river */
<b class="nc">&nbsp;        if ((width &lt; 5) || (height &lt; 5)) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        /* First select start and the direction */
<b class="nc">&nbsp;        switch (Compute.randomInt(4)) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                p = new Point(0, Compute.randomInt(5) - 2 + height / 2);</b>
<b class="nc">&nbsp;                direction = Compute.randomInt(2) + 1;</b>
<b class="nc">&nbsp;                nextLeft = direction - 1;</b>
<b class="nc">&nbsp;                nextRight = direction + 1;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                p = new Point(width - 1, Compute.randomInt(5) - 2 + height / 2);</b>
<b class="nc">&nbsp;                direction = Compute.randomInt(2) + 4;</b>
<b class="nc">&nbsp;                nextLeft = direction - 1;</b>
<b class="nc">&nbsp;                nextRight = (direction + 1) % 6;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 2:
&nbsp;            case 3:
<b class="nc">&nbsp;                p = new Point(Compute.randomInt(5) - 2 + width / 2, 0);</b>
<b class="nc">&nbsp;                direction = 2;</b>
<b class="nc">&nbsp;                nextRight = 3;</b>
<b class="nc">&nbsp;                nextLeft = 4;</b>
&nbsp;                break;
&nbsp;        } // switch
&nbsp;        /* place the river */
<b class="nc">&nbsp;        field = board.getHex(p.x, p.y);</b>
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
&nbsp;        do {
&nbsp;            /* first the hex itself */
<b class="nc">&nbsp;            field.removeAllTerrains();</b>
<b class="nc">&nbsp;            field.addTerrain(f.createTerrain(Terrains.WATER, 1));</b>
<b class="nc">&nbsp;            riverHexes.add(field);</b>
<b class="nc">&nbsp;            p = reverseHex.get(field);</b>
&nbsp;            /* then maybe the left and right neighbours */
<b class="nc">&nbsp;            riverHexes.addAll(extendRiverToSide(board, p, Compute.randomInt(3),</b>
&nbsp;                    nextLeft, reverseHex));
<b class="nc">&nbsp;            riverHexes.addAll(extendRiverToSide(board, p, Compute.randomInt(3),</b>
&nbsp;                    nextRight, reverseHex));
<b class="nc">&nbsp;            switch (Compute.randomInt(4)) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    field = board.getHexInDir(p.x, p.y, (direction + 5) % 6);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    field = board.getHexInDir(p.x, p.y, (direction + 1) % 6);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    field = board.getHexInDir(p.x, p.y, direction);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } while (field != null);</b>
&nbsp;
&nbsp;        /* search the elevation for the river */
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; tmpRiverHexes = new HashSet&lt;IHex&gt;(riverHexes);</b>
<b class="nc">&nbsp;        while (!tmpRiverHexes.isEmpty()) {</b>
<b class="nc">&nbsp;            Iterator&lt;IHex&gt; iter = tmpRiverHexes.iterator();</b>
<b class="nc">&nbsp;            field = iter.next();</b>
<b class="nc">&nbsp;            if (field.getLevel() &lt; minElevation) {</b>
<b class="nc">&nbsp;                minElevation = field.getLevel();</b>
&nbsp;            }
<b class="nc">&nbsp;            tmpRiverHexes.remove(field);</b>
<b class="nc">&nbsp;            Point thisHex = reverseHex.get(field);</b>
&nbsp;            /* and now the six neighbours */
<b class="nc">&nbsp;            for (int i = 0; i &lt; 6; i++) {</b>
<b class="nc">&nbsp;                field = board.getHexInDir(thisHex.x, thisHex.y, i);</b>
<b class="nc">&nbsp;                if ((field != null) &amp;&amp; (field.getLevel() &lt; minElevation)) {</b>
<b class="nc">&nbsp;                    minElevation = field.getLevel();</b>
&nbsp;                }
<b class="nc">&nbsp;                tmpRiverHexes.remove(field);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /* now adjust the elevation to same height */
<b class="nc">&nbsp;        Iterator&lt;IHex&gt; iter = riverHexes.iterator();</b>
<b class="nc">&nbsp;        while (iter.hasNext()) {</b>
<b class="nc">&nbsp;            field = iter.next();</b>
<b class="nc">&nbsp;            field.setLevel(minElevation);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extends a river hex to left and right sides.
&nbsp;     *
&nbsp;     * @param hexloc The location of the river hex, from which it should get
&nbsp;     *            started.
&nbsp;     * @param width The width to wich the river should extend in the direction.
&nbsp;     *            So the actual width of the river is 2*width+1.
&nbsp;     * @param direction Direction too which the riverhexes should be extended.
&nbsp;     * @return Hashset with the hexes from the side.
&nbsp;     */
&nbsp;    private static HashSet&lt;IHex&gt; extendRiverToSide(IBoard board, Point hexloc,
&nbsp;            int width, int direction, HashMap&lt;IHex, Point&gt; reverseHex) {
<b class="nc">&nbsp;        Point current = new Point(hexloc);</b>
<b class="nc">&nbsp;        HashSet&lt;IHex&gt; result = new HashSet&lt;IHex&gt;();</b>
&nbsp;        IHex hex;
&nbsp;
<b class="nc">&nbsp;        hex = board.getHexInDir(current.x, current.y, direction);</b>
<b class="nc">&nbsp;        while ((hex != null) &amp;&amp; (width-- &gt; 0)) {</b>
<b class="nc">&nbsp;            hex.removeAllTerrains();</b>
<b class="nc">&nbsp;            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(</b>
&nbsp;                    Terrains.WATER, 1));
<b class="nc">&nbsp;            result.add(hex);</b>
<b class="nc">&nbsp;            current = reverseHex.get(hex);</b>
<b class="nc">&nbsp;            hex = board.getHexInDir(current.x, current.y, direction);</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Flood negative hex levels Shoreline / salt marshes effect Works best with
&nbsp;     * more elevation
&nbsp;     */
&nbsp;    protected static void postProcessFlood(IHex[] hexSet, int modifier) {
&nbsp;        int n;
&nbsp;        IHex field;
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        for (n = 0; n &lt; hexSet.length; n++) {</b>
<b class="nc">&nbsp;            field = hexSet[n];</b>
<b class="nc">&nbsp;            int elev = field.getLevel() - modifier;</b>
<b class="nc">&nbsp;            if ((elev == 0) &amp;&amp; !(field.containsTerrain(Terrains.WATER))</b>
<b class="nc">&nbsp;                    &amp;&amp; !(field.containsTerrain(Terrains.PAVEMENT))) {</b>
<b class="nc">&nbsp;                field.addTerrain(f.createTerrain(Terrains.SWAMP, 1));</b>
<b class="nc">&nbsp;            } else if (elev &lt; 0) {</b>
<b class="nc">&nbsp;                if (elev &lt; -4) {</b>
<b class="nc">&nbsp;                    elev = -4;</b>
&nbsp;                }
<b class="nc">&nbsp;                field.removeAllTerrains();</b>
<b class="nc">&nbsp;                field.addTerrain(f.createTerrain(Terrains.WATER, -elev));</b>
<b class="nc">&nbsp;                field.setLevel(modifier);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Converts water hexes to ice hexes. Works best with snow&amp;ice theme.
&nbsp;     */
&nbsp;    protected static void postProcessDeepFreeze(IHex[] hexSet, int modifier) {
&nbsp;        int n;
&nbsp;        IHex field;
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        for (n = 0; n &lt; hexSet.length; n++) {</b>
<b class="nc">&nbsp;            field = hexSet[n];</b>
<b class="nc">&nbsp;            if (field.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                int level = field.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;                if (modifier != 0) {</b>
<b class="nc">&nbsp;                    level -= modifier;</b>
<b class="nc">&nbsp;                    field.removeTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;                    if (level &gt; 0) {</b>
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.WATER,</b>
&nbsp;                                        level));
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                field.addTerrain(f.createTerrain(Terrains.ICE, 1));</b>
<b class="nc">&nbsp;            } else if (field.containsTerrain(Terrains.SWAMP)) {</b>
<b class="nc">&nbsp;                field.removeTerrain(Terrains.SWAMP);</b>
<b class="nc">&nbsp;                if (field.terrainsPresent() == 0) {</b>
<b class="nc">&nbsp;                    if (Compute.randomInt(100) &lt; 30) {</b>
&nbsp;                        // if no other terrains present, 30% chance to change to
&nbsp;                        // rough
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.ROUGH, 1));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.ICE, 1));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Burning woods, with chance to be burnt down already
&nbsp;     */
&nbsp;    protected static void postProcessForestFire(IHex[] hexSet, int modifier) {
&nbsp;        int n;
&nbsp;        IHex field;
&nbsp;        int level, newlevel;
&nbsp;        int severity;
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        for (n = 0; n &lt; hexSet.length; n++) {</b>
<b class="nc">&nbsp;            field = hexSet[n];</b>
<b class="nc">&nbsp;            level = field.terrainLevel(Terrains.WOODS);</b>
<b class="nc">&nbsp;            if (level != ITerrain.LEVEL_NONE) {</b>
<b class="nc">&nbsp;                severity = Compute.randomInt(5) - 2 + modifier;</b>
<b class="nc">&nbsp;                newlevel = level - severity;</b>
&nbsp;
<b class="nc">&nbsp;                if (newlevel &lt;= level) {</b>
<b class="nc">&nbsp;                    field.removeTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;                    field.removeTerrain(Terrains.FOLIAGE_ELEV);</b>
<b class="nc">&nbsp;                    if (newlevel &lt;= 0) {</b>
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.ROUGH, 1));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.WOODS,</b>
&nbsp;                                newlevel));
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.FOLIAGE_ELEV,</b>
<b class="nc">&nbsp;                                newlevel == 3 ? 3 : 2));</b>
<b class="nc">&nbsp;                        field.addTerrain(f.createTerrain(Terrains.FIRE, 1));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Dries up all bodies of water by 1-3 levels. dried up water becomes swamp
&nbsp;     * then rough
&nbsp;     */
&nbsp;    protected static void postProcessDrought(IHex[] hexSet, int modifier) {
&nbsp;        int n;
&nbsp;        IHex field;
&nbsp;        int level, newlevel;
<b class="nc">&nbsp;        int severity = 1 + Compute.randomInt(3) + modifier;</b>
<b class="nc">&nbsp;        if (severity &lt; 0) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        ITerrainFactory f = Terrains.getTerrainFactory();</b>
<b class="nc">&nbsp;        for (n = 0; n &lt; hexSet.length; n++) {</b>
<b class="nc">&nbsp;            field = hexSet[n];</b>
<b class="nc">&nbsp;            if (field.containsTerrain(Terrains.SWAMP)) {</b>
<b class="nc">&nbsp;                field.removeTerrain(Terrains.SWAMP); // any swamps are dried</b>
&nbsp;                                                        // up to hardened mud
<b class="nc">&nbsp;                if ((field.terrainsPresent() == 0) &amp;&amp; (Compute.randomInt(100) &lt; 30)) {</b>
&nbsp;                    // if no other terrains present, 30% chance to change to
&nbsp;                    // rough
<b class="nc">&nbsp;                    field.addTerrain(f.createTerrain(Terrains.ROUGH, 1));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            level = field.terrainLevel(Terrains.WATER);</b>
<b class="nc">&nbsp;            if (level != ITerrain.LEVEL_NONE) {</b>
<b class="nc">&nbsp;                newlevel = level - severity;</b>
<b class="nc">&nbsp;                field.removeTerrain(Terrains.WATER);</b>
<b class="nc">&nbsp;                if (newlevel == 0) {</b>
<b class="nc">&nbsp;                    field.addTerrain(f.createTerrain(Terrains.SWAMP, 1));</b>
<b class="nc">&nbsp;                } else if (newlevel &lt; 0) {</b>
<b class="nc">&nbsp;                    field.addTerrain(f.createTerrain(Terrains.ROUGH, 1));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    field.addTerrain(f.createTerrain(Terrains.WATER, newlevel));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (level &gt; severity) {</b>
<b class="nc">&nbsp;                    newlevel = severity;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    newlevel = level;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                field.setLevel(field.getLevel() - newlevel);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static boolean hexCouldBeCliff(IBoard board, Coords c) {
<b class="nc">&nbsp;        int elevation = board.getHex(c).getLevel();</b>
<b class="nc">&nbsp;        boolean higher = false;</b>
<b class="nc">&nbsp;        boolean lower = false;</b>
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            Coords t = c.translated(dir);</b>
<b class="nc">&nbsp;            if (board.contains(t)) {</b>
<b class="nc">&nbsp;                IHex hex = board.getHex(t);</b>
<b class="nc">&nbsp;                int el = hex.getLevel();</b>
<b class="nc">&nbsp;                if (el &gt; elevation) {</b>
<b class="nc">&nbsp;                    lower = true;</b>
<b class="nc">&nbsp;                } else if (el &lt; elevation) {</b>
<b class="nc">&nbsp;                    higher = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    count++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return higher &amp;&amp; lower &amp;&amp; (count &lt;= 3) &amp;&amp; (count &gt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void findCliffNeighbours(IBoard board, Coords c,
&nbsp;            ArrayList&lt;Coords&gt; candidate, HashSet&lt;Coords&gt; ignore) {
<b class="nc">&nbsp;        candidate.add(c);</b>
<b class="nc">&nbsp;        ignore.add(c);</b>
<b class="nc">&nbsp;        int elevation = board.getHex(c).getLevel();</b>
<b class="nc">&nbsp;        for (int dir = 0; dir &lt; 6; dir++) {</b>
<b class="nc">&nbsp;            Coords t = c.translated(dir);</b>
<b class="nc">&nbsp;            if (board.contains(t) &amp;&amp; !ignore.contains(t)) {</b>
<b class="nc">&nbsp;                if (hexCouldBeCliff(board, t)) {</b>
<b class="nc">&nbsp;                    IHex hex = board.getHex(t);</b>
<b class="nc">&nbsp;                    int el = hex.getLevel();</b>
<b class="nc">&nbsp;                    if (el == elevation) {</b>
<b class="nc">&nbsp;                        findCliffNeighbours(board, t, candidate, ignore);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    ignore.add(t);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected static void addCliffs(IBoard board, int modifier) {
<b class="nc">&nbsp;        HashSet&lt;Coords&gt; ignore = new HashSet&lt;Coords&gt;(); // previously considered</b>
&nbsp;                                                        // hexes
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; candidate = new ArrayList&lt;Coords&gt;();</b>
<b class="nc">&nbsp;        for (int x = 0; x &lt; board.getWidth(); x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; board.getHeight(); y++) {</b>
<b class="nc">&nbsp;                Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;                int elevation = board.getHex(c).getLevel();</b>
<b class="nc">&nbsp;                if (ignore.contains(c)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!hexCouldBeCliff(board, c)) {</b>
<b class="nc">&nbsp;                    ignore.add(c);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                findCliffNeighbours(board, c, candidate, ignore);</b>
&nbsp;                // is the candidate interesting (at least 3 hexes)?
<b class="nc">&nbsp;                if ((candidate.size() &gt;= 3) &amp;&amp; (Compute.randomInt(100) &lt; modifier)) {</b>
<b class="nc">&nbsp;                    if (elevation &gt; 0) {</b>
<b class="nc">&nbsp;                        elevation--;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        elevation++;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (Iterator&lt;Coords&gt; e = candidate.iterator(); e.hasNext();) {</b>
<b class="nc">&nbsp;                        c = e.next();</b>
<b class="nc">&nbsp;                        IHex hex = board.getHex(c);</b>
<b class="nc">&nbsp;                        hex.setLevel(elevation);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                candidate.clear();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /*
&nbsp;     * adjust the board based on weather conditions
&nbsp;     */
&nbsp;    public static void addWeatherConditions(IBoard board, int weatherCond, int windCond) {
<b class="nc">&nbsp;        ITerrainFactory tf = Terrains.getTerrainFactory();</b>
&nbsp;
<b class="nc">&nbsp;        for (int x = 0; x &lt; board.getWidth(); x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; board.getHeight(); y++) {</b>
<b class="nc">&nbsp;                Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;                IHex hex = board.getHex(c);</b>
&nbsp;
&nbsp;                //moderate rain - mud in clear hexes, depth 0 water, and dirt roads (not implemented yet)
<b class="nc">&nbsp;                if(weatherCond == PlanetaryConditions.WE_MOD_RAIN) {</b>
<b class="nc">&nbsp;                    if((hex.terrainsPresent() == 0) || (hex.containsTerrain(Terrains.WATER) &amp;&amp; (hex.depth() == 0))) {</b>
<b class="nc">&nbsp;                        hex.addTerrain(tf.createTerrain(Terrains.MUD, 1));</b>
<b class="nc">&nbsp;                        if(hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                            hex.removeTerrain(Terrains.WATER);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //heavy rain - mud in all hexes except buildings, depth 1+ water, and non-dirt roads
&nbsp;                //rapids in all depth 1+ water
<b class="nc">&nbsp;                if ((weatherCond == PlanetaryConditions.WE_HEAVY_RAIN)</b>
&nbsp;                        || (weatherCond == PlanetaryConditions.WE_GUSTING_RAIN)) {
<b class="nc">&nbsp;                    if(hex.containsTerrain(Terrains.WATER) &amp;&amp; !hex.containsTerrain(Terrains.RAPIDS) &amp;&amp; (hex.depth() &gt; 0)) {</b>
<b class="nc">&nbsp;                        hex.addTerrain(tf.createTerrain(Terrains.RAPIDS, 1));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    else if(!hex.containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                            &amp;&amp; !hex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                            &amp;&amp; !hex.containsTerrain(Terrains.ROAD)) {</b>
<b class="nc">&nbsp;                        hex.addTerrain(tf.createTerrain(Terrains.MUD, 1));</b>
<b class="nc">&nbsp;                        if(hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                            hex.removeTerrain(Terrains.WATER);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //torrential downpour - mud in all hexes except buildings, depth 1+ water, and non-dirt roads
&nbsp;                //torrent in all depth 1+ water, swamps in all depth 0 water hexes
<b class="nc">&nbsp;                if(weatherCond == PlanetaryConditions.WE_DOWNPOUR) {</b>
<b class="nc">&nbsp;                    if(hex.containsTerrain(Terrains.WATER) &amp;&amp; !(hex.terrainLevel(Terrains.RAPIDS) &gt; 1) &amp;&amp; (hex.depth() &gt; 0)) {</b>
<b class="nc">&nbsp;                        hex.addTerrain(tf.createTerrain(Terrains.RAPIDS, 2));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    else if(hex.containsTerrain(Terrains.WATER)) {</b>
<b class="nc">&nbsp;                        hex.addTerrain(tf.createTerrain(Terrains.SWAMP, 1));</b>
<b class="nc">&nbsp;                        hex.removeTerrain(Terrains.WATER);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    else if(!hex.containsTerrain(Terrains.BUILDING)</b>
<b class="nc">&nbsp;                            &amp;&amp; !hex.containsTerrain(Terrains.PAVEMENT)</b>
<b class="nc">&nbsp;                            &amp;&amp; !hex.containsTerrain(Terrains.ROAD)) {</b>
<b class="nc">&nbsp;                        hex.addTerrain(tf.createTerrain(Terrains.MUD, 1));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //check for rapids/torrents created by wind
<b class="nc">&nbsp;                if((windCond &gt; PlanetaryConditions.WI_MOD_GALE)</b>
<b class="nc">&nbsp;                        &amp;&amp; hex.containsTerrain(Terrains.WATER) &amp;&amp; (hex.depth() &gt; 0)) {</b>
&nbsp;
<b class="nc">&nbsp;                    if(windCond &gt; PlanetaryConditions.WI_STORM) {</b>
<b class="nc">&nbsp;                        if(!(hex.terrainLevel(Terrains.RAPIDS) &gt; 1)) {</b>
<b class="nc">&nbsp;                            hex.addTerrain(tf.createTerrain(Terrains.RAPIDS, 2));</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        if(!hex.containsTerrain(Terrains.RAPIDS)) {</b>
<b class="nc">&nbsp;                            hex.addTerrain(tf.createTerrain(Terrains.RAPIDS, 1));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Generates the elevations
&nbsp;     *
&nbsp;     * @param hilliness The Hilliness
&nbsp;     * @param width The Width of the map.
&nbsp;     * @param height The Height of the map.
&nbsp;     * @param range Max difference betweenn highest and lowest level.
&nbsp;     * @param invertProb Probability for the invertion of the map (0..100)
&nbsp;     * @param invertNegative If 1, invert negative hexes, else do nothing
&nbsp;     * @param elevationMap here is the result stored
&nbsp;     */
&nbsp;    public static void generateElevation(int hilliness, int width, int height,
&nbsp;            int range, int invertProb, int invertNegative,
&nbsp;            int elevationMap[][], int algorithm) {
<b class="nc">&nbsp;        int minLevel = 0;</b>
<b class="nc">&nbsp;        int maxLevel = range;</b>
<b class="nc">&nbsp;        boolean invert = (Compute.randomInt(100) &lt; invertProb);</b>
&nbsp;
&nbsp;        /* init elevation map with 0 */
<b class="nc">&nbsp;        for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;            for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                elevationMap[w][h] = 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        /* generate landscape */
<b class="nc">&nbsp;        switch (algorithm) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                cutSteps(hilliness, width, height, elevationMap);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                midPoint(hilliness, width, height, elevationMap);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                cutSteps(hilliness, width, height, elevationMap);</b>
<b class="nc">&nbsp;                midPoint(hilliness, width, height, elevationMap);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;                // Non-hardcoded generators, if we have any
<b class="nc">&nbsp;                if((algorithm &gt; 2) &amp;&amp; (algorithm - 3 &lt; elevationGenerators.size())) {</b>
<b class="nc">&nbsp;                    elevationGenerators.get(algorithm - 3).generate(hilliness, width, height, elevationMap);</b>
&nbsp;                }
&nbsp;        }
&nbsp;
&nbsp;        /* and now normalize it */
<b class="nc">&nbsp;        int min = elevationMap[0][0];</b>
<b class="nc">&nbsp;        int max = elevationMap[0][0];</b>
<b class="nc">&nbsp;        for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;            for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                if (elevationMap[w][h] &gt; max) {</b>
<b class="nc">&nbsp;                    max = elevationMap[w][h];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (elevationMap[w][h] &lt; min) {</b>
<b class="nc">&nbsp;                    min = elevationMap[w][h];</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double scale = (double) (maxLevel - minLevel) / (double) (max - min);</b>
<b class="nc">&nbsp;        int inc = (int) (-scale * min + minLevel);</b>
<b class="nc">&nbsp;        int[] elevationCount = new int[maxLevel + 1];</b>
<b class="nc">&nbsp;        for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;            for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                elevationMap[w][h] *= scale;</b>
<b class="nc">&nbsp;                elevationMap[w][h] += inc;</b>
<b class="nc">&nbsp;                elevationCount[elevationMap[w][h]]++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        int mostElevation = 0;</b>
<b class="nc">&nbsp;        for (int lvl = 1; lvl &lt;= range; lvl++) {</b>
<b class="nc">&nbsp;            if (elevationCount[lvl] &gt; elevationCount[mostElevation]) {</b>
<b class="nc">&nbsp;                mostElevation = lvl;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;            for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                elevationMap[w][h] -= mostElevation;</b>
<b class="nc">&nbsp;                if (invert) {</b>
<b class="nc">&nbsp;                    elevationMap[w][h] *= -1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // invert negative terrain?
<b class="nc">&nbsp;        if (invertNegative == 1) {</b>
<b class="nc">&nbsp;            for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;                for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                    if (elevationMap[w][h] &lt; 0) {</b>
<b class="nc">&nbsp;                        elevationMap[w][h] *= -1;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static void generateMountain(IBoard board, int width, Coords centre,
&nbsp;            int height, int capStyle) {
<b class="nc">&nbsp;        final int mapW = board.getWidth();</b>
<b class="nc">&nbsp;        final int mapH = board.getHeight();</b>
&nbsp;
<b class="nc">&nbsp;        ITerrainFactory tf = Terrains.getTerrainFactory();</b>
&nbsp;
<b class="nc">&nbsp;        for (int x = 0; x &lt; mapW; x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; mapH; y++) {</b>
<b class="nc">&nbsp;                Coords c = new Coords(x, y);</b>
<b class="nc">&nbsp;                int distance = c.distance(centre);</b>
<b class="nc">&nbsp;                int elev = (100 * height * (width - distance)) / width;</b>
<b class="nc">&nbsp;                elev = (elev / 100)</b>
<b class="nc">&nbsp;                        + (Compute.randomInt(100) &lt; (elev % 100) ? 1 : 0);</b>
&nbsp;
<b class="nc">&nbsp;                IHex hex = board.getHex(c);</b>
&nbsp;
<b class="nc">&nbsp;                if (elev &gt;= height - 2) {</b>
<b class="nc">&nbsp;                    switch (capStyle) {</b>
&nbsp;                        case MapSettings.MOUNTAIN_SNOWCAPPED:
<b class="nc">&nbsp;                            hex.setTheme(&quot;snow&quot;);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case MapSettings.MOUNTAIN_VOLCANO_ACTIVE:
&nbsp;                        case MapSettings.MOUNTAIN_VOLCANO_DORMANT:
<b class="nc">&nbsp;                            hex.setTheme(&quot;lunar&quot;);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case MapSettings.MOUNTAIN_LAKE:
<b class="nc">&nbsp;                            int lake = (width / 4);</b>
<b class="nc">&nbsp;                            int depth = ((lake - distance) + 1);</b>
<b class="nc">&nbsp;                            if (depth &lt; 1) { // eliminates depth 0 water</b>
<b class="nc">&nbsp;                                depth = 1;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            hex.addTerrain(tf.createTerrain(Terrains.WATER,</b>
&nbsp;                                    (depth)));
<b class="nc">&nbsp;                            elev -= (Math.abs(lake - elev) - 1);</b>
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (elev == height) {</b>
&nbsp;                    // for volcanoes, invert the peak
<b class="nc">&nbsp;                    switch (capStyle) {</b>
&nbsp;                        case MapSettings.MOUNTAIN_VOLCANO_ACTIVE:
<b class="nc">&nbsp;                            hex.removeAllTerrains();</b>
<b class="nc">&nbsp;                            hex.addTerrain(tf.createTerrain(Terrains.MAGMA, 2));</b>
<b class="nc">&nbsp;                            elev -= 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case MapSettings.MOUNTAIN_VOLCANO_DORMANT:
<b class="nc">&nbsp;                            hex.removeAllTerrains();</b>
<b class="nc">&nbsp;                            hex.addTerrain(tf.createTerrain(Terrains.MAGMA, 1));</b>
<b class="nc">&nbsp;                            elev -= 2;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case MapSettings.MOUNTAIN_VOLCANO_EXTINCT:
<b class="nc">&nbsp;                            hex.setTheme(&quot;lunar&quot;);</b>
<b class="nc">&nbsp;                            elev -= 2;</b>
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (hex.getLevel() &lt; elev) {</b>
<b class="nc">&nbsp;                    hex.setLevel(elev);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flips the board around the vertical axis (North-for-South) and/or the
&nbsp;     * horizontal axis (East-for-West). The dimensions of the board will remain
&nbsp;     * the same, but the terrain of the hexes will be swiched.
&nbsp;     *
&nbsp;     * @param horiz - a &lt;code&gt;boolean&lt;/code&gt; value that, if &lt;code&gt;true&lt;/code&gt;,
&nbsp;     *            indicates that the board is being flipped North-for-South.
&nbsp;     * @param vert - a &lt;code&gt;boolean&lt;/code&gt; value that, if &lt;code&gt;true&lt;/code&gt;,
&nbsp;     *            indicates that the board is being flipped East-for-West.
&nbsp;     */
&nbsp;    public static void flip(IBoard board, boolean horiz, boolean vert) {
&nbsp;        // If we&#39;re not flipping around *some* axis, do nothing.
<b class="nc">&nbsp;        if (!vert &amp;&amp; !horiz) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // We only walk through half the board, but *which* half?
&nbsp;        int stopX;
&nbsp;        int stopY;
<b class="nc">&nbsp;        int width = board.getWidth();</b>
<b class="nc">&nbsp;        int height = board.getHeight();</b>
&nbsp;
<b class="nc">&nbsp;        if (horiz) {</b>
&nbsp;            // West half of board.
<b class="nc">&nbsp;            stopX = width / 2;</b>
<b class="nc">&nbsp;            stopY = height;</b>
&nbsp;        } else {
&nbsp;            // North half of board.
<b class="nc">&nbsp;            stopX = width;</b>
<b class="nc">&nbsp;            stopY = height / 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Walk through the current data array and build a new one.
&nbsp;        int newX;
&nbsp;        int newY;
&nbsp;        IHex tempHex;
&nbsp;        ITerrain terr;
<b class="nc">&nbsp;        for (int oldX = 0; oldX &lt; stopX; oldX++) {</b>
&nbsp;            // Calculate the new X position of the flipped hex.
<b class="nc">&nbsp;            if (horiz) {</b>
<b class="nc">&nbsp;                newX = width - oldX - 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                newX = oldX;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int oldY = 0; oldY &lt; stopY; oldY++) {</b>
&nbsp;                // Calculate the new Y position of the flipped hex.
<b class="nc">&nbsp;                if (vert) {</b>
<b class="nc">&nbsp;                    newY = height - oldY - 1;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    newY = oldY;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Swap the old hex for the new hex.
<b class="nc">&nbsp;                tempHex = board.getHex(oldX, oldY);</b>
<b class="nc">&nbsp;                board.setHex(oldX, oldY, board.getHex(newX, newY));</b>
<b class="nc">&nbsp;                board.setHex(newX, newY, tempHex);</b>
&nbsp;
<b class="nc">&nbsp;                IHex newHex = board.getHex(newX, newY);</b>
<b class="nc">&nbsp;                IHex oldHex = board.getHex(oldX, oldY);</b>
&nbsp;
&nbsp;                // Update the road exits in the swapped hexes.
<b class="nc">&nbsp;                terr = newHex.getTerrain(Terrains.ROAD);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
<b class="nc">&nbsp;                terr = oldHex.getTerrain(Terrains.ROAD);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Update the building exits in the swapped hexes.
<b class="nc">&nbsp;                terr = newHex.getTerrain(Terrains.BUILDING);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
<b class="nc">&nbsp;                terr = oldHex.getTerrain(Terrains.BUILDING);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Update the fuel tank exits in the swapped hexes.
<b class="nc">&nbsp;                terr = newHex.getTerrain(Terrains.FUEL_TANK);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
<b class="nc">&nbsp;                terr = oldHex.getTerrain(Terrains.FUEL_TANK);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Update the bridge exits in the swapped hexes.
<b class="nc">&nbsp;                terr = newHex.getTerrain(Terrains.BRIDGE);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
<b class="nc">&nbsp;                terr = oldHex.getTerrain(Terrains.BRIDGE);</b>
<b class="nc">&nbsp;                if (null != terr) {</b>
<b class="nc">&nbsp;                    terr.flipExits(horiz, vert);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * one of the landscape generation algorithms
&nbsp;     */
&nbsp;    protected static void cutSteps(int hilliness, int width, int height,
&nbsp;            int elevationMap[][]) {
&nbsp;        Point p1, p2;
&nbsp;        int sideA, sideB;
&nbsp;        int type;
&nbsp;
<b class="nc">&nbsp;        p1 = new Point(0, 0);</b>
<b class="nc">&nbsp;        p2 = new Point(0, 0);</b>
<b class="nc">&nbsp;        for (int step = 0; step &lt; hilliness * 20; step++) {</b>
&nbsp;            /*
&nbsp;             * select which side should be decremented, and which increemented
&nbsp;             */
<b class="nc">&nbsp;            sideA = (Compute.randomInt(2) == 0) ? -1 : 1;</b>
<b class="nc">&nbsp;            sideB = -sideA;</b>
<b class="nc">&nbsp;            type = Compute.randomInt(6);</b>
&nbsp;            /*
&nbsp;             * 6 different lines in rectangular area from border to border
&nbsp;             * possible
&nbsp;             */
<b class="nc">&nbsp;            switch (type) {</b>
&nbsp;                case 0: /* left to upper border */
<b class="nc">&nbsp;                    p1.setLocation(0, Compute.randomInt(height));</b>
<b class="nc">&nbsp;                    p2.setLocation(Compute.randomInt(width), height - 1);</b>
<b class="nc">&nbsp;                    markSides(p1, p2, sideB, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    markRect(p2.x, width, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1: /* upper to lower border */
<b class="nc">&nbsp;                    p1.setLocation(Compute.randomInt(width), 0);</b>
<b class="nc">&nbsp;                    p2.setLocation(Compute.randomInt(width), height - 1);</b>
<b class="nc">&nbsp;                    if (p1.x &lt; p2.x) {</b>
<b class="nc">&nbsp;                        markSides(p1, p2, sideA, sideB, elevationMap, height);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        markSides(p2, p1, sideB, sideA, elevationMap, height);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    markRect(0, p1.x, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    markRect(p2.x, width, sideB, elevationMap, height);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 2: /* upper to right border */
<b class="nc">&nbsp;                    p1.setLocation(Compute.randomInt(width), height - 1);</b>
<b class="nc">&nbsp;                    p2.setLocation(width, Compute.randomInt(height));</b>
<b class="nc">&nbsp;                    markSides(p1, p2, sideB, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    markRect(0, p1.x, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3: /* left to right border */
<b class="nc">&nbsp;                    p1.setLocation(0, Compute.randomInt(height));</b>
<b class="nc">&nbsp;                    p2.setLocation(width, Compute.randomInt(height));</b>
<b class="nc">&nbsp;                    markSides(p1, p2, sideA, sideB, elevationMap, height);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 4: /* left to lower border */
<b class="nc">&nbsp;                    p1.setLocation(0, Compute.randomInt(height));</b>
<b class="nc">&nbsp;                    p2.setLocation(Compute.randomInt(width), 0);</b>
<b class="nc">&nbsp;                    markSides(p1, p2, sideB, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    markRect(p2.x, width, sideB, elevationMap, height);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 5: /* lower to right border */
<b class="nc">&nbsp;                    p1.setLocation(Compute.randomInt(width), 0);</b>
<b class="nc">&nbsp;                    p2.setLocation(width, Compute.randomInt(height));</b>
<b class="nc">&nbsp;                    markSides(p1, p2, sideB, sideA, elevationMap, height);</b>
<b class="nc">&nbsp;                    markRect(0, p1.x, sideB, elevationMap, height);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function for the map generator increased a heightmap my a given
&nbsp;     * value
&nbsp;     */
&nbsp;    protected static void markRect(int x1, int x2, int inc,
&nbsp;            int elevationMap[][], int height) {
<b class="nc">&nbsp;        for (int x = x1; x &lt; x2; x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;                elevationMap[x][y] += inc;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function for map generator inreases all of one side and decreased
&nbsp;     * on other side
&nbsp;     */
&nbsp;    protected static void markSides(Point p1, Point p2, int upperInc,
&nbsp;            int lowerInc, int elevationMap[][], int height) {
<b class="nc">&nbsp;        for (int x = p1.x; x &lt; p2.x; x++) {</b>
<b class="nc">&nbsp;            for (int y = 0; y &lt; height; y++) {</b>
<b class="nc">&nbsp;                int point = (p2.y - p1.y) / (p2.x - p1.x) * (x - p1.x) + p1.y;</b>
<b class="nc">&nbsp;                if (y &gt; point) {</b>
<b class="nc">&nbsp;                    elevationMap[x][y] += upperInc;</b>
<b class="nc">&nbsp;                } else if (y &lt; point) {</b>
<b class="nc">&nbsp;                    elevationMap[x][y] += lowerInc;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * midpoint algorithm for landscape generartion
&nbsp;     */
&nbsp;    protected static void midPoint(int hilliness, int width, int height,
&nbsp;            int elevationMap[][]) {
&nbsp;        int size;
<b class="nc">&nbsp;        int steps = 1;</b>
&nbsp;        int tmpElevation[][];
&nbsp;
<b class="nc">&nbsp;        size = (width &gt; height) ? width : height;</b>
<b class="nc">&nbsp;        while (size &gt; 0) {</b>
<b class="nc">&nbsp;            steps++;</b>
<b class="nc">&nbsp;            size /= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        size = (1 &lt;&lt; steps) + 1;</b>
<b class="nc">&nbsp;        tmpElevation = new int[size + 1][size + 1];</b>
&nbsp;        /* init elevation map with 0 */
<b class="nc">&nbsp;        for (int w = 0; w &lt; size; w++) {</b>
<b class="nc">&nbsp;            for (int h = 0; h &lt; size; h++) {</b>
<b class="nc">&nbsp;                if ((w &lt; width) &amp;&amp; (h &lt; height)) {</b>
<b class="nc">&nbsp;                    tmpElevation[w][h] = elevationMap[w][h];</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    tmpElevation[w][h] = 0;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (int i = steps; i &gt; 0; i--) {</b>
<b class="nc">&nbsp;            midPointStep((double) hilliness / 100, size, 100, tmpElevation, i,</b>
&nbsp;                    true);
&nbsp;        }
<b class="nc">&nbsp;        for (int w = 0; w &lt; width; w++) {</b>
<b class="nc">&nbsp;            for (int h = 0; h &lt; height; h++) {</b>
<b class="nc">&nbsp;                elevationMap[w][h] = tmpElevation[w][h];</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function for landscape generation
&nbsp;     */
&nbsp;    protected static void midPointStep(double fracdim, int size, int delta,
&nbsp;            int elevationMap[][], int step, boolean newBorder) {
&nbsp;        int d1, d2;
&nbsp;        int delta5;
&nbsp;        int x, y;
&nbsp;
<b class="nc">&nbsp;        d1 = size &gt;&gt; (step - 1);</b>
<b class="nc">&nbsp;        d2 = d1 / 2;</b>
<b class="nc">&nbsp;        fracdim = (1.0 - fracdim) / 2.0;</b>
<b class="nc">&nbsp;        delta = (int) (delta * Math.exp(-0.6931 * fracdim * (2.0 * step - 1)));</b>
<b class="nc">&nbsp;        delta5 = delta &lt;&lt; 5;</b>
<b class="nc">&nbsp;        x = d2;</b>
&nbsp;        do {
<b class="nc">&nbsp;            y = d2;</b>
&nbsp;            do {
<b class="nc">&nbsp;                elevationMap[x][y] = middleValue(elevationMap[x + d2][y + d2],</b>
&nbsp;                        elevationMap[x + d2][y - d2], elevationMap[x - d2][y
&nbsp;                                + d2], elevationMap[x - d2][y - d2], delta5);
<b class="nc">&nbsp;                y += d1;</b>
<b class="nc">&nbsp;            } while (y &lt; size - d2);</b>
<b class="nc">&nbsp;            x += d1;</b>
<b class="nc">&nbsp;        } while (x &lt; size - d2);</b>
&nbsp;
<b class="nc">&nbsp;        delta = (int) (delta * Math.exp(-0.6931 * fracdim));</b>
<b class="nc">&nbsp;        delta5 = delta &lt;&lt; 5;</b>
<b class="nc">&nbsp;        if (newBorder) {</b>
<b class="nc">&nbsp;            x = d2;</b>
&nbsp;            do {
<b class="nc">&nbsp;                y = x;</b>
<b class="nc">&nbsp;                elevationMap[0][x] = middleValue(elevationMap[0][x + d2],</b>
&nbsp;                        elevationMap[0][x - d2], elevationMap[d2][x], delta5);
<b class="nc">&nbsp;                elevationMap[size][x] = middleValue(elevationMap[size - 1][x</b>
&nbsp;                        + d2], elevationMap[size - 1][x - d2],
&nbsp;                        elevationMap[size - d2 - 1][x], delta5);
<b class="nc">&nbsp;                y = 0;</b>
<b class="nc">&nbsp;                elevationMap[x][0] = middleValue(elevationMap[x + d2][0],</b>
&nbsp;                        elevationMap[x - d2][0], elevationMap[x][d2], delta5);
<b class="nc">&nbsp;                elevationMap[x][size] = middleValue(</b>
&nbsp;                        elevationMap[x + d2][size - 1],
&nbsp;                        elevationMap[x - d2][size - 1], elevationMap[x][size
&nbsp;                                - d2 - 1], delta5);
<b class="nc">&nbsp;                x += d1;</b>
<b class="nc">&nbsp;            } while (x &lt; size - d2);</b>
&nbsp;        }
<b class="nc">&nbsp;        diagMid(new Point(d2, d1), d1, d2, delta5, size, elevationMap);</b>
<b class="nc">&nbsp;        diagMid(new Point(d1, d2), d1, d2, delta5, size, elevationMap);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * calculates the diagonal middlepoints with new values
&nbsp;     *
&nbsp;     * @param p Starting point.
&nbsp;     */
&nbsp;    protected static void diagMid(Point p, int d1, int d2, int delta, int size,
&nbsp;            int elevationMap[][]) {
<b class="nc">&nbsp;        int x = p.x;</b>
&nbsp;        int y;
<b class="nc">&nbsp;        int hx = x + d2;</b>
&nbsp;        int hy;
&nbsp;
<b class="nc">&nbsp;        while ((x &lt; size - d2) &amp;&amp; (hx &lt; size)) {</b>
<b class="nc">&nbsp;            y = p.y;</b>
<b class="nc">&nbsp;            hy = y + d2;</b>
<b class="nc">&nbsp;            while ((y &lt; size - d2) &amp;&amp; (hy &lt; size)) {</b>
<b class="nc">&nbsp;                elevationMap[x][y] = middleValue(elevationMap[x][hy],</b>
&nbsp;                        elevationMap[x][y - d2], elevationMap[hx][y],
&nbsp;                        elevationMap[x - d2][y], delta);
<b class="nc">&nbsp;                y += d1;</b>
<b class="nc">&nbsp;                hy = y + d2;</b>
&nbsp;            }
<b class="nc">&nbsp;            x += d1;</b>
<b class="nc">&nbsp;            hx = x + d2;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * calculates the arithmetic medium of 3 values and add random value in
&nbsp;     * range of delta.
&nbsp;     */
&nbsp;    protected static int middleValue(int a, int b, int c, int delta) {
<b class="nc">&nbsp;        int result = (((a + b + c) / 3) + normRNG(delta));</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * calculates the arithmetic medium of 4 values and add random value in
&nbsp;     * range of delta.
&nbsp;     */
&nbsp;    protected static int middleValue(int a, int b, int c, int d, int delta) {
<b class="nc">&nbsp;        int result = (((a + b + c + d) / 4) + normRNG(delta));</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gives a normal distributed Randomvalue, with mediumvalue from 0 and a
&nbsp;     * Varianz of factor.
&nbsp;     *
&nbsp;     * @param factor varianz of of the distribution.
&nbsp;     * @return Random number, most times in the range -factor .. +factor, at
&nbsp;     *         most in the range of -3*factor .. +3*factor.
&nbsp;     */
&nbsp;    private static int normRNG(int factor) {
<b class="nc">&nbsp;        factor++;</b>
<b class="nc">&nbsp;        return (2 * (Compute.randomInt(factor) + Compute.randomInt(factor) + Compute</b>
<b class="nc">&nbsp;                .randomInt(factor)) - 3 * (factor - 1)) / 32;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Figures out the &quot;closest&quot; edge for the given entity on the entity&#39;s game board
&nbsp;     * @param entity Entity to evaluate
&nbsp;     * @return the Board.START_ constant representing the &quot;closest&quot; edge
&nbsp;     */
&nbsp;    public static CardinalEdge getClosestEdge(Entity entity) {
<b class="nc">&nbsp;        int distanceToWest = entity.getPosition().getX();</b>
<b class="nc">&nbsp;        int distanceToEast = entity.getGame().getBoard().getWidth() - entity.getPosition().getX();</b>
<b class="nc">&nbsp;        int distanceToNorth = entity.getPosition().getY();</b>
<b class="nc">&nbsp;        int distanceToSouth = entity.getGame().getBoard().getHeight() - entity.getPosition().getY();</b>
&nbsp;
<b class="nc">&nbsp;        boolean closerWestThanEast = distanceToWest &lt; distanceToEast;</b>
<b class="nc">&nbsp;        boolean closerNorthThanSouth = distanceToNorth &lt; distanceToSouth;</b>
&nbsp;
<b class="nc">&nbsp;        int horizontalDistance = Math.min(distanceToWest, distanceToEast);</b>
<b class="nc">&nbsp;        int verticalDistance = Math.min(distanceToNorth, distanceToSouth);</b>
&nbsp;
<b class="nc">&nbsp;        if(horizontalDistance &lt; verticalDistance) {</b>
<b class="nc">&nbsp;            return closerWestThanEast ? CardinalEdge.WEST : CardinalEdge.EAST;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return closerNorthThanSouth ? CardinalEdge.NORTH : CardinalEdge.SOUTH;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Figures out the &quot;opposite&quot; edge for the given entity.
&nbsp;     * @param entity Entity to evaluate
&nbsp;     * @return the Board.START_ constant representing the &quot;opposite&quot; edge
&nbsp;     */
&nbsp;    public static CardinalEdge determineOppositeEdge(Entity entity) {
<b class="nc">&nbsp;        IBoard board = entity.getGame().getBoard();</b>
&nbsp;
&nbsp;        // the easiest part is if the entity is supposed to start on a particular edge. Just return the opposite edge.
<b class="nc">&nbsp;        int oppositeEdge = board.getOppositeEdge(entity.getStartingPos());</b>
<b class="nc">&nbsp;        if (oppositeEdge != Board.START_NONE) {</b>
<b class="nc">&nbsp;            return CardinalEdge.getCardinalEdge(OffBoardDirection.translateBoardStart(oppositeEdge));</b>
&nbsp;        }
&nbsp;
&nbsp;        // otherwise, we determine which edge of the board is closest to current position and return the opposite edge
&nbsp;        // in case of tie, vertical distance wins over horizontal distance
<b class="nc">&nbsp;        CardinalEdge closestEdge = getClosestEdge(entity);</b>
<b class="nc">&nbsp;        return CardinalEdge.getOppositeEdge(closestEdge);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected static class Point {
&nbsp;
&nbsp;        public int x;
&nbsp;        public int y;
&nbsp;
<b class="nc">&nbsp;        public Point(int x, int y) {</b>
<b class="nc">&nbsp;            this.x = x;</b>
<b class="nc">&nbsp;            this.y = y;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public Point(Point other) {</b>
<b class="nc">&nbsp;            x = other.x;</b>
<b class="nc">&nbsp;            y = other.y;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Set the location
&nbsp;         *
&nbsp;         * @param x x coordinate
&nbsp;         * @param y y coordinate
&nbsp;         */
&nbsp;        public void setLocation(int x, int y) {
<b class="nc">&nbsp;            this.x = x;</b>
<b class="nc">&nbsp;            this.y = y;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
