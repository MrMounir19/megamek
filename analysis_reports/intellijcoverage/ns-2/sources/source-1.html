


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Client</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client</a>
</div>

<h1>Coverage Summary for Class: Client (megamek.client)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Client</td>
<td class="coverageStat">
  <span class="percent">
    4.1%
  </span>
  <span class="absValue">
    (5/121)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.3%
  </span>
  <span class="absValue">
    (33/766)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Client$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Client$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Client$1$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Client$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Client$ConnectionHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$0JiNmtY5</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$0kT7IGZg</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$16T95xtH</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$1ET0xhRf</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$1VGZHKGA</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$23pDWF82</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$2JNgQROB</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$3LC6LWds</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$3PauNdOj</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$42o07kH9</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$4Ujmk4Kp</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$4XEGIo8J</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$4yyCkRyZ</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$5OJCMiNP</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$6odLfkUV</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$74Nfqnoy</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$7dVQxH18</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$7R6msKaT</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$88h4hfVl</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$8coSRGH5</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$9jNcnr3K</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$a9mqkzZ2</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$AcghAGW2</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ACqbPN6A</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$AEF49Mwv</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$aekWWPk5</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ahRSpY6T</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$AiC96LXp</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$apfArImV</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$bkqPmdZ6</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$bqIoglE7</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$cfhdTRpg</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$Cgvg3lcb</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$CiVPa25L</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$CPyeTrLu</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$D4uail7F</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$dC0IkcA6</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$dcnDyovV</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$dF6JIW3f</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$dotOpXTJ</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$dSyDEcWz</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$dzV82yD9</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$e9Keh0PS</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$EcXNHAPT</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$EHw4pCpr</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$fDjLh9d3</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$fkIaz4Rr</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$FNG2Vn0N</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$FnUXm7kr</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$fOqbDrr1</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$fsS0bX4U</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$goUuRI1g</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$HB6ioh5c</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$HnkarmxO</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$hp5ynrQL</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$hqE8Cg9Q</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$Hybfh1oL</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ijJbQ2TB</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ItRtUkob</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$JBFb129C</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$jhlbfB3a</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$jiKxDI37</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$jINWixdx</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$jMcDiuqG</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$jzEZlTUu</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ke2GV1bs</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$lA0T2gjm</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$lfXtAKVH</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$lh7GqUw8</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$LmUKfvSQ</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$lptzQYzW</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$LzuGjvJc</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$m8JqCwZc</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$MLUeCNIs</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$mqRJqzqz</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$mQYpCyHY</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$MTdU5Qnl</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$nfAaPQ0w</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$NFkd4kn1</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$nL4EZlCL</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$nMitB0wD</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$oBsw4otD</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$oseqSKir</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$p2Cd0JWG</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$p6VGSIYB</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$pAoBznVB</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$pwpxmHDf</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$PZqchh23</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$qN6DrjSN</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$qxl7PhBu</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$R3Da3aVc</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$rbX6s4Hr</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$RETqoVAF</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$S7TYCXiu</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$SKv2N0uW</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$Sxs4uh6d</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$tAfgTE5Y</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$tbpuoLOO</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$U9F6URKF</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$up2hCMv9</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$UU5ndkGW</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$vdENh9j0</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$wActWRDA</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$WCxbG2y0</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$wf1WxOgL</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$xZY4ks6w</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$yAlFCANn</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$YMs446F7</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$yuywKpgi</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$YYLENVCh</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ZRJEs9lY</td>
  </tr>
  <tr>
    <td class="name">Client$MockitoMock$614823384$auxiliary$ZxkytVdC</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    4.5%
  </span>
  <span class="absValue">
    (6/132)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.3%
  </span>
  <span class="absValue">
    (34/788)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; * Copyright © 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.client;
&nbsp;
&nbsp;import java.awt.*;
&nbsp;import java.awt.image.RenderedImage;
&nbsp;import java.io.*;
&nbsp;import java.util.*;
&nbsp;import java.util.List;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.zip.GZIPInputStream;
&nbsp;
&nbsp;import javax.imageio.ImageIO;
&nbsp;import javax.swing.*;
&nbsp;
&nbsp;
&nbsp;import com.thoughtworks.xstream.XStream;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.client.commands.AddBotCommand;
&nbsp;import megamek.client.commands.AssignNovaNetworkCommand;
&nbsp;import megamek.client.commands.ClientCommand;
&nbsp;import megamek.client.commands.DeployCommand;
&nbsp;import megamek.client.commands.FireCommand;
&nbsp;import megamek.client.commands.HelpCommand;
&nbsp;import megamek.client.commands.MoveCommand;
&nbsp;import megamek.client.commands.RulerCommand;
&nbsp;import megamek.client.commands.ShowEntityCommand;
&nbsp;import megamek.client.commands.ShowTileCommand;
&nbsp;import megamek.client.commands.SitrepCommand;
&nbsp;import megamek.client.generator.RandomSkillsGenerator;
&nbsp;import megamek.client.generator.RandomUnitGenerator;
&nbsp;import megamek.client.ui.IClientCommandHandler;
&nbsp;import megamek.client.ui.swing.GUIPreferences;
&nbsp;import megamek.client.ui.swing.boardview.BoardView1;
&nbsp;import megamek.common.*;
&nbsp;import megamek.common.Building.DemolitionCharge;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.ClubAttackAction;
&nbsp;import megamek.common.actions.DodgeAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.FlipArmsAction;
&nbsp;import megamek.common.actions.TorsoTwistAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.event.GameBoardChangeEvent;
&nbsp;import megamek.common.event.GameCFREvent;
&nbsp;import megamek.common.event.GameEntityChangeEvent;
&nbsp;import megamek.common.event.GamePlayerChatEvent;
&nbsp;import megamek.common.event.GamePlayerDisconnectedEvent;
&nbsp;import megamek.common.event.GameReportEvent;
&nbsp;import megamek.common.event.GameSettingsChangeEvent;
&nbsp;import megamek.common.event.GameVictoryEvent;
&nbsp;import megamek.common.net.ConnectionFactory;
&nbsp;import megamek.common.net.ConnectionListenerAdapter;
&nbsp;import megamek.common.net.DisconnectedEvent;
&nbsp;import megamek.common.net.IConnection;
&nbsp;import megamek.common.net.Packet;
&nbsp;import megamek.common.net.PacketReceivedEvent;
&nbsp;import megamek.common.options.GameOptions;
&nbsp;import megamek.common.options.IBasicOption;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;import megamek.common.util.ImageUtil;
&nbsp;import megamek.common.util.SerializationHelper;
&nbsp;import megamek.common.util.StringUtil;
&nbsp;import megamek.server.SmokeCloud;
&nbsp;
&nbsp;/**
&nbsp; * This class is instanciated for each client and for each bot running on that
&nbsp; * client. non-local clients are not also instantiated on the local server.
&nbsp; */
<b class="fc">&nbsp;public class Client implements IClientCommandHandler {</b>
&nbsp;    public static final String CLIENT_COMMAND = &quot;#&quot;;
&nbsp;
&nbsp;    // we need these to communicate with the server
&nbsp;    private String name;
&nbsp;
&nbsp;    private IConnection connection;
&nbsp;
&nbsp;    // the hash table of client commands
<b class="fc">&nbsp;    private Hashtable&lt;String, ClientCommand&gt; commandsHash = new Hashtable&lt;&gt;();</b>
&nbsp;
&nbsp;    // some info about us and the server
<b class="fc">&nbsp;    private boolean connected = false;</b>
<b class="fc">&nbsp;    protected int localPlayerNumber = -1;</b>
&nbsp;    private String host;
&nbsp;    private int port;
&nbsp;
&nbsp;    // the game state object
<b class="fc">&nbsp;    protected IGame game = new Game();</b>
&nbsp;
&nbsp;    // here&#39;s some game phase stuff
&nbsp;    private MapSettings mapSettings;
&nbsp;    public String phaseReport;
&nbsp;    public String roundReport;
&nbsp;
&nbsp;    // random generatorsI
&nbsp;    private RandomSkillsGenerator rsg;
&nbsp;    // And close client events!
<b class="fc">&nbsp;    private Vector&lt;CloseClientListener&gt; closeClientListeners = new Vector&lt;CloseClientListener&gt;();</b>
&nbsp;
&nbsp;    // we might want to keep a game log...
&nbsp;    private GameLog log;
&nbsp;
<b class="fc">&nbsp;    private Set&lt;BoardDimensions&gt; availableSizes = new TreeSet&lt;BoardDimensions&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private Vector&lt;Coords&gt; artilleryAutoHitHexes = null;</b>
&nbsp;
<b class="fc">&nbsp;    private boolean disconnectFlag = false;</b>
&nbsp;
<b class="fc">&nbsp;    private Hashtable&lt;String, Integer&gt; duplicateNameHash = new Hashtable&lt;String, Integer&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    public Map&lt;String, Client&gt; bots = new TreeMap&lt;String, Client&gt;(StringUtil.stringComparator());</b>
&nbsp;
&nbsp;    //Hashtable for storing image tags containing base64Text src
&nbsp;    private Hashtable&lt;Integer, String&gt; imgCache;
&nbsp;
&nbsp;    //board view for getting entity art assets
&nbsp;    private BoardView1 bv;
&nbsp;
&nbsp;    ConnectionHandler packetUpdate;
&nbsp;
<b class="nc">&nbsp;    private class ConnectionHandler implements Runnable {</b>
&nbsp;
<b class="nc">&nbsp;        boolean shouldStop = false;</b>
&nbsp;
&nbsp;        public void signalStop() {
<b class="nc">&nbsp;            shouldStop = true;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public void run() {
<b class="nc">&nbsp;            while (!shouldStop) {</b>
&nbsp;                // Write any queued packets
<b class="nc">&nbsp;                flushConn();</b>
&nbsp;                // Wait for new input
<b class="nc">&nbsp;                updateConnection();</b>
<b class="nc">&nbsp;                if ((connection == null) || connection.isClosed()) {</b>
<b class="nc">&nbsp;                    shouldStop = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private Thread connThread;
&nbsp;
<b class="fc">&nbsp;    private ConnectionListenerAdapter connectionListener = new ConnectionListenerAdapter() {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Called when it is sensed that a connection has terminated.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void disconnected(DisconnectedEvent e) {
&nbsp;            // We can&#39;t just run this directly, otherwise we open up all sorts
&nbsp;            // of concurrency issues with the AWT event dispatch thread.
&nbsp;            // Instead, if we will have the event dispatch thread handle it,
&nbsp;            // by using SwingUtilities.invokeLater
&nbsp;            // Not running this on the AWT EDT can lead to dead-lock
<b class="nc">&nbsp;            Runnable handlePacketEvent = new Runnable() {</b>
&nbsp;                public void run() {
<b class="nc">&nbsp;                    Client.this.disconnected();</b>
&nbsp;                }
&nbsp;            };
<b class="nc">&nbsp;            SwingUtilities.invokeLater(handlePacketEvent);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void packetReceived(final PacketReceivedEvent e) {
&nbsp;            // We can&#39;t just run this directly, otherwise we open up all sorts
&nbsp;            // of concurrency issues with the AWT event dispatch thread.
&nbsp;            // Instead, if we will have the event dispatch thread handle it,
&nbsp;            // by using SwingUtilities.invokeLater
&nbsp;            // TODO: I don&#39;t think this is really what we should do: ideally
&nbsp;            // Client.handlePacket should play well with the AWT event queue,
&nbsp;            // but nothing appears to really be designed to be thread safe, so
&nbsp;            // this is a reasonable hack for now
<b class="nc">&nbsp;            Runnable handlePacketEvent = new Runnable() {</b>
&nbsp;                public void run() {
<b class="nc">&nbsp;                    handlePacket(e.getPacket());</b>
&nbsp;                }
&nbsp;            };
<b class="nc">&nbsp;            SwingUtilities.invokeLater(handlePacketEvent);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a client which will try to connect. If the connection fails, it
&nbsp;     * will alert the player, free resources and hide the frame.
&nbsp;     *
&nbsp;     * @param name
&nbsp;     *            the player name for this client
&nbsp;     * @param host
&nbsp;     *            the hostname
&nbsp;     * @param port
&nbsp;     *            the host port
&nbsp;     */
<b class="fc">&nbsp;    public Client(String name, String host, int port){</b>
&nbsp;        // construct new client
<b class="fc">&nbsp;        this.name = name;</b>
<b class="fc">&nbsp;        this.host = host;</b>
<b class="fc">&nbsp;        this.port = port;</b>
&nbsp;
<b class="fc">&nbsp;        registerCommand(new HelpCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new MoveCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new RulerCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new ShowEntityCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new FireCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new DeployCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new ShowTileCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new AddBotCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new AssignNovaNetworkCommand(this));</b>
<b class="fc">&nbsp;        registerCommand(new SitrepCommand(this));</b>
&nbsp;
<b class="fc">&nbsp;        rsg = new RandomSkillsGenerator();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int getLocalPlayerNumber() {
<b class="nc">&nbsp;        return localPlayerNumber;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLocalPlayerNumber(int localPlayerNumber) {
<b class="fc">&nbsp;        this.localPlayerNumber = localPlayerNumber;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * call this once to update the connection
&nbsp;     */
&nbsp;    protected void updateConnection() {
<b class="nc">&nbsp;        if (connection != null &amp;&amp; !connection.isClosed()) {</b>
<b class="nc">&nbsp;            connection.update();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setBoardView(BoardView1 bv){
<b class="nc">&nbsp;        this.bv = bv;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Attempt to connect to the specified host
&nbsp;     */
&nbsp;    public boolean connect() {
<b class="nc">&nbsp;        connection = ConnectionFactory.getInstance().createClientConnection(host, port, 1);</b>
<b class="nc">&nbsp;        boolean result = connection.open();</b>
<b class="nc">&nbsp;        if (result) {</b>
<b class="nc">&nbsp;            connection.addConnectionListener(connectionListener);</b>
<b class="nc">&nbsp;            packetUpdate = new ConnectionHandler();</b>
<b class="nc">&nbsp;            connThread = new Thread(packetUpdate, &quot;Client Connection, Player &quot; + name);</b>
<b class="nc">&nbsp;            connThread.start();</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shuts down threads and sockets
&nbsp;     */
&nbsp;    public synchronized void die() {
&nbsp;        // If we&#39;re still connected, tell the server that we&#39;re going down.
<b class="nc">&nbsp;        if (connected) {</b>
&nbsp;            // Stop listening for in coming packets, this should be done before
&nbsp;            // sending the close connection command
<b class="nc">&nbsp;            packetUpdate.signalStop();</b>
<b class="nc">&nbsp;            connThread.interrupt();</b>
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_CLOSE_CONNECTION));</b>
<b class="nc">&nbsp;            flushConn();</b>
&nbsp;        }
<b class="nc">&nbsp;        connected = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (connection != null) {</b>
<b class="nc">&nbsp;            connection.close();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; closeClientListeners.size(); i++) {</b>
<b class="nc">&nbsp;            closeClientListeners.elementAt(i).clientClosed();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (log != null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                log.close();</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                System.err.print(&quot;Exception closing logfile: &quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                e.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(&quot;client: died&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        System.out.flush();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The client has become disconnected from the server
&nbsp;     */
&nbsp;    protected void disconnected() {
<b class="nc">&nbsp;        if (!disconnectFlag) {</b>
<b class="nc">&nbsp;            disconnectFlag = true;</b>
<b class="nc">&nbsp;            if (connected) {</b>
<b class="nc">&nbsp;                die();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!host.equals(&quot;localhost&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                game.processGameEvent(new GamePlayerDisconnectedEvent(this, getLocalPlayer()));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get hexes designated for automatic artillery hits.
&nbsp;     */
&nbsp;    public Vector&lt;Coords&gt; getArtilleryAutoHit() {
<b class="nc">&nbsp;        return artilleryAutoHitHexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initGameLog() {
&nbsp;        // log = new GameLog(
&nbsp;        // PreferenceManager.getClientPreferences().getGameLogFilename(),
&nbsp;        // false,
&nbsp;        // (new
&nbsp;        // Integer(PreferenceManager.getClientPreferences().getGameLogMaxSize()).longValue()
&nbsp;        // * 1024 * 1024) );
<b class="nc">&nbsp;        log = new GameLog(PreferenceManager.getClientPreferences().getGameLogFilename());</b>
<b class="nc">&nbsp;        log.append(&quot;&lt;html&gt;&lt;body&gt;&quot;);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called to determine whether the game log should be kept.
&nbsp;     * &lt;p&gt;
&nbsp;     * Default implementation delegates to {@code PreferenceManager.getClientPreferences()}.
&nbsp;     */
&nbsp;    protected boolean keepGameLog() {
<b class="nc">&nbsp;        return PreferenceManager.getClientPreferences().keepGameLog();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return an enumeration of the players in the game
&nbsp;     */
&nbsp;    public Enumeration&lt;IPlayer&gt; getPlayers() {
<b class="nc">&nbsp;        return game.getPlayers();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Entity getEntity(int id) {
<b class="nc">&nbsp;        return game.getEntity(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the individual player assigned the index parameter.
&nbsp;     */
&nbsp;    public IPlayer getPlayer(int idx) {
<b class="nc">&nbsp;        return game.getPlayer(idx);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the local player
&nbsp;     */
&nbsp;    public IPlayer getLocalPlayer() {
<b class="nc">&nbsp;        return getPlayer(localPlayerNumber);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the entities that match the
&nbsp;     * selection criteria.
&nbsp;     */
&nbsp;    public Iterator&lt;Entity&gt; getSelectedEntities(EntitySelector selector) {
<b class="nc">&nbsp;        return game.getSelectedEntities(selector);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of first selectable entity
&nbsp;     */
&nbsp;    public int getFirstEntityNum() {
<b class="nc">&nbsp;        return game.getFirstEntityNum(getMyTurn());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the next selectable entity after the one given
&nbsp;     */
&nbsp;    public int getNextEntityNum(int entityId) {
<b class="nc">&nbsp;        return game.getNextEntityNum(getMyTurn(), entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the previous selectable entity after the one given
&nbsp;     */
&nbsp;    public int getPrevEntityNum(int entityId) {
<b class="nc">&nbsp;        return game.getPrevEntityNum(getMyTurn(), entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the first deployable entity
&nbsp;     */
&nbsp;    public int getFirstDeployableEntityNum() {
<b class="nc">&nbsp;        return game.getFirstDeployableEntityNum(getMyTurn());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the next deployable entity
&nbsp;     */
&nbsp;    public int getNextDeployableEntityNum(int entityId) {
<b class="nc">&nbsp;        return game.getNextDeployableEntityNum(getMyTurn(), entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shortcut to game.board
&nbsp;     */
&nbsp;    public IBoard getBoard() {
<b class="nc">&nbsp;        return game.getBoard();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an enumeration of the entities in game.entities
&nbsp;     */
&nbsp;    public List&lt;Entity&gt; getEntitiesVector() {
<b class="nc">&nbsp;        return game.getEntitiesVector();</b>
&nbsp;    }
&nbsp;
&nbsp;    public MapSettings getMapSettings() {
<b class="nc">&nbsp;        return mapSettings;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * give the initiative to the next player on the team.
&nbsp;     */
&nbsp;    public void sendNextPlayer() {
<b class="nc">&nbsp;        connection.send(new Packet(Packet.COMMAND_FORWARD_INITIATIVE));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Changes the game phase, and the displays that go along with it.
&nbsp;     */
&nbsp;    public void changePhase(IGame.Phase phase) {
<b class="nc">&nbsp;        game.setPhase(phase);</b>
&nbsp;        // Handle phase-specific items.
<b class="nc">&nbsp;        switch (phase) {</b>
&nbsp;        case PHASE_STARTING_SCENARIO:
&nbsp;        case PHASE_EXCHANGE:
<b class="nc">&nbsp;            sendDone(true);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_DEPLOYMENT:
&nbsp;            // free some memory thats only needed in lounge
<b class="nc">&nbsp;            MechFileParser.dispose();</b>
&nbsp;            // We must do this last, as the name and unit generators can create
&nbsp;            // a new instance if they are running
<b class="nc">&nbsp;            MechSummaryCache.dispose();</b>
<b class="nc">&nbsp;            memDump(&quot;entering deployment phase&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_TARGETING:
<b class="nc">&nbsp;            memDump(&quot;entering targeting phase&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_MOVEMENT:
<b class="nc">&nbsp;            memDump(&quot;entering movement phase&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_OFFBOARD:
<b class="nc">&nbsp;            memDump(&quot;entering offboard phase&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_FIRING:
<b class="nc">&nbsp;            memDump(&quot;entering firing phase&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_PHYSICAL:
<b class="nc">&nbsp;            memDump(&quot;entering physical phase&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case PHASE_LOUNGE:
&nbsp;            try {
<b class="nc">&nbsp;                QuirksHandler.initQuirksList();</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                System.out.println(e);</b>
<b class="nc">&nbsp;                e.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            UnitRoleHandler.initialize();</b>
<b class="nc">&nbsp;            MechSummaryCache.getInstance().addListener(RandomUnitGenerator::getInstance);</b>
<b class="nc">&nbsp;            if (MechSummaryCache.getInstance().isInitialized()) {</b>
<b class="nc">&nbsp;                RandomUnitGenerator.getInstance();</b>
&nbsp;            }
<b class="nc">&nbsp;            duplicateNameHash.clear(); // reset this</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        default:
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the specified close client listener to receive close client events.
&nbsp;     * This is used by external programs running megamek
&nbsp;     *
&nbsp;     * @param l
&nbsp;     *            the game listener.
&nbsp;     */
&nbsp;    public void addCloseClientListener(CloseClientListener l) {
<b class="nc">&nbsp;        closeClientListeners.addElement(l);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * is it my turn?
&nbsp;     */
&nbsp;    public boolean isMyTurn() {
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
<b class="nc">&nbsp;            return game.getTurnForPlayer(localPlayerNumber) != null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return (game.getTurn() != null) &amp;&amp; game.getTurn().isValid(localPlayerNumber, game);</b>
&nbsp;    }
&nbsp;
&nbsp;    public GameTurn getMyTurn() {
<b class="nc">&nbsp;        if (game.isPhaseSimultaneous()) {</b>
<b class="nc">&nbsp;            return game.getTurnForPlayer(localPlayerNumber);</b>
&nbsp;        }
<b class="nc">&nbsp;        return game.getTurn();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can I unload entities stranded on immobile transports?
&nbsp;     */
&nbsp;    public boolean canUnloadStranded() {
<b class="nc">&nbsp;        return (game.getTurn() instanceof GameTurn.UnloadStrandedTurn)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getTurn().isValid(localPlayerNumber, game);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Send command to unload stranded entities to the server
&nbsp;     */
&nbsp;    public void sendUnloadStranded(int[] entityIds) {
<b class="nc">&nbsp;        Object[] data = new Object[1];</b>
<b class="nc">&nbsp;        data[0] = entityIds;</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_UNLOAD_STRANDED, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Change whose turn it is.
&nbsp;     */
&nbsp;    protected void changeTurnIndex(int index, int prevPlayerId) {
<b class="nc">&nbsp;        game.setTurnIndex(index, prevPlayerId);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send mode-change data to the server
&nbsp;     */
&nbsp;    public void sendModeChange(int nEntity, int nEquip, int nMode) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(nEquip), Integer.valueOf(nMode) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_MODECHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send mount-facing-change data to the server
&nbsp;     */
&nbsp;    public void sendMountFacingChange(int nEntity, int nEquip, int nFacing) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(nEquip), Integer.valueOf(nFacing) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_MOUNTED_FACINGCHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send called shot change data to the server
&nbsp;     */
&nbsp;    public void sendCalledShotChange(int nEntity, int nEquip) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(nEquip) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_CALLEDSHOTCHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send system mode-change data to the server
&nbsp;     */
&nbsp;    public void sendSystemModeChange(int nEntity, int nSystem, int nMode) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(nSystem), Integer.valueOf(nMode) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_SYSTEMMODECHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send mode-change data to the server
&nbsp;     */
&nbsp;    public void sendAmmoChange(int nEntity, int nWeapon, int nAmmo) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(nWeapon), Integer.valueOf(nAmmo) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_AMMOCHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send sensor-change data to the server
&nbsp;     */
&nbsp;    public void sendSensorChange(int nEntity, int nSensor) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(nSensor) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_SENSORCHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send sinks-change data to the server
&nbsp;     */
&nbsp;    public void sendSinksChange(int nEntity, int activeSinks) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), Integer.valueOf(activeSinks) };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_SINKSCHANGE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send activate hidden data to the server
&nbsp;     */
&nbsp;    public void sendActivateHidden(int nEntity, IGame.Phase phase) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(nEntity), phase };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_ACTIVATE_HIDDEN, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send movement data for the given entity to the server.
&nbsp;     */
&nbsp;    public void moveEntity(int id, MovePath md) {
<b class="nc">&nbsp;        Object[] data = new Object[2];</b>
&nbsp;
<b class="nc">&nbsp;        data[0] = Integer.valueOf(id);</b>
<b class="nc">&nbsp;        data[1] = md;</b>
&nbsp;
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_MOVE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Maintain backwards compatability.
&nbsp;     *
&nbsp;     * @param id
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; ID of the deployed entity
&nbsp;     * @param c
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; where the entity should be deployed
&nbsp;     * @param nFacing
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; direction the entity should face
&nbsp;     */
&nbsp;    public void deploy(int id, Coords c, int nFacing, int elevation) {
<b class="nc">&nbsp;        this.deploy(id, c, nFacing, elevation, new Vector&lt;Entity&gt;(), false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Deploy an entity at the given coordinates, with the given facing, and
&nbsp;     * starting with the given units already loaded.
&nbsp;     *
&nbsp;     * @param id
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; ID of the deployed entity
&nbsp;     * @param c
&nbsp;     *            - the &lt;code&gt;Coords&lt;/code&gt; where the entity should be deployed
&nbsp;     * @param nFacing
&nbsp;     *            - the &lt;code&gt;int&lt;/code&gt; direction the entity should face
&nbsp;     * @param loadedUnits
&nbsp;     *            - a &lt;code&gt;List&lt;/code&gt; of units that start the game being
&nbsp;     *            transported byt the deployed entity.
&nbsp;     * @param assaultDrop
&nbsp;     *            - true if deployment is an assault drop
&nbsp;     */
&nbsp;    public void deploy(int id, Coords c, int nFacing, int elevation, List&lt;Entity&gt; loadedUnits, boolean assaultDrop) {
<b class="nc">&nbsp;        int packetCount = 6 + loadedUnits.size();</b>
<b class="nc">&nbsp;        int index = 0;</b>
<b class="nc">&nbsp;        Object[] data = new Object[packetCount];</b>
<b class="nc">&nbsp;        data[index++] = Integer.valueOf(id);</b>
<b class="nc">&nbsp;        data[index++] = c;</b>
<b class="nc">&nbsp;        data[index++] = Integer.valueOf(nFacing);</b>
<b class="nc">&nbsp;        data[index++] = Integer.valueOf(elevation);</b>
<b class="nc">&nbsp;        data[index++] = Integer.valueOf(loadedUnits.size());</b>
<b class="nc">&nbsp;        data[index++] = Boolean.valueOf(assaultDrop);</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity ent : loadedUnits) {</b>
<b class="nc">&nbsp;            data[index++] = Integer.valueOf(ent.getId());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_DEPLOY, data));</b>
<b class="nc">&nbsp;        flushConn();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * For ground to air attacks, the ground unit targets the closest hex in the
&nbsp;     * air units flight path. In the case of several equidistant hexes, the
&nbsp;     * attacker gets to choose. This method updates the server with the users
&nbsp;     * choice.
&nbsp;     * 
&nbsp;     * @param targetId
&nbsp;     * @param attackerId
&nbsp;     * @param pos
&nbsp;     */
&nbsp;    public void sendPlayerPickedPassThrough(Integer targetId, Integer attackerId, Coords pos) {
<b class="nc">&nbsp;        Object[] data = new Object[3];</b>
<b class="nc">&nbsp;        data[0] = targetId;</b>
<b class="nc">&nbsp;        data[1] = attackerId;</b>
<b class="nc">&nbsp;        data[2] = pos;</b>
&nbsp;
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_GTA_HEX_SELECT, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send a weapon fire command to the server.
&nbsp;     */
&nbsp;    public void sendAttackData(int aen, Vector&lt;EntityAction&gt; attacks) {
<b class="nc">&nbsp;        Object[] data = new Object[2];</b>
&nbsp;
<b class="nc">&nbsp;        data[0] = aen;</b>
<b class="nc">&nbsp;        data[1] = attacks;</b>
&nbsp;
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_ATTACK, data));</b>
<b class="nc">&nbsp;        flushConn();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send the game options to the server
&nbsp;     */
&nbsp;    public void sendGameOptions(String password, Vector&lt;IBasicOption&gt; options) {
<b class="nc">&nbsp;        final Object[] data = new Object[2];</b>
<b class="nc">&nbsp;        data[0] = password;</b>
<b class="nc">&nbsp;        data[1] = options;</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send the new map selection to the server
&nbsp;     */
&nbsp;    public void sendMapSettings(MapSettings settings) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, settings));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send the new map dimensions to the server
&nbsp;     */
&nbsp;    public void sendMapDimensions(MapSettings settings) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SENDING_MAP_DIMENSIONS, settings));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send the planetary Conditions to the server
&nbsp;     */
&nbsp;    public void sendPlanetaryConditions(PlanetaryConditions conditions) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SENDING_PLANETARY_CONDITIONS, conditions));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Broadcast a general chat message from the local player
&nbsp;     */
&nbsp;    public void sendChat(String message) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_CHAT, message));</b>
<b class="nc">&nbsp;        flushConn();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Broadcast a general chat message from the local player
&nbsp;     */
&nbsp;    public void sendServerChat(int connId, String message) {
<b class="nc">&nbsp;        Object[] data = { message, connId };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_CHAT, data));</b>
<b class="nc">&nbsp;        flushConn();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends a &quot;player done&quot; message to the server.
&nbsp;     */
&nbsp;    public synchronized void sendDone(boolean done) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_PLAYER_READY, done));</b>
<b class="nc">&nbsp;        flushConn();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends a &quot;reroll initiative&quot; message to the server.
&nbsp;     */
&nbsp;    public void sendRerollInitiativeRequest() {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_REROLL_INITIATIVE));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends the info associated with the local player.
&nbsp;     */
&nbsp;    public void sendPlayerInfo() {
<b class="nc">&nbsp;        IPlayer player = game.getPlayer(localPlayerNumber);</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_PLAYER_UPDATE, player));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Reset round deployment packet
&nbsp;     */
&nbsp;    public void sendResetRoundDeployment() {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_RESET_ROUND_DEPLOYMENT));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendEntityWeaponOrderUpdate(Entity entity) {
&nbsp;        Object data[];
<b class="nc">&nbsp;        if (entity.getWeaponSortOrder() == Entity.WeaponSortOrder.CUSTOM) {</b>
<b class="nc">&nbsp;            data = new Object[3];</b>
<b class="nc">&nbsp;            data[2] = entity.getCustomWeaponOrder();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            data = new Object[2];</b>
&nbsp;        }
<b class="nc">&nbsp;        data[0] = entity.getId();</b>
<b class="nc">&nbsp;        data[1] = entity.getWeaponSortOrder();</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_WORDER_UPDATE, data));</b>
<b class="nc">&nbsp;        entity.setWeapOrderChanged(false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;add entity&quot; packet with only one Entity.
&nbsp;     *
&nbsp;     * @param entity
&nbsp;     *            The Entity to add.
&nbsp;     */
&nbsp;    public void sendAddEntity(Entity entity) {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;(1);</b>
<b class="nc">&nbsp;        entities.add(entity);</b>
<b class="nc">&nbsp;        sendAddEntity(entities);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;add entity&quot; packet that contains a collection of Entity
&nbsp;     * objections.
&nbsp;     *
&nbsp;     * @param entities
&nbsp;     *            The collection of Entity objects to add.
&nbsp;     */
&nbsp;    public void sendAddEntity(List&lt;Entity&gt; entities) {
<b class="nc">&nbsp;        for (Entity entity : entities) {</b>
<b class="nc">&nbsp;            checkDuplicateNamesDuringAdd(entity);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_ADD, entities));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;add squadron&quot; packet
&nbsp;     */
&nbsp;    public void sendAddSquadron(FighterSquadron fs, Vector&lt;Integer&gt; fighterIds) {
<b class="nc">&nbsp;        checkDuplicateNamesDuringAdd(fs);</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SQUADRON_ADD, new Object[] { fs, fighterIds }));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;deploy minefields&quot; packet
&nbsp;     */
&nbsp;    public void sendDeployMinefields(Vector&lt;Minefield&gt; minefields) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_DEPLOY_MINEFIELDS, minefields));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends a &quot;set Artillery Autohit Hexes&quot; packet
&nbsp;     */
&nbsp;    public void sendArtyAutoHitHexes(Vector&lt;Coords&gt; hexes) {
<b class="nc">&nbsp;        artilleryAutoHitHexes = hexes; // save for minimap use</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_SET_ARTYAUTOHITHEXES, hexes));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;update entity&quot; packet
&nbsp;     */
&nbsp;    public void sendUpdateEntity(Entity entity) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_UPDATE, entity));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;update entity&quot; packet
&nbsp;     */
&nbsp;    public void sendDeploymentUnload(Entity loader, Entity loaded) {
<b class="nc">&nbsp;        Object data[] = { loader.getId(), loaded.getId() };</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_DEPLOY_UNLOAD, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends an &quot;update custom initiative&quot; packet
&nbsp;     */
&nbsp;    public void sendCustomInit(IPlayer player) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_CUSTOM_INITIATIVE, player));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends a &quot;delete entity&quot; packet
&nbsp;     */
&nbsp;    public void sendDeleteEntity(int id) {
<b class="nc">&nbsp;        ArrayList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(1);</b>
<b class="nc">&nbsp;        ids.add(id);</b>
<b class="nc">&nbsp;        sendDeleteEntities(ids);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendDeleteEntities(List&lt;Integer&gt; ids) {
<b class="nc">&nbsp;        checkDuplicateNamesDuringDelete(ids);</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_REMOVE, ids));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sends a &quot;load entity&quot; packet
&nbsp;     */
&nbsp;    public void sendLoadEntity(int id, int loaderId, int bayNumber) {
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_ENTITY_LOAD, new Object[] { id, loaderId, bayNumber }));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * sends a load game file to the server
&nbsp;     */
&nbsp;    public void sendLoadGame(File f) {
<b class="nc">&nbsp;        try (InputStream is = new GZIPInputStream(new FileInputStream(f))) {</b>
<b class="nc">&nbsp;            game.reset();</b>
&nbsp;            
<b class="nc">&nbsp;            XStream xstream = SerializationHelper.getXStream();            </b>
<b class="nc">&nbsp;            IGame newGame = (IGame) xstream.fromXML(is);</b>
&nbsp;
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_LOAD_GAME, new Object[] { newGame }));</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;            System.out.println(&quot;Can&#39;t find local savegame &quot; + f); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendExplodeBuilding(DemolitionCharge charge) {
<b class="nc">&nbsp;        Object data[] = new Object[1];</b>
<b class="nc">&nbsp;        data[0] = charge;</b>
<b class="nc">&nbsp;        send(new Packet(Packet.COMMAND_BLDG_EXPLODE, data));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Receives player information from the message packet.
&nbsp;     */
&nbsp;    protected void receivePlayerInfo(Packet c) {
<b class="nc">&nbsp;        int pindex = c.getIntValue(0);</b>
<b class="nc">&nbsp;        IPlayer newPlayer = (IPlayer) c.getObject(1);</b>
<b class="nc">&nbsp;        if (getPlayer(newPlayer.getId()) == null) {</b>
<b class="nc">&nbsp;            game.addPlayer(pindex, newPlayer);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            game.setPlayer(pindex, newPlayer);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the turn list from the data in the packet
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveTurns(Packet packet) {
<b class="nc">&nbsp;        game.setTurnVector((List&lt;GameTurn&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the board from the data in the net command.
&nbsp;     */
&nbsp;    protected void receiveBoard(Packet c) {
<b class="nc">&nbsp;        Board newBoard = (Board) c.getObject(0);</b>
<b class="nc">&nbsp;        game.setBoard(newBoard);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the entities from the data in the net command.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveEntities(Packet c) {
<b class="nc">&nbsp;        List&lt;Entity&gt; newEntities = (List&lt;Entity&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;        List&lt;Entity&gt; newOutOfGame = (List&lt;Entity&gt;) c.getObject(1);</b>
&nbsp;        // Replace the entities in the game.
<b class="nc">&nbsp;        game.setEntitiesVector(newEntities);</b>
<b class="nc">&nbsp;        if (newOutOfGame != null) {</b>
<b class="nc">&nbsp;            game.setOutOfGameEntitiesVector(newOutOfGame);</b>
<b class="nc">&nbsp;            for(Entity e: newOutOfGame) {</b>
<b class="nc">&nbsp;                cacheImgTag(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        //cache the image data for the entities
<b class="nc">&nbsp;        for(Entity e: newEntities) {</b>
<b class="nc">&nbsp;            cacheImgTag(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads entity update data from the data in the net command.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveEntityUpdate(Packet c) {
<b class="nc">&nbsp;        int eindex = c.getIntValue(0);</b>
<b class="nc">&nbsp;        Entity entity = (Entity) c.getObject(1);</b>
<b class="nc">&nbsp;        Vector&lt;UnitLocation&gt; movePath = (Vector&lt;UnitLocation&gt;) c.getObject(2);</b>
&nbsp;        // Replace this entity in the game.
<b class="nc">&nbsp;        game.setEntity(eindex, entity, movePath);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void receiveEntityAdd(Packet packet) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Integer&gt; entityIds = (List&lt;Integer&gt;) packet.getObject(0);</b>
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Entity&gt; entities = (List&lt;Entity&gt;) packet.getObject(1);</b>
&nbsp;
<b class="nc">&nbsp;        assert(entityIds.size() == entities.size());</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; entityIds.size(); i++) {</b>
<b class="nc">&nbsp;            assert(entityIds.get(i) == entities.get(i).getId());</b>
&nbsp;        }
<b class="nc">&nbsp;        game.addEntities(entities);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void receiveEntityRemove(Packet packet) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        List&lt;Integer&gt; entityIds = (List&lt;Integer&gt;) packet.getObject(0);</b>
<b class="nc">&nbsp;        int condition = packet.getIntValue(1);</b>
&nbsp;        //create a final image for the entity
<b class="nc">&nbsp;        for(int id: entityIds) {</b>
<b class="nc">&nbsp;            cacheImgTag(game.getEntity(id));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Move the unit to its final resting place.
<b class="nc">&nbsp;        game.removeEntities(entityIds, condition);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveEntityVisibilityIndicator(Packet packet) {
<b class="nc">&nbsp;        Entity e = game.getEntity(packet.getIntValue(0));</b>
<b class="nc">&nbsp;        if (e != null) { // we may not have this entity due to double blind</b>
<b class="nc">&nbsp;            e.setEverSeenByEnemy(packet.getBooleanValue(1));</b>
<b class="nc">&nbsp;            e.setVisibleToEnemy(packet.getBooleanValue(2));</b>
<b class="nc">&nbsp;            e.setDetectedByEnemy(packet.getBooleanValue(3));</b>
<b class="nc">&nbsp;            e.setWhoCanSee((Vector&lt;IPlayer&gt;) packet.getObject(4));</b>
<b class="nc">&nbsp;            e.setWhoCanDetect((Vector&lt;IPlayer&gt;) packet.getObject(5));</b>
&nbsp;            // this next call is only needed sometimes, but we&#39;ll just
&nbsp;            // call it everytime
<b class="nc">&nbsp;            game.processGameEvent(new GameEntityChangeEvent(this, e));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveDeployMinefields(Packet packet) {
<b class="nc">&nbsp;        game.addMinefields((Vector&lt;Minefield&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveSendingMinefields(Packet packet) {
<b class="nc">&nbsp;        game.setMinefields((Vector&lt;Minefield&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveIlluminatedHexes(Packet p) {
<b class="nc">&nbsp;        game.setIlluminatedPositions((HashSet&lt;Coords&gt;) p.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void receiveRevealMinefield(Packet packet) {
<b class="nc">&nbsp;        game.addMinefield((Minefield) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void receiveRemoveMinefield(Packet packet) {
<b class="nc">&nbsp;        game.removeMinefield((Minefield) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveUpdateMinefields(Packet packet) {
&nbsp;        // only update information if you know about the minefield
<b class="nc">&nbsp;        Vector&lt;Minefield&gt; newMines = new Vector&lt;Minefield&gt;();</b>
<b class="nc">&nbsp;        for (Minefield mf : (Vector&lt;Minefield&gt;) packet.getObject(0)) {</b>
<b class="nc">&nbsp;            if (getLocalPlayer().containsMinefield(mf)) {</b>
<b class="nc">&nbsp;                newMines.add(mf);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (newMines.size() &gt; 0) {</b>
<b class="nc">&nbsp;            game.resetMinefieldDensity(newMines);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveBuildingUpdate(Packet packet) {
<b class="nc">&nbsp;        game.getBoard().updateBuildings((Vector&lt;Building&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveBuildingCollapse(Packet packet) {
<b class="nc">&nbsp;        game.getBoard().collapseBuilding((Vector&lt;Coords&gt;) packet.getObject(0));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loads entity firing data from the data in the net command
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void receiveAttack(Packet c) {
<b class="nc">&nbsp;        List&lt;EntityAction&gt; vector = (List&lt;EntityAction&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;        int charge = c.getIntValue(1);</b>
<b class="nc">&nbsp;        boolean addAction = true;</b>
<b class="nc">&nbsp;        for (EntityAction ea : vector) {</b>
<b class="nc">&nbsp;            int entityId = ea.getEntityId();</b>
<b class="nc">&nbsp;            if ((ea instanceof TorsoTwistAction) &amp;&amp; game.hasEntity(entityId)) {</b>
<b class="nc">&nbsp;                TorsoTwistAction tta = (TorsoTwistAction) ea;</b>
<b class="nc">&nbsp;                Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;                entity.setSecondaryFacing(tta.getFacing());</b>
<b class="nc">&nbsp;            } else if ((ea instanceof FlipArmsAction) &amp;&amp; game.hasEntity(entityId)) {</b>
<b class="nc">&nbsp;                FlipArmsAction faa = (FlipArmsAction) ea;</b>
<b class="nc">&nbsp;                Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;                entity.setArmsFlipped(faa.getIsFlipped());</b>
<b class="nc">&nbsp;            } else if ((ea instanceof DodgeAction) &amp;&amp; game.hasEntity(entityId)) {</b>
<b class="nc">&nbsp;                Entity entity = game.getEntity(entityId);</b>
<b class="nc">&nbsp;                entity.dodging = true;</b>
<b class="nc">&nbsp;                addAction = false;</b>
<b class="nc">&nbsp;            } else if (ea instanceof AttackAction) {</b>
&nbsp;                // The equipment type of a club needs to be restored.
<b class="nc">&nbsp;                if (ea instanceof ClubAttackAction) {</b>
<b class="nc">&nbsp;                    ClubAttackAction caa = (ClubAttackAction) ea;</b>
<b class="nc">&nbsp;                    Mounted club = caa.getClub();</b>
<b class="nc">&nbsp;                    club.restore();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (addAction) {</b>
&nbsp;                // track in the appropriate list
<b class="nc">&nbsp;                if (charge == 0) {</b>
<b class="nc">&nbsp;                    game.addAction(ea);</b>
<b class="nc">&nbsp;                } else if (charge == 1) {</b>
<b class="nc">&nbsp;                    game.addCharge((AttackAction) ea);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    // Should be private?
&nbsp;    public String receiveReport(Vector&lt;Report&gt; v) {
<b class="nc">&nbsp;        if (v == null) {</b>
<b class="nc">&nbsp;            return &quot;[null report vector]&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        StringBuffer report = new StringBuffer();</b>
<b class="nc">&nbsp;        for (Report r : v) {</b>
<b class="nc">&nbsp;            report.append(r.getText());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</b>
&nbsp;        //find id stored in spans and extract it
<b class="nc">&nbsp;        Pattern p = Pattern.compile(&quot;&lt;s(.*?)n&gt;&quot;);</b>
<b class="nc">&nbsp;        Matcher m = p.matcher(report.toString());</b>
&nbsp;
&nbsp;        //add all instances to a hashset to prevent duplicates
<b class="nc">&nbsp;        while(m.find()){</b>
<b class="nc">&nbsp;            String cleanedText = m.group(1).replaceAll(&quot;\\D&quot;, &quot;&quot;);</b>
<b class="nc">&nbsp;            if(cleanedText.length() &gt; 0) {</b>
<b class="nc">&nbsp;                set.add(Integer.parseInt(cleanedText));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        String updatedReport = report.toString();</b>
&nbsp;        //loop through the hashset of unique ids and replace the ids with img tags
<b class="nc">&nbsp;        for (int i : set) {</b>
<b class="nc">&nbsp;            if(getCachedImgTag(i) != null) {</b>
<b class="nc">&nbsp;                updatedReport = updatedReport.replace(&quot;&lt;span id=&#39;&quot; + i + &quot;&#39;&gt;&lt;/span&gt;&quot;, getCachedImgTag(i));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return updatedReport;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns the stored &lt;img&gt; tag for given unit id
&nbsp;     */
&nbsp;    private String getCachedImgTag(int id){
<b class="nc">&nbsp;        if (!GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_ROUND_REPORT_SPRITES)</b>
<b class="nc">&nbsp;                || (imgCache == null) || !imgCache.containsKey(id)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return imgCache.get(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hashtable for storing &lt;img&gt; tags containing base64Text src.
&nbsp;     */
&nbsp;    private void cacheImgTag(Entity entity){
&nbsp;
<b class="nc">&nbsp;        if(entity == null) {</b>
<b class="nc">&nbsp;            MegaMek.getLogger().error(&quot;Null entity reference&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (imgCache == null) {</b>
<b class="nc">&nbsp;            imgCache = new Hashtable&lt;&gt;();</b>
<b class="nc">&nbsp;        } else if (imgCache.containsKey(entity.getId())) {</b>
&nbsp;            //remove images that should be refreshed
<b class="nc">&nbsp;            imgCache.remove(entity.getId());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (getTargetImage(entity) != null) {</b>
&nbsp;            //convert image to base64, add to to &lt;img&gt; tag and store in cache
<b class="nc">&nbsp;            Image image = ImageUtil.getScaledImage(getTargetImage(entity), 56, 48);</b>
&nbsp;            try {
&nbsp;                String base64Text;
<b class="nc">&nbsp;                ByteArrayOutputStream baos = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;                ImageIO.write((RenderedImage) image, &quot;png&quot;, baos);</b>
<b class="nc">&nbsp;                baos.flush();</b>
<b class="nc">&nbsp;                base64Text = Base64.getEncoder().encodeToString(baos.toByteArray());</b>
<b class="nc">&nbsp;                baos.close();</b>
<b class="nc">&nbsp;                String img = &quot;&lt;img src=&#39;data:image/png;base64,&quot; + base64Text + &quot;&#39;&gt;&quot;;</b>
<b class="nc">&nbsp;                imgCache.put(entity.getId(), img);</b>
<b class="nc">&nbsp;            } catch (final IOException ioe) {</b>
<b class="nc">&nbsp;                throw new UncheckedIOException(ioe);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the current mech image
&nbsp;     */
&nbsp;    private Image getTargetImage(Entity e){
<b class="nc">&nbsp;        if (bv == null) {</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        } else if (e.isDestroyed()) {</b>
<b class="nc">&nbsp;            return bv.getTilesetManager().wreckMarkerFor(e, -1);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return bv.getTilesetManager().imageFor(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Saves server entity status data to a local file
&nbsp;     */
&nbsp;    private void saveEntityStatus(String sStatus) {
&nbsp;        try {
<b class="nc">&nbsp;            String sLogDir = PreferenceManager.getClientPreferences().getLogDirectory();</b>
<b class="nc">&nbsp;            File logDir = new File(sLogDir);</b>
<b class="nc">&nbsp;            if (!logDir.exists()) {</b>
<b class="nc">&nbsp;                logDir.mkdir();</b>
&nbsp;            }
<b class="nc">&nbsp;            String fileName = &quot;entitystatus.txt&quot;;</b>
<b class="nc">&nbsp;            if (PreferenceManager.getClientPreferences().stampFilenames()) {</b>
<b class="nc">&nbsp;                fileName = StringUtil.addDateTimeStamp(fileName);</b>
&nbsp;            }
<b class="nc">&nbsp;            FileWriter fw = new FileWriter(sLogDir + File.separator + fileName);</b>
<b class="nc">&nbsp;            fw.write(sStatus);</b>
<b class="nc">&nbsp;            fw.flush();</b>
<b class="nc">&nbsp;            fw.close();</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * send the message to the server
&nbsp;     */
&nbsp;    protected void send(Packet packet) {
<b class="nc">&nbsp;        if (connection != null) {</b>
<b class="nc">&nbsp;            connection.send(packet);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Send a Nova CEWS update packet
&nbsp;     *
&nbsp;     * @param ID
&nbsp;     * @param net
&nbsp;     */
&nbsp;    public void sendNovaChange(int ID, String net) {
<b class="nc">&nbsp;        Object[] data = { Integer.valueOf(ID), new String(net) };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendSpecialHexDisplayAppend(Coords c, SpecialHexDisplay shd) {
<b class="nc">&nbsp;        Object[] data = { c, shd };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_SPECIAL_HEX_DISPLAY_APPEND, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendSpecialHexDisplayDelete(Coords c, SpecialHexDisplay shd) {
<b class="nc">&nbsp;        Object[] data = { c, shd };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_SPECIAL_HEX_DISPLAY_DELETE, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * send all buffered packets on their way this should be called after
&nbsp;     * everything which causes us to wait for a reply. For example &quot;done&quot; button
&nbsp;     * presses etc. to make stuff more efficient, this should only be called
&nbsp;     * after a batch of packets is sent,not separately for each packet
&nbsp;     */
&nbsp;    protected void flushConn() {
<b class="nc">&nbsp;        if (connection != null) {</b>
<b class="nc">&nbsp;            connection.flush();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected void handlePacket(Packet c) {
<b class="nc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;client: got null packet&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (c.getCommand()) {</b>
&nbsp;        case Packet.COMMAND_CLOSE_CONNECTION:
<b class="nc">&nbsp;            disconnected();</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SERVER_GREETING:
<b class="nc">&nbsp;            connected = true;</b>
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_CLIENT_NAME, name));</b>
<b class="nc">&nbsp;            Object[] versionData = new Object[2];</b>
<b class="nc">&nbsp;            versionData[0] = MegaMek.VERSION;</b>
<b class="nc">&nbsp;            versionData[1] = MegaMek.getMegaMekSHA256();</b>
<b class="nc">&nbsp;            send(new Packet(Packet.COMMAND_CLIENT_VERSIONS, versionData));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SERVER_CORRECT_NAME:
<b class="nc">&nbsp;            correctName(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_LOCAL_PN:
<b class="nc">&nbsp;            localPlayerNumber = c.getIntValue(0);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_PLAYER_UPDATE:
<b class="nc">&nbsp;            receivePlayerInfo(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_PLAYER_READY:
<b class="nc">&nbsp;            getPlayer(c.getIntValue(0)).setDone(c.getBooleanValue(1));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_PLAYER_ADD:
<b class="nc">&nbsp;            receivePlayerInfo(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_PLAYER_REMOVE:
<b class="nc">&nbsp;            for (Iterator&lt;Client&gt; botIterator = bots.values().iterator(); botIterator.hasNext();) {</b>
<b class="nc">&nbsp;                Client bot = botIterator.next();</b>
<b class="nc">&nbsp;                if (bot.localPlayerNumber == c.getIntValue(0)) {</b>
<b class="nc">&nbsp;                    botIterator.remove();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            game.removePlayer(c.getIntValue(0));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_CHAT:
<b class="nc">&nbsp;            if (log == null) {</b>
<b class="nc">&nbsp;                initGameLog();</b>
&nbsp;            }
<b class="nc">&nbsp;            if ((log != null) &amp;&amp; keepGameLog()) {</b>
<b class="nc">&nbsp;                log.append((String) c.getObject(0));</b>
&nbsp;            }
<b class="nc">&nbsp;            game.processGameEvent(new GamePlayerChatEvent(this, null, (String) c.getObject(0)));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ENTITY_ADD:
<b class="nc">&nbsp;            receiveEntityAdd(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ENTITY_UPDATE:
<b class="nc">&nbsp;            receiveEntityUpdate(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ENTITY_REMOVE:
<b class="nc">&nbsp;            receiveEntityRemove(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR:
<b class="nc">&nbsp;            receiveEntityVisibilityIndicator(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_MINEFIELDS:
<b class="nc">&nbsp;            receiveSendingMinefields(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_ILLUM_HEXES:
<b class="nc">&nbsp;            receiveIlluminatedHexes(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_CLEAR_ILLUM_HEXES:
<b class="nc">&nbsp;            game.clearIlluminatedPositions();</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_UPDATE_MINEFIELDS:
<b class="nc">&nbsp;            receiveUpdateMinefields(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_DEPLOY_MINEFIELDS:
<b class="nc">&nbsp;            receiveDeployMinefields(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_REVEAL_MINEFIELD:
<b class="nc">&nbsp;            receiveRevealMinefield(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_REMOVE_MINEFIELD:
<b class="nc">&nbsp;            receiveRemoveMinefield(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ADD_SMOKE_CLOUD:
<b class="nc">&nbsp;            SmokeCloud cloud = (SmokeCloud) c.getObject(0);</b>
<b class="nc">&nbsp;            game.addSmokeCloud(cloud);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_CHANGE_HEX:
<b class="nc">&nbsp;            game.getBoard().setHex((Coords) c.getObject(0), (IHex) c.getObject(1));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_CHANGE_HEXES:
<b class="nc">&nbsp;            List&lt;Coords&gt; coords = new ArrayList&lt;Coords&gt;((Set&lt;Coords&gt;) c.getObject(0));</b>
<b class="nc">&nbsp;            List&lt;IHex&gt; hexes = new ArrayList&lt;IHex&gt;((Set&lt;IHex&gt;) c.getObject(1));</b>
<b class="nc">&nbsp;            game.getBoard().setHexes(coords, hexes);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_BLDG_UPDATE:
<b class="nc">&nbsp;            receiveBuildingUpdate(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_BLDG_COLLAPSE:
<b class="nc">&nbsp;            receiveBuildingCollapse(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_PHASE_CHANGE:
<b class="nc">&nbsp;            changePhase((IGame.Phase) c.getObject(0));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_TURN:
<b class="nc">&nbsp;            changeTurnIndex(c.getIntValue(0), c.getIntValue(1));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ROUND_UPDATE:
<b class="nc">&nbsp;            game.setRoundCount(c.getIntValue(0));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_TURNS:
<b class="nc">&nbsp;            receiveTurns(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_BOARD:
<b class="nc">&nbsp;            receiveBoard(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_ENTITIES:
<b class="nc">&nbsp;            receiveEntities(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_REPORTS:
&nbsp;        case Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS:
<b class="nc">&nbsp;            phaseReport = receiveReport((Vector&lt;Report&gt;) c.getObject(0));</b>
<b class="nc">&nbsp;            if (keepGameLog()) {</b>
<b class="nc">&nbsp;                if ((log == null) &amp;&amp; (game.getRoundCount() == 1)) {</b>
<b class="nc">&nbsp;                    initGameLog();</b>
&nbsp;                }
<b class="nc">&nbsp;                if (log != null) {</b>
<b class="nc">&nbsp;                    log.append(phaseReport);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            game.addReports((Vector&lt;Report&gt;) c.getObject(0));</b>
<b class="nc">&nbsp;            roundReport = receiveReport(game.getReports(game.getRoundCount()));</b>
<b class="nc">&nbsp;            if (c.getCommand() == Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS) {</b>
<b class="nc">&nbsp;                game.processGameEvent(new GameReportEvent(this, roundReport));</b>
&nbsp;            }
&nbsp;            break;
&nbsp;        case Packet.COMMAND_SENDING_REPORTS_SPECIAL:
<b class="nc">&nbsp;            game.processGameEvent(new GameReportEvent(this, receiveReport((Vector&lt;Report&gt;) c.getObject(0))));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_REPORTS_ALL:
<b class="nc">&nbsp;            Vector&lt;Vector&lt;Report&gt;&gt; allReports = (Vector&lt;Vector&lt;Report&gt;&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;            game.setAllReports(allReports);</b>
<b class="nc">&nbsp;            if (keepGameLog()) {</b>
&nbsp;                // Re-write gamelog.txt from scratch
<b class="nc">&nbsp;                initGameLog();</b>
<b class="nc">&nbsp;                if (log != null) {</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; allReports.size(); i++) {</b>
<b class="nc">&nbsp;                        log.append(receiveReport(allReports.elementAt(i)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            roundReport = receiveReport(game.getReports(game.getRoundCount()));</b>
&nbsp;            // We don&#39;t really have a copy of the phase report at
&nbsp;            // this point, so I guess we&#39;ll just use the round report
&nbsp;            // until the next phase actually completes.
<b class="nc">&nbsp;            phaseReport = roundReport;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ENTITY_ATTACK:
<b class="nc">&nbsp;            receiveAttack(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_GAME_SETTINGS:
<b class="nc">&nbsp;            game.setOptions((GameOptions) c.getObject(0));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_MAP_SETTINGS:
<b class="nc">&nbsp;            mapSettings = (MapSettings) c.getObject(0);</b>
<b class="nc">&nbsp;            mapSettings.adjustPathSeparator();</b>
<b class="nc">&nbsp;            GameSettingsChangeEvent evt = new GameSettingsChangeEvent(this);</b>
<b class="nc">&nbsp;            evt.setMapSettingsOnlyChange(true);</b>
<b class="nc">&nbsp;            game.processGameEvent(evt);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_PLANETARY_CONDITIONS:
<b class="nc">&nbsp;            game.setPlanetaryConditions((PlanetaryConditions) c.getObject(0));</b>
<b class="nc">&nbsp;            game.processGameEvent(new GameSettingsChangeEvent(this));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_TAGINFO:
<b class="nc">&nbsp;            Vector&lt;TagInfo&gt; vti = (Vector&lt;TagInfo&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;            for (TagInfo ti : vti) {</b>
<b class="nc">&nbsp;                game.addTagInfo(ti);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_RESET_TAGINFO:
<b class="nc">&nbsp;            game.resetTagInfo();</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_END_OF_GAME:
<b class="nc">&nbsp;            String sEntityStatus = (String) c.getObject(0);</b>
<b class="nc">&nbsp;            game.end(c.getIntValue(1), c.getIntValue(2));</b>
&nbsp;            // save victory report
<b class="nc">&nbsp;            saveEntityStatus(sEntityStatus);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_ARTILLERYATTACKS:
<b class="nc">&nbsp;            Vector&lt;ArtilleryAttackAction&gt; v = (Vector&lt;ArtilleryAttackAction&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;            game.setArtilleryVector(v);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_FLARES:
<b class="nc">&nbsp;            Vector&lt;Flare&gt; v2 = (Vector&lt;Flare&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;            game.setFlares(v2);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SEND_SAVEGAME:
<b class="nc">&nbsp;            String sFinalFile = (String) c.getObject(0);</b>
<b class="nc">&nbsp;            String sLocalPath = (String) c.getObject(2);</b>
<b class="nc">&nbsp;            String localFile = sLocalPath + File.separator + sFinalFile;</b>
&nbsp;            try {
<b class="nc">&nbsp;                File sDir = new File(sLocalPath);</b>
<b class="nc">&nbsp;                if (!sDir.exists()) {</b>
<b class="nc">&nbsp;                    sDir.mkdir();</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                System.err.println(&quot;Unable to create savegames directory&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            try {
&nbsp;
<b class="nc">&nbsp;                BufferedOutputStream fout = new BufferedOutputStream(new FileOutputStream(localFile));</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; data = (ArrayList&lt;Integer&gt;) c.getObject(1);</b>
<b class="nc">&nbsp;                for (Integer d : data) {</b>
<b class="nc">&nbsp;                    fout.write(d);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                fout.flush();</b>
<b class="nc">&nbsp;                fout.close();</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                System.err.println(&quot;Unable to save file: &quot; + sFinalFile);</b>
<b class="nc">&nbsp;                e.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_LOAD_SAVEGAME:
<b class="nc">&nbsp;            String loadFile = (String) c.getObject(0);</b>
&nbsp;            try {
<b class="nc">&nbsp;                File f = new File(&quot;savegames&quot;, loadFile);</b>
<b class="nc">&nbsp;                sendLoadGame(f);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                System.err.println(&quot;Unable to find the file: &quot; + loadFile);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_SPECIAL_HEX_DISPLAY:
<b class="nc">&nbsp;            game.getBoard()</b>
<b class="nc">&nbsp;                    .setSpecialHexDisplayTable((Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt;) c.getObject(0));</b>
<b class="nc">&nbsp;            game.processGameEvent(new GameBoardChangeEvent(this));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_SENDING_AVAILABLE_MAP_SIZES:
<b class="nc">&nbsp;            availableSizes = (Set&lt;BoardDimensions&gt;) c.getObject(0);</b>
<b class="nc">&nbsp;            game.processGameEvent(new GameSettingsChangeEvent(this));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE:
<b class="nc">&nbsp;            receiveEntityNovaNetworkModeChange(c);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_CLIENT_FEEDBACK_REQUEST:
<b class="nc">&nbsp;            int cfrType = (int) c.getData()[0];</b>
<b class="nc">&nbsp;            GameCFREvent cfrEvt = new GameCFREvent(this, cfrType);</b>
<b class="nc">&nbsp;            switch (cfrType) {</b>
&nbsp;            case (Packet.COMMAND_CFR_DOMINO_EFFECT):
<b class="nc">&nbsp;                cfrEvt.setEntityId((int) c.getData()[1]);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CFR_AMS_ASSIGN:
<b class="nc">&nbsp;                cfrEvt.setEntityId((int) c.getData()[1]);</b>
<b class="nc">&nbsp;                cfrEvt.setAmsEquipNum((int) c.getData()[2]);</b>
<b class="nc">&nbsp;                cfrEvt.setWAAs((List&lt;WeaponAttackAction&gt;) c.getData()[3]);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CFR_APDS_ASSIGN:
<b class="nc">&nbsp;                cfrEvt.setEntityId((int) c.getData()[1]);</b>
<b class="nc">&nbsp;                cfrEvt.setApdsDists((List&lt;Integer&gt;) c.getData()[2]);</b>
<b class="nc">&nbsp;                cfrEvt.setWAAs((List&lt;WeaponAttackAction&gt;) c.getData()[3]);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CFR_HIDDEN_PBS:
<b class="nc">&nbsp;                cfrEvt.setEntityId((int) c.getObject(1));</b>
<b class="nc">&nbsp;                cfrEvt.setTargetId((int) c.getObject(2));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CFR_TELEGUIDED_TARGET:
<b class="nc">&nbsp;                cfrEvt.setTeleguidedMissileTargets((List&lt;Integer&gt;)c.getObject(1));</b>
<b class="nc">&nbsp;                cfrEvt.setTmToHitValues((List&lt;Integer&gt;)c.getObject(2));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case Packet.COMMAND_CFR_TAG_TARGET:
<b class="nc">&nbsp;                cfrEvt.setTAGTargets((List&lt;Integer&gt;)c.getObject(1));</b>
<b class="nc">&nbsp;                cfrEvt.setTAGTargetTypes((List&lt;Integer&gt;)c.getObject(2));</b>
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            game.processGameEvent(cfrEvt);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;        case Packet.COMMAND_GAME_VICTORY_EVENT:
<b class="nc">&nbsp;            GameVictoryEvent gve = new GameVictoryEvent(this, game);</b>
<b class="nc">&nbsp;            game.processGameEvent(gve);</b>
&nbsp;            break;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * receive and process an entity nova network mode change packet
&nbsp;     *
&nbsp;     * @param c
&nbsp;     */
&nbsp;    private void receiveEntityNovaNetworkModeChange(Packet c) {
&nbsp;        try {
<b class="nc">&nbsp;            int entityId = c.getIntValue(0);</b>
<b class="nc">&nbsp;            String networkID = c.getObject(1).toString();</b>
<b class="nc">&nbsp;            Entity e = game.getEntity(entityId);</b>
<b class="nc">&nbsp;            if (e != null) {</b>
<b class="nc">&nbsp;                e.setNewRoundNovaNetworkString(networkID);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            ex.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendDominoCFRResponse(MovePath mp) {
<b class="nc">&nbsp;        Object data[] = { Packet.COMMAND_CFR_DOMINO_EFFECT, mp };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendAMSAssignCFRResponse(Integer waaIndex) {
<b class="nc">&nbsp;        Object data[] = { Packet.COMMAND_CFR_AMS_ASSIGN, waaIndex };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendAPDSAssignCFRResponse(Integer waaIndex) {
<b class="nc">&nbsp;        Object data[] = { Packet.COMMAND_CFR_APDS_ASSIGN, waaIndex };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendHiddenPBSCFRResponse(Vector&lt;EntityAction&gt; attacks) {
<b class="nc">&nbsp;        Object data[] = { Packet.COMMAND_CFR_HIDDEN_PBS, attacks };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void sendTelemissileTargetCFRResponse(int index) {
<b class="nc">&nbsp;        Object data[] = { Packet.COMMAND_CFR_TELEGUIDED_TARGET, index };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    public void sendTAGTargetCFRResponse(int index) {
<b class="nc">&nbsp;        Object data[] = { Packet.COMMAND_CFR_TAG_TARGET, index };</b>
<b class="nc">&nbsp;        Packet packet = new Packet(Packet.COMMAND_CLIENT_FEEDBACK_REQUEST, data);</b>
<b class="nc">&nbsp;        send(packet);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Perform a dump of the current memory usage.
&nbsp;     * &lt;p/&gt;
&nbsp;     * This method is useful in tracking performance issues on various player&#39;s
&nbsp;     * systems. You can activate it by changing the &quot;memorydumpon&quot; setting to
&nbsp;     * &quot;true&quot; in the clientsettings.xml file.
&nbsp;     *
&nbsp;     * @param where
&nbsp;     *            - a &lt;code&gt;String&lt;/code&gt; indicating which part of the game is
&nbsp;     *            making this call.
&nbsp;     */
&nbsp;    private void memDump(String where) {
<b class="nc">&nbsp;        if (PreferenceManager.getClientPreferences().memoryDumpOn()) {</b>
<b class="nc">&nbsp;            StringBuffer buf = new StringBuffer();</b>
<b class="nc">&nbsp;            final long total = Runtime.getRuntime().totalMemory();</b>
<b class="nc">&nbsp;            final long free = Runtime.getRuntime().freeMemory();</b>
<b class="nc">&nbsp;            final long used = total - free;</b>
<b class="nc">&nbsp;            buf.append(&quot;Memory dump &quot;).append(where); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            for (int loop = where.length(); loop &lt; 25; loop++) {</b>
<b class="nc">&nbsp;                buf.append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            buf.append(&quot;: used (&quot;).append(used).append(&quot;) + free (&quot;).append(free).append(&quot;) = &quot;).append(total); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$</b>
<b class="nc">&nbsp;            System.out.println(buf.toString());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public String getName() {
<b class="fc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getPort() {
<b class="nc">&nbsp;        return port;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getHost() {
<b class="nc">&nbsp;        return host;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void correctName(Packet inP) {
<b class="nc">&nbsp;        setName((String) (inP.getObject(0)));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void setName(String newN) {
<b class="nc">&nbsp;        name = newN;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Before we officially &quot;add&quot; this unit to the game, check and see if this
&nbsp;     * client (player) already has a unit in the game with the same name. If so,
&nbsp;     * add an identifier to the units name.
&nbsp;     */
&nbsp;    private void checkDuplicateNamesDuringAdd(Entity entity) {
<b class="nc">&nbsp;        if (duplicateNameHash.get(entity.getShortName()) == null) {</b>
<b class="nc">&nbsp;            duplicateNameHash.put(entity.getShortName(), Integer.valueOf(1));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            int count = duplicateNameHash.get(entity.getShortName()).intValue();</b>
<b class="nc">&nbsp;            count++;</b>
<b class="nc">&nbsp;            duplicateNameHash.put(entity.getShortName(), Integer.valueOf(count));</b>
<b class="nc">&nbsp;            entity.duplicateMarker = count;</b>
<b class="nc">&nbsp;            entity.generateShortName();</b>
<b class="nc">&nbsp;            entity.generateDisplayName();</b>
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * If we remove an entity, we may need to update the duplicate identifier.
&nbsp;     *
&nbsp;     * @param ids
&nbsp;     */
&nbsp;    private void checkDuplicateNamesDuringDelete(List&lt;Integer&gt; ids) {
<b class="nc">&nbsp;        ArrayList&lt;Entity&gt; myEntities = game.getPlayerEntities(game.getPlayer(localPlayerNumber), false);</b>
<b class="nc">&nbsp;        Hashtable&lt;String, ArrayList&lt;Integer&gt;&gt; rawNameToId = new Hashtable&lt;String, ArrayList&lt;Integer&gt;&gt;(</b>
<b class="nc">&nbsp;                (int) (myEntities.size() * 1.26));</b>
&nbsp;
<b class="nc">&nbsp;        for (Entity e : myEntities) {</b>
<b class="nc">&nbsp;            String rawName = e.getShortNameRaw();</b>
<b class="nc">&nbsp;            ArrayList&lt;Integer&gt; namedIds = rawNameToId.get(rawName);</b>
<b class="nc">&nbsp;            if (namedIds == null) {</b>
<b class="nc">&nbsp;                namedIds = new ArrayList&lt;Integer&gt;();</b>
&nbsp;            }
<b class="nc">&nbsp;            namedIds.add(e.getId());</b>
<b class="nc">&nbsp;            rawNameToId.put(rawName, namedIds);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (int id : ids) {</b>
<b class="nc">&nbsp;            Entity removedEntity = game.getEntity(id);</b>
<b class="nc">&nbsp;            if (removedEntity == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String removedRawName = removedEntity.getShortNameRaw();</b>
<b class="nc">&nbsp;            Integer count = duplicateNameHash.get(removedEntity.getShortNameRaw());</b>
<b class="nc">&nbsp;            if ((count != null) &amp;&amp; (count &gt; 1)) {</b>
<b class="nc">&nbsp;                ArrayList&lt;Integer&gt; namedIds = rawNameToId.get(removedRawName);</b>
<b class="nc">&nbsp;                for (Integer i : namedIds) {</b>
<b class="nc">&nbsp;                    Entity e = game.getEntity(i);</b>
<b class="nc">&nbsp;                    String eRawName = e.getShortNameRaw();</b>
<b class="nc">&nbsp;                    if (eRawName.equals(removedRawName) &amp;&amp; (e.duplicateMarker &gt; removedEntity.duplicateMarker)) {</b>
<b class="nc">&nbsp;                        e.duplicateMarker--;</b>
<b class="nc">&nbsp;                        e.generateShortName();</b>
<b class="nc">&nbsp;                        e.generateDisplayName();</b>
&nbsp;                        // Update the Entity, unless it&#39;s going to be deleted
<b class="nc">&nbsp;                        if (!ids.contains(e.getId())) {</b>
<b class="nc">&nbsp;                            sendUpdateEntity(e);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                duplicateNameHash.put(removedEntity.getShortNameRaw(), Integer.valueOf(count - 1));</b>
&nbsp;
<b class="nc">&nbsp;            } else if (count != null) {</b>
<b class="nc">&nbsp;                duplicateNameHash.remove(removedEntity.getShortNameRaw());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param cmd
&nbsp;     *            a client command with CLIENT_COMMAND prepended.
&nbsp;     */
&nbsp;    public String runCommand(String cmd) {
<b class="nc">&nbsp;        cmd = cmd.substring(CLIENT_COMMAND.length());</b>
&nbsp;
<b class="nc">&nbsp;        return runCommand(cmd.split(&quot;\\s+&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the command
&nbsp;     *
&nbsp;     * @param args
&nbsp;     *            the command and it&#39;s arguments with the CLIENT_COMMAND already
&nbsp;     *            removed, and the string tokenized.
&nbsp;     */
&nbsp;    public String runCommand(String[] args) {
<b class="nc">&nbsp;        if ((args != null) &amp;&amp; (args.length &gt; 0) &amp;&amp; commandsHash.containsKey(args[0])) {</b>
<b class="nc">&nbsp;            return commandsHash.get(args[0]).run(args);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;Unknown Client Command.&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Registers a new command in the client command table
&nbsp;     */
&nbsp;    public void registerCommand(ClientCommand command) {
<b class="fc">&nbsp;        commandsHash.put(command.getName(), command);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the command associated with the specified name
&nbsp;     */
&nbsp;    public ClientCommand getCommand(String commandName) {
<b class="nc">&nbsp;        return commandsHash.get(commandName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * (non-Javadoc)
&nbsp;     *
&nbsp;     * @see megamek.client.ui.IClientCommandHandler#getAllCommandNames()
&nbsp;     */
&nbsp;    public Enumeration&lt;String&gt; getAllCommandNames() {
<b class="nc">&nbsp;        return commandsHash.keys();</b>
&nbsp;    }
&nbsp;
&nbsp;    public RandomSkillsGenerator getRandomSkillsGenerator() {
<b class="nc">&nbsp;        return rsg;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;BoardDimensions&gt; getAvailableMapSizes() {
<b class="nc">&nbsp;        return availableSizes;</b>
&nbsp;    }
&nbsp;
&nbsp;    public IGame getGame() {
<b class="nc">&nbsp;        return game;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
