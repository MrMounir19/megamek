


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FiringDisplay</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ui.swing</a>
</div>

<h1>Coverage Summary for Class: FiringDisplay (megamek.client.ui.swing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FiringDisplay</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1130)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FiringDisplay$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$19</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$20</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FiringDisplay$FiringCommand</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/137)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1316)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.client.ui.swing;
&nbsp;
&nbsp;import megamek.client.event.BoardViewEvent;
&nbsp;import megamek.client.ui.Messages;
&nbsp;import megamek.client.ui.SharedUtility;
&nbsp;import megamek.client.ui.swing.util.CommandAction;
&nbsp;import megamek.client.ui.swing.util.KeyCommandBind;
&nbsp;import megamek.client.ui.swing.util.MegaMekController;
&nbsp;import megamek.client.ui.swing.widget.MegamekButton;
&nbsp;import megamek.client.ui.swing.widget.SkinSpecification;
&nbsp;import megamek.common.*;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.actions.*;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.event.GameTurnChangeEvent;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.util.FiringSolution;
&nbsp;import megamek.client.ui.swing.util.TurnTimer;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.capitalweapons.CapitalMissileWeapon;
&nbsp;
&nbsp;import javax.swing.*;
&nbsp;import javax.swing.event.ListSelectionEvent;
&nbsp;import javax.swing.event.ListSelectionListener;
&nbsp;import java.awt.event.ActionEvent;
&nbsp;import java.awt.event.InputEvent;
&nbsp;import java.awt.event.ItemEvent;
&nbsp;import java.awt.event.ItemListener;
&nbsp;import java.util.*;
&nbsp;
<b class="nc">&nbsp;public class FiringDisplay extends StatusBarPhaseDisplay implements</b>
&nbsp;        ItemListener, ListSelectionListener {
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = -5586388490027013723L;
&nbsp;
&nbsp;    /**
&nbsp;     * timer that ends turn if time limit set in options is over
&nbsp;     */
&nbsp;    private TurnTimer tt;
&nbsp;
&nbsp;    /**
&nbsp;     * This enumeration lists all of the possible ActionCommands that can be
&nbsp;     * carried out during the firing phase.  Each command has a string for the
&nbsp;     * command plus a flag that determines what unit type it is appropriate for.
&nbsp;     *
&nbsp;     * @author arlith
&nbsp;     */
<b class="nc">&nbsp;    public static enum FiringCommand implements PhaseCommand {</b>
<b class="nc">&nbsp;        FIRE_NEXT(&quot;fireNext&quot;),</b>
<b class="nc">&nbsp;        FIRE_TWIST(&quot;fireTwist&quot;),</b>
<b class="nc">&nbsp;        FIRE_FIRE(&quot;fireFire&quot;),</b>
<b class="nc">&nbsp;        FIRE_SKIP(&quot;fireSkip&quot;),</b>
<b class="nc">&nbsp;        FIRE_NEXT_TARG(&quot;fireNextTarg&quot;),</b>
<b class="nc">&nbsp;        FIRE_MODE(&quot;fireMode&quot;),</b>
<b class="nc">&nbsp;        FIRE_SPOT(&quot;fireSpot&quot;),</b>
<b class="nc">&nbsp;        FIRE_FLIP_ARMS(&quot;fireFlipArms&quot;),</b>
<b class="nc">&nbsp;        FIRE_FIND_CLUB(&quot;fireFindClub&quot;),</b>
<b class="nc">&nbsp;        FIRE_STRAFE(&quot;fireStrafe&quot;),</b>
<b class="nc">&nbsp;        FIRE_SEARCHLIGHT(&quot;fireSearchlight&quot;),</b>
<b class="nc">&nbsp;        FIRE_CLEAR_TURRET(&quot;fireClearTurret&quot;),</b>
<b class="nc">&nbsp;        FIRE_CLEAR_WEAPON(&quot;fireClearWeaponJam&quot;),</b>
<b class="nc">&nbsp;        FIRE_CALLED(&quot;fireCalled&quot;),</b>
<b class="nc">&nbsp;        FIRE_CANCEL(&quot;fireCancel&quot;),</b>
<b class="nc">&nbsp;        FIRE_MORE(&quot;fireMore&quot;);</b>
&nbsp;
&nbsp;        String cmd;
&nbsp;
&nbsp;        /**
&nbsp;         * Priority that determines this buttons order
&nbsp;         */
&nbsp;        public int priority;
&nbsp;
<b class="nc">&nbsp;        private FiringCommand(String c) {</b>
<b class="nc">&nbsp;            cmd = c;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getCmd() {
<b class="nc">&nbsp;            return cmd;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getPriority() {
<b class="nc">&nbsp;            return priority;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setPriority(int p) {
<b class="nc">&nbsp;            priority = p;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return Messages.getString(&quot;FiringDisplay.&quot; + getCmd());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // buttons
&nbsp;    private Map&lt;FiringCommand, MegamekButton&gt; buttons;
&nbsp;
&nbsp;    // let&#39;s keep track of what we&#39;re shooting and at what, too
<b class="nc">&nbsp;    protected int cen = Entity.NONE; // current entity number</b>
&nbsp;
&nbsp;    Targetable target; // target
&nbsp;
&nbsp;    // HACK : track when we wan to show the target choice dialog.
<b class="nc">&nbsp;    protected boolean showTargetChoice = true;</b>
&nbsp;
&nbsp;    // shots we have so far.
&nbsp;    protected Vector&lt;AbstractEntityAction&gt; attacks;
&nbsp;
&nbsp;    // is the shift key held?
&nbsp;    protected boolean shiftheld;
&nbsp;
&nbsp;    protected boolean twisting;
&nbsp;
<b class="nc">&nbsp;    protected Entity[] visibleTargets = null;</b>
&nbsp;
<b class="nc">&nbsp;    protected int lastTargetID = -1;</b>
&nbsp;
&nbsp;    protected AimedShotHandler ash;
&nbsp;    
<b class="nc">&nbsp;    protected boolean isStrafing = false;</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Keeps track of the Coords that are in a strafing run.
&nbsp;     */
<b class="nc">&nbsp;    private ArrayList&lt;Coords&gt; strafingCoords = new ArrayList&lt;Coords&gt;(5);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates and lays out a new firing phase display for the specified
&nbsp;     * clientgui.getClient().
&nbsp;     */
&nbsp;    public FiringDisplay(final ClientGUI clientgui) {
<b class="nc">&nbsp;        super(clientgui);</b>
<b class="nc">&nbsp;        clientgui.getClient().getGame().addGameListener(this);</b>
&nbsp;
<b class="nc">&nbsp;        clientgui.getBoardView().addBoardViewListener(this);</b>
&nbsp;
<b class="nc">&nbsp;        shiftheld = false;</b>
&nbsp;
&nbsp;        // fire
<b class="nc">&nbsp;        attacks = new Vector&lt;AbstractEntityAction&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        setupStatusBar(Messages</b>
<b class="nc">&nbsp;                .getString(&quot;FiringDisplay.waitingForFiringPhase&quot;)); //$NON-NLS-1$</b>
&nbsp;
<b class="nc">&nbsp;        buttons = new HashMap&lt;FiringCommand, MegamekButton&gt;(</b>
<b class="nc">&nbsp;                (int) (FiringCommand.values().length * 1.25 + 0.5));</b>
<b class="nc">&nbsp;        for (FiringCommand cmd : FiringCommand.values()) {</b>
<b class="nc">&nbsp;            String title = Messages.getString(&quot;FiringDisplay.&quot; //$NON-NLS-1$</b>
<b class="nc">&nbsp;                    + cmd.getCmd());</b>
<b class="nc">&nbsp;            MegamekButton newButton = new MegamekButton(title,</b>
<b class="nc">&nbsp;                    SkinSpecification.UIComponents.PhaseDisplayButton.getComp());</b>
<b class="nc">&nbsp;            String ttKey = &quot;FiringDisplay.&quot; + cmd.getCmd() + &quot;.tooltip&quot;;</b>
<b class="nc">&nbsp;            if (Messages.keyExists(ttKey)) {</b>
<b class="nc">&nbsp;                newButton.setToolTipText(Messages.getString(ttKey));</b>
&nbsp;            }
<b class="nc">&nbsp;            newButton.addActionListener(this);</b>
<b class="nc">&nbsp;            newButton.setActionCommand(cmd.getCmd());</b>
<b class="nc">&nbsp;            newButton.setEnabled(false);</b>
<b class="nc">&nbsp;            buttons.put(cmd, newButton);</b>
&nbsp;        }
<b class="nc">&nbsp;        numButtonGroups =</b>
<b class="nc">&nbsp;                (int) Math.ceil((buttons.size() + 0.0) / buttonsPerGroup);</b>
&nbsp;
<b class="nc">&nbsp;        butDone.setText(&quot;&lt;html&gt;&lt;b&gt;&quot; + Messages.getString( //$NON-NLS-1$</b>
&nbsp;                &quot;FiringDisplay.Done&quot;) + &quot;&lt;/b&gt;&lt;/html&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
<b class="nc">&nbsp;        butDone.setEnabled(false);</b>
&nbsp;
<b class="nc">&nbsp;        layoutScreen();</b>
&nbsp;
<b class="nc">&nbsp;        setupButtonPanel();</b>
&nbsp;
<b class="nc">&nbsp;        clientgui.bv.addKeyListener(this);</b>
&nbsp;
&nbsp;        // mech display.
<b class="nc">&nbsp;        clientgui.mechD.wPan.weaponList.addListSelectionListener(this);</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.weaponList.addKeyListener(this);</b>
&nbsp;
<b class="nc">&nbsp;        ash = new AimedShotHandler(this);</b>
&nbsp;
<b class="nc">&nbsp;        registerKeyCommands();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Register all of the &lt;code&gt;CommandAction&lt;/code&gt;s for this panel display.
&nbsp;     */
&nbsp;    protected void registerKeyCommands() {
<b class="nc">&nbsp;        MegaMekController controller = clientgui.controller;</b>
<b class="nc">&nbsp;        final StatusBarPhaseDisplay display = this;</b>
&nbsp;        // Register the action for UNDO
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.UNDO.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !display.isVisible()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        removeLastFiring();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for TWIST_LEFT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TWIST_LEFT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        updateFlipArms(false);</b>
<b class="nc">&nbsp;                        torsoTwist(0);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for TWIST_RIGHT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TWIST_RIGHT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        updateFlipArms(false);</b>
<b class="nc">&nbsp;                        torsoTwist(1);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for FIRE
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.FIRE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !buttons.get(FiringCommand.FIRE_FIRE)</b>
<b class="nc">&nbsp;                                        .isEnabled()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        fire();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_WEAPON
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_WEAPON.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        nextWeapon();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_WEAPON
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_WEAPON.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        prevWeapon();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_UNIT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_UNIT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        selectEntity(clientgui.getClient()</b>
<b class="nc">&nbsp;                                .getNextEntityNum(cen));</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_UNIT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_UNIT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        selectEntity(clientgui.getClient()</b>
<b class="nc">&nbsp;                                .getPrevEntityNum(cen));</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_TARGET.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(true, false, false);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_TARGET.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(false, false, false);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_TARGET_VALID.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(true, true, false);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_TARGET_VALID.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(false, true, false);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_TARGET_NOALLIES.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(true, false, true);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_TARGET_NOALLIES.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(false, false, true);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_TARGET_VALID_NO_ALLIES.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(true, true, true);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_TARGET_VALID_NO_ALLIES.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToTarget(false, true, true);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;        // Register the action for NEXT_MODE
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_MODE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !display.isVisible()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        changeMode(true);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_MODE
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_MODE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !display.isVisible()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        changeMode(false);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for CLEAR
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.CANCEL.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        clear();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    protected ArrayList&lt;MegamekButton&gt; getButtonList() {
<b class="nc">&nbsp;        ArrayList&lt;MegamekButton&gt; buttonList = new ArrayList&lt;MegamekButton&gt;();</b>
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        FiringCommand commands[] = FiringCommand.values();</b>
<b class="nc">&nbsp;        CommandComparator comparator = new CommandComparator();</b>
<b class="nc">&nbsp;        Arrays.sort(commands, comparator);</b>
<b class="nc">&nbsp;        for (FiringCommand cmd : commands) {</b>
<b class="nc">&nbsp;            if (cmd == FiringCommand.FIRE_NEXT</b>
&nbsp;                    || cmd == FiringCommand.FIRE_MORE
&nbsp;                    || cmd == FiringCommand.FIRE_CANCEL) {
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (i % buttonsPerGroup == 0) {</b>
<b class="nc">&nbsp;                buttonList.add(buttons.get(FiringCommand.FIRE_NEXT));</b>
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            buttonList.add(buttons.get(cmd));</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;
<b class="nc">&nbsp;            if ((i + 1) % buttonsPerGroup == 0) {</b>
<b class="nc">&nbsp;                buttonList.add(buttons.get(FiringCommand.FIRE_MORE));</b>
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!buttonList.get(i - 1).getActionCommand()</b>
<b class="nc">&nbsp;                .equals(FiringCommand.FIRE_MORE.getCmd())) {</b>
<b class="nc">&nbsp;            while ((i + 1) % buttonsPerGroup != 0) {</b>
<b class="nc">&nbsp;                buttonList.add(null);</b>
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
<b class="nc">&nbsp;            buttonList.add(buttons.get(FiringCommand.FIRE_MORE));</b>
&nbsp;        }
<b class="nc">&nbsp;        return buttonList;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Selects an entity, by number, for firing.
&nbsp;     */
&nbsp;    public void selectEntity(int en) {
&nbsp;        // clear any previously considered attacks
<b class="nc">&nbsp;        if (en != cen) {</b>
<b class="nc">&nbsp;            target(null);</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            refreshAll();</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; ce().isWeapOrderChanged()) {</b>
<b class="nc">&nbsp;            clientgui.getClient().sendEntityWeaponOrderUpdate(ce());</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn()) {</b>
<b class="nc">&nbsp;            setStatusBarText(Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.its_your_turn&quot;)); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getEntity(en) != null) {</b>
&nbsp;
<b class="nc">&nbsp;            cen = en;</b>
<b class="nc">&nbsp;            clientgui.setSelectedEntityNum(en);</b>
<b class="nc">&nbsp;            clientgui.mechD.displayEntity(ce());</b>
&nbsp;
&nbsp;            // If the selected entity is not on the board, use the next one.
&nbsp;            // ASSUMPTION: there will always be *at least one* entity on map.
<b class="nc">&nbsp;            if (ce().getPosition() == null) {</b>
&nbsp;
&nbsp;                // Walk through the list of entities for this player.
<b class="nc">&nbsp;                for (int nextId = clientgui.getClient().getNextEntityNum(en);</b>
<b class="nc">&nbsp;                     nextId != en; nextId = clientgui</b>
<b class="nc">&nbsp;                        .getClient().getNextEntityNum(nextId)) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (clientgui.getClient().getGame().getEntity(nextId)</b>
<b class="nc">&nbsp;                                 .getPosition() != null) {</b>
<b class="nc">&nbsp;                        cen = nextId;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
&nbsp;                } // Check the player&#39;s next entity.
&nbsp;
&nbsp;                // We were *supposed* to have found an on-board entity.
<b class="nc">&nbsp;                if (ce().getPosition() == null) {</b>
<b class="nc">&nbsp;                    System.err.println(&quot;FiringDisplay: could &quot; + //$NON-NLS-1$</b>
&nbsp;                            &quot;not find an on-board entity: &quot; + en); //$NON-NLS-1$
&nbsp;                    return;
&nbsp;                }
&nbsp;
&nbsp;            } // End ce()-not-on-board
&nbsp;
<b class="nc">&nbsp;            if (ce().isMakingVTOLGroundAttack()) {</b>
<b class="nc">&nbsp;                this.updateVTOLGroundTarget();</b>
&nbsp;            } else {
&nbsp;                // Need to clear attacks again in case previous en was making VTOL ground attack
<b class="nc">&nbsp;                clearAttacks();</b>
<b class="nc">&nbsp;                int lastTarget = ce().getLastTarget();</b>
<b class="nc">&nbsp;                if (ce() instanceof Mech) {</b>
<b class="nc">&nbsp;                    int grapple = ((Mech) ce()).getGrappled();</b>
<b class="nc">&nbsp;                    if (grapple != Entity.NONE) {</b>
<b class="nc">&nbsp;                        lastTarget = grapple;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                Entity t = clientgui.getClient().getGame().getEntity(lastTarget);</b>
<b class="nc">&nbsp;                target(t);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!ce().isOffBoard()) {</b>
<b class="nc">&nbsp;                clientgui.getBoardView().highlight(ce().getPosition());</b>
&nbsp;            }
<b class="nc">&nbsp;            clientgui.getBoardView().select(null);</b>
<b class="nc">&nbsp;            clientgui.getBoardView().cursor(null);</b>
&nbsp;
<b class="nc">&nbsp;            refreshAll();</b>
<b class="nc">&nbsp;            cacheVisibleTargets();</b>
&nbsp;
<b class="nc">&nbsp;            if (!ce().isOffBoard()) {</b>
<b class="nc">&nbsp;                clientgui.bv.centerOnHex(ce().getPosition());</b>
&nbsp;            }
&nbsp;
&nbsp;            // Update the menu bar.
<b class="nc">&nbsp;            clientgui.getMenuBar().setEntity(ce());</b>
&nbsp;
&nbsp;            // only twist if crew conscious
<b class="nc">&nbsp;            setTwistEnabled(ce().canChangeSecondaryFacing()</b>
<b class="nc">&nbsp;                            &amp;&amp; ce().getCrew().isActive());</b>
&nbsp;
<b class="nc">&nbsp;            setFindClubEnabled(FindClubAction.canMechFindClub(</b>
<b class="nc">&nbsp;                    clientgui.getClient().getGame(), en));</b>
<b class="nc">&nbsp;            setFlipArmsEnabled(ce().canFlipArms());</b>
<b class="nc">&nbsp;            updateSearchlight();</b>
<b class="nc">&nbsp;            updateClearTurret();</b>
<b class="nc">&nbsp;            updateClearWeaponJam();</b>
<b class="nc">&nbsp;            updateStrafe();</b>
&nbsp;
&nbsp;            // Hidden units can only spot
<b class="nc">&nbsp;            if ((ce() != null) &amp;&amp; ce().isHidden()) {</b>
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;                setTwistEnabled(false);</b>
<b class="nc">&nbsp;                setFindClubEnabled(false);</b>
<b class="nc">&nbsp;                setFlipArmsEnabled(false);</b>
<b class="nc">&nbsp;                setStrafeEnabled(false);</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.toHitText</b>
<b class="nc">&nbsp;                .setText(&quot;Hidden units are only allowed to spot!&quot;);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            System.err.println(&quot;FiringDisplay: tried to &quot; + //$NON-NLS-1$</b>
&nbsp;                    &quot;select non-existant entity: &quot; + en); //$NON-NLS-1$
&nbsp;        }
&nbsp;        
&nbsp;
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getBoolean(&quot;FiringSolutions&quot;)) {</b>
<b class="nc">&nbsp;            setFiringSolutions();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            clientgui.getBoardView().clearFiringSolutionData();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setFiringSolutions() {
&nbsp;        // If no Entity is selected, exit
<b class="nc">&nbsp;        if (cen == Entity.NONE) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;        IPlayer localPlayer = clientgui.getClient().getLocalPlayer();</b>
<b class="nc">&nbsp;        if (!GUIPreferences.getInstance().getFiringSolutions()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // Determine which entities are spotted
<b class="nc">&nbsp;        Set&lt;Integer&gt; spottedEntities = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity target : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (!target.isEnemyOf(ce()) &amp;&amp; target.isSpotting()) {</b>
<b class="nc">&nbsp;                spottedEntities.add(target.getSpotTargetId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Calculate firing solutions
<b class="nc">&nbsp;        Map&lt;Integer, FiringSolution&gt; fs = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity target : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            boolean friendlyFire = game.getOptions().booleanOption(</b>
&nbsp;                    OptionsConstants.BASE_FRIENDLY_FIRE); //$NON-NLS-1$
<b class="nc">&nbsp;            boolean enemyTarget = target.getOwner().isEnemyOf(ce().getOwner());</b>
<b class="nc">&nbsp;            if ((target.getId() != cen)</b>
&nbsp;                &amp;&amp; (friendlyFire || enemyTarget)
<b class="nc">&nbsp;                &amp;&amp; (!enemyTarget || EntityVisibilityUtils.detectedOrHasVisual(localPlayer, game, target))</b>
<b class="nc">&nbsp;                &amp;&amp; target.isTargetable()) {</b>
<b class="nc">&nbsp;                ToHitData thd = WeaponAttackAction.toHit(game, cen, target);</b>
<b class="nc">&nbsp;                thd.setLocation(target.getPosition());</b>
<b class="nc">&nbsp;                thd.setRange(ce().getPosition().distance(target.getPosition()));</b>
<b class="nc">&nbsp;                fs.put(target.getId(), new FiringSolution(thd, spottedEntities.contains(target.getId())));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        clientgui.getBoardView().setFiringSolutions(ce(), fs);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does turn start stuff
&nbsp;     */
&nbsp;    protected void beginMyTurn() {
<b class="nc">&nbsp;        target = null;</b>
&nbsp;
<b class="nc">&nbsp;        if (!clientgui.bv.isMovingUnits()) {</b>
<b class="nc">&nbsp;            clientgui.setDisplayVisible(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        clientgui.bv.clearFieldofF();</b>
&nbsp;
<b class="nc">&nbsp;        selectEntity(clientgui.getClient().getFirstEntityNum());</b>
&nbsp;
<b class="nc">&nbsp;        GameTurn turn = clientgui.getClient().getMyTurn();</b>
&nbsp;        // There&#39;s special processing for triggering AP Pods.
<b class="nc">&nbsp;        if ((turn instanceof GameTurn.TriggerAPPodTurn) &amp;&amp; (ce() != null)) {</b>
<b class="nc">&nbsp;            disableButtons();</b>
<b class="nc">&nbsp;            TriggerAPPodDialog dialog = new TriggerAPPodDialog(</b>
<b class="nc">&nbsp;                    clientgui.getFrame(), ce());</b>
<b class="nc">&nbsp;            dialog.setVisible(true);</b>
<b class="nc">&nbsp;            attacks.removeAllElements();</b>
<b class="nc">&nbsp;            Enumeration&lt;TriggerAPPodAction&gt; actions = dialog.getActions();</b>
<b class="nc">&nbsp;            while (actions.hasMoreElements()) {</b>
<b class="nc">&nbsp;                attacks.addElement(actions.nextElement());</b>
&nbsp;            }
<b class="nc">&nbsp;            ready();</b>
<b class="nc">&nbsp;        } else if ((turn instanceof GameTurn.TriggerBPodTurn) &amp;&amp; (null != ce())) {</b>
<b class="nc">&nbsp;            disableButtons();</b>
<b class="nc">&nbsp;            TriggerBPodDialog dialog = new TriggerBPodDialog(clientgui, ce(),</b>
<b class="nc">&nbsp;                    ((GameTurn.TriggerBPodTurn) turn).getAttackType());</b>
<b class="nc">&nbsp;            dialog.setVisible(true);</b>
<b class="nc">&nbsp;            attacks.removeAllElements();</b>
<b class="nc">&nbsp;            Enumeration&lt;TriggerBPodAction&gt; actions = dialog.getActions();</b>
<b class="nc">&nbsp;            while (actions.hasMoreElements()) {</b>
<b class="nc">&nbsp;                attacks.addElement(actions.nextElement());</b>
&nbsp;            }
<b class="nc">&nbsp;            ready();</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            setNextEnabled(true);</b>
<b class="nc">&nbsp;            butDone.setEnabled(true);</b>
<b class="nc">&nbsp;            if (numButtonGroups &gt; 1)</b>
<b class="nc">&nbsp;                buttons.get(FiringCommand.FIRE_MORE).setEnabled(true);</b>
<b class="nc">&nbsp;            setFireCalledEnabled(clientgui.getClient().getGame().getOptions()</b>
<b class="nc">&nbsp;                    .booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CALLED_SHOTS));</b>
<b class="nc">&nbsp;            clientgui.getBoardView().select(null);</b>
&nbsp;        }
&nbsp;        //check if there should be a turn timer running
<b class="nc">&nbsp;        tt = TurnTimer.init(this, clientgui.getClient());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does end turn stuff.
&nbsp;     */
&nbsp;    protected void endMyTurn() {
&nbsp;        //get rid of still running timer, if turn is concluded before time is up
<b class="nc">&nbsp;        if (tt != null) {</b>
<b class="nc">&nbsp;            tt.stopTimer();</b>
<b class="nc">&nbsp;            tt = null;</b>
&nbsp;        }
&nbsp;        // end my turn, then.
<b class="nc">&nbsp;        IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;        Entity next = game.getNextEntity(game.getTurnIndex());</b>
<b class="nc">&nbsp;        if ((game.getPhase() == IGame.Phase.PHASE_FIRING)</b>
<b class="nc">&nbsp;            &amp;&amp; (next != null) &amp;&amp; (ce() != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (next.getOwnerId() != ce().getOwnerId())) {</b>
<b class="nc">&nbsp;            clientgui.setDisplayVisible(false);</b>
&nbsp;        }
<b class="nc">&nbsp;        cen = Entity.NONE;</b>
<b class="nc">&nbsp;        target(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().highlight(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().cursor(null);</b>
<b class="nc">&nbsp;        clientgui.bv.clearMovementData();</b>
<b class="nc">&nbsp;        clientgui.bv.clearFiringSolutionData();</b>
<b class="nc">&nbsp;        clientgui.bv.clearStrafingCoords();</b>
<b class="nc">&nbsp;        clientgui.bv.clearFieldofF();</b>
<b class="nc">&nbsp;        clientgui.setSelectedEntityNum(Entity.NONE);</b>
<b class="nc">&nbsp;        disableButtons();</b>
&nbsp;
<b class="nc">&nbsp;        clearVisibleTargets();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Disables all buttons in the interface
&nbsp;     */
&nbsp;    protected void disableButtons() {
<b class="nc">&nbsp;        setFireEnabled(false);</b>
<b class="nc">&nbsp;        setSkipEnabled(false);</b>
<b class="nc">&nbsp;        setTwistEnabled(false);</b>
<b class="nc">&nbsp;        setSpotEnabled(false);</b>
<b class="nc">&nbsp;        setFindClubEnabled(false);</b>
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_MORE).setEnabled(false);</b>
<b class="nc">&nbsp;        setNextEnabled(false);</b>
<b class="nc">&nbsp;        butDone.setEnabled(false);</b>
<b class="nc">&nbsp;        setNextTargetEnabled(false);</b>
<b class="nc">&nbsp;        setFlipArmsEnabled(false);</b>
<b class="nc">&nbsp;        setFireModeEnabled(false);</b>
<b class="nc">&nbsp;        setFireCalledEnabled(false);</b>
<b class="nc">&nbsp;        setFireClearTurretEnabled(false);</b>
<b class="nc">&nbsp;        setFireClearWeaponJamEnabled(false);</b>
<b class="nc">&nbsp;        setStrafeEnabled(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fire Mode - Adds a Fire Mode Change to the current Attack Action
&nbsp;     */
&nbsp;    protected void changeMode(boolean forward) {
<b class="nc">&nbsp;        int wn = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
&nbsp;
&nbsp;        // Do nothing we have no unit selected.
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // If the weapon does not have modes, just exit.
<b class="nc">&nbsp;        Mounted m = ce().getEquipment(wn);</b>
<b class="nc">&nbsp;        if ((m == null) || !m.getType().hasModes()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // Aeros cannot switch modes under standard rules
&nbsp;        /*
&nbsp;         * if (ce() instanceof Aero) { return; }
&nbsp;         */
&nbsp;
&nbsp;        // send change to the server
<b class="nc">&nbsp;        int nMode = m.switchMode(forward);</b>
&nbsp;        // BattleArmor can fire popup-mine launchers individually. The mode determines
&nbsp;        // how many will be fired, but we don&#39;t want to set the mode higher than the
&nbsp;        // number of troopers in the squad.
<b class="nc">&nbsp;        if ((ce() instanceof BattleArmor)</b>
<b class="nc">&nbsp;                &amp;&amp; (m.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                &amp;&amp; ((WeaponType)m.getType()).hasFlag(WeaponType.F_BA_INDIVIDUAL)</b>
<b class="nc">&nbsp;                &amp;&amp; (m.curMode().getName().contains(&quot;-shot&quot;))</b>
<b class="nc">&nbsp;                &amp;&amp; (Integer.parseInt(m.curMode().getName().replace(&quot;-shot&quot;, &quot;&quot;)) &gt; ce().getTotalInternal())) {</b>
<b class="nc">&nbsp;            m.setMode(0);</b>
&nbsp;        }
<b class="nc">&nbsp;        clientgui.getClient().sendModeChange(cen, wn, nMode);</b>
&nbsp;
&nbsp;        // notify the player
<b class="nc">&nbsp;        if (m.canInstantSwitch(nMode)) {</b>
<b class="nc">&nbsp;            clientgui.systemMessage(Messages.getString(</b>
<b class="nc">&nbsp;                    &quot;FiringDisplay.switched&quot;, new Object[] { m.getName(),</b>
<b class="nc">&nbsp;                            m.curMode().getDisplayableName(true) })); //$NON-NLS-1$</b>
&nbsp;        } else {
<b class="nc">&nbsp;            clientgui.systemMessage(Messages.getString(</b>
<b class="nc">&nbsp;                    &quot;FiringDisplay.willSwitch&quot;, new Object[] { m.getName(), //$NON-NLS-1$</b>
<b class="nc">&nbsp;                            m.pendingMode().getDisplayableName(true) }));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        updateTarget();</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectWeapon(wn);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called Shots - changes the current called shots selection
&nbsp;     */
&nbsp;    protected void changeCalled() {
<b class="nc">&nbsp;        int wn = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
&nbsp;
&nbsp;        // Do nothing we have no unit selected.
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Mounted m = ce().getEquipment(wn);</b>
<b class="nc">&nbsp;        if ((m == null)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // send change to the server
<b class="nc">&nbsp;        m.getCalledShot().switchCalledShot();</b>
<b class="nc">&nbsp;        clientgui.getClient().sendCalledShotChange(cen, wn);</b>
&nbsp;
<b class="nc">&nbsp;        updateTarget();</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectWeapon(wn);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Cache the list of visible targets. This is used for the &#39;next target&#39;
&nbsp;     * button.
&nbsp;     * &lt;p/&gt;
&nbsp;     * We&#39;ll sort it by range to us.
&nbsp;     */
&nbsp;    private void cacheVisibleTargets() {
<b class="nc">&nbsp;        clearVisibleTargets();</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Entity&gt; vec = clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                .getValidTargets(ce());</b>
<b class="nc">&nbsp;        Comparator&lt;Entity&gt; sortComp = new Comparator&lt;Entity&gt;() {</b>
&nbsp;            public int compare(Entity entX, Entity entY) {
<b class="nc">&nbsp;                int rangeToX = ce().getPosition().distance(entX.getPosition());</b>
<b class="nc">&nbsp;                int rangeToY = ce().getPosition().distance(entY.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;                if (rangeToX == rangeToY) {</b>
<b class="nc">&nbsp;                    return ((entX.getId() &lt; entY.getId()) ? -1 : 1);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return ((rangeToX &lt; rangeToY) ? -1 : 1);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        // put the vector in the TreeSet first to sort it.
<b class="nc">&nbsp;        TreeSet&lt;Entity&gt; tree = new TreeSet&lt;Entity&gt;(sortComp);</b>
<b class="nc">&nbsp;        visibleTargets = new Entity[vec.size()];</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; vec.size(); i++) {</b>
<b class="nc">&nbsp;            tree.add(vec.get(i));</b>
&nbsp;        }
&nbsp;
&nbsp;        // not go through the sorted Set to cache the targets.
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; it = tree.iterator();</b>
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        while (it.hasNext()) {</b>
<b class="nc">&nbsp;            visibleTargets[count++] = it.next();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        setNextTargetEnabled(visibleTargets.length &gt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void clearVisibleTargets() {
<b class="nc">&nbsp;        visibleTargets = null;</b>
<b class="nc">&nbsp;        lastTargetID = -1;</b>
<b class="nc">&nbsp;        setNextTargetEnabled(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the next target. Return null if we don&#39;t have any targets.
&nbsp;     */
&nbsp;    private Entity getNextTarget(boolean nextOrPrev, boolean onlyValid,
&nbsp;            boolean ignoreAllies) {
<b class="nc">&nbsp;        if (visibleTargets == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entity result = null;</b>
<b class="nc">&nbsp;        boolean done = false;</b>
<b class="nc">&nbsp;        int count = 0;</b>
&nbsp;        // Loop until we hit an exit criteria
&nbsp;        //  Default is one iteration, but may need to skip invalid or allies
<b class="nc">&nbsp;        while (!done) {</b>
&nbsp;            // Increment or decrement target index
<b class="nc">&nbsp;            if (nextOrPrev) {</b>
<b class="nc">&nbsp;                lastTargetID++;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                lastTargetID--;</b>
&nbsp;            }
&nbsp;            // Check bounds
<b class="nc">&nbsp;            if (lastTargetID &lt; 0) {</b>
<b class="nc">&nbsp;                lastTargetID = visibleTargets.length - 1;</b>
<b class="nc">&nbsp;            } else if (lastTargetID &gt;= visibleTargets.length) {</b>
<b class="nc">&nbsp;                lastTargetID = 0;</b>
&nbsp;            }
&nbsp;            //If we&#39;ve cycled through all visible targets without finding a valid one, stop looping
<b class="nc">&nbsp;            count++;</b>
<b class="nc">&nbsp;            if (count &gt; visibleTargets.length) {</b>
<b class="nc">&nbsp;            	return null;</b>
&nbsp;            }
&nbsp;            // Store target
<b class="nc">&nbsp;            result = visibleTargets[lastTargetID];</b>
<b class="nc">&nbsp;            done = true;</b>
&nbsp;            // Check done
<b class="nc">&nbsp;            if (onlyValid) {</b>
<b class="nc">&nbsp;                ToHitData toHit = WeaponAttackAction.toHit(</b>
<b class="nc">&nbsp;                        clientgui.getClient().getGame(), ce().getId(), result,</b>
<b class="nc">&nbsp;                        clientgui.mechD.wPan.getSelectedWeaponNum(),</b>
&nbsp;                        isStrafing);
<b class="nc">&nbsp;                done &amp;= toHit.getValue() != TargetRoll.AUTOMATIC_FAIL</b>
<b class="nc">&nbsp;                        &amp;&amp; toHit.getValue() != TargetRoll.IMPOSSIBLE</b>
<b class="nc">&nbsp;                        &amp;&amp; toHit.getValue() &lt;= 12;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (ignoreAllies) {</b>
<b class="nc">&nbsp;                done &amp;= result.isEnemyOf(ce());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Jump to our next target. If there isn&#39;t one, well, don&#39;t do anything.
&nbsp;     */
&nbsp;    private void jumpToTarget(boolean nextTarg, boolean onlyValid,
&nbsp;            boolean ignoreAllies) {
<b class="nc">&nbsp;        Entity targ = getNextTarget(nextTarg, onlyValid, ignoreAllies);</b>
&nbsp;
<b class="nc">&nbsp;        if (targ == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // HACK : don&#39;t show the choice dialog.
<b class="nc">&nbsp;        showTargetChoice = false;</b>
&nbsp;
<b class="nc">&nbsp;        clientgui.bv.centerOnHex(targ.getPosition());</b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(targ.getPosition());</b>
&nbsp;
&nbsp;        // HACK : show the choice dialog again.
<b class="nc">&nbsp;        showTargetChoice = true;</b>
<b class="nc">&nbsp;        target(targ);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called when the current entity is done firing. Send out our attack queue
&nbsp;     * to the server.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void ready() {
<b class="nc">&nbsp;        if (attacks.isEmpty()</b>
<b class="nc">&nbsp;                &amp;&amp; GUIPreferences.getInstance().getNagForNoAction()) {</b>
&nbsp;            // comfirm this action
<b class="nc">&nbsp;            String title = Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.DontFireDialog.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            String body = Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.DontFireDialog.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            ConfirmDialog response = clientgui.doYesNoBotherDialog(title, body);</b>
<b class="nc">&nbsp;            if (!response.getShowAgain()) {</b>
<b class="nc">&nbsp;                GUIPreferences.getInstance().setNagForNoAction(false);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!response.getAnswer()) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // We need to nag for overheat on capital fighters
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; ce().isCapitalFighter()</b>
<b class="nc">&nbsp;            &amp;&amp; GUIPreferences.getInstance().getNagForOverheat()) {</b>
<b class="nc">&nbsp;            int totalheat = 0;</b>
<b class="nc">&nbsp;            for (EntityAction action : attacks) {</b>
<b class="nc">&nbsp;                if (action instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                    Mounted weapon = ce().getEquipment(</b>
<b class="nc">&nbsp;                            ((WeaponAttackAction) action).getWeaponId());</b>
<b class="nc">&nbsp;                    totalheat += weapon.getCurrentHeat();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (totalheat &gt; ce().getHeatCapacity()) {</b>
&nbsp;                // comfirm this action
<b class="nc">&nbsp;                String title = Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;FiringDisplay.OverheatNag.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                String body = Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;FiringDisplay.OverheatNag.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                ConfirmDialog response = clientgui.doYesNoBotherDialog(title,</b>
&nbsp;                        body);
<b class="nc">&nbsp;                if (!response.getShowAgain()) {</b>
<b class="nc">&nbsp;                    GUIPreferences.getInstance().setNagForOverheat(false);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!response.getAnswer()) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // stop further input (hopefully)
<b class="nc">&nbsp;        disableButtons();</b>
&nbsp;
&nbsp;        // remove temporary attacks from game &amp; board
<b class="nc">&nbsp;        removeTempAttacks();</b>
&nbsp;
&nbsp;        // For bug 1002223
&nbsp;        // Re-compute the to-hit numbers by adding in correct order.
<b class="nc">&nbsp;        Vector&lt;EntityAction&gt; newAttacks = new Vector&lt;EntityAction&gt;();</b>
<b class="nc">&nbsp;        for (EntityAction o : attacks) {</b>
<b class="nc">&nbsp;            if (o instanceof ArtilleryAttackAction) {</b>
<b class="nc">&nbsp;                newAttacks.addElement(o);</b>
<b class="nc">&nbsp;            } else if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                Entity attacker = waa</b>
<b class="nc">&nbsp;                        .getEntity(clientgui.getClient().getGame());</b>
<b class="nc">&nbsp;                Targetable target1 = waa.getTarget(clientgui.getClient()</b>
<b class="nc">&nbsp;                        .getGame());</b>
<b class="nc">&nbsp;                boolean curInFrontArc = Compute.isInArc(attacker.getPosition(),</b>
<b class="nc">&nbsp;                        attacker.getSecondaryFacing(), target1,</b>
<b class="nc">&nbsp;                        attacker.getForwardArc());</b>
<b class="nc">&nbsp;                if (curInFrontArc) {</b>
<b class="nc">&nbsp;                    WeaponAttackAction waa2 = new WeaponAttackAction(</b>
<b class="nc">&nbsp;                            waa.getEntityId(), waa.getTargetType(),</b>
<b class="nc">&nbsp;                            waa.getTargetId(), waa.getWeaponId());</b>
<b class="nc">&nbsp;                    waa2.setAimedLocation(waa.getAimedLocation());</b>
<b class="nc">&nbsp;                    waa2.setAimingMode(waa.getAimingMode());</b>
<b class="nc">&nbsp;                    waa2.setOtherAttackInfo(waa.getOtherAttackInfo());</b>
<b class="nc">&nbsp;                    waa2.setAmmoId(waa.getAmmoId());</b>
<b class="nc">&nbsp;                    waa2.setAmmoCarrier(waa.getAmmoCarrier());</b>
<b class="nc">&nbsp;                    waa2.setBombPayload(waa.getBombPayload());</b>
<b class="nc">&nbsp;                    waa2.setStrafing(waa.isStrafing());</b>
<b class="nc">&nbsp;                    waa2.setStrafingFirstShot(waa.isStrafingFirstShot());</b>
<b class="nc">&nbsp;                    newAttacks.addElement(waa2);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                newAttacks.addElement(o);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        // now add the attacks in rear/arm arcs
<b class="nc">&nbsp;        for (EntityAction o : attacks) {</b>
<b class="nc">&nbsp;            if (o instanceof ArtilleryAttackAction) {</b>
&nbsp;                // newAttacks.addElement(o);
<b class="nc">&nbsp;                continue;</b>
<b class="nc">&nbsp;            } else if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                Entity attacker = waa</b>
<b class="nc">&nbsp;                        .getEntity(clientgui.getClient().getGame());</b>
<b class="nc">&nbsp;                Targetable target1 = waa.getTarget(clientgui.getClient()</b>
<b class="nc">&nbsp;                        .getGame());</b>
<b class="nc">&nbsp;                boolean curInFrontArc = Compute.isInArc(attacker.getPosition(),</b>
<b class="nc">&nbsp;                        attacker.getSecondaryFacing(), target1,</b>
<b class="nc">&nbsp;                        attacker.getForwardArc());</b>
<b class="nc">&nbsp;                if (!curInFrontArc) {</b>
<b class="nc">&nbsp;                    WeaponAttackAction waa2 = new WeaponAttackAction(</b>
<b class="nc">&nbsp;                            waa.getEntityId(), waa.getTargetType(),</b>
<b class="nc">&nbsp;                            waa.getTargetId(), waa.getWeaponId());</b>
<b class="nc">&nbsp;                    waa2.setAimedLocation(waa.getAimedLocation());</b>
<b class="nc">&nbsp;                    waa2.setAimingMode(waa.getAimingMode());</b>
<b class="nc">&nbsp;                    waa2.setOtherAttackInfo(waa.getOtherAttackInfo());</b>
<b class="nc">&nbsp;                    waa2.setAmmoId(waa.getAmmoId());</b>
<b class="nc">&nbsp;                    waa2.setAmmoCarrier(waa.getAmmoCarrier());</b>
<b class="nc">&nbsp;                    waa2.setBombPayload(waa.getBombPayload());</b>
<b class="nc">&nbsp;                    waa2.setStrafing(waa.isStrafing());</b>
<b class="nc">&nbsp;                    waa2.setStrafingFirstShot(waa.isStrafingFirstShot());</b>
<b class="nc">&nbsp;                    newAttacks.addElement(waa2);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // If the user picked a hex along the flight path, server needs to know
<b class="nc">&nbsp;        if ((target instanceof Entity) &amp;&amp; Compute.isGroundToAir(ce(), target)) {</b>
<b class="nc">&nbsp;            Coords targetPos = ((Entity)target).getPlayerPickedPassThrough(cen);</b>
<b class="nc">&nbsp;            if (targetPos != null) {</b>
<b class="nc">&nbsp;                clientgui.getClient().sendPlayerPickedPassThrough(</b>
<b class="nc">&nbsp;                        ((Entity) target).getId(), cen, targetPos);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // send out attacks
<b class="nc">&nbsp;        clientgui.getClient().sendAttackData(cen, newAttacks);</b>
&nbsp;
&nbsp;        // clear queue
<b class="nc">&nbsp;        attacks.removeAllElements();</b>
&nbsp;
&nbsp;        // Clear the menu bar.
<b class="nc">&nbsp;        clientgui.getMenuBar().setEntity(null);</b>
&nbsp;
&nbsp;        // close aimed shot display, if any
<b class="nc">&nbsp;        ash.closeDialog();</b>
&nbsp;
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; ce().isWeapOrderChanged()) {</b>
<b class="nc">&nbsp;            clientgui.getClient().sendEntityWeaponOrderUpdate(ce());</b>
&nbsp;        }
<b class="nc">&nbsp;        endMyTurn();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * clear turret
&nbsp;     */
&nbsp;    private void doClearTurret() {
<b class="nc">&nbsp;        String title = Messages.getString(&quot;FiringDisplay.ClearTurret.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        String body = Messages.getString(&quot;FiringDisplay.ClearTurret.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        if (!clientgui.doYesNoDialog(title, body)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if ((((attacks.size() == 0) &amp;&amp; (ce() instanceof Tank) &amp;&amp; (((Tank) ce())</b>
<b class="nc">&nbsp;                .isTurretJammed(((Tank) ce()).getLocTurret()))) || ((Tank) ce())</b>
<b class="nc">&nbsp;                .isTurretJammed(((Tank) ce()).getLocTurret2()))) {</b>
<b class="nc">&nbsp;            UnjamTurretAction uta = new UnjamTurretAction(ce().getId());</b>
<b class="nc">&nbsp;            attacks.add(uta);</b>
<b class="nc">&nbsp;            ready();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * clear weapon jam
&nbsp;     */
&nbsp;    private void doClearWeaponJam() {
<b class="nc">&nbsp;        ArrayList&lt;Mounted&gt; weapons = ((Tank) ce()).getJammedWeapons();</b>
<b class="nc">&nbsp;        String[] names = new String[weapons.size()];</b>
<b class="nc">&nbsp;        for (int loop = 0; loop &lt; names.length; loop++) {</b>
<b class="nc">&nbsp;            names[loop] = weapons.get(loop).getDesc();</b>
&nbsp;        }
<b class="nc">&nbsp;        String input = (String) JOptionPane.showInputDialog(clientgui, Messages</b>
<b class="nc">&nbsp;                .getString(&quot;FiringDisplay.ClearWeaponJam&quot; + &quot;.question&quot;), //$NON-NLS-1$ //$NON-NLS-2$</b>
<b class="nc">&nbsp;                Messages.getString(&quot;FiringDisplay.ClearWeaponJam.title&quot;), //$NON-NLS-1$</b>
&nbsp;                //$NON-NLS-1$
&nbsp;                JOptionPane.QUESTION_MESSAGE, null, names, null);
&nbsp;
<b class="nc">&nbsp;        if (input != null) {</b>
<b class="nc">&nbsp;            for (int loop = 0; loop &lt; names.length; loop++) {</b>
<b class="nc">&nbsp;                if (input.equals(names[loop])) {</b>
<b class="nc">&nbsp;                    RepairWeaponMalfunctionAction rwma = new RepairWeaponMalfunctionAction(</b>
<b class="nc">&nbsp;                            ce().getId(), ce().getEquipmentNum(</b>
<b class="nc">&nbsp;                                    weapons.get(loop)));</b>
<b class="nc">&nbsp;                    attacks.add(rwma);</b>
<b class="nc">&nbsp;                    ready();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * fire searchlight
&nbsp;     */
&nbsp;    protected void doSearchlight() {
&nbsp;        // validate
<b class="nc">&nbsp;        if ((ce() == null) || (target == null)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;current searchlight parameters are invalid&quot;); //$NON-NLS-1$
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!SearchlightAttackAction.isPossible(</b>
<b class="nc">&nbsp;                clientgui.getClient().getGame(), cen, target, null)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // create and queue a searchlight action
<b class="nc">&nbsp;        SearchlightAttackAction saa = new SearchlightAttackAction(cen,</b>
<b class="nc">&nbsp;                target.getTargetType(), target.getTargetId());</b>
<b class="nc">&nbsp;        attacks.addElement(saa);</b>
&nbsp;
&nbsp;        // and add it into the game, temporarily
<b class="nc">&nbsp;        clientgui.getClient().getGame().addAction(saa);</b>
<b class="nc">&nbsp;        clientgui.bv.addAttack(saa);</b>
<b class="nc">&nbsp;        clientgui.minimap.drawMap();</b>
&nbsp;
&nbsp;        // refresh weapon panel, as bth will have changed
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private void doStrafe() {
<b class="nc">&nbsp;        target(null);</b>
<b class="nc">&nbsp;        clearAttacks();        </b>
<b class="nc">&nbsp;        isStrafing = true;</b>
<b class="nc">&nbsp;        setStatusBarText(Messages</b>
<b class="nc">&nbsp;                .getString(&quot;FiringDisplay.Strafing.StatusLabel&quot;));</b>
<b class="nc">&nbsp;        refreshAll();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private void updateStrafingTargets() {
<b class="nc">&nbsp;        final IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;        final int weaponId = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        final Mounted m = ce().getEquipment(weaponId);</b>
&nbsp;        ToHitData toHit;
<b class="nc">&nbsp;        StringBuffer toHitBuff = new StringBuffer();</b>
<b class="nc">&nbsp;        setFireEnabled(true);</b>
<b class="nc">&nbsp;        for (Coords c : strafingCoords) {</b>
<b class="nc">&nbsp;            for (Entity t : game.getEntitiesVector(c)) {</b>
&nbsp;                // Airborne units cannot be strafed
<b class="nc">&nbsp;                if (t.isAirborne()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Can&#39;t shoot at infantry in the building
&nbsp;                // Instead, strafe will hit the building, which could damage Inf
<b class="nc">&nbsp;                if (Compute.isInBuilding(game, t) &amp;&amp; (t instanceof Infantry)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                toHit = WeaponAttackAction.toHit(game, cen, t, weaponId,</b>
&nbsp;                        Entity.LOC_NONE, IAimingModes.AIM_MODE_NONE, true);
<b class="nc">&nbsp;                toHitBuff.append(t.getShortName() + &quot;: &quot;);</b>
<b class="nc">&nbsp;                toHitBuff.append(toHit.getDesc());</b>
<b class="nc">&nbsp;                toHitBuff.append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;                if (m.getType().hasFlag(WeaponType.F_AUTO_TARGET)</b>
<b class="nc">&nbsp;                        || (toHit.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
<b class="nc">&nbsp;                    setFireEnabled(false);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Building bldg = game.getBoard().getBuildingAt(c); </b>
<b class="nc">&nbsp;            if (bldg != null) {</b>
<b class="nc">&nbsp;                Targetable t = new BuildingTarget(c, game.getBoard(), false);</b>
<b class="nc">&nbsp;                toHit = WeaponAttackAction.toHit(game, cen, t, weaponId,</b>
&nbsp;                        Entity.LOC_NONE, IAimingModes.AIM_MODE_NONE, true);
<b class="nc">&nbsp;                toHitBuff.append(t.getDisplayName() + &quot;: &quot;);</b>
<b class="nc">&nbsp;                toHitBuff.append(toHit.getDesc());</b>
<b class="nc">&nbsp;                toHitBuff.append(&quot;\n&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            Targetable hexTarget = new HexTarget(c, game.getBoard(),</b>
&nbsp;                    HexTarget.TYPE_HEX_CLEAR);
<b class="nc">&nbsp;            toHit = WeaponAttackAction.toHit(game, cen, hexTarget, weaponId,</b>
&nbsp;                    Entity.LOC_NONE, IAimingModes.AIM_MODE_NONE, true);
<b class="nc">&nbsp;            if (m.getType().hasFlag(WeaponType.F_AUTO_TARGET)</b>
<b class="nc">&nbsp;                    || (toHit.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;                if (toHitBuff.length() &lt; 1) {</b>
<b class="nc">&nbsp;                    toHitBuff.append(toHit.getDesc());</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // Could check legality on buildings, but I don&#39;t believe there are
&nbsp;            // any weapons that are still legal that aren&#39;t legal on buildings            
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.toHitText.setText(toHitBuff.toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    private int[] getBombPayload(boolean isSpace, int limit) {
<b class="nc">&nbsp;        int[] payload = new int[BombType.B_NUM];</b>
<b class="nc">&nbsp;        if (!ce().isBomber()) {</b>
<b class="nc">&nbsp;            return payload;</b>
&nbsp;        }
<b class="nc">&nbsp;        int[] loadout = ce().getBombLoadout();</b>
&nbsp;        // this part is ugly, but we need to find any other bombing attacks by
&nbsp;        // this
&nbsp;        // entity in the attack list and subtract those payloads from the
&nbsp;        // loadout
<b class="nc">&nbsp;        for (EntityAction o : attacks) {</b>
<b class="nc">&nbsp;            if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                if (waa.getEntityId() == ce().getId()) {</b>
<b class="nc">&nbsp;                    int[] priorLoad = waa.getBombPayload();</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; priorLoad.length; i++) {</b>
<b class="nc">&nbsp;                        loadout[i] = loadout[i] - priorLoad[i];</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        int numFighters = ce().getActiveSubEntities().orElse(Collections.emptyList()).size();</b>
<b class="nc">&nbsp;        BombPayloadDialog bombsDialog = new BombPayloadDialog(</b>
&nbsp;                clientgui.frame,
<b class="nc">&nbsp;                Messages.getString(&quot;FiringDisplay.BombNumberDialog&quot; + &quot;.title&quot;), //$NON-NLS-1$</b>
&nbsp;                loadout, isSpace, false, limit, numFighters);
<b class="nc">&nbsp;        bombsDialog.setVisible(true);</b>
<b class="nc">&nbsp;        if (bombsDialog.getAnswer()) {</b>
<b class="nc">&nbsp;            payload = bombsDialog.getChoices();</b>
&nbsp;        }
<b class="nc">&nbsp;        return payload;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a weapon attack with the currently selected weapon to the attack
&nbsp;     * queue.
&nbsp;     */
&nbsp;    void fire() {
<b class="nc">&nbsp;        final IGame game = clientgui.getClient().getGame();</b>
&nbsp;        // get the selected weaponnum
<b class="nc">&nbsp;        final int weaponNum = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        Mounted mounted = ce().getEquipment(weaponNum);</b>
&nbsp;
&nbsp;        // validate
<b class="nc">&nbsp;        if ((ce() == null)</b>
<b class="nc">&nbsp;                || (target == null &amp;&amp; (!isStrafing || strafingCoords.size() == 0))</b>
&nbsp;                || (mounted == null)
<b class="nc">&nbsp;                || !(mounted.getType() instanceof WeaponType)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;current fire parameters are invalid&quot;); //$NON-NLS-1$
&nbsp;        }
&nbsp;        // check if we now shoot at a target in the front arc and previously
&nbsp;        // shot a target in side/rear arc that then was primary target
&nbsp;        // if so, ask and tell the user that to-hits will change
<b class="nc">&nbsp;        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_FORCED_PRIMARY_TARGETS)</b>
<b class="nc">&nbsp;                &amp;&amp; (ce() instanceof Mech) || (ce() instanceof Tank)</b>
<b class="nc">&nbsp;                || (ce() instanceof Protomech)) {</b>
<b class="nc">&nbsp;            EntityAction lastAction = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                lastAction = attacks.lastElement();</b>
<b class="nc">&nbsp;            } catch (NoSuchElementException ex) {</b>
&nbsp;                // ignore
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if ((lastAction != null)</b>
&nbsp;                    &amp;&amp; (lastAction instanceof WeaponAttackAction)) {
<b class="nc">&nbsp;                WeaponAttackAction oldWaa = (WeaponAttackAction) lastAction;</b>
<b class="nc">&nbsp;                Targetable oldTarget = oldWaa.getTarget(game);</b>
<b class="nc">&nbsp;                if (!oldTarget.equals(target)) {</b>
<b class="nc">&nbsp;                    boolean oldInFront = Compute.isInArc(ce().getPosition(),</b>
<b class="nc">&nbsp;                            ce().getSecondaryFacing(), oldTarget, ce()</b>
<b class="nc">&nbsp;                                    .getForwardArc());</b>
<b class="nc">&nbsp;                    boolean curInFront = Compute.isInArc(ce().getPosition(),</b>
<b class="nc">&nbsp;                            ce().getSecondaryFacing(), target, ce()</b>
<b class="nc">&nbsp;                                    .getForwardArc());</b>
<b class="nc">&nbsp;                    if (!oldInFront &amp;&amp; curInFront) {</b>
<b class="nc">&nbsp;                        String title = Messages</b>
<b class="nc">&nbsp;                                .getString(&quot;FiringDisplay.SecondaryTargetToHitChange.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        String body = Messages</b>
<b class="nc">&nbsp;                                .getString(&quot;FiringDisplay.SecondaryTargetToHitChange.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        if (!clientgui.doYesNoDialog(title, body)) {</b>
&nbsp;                            return;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // declare searchlight, if possible
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getAutoDeclareSearchlight()</b>
<b class="nc">&nbsp;            &amp;&amp; ce().isUsingSpotlight()) {</b>
<b class="nc">&nbsp;            doSearchlight();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Targetable&gt; targets = new ArrayList&lt;Targetable&gt;();</b>
<b class="nc">&nbsp;        if (isStrafing) {</b>
<b class="nc">&nbsp;            for (Coords c : strafingCoords) {</b>
<b class="nc">&nbsp;                targets.add(new HexTarget(c, game.getBoard(),</b>
&nbsp;                        Targetable.TYPE_HEX_CLEAR));
<b class="nc">&nbsp;                Building bldg = game.getBoard().getBuildingAt(c); </b>
<b class="nc">&nbsp;                if (bldg != null) {</b>
<b class="nc">&nbsp;                    targets.add(new BuildingTarget(c, game.getBoard(), false));</b>
&nbsp;                }
&nbsp;                // Target all ground units (non-airborne, VTOLs still count)
<b class="nc">&nbsp;                for (Entity t : game.getEntitiesVector(c)) {</b>
<b class="nc">&nbsp;                    boolean infInBuilding = Compute.isInBuilding(game, t)</b>
&nbsp;                            &amp;&amp; (t instanceof Infantry);
<b class="nc">&nbsp;                    if (!t.isAirborne() &amp;&amp; !infInBuilding) {</b>
<b class="nc">&nbsp;                        targets.add(t);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
<b class="nc">&nbsp;            targets.add(target);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        boolean firstShot = true;</b>
<b class="nc">&nbsp;        for (Targetable t : targets) {</b>
&nbsp;        
&nbsp;            WeaponAttackAction waa;
<b class="nc">&nbsp;            if (!(mounted.getType().hasFlag(WeaponType.F_ARTILLERY)</b>
<b class="nc">&nbsp;                    || (mounted.getType() instanceof CapitalMissileWeapon</b>
<b class="nc">&nbsp;                            &amp;&amp; Compute.isGroundToGround(ce(), t)))){</b>
<b class="nc">&nbsp;                waa = new WeaponAttackAction(cen, t.getTargetType(),</b>
<b class="nc">&nbsp;                        t.getTargetId(), weaponNum);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                waa = new ArtilleryAttackAction(cen, t.getTargetType(),</b>
<b class="nc">&nbsp;                        t.getTargetId(), weaponNum, game);</b>
&nbsp;            }
&nbsp;
&nbsp;            // check for a bomb payload dialog
<b class="nc">&nbsp;            if (mounted.getType().hasFlag(WeaponType.F_SPACE_BOMB)) {</b>
<b class="nc">&nbsp;                int[] payload = getBombPayload(true, -1);</b>
<b class="nc">&nbsp;                waa.setBombPayload(payload);</b>
<b class="nc">&nbsp;            } else if (mounted.getType().hasFlag(WeaponType.F_DIVE_BOMB)) {</b>
<b class="nc">&nbsp;                int[] payload = getBombPayload(false, -1);</b>
<b class="nc">&nbsp;                waa.setBombPayload(payload);</b>
<b class="nc">&nbsp;            } else if (mounted.getType().hasFlag(WeaponType.F_ALT_BOMB)) {</b>
&nbsp;                // if the user cancels, then return
<b class="nc">&nbsp;                int[] payload = getBombPayload(false, 2);</b>
<b class="nc">&nbsp;                waa.setBombPayload(payload);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if ((mounted.getLinked() != null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (((WeaponType) mounted.getType()).getAmmoType() != AmmoType.T_NA)</b>
<b class="nc">&nbsp;                    &amp;&amp; (mounted.getLinked().getType() instanceof AmmoType)) {</b>
<b class="nc">&nbsp;                Mounted ammoMount = mounted.getLinked();</b>
<b class="nc">&nbsp;                AmmoType ammoType = (AmmoType) ammoMount.getType();</b>
<b class="nc">&nbsp;                waa.setAmmoId(ammoMount.getEntity().getEquipmentNum(ammoMount));</b>
<b class="nc">&nbsp;                waa.setAmmoCarrier(ammoMount.getEntity().getId());</b>
<b class="nc">&nbsp;                if (((ammoType.getMunitionType() == AmmoType.M_THUNDER_VIBRABOMB) &amp;&amp; </b>
<b class="nc">&nbsp;                        ((ammoType.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_LRM_IMP)</b>
<b class="nc">&nbsp;                        || (ammoType.getAmmoType() == AmmoType.T_MML)))</b>
<b class="nc">&nbsp;                        || (ammoType.getMunitionType() == AmmoType.M_VIBRABOMB_IV)) {</b>
<b class="nc">&nbsp;                    VibrabombSettingDialog vsd = new VibrabombSettingDialog(</b>
&nbsp;                            clientgui.frame);
<b class="nc">&nbsp;                    vsd.setVisible(true);</b>
<b class="nc">&nbsp;                    waa.setOtherAttackInfo(vsd.getSetting());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (ash.allowAimedShotWith(mounted) &amp;&amp; ash.inAimingMode()</b>
<b class="nc">&nbsp;                    &amp;&amp; ash.isAimingAtLocation()) {</b>
<b class="nc">&nbsp;                waa.setAimedLocation(ash.getAimingAt());</b>
<b class="nc">&nbsp;                waa.setAimingMode(ash.getAimingMode());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                waa.setAimedLocation(Entity.LOC_NONE);</b>
<b class="nc">&nbsp;                waa.setAimingMode(IAimingModes.AIM_MODE_NONE);</b>
&nbsp;            }
<b class="nc">&nbsp;            waa.setStrafing(isStrafing);</b>
<b class="nc">&nbsp;            waa.setStrafingFirstShot(firstShot);</b>
<b class="nc">&nbsp;            firstShot = false;</b>
&nbsp;
&nbsp;            // add the attack to our temporary queue
<b class="nc">&nbsp;            attacks.addElement(waa);</b>
&nbsp;
&nbsp;            // and add it into the game, temporarily
<b class="nc">&nbsp;            game.addAction(waa);</b>
&nbsp;        
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        clientgui.minimap.drawMap();</b>
&nbsp;
&nbsp;        // set the weapon as used
<b class="nc">&nbsp;        mounted.setUsedThisRound(true);</b>
&nbsp;
&nbsp;        // find the next available weapon
<b class="nc">&nbsp;        int nextWeapon = clientgui.mechD.wPan.getNextWeaponNum();</b>
&nbsp;
&nbsp;        // we fired a weapon, can&#39;t clear turret jams or weapon jams anymore
<b class="nc">&nbsp;        updateClearTurret();</b>
<b class="nc">&nbsp;        updateClearWeaponJam();</b>
&nbsp;
&nbsp;        // check; if there are no ready weapons, you&#39;re done.
<b class="nc">&nbsp;        if ((nextWeapon == -1)</b>
<b class="nc">&nbsp;            &amp;&amp; GUIPreferences.getInstance().getAutoEndFiring()) {</b>
<b class="nc">&nbsp;            ready();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // otherwise, display firing info for the next weapon
<b class="nc">&nbsp;        clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;        Mounted nextMounted = ce().getEquipment(nextWeapon);</b>
<b class="nc">&nbsp;        if (!mounted.getType().hasFlag(WeaponType.F_VGL)</b>
&nbsp;                &amp;&amp; (nextMounted != null)
<b class="nc">&nbsp;                &amp;&amp; nextMounted.getType().hasFlag(WeaponType.F_VGL)) {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.setPrevTarget(target);</b>
&nbsp;        }
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectWeapon(nextWeapon);</b>
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Skips to the next weapon
&nbsp;     */
&nbsp;    void nextWeapon() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectNextWeapon();</b>
&nbsp;
<b class="nc">&nbsp;        if (ce().getId() != clientgui.mechD.wPan.getSelectedEntityId()) {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.displayMech(ce());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Skips to the previous weapon
&nbsp;     */
&nbsp;    void prevWeapon() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectPrevWeapon();</b>
&nbsp;
<b class="nc">&nbsp;        if (ce().getId() != clientgui.mechD.wPan.getSelectedEntityId()) {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.displayMech(ce());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The entity spends the rest of its turn finding a club
&nbsp;     */
&nbsp;    private void findClub() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // comfirm this action
<b class="nc">&nbsp;        String title = Messages.getString(&quot;FiringDisplay.FindClubDialog.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        String body = Messages</b>
<b class="nc">&nbsp;                .getString(&quot;FiringDisplay.FindClubDialog.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        if (!clientgui.doYesNoDialog(title, body)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        attacks.removeAllElements();</b>
<b class="nc">&nbsp;        attacks.addElement(new FindClubAction(cen));</b>
&nbsp;
<b class="nc">&nbsp;        ready();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The entity spends the rest of its turn spotting
&nbsp;     */
&nbsp;    protected void doSpot() {
<b class="nc">&nbsp;        if ((ce() == null) || (target == null)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (ce().isINarcedWith(INarcPod.HAYWIRE)) {</b>
<b class="nc">&nbsp;            String title = Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.CantSpotDialog.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            String body = Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.CantSpotDialog.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.doAlertDialog(title, body);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // comfirm this action
<b class="nc">&nbsp;        String title = Messages</b>
<b class="nc">&nbsp;                .getString(&quot;FiringDisplay.SpotForInderectDialog.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        String body = Messages</b>
<b class="nc">&nbsp;                .getString(&quot;FiringDisplay.SpotForInderectDialog.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        if (!clientgui.doYesNoDialog(title, body)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        attacks.addElement(new SpotAction(cen, target.getTargetId()));</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all current fire
&nbsp;     */
&nbsp;    protected void clearAttacks() {
<b class="nc">&nbsp;        isStrafing = false;</b>
<b class="nc">&nbsp;        strafingCoords.clear();</b>
<b class="nc">&nbsp;        clientgui.bv.clearStrafingCoords();</b>
&nbsp;        
&nbsp;        // We may not have an entity selected yet (race condition).
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        
&nbsp;        // remove attacks, set weapons available again
<b class="nc">&nbsp;        Enumeration&lt;AbstractEntityAction&gt; i = attacks.elements();</b>
<b class="nc">&nbsp;        while (i.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Object o = i.nextElement();</b>
<b class="nc">&nbsp;            if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                ce().getEquipment(waa.getWeaponId()).setUsedThisRound(false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        attacks.removeAllElements();</b>
&nbsp;
&nbsp;        // remove temporary attacks from game &amp; board
<b class="nc">&nbsp;        removeTempAttacks();</b>
&nbsp;
&nbsp;        // restore any other movement to default
<b class="nc">&nbsp;        ce().setSecondaryFacing(ce().getFacing());</b>
<b class="nc">&nbsp;        ce().setArmsFlipped(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes temp attacks from the game and board
&nbsp;     */
&nbsp;    protected void removeTempAttacks() {
&nbsp;        // remove temporary attacks from game &amp; board
<b class="nc">&nbsp;        clientgui.getClient().getGame().removeActionsFor(cen);</b>
<b class="nc">&nbsp;        clientgui.bv.removeAttacksFor(ce());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * removes the last action
&nbsp;     */
&nbsp;    protected void removeLastFiring() {
<b class="nc">&nbsp;        if (!attacks.isEmpty()) {</b>
<b class="nc">&nbsp;            Object o = attacks.lastElement();</b>
<b class="nc">&nbsp;            if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                ce().getEquipment(waa.getWeaponId()).setUsedThisRound(false);</b>
<b class="nc">&nbsp;                attacks.removeElement(o);</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;                clientgui.getClient().getGame().removeAction(o);</b>
<b class="nc">&nbsp;                clientgui.bv.refreshAttacks();</b>
<b class="nc">&nbsp;                clientgui.minimap.drawMap();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Refreshes all displays.
&nbsp;     */
&nbsp;    protected void refreshAll() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        clientgui.bv.redrawEntity(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.displayEntity(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.showPanel(&quot;weapons&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectFirstWeapon();</b>
<b class="nc">&nbsp;        if (ce().isMakingVTOLGroundAttack()) {</b>
<b class="nc">&nbsp;            this.updateVTOLGroundTarget();</b>
&nbsp;        }
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Targets something
&nbsp;     */
&nbsp;    public void target(Targetable t) {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        final int weaponId = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        Mounted weapon = ce().getEquipment(weaponId); </b>
&nbsp;        // Some weapons pick an automatic target
<b class="nc">&nbsp;        if ((weapon != null) &amp;&amp; weapon.getType().hasFlag(WeaponType.F_VGL)) {</b>
&nbsp;            int facing;
<b class="nc">&nbsp;            if (ce().isSecondaryArcWeapon(weaponId)) {</b>
<b class="nc">&nbsp;                facing = ce().getSecondaryFacing();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                facing = ce().getFacing();</b>
&nbsp;            }
<b class="nc">&nbsp;            facing = (facing + weapon.getFacing()) % 6;</b>
<b class="nc">&nbsp;            Coords c = ce().getPosition().translated(facing);</b>
<b class="nc">&nbsp;            Targetable hexTarget = </b>
&nbsp;                    new HexTarget(c, Targetable.TYPE_HEX_CLEAR);
&nbsp;            // Ignore events that will be generated by the select/cursor calls
<b class="nc">&nbsp;            setIgnoringEvents(true);</b>
<b class="nc">&nbsp;            clientgui.getBoardView().select(c);</b>
<b class="nc">&nbsp;            setIgnoringEvents(false);</b>
<b class="nc">&nbsp;            target = hexTarget;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            target = t;</b>
<b class="nc">&nbsp;            if ((visibleTargets != null) &amp;&amp; (target != null)) {</b>
&nbsp;                // Set last target ID, so next/prev target behaves correctly
<b class="nc">&nbsp;                for (int i = 0; i &lt; visibleTargets.length; i++) {</b>
<b class="nc">&nbsp;                    if (visibleTargets[i].getId() == target.getTargetId()) {</b>
<b class="nc">&nbsp;                        lastTargetID = i;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if ((target instanceof Entity) &amp;&amp; Compute.isGroundToAir(ce(), target)) {</b>
<b class="nc">&nbsp;            Coords targetPos = Compute.getClosestFlightPath(cen, ce()</b>
<b class="nc">&nbsp;                    .getPosition(), (Entity) target);</b>
<b class="nc">&nbsp;            clientgui.getBoardView().cursor(targetPos);</b>
&nbsp;        }
<b class="nc">&nbsp;        ash.setAimingMode();</b>
<b class="nc">&nbsp;        updateTarget();</b>
<b class="nc">&nbsp;        ash.showDialog();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Targets something
&nbsp;     */
&nbsp;    public void updateTarget() {
<b class="nc">&nbsp;        setFireEnabled(false);</b>
<b class="nc">&nbsp;        IGame game = clientgui.getClient().getGame();</b>
&nbsp;        // allow spotting
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; !ce().isSpotting() &amp;&amp; ce().canSpot() &amp;&amp; (target != null)</b>
<b class="nc">&nbsp;                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)) { //$NON-NLS-1$)</b>
<b class="nc">&nbsp;            boolean hasLos = LosEffects.calculateLos(game, cen, target)</b>
<b class="nc">&nbsp;                    .canSee();</b>
&nbsp;            // In double blind, we need to &quot;spot&quot; the target as well as LoS
<b class="nc">&nbsp;            if (hasLos</b>
<b class="nc">&nbsp;                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</b>
<b class="nc">&nbsp;                    &amp;&amp; !Compute.inVisualRange(game, ce(), target)</b>
<b class="nc">&nbsp;                    &amp;&amp; !Compute.inSensorRange(game, ce(), target, null)) {</b>
<b class="nc">&nbsp;                hasLos = false;</b>
&nbsp;            }
<b class="nc">&nbsp;            setSpotEnabled(hasLos);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            setSpotEnabled(false);</b>
&nbsp;        }
&nbsp;
&nbsp;        // update target panel
<b class="nc">&nbsp;        final int weaponId = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        if (isStrafing &amp;&amp; weaponId != -1) {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wTargetR.setText(Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.Strafing.TargetLabel&quot;));</b>
<b class="nc">&nbsp;            updateStrafingTargets();</b>
<b class="nc">&nbsp;        } else if ((target != null) &amp;&amp; (target.getPosition() != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (weaponId != -1) &amp;&amp; (ce() != null)) {</b>
&nbsp;            ToHitData toHit;
<b class="nc">&nbsp;            if (ash.inAimingMode()) {</b>
<b class="nc">&nbsp;                Mounted weapon = ce().getEquipment(weaponId);</b>
<b class="nc">&nbsp;                boolean aiming = ash.isAimingAtLocation()</b>
<b class="nc">&nbsp;                        &amp;&amp; ash.allowAimedShotWith(weapon);</b>
<b class="nc">&nbsp;                ash.setEnableAll(aiming);</b>
<b class="nc">&nbsp;                if (aiming) {</b>
<b class="nc">&nbsp;                    toHit = WeaponAttackAction.toHit(game, cen, target,</b>
<b class="nc">&nbsp;                            weaponId, ash.getAimingAt(), ash.getAimingMode(),</b>
&nbsp;                            false);
<b class="nc">&nbsp;                    clientgui.mechD.wPan.wTargetR.setText(target</b>
<b class="nc">&nbsp;                            .getDisplayName()</b>
<b class="nc">&nbsp;                            + &quot; (&quot; + ash.getAimingLocation() + &quot;)&quot;); //$NON-NLS-1$ // $NON-NLS-2$</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toHit = WeaponAttackAction.toHit(game, cen, target,</b>
&nbsp;                            weaponId, Entity.LOC_NONE,
&nbsp;                            IAimingModes.AIM_MODE_NONE, false);
<b class="nc">&nbsp;                    clientgui.mechD.wPan.wTargetR.setText(target</b>
<b class="nc">&nbsp;                            .getDisplayName());</b>
&nbsp;                }
<b class="nc">&nbsp;                ash.setPartialCover(toHit.getCover());</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                toHit = WeaponAttackAction.toHit(game, cen, target, weaponId,</b>
&nbsp;                        Entity.LOC_NONE, IAimingModes.AIM_MODE_NONE, false);
<b class="nc">&nbsp;                clientgui.mechD.wPan.wTargetR.setText(target.getDisplayName());</b>
&nbsp;            }
<b class="nc">&nbsp;            int effectiveDistance = Compute.effectiveDistance(</b>
<b class="nc">&nbsp;                    game, ce(), target);</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wRangeR.setText(&quot;&quot; + effectiveDistance); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            Mounted m = ce().getEquipment(weaponId);</b>
&nbsp;            // If we have a Centurion Weapon System selected, we may need to
&nbsp;            //  update ranges.
<b class="nc">&nbsp;            if (m.getType().hasFlag(WeaponType.F_CWS)) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.selectWeapon(weaponId);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (m.isUsedThisRound()) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;FiringDisplay.alreadyFired&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if ((m.getType().hasFlag(WeaponType.F_AUTO_TARGET) &amp;&amp; !m.curMode().equals(Weapon.MODE_AMS_MANUAL))</b>
<b class="nc">&nbsp;            			|| (m.getType().hasModes() &amp;&amp; m.curMode().equals(&quot;Point Defense&quot;))) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;FiringDisplay.autoFiringWeapon&quot;));</b>
&nbsp;                //$NON-NLS-1$
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if (m.isInBearingsOnlyMode()) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;FiringDisplay.bearingsOnlyWrongPhase&quot;));</b>
&nbsp;                //$NON-NLS-1$
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(toHit.getValueAsString());</b>
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if (toHit.getValue() == TargetRoll.AUTOMATIC_FAIL) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(toHit.getValueAsString());</b>
<b class="nc">&nbsp;                setFireEnabled(true);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                boolean natAptGunnery = ce().hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(toHit.getValueAsString()</b>
&nbsp;                        + &quot; (&quot;
<b class="nc">&nbsp;                        + Compute.oddsAbove(toHit.getValue(), natAptGunnery)</b>
&nbsp;                        + &quot;%)&quot;); //$NON-NLS-1$
&nbsp;                // $NON-NLS-2$
<b class="nc">&nbsp;                setFireEnabled(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            clientgui.mechD.wPan.toHitText.setText(toHit.getDesc());</b>
<b class="nc">&nbsp;            setSkipEnabled(true);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wTargetR.setText(&quot;---&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wRangeR.setText(&quot;---&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wToHitR.setText(&quot;---&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.toHitText.setText(&quot;&quot;); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((weaponId != -1) &amp;&amp; (ce() != null) &amp;&amp; !isStrafing) {</b>
<b class="nc">&nbsp;            adaptFireModeEnabled(ce().getEquipment(weaponId));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setFireModeEnabled(false);</b>
&nbsp;        } 
&nbsp;
<b class="nc">&nbsp;        updateSearchlight();</b>
&nbsp;
&nbsp;        // Hidden units can only spot
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; ce().isHidden()) {</b>
<b class="nc">&nbsp;            setFireEnabled(false);</b>
<b class="nc">&nbsp;            setTwistEnabled(false);</b>
<b class="nc">&nbsp;            setFindClubEnabled(false);</b>
<b class="nc">&nbsp;            setFlipArmsEnabled(false);</b>
<b class="nc">&nbsp;            setStrafeEnabled(false);</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.toHitText</b>
<b class="nc">&nbsp;                    .setText(&quot;Hidden units are only allowed to spot!&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A VTOL or LAM in airmech mode making a bombing or strafing attack already has the target set
&nbsp;     * during the movement phase. 
&nbsp;     */
&nbsp;    void updateVTOLGroundTarget() {
<b class="nc">&nbsp;        clientgui.bv.clearStrafingCoords();</b>
<b class="nc">&nbsp;        target(null);</b>
<b class="nc">&nbsp;        isStrafing = false;</b>
<b class="nc">&nbsp;        strafingCoords.clear();</b>
<b class="nc">&nbsp;        if (ce().isBomber() &amp;&amp; ((IBomber)ce()).isVTOLBombing()) {</b>
<b class="nc">&nbsp;            target(((IBomber)ce()).getVTOLBombTarget());</b>
<b class="nc">&nbsp;            clientgui.bv.addStrafingCoords(target.getPosition());</b>
<b class="nc">&nbsp;        } else if ((ce() instanceof VTOL) &amp;&amp; ((VTOL)ce()).getStrafingCoords().size() &gt; 0) {</b>
<b class="nc">&nbsp;            strafingCoords.addAll(((VTOL)ce()).getStrafingCoords());</b>
<b class="nc">&nbsp;            strafingCoords.forEach(c -&gt; clientgui.bv.addStrafingCoords(c));</b>
<b class="nc">&nbsp;            isStrafing = true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Torso twist in the proper direction.
&nbsp;     */
&nbsp;    void torsoTwist(Coords twistTarget) {
<b class="nc">&nbsp;        int direction = ce().getFacing();</b>
&nbsp;
<b class="nc">&nbsp;        if (twistTarget != null) {</b>
<b class="nc">&nbsp;            direction = ce().clipSecondaryFacing(</b>
<b class="nc">&nbsp;                    ce().getPosition().direction(twistTarget));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (direction != ce().getSecondaryFacing()) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            attacks.addElement(new TorsoTwistAction(cen, direction));</b>
<b class="nc">&nbsp;            ce().setSecondaryFacing(direction);</b>
<b class="nc">&nbsp;            refreshAll();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Torso twist to the left or right
&nbsp;     *
&nbsp;     * @param twistDir An &lt;code&gt;int&lt;/code&gt; specifying wether we&#39;re twisting left or
&nbsp;     *                 right, 0 if we&#39;re twisting to the left, 1 if to the right.
&nbsp;     */
&nbsp;
&nbsp;    void torsoTwist(int twistDir) {
<b class="nc">&nbsp;        int direction = ce().getSecondaryFacing();</b>
<b class="nc">&nbsp;        if (twistDir == 0) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            direction = ce().clipSecondaryFacing((direction + 5) % 6);</b>
<b class="nc">&nbsp;            attacks.addElement(new TorsoTwistAction(cen, direction));</b>
<b class="nc">&nbsp;            ce().setSecondaryFacing(direction);</b>
<b class="nc">&nbsp;            refreshAll();</b>
<b class="nc">&nbsp;        } else if (twistDir == 1) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            direction = ce().clipSecondaryFacing((direction + 7) % 6);</b>
<b class="nc">&nbsp;            attacks.addElement(new TorsoTwistAction(cen, direction));</b>
<b class="nc">&nbsp;            ce().setSecondaryFacing(direction);</b>
<b class="nc">&nbsp;            refreshAll();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current entity.
&nbsp;     */
&nbsp;    Entity ce() {
<b class="nc">&nbsp;        return clientgui.getClient().getGame().getEntity(cen);</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // BoardListener
&nbsp;    //
&nbsp;    @Override
&nbsp;    public void hexMoused(BoardViewEvent b) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // ignore buttons other than 1
<b class="nc">&nbsp;        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;            || ((b.getModifiers() &amp; InputEvent.BUTTON1_MASK) == 0)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // control pressed means a line of sight check.
&nbsp;        // added ALT_MASK by kenn
<b class="nc">&nbsp;        if (((b.getModifiers() &amp; InputEvent.CTRL_MASK) != 0)</b>
<b class="nc">&nbsp;            || ((b.getModifiers() &amp; InputEvent.ALT_MASK) != 0)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // check for shifty goodness
<b class="nc">&nbsp;        if (shiftheld != ((b.getModifiers() &amp; InputEvent.SHIFT_MASK) != 0)) {</b>
<b class="nc">&nbsp;            shiftheld = (b.getModifiers() &amp; InputEvent.SHIFT_MASK) != 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (b.getType() == BoardViewEvent.BOARD_HEX_DRAGGED) {</b>
<b class="nc">&nbsp;            if (shiftheld || twisting) {</b>
<b class="nc">&nbsp;                updateFlipArms(false);</b>
<b class="nc">&nbsp;                torsoTwist(b.getCoords());</b>
&nbsp;            }
<b class="nc">&nbsp;            clientgui.getBoardView().cursor(b.getCoords());</b>
<b class="nc">&nbsp;        } else if (b.getType() == BoardViewEvent.BOARD_HEX_CLICKED) {</b>
<b class="nc">&nbsp;            twisting = false;</b>
<b class="nc">&nbsp;            if (!shiftheld) {</b>
<b class="nc">&nbsp;                clientgui.getBoardView().select(b.getCoords());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void hexSelected(BoardViewEvent b) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Coords evtCoords = b.getCoords();</b>
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn() &amp;&amp; (evtCoords != null)</b>
<b class="nc">&nbsp;            &amp;&amp; (ce() != null)) {</b>
<b class="nc">&nbsp;            if (isStrafing) {</b>
<b class="nc">&nbsp;                if (validStrafingCoord(evtCoords)) {</b>
<b class="nc">&nbsp;                    strafingCoords.add(evtCoords);</b>
<b class="nc">&nbsp;                    clientgui.bv.addStrafingCoords(evtCoords);</b>
<b class="nc">&nbsp;                    updateStrafingTargets();</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (!evtCoords.equals(ce().getPosition())){</b>
&nbsp;                // HACK : sometimes we don&#39;t show the target choice window
<b class="nc">&nbsp;                Targetable targ = null;</b>
<b class="nc">&nbsp;                if (showTargetChoice) {</b>
<b class="nc">&nbsp;                    targ = chooseTarget(evtCoords);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (shiftheld) {</b>
<b class="nc">&nbsp;                    updateFlipArms(false);</b>
<b class="nc">&nbsp;                    torsoTwist(b.getCoords());</b>
<b class="nc">&nbsp;                } else if (targ != null &amp;&amp; !ce().isMakingVTOLGroundAttack()) {</b>
<b class="nc">&nbsp;                    if ((targ instanceof Entity) </b>
<b class="nc">&nbsp;                            &amp;&amp; Compute.isGroundToAir(ce(), targ)) {</b>
<b class="nc">&nbsp;                        Entity entTarg = (Entity)targ;</b>
<b class="nc">&nbsp;                        boolean alreadyShotAt = false;</b>
<b class="nc">&nbsp;                        List&lt;EntityAction&gt; actions = clientgui.getClient()</b>
<b class="nc">&nbsp;                                .getGame().getActionsVector();</b>
<b class="nc">&nbsp;                        for (EntityAction action : actions) {</b>
<b class="nc">&nbsp;                            if (!(action instanceof AttackAction)) {</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            AttackAction aa = (AttackAction)action;</b>
<b class="nc">&nbsp;                            if ((action.getEntityId() == cen) </b>
<b class="nc">&nbsp;                                    &amp;&amp; (aa.getTargetId() == entTarg.getId())) {</b>
<b class="nc">&nbsp;                                alreadyShotAt = true;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if (!alreadyShotAt) {</b>
<b class="nc">&nbsp;                            entTarg.setPlayerPickedPassThrough(cen, evtCoords);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    target(targ);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // GameListener
&nbsp;    //
&nbsp;    @Override
&nbsp;    public void gameTurnChange(GameTurnChangeEvent e) {
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // On simultaneous phases, each player ending their turn will generalte a turn change
&nbsp;        // We want to ignore turns from other players and only listen to events we generated
&nbsp;        // Except on the first turn
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().isPhaseSimultaneous()</b>
<b class="nc">&nbsp;                &amp;&amp; (e.getPreviousPlayerId() != clientgui.getClient().getLocalPlayerNumber())</b>
<b class="nc">&nbsp;                &amp;&amp; (clientgui.getClient().getGame().getTurnIndex() != 0)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;            if (clientgui.getClient().isMyTurn()) {</b>
<b class="nc">&nbsp;                if (cen == Entity.NONE) {</b>
<b class="nc">&nbsp;                    beginMyTurn();</b>
&nbsp;                }
<b class="nc">&nbsp;                setStatusBarText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;FiringDisplay.its_your_turn&quot;)); //$NON-NLS-1$</b>
&nbsp;            } else {
<b class="nc">&nbsp;                endMyTurn();</b>
&nbsp;                String playerName;
<b class="nc">&nbsp;                if (e.getPlayer() != null) {</b>
<b class="nc">&nbsp;                    playerName = e.getPlayer().getName();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    playerName = &quot;Unknown&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                setStatusBarText(Messages.getString(</b>
&nbsp;                        &quot;FiringDisplay.its_others_turn&quot;, //$NON-NLS-1$
&nbsp;                        new Object[] { playerName }));
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void gamePhaseChange(GamePhaseChangeEvent e) {
&nbsp;
&nbsp;        // In case of a /reset command, ensure the state gets reset
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getPhase() </b>
&nbsp;                == IGame.Phase.PHASE_LOUNGE) {
<b class="nc">&nbsp;            endMyTurn();</b>
&nbsp;        }
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                &amp;&amp; (clientgui.getClient().getGame().getPhase() </b>
&nbsp;                        != IGame.Phase.PHASE_FIRING)) {
<b class="nc">&nbsp;            endMyTurn();</b>
&nbsp;        }
&nbsp;        // if we&#39;re ending the firing phase, unregister stuff.
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getPhase() </b>
&nbsp;                == IGame.Phase.PHASE_FIRING) {
<b class="nc">&nbsp;            setStatusBarText(Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.waitingForFiringPhase&quot;)); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // ActionListener
&nbsp;    //
&nbsp;    public void actionPerformed(ActionEvent ev) {
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (statusBarActionPerformed(ev, clientgui.getClient())) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!clientgui.getClient().isMyTurn()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ev.getActionCommand().equals(FiringCommand.FIRE_FIRE.getCmd())) {</b>
<b class="nc">&nbsp;            fire();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_SKIP.getCmd())) {</b>
<b class="nc">&nbsp;            nextWeapon();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_TWIST.getCmd())) {</b>
<b class="nc">&nbsp;            twisting = true;</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_NEXT.getCmd())) {</b>
<b class="nc">&nbsp;            selectEntity(clientgui.getClient().getNextEntityNum(cen));</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_MORE.getCmd())) {</b>
<b class="nc">&nbsp;            currentButtonGroup++;</b>
<b class="nc">&nbsp;            currentButtonGroup %= numButtonGroups;</b>
<b class="nc">&nbsp;            setupButtonPanel();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_FIND_CLUB.getCmd())) {</b>
<b class="nc">&nbsp;            findClub();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_SPOT.getCmd())) {</b>
<b class="nc">&nbsp;            doSpot();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_NEXT_TARG.getCmd())) {</b>
<b class="nc">&nbsp;            boolean onlyValidTargets = (ev.getModifiers() &amp; ActionEvent.SHIFT_MASK) &gt; 0;</b>
<b class="nc">&nbsp;            boolean ignoreAllies = (ev.getModifiers() &amp; ActionEvent.CTRL_MASK) &gt; 0;</b>
<b class="nc">&nbsp;            jumpToTarget(true, onlyValidTargets, ignoreAllies);</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_FLIP_ARMS.getCmd())) {</b>
<b class="nc">&nbsp;            updateFlipArms(!ce().getArmsFlipped());</b>
&nbsp;            // Fire Mode - More Fire Mode button handling - Rasia
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_MODE.getCmd())) {</b>
<b class="nc">&nbsp;            changeMode(true);</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_CALLED.getCmd())) {</b>
<b class="nc">&nbsp;            changeCalled();</b>
<b class="nc">&nbsp;        } else if ((&quot;changeSinks&quot;.equalsIgnoreCase(ev.getActionCommand()))</b>
<b class="nc">&nbsp;                   || (ev.getActionCommand().equals(FiringCommand.FIRE_CANCEL.getCmd()))) {</b>
<b class="nc">&nbsp;            clear();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_SEARCHLIGHT.getCmd())) {</b>
<b class="nc">&nbsp;            doSearchlight();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_CLEAR_TURRET.getCmd())) {</b>
<b class="nc">&nbsp;            doClearTurret();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_CLEAR_WEAPON.getCmd())) {</b>
<b class="nc">&nbsp;            doClearWeaponJam();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(FiringCommand.FIRE_STRAFE.getCmd())) {</b>
<b class="nc">&nbsp;            doStrafe();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * update for change of arms-flipping status
&nbsp;     *
&nbsp;     * @param armsFlipped
&nbsp;     */
&nbsp;    void updateFlipArms(boolean armsFlipped) {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (armsFlipped == ce().getArmsFlipped()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        twisting = false;</b>
&nbsp;
<b class="nc">&nbsp;        torsoTwist(null);</b>
&nbsp;
<b class="nc">&nbsp;        clearAttacks();</b>
<b class="nc">&nbsp;        ce().setArmsFlipped(armsFlipped);</b>
<b class="nc">&nbsp;        attacks.addElement(new FlipArmsAction(cen, armsFlipped));</b>
<b class="nc">&nbsp;        updateTarget();</b>
<b class="nc">&nbsp;        refreshAll();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void updateSearchlight() {
<b class="nc">&nbsp;        setSearchlightEnabled((ce() != null)</b>
&nbsp;                &amp;&amp; (target != null)
<b class="nc">&nbsp;                &amp;&amp; ce().isUsingSpotlight()</b>
<b class="nc">&nbsp;                &amp;&amp; ce().getCrew().isActive()</b>
<b class="nc">&nbsp;                &amp;&amp; !ce().isHidden()</b>
<b class="nc">&nbsp;                &amp;&amp; SearchlightAttackAction.isPossible(clientgui.getClient()</b>
<b class="nc">&nbsp;                        .getGame(), cen, target, null)</b>
<b class="nc">&nbsp;                &amp;&amp; !((ce() instanceof Tank) &amp;&amp; (((Tank) ce()).getStunnedTurns() &gt; 0)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateClearTurret() {
<b class="nc">&nbsp;        setFireClearTurretEnabled((ce() instanceof Tank)</b>
<b class="nc">&nbsp;                &amp;&amp; ((Tank) ce()).canClearTurret()</b>
<b class="nc">&nbsp;                &amp;&amp; (attacks.size() == 0));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateClearWeaponJam() {
<b class="nc">&nbsp;        setFireClearWeaponJamEnabled((ce() instanceof Tank)</b>
<b class="nc">&nbsp;                &amp;&amp; ((Tank) ce()).canUnjamWeapon()</b>
<b class="nc">&nbsp;                &amp;&amp; (attacks.size() == 0));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateStrafe() {
<b class="nc">&nbsp;        if (ce().isAero()) {</b>
<b class="nc">&nbsp;            setStrafeEnabled(ce().getAltitude() &lt;= 3 &amp;&amp; !((IAero)ce()).isSpheroid());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            setStrafeEnabled(false);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void setFireEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_FIRE).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireFireEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setTwistEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_TWIST).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireTwistEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setSkipEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_SKIP).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireSkipEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFindClubEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_FIND_CLUB).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireFindClubEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setNextTargetEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_NEXT_TARG).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireNextTargetEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFlipArmsEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_FLIP_ARMS).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireFlipArmsEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setSpotEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_SPOT).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireSpotEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setSearchlightEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_SEARCHLIGHT).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireSearchlightEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFireModeEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_MODE).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireModeEnabled(enabled);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Enables the mode button when mode switching is allowed
&nbsp;     * (always true except for LAMs with certain weapons) and
&nbsp;     * the weapon has modes. Disables otherwise.
&nbsp;     *  
&nbsp;     * @param m The active weapon
&nbsp;     */
&nbsp;    protected void adaptFireModeEnabled(Mounted m) {
<b class="nc">&nbsp;        setFireModeEnabled(m.isModeSwitchable() &amp; m.getType().hasModes());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFireCalledEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_CALLED).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireCalledEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFireClearTurretEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_CLEAR_TURRET).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireClearTurretEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setFireClearWeaponJamEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_CLEAR_WEAPON).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireClearWeaponJamEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setStrafeEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_STRAFE).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireClearWeaponJamEnabled(enabled);</b>
&nbsp;    }    
&nbsp;    
&nbsp;
&nbsp;    protected void setNextEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(FiringCommand.FIRE_NEXT).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireNextEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void clear() {
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn()) {</b>
<b class="nc">&nbsp;            setStatusBarText(Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;FiringDisplay.its_your_turn&quot;)); //$NON-NLS-1$</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((target instanceof Entity) </b>
<b class="nc">&nbsp;                &amp;&amp; Compute.isGroundToAir(ce(), target)) {</b>
<b class="nc">&nbsp;            ((Entity)target).setPlayerPickedPassThrough(cen, null);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; !ce().isMakingVTOLGroundAttack()) {</b>
<b class="nc">&nbsp;            target(null);</b>
&nbsp;        }
<b class="nc">&nbsp;        clearAttacks();        </b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().cursor(null);</b>
<b class="nc">&nbsp;        refreshAll();</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // ItemListener
&nbsp;    //
&nbsp;    public void itemStateChanged(ItemEvent ev) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // board view listener
&nbsp;    @Override
&nbsp;    public void finishedMovingUnits(BoardViewEvent b) {
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn() &amp;&amp; (ce() != null)) {</b>
<b class="nc">&nbsp;            clientgui.setDisplayVisible(true);</b>
<b class="nc">&nbsp;            clientgui.bv.centerOnHex(ce().getPosition());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void unitSelected(BoardViewEvent b) {
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entity e = clientgui.getClient().getGame().getEntity(b.getEntityId());</b>
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn()) {</b>
<b class="nc">&nbsp;            if (clientgui.getClient().getMyTurn()</b>
<b class="nc">&nbsp;                         .isValidEntity(e, clientgui.getClient().getGame())) {</b>
<b class="nc">&nbsp;                selectEntity(e.getId());</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            clientgui.setDisplayVisible(true);</b>
<b class="nc">&nbsp;            clientgui.mechD.displayEntity(e);</b>
<b class="nc">&nbsp;            if (e.isDeployed()) {</b>
<b class="nc">&nbsp;                clientgui.bv.centerOnHex(e.getPosition());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void valueChanged(ListSelectionEvent event) {
<b class="nc">&nbsp;        if (event.getValueIsAdjusting()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (event.getSource().equals(clientgui.mechD.wPan.weaponList)</b>
<b class="nc">&nbsp;                &amp;&amp; (clientgui.getClient().getGame().getPhase() == Phase.PHASE_FIRING)) {</b>
&nbsp;            // If we aren&#39;t in the firing phase, there&#39;s no guarantee that cen
&nbsp;            // is set properly, hence we can&#39;t update
&nbsp;
&nbsp;            // update target data in weapon display
<b class="nc">&nbsp;            updateTarget();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Stop just ignoring events and actually stop listening to them.
&nbsp;     */
&nbsp;    public void removeAllListeners() {
<b class="nc">&nbsp;        clientgui.getClient().getGame().removeGameListener(this);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().removeBoardViewListener(this);</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.weaponList.removeListSelectionListener(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Have the player select a target from the entities at the given coords.
&nbsp;     *
&nbsp;     * @param pos - the &lt;code&gt;Coords&lt;/code&gt; containing targets.
&nbsp;     */
&nbsp;    private Targetable chooseTarget(Coords pos) {
<b class="nc">&nbsp;        final IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;        boolean friendlyFire = game.getOptions().booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE); //$NON-NLS-1$</b>
&nbsp;        // Assume that we have *no* choice.
<b class="nc">&nbsp;        Targetable choice = null;</b>
&nbsp;        Iterator&lt;Entity&gt; choices;
&nbsp;
<b class="nc">&nbsp;        int wn = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        Mounted weap = ce().getEquipment(wn);</b>
&nbsp;        
&nbsp;        // Check for weapon/ammo types that should automatically target hexes
<b class="nc">&nbsp;        if ((weap != null) &amp;&amp; (weap.getLinked() != null) </b>
<b class="nc">&nbsp;                &amp;&amp; (weap.getLinked().getType() instanceof AmmoType)) {</b>
<b class="nc">&nbsp;            AmmoType aType = (AmmoType)weap.getLinked().getType();</b>
<b class="nc">&nbsp;            long munitionType = aType.getMunitionType();</b>
&nbsp;            // Mek mortar flares should default to deliver flare
<b class="nc">&nbsp;            if ((aType.getAmmoType() == AmmoType.T_MEK_MORTAR) </b>
&nbsp;                    &amp;&amp; (munitionType == AmmoType.M_FLARE)) {
<b class="nc">&nbsp;                return new HexTarget(pos, game.getBoard(),</b>
&nbsp;                        Targetable.TYPE_FLARE_DELIVER);
&nbsp;            // Certain mek mortar types and LRMs should target hexes
<b class="nc">&nbsp;            } else if (((aType.getAmmoType() == AmmoType.T_MEK_MORTAR)</b>
<b class="nc">&nbsp;                    || (aType.getAmmoType() == AmmoType.T_LRM)</b>
<b class="nc">&nbsp;                    || (aType.getAmmoType() == AmmoType.T_LRM_IMP))</b>
&nbsp;                    &amp;&amp; ((munitionType == AmmoType.M_AIRBURST) 
&nbsp;                            || (munitionType == AmmoType.M_SMOKE_WARHEAD))) {
<b class="nc">&nbsp;                return new HexTarget(pos, game.getBoard(),</b>
&nbsp;                        Targetable.TYPE_HEX_CLEAR);
<b class="nc">&nbsp;            } else if (munitionType == AmmoType.M_MINE_CLEARANCE) {</b>
<b class="nc">&nbsp;                return new HexTarget(pos, game.getBoard(),</b>
&nbsp;                        Targetable.TYPE_HEX_CLEAR);
&nbsp;            }
&nbsp;        }
&nbsp;        // Get the available choices, depending on friendly fire
<b class="nc">&nbsp;        if (friendlyFire) {</b>
<b class="nc">&nbsp;            choices = game.getEntities(pos);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            choices = game.getEnemyEntities(pos, ce());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Convert the choices into a List of targets.
<b class="nc">&nbsp;        List&lt;Targetable&gt; targets = new ArrayList&lt;Targetable&gt;();</b>
<b class="nc">&nbsp;        final IPlayer localPlayer = clientgui.getClient().getLocalPlayer();</b>
<b class="nc">&nbsp;        while (choices.hasNext()) {</b>
<b class="nc">&nbsp;            Targetable t = choices.next();</b>
<b class="nc">&nbsp;            boolean isSensorReturn = false;</b>
<b class="nc">&nbsp;            boolean isVisible = true;</b>
<b class="nc">&nbsp;            boolean isHidden = false;</b>
<b class="nc">&nbsp;            if (t instanceof Entity) {</b>
<b class="nc">&nbsp;                isSensorReturn = ((Entity) t).isSensorReturn(localPlayer);</b>
<b class="nc">&nbsp;                isVisible = ((Entity) t).hasSeenEntity(localPlayer);</b>
<b class="nc">&nbsp;                isHidden = ((Entity) t).isHidden();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!ce().equals(t) &amp;&amp; !isSensorReturn &amp;&amp; isVisible &amp;&amp; !isHidden) {</b>
<b class="nc">&nbsp;                targets.add(t);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        
&nbsp;        // If there aren&#39;t other targets, check for targets flying over pos
<b class="nc">&nbsp;        if (targets.size() == 0) {</b>
<b class="nc">&nbsp;            List&lt;Entity&gt; flyovers = </b>
<b class="nc">&nbsp;                    clientgui.getBoardView().getEntitiesFlyingOver(pos);</b>
<b class="nc">&nbsp;            for (Entity e : flyovers) {</b>
<b class="nc">&nbsp;                if (!targets.contains(e)) {</b>
<b class="nc">&nbsp;                    targets.add(e);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Is there a building in the hex?
<b class="nc">&nbsp;        Building bldg = clientgui.getClient().getGame().getBoard()</b>
<b class="nc">&nbsp;                .getBuildingAt(pos);</b>
<b class="nc">&nbsp;        if (bldg != null) {</b>
<b class="nc">&nbsp;            targets.add(new BuildingTarget(pos, clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                    .getBoard(), false));</b>
&nbsp;        }
&nbsp;        
&nbsp;        // If we clicked on a wooded hex with no other targets, clear woods
<b class="nc">&nbsp;        if (targets.size() == 0) {</b>
<b class="nc">&nbsp;            IHex hex = game.getBoard().getHex(pos);</b>
<b class="nc">&nbsp;            if (hex.containsTerrain(Terrains.WOODS)</b>
<b class="nc">&nbsp;                    || hex.containsTerrain(Terrains.JUNGLE)) {</b>
<b class="nc">&nbsp;                targets.add(new HexTarget(pos, game.getBoard(),</b>
&nbsp;                        Targetable.TYPE_HEX_CLEAR));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Do we have a single choice?
<b class="nc">&nbsp;        if (targets.size() == 1) {</b>
&nbsp;
&nbsp;            // Return that choice.
<b class="nc">&nbsp;            choice = targets.get(0);</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        // If we have multiple choices, display a selection dialog.
<b class="nc">&nbsp;        else if (targets.size() &gt; 1) {</b>
<b class="nc">&nbsp;            String input = (String) JOptionPane</b>
<b class="nc">&nbsp;                    .showInputDialog(clientgui,</b>
<b class="nc">&nbsp;                            Messages.getString(</b>
&nbsp;                                    &quot;FiringDisplay.ChooseTargetDialog.message&quot;,
<b class="nc">&nbsp;                                    new Object[] { pos.getBoardNum() }),</b>
&nbsp;                            //$NON-NLS-1$                            JOptionPane.QUESTION_MESSAGE, null,
<b class="nc">&nbsp;                            Messages.getString(&quot;FiringDisplay.ChooseTargetDialog.title&quot;), //$NON-NLS-1$</b>
&nbsp;                            JOptionPane.QUESTION_MESSAGE, null, SharedUtility
<b class="nc">&nbsp;                                    .getDisplayArray(targets), null);</b>
<b class="nc">&nbsp;            choice = SharedUtility.getTargetPicked(targets, input);</b>
&nbsp;        } // End have-choices
&nbsp;
&nbsp;        // Return the chosen unit.
<b class="nc">&nbsp;        return choice;</b>
&nbsp;
&nbsp;    } // End private Targetable chooseTarget( Coords )
&nbsp;
&nbsp;    public Targetable getTarget() {
<b class="nc">&nbsp;        return target;</b>
&nbsp;    }
&nbsp;    
&nbsp;    private boolean validStrafingCoord(Coords newCoord) {
&nbsp;        // Only Aeros can strafe...
<b class="nc">&nbsp;        if (ce() == null || !ce().isAero()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Can&#39;t update strafe hexes after weapons are fired, otherwise we&#39;d
&nbsp;        // have to have a way to update the attacks vector
<b class="nc">&nbsp;        if (attacks.size() &gt; 0) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Can only strafe hexes that were flown over
<b class="nc">&nbsp;        if (!ce().passedThrough(newCoord)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // No more limitations if it&#39;s the first hex
<b class="nc">&nbsp;        if (strafingCoords.size() == 0) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // We can only select at most 5 hexes
<b class="nc">&nbsp;        if (strafingCoords.size() &gt;= 5) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Can&#39;t strafe the same hex twice
<b class="nc">&nbsp;        if (strafingCoords.contains(newCoord)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        boolean isConsecutive = false;</b>
<b class="nc">&nbsp;        for (Coords c : strafingCoords) {</b>
<b class="nc">&nbsp;            isConsecutive |= (c.distance(newCoord) == 1);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isInaLine = true;</b>
&nbsp;        // If there is only one other coord, then they&#39;re linear
<b class="nc">&nbsp;        if (strafingCoords.size() &gt; 1) {</b>
<b class="nc">&nbsp;            IdealHex newHex = new IdealHex(newCoord);</b>
<b class="nc">&nbsp;            IdealHex start = new IdealHex(strafingCoords.get(0));</b>
&nbsp;            // Define the vector formed by the new coords and the first coords
<b class="nc">&nbsp;            for (int i = 1; i &lt; strafingCoords.size(); i++) {</b>
<b class="nc">&nbsp;                IdealHex iHex = new IdealHex(strafingCoords.get(i));</b>
<b class="nc">&nbsp;                isInaLine &amp;= iHex.isIntersectedBy(start.cx, start.cy, newHex.cx,</b>
&nbsp;                        newHex.cy);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return isConsecutive &amp;&amp; isInaLine;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void FieldofFire(Entity unit, int[][] ranges, int arc, int loc, int facing) {
&nbsp;        // do nothing here outside the movement phase
<b class="nc">&nbsp;        if (!(clientgui.getClient().getGame().getPhase() == Phase.PHASE_FIRING)) return;</b>
&nbsp;        
<b class="nc">&nbsp;        clientgui.bv.fieldofFireUnit = unit;</b>
<b class="nc">&nbsp;        clientgui.bv.fieldofFireRanges = ranges;</b>
<b class="nc">&nbsp;        clientgui.bv.fieldofFireWpArc = arc;</b>
<b class="nc">&nbsp;        clientgui.bv.fieldofFireWpLoc = loc;</b>
&nbsp;        
<b class="nc">&nbsp;        clientgui.bv.setWeaponFieldofFire(facing, unit.getPosition());</b>
&nbsp;    }
&nbsp;    
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
