


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TargetingPhaseDisplay</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ui.swing</a>
</div>

<h1>Coverage Summary for Class: TargetingPhaseDisplay (megamek.client.ui.swing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TargetingPhaseDisplay</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/588)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetingPhaseDisplay$TargetingCommand</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/101)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/719)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2004 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;
&nbsp;package megamek.client.ui.swing;
&nbsp;
&nbsp;import java.awt.event.ActionEvent;
&nbsp;import java.awt.event.InputEvent;
&nbsp;import java.awt.event.ItemEvent;
&nbsp;import java.awt.event.ItemListener;
&nbsp;import java.awt.event.KeyListener;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import javax.swing.JOptionPane;
&nbsp;import javax.swing.event.ListSelectionEvent;
&nbsp;import javax.swing.event.ListSelectionListener;
&nbsp;
&nbsp;import megamek.client.Client;
&nbsp;import megamek.client.event.BoardViewEvent;
&nbsp;import megamek.client.ui.Messages;
&nbsp;import megamek.client.ui.SharedUtility;
&nbsp;import megamek.client.ui.swing.util.CommandAction;
&nbsp;import megamek.client.ui.swing.util.KeyCommandBind;
&nbsp;import megamek.client.ui.swing.util.MegaMekController;
&nbsp;import megamek.client.ui.swing.widget.MegamekButton;
&nbsp;import megamek.client.ui.swing.widget.SkinSpecification;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.BuildingTarget;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Dropship;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.GameTurn;
&nbsp;import megamek.common.IPlayer;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.event.GameTurnChangeEvent;
&nbsp;import megamek.common.HexTarget;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.RangeType;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.actions.ArtilleryAttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.FlipArmsAction;
&nbsp;import megamek.common.actions.SearchlightAttackAction;
&nbsp;import megamek.common.actions.TorsoTwistAction;
&nbsp;import megamek.common.actions.TriggerAPPodAction;
&nbsp;import megamek.common.actions.TriggerBPodAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.util.FiringSolution;
&nbsp;import megamek.common.weapons.Weapon;
&nbsp;import megamek.common.weapons.artillery.ArtilleryWeapon;
&nbsp;import megamek.common.weapons.bayweapons.TeleOperatedMissileBayWeapon;
&nbsp;import megamek.common.weapons.capitalweapons.CapitalMissileWeapon;
&nbsp;
&nbsp;/*
&nbsp; * Targeting Phase Display. Breaks naming convention because TargetingDisplay is too easy to confuse
&nbsp; * with something else
&nbsp; */
&nbsp;
<b class="nc">&nbsp;public class TargetingPhaseDisplay extends StatusBarPhaseDisplay implements</b>
&nbsp;        KeyListener, ItemListener, ListSelectionListener {
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 3441669419807288865L;
&nbsp;
&nbsp;    /**
&nbsp;     * This enumeration lists all of the possible ActionCommands that can be
&nbsp;     * carried out during the deploy minefield phase.  Each command has a string
&nbsp;     * for the command plus a flag that determines what unit type it is
&nbsp;     * appropriate for.
&nbsp;     *
&nbsp;     * @author arlith
&nbsp;     */
<b class="nc">&nbsp;    public static enum TargetingCommand implements PhaseCommand {</b>
<b class="nc">&nbsp;        FIRE_NEXT(&quot;fireNext&quot;),</b>
<b class="nc">&nbsp;        FIRE_TWIST(&quot;fireTwist&quot;),</b>
<b class="nc">&nbsp;        FIRE_FIRE(&quot;fireFire&quot;),</b>
<b class="nc">&nbsp;        FIRE_SKIP(&quot;fireSkip&quot;),</b>
<b class="nc">&nbsp;        FIRE_NEXT_TARG(&quot;fireNextTarg&quot;),</b>
<b class="nc">&nbsp;        FIRE_MODE(&quot;fireMode&quot;),</b>
<b class="nc">&nbsp;        FIRE_FLIP_ARMS(&quot;fireFlipArms&quot;),</b>
<b class="nc">&nbsp;        FIRE_SEARCHLIGHT(&quot;fireSearchlight&quot;),</b>
<b class="nc">&nbsp;        FIRE_CANCEL(&quot;fireCancel&quot;);</b>
&nbsp;
&nbsp;        String cmd;
&nbsp;
&nbsp;        /**
&nbsp;         * Priority that determines this buttons order
&nbsp;         */
&nbsp;        public int priority;
&nbsp;
<b class="nc">&nbsp;        private TargetingCommand(String c) {</b>
<b class="nc">&nbsp;            cmd = c;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getCmd() {
<b class="nc">&nbsp;            return cmd;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getPriority() {
<b class="nc">&nbsp;            return priority;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setPriority(int p) {
<b class="nc">&nbsp;            priority = p;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return Messages.getString(&quot;TargetingPhaseDisplay.&quot; + getCmd());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // buttons
&nbsp;    protected Map&lt;TargetingCommand, MegamekButton&gt; buttons;
&nbsp;
&nbsp;    // let&#39;s keep track of what we&#39;re shooting and at what, too
<b class="nc">&nbsp;    private int cen = Entity.NONE; // current entity number</b>
&nbsp;
&nbsp;    private Targetable target; // target
&nbsp;
&nbsp;    // shots we have so far.
&nbsp;    private Vector&lt;EntityAction&gt; attacks;
&nbsp;
&nbsp;    // is the shift key held?
&nbsp;    private boolean shiftheld;
&nbsp;
&nbsp;    private boolean twisting;
&nbsp;
&nbsp;    private final IGame.Phase phase;
&nbsp;
&nbsp;    private Entity[] visibleTargets;
&nbsp;
<b class="nc">&nbsp;    private int lastTargetID = -1;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates and lays out a new targeting phase display for the specified
&nbsp;     * clientgui.getClient().
&nbsp;     */
&nbsp;    public TargetingPhaseDisplay(final ClientGUI clientgui, boolean offboard) {
<b class="nc">&nbsp;        super(clientgui);</b>
<b class="nc">&nbsp;        phase = offboard ? IGame.Phase.PHASE_OFFBOARD</b>
<b class="nc">&nbsp;                : IGame.Phase.PHASE_TARGETING;</b>
<b class="nc">&nbsp;        shiftheld = false;</b>
&nbsp;
&nbsp;        // fire
<b class="nc">&nbsp;        attacks = new Vector&lt;EntityAction&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        setupStatusBar(Messages</b>
<b class="nc">&nbsp;                .getString(&quot;TargetingPhaseDisplay.waitingForTargetingPhase&quot;)); //$NON-NLS-1$</b>
&nbsp;
<b class="nc">&nbsp;        buttons = new HashMap&lt;TargetingCommand, MegamekButton&gt;(</b>
<b class="nc">&nbsp;                (int) (TargetingCommand.values().length * 1.25 + 0.5));</b>
<b class="nc">&nbsp;        for (TargetingCommand cmd : TargetingCommand.values()) {</b>
<b class="nc">&nbsp;            String title = Messages.getString(&quot;TargetingPhaseDisplay.&quot;</b>
<b class="nc">&nbsp;                    + cmd.getCmd());</b>
<b class="nc">&nbsp;            MegamekButton newButton = new MegamekButton(title,</b>
<b class="nc">&nbsp;                    SkinSpecification.UIComponents.PhaseDisplayButton.getComp());</b>
<b class="nc">&nbsp;            String ttKey = &quot;TargetingPhaseDisplay.&quot; + cmd.getCmd() + &quot;.tooltip&quot;;</b>
<b class="nc">&nbsp;            if (Messages.keyExists(ttKey)) {</b>
<b class="nc">&nbsp;                newButton.setToolTipText(Messages.getString(ttKey));</b>
&nbsp;            }
<b class="nc">&nbsp;            newButton.addActionListener(this);</b>
<b class="nc">&nbsp;            newButton.setActionCommand(cmd.getCmd());</b>
<b class="nc">&nbsp;            newButton.setEnabled(false);</b>
<b class="nc">&nbsp;            buttons.put(cmd, newButton);</b>
&nbsp;        }
<b class="nc">&nbsp;        numButtonGroups = (int) Math.ceil((buttons.size() + 0.0)</b>
&nbsp;                / buttonsPerGroup);
&nbsp;
<b class="nc">&nbsp;        butDone.setText(Messages.getString(&quot;TargetingPhaseDisplay.Done&quot;)); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        butDone.setEnabled(false);</b>
&nbsp;
<b class="nc">&nbsp;        layoutScreen();</b>
&nbsp;
<b class="nc">&nbsp;        setupButtonPanel();</b>
&nbsp;        
<b class="nc">&nbsp;        MegaMekController controller = clientgui.controller;</b>
<b class="nc">&nbsp;        final StatusBarPhaseDisplay display = this;</b>
&nbsp;        // Register the action for UNDO
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.UNDO.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !display.isVisible()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        removeLastFiring();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;        // Register the action for TWIST_LEFT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TWIST_LEFT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        updateFlipArms(false);</b>
<b class="nc">&nbsp;                        torsoTwist(0);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for TWIST_RIGHT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.TWIST_RIGHT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        updateFlipArms(false);</b>
<b class="nc">&nbsp;                        torsoTwist(1);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;     // Register the action for FIRE
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.FIRE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !buttons.get(TargetingCommand.FIRE_FIRE)</b>
<b class="nc">&nbsp;                                        .isEnabled()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        fire();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_WEAPON
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_WEAPON.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        nextWeapon();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_WEAPON
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_WEAPON.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        prevWeapon();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_UNIT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_UNIT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        selectEntity(clientgui.getClient()</b>
<b class="nc">&nbsp;                                .getNextEntityNum(cen));</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_UNIT
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_UNIT.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        selectEntity(clientgui.getClient()</b>
<b class="nc">&nbsp;                                .getPrevEntityNum(cen));</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_TARGET.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToNextTarget();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_TARGET
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_TARGET.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        jumpToPrevTarget();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for NEXT_MODE
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.NEXT_MODE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !display.isVisible()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        changeMode(true);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for PREV_MODE
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.PREV_MODE.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                                || clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()</b>
<b class="nc">&nbsp;                                || !display.isVisible()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        changeMode(false);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;
&nbsp;        // Register the action for CLEAR
<b class="nc">&nbsp;        controller.registerCommandAction(KeyCommandBind.CANCEL.cmd,</b>
<b class="nc">&nbsp;                new CommandAction() {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean shouldPerformAction() {
<b class="nc">&nbsp;                        if (clientgui.bv.getChatterBoxActive()</b>
<b class="nc">&nbsp;                                || !display.isVisible()</b>
<b class="nc">&nbsp;                                || display.isIgnoringEvents()) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void performAction() {
<b class="nc">&nbsp;                        clear();</b>
&nbsp;                    }
&nbsp;                });
&nbsp;        
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Have the panel register itself as a listener wherever it&#39;s needed.
&nbsp;     * &lt;p/&gt;
&nbsp;     * According to
&nbsp;     * http://www-106.ibm.com/developerworks/java/library/j-jtp0618.html it is a
&nbsp;     * major bad no-no to perform these registrations before the constructor
&nbsp;     * finishes, so this function has to be called after the panel is created.
&nbsp;     * Please note, this restriction only applies to listeners for objects that
&nbsp;     * aren&#39;t on the panel itself.
&nbsp;     */
&nbsp;    public void initializeListeners() {
&nbsp;
<b class="nc">&nbsp;        clientgui.getClient().getGame().addGameListener(this);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().addBoardViewListener(this);</b>
&nbsp;
<b class="nc">&nbsp;        clientgui.bv.addKeyListener(this);</b>
&nbsp;
&nbsp;        // mech display.
<b class="nc">&nbsp;        clientgui.mechD.wPan.weaponList.addListSelectionListener(this);</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.weaponList.addKeyListener(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected ArrayList&lt;MegamekButton&gt; getButtonList() {
<b class="nc">&nbsp;        ArrayList&lt;MegamekButton&gt; buttonList = new ArrayList&lt;MegamekButton&gt;();</b>
<b class="nc">&nbsp;        TargetingCommand commands[] = TargetingCommand.values();</b>
<b class="nc">&nbsp;        CommandComparator comparator = new CommandComparator();</b>
<b class="nc">&nbsp;        Arrays.sort(commands, comparator);</b>
<b class="nc">&nbsp;        for (TargetingCommand cmd : commands) {</b>
<b class="nc">&nbsp;            if (cmd == TargetingCommand.FIRE_CANCEL) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            buttonList.add(buttons.get(cmd));</b>
&nbsp;        }
<b class="nc">&nbsp;        return buttonList;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects an entity, by number, for targeting.
&nbsp;     */
&nbsp;    private void selectEntity(int en) {
&nbsp;        // clear any previously considered attacks
<b class="nc">&nbsp;        if (en != cen) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            refreshAll();</b>
&nbsp;        }
<b class="nc">&nbsp;        Client client = clientgui.getClient();</b>
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp;ce().isWeapOrderChanged()) {</b>
<b class="nc">&nbsp;            client.sendEntityWeaponOrderUpdate(ce());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (client.getGame().getEntity(en) != null) {</b>
&nbsp;
<b class="nc">&nbsp;            cen = en;</b>
<b class="nc">&nbsp;            clientgui.setSelectedEntityNum(en);</b>
&nbsp;
&nbsp;            // If the selected entity is not on the board, use the next one.
&nbsp;            // ASSUMPTION: there will always be *at least one* entity on map.
<b class="nc">&nbsp;            if (null == ce().getPosition()) {</b>
&nbsp;
&nbsp;                // Walk through the list of entities for this player.
<b class="nc">&nbsp;                for (int nextId = client.getNextEntityNum(en); nextId != en; </b>
<b class="nc">&nbsp;                        nextId = client.getNextEntityNum(nextId)) {</b>
&nbsp;
<b class="nc">&nbsp;                    if (null != clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                            .getEntity(nextId).getPosition()) {</b>
<b class="nc">&nbsp;                        cen = nextId;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
&nbsp;
&nbsp;                } // Check the player&#39;s next entity.
&nbsp;
&nbsp;                // We were *supposed* to have found an on-board entity.
<b class="nc">&nbsp;                if (null == ce().getPosition()) {</b>
<b class="nc">&nbsp;                    System.err.println(&quot;FiringDisplay: could not find &quot; //$NON-NLS-1$</b>
&nbsp;                            + &quot;an on-board entity: &quot; + //$NON-NLS-1$
&nbsp;                            en);
&nbsp;                    return;
&nbsp;                }
&nbsp;
&nbsp;            } // End ce()-not-on-board
&nbsp;
<b class="nc">&nbsp;            target(null);</b>
<b class="nc">&nbsp;            clientgui.getBoardView().highlight(ce().getPosition());</b>
<b class="nc">&nbsp;            clientgui.getBoardView().select(null);</b>
<b class="nc">&nbsp;            clientgui.getBoardView().cursor(null);</b>
&nbsp;
<b class="nc">&nbsp;            refreshAll();</b>
<b class="nc">&nbsp;            cacheVisibleTargets();</b>
&nbsp;
<b class="nc">&nbsp;            if (!clientgui.bv.isMovingUnits() &amp;&amp; !ce().isOffBoard()) {</b>
<b class="nc">&nbsp;                clientgui.bv.centerOnHex(ce().getPosition());</b>
&nbsp;            }
&nbsp;
&nbsp;            // Update the menu bar.
<b class="nc">&nbsp;            clientgui.getMenuBar().setEntity(ce());</b>
&nbsp;
&nbsp;            // 2003-12-29, nemchenk -- only twist if crew conscious
<b class="nc">&nbsp;            setTwistEnabled(ce().canChangeSecondaryFacing()</b>
<b class="nc">&nbsp;                            &amp;&amp; ce().getCrew().isActive());</b>
<b class="nc">&nbsp;            setFlipArmsEnabled(ce().canFlipArms());</b>
<b class="nc">&nbsp;            updateSearchlight();</b>
&nbsp;
<b class="nc">&nbsp;            setFireModeEnabled(true);</b>
&nbsp;
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getBoolean(&quot;FiringSolutions&quot;)</b>
<b class="nc">&nbsp;                    &amp;&amp; !ce().isOffBoard()) {</b>
<b class="nc">&nbsp;                setFiringSolutions();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                clientgui.getBoardView().clearFiringSolutionData();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            System.err.println(&quot;TargetingPhaseDisplay: &quot; //$NON-NLS-1$</b>
&nbsp;                    + &quot;tried to select non-existant entity: &quot; + en); //$NON-NLS-1$
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setFiringSolutions() {
&nbsp;        // If no Entity is selected, exit
<b class="nc">&nbsp;        if (cen == Entity.NONE) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;        IPlayer localPlayer = clientgui.getClient().getLocalPlayer();</b>
<b class="nc">&nbsp;        if (!GUIPreferences.getInstance().getFiringSolutions()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // Determine which entities are spotted
<b class="nc">&nbsp;        Set&lt;Integer&gt; spottedEntities = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity target : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            if (!target.isEnemyOf(ce()) &amp;&amp; target.isSpotting()) {</b>
<b class="nc">&nbsp;                spottedEntities.add(target.getSpotTargetId());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Calculate firing solutions
<b class="nc">&nbsp;        Map&lt;Integer, FiringSolution&gt; fs = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Entity target : game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;            boolean friendlyFire = game.getOptions().booleanOption(</b>
&nbsp;                    OptionsConstants.BASE_FRIENDLY_FIRE); //$NON-NLS-1$
<b class="nc">&nbsp;            boolean enemyTarget = target.getOwner().isEnemyOf(ce().getOwner());</b>
<b class="nc">&nbsp;            if ((target.getId() != cen)</b>
&nbsp;                &amp;&amp; (friendlyFire || enemyTarget)
<b class="nc">&nbsp;                &amp;&amp; (!enemyTarget || target.hasSeenEntity(localPlayer)</b>
<b class="nc">&nbsp;                    || target.hasDetectedEntity(localPlayer))</b>
<b class="nc">&nbsp;                &amp;&amp; target.isTargetable()) {</b>
<b class="nc">&nbsp;                ToHitData thd = WeaponAttackAction.toHit(game, cen, target);</b>
<b class="nc">&nbsp;                thd.setLocation(target.getPosition());</b>
<b class="nc">&nbsp;                thd.setRange(ce().getPosition().distance(target.getPosition()));</b>
<b class="nc">&nbsp;                fs.put(target.getId(), new FiringSolution(thd, spottedEntities.contains(target.getId())));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        clientgui.getBoardView().setFiringSolutions(ce(), fs);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does turn start stuff
&nbsp;     */
&nbsp;    private void beginMyTurn() {
<b class="nc">&nbsp;        target = null;</b>
&nbsp;
<b class="nc">&nbsp;        if (!clientgui.bv.isMovingUnits()) {</b>
<b class="nc">&nbsp;            clientgui.setDisplayVisible(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        clientgui.bv.clearFieldofF();</b>
&nbsp;
<b class="nc">&nbsp;        selectEntity(clientgui.getClient().getFirstEntityNum());</b>
&nbsp;
<b class="nc">&nbsp;        GameTurn turn = clientgui.getClient().getMyTurn();</b>
&nbsp;        // There&#39;s special processing for triggering AP Pods.
<b class="nc">&nbsp;        if ((turn instanceof GameTurn.TriggerAPPodTurn) &amp;&amp; (null != ce())) {</b>
<b class="nc">&nbsp;            disableButtons();</b>
<b class="nc">&nbsp;            TriggerAPPodDialog dialog = new TriggerAPPodDialog(</b>
<b class="nc">&nbsp;                    clientgui.getFrame(), ce());</b>
<b class="nc">&nbsp;            dialog.setVisible(true);</b>
<b class="nc">&nbsp;            attacks.removeAllElements();</b>
<b class="nc">&nbsp;            Enumeration&lt;TriggerAPPodAction&gt; actions = dialog.getActions();</b>
<b class="nc">&nbsp;            while (actions.hasMoreElements()) {</b>
<b class="nc">&nbsp;                attacks.addElement(actions.nextElement());</b>
&nbsp;            }
<b class="nc">&nbsp;            ready();</b>
<b class="nc">&nbsp;        } else if ((turn instanceof GameTurn.TriggerBPodTurn) &amp;&amp; (null != ce())) {</b>
<b class="nc">&nbsp;            disableButtons();</b>
<b class="nc">&nbsp;            TriggerBPodDialog dialog = new TriggerBPodDialog(clientgui, ce(),</b>
<b class="nc">&nbsp;                    ((GameTurn.TriggerBPodTurn) turn).getAttackType());</b>
<b class="nc">&nbsp;            dialog.setVisible(true);</b>
<b class="nc">&nbsp;            attacks.removeAllElements();</b>
<b class="nc">&nbsp;            Enumeration&lt;TriggerBPodAction&gt; actions = dialog.getActions();</b>
<b class="nc">&nbsp;            while (actions.hasMoreElements()) {</b>
<b class="nc">&nbsp;                attacks.addElement(actions.nextElement());</b>
&nbsp;            }
<b class="nc">&nbsp;            ready();</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            setNextEnabled(true);</b>
<b class="nc">&nbsp;            butDone.setEnabled(true);</b>
<b class="nc">&nbsp;            clientgui.getBoardView().select(null);</b>
&nbsp;        }
<b class="nc">&nbsp;        setupButtonPanel();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does end turn stuff.
&nbsp;     */
&nbsp;    private void endMyTurn() {
&nbsp;        // end my turn, then.
<b class="nc">&nbsp;        Entity next = clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                .getNextEntity(clientgui.getClient().getGame().getTurnIndex());</b>
<b class="nc">&nbsp;        if ((phase == clientgui.getClient().getGame().getPhase())</b>
<b class="nc">&nbsp;                &amp;&amp; (null != next) &amp;&amp; (null != ce())</b>
<b class="nc">&nbsp;                &amp;&amp; (next.getOwnerId() != ce().getOwnerId())) {</b>
<b class="nc">&nbsp;            clientgui.setDisplayVisible(false);</b>
&nbsp;        }
<b class="nc">&nbsp;        cen = Entity.NONE;</b>
<b class="nc">&nbsp;        target(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().highlight(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().cursor(null);</b>
<b class="nc">&nbsp;        clientgui.bv.clearFiringSolutionData();</b>
<b class="nc">&nbsp;        clientgui.bv.clearMovementData();</b>
<b class="nc">&nbsp;        clientgui.bv.clearFieldofF();</b>
<b class="nc">&nbsp;        clientgui.setSelectedEntityNum(Entity.NONE);</b>
<b class="nc">&nbsp;        disableButtons();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Disables all buttons in the interface
&nbsp;     */
&nbsp;    private void disableButtons() {
<b class="nc">&nbsp;        setFireEnabled(false);</b>
<b class="nc">&nbsp;        setSkipEnabled(false);</b>
<b class="nc">&nbsp;        setTwistEnabled(false);</b>
<b class="nc">&nbsp;        setNextEnabled(false);</b>
<b class="nc">&nbsp;        butDone.setEnabled(false);</b>
<b class="nc">&nbsp;        setFlipArmsEnabled(false);</b>
<b class="nc">&nbsp;        setFireModeEnabled(false);</b>
<b class="nc">&nbsp;        setNextTargetEnabled(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fire Mode - Adds a Fire Mode Change to the current Attack Action
&nbsp;     */
&nbsp;    private void changeMode(boolean forward) {
<b class="nc">&nbsp;        int wn = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
&nbsp;
&nbsp;        // Do nothing we have no unit selected.
<b class="nc">&nbsp;        if (null == ce()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // If the weapon does not have modes, just exit.
<b class="nc">&nbsp;        Mounted m = ce().getEquipment(wn);</b>
<b class="nc">&nbsp;        if ((m == null) || !m.getType().hasModes()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // Dropship Artillery cannot be switched to &quot;Direct&quot; Fire
<b class="nc">&nbsp;        final WeaponType wtype = (WeaponType) m.getType();</b>
<b class="nc">&nbsp;        if ((ce() instanceof Dropship) &amp;&amp; (wtype instanceof ArtilleryWeapon)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // send change to the server
<b class="nc">&nbsp;        int nMode = m.switchMode(forward);</b>
<b class="nc">&nbsp;        clientgui.getClient().sendModeChange(cen, wn, nMode);</b>
&nbsp;
&nbsp;        // notify the player
<b class="nc">&nbsp;        if (m.canInstantSwitch(nMode)) {</b>
<b class="nc">&nbsp;            clientgui.systemMessage(Messages.getString(</b>
<b class="nc">&nbsp;                    &quot;FiringDisplay.switched&quot;, new Object[] { m.getName(),</b>
<b class="nc">&nbsp;                            m.curMode().getDisplayableName() }));</b>
&nbsp;            //$NON-NLS-1$
&nbsp;        } else {
<b class="nc">&nbsp;            clientgui.systemMessage(Messages.getString(</b>
<b class="nc">&nbsp;                    &quot;FiringDisplay.willSwitch&quot;, new Object[] { m.getName(),</b>
<b class="nc">&nbsp;                            m.pendingMode().getDisplayableName() })); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        updateTarget();</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectWeapon(wn);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called when the current entity is done firing. Send out our attack queue
&nbsp;     * to the server.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void ready() {
<b class="nc">&nbsp;        if (attacks.isEmpty()</b>
<b class="nc">&nbsp;            &amp;&amp; GUIPreferences.getInstance().getNagForNoAction()) {</b>
&nbsp;            // comfirm this action
<b class="nc">&nbsp;            String title = Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;TargetingPhaseDisplay.DontFireDialog.title&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            String body = Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;TargetingPhaseDisplay.DontFireDialog.message&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            ConfirmDialog response = clientgui.doYesNoBotherDialog(title, body);</b>
<b class="nc">&nbsp;            if (!response.getShowAgain()) {</b>
<b class="nc">&nbsp;                GUIPreferences.getInstance().setNagForNoAction(false);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!response.getAnswer()) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // stop further input (hopefully)
<b class="nc">&nbsp;        disableButtons();</b>
&nbsp;
&nbsp;        // remove temporary attacks from game &amp; board
<b class="nc">&nbsp;        removeTempAttacks();</b>
&nbsp;
&nbsp;        // send out attacks
<b class="nc">&nbsp;        clientgui.getClient().sendAttackData(cen, attacks);</b>
&nbsp;
&nbsp;        // clear queue
<b class="nc">&nbsp;        attacks.removeAllElements();</b>
&nbsp;
&nbsp;        // Clear the menu bar.
<b class="nc">&nbsp;        clientgui.getMenuBar().setEntity(null);</b>
<b class="nc">&nbsp;        if ((ce() != null) &amp;&amp; ce().isWeapOrderChanged()) {</b>
<b class="nc">&nbsp;            clientgui.getClient().sendEntityWeaponOrderUpdate(ce());</b>
&nbsp;        }
<b class="nc">&nbsp;        endMyTurn();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void doSearchlight() {
&nbsp;        // validate
<b class="nc">&nbsp;        if ((ce() == null) || (target == null)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;current searchlight parameters are invalid&quot;); //$NON-NLS-1$
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!SearchlightAttackAction.isPossible(clientgui.getClient().getGame(), cen, target, null)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // create and queue a searchlight action
<b class="nc">&nbsp;        SearchlightAttackAction saa = new SearchlightAttackAction(cen, target</b>
<b class="nc">&nbsp;                .getTargetType(), target.getTargetId());</b>
<b class="nc">&nbsp;        attacks.addElement(saa);</b>
&nbsp;
&nbsp;        // and add it into the game, temporarily
<b class="nc">&nbsp;        clientgui.getClient().getGame().addAction(saa);</b>
<b class="nc">&nbsp;        clientgui.bv.addAttack(saa);</b>
<b class="nc">&nbsp;        clientgui.minimap.drawMap();</b>
&nbsp;
&nbsp;        // refresh weapon panel, as bth will have changed
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a weapon attack with the currently selected weapon to the attack
&nbsp;     * queue.
&nbsp;     */
&nbsp;    private void fire() {
&nbsp;        // get the selected weaponnum
<b class="nc">&nbsp;        int weaponNum = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        Mounted mounted = ce().getEquipment(weaponNum);</b>
&nbsp;
&nbsp;        // validate
<b class="nc">&nbsp;        if ((ce() == null) || (target == null) || (mounted == null)</b>
<b class="nc">&nbsp;                || !(mounted.getType() instanceof WeaponType)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;current fire parameters are invalid&quot;); //$NON-NLS-1$
&nbsp;        }
&nbsp;
&nbsp;        // declare searchlight, if possible
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getAutoDeclareSearchlight()) {</b>
<b class="nc">&nbsp;            doSearchlight();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        WeaponAttackAction waa = new WeaponAttackAction(cen,</b>
<b class="nc">&nbsp;                target.getTargetType(), target.getTargetId(), weaponNum);</b>
<b class="nc">&nbsp;        IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;        int distance = Compute.effectiveDistance(game, waa.getEntity(game),</b>
<b class="nc">&nbsp;                waa.getTarget(game));</b>
<b class="nc">&nbsp;        if ((mounted.getType().hasFlag(WeaponType.F_ARTILLERY))</b>
<b class="nc">&nbsp;                || (mounted.isInBearingsOnlyMode()</b>
&nbsp;                            &amp;&amp; distance &gt;= RangeType.RANGE_BEARINGS_ONLY_MINIMUM)
<b class="nc">&nbsp;                || (mounted.getType() instanceof CapitalMissileWeapon</b>
<b class="nc">&nbsp;                                &amp;&amp; Compute.isGroundToGround(ce(), target))) {</b>
<b class="nc">&nbsp;            waa = new ArtilleryAttackAction(cen, target.getTargetType(),</b>
<b class="nc">&nbsp;                    target.getTargetId(), weaponNum, clientgui.getClient()</b>
<b class="nc">&nbsp;                            .getGame());</b>
&nbsp;            // Get the launch velocity for bearings-only telemissiles
<b class="nc">&nbsp;            if (mounted.getType() instanceof TeleOperatedMissileBayWeapon) {                </b>
<b class="nc">&nbsp;                TeleMissileSettingDialog tsd = new TeleMissileSettingDialog(clientgui.frame, clientgui.getClient().getGame());</b>
<b class="nc">&nbsp;                tsd.setVisible(true);</b>
<b class="nc">&nbsp;                waa.setLaunchVelocity(tsd.getSetting());</b>
<b class="nc">&nbsp;                waa.updateTurnsTilHit(clientgui.getClient().getGame());</b>
&nbsp;            } 
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        updateDisplayForPendingAttack(mounted, waa);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Worker function that handles setting associated ammo and other bookkeeping/UI updates
&nbsp;     * for a pending weapon attack action.
&nbsp;     */
&nbsp;    public void updateDisplayForPendingAttack(Mounted mounted, WeaponAttackAction waa) {
&nbsp;        // put this and the rest of the method into a separate function for access externally.
<b class="nc">&nbsp;        if ((null != mounted.getLinked())</b>
<b class="nc">&nbsp;                &amp;&amp; (((WeaponType) mounted.getType()).getAmmoType() != AmmoType.T_NA)) {</b>
<b class="nc">&nbsp;            Mounted ammoMount = mounted.getLinked();</b>
<b class="nc">&nbsp;            waa.setAmmoId(ammoMount.getEntity().getEquipmentNum(ammoMount));</b>
<b class="nc">&nbsp;            waa.setAmmoCarrier(ammoMount.getEntity().getId());</b>
<b class="nc">&nbsp;            if (((AmmoType) ammoMount.getType()).getMunitionType() == AmmoType.M_VIBRABOMB_IV) {</b>
<b class="nc">&nbsp;                VibrabombSettingDialog vsd = new VibrabombSettingDialog(</b>
&nbsp;                        clientgui.frame);
<b class="nc">&nbsp;                vsd.setVisible(true);</b>
<b class="nc">&nbsp;                waa.setOtherAttackInfo(vsd.getSetting());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // add the attack to our temporary queue
<b class="nc">&nbsp;        attacks.addElement(waa);</b>
&nbsp;
&nbsp;        // and add it into the game, temporarily
<b class="nc">&nbsp;        clientgui.getClient().getGame().addAction(waa);</b>
<b class="nc">&nbsp;        clientgui.minimap.drawMap();</b>
&nbsp;
&nbsp;        // set the weapon as used
<b class="nc">&nbsp;        mounted.setUsedThisRound(true);</b>
&nbsp;
&nbsp;        // find the next available weapon
<b class="nc">&nbsp;        int nextWeapon = clientgui.mechD.wPan.selectNextWeapon();</b>
&nbsp;
&nbsp;        // check; if there are no ready weapons, you&#39;re done.
<b class="nc">&nbsp;        if ((nextWeapon == -1) &amp;&amp; GUIPreferences.getInstance().getAutoEndFiring()) {</b>
<b class="nc">&nbsp;            ready();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // otherwise, display firing info for the next weapon
<b class="nc">&nbsp;        clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectWeapon(nextWeapon);</b>
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Skips to the next weapon
&nbsp;     */
&nbsp;    private void nextWeapon() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        int weaponId = clientgui.mechD.wPan.selectNextWeapon();</b>
&nbsp;
<b class="nc">&nbsp;        if (ce().getId() != clientgui.mechD.wPan.getSelectedEntityId()) {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.displayMech(ce());</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (weaponId == -1) {</b>
<b class="nc">&nbsp;            setFireModeEnabled(false);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Mounted m = ce().getEquipment(weaponId);</b>
<b class="nc">&nbsp;            setFireModeEnabled(m.isModeSwitchable());</b>
&nbsp;        }
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Skips to the previous weapon
&nbsp;     */
&nbsp;    void prevWeapon() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        int weaponId = clientgui.mechD.wPan.selectPrevWeapon();</b>
&nbsp;
<b class="nc">&nbsp;        if (ce().getId() != clientgui.mechD.wPan.getSelectedEntityId()) {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.displayMech(ce());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (weaponId == -1) {</b>
<b class="nc">&nbsp;            setFireModeEnabled(false);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Mounted m = ce().getEquipment(weaponId);</b>
<b class="nc">&nbsp;            setFireModeEnabled(m.isModeSwitchable());</b>
&nbsp;        }
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }    
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all current fire
&nbsp;     */
&nbsp;    private void clearAttacks() {
&nbsp;        // We may not have an entity selected yet (race condition).
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // remove attacks, set weapons available again
<b class="nc">&nbsp;        Enumeration&lt;EntityAction&gt; i = attacks.elements();</b>
<b class="nc">&nbsp;        while (i.hasMoreElements()) {</b>
<b class="nc">&nbsp;            Object o = i.nextElement();</b>
<b class="nc">&nbsp;            if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                ce().getEquipment(waa.getWeaponId()).setUsedThisRound(false);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        attacks.removeAllElements();</b>
&nbsp;
&nbsp;        // remove temporary attacks from game &amp; board
<b class="nc">&nbsp;        removeTempAttacks();</b>
&nbsp;
&nbsp;        // restore any other movement to default
<b class="nc">&nbsp;        ce().setSecondaryFacing(ce().getFacing());</b>
<b class="nc">&nbsp;        ce().setArmsFlipped(false);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes temp attacks from the game and board
&nbsp;     */
&nbsp;    private void removeTempAttacks() {
&nbsp;        // remove temporary attacks from game &amp; board
<b class="nc">&nbsp;        clientgui.getClient().getGame().removeActionsFor(cen);</b>
<b class="nc">&nbsp;        clientgui.bv.removeAttacksFor(ce());</b>
&nbsp;
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * removes the last action
&nbsp;     */
&nbsp;    private void removeLastFiring() {
<b class="nc">&nbsp;        if (!attacks.isEmpty()) {</b>
<b class="nc">&nbsp;            Object o = attacks.lastElement();</b>
<b class="nc">&nbsp;            if (o instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;                WeaponAttackAction waa = (WeaponAttackAction) o;</b>
<b class="nc">&nbsp;                ce().getEquipment(waa.getWeaponId()).setUsedThisRound(false);</b>
<b class="nc">&nbsp;                attacks.removeElement(o);</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.displayMech(ce());</b>
<b class="nc">&nbsp;                clientgui.getClient().getGame().removeAction(o);</b>
<b class="nc">&nbsp;                clientgui.bv.refreshAttacks();</b>
<b class="nc">&nbsp;                clientgui.minimap.drawMap();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }    
&nbsp;
&nbsp;    /**
&nbsp;     * Refeshes all displays.
&nbsp;     */
&nbsp;    private void refreshAll() {
<b class="nc">&nbsp;        if (ce() == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        clientgui.bv.redrawEntity(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.displayEntity(ce());</b>
<b class="nc">&nbsp;        clientgui.mechD.showPanel(&quot;weapons&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.selectFirstWeapon();</b>
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Targets something
&nbsp;     */
&nbsp;    void target(Targetable t) {
<b class="nc">&nbsp;        target = t;</b>
<b class="nc">&nbsp;        updateTarget();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Targets something
&nbsp;     */
&nbsp;    public void updateTarget() {
<b class="nc">&nbsp;        setFireEnabled(false);</b>
&nbsp;
&nbsp;        // update target panel
<b class="nc">&nbsp;        final int weaponId = clientgui.mechD.wPan.getSelectedWeaponNum();</b>
<b class="nc">&nbsp;        if ((target != null) &amp;&amp; (weaponId != -1)) {</b>
&nbsp;            ToHitData toHit;
<b class="nc">&nbsp;            Mounted m = ce().getEquipment(weaponId);</b>
&nbsp;
<b class="nc">&nbsp;            int targetDistance = ce().getPosition().distance(target.getPosition()); </b>
<b class="nc">&nbsp;            boolean isArtilleryAttack = ((WeaponType) m.getType()).hasFlag(WeaponType.F_ARTILLERY)</b>
&nbsp;                    // For other weapons that can make artillery attacks
<b class="nc">&nbsp;                    || target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY;            </b>
&nbsp;            
<b class="nc">&nbsp;            toHit = WeaponAttackAction.toHit(clientgui.getClient().getGame(),</b>
&nbsp;                    cen, target, weaponId, Entity.LOC_NONE, 0, false);
&nbsp;            
<b class="nc">&nbsp;            String flightTimeText = &quot;&quot;; </b>
<b class="nc">&nbsp;            if(isArtilleryAttack) {</b>
<b class="nc">&nbsp;                ArtilleryAttackAction aaa = new ArtilleryAttackAction(ce().getId(), target.getTargetType(),</b>
<b class="nc">&nbsp;                        target.getTargetId(), weaponId, clientgui.getClient().getGame());</b>
<b class="nc">&nbsp;                flightTimeText = String.format(&quot;(%d turns)&quot;, aaa.getTurnsTilHit());</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            clientgui.mechD.wPan.wTargetR.setText(target.getDisplayName());</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wRangeR</b>
<b class="nc">&nbsp;                    .setText(String.format(&quot;%d %s&quot;, targetDistance, flightTimeText)); //$NON-NLS-1$</b>
&nbsp;            
<b class="nc">&nbsp;            IGame game = clientgui.getClient().getGame();</b>
<b class="nc">&nbsp;            int distance = Compute.effectiveDistance(game, ce(),</b>
&nbsp;                    target);
<b class="nc">&nbsp;            if (m.isUsedThisRound()) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;TargetingPhaseDisplay.alreadyFired&quot;));</b>
&nbsp;                //$NON-NLS-1$
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if (m.isInBearingsOnlyMode() &amp;&amp; distance &lt; RangeType.RANGE_BEARINGS_ONLY_MINIMUM) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(Messages.getString(&quot;TargetingPhaseDisplay.bearingsOnlyMinRange&quot;));</b>
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if ((m.getType().hasFlag(WeaponType.F_AUTO_TARGET) &amp;&amp; !m.curMode().equals(Weapon.MODE_AMS_MANUAL))) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;TargetingPhaseDisplay.autoFiringWeapon&quot;));</b>
&nbsp;                //$NON-NLS-1$
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(toHit.getValueAsString());</b>
<b class="nc">&nbsp;                setFireEnabled(false);</b>
<b class="nc">&nbsp;            } else if (toHit.getValue() == TargetRoll.AUTOMATIC_FAIL) {</b>
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR.setText(toHit.getValueAsString());</b>
<b class="nc">&nbsp;                setFireEnabled(true);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                clientgui.mechD.wPan.wToHitR</b>
<b class="nc">&nbsp;                        .setText(toHit.getValueAsString()</b>
&nbsp;                                + &quot; (&quot;
<b class="nc">&nbsp;                                + Compute.oddsAbove(</b>
<b class="nc">&nbsp;                                        toHit.getValue(),</b>
<b class="nc">&nbsp;                                        ce().hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))</b>
&nbsp;                                + &quot;%)&quot;); //$NON-NLS-1$ //$NON-NLS-2$
<b class="nc">&nbsp;                setFireEnabled(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            clientgui.mechD.wPan.toHitText.setText(toHit.getDesc());</b>
<b class="nc">&nbsp;            setSkipEnabled(true);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wTargetR.setText(&quot;---&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wRangeR.setText(&quot;---&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.wToHitR.setText(&quot;---&quot;); //$NON-NLS-1$</b>
<b class="nc">&nbsp;            clientgui.mechD.wPan.toHitText.setText(&quot;&quot;); //$NON-NLS-1$</b>
&nbsp;        }
<b class="nc">&nbsp;        updateSearchlight();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Torso twist in the proper direction.
&nbsp;     */
&nbsp;    void torsoTwist(Coords cTarget) {
<b class="nc">&nbsp;        int direction = ce().getFacing();</b>
&nbsp;
<b class="nc">&nbsp;        if (null != cTarget) {</b>
<b class="nc">&nbsp;            direction = ce().clipSecondaryFacing(</b>
<b class="nc">&nbsp;                    ce().getPosition().direction(cTarget));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (direction != ce().getSecondaryFacing()) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            attacks.addElement(new TorsoTwistAction(cen, direction));</b>
<b class="nc">&nbsp;            ce().setSecondaryFacing(direction);</b>
<b class="nc">&nbsp;            refreshAll();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Torso twist to the left or right
&nbsp;     *
&nbsp;     * @param twistDirection An &lt;code&gt;int&lt;/code&gt; specifying wether we&#39;re twisting left or
&nbsp;     *                       right, 0 if we&#39;re twisting to the left, 1 if to the right.
&nbsp;     */
&nbsp;
&nbsp;    void torsoTwist(int twistDirection) {
<b class="nc">&nbsp;        int direction = ce().getSecondaryFacing();</b>
<b class="nc">&nbsp;        if (twistDirection == 0) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            direction = ce().clipSecondaryFacing((direction + 5) % 6);</b>
<b class="nc">&nbsp;            attacks.addElement(new TorsoTwistAction(cen, direction));</b>
<b class="nc">&nbsp;            ce().setSecondaryFacing(direction);</b>
<b class="nc">&nbsp;            refreshAll();</b>
<b class="nc">&nbsp;        } else if (twistDirection == 1) {</b>
<b class="nc">&nbsp;            clearAttacks();</b>
<b class="nc">&nbsp;            direction = ce().clipSecondaryFacing((direction + 7) % 6);</b>
<b class="nc">&nbsp;            attacks.addElement(new TorsoTwistAction(cen, direction));</b>
<b class="nc">&nbsp;            ce().setSecondaryFacing(direction);</b>
<b class="nc">&nbsp;            refreshAll();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Cache the list of visible targets. This is used for the &#39;next target&#39;
&nbsp;     * button.
&nbsp;     * &lt;p/&gt;
&nbsp;     * We&#39;ll sort it by range to us.
&nbsp;     */
&nbsp;    private void cacheVisibleTargets() {
<b class="nc">&nbsp;        clearVisibleTargets();</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Entity&gt; vec = clientgui.getClient().getGame().getValidTargets(ce());</b>
<b class="nc">&nbsp;        Comparator&lt;Entity&gt; sortComp = new Comparator&lt;Entity&gt;() {</b>
&nbsp;            public int compare(Entity x, Entity y) {
&nbsp;
<b class="nc">&nbsp;                int rangeToX = ce().getPosition().distance(x.getPosition());</b>
<b class="nc">&nbsp;                int rangeToY = ce().getPosition().distance(y.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;                if (rangeToX == rangeToY) {</b>
<b class="nc">&nbsp;                    return x.getId() &lt; y.getId() ? -1 : 1;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return rangeToX &lt; rangeToY ? -1 : 1;</b>
&nbsp;            }
&nbsp;        };
&nbsp;
<b class="nc">&nbsp;        TreeSet&lt;Entity&gt; tree = new TreeSet&lt;Entity&gt;(sortComp);</b>
<b class="nc">&nbsp;        visibleTargets = new Entity[vec.size()];</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; vec.size(); i++) {</b>
<b class="nc">&nbsp;            tree.add(vec.get(i));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Iterator&lt;Entity&gt; it = tree.iterator();</b>
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        while (it.hasNext()) {</b>
<b class="nc">&nbsp;            visibleTargets[count++] = it.next();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        setNextTargetEnabled(visibleTargets.length &gt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void clearVisibleTargets() {
<b class="nc">&nbsp;        visibleTargets = null;</b>
<b class="nc">&nbsp;        lastTargetID = -1;</b>
<b class="nc">&nbsp;        setNextTargetEnabled(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the next target. Return null if we don&#39;t have any targets.
&nbsp;     */
&nbsp;    private Entity getNextTarget() {
<b class="nc">&nbsp;        if (null == visibleTargets) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        lastTargetID++;</b>
&nbsp;
<b class="nc">&nbsp;        if (lastTargetID &gt;= visibleTargets.length) {</b>
<b class="nc">&nbsp;            lastTargetID = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return visibleTargets[lastTargetID];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Jump to our next target. If there isn&#39;t one, well, don&#39;t do anything.
&nbsp;     */
&nbsp;    private void jumpToNextTarget() {
<b class="nc">&nbsp;        Entity targ = getNextTarget();</b>
&nbsp;
<b class="nc">&nbsp;        if (null == targ) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        clientgui.bv.centerOnHex(targ.getPosition());</b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(targ.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        target(targ);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Get the next target. Return null if we don&#39;t have any targets.
&nbsp;     */
&nbsp;    private Entity getPrevTarget() {
<b class="nc">&nbsp;        if (visibleTargets == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        lastTargetID--;</b>
&nbsp;
<b class="nc">&nbsp;        if (lastTargetID &lt; 0) {</b>
<b class="nc">&nbsp;            lastTargetID = visibleTargets.length - 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return visibleTargets[lastTargetID];</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Jump to our next target. If there isn&#39;t one, well, don&#39;t do anything.
&nbsp;     */
&nbsp;    private void jumpToPrevTarget() {
<b class="nc">&nbsp;        Entity targ = getPrevTarget();</b>
&nbsp;
<b class="nc">&nbsp;        if (targ == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        clientgui.bv.centerOnHex(targ.getPosition());</b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(targ.getPosition());</b>
&nbsp;
<b class="nc">&nbsp;        target(targ);</b>
&nbsp;    }    
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current entity.
&nbsp;     */
&nbsp;    Entity ce() {
<b class="nc">&nbsp;        return clientgui.getClient().getGame().getEntity(cen);</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // BoardListener
&nbsp;    //
&nbsp;    @Override
&nbsp;    public void hexMoused(BoardViewEvent b) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // ignore buttons other than 1
<b class="nc">&nbsp;        if (!clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;            || ((b.getModifiers() &amp; InputEvent.BUTTON1_MASK) == 0)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // control pressed means a line of sight check.
&nbsp;        // added ALT_MASK by kenn
<b class="nc">&nbsp;        if (((b.getModifiers() &amp; InputEvent.CTRL_MASK) != 0)</b>
<b class="nc">&nbsp;            || ((b.getModifiers() &amp; InputEvent.ALT_MASK) != 0)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // check for shifty goodness
<b class="nc">&nbsp;        if (shiftheld != ((b.getModifiers() &amp; InputEvent.SHIFT_MASK) != 0)) {</b>
<b class="nc">&nbsp;            shiftheld = (b.getModifiers() &amp; InputEvent.SHIFT_MASK) != 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (b.getType() == BoardViewEvent.BOARD_HEX_DRAGGED) {</b>
<b class="nc">&nbsp;            if (shiftheld || twisting) {</b>
<b class="nc">&nbsp;                updateFlipArms(false);</b>
<b class="nc">&nbsp;                torsoTwist(b.getCoords());</b>
&nbsp;            }
<b class="nc">&nbsp;            clientgui.getBoardView().cursor(b.getCoords());</b>
<b class="nc">&nbsp;        } else if (b.getType() == BoardViewEvent.BOARD_HEX_CLICKED) {</b>
<b class="nc">&nbsp;            twisting = false;</b>
<b class="nc">&nbsp;            clientgui.getBoardView().select(b.getCoords());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void hexSelected(BoardViewEvent b) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        final Client client = clientgui.getClient();</b>
&nbsp;
<b class="nc">&nbsp;        if (client.isMyTurn() &amp;&amp; (b.getCoords() != null)</b>
<b class="nc">&nbsp;                &amp;&amp; (ce() != null) &amp;&amp; !b.getCoords().equals(ce().getPosition())) {</b>
<b class="nc">&nbsp;            if (shiftheld) {</b>
<b class="nc">&nbsp;                updateFlipArms(false);</b>
<b class="nc">&nbsp;                torsoTwist(b.getCoords());</b>
<b class="nc">&nbsp;            } else if (phase == IGame.Phase.PHASE_TARGETING) {</b>
<b class="nc">&nbsp;                target(new HexTarget(b.getCoords(), ce().getGame().getBoard(),</b>
&nbsp;                        Targetable.TYPE_HEX_ARTILLERY));
&nbsp;            } else {
<b class="nc">&nbsp;                target(chooseTarget(b.getCoords()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Have the player select a target from the entities at the given coords.
&nbsp;     *
&nbsp;     * @param pos - the &lt;code&gt;Coords&lt;/code&gt; containing targets.
&nbsp;     */
&nbsp;    private Targetable chooseTarget(Coords pos) {
&nbsp;
<b class="nc">&nbsp;        boolean friendlyFire = clientgui.getClient().getGame().getOptions()</b>
<b class="nc">&nbsp;                .booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE); //$NON-NLS-1$</b>
&nbsp;        // Assume that we have *no* choice.
<b class="nc">&nbsp;        Targetable choice = null;</b>
&nbsp;        Iterator&lt;Entity&gt; choices;
&nbsp;
&nbsp;        // Get the available choices, depending on friendly fire
<b class="nc">&nbsp;        if (friendlyFire) {</b>
<b class="nc">&nbsp;            choices = clientgui.getClient().getGame().getEntities(pos);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            choices = clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                    .getEnemyEntities(pos, ce());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Convert the choices into a List of targets.
<b class="nc">&nbsp;        List&lt;Targetable&gt; targets = new ArrayList&lt;Targetable&gt;();</b>
<b class="nc">&nbsp;        final IPlayer localPlayer = clientgui.getClient().getLocalPlayer();</b>
<b class="nc">&nbsp;        while (choices.hasNext()) {</b>
<b class="nc">&nbsp;            Targetable t = choices.next();</b>
<b class="nc">&nbsp;            boolean isSensorReturn = false;</b>
<b class="nc">&nbsp;            boolean isVisible = true;</b>
<b class="nc">&nbsp;            if (t instanceof Entity) {</b>
<b class="nc">&nbsp;                isSensorReturn = ((Entity) t).isSensorReturn(localPlayer);</b>
<b class="nc">&nbsp;                isVisible = ((Entity) t).hasSeenEntity(localPlayer);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!ce().equals(t) &amp;&amp; !isSensorReturn &amp;&amp; isVisible) {</b>
<b class="nc">&nbsp;                targets.add(t);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Is there a building in the hex?
<b class="nc">&nbsp;        Building bldg = clientgui.getClient().getGame().getBoard()</b>
<b class="nc">&nbsp;                .getBuildingAt(pos);</b>
<b class="nc">&nbsp;        if (bldg != null) {</b>
<b class="nc">&nbsp;            targets.add(new BuildingTarget(pos, clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                    .getBoard(), Targetable.TYPE_BLDG_TAG));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        targets.add(new HexTarget(pos, clientgui.getClient().getGame()</b>
<b class="nc">&nbsp;                .getBoard(), Targetable.TYPE_HEX_TAG));</b>
&nbsp;
&nbsp;        // Do we have a single choice?
<b class="nc">&nbsp;        if (targets.size() == 1) {</b>
&nbsp;            // Return that choice.
<b class="nc">&nbsp;            choice = targets.get(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // If we have multiple choices, display a selection dialog.
<b class="nc">&nbsp;        else if (targets.size() &gt; 1) {</b>
<b class="nc">&nbsp;            String input = (String) JOptionPane</b>
<b class="nc">&nbsp;                    .showInputDialog(</b>
&nbsp;                            clientgui,
<b class="nc">&nbsp;                            Messages.getString(</b>
&nbsp;                                    &quot;FiringDisplay.ChooseTargetDialog.message&quot;, //$NON-NLS-1$ 
<b class="nc">&nbsp;                                    new Object[] { pos.getBoardNum() }),</b>
<b class="nc">&nbsp;                            Messages.getString(&quot;FiringDisplay.ChooseTargetDialog.title&quot;), //$NON-NLS-1$</b>
&nbsp;                            JOptionPane.QUESTION_MESSAGE, null, SharedUtility
<b class="nc">&nbsp;                                    .getDisplayArray(targets), null);</b>
<b class="nc">&nbsp;            choice = SharedUtility.getTargetPicked(targets, input);</b>
&nbsp;        } // End have-choices
&nbsp;
&nbsp;        // Return the chosen unit.
<b class="nc">&nbsp;        return choice;</b>
&nbsp;
&nbsp;    } // End private Targetable chooseTarget( Coords )
&nbsp;
&nbsp;    //
&nbsp;    // GameListener
&nbsp;    //
&nbsp;    @Override
&nbsp;    public void gameTurnChange(GameTurnChangeEvent e) {
&nbsp;
&nbsp;        // In case of a /reset command, ensure the state gets reset
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {</b>
<b class="nc">&nbsp;            endMyTurn();</b>
&nbsp;        }
&nbsp;        // On simultaneous phases, each player ending their turn will generalte a turn change
&nbsp;        // We want to ignore turns from other players and only listen to events we generated
&nbsp;        // Except on the first turn
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().isPhaseSimultaneous()</b>
<b class="nc">&nbsp;                &amp;&amp; (e.getPreviousPlayerId() != clientgui.getClient().getLocalPlayerNumber())</b>
<b class="nc">&nbsp;                &amp;&amp; (clientgui.getClient().getGame().getTurnIndex() != 0)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getPhase() == phase) {</b>
&nbsp;
<b class="nc">&nbsp;            if (clientgui.getClient().isMyTurn()) {</b>
<b class="nc">&nbsp;                if (cen == Entity.NONE) {</b>
<b class="nc">&nbsp;                    beginMyTurn();</b>
&nbsp;                }
<b class="nc">&nbsp;                setStatusBarText(Messages</b>
<b class="nc">&nbsp;                        .getString(&quot;TargetingPhaseDisplay.its_your_turn&quot;)); //$NON-NLS-1$</b>
&nbsp;            } else {
<b class="nc">&nbsp;                endMyTurn();</b>
<b class="nc">&nbsp;                if (e.getPlayer() != null) {</b>
<b class="nc">&nbsp;                    setStatusBarText(Messages.getString(</b>
&nbsp;                            &quot;TargetingPhaseDisplay.its_others_turn&quot;, //$NON-NLS-1$
<b class="nc">&nbsp;                            new Object[] { e.getPlayer().getName() }));</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void gamePhaseChange(GamePhaseChangeEvent e) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn()</b>
<b class="nc">&nbsp;                &amp;&amp; (clientgui.getClient().getGame().getPhase() != phase)) {</b>
<b class="nc">&nbsp;            endMyTurn();</b>
&nbsp;        }
&nbsp;        // if we&#39;re ending the firing phase, unregister stuff.
<b class="nc">&nbsp;        if (clientgui.getClient().getGame().getPhase() == phase) {</b>
<b class="nc">&nbsp;            setStatusBarText(Messages</b>
<b class="nc">&nbsp;                    .getString(&quot;TargetingPhaseDisplay.waitingForFiringPhase&quot;)); //$NON-NLS-1$</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // ActionListener
&nbsp;    //
&nbsp;    public void actionPerformed(ActionEvent ev) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (statusBarActionPerformed(ev, clientgui.getClient())) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!clientgui.getClient().isMyTurn()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ev.getActionCommand().equals(TargetingCommand.FIRE_FIRE.getCmd())) {</b>
<b class="nc">&nbsp;            fire();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_SKIP.getCmd())) {</b>
<b class="nc">&nbsp;            nextWeapon();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_TWIST.getCmd())) {</b>
<b class="nc">&nbsp;            twisting = true;</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_NEXT.getCmd())) {</b>
<b class="nc">&nbsp;            selectEntity(clientgui.getClient().getNextEntityNum(cen));</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_NEXT_TARG.getCmd())) {</b>
<b class="nc">&nbsp;            jumpToNextTarget();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_FLIP_ARMS.getCmd())) {</b>
<b class="nc">&nbsp;            updateFlipArms(!ce().getArmsFlipped());</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_MODE.getCmd())) {</b>
<b class="nc">&nbsp;            changeMode(true);</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_CANCEL.getCmd())) {</b>
<b class="nc">&nbsp;            clear();</b>
<b class="nc">&nbsp;        } else if (ev.getActionCommand().equals(TargetingCommand.FIRE_SEARCHLIGHT.getCmd())) {</b>
<b class="nc">&nbsp;            doSearchlight();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void updateFlipArms(boolean armsFlipped) {
<b class="nc">&nbsp;        if (armsFlipped == ce().getArmsFlipped()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        twisting = false;</b>
&nbsp;
<b class="nc">&nbsp;        torsoTwist(null);</b>
&nbsp;
<b class="nc">&nbsp;        clearAttacks();</b>
<b class="nc">&nbsp;        ce().setArmsFlipped(armsFlipped);</b>
<b class="nc">&nbsp;        attacks.addElement(new FlipArmsAction(cen, armsFlipped));</b>
<b class="nc">&nbsp;        updateTarget();</b>
<b class="nc">&nbsp;        refreshAll();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateSearchlight() {
<b class="nc">&nbsp;        setSearchlightEnabled((ce() != null)</b>
&nbsp;                &amp;&amp; (target != null)
<b class="nc">&nbsp;                &amp;&amp; ce().isUsingSpotlight()</b>
<b class="nc">&nbsp;                &amp;&amp; ce().getCrew().isActive()</b>
<b class="nc">&nbsp;                &amp;&amp; SearchlightAttackAction.isPossible(clientgui.getClient()</b>
<b class="nc">&nbsp;                        .getGame(), cen, target, null));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setFireEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_FIRE).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireFireEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setTwistEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_TWIST).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireTwistEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setSkipEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_SKIP).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireSkipEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setFlipArmsEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_FLIP_ARMS).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireFlipArmsEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setNextEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_NEXT).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireNextEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setSearchlightEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_SEARCHLIGHT).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireSearchlightEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setFireModeEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_MODE).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireModeEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setNextTargetEnabled(boolean enabled) {
<b class="nc">&nbsp;        buttons.get(TargetingCommand.FIRE_NEXT_TARG).setEnabled(enabled);</b>
<b class="nc">&nbsp;        clientgui.getMenuBar().setFireNextTargetEnabled(enabled);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void clear() {
<b class="nc">&nbsp;        clearAttacks();</b>
<b class="nc">&nbsp;        clientgui.getBoardView().select(null);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().cursor(null);</b>
<b class="nc">&nbsp;        refreshAll();</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // ItemListener
&nbsp;    //
&nbsp;    public void itemStateChanged(ItemEvent ev) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    // board view listener
&nbsp;    @Override
&nbsp;    public void finishedMovingUnits(BoardViewEvent b) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn() &amp;&amp; (ce() != null)) {</b>
<b class="nc">&nbsp;            clientgui.setDisplayVisible(true);</b>
<b class="nc">&nbsp;            clientgui.bv.centerOnHex(ce().getPosition());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void unitSelected(BoardViewEvent b) {
&nbsp;
&nbsp;        // Are we ignoring events?
<b class="nc">&nbsp;        if (isIgnoringEvents()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entity e = clientgui.getClient().getGame().getEntity(b.getEntityId());</b>
<b class="nc">&nbsp;        if (clientgui.getClient().isMyTurn()) {</b>
<b class="nc">&nbsp;            if (clientgui.getClient().getMyTurn()</b>
<b class="nc">&nbsp;                    .isValidEntity(e, clientgui.getClient().getGame())) {</b>
<b class="nc">&nbsp;                selectEntity(e.getId());</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            clientgui.setDisplayVisible(true);</b>
<b class="nc">&nbsp;            clientgui.mechD.displayEntity(e);</b>
<b class="nc">&nbsp;            if (e.isDeployed()) {</b>
<b class="nc">&nbsp;                clientgui.bv.centerOnHex(e.getPosition());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Stop just ignoring events and actually stop listening to them.
&nbsp;     */
&nbsp;    public void removeAllListeners() {
<b class="nc">&nbsp;        clientgui.getClient().getGame().removeGameListener(this);</b>
<b class="nc">&nbsp;        clientgui.getBoardView().removeBoardViewListener(this);</b>
<b class="nc">&nbsp;        clientgui.mechD.wPan.weaponList.removeListSelectionListener(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void valueChanged(ListSelectionEvent event) {
<b class="nc">&nbsp;        if (event.getValueIsAdjusting()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (event.getSource().equals(clientgui.mechD.wPan.weaponList)) {</b>
&nbsp;            // update target data in weapon display
<b class="nc">&nbsp;            updateTarget();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public void FieldofFire(Entity unit, int[][] ranges, int arc, int loc, int facing) {
&nbsp;        // do nothing here outside the arty targeting phase
<b class="nc">&nbsp;        if (!(clientgui.getClient().getGame().getPhase() == Phase.PHASE_TARGETING)) return;</b>
&nbsp;        
<b class="nc">&nbsp;        clientgui.bv.fieldofFireUnit = unit;</b>
<b class="nc">&nbsp;        clientgui.bv.fieldofFireRanges = ranges;</b>
<b class="nc">&nbsp;        clientgui.bv.fieldofFireWpArc = arc;</b>
<b class="nc">&nbsp;        clientgui.bv.fieldofFireWpLoc = loc;</b>
&nbsp;        
<b class="nc">&nbsp;        clientgui.bv.setWeaponFieldofFire(facing, unit.getPosition());</b>
&nbsp;    }
&nbsp;    
&nbsp;    
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
