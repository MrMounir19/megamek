


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MiniMap</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.client.ui.swing</a>
</div>

<h1>Coverage Summary for Class: MiniMap (megamek.client.ui.swing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MiniMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1034)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MiniMap$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniMap$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1109)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek - Copyright (C) 2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; * Copyright (C) 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)
&nbsp; *
&nbsp; * This program is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU General Public License as published by the Free
&nbsp; * Software Foundation; either version 2 of the License, or (at your option)
&nbsp; * any later version.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but
&nbsp; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; * for more details.
&nbsp; */
&nbsp;package megamek.client.ui.swing;
&nbsp;
&nbsp;import java.awt.BasicStroke;
&nbsp;import java.awt.Color;
&nbsp;import java.awt.Container;
&nbsp;import java.awt.Cursor;
&nbsp;import java.awt.Dimension;
&nbsp;import java.awt.Font;
&nbsp;import java.awt.FontMetrics;
&nbsp;import java.awt.Graphics;
&nbsp;import java.awt.Graphics2D;
&nbsp;import java.awt.GraphicsConfiguration;
&nbsp;import java.awt.GraphicsDevice;
&nbsp;import java.awt.GraphicsEnvironment;
&nbsp;import java.awt.Image;
&nbsp;import java.awt.Rectangle;
&nbsp;import java.awt.RenderingHints;
&nbsp;import java.awt.Stroke;
&nbsp;import java.awt.event.ComponentAdapter;
&nbsp;import java.awt.event.ComponentEvent;
&nbsp;import java.awt.event.ComponentListener;
&nbsp;import java.awt.event.InputEvent;
&nbsp;import java.awt.event.MouseAdapter;
&nbsp;import java.awt.event.MouseEvent;
&nbsp;import java.awt.event.MouseListener;
&nbsp;import java.awt.event.MouseMotionAdapter;
&nbsp;import java.awt.event.MouseMotionListener;
&nbsp;import java.awt.event.MouseWheelEvent;
&nbsp;import java.awt.event.MouseWheelListener;
&nbsp;import java.awt.font.FontRenderContext;
&nbsp;import java.awt.font.GlyphVector;
&nbsp;import java.awt.geom.AffineTransform;
&nbsp;import java.awt.geom.Path2D;
&nbsp;import java.awt.image.BufferedImage;
&nbsp;import java.io.File;
&nbsp;import java.io.FileReader;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Reader;
&nbsp;import java.io.StreamTokenizer;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import javax.imageio.ImageIO;
&nbsp;import javax.swing.JDialog;
&nbsp;import javax.swing.JPanel;
&nbsp;import javax.swing.JScrollPane;
&nbsp;import javax.swing.SwingUtilities;
&nbsp;
&nbsp;import megamek.client.Client;
&nbsp;import megamek.client.event.BoardViewEvent;
&nbsp;import megamek.client.event.BoardViewListener;
&nbsp;import megamek.client.event.BoardViewListenerAdapter;
&nbsp;import megamek.client.ui.IBoardView;
&nbsp;import megamek.client.ui.Messages;
&nbsp;import megamek.common.Aero;
&nbsp;import megamek.common.Configuration;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EntityMovementMode;
&nbsp;import megamek.common.EntityVisibilityUtils;
&nbsp;import megamek.common.GameTurn;
&nbsp;import megamek.common.GunEmplacement;
&nbsp;import megamek.common.IBoard;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.MechWarrior;
&nbsp;import megamek.common.Protomech;
&nbsp;import megamek.common.Tank;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.VTOL;
&nbsp;import megamek.common.IGame.Phase;
&nbsp;import megamek.common.actions.AttackAction;
&nbsp;import megamek.common.actions.EntityAction;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.event.BoardEvent;
&nbsp;import megamek.common.event.BoardListener;
&nbsp;import megamek.common.event.BoardListenerAdapter;
&nbsp;import megamek.common.event.GameBoardChangeEvent;
&nbsp;import megamek.common.event.GameBoardNewEvent;
&nbsp;import megamek.common.event.GameListener;
&nbsp;import megamek.common.event.GameListenerAdapter;
&nbsp;import megamek.common.event.GamePhaseChangeEvent;
&nbsp;import megamek.common.event.GameTurnChangeEvent;
&nbsp;import megamek.common.util.ImageUtil;
&nbsp;import megamek.common.util.fileUtils.MegaMekFile;
&nbsp;
&nbsp;/**
&nbsp; * Displays all the mapsheets in a scaled-down size. TBD refactorings: -make a
&nbsp; * real public API for this with interfaces -decouple rest of the application
&nbsp; * -use JPanel instead of canvas -move the buttons from graphics to real Swing
&nbsp; * buttons -clean up listenercode.. -initializecolors is fugly -uses exception
&nbsp; * to return from method? -uses break-to-label -uses while-true
&nbsp; */
<b class="nc">&nbsp;public class MiniMap extends JPanel {</b>
&nbsp;    private static final long serialVersionUID = 6964529682842424060L;
<b class="nc">&nbsp;    private static final Color[] m_terrainColors = new Color[Terrains.SIZE];</b>
&nbsp;    private static Color HEAVY_WOODS;
&nbsp;    private static Color ULTRA_HEAVY_WOODS;
&nbsp;    private static Color BACKGROUND;
&nbsp;    private static Color SINKHOLE;
&nbsp;    private static Color SMOKE_AND_FIRE;
&nbsp;
&nbsp;    private static final int SHOW_NO_HEIGHT = 0;
&nbsp;    private static final int SHOW_GROUND_HEIGHT = 1;
&nbsp;    private static final int SHOW_BUILDING_HEIGHT = 2;
&nbsp;    private static final int SHOW_TOTAL_HEIGHT = 3;
&nbsp;    private static final int NBR_MODES = 3;
&nbsp;
&nbsp;    private static final int SCROLL_PANE_WIDTH = 160;
&nbsp;    private static final int SCROLL_PANE_HEIGHT = 200;
&nbsp;
&nbsp;    private BufferedImage m_mapImage;
&nbsp;    private IBoardView m_bview;
&nbsp;    private IGame m_game;
&nbsp;    private IBoard m_board;
&nbsp;    private Container m_dialog;
&nbsp;    private static final int margin = 6;
&nbsp;    private int topMargin;
&nbsp;    private int leftMargin;
&nbsp;    //This value is variable.
&nbsp;    //if the container m_dialog is an instance of JDialog, it is 14. otherwise 0.
<b class="nc">&nbsp;    private int buttonHeight = 0;</b>
<b class="nc">&nbsp;    private boolean minimized = false;</b>
&nbsp;    private int heightBufer;
<b class="nc">&nbsp;    private int unitSize = 6;// variable which define size of triangle for</b>
&nbsp;    // unit representation
<b class="nc">&nbsp;    private Vector&lt;int[]&gt; roadHexIndexes = new Vector&lt;int[]&gt;();</b>
<b class="nc">&nbsp;    private int zoom = GUIPreferences.getInstance().getMinimapZoom();</b>
<b class="nc">&nbsp;    private int[] fontSize = {6, 8, 10, 12, 14, 16};</b>
<b class="nc">&nbsp;    private int[] hexSide = {3, 5, 6, 8, 10, 12};</b>
<b class="nc">&nbsp;    private int[] hexSideByCos30 = {3, 4, 5, 7, 9, 10};</b>
<b class="nc">&nbsp;    private int[] hexSideBySin30 = {2, 2, 3, 4, 5, 6};</b>
<b class="nc">&nbsp;    private int[] halfRoadWidthByCos30 = {0, 0, 1, 2, 2, 3};</b>
<b class="nc">&nbsp;    private int[] halfRoadWidthBySin30 = {0, 0, 1, 1, 1, 2};</b>
<b class="nc">&nbsp;    private int[] halfRoadWidth = {0, 0, 1, 2, 3, 3};</b>
<b class="nc">&nbsp;    private int[] unitSizes = {5, 6, 7, 8, 9, 10};</b>
<b class="nc">&nbsp;    private int[] stratZoom = {8, 9, 11, 12, 14, 16};</b>
<b class="nc">&nbsp;    private int[] unitBorder = {1, 1, 1, 2, 2, 2};</b>
&nbsp;
<b class="nc">&nbsp;    private int heightDisplayMode = SHOW_NO_HEIGHT;</b>
&nbsp;    Coords firstLOS;
&nbsp;    Coords secondLOS;
&nbsp;
&nbsp;    private Client m_client;
&nbsp;
<b class="nc">&nbsp;    private ClientGUI clientgui = null;</b>
&nbsp;
<b class="nc">&nbsp;    boolean dirtyMap = true;</b>
&nbsp;    boolean[][] dirty;
&nbsp;    private Image terrainBuffer;
&nbsp;    
&nbsp;    // Here come the Strat Ops / NATO unit symbols
<b class="nc">&nbsp;    Map&lt;Coords, Integer&gt; multiUnits = new HashMap&lt;Coords, Integer&gt;();</b>
&nbsp;    private static final Path2D STRAT_BASERECT;
&nbsp;    private static final Path2D STRAT_INFANTRY;
&nbsp;    private static final Path2D STRAT_MECH;
&nbsp;    private static final Path2D STRAT_VTOL;
&nbsp;    private static final Path2D STRAT_TANKTRACKED;
&nbsp;    private static final Path2D STRAT_AERO;
&nbsp;    private static final Path2D STRAT_SPHEROID;
&nbsp;    private static final Path2D STRAT_HOVER;
&nbsp;    private static final Path2D STRAT_WHEELED;
&nbsp;    private static final Path2D STRAT_NAVAL;
<b class="nc">&nbsp;    private static final Dimension SYMBOLSIZE = new Dimension(167,103);</b>
<b class="nc">&nbsp;    private static final String[] STRAT_WEIGHTS = { &quot;L&quot;, &quot;L&quot;, &quot;M&quot;, &quot;H&quot;, &quot;A&quot;, &quot;A&quot; };</b>
<b class="nc">&nbsp;    private static final double STRAT_CX = SYMBOLSIZE.getWidth()/5; // X center for two symbols</b>
&nbsp;    
&nbsp;    static {
&nbsp;        // Base rectangle for all units
<b class="nc">&nbsp;        STRAT_BASERECT = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_BASERECT.moveTo(-SYMBOLSIZE.getWidth()/2, -SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_BASERECT.lineTo( SYMBOLSIZE.getWidth()/2, -SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_BASERECT.lineTo( SYMBOLSIZE.getWidth()/2,  SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_BASERECT.lineTo(-SYMBOLSIZE.getWidth()/2,  SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_BASERECT.closePath();</b>
&nbsp;        
&nbsp;        // Infantry Symbol
<b class="nc">&nbsp;        STRAT_INFANTRY = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_INFANTRY.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        STRAT_INFANTRY.moveTo(-SYMBOLSIZE.getWidth()/2, -SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_INFANTRY.lineTo( SYMBOLSIZE.getWidth()/2,  SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_INFANTRY.moveTo(-SYMBOLSIZE.getWidth()/2,  SYMBOLSIZE.getHeight()/2);</b>
<b class="nc">&nbsp;        STRAT_INFANTRY.lineTo( SYMBOLSIZE.getWidth()/2, -SYMBOLSIZE.getHeight()/2);</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_VTOL = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_VTOL.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        STRAT_VTOL.moveTo(-SYMBOLSIZE.getWidth()/4, -SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_VTOL.lineTo(-SYMBOLSIZE.getWidth()/4,  SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_VTOL.lineTo( 0,  0);</b>
<b class="nc">&nbsp;        STRAT_VTOL.lineTo(-SYMBOLSIZE.getWidth()/4, -SYMBOLSIZE.getHeight()/4);</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_VTOL.moveTo( SYMBOLSIZE.getWidth()/4,  SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_VTOL.lineTo( SYMBOLSIZE.getWidth()/4, -SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_VTOL.lineTo( 0, 0);</b>
<b class="nc">&nbsp;        STRAT_VTOL.closePath();</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_TANKTRACKED = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        double small = SYMBOLSIZE.getWidth()/20; </b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.moveTo(-SYMBOLSIZE.getWidth()/3+small, -SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo( SYMBOLSIZE.getWidth()/3-small, -SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo( SYMBOLSIZE.getWidth()/3,       -SYMBOLSIZE.getHeight()/4+small);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo( SYMBOLSIZE.getWidth()/3,        SYMBOLSIZE.getHeight()/4-small);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo( SYMBOLSIZE.getWidth()/3-small,  SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo(-SYMBOLSIZE.getWidth()/3+small,  SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo(-SYMBOLSIZE.getWidth()/3,        SYMBOLSIZE.getHeight()/4-small);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.lineTo(-SYMBOLSIZE.getWidth()/3,       -SYMBOLSIZE.getHeight()/4+small);</b>
<b class="nc">&nbsp;        STRAT_TANKTRACKED.closePath();</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_MECH = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_MECH.append(STRAT_BASERECT, false);</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_MECH.moveTo(-STRAT_CX-1.5*small, -SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_MECH.lineTo(-STRAT_CX-3.0*small,  SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_MECH.lineTo(-STRAT_CX+3.0*small,  SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_MECH.lineTo(-STRAT_CX+1.5*small, -SYMBOLSIZE.getHeight()/4);</b>
<b class="nc">&nbsp;        STRAT_MECH.closePath();</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_AERO = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_AERO.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        double rad = SYMBOLSIZE.getWidth()/5;</b>
<b class="nc">&nbsp;        double r72 = Math.toRadians(72);</b>
<b class="nc">&nbsp;        STRAT_AERO.moveTo(-STRAT_CX+rad/3*Math.cos(Math.PI/2+2*r72), rad/3*Math.sin(Math.PI/2+2*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad*Math.cos(Math.PI/2+1*r72), -rad*Math.sin(Math.PI/2+1*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad/3*Math.cos(Math.PI/2+1*r72), rad/3*Math.sin(Math.PI/2+1*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad*Math.cos(Math.PI/2+2*r72), -rad*Math.sin(Math.PI/2+2*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad/3*Math.cos(Math.PI/2), rad/3*Math.sin(Math.PI/2));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad*Math.cos(Math.PI/2+3*r72), -rad*Math.sin(Math.PI/2+3*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad/3*Math.cos(Math.PI/2+4*r72), rad/3*Math.sin(Math.PI/2+4*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad*Math.cos(Math.PI/2+4*r72), -rad*Math.sin(Math.PI/2+4*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad/3*Math.cos(Math.PI/2+3*r72), rad/3*Math.sin(Math.PI/2+3*r72));</b>
<b class="nc">&nbsp;        STRAT_AERO.lineTo(-STRAT_CX+rad*Math.cos(Math.PI/2),       -rad*Math.sin(Math.PI/2));</b>
<b class="nc">&nbsp;        STRAT_AERO.closePath();</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_SPHEROID = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.moveTo(rad*Math.cos(Math.PI/2),       -rad*Math.sin(Math.PI/2));</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.lineTo(rad*Math.cos(Math.PI/2+r72),   -rad*Math.sin(Math.PI/2+r72));</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.lineTo(rad*Math.cos(Math.PI/2+2*r72), -rad*Math.sin(Math.PI/2+2*r72));</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.lineTo(rad*Math.cos(Math.PI/2+3*r72), -rad*Math.sin(Math.PI/2+3*r72));</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.lineTo(rad*Math.cos(Math.PI/2+4*r72), -rad*Math.sin(Math.PI/2+4*r72));</b>
<b class="nc">&nbsp;        STRAT_SPHEROID.closePath();</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_HOVER = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_HOVER.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        STRAT_HOVER.moveTo(-SYMBOLSIZE.getWidth()/3,  small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.lineTo(-SYMBOLSIZE.getWidth()/3, -small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.lineTo( SYMBOLSIZE.getWidth()/3, -small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.lineTo( SYMBOLSIZE.getWidth()/3,  small);</b>
&nbsp;
<b class="nc">&nbsp;        STRAT_HOVER.moveTo(-SYMBOLSIZE.getWidth()/6, -small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.lineTo(-SYMBOLSIZE.getWidth()/6, +small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.moveTo(0, -small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.lineTo(0, +small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.moveTo( SYMBOLSIZE.getWidth()/6, -small);</b>
<b class="nc">&nbsp;        STRAT_HOVER.lineTo( SYMBOLSIZE.getWidth()/6, +small);</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_WHEELED = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_WHEELED.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        double smallr = SYMBOLSIZE.getWidth()/17;</b>
<b class="nc">&nbsp;        STRAT_WHEELED.moveTo(-STRAT_CX-smallr*2, -smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(+STRAT_CX+smallr*2, -smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.moveTo(-STRAT_CX, -smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(-STRAT_CX-smallr, 0);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(-STRAT_CX, +smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(-STRAT_CX+smallr, 0);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.closePath();</b>
<b class="nc">&nbsp;        STRAT_WHEELED.moveTo( STRAT_CX, -smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo( STRAT_CX-smallr, 0);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo( STRAT_CX, +smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo( STRAT_CX+smallr, 0);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.closePath();</b>
<b class="nc">&nbsp;        STRAT_WHEELED.moveTo(0, -smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(-smallr, 0);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(0, +smallr);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.lineTo(smallr, 0);</b>
<b class="nc">&nbsp;        STRAT_WHEELED.closePath();</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_NAVAL = new Path2D.Double();</b>
<b class="nc">&nbsp;        STRAT_NAVAL.append(STRAT_BASERECT, false);</b>
<b class="nc">&nbsp;        STRAT_NAVAL.moveTo(0, -SYMBOLSIZE.getHeight()/3);</b>
<b class="nc">&nbsp;        STRAT_NAVAL.lineTo(0,  SYMBOLSIZE.getHeight()/3);</b>
<b class="nc">&nbsp;        STRAT_NAVAL.moveTo(-STRAT_CX/2, -SYMBOLSIZE.getHeight()/5);</b>
<b class="nc">&nbsp;        STRAT_NAVAL.lineTo( STRAT_CX/2, -SYMBOLSIZE.getHeight()/5);</b>
&nbsp;        
<b class="nc">&nbsp;        STRAT_NAVAL.moveTo(rad, 0);</b>
<b class="nc">&nbsp;        STRAT_NAVAL.curveTo(</b>
<b class="nc">&nbsp;                rad*0.8, SYMBOLSIZE.getHeight()/3*0.8,</b>
<b class="nc">&nbsp;                rad*0.8, SYMBOLSIZE.getHeight()/3*0.8,</b>
<b class="nc">&nbsp;                0, SYMBOLSIZE.getHeight()/3);</b>
<b class="nc">&nbsp;        STRAT_NAVAL.curveTo(</b>
<b class="nc">&nbsp;                -rad*0.8, SYMBOLSIZE.getHeight()/3*0.8,</b>
<b class="nc">&nbsp;                -rad*0.8, SYMBOLSIZE.getHeight()/3*0.8,</b>
&nbsp;                -rad, 0);
&nbsp;    }
&nbsp;    
&nbsp;    // are we drag-scrolling?
<b class="nc">&nbsp;    private boolean dragging = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates and lays out a new mech display.
&nbsp;     */
<b class="nc">&nbsp;    public MiniMap(Container d, IGame g, IBoardView bview) throws IOException {</b>
<b class="nc">&nbsp;        m_game = g;</b>
<b class="nc">&nbsp;        m_bview = bview;</b>
<b class="nc">&nbsp;        m_dialog = d;</b>
<b class="nc">&nbsp;        m_board = m_game.getBoard();</b>
<b class="nc">&nbsp;        m_bview.addBoardViewListener(boardViewListener);</b>
<b class="nc">&nbsp;        m_game.addGameListener(gameListener);</b>
<b class="nc">&nbsp;        m_board.addBoardListener(boardListener);</b>
<b class="nc">&nbsp;        initialize();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public MiniMap(Container d, IBoard b) throws IOException {</b>
<b class="nc">&nbsp;        m_dialog = d;</b>
<b class="nc">&nbsp;        m_board = b;</b>
<b class="nc">&nbsp;        initialize();</b>
&nbsp;    }
&nbsp;
&nbsp;    public MiniMap(Container d, ClientGUI c, IBoardView bview) throws IOException {
<b class="nc">&nbsp;        this(d, c.getClient().getGame(), bview);</b>
<b class="nc">&nbsp;        clientgui = c;</b>
&nbsp;
&nbsp;        // this may come in useful later...
<b class="nc">&nbsp;        m_client = c.getClient();</b>
<b class="nc">&nbsp;        assert (m_client != null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setBoard(IBoard board) {
<b class="nc">&nbsp;        m_board = board;</b>
<b class="nc">&nbsp;        initializeMap();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initialize() throws IOException {
<b class="nc">&nbsp;        initializeColors();</b>
<b class="nc">&nbsp;        addMouseListener(mouseListener);</b>
<b class="nc">&nbsp;        addMouseMotionListener(mouseMotionListener);</b>
<b class="nc">&nbsp;        addMouseWheelListener(mouseWheelListener);</b>
<b class="nc">&nbsp;        addComponentListener(componentListener);</b>
<b class="nc">&nbsp;        m_dialog.addComponentListener(componentListener);</b>
<b class="nc">&nbsp;        if (m_dialog instanceof JDialog) {</b>
<b class="nc">&nbsp;            buttonHeight = 14;</b>
<b class="nc">&nbsp;            ((JDialog) m_dialog).setResizable(false);</b>
&nbsp;
&nbsp;            // TODO: replace this quick-and-dirty with some real size
&nbsp;            // calculator.
<b class="nc">&nbsp;            Dimension size = getSize();</b>
<b class="nc">&nbsp;            boolean updateSize = false;</b>
<b class="nc">&nbsp;            if (size.width &lt; GUIPreferences.getInstance().getMinimumSizeWidth()) {</b>
<b class="nc">&nbsp;                size.width = GUIPreferences.getInstance().getMinimumSizeWidth();</b>
<b class="nc">&nbsp;                updateSize = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (size.height &lt; GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                                            .getMinimumSizeHeight()) {</b>
<b class="nc">&nbsp;                size.height = GUIPreferences.getInstance()</b>
<b class="nc">&nbsp;                                            .getMinimumSizeHeight();</b>
<b class="nc">&nbsp;                updateSize = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (updateSize) {</b>
<b class="nc">&nbsp;                setSize(size);</b>
&nbsp;            }
<b class="nc">&nbsp;            setLocation(GUIPreferences.getInstance().getMinimapPosX(),</b>
<b class="nc">&nbsp;                        GUIPreferences.getInstance().getMinimapPosY());</b>
&nbsp;
<b class="nc">&nbsp;            ((JDialog) m_dialog).pack();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public synchronized void update(Graphics g) {
<b class="nc">&nbsp;        paint(g);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void paint(Graphics g) {
<b class="nc">&nbsp;        if (m_mapImage != null) {</b>
<b class="nc">&nbsp;            g.drawImage(m_mapImage, 0, 0, this);</b>
&nbsp;            // drawBox(g); this would be a nice place to draw a visible-area box
<b class="nc">&nbsp;            paintBVSection(g); // Happy to oblige</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initialize default colours and override with config file if there is one.
&nbsp;     */
&nbsp;    private void initializeColors() throws IOException {
&nbsp;
&nbsp;        // set up defaults -- this might go away later...
<b class="nc">&nbsp;        BACKGROUND = Color.black;</b>
<b class="nc">&nbsp;        m_terrainColors[0] = new Color(218, 215, 170);</b>
<b class="nc">&nbsp;        SINKHOLE = new Color(218, 215, 170);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.WOODS] = new Color(180, 230, 130);</b>
<b class="nc">&nbsp;        HEAVY_WOODS = new Color(160, 200, 100);</b>
<b class="nc">&nbsp;        ULTRA_HEAVY_WOODS = new Color(0, 100, 0);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.ROUGH] = new Color(215, 181, 0);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.RUBBLE] = new Color(200, 200, 200);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.WATER] = new Color(200, 247, 253);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.PAVEMENT] = new Color(204, 204, 204);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.ROAD] = new Color(71, 79, 107);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.FIRE] = Color.red;</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.SMOKE] = new Color(204, 204, 204);</b>
<b class="nc">&nbsp;        SMOKE_AND_FIRE = new Color(153, 0, 0);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.SWAMP] = new Color(49, 136, 74);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.BUILDING] = new Color(204, 204, 204);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.FUEL_TANK] = new Color(255, 204, 204);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.BRIDGE] = new Color(109, 55, 25);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.ICE] = new Color(204, 204, 255);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.MAGMA] = new Color(200, 0, 0);</b>
&nbsp;        //m_terrainColors[Terrains.MUD] = new Color(218, 160, 100);
<b class="nc">&nbsp;        m_terrainColors[Terrains.JUNGLE] = new Color(180, 230, 130);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.FIELDS] = new Color(250, 255, 205);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.INDUSTRIAL] = new Color(112, 138, 144);</b>
<b class="nc">&nbsp;        m_terrainColors[Terrains.SPACE] = Color.gray;</b>
&nbsp;
&nbsp;        // now try to read in the config file
&nbsp;        int red;
&nbsp;        int green;
&nbsp;        int blue;
&nbsp;
<b class="nc">&nbsp;        File coloursFile = new MegaMekFile(</b>
<b class="nc">&nbsp;                Configuration.hexesDir(), GUIPreferences.getInstance().getMinimapColours()</b>
<b class="nc">&nbsp;        ).getFile();</b>
&nbsp;
&nbsp;        // only while the defaults are hard-coded!
<b class="nc">&nbsp;        if (!coloursFile.exists()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Reader cr = new FileReader(coloursFile);</b>
<b class="nc">&nbsp;        StreamTokenizer st = new StreamTokenizer(cr);</b>
&nbsp;
<b class="nc">&nbsp;        st.lowerCaseMode(true);</b>
<b class="nc">&nbsp;        st.quoteChar(&#39;&quot;&#39;);</b>
<b class="nc">&nbsp;        st.commentChar(&#39;#&#39;);</b>
&nbsp;
&nbsp;        scan:
&nbsp;        while (true) {
<b class="nc">&nbsp;            red = 0;</b>
<b class="nc">&nbsp;            green = 0;</b>
<b class="nc">&nbsp;            blue = 0;</b>
&nbsp;
<b class="nc">&nbsp;            switch (st.nextToken()) {</b>
&nbsp;                case StreamTokenizer.TT_EOF:
<b class="nc">&nbsp;                    break scan;</b>
&nbsp;                case StreamTokenizer.TT_EOL:
<b class="nc">&nbsp;                    break scan;</b>
&nbsp;                case StreamTokenizer.TT_WORD:
&nbsp;                    // read in
<b class="nc">&nbsp;                    String key = st.sval;</b>
<b class="nc">&nbsp;                    if (key.equals(&quot;unitsize&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        unitSize = (int) st.nval;</b>
<b class="nc">&nbsp;                    } else if (key.equals(&quot;background&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        red = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        green = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        blue = (int) st.nval;</b>
&nbsp;
<b class="nc">&nbsp;                        BACKGROUND = new Color(red, green, blue);</b>
<b class="nc">&nbsp;                    } else if (key.equals(&quot;heavywoods&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        red = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        green = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        blue = (int) st.nval;</b>
&nbsp;
<b class="nc">&nbsp;                        HEAVY_WOODS = new Color(red, green, blue);</b>
<b class="nc">&nbsp;                    } else if (key.equals(&quot;ultraheavywoods&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        red = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        green = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        blue = (int) st.nval;</b>
&nbsp;
<b class="nc">&nbsp;                        ULTRA_HEAVY_WOODS = new Color(red, green, blue);</b>
<b class="nc">&nbsp;                    } else if (key.equals(&quot;sinkhole&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        red = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        green = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        blue = (int) st.nval;</b>
&nbsp;
<b class="nc">&nbsp;                        SINKHOLE = new Color(red, green, blue);</b>
<b class="nc">&nbsp;                    } else if (key.equals(&quot;smokeandfire&quot;)) { //$NON-NLS-1$</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        red = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        green = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        blue = (int) st.nval;</b>
&nbsp;
<b class="nc">&nbsp;                        SMOKE_AND_FIRE = new Color(red, green, blue);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        red = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        green = (int) st.nval;</b>
<b class="nc">&nbsp;                        st.nextToken();</b>
<b class="nc">&nbsp;                        blue = (int) st.nval;</b>
&nbsp;
<b class="nc">&nbsp;                        m_terrainColors[Terrains.getType(key)] = new Color(red,</b>
&nbsp;                                                                           green, blue);
&nbsp;                    }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        cr.close();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void clean() {
<b class="nc">&nbsp;        dirtyMap = false;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; dirty.length; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; dirty[i].length; j++) {</b>
<b class="nc">&nbsp;                dirty[i][j] = false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void initializeMap() {
&nbsp;
&nbsp;        // sanity check (cfg file could be hosed)
<b class="nc">&nbsp;        if (zoom &lt; 0) {</b>
<b class="nc">&nbsp;            zoom = 0;</b>
<b class="nc">&nbsp;        } else if (zoom &gt; (hexSide.length - 1)) {</b>
<b class="nc">&nbsp;            zoom = (hexSide.length - 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        int requiredWidth, requiredHeight;
<b class="nc">&nbsp;        int currentHexSide = hexSide[zoom];</b>
<b class="nc">&nbsp;        int currentHexSideByCos30 = hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;        int currentHexSideBySin30 = hexSideBySin30[zoom];</b>
<b class="nc">&nbsp;        topMargin = margin;</b>
<b class="nc">&nbsp;        leftMargin = margin;</b>
<b class="nc">&nbsp;        requiredWidth = (m_board.getWidth()</b>
&nbsp;                         * (currentHexSide + currentHexSideBySin30))
&nbsp;                        + currentHexSideBySin30 + (2 * margin);
<b class="nc">&nbsp;        requiredHeight = (((2 * m_board.getHeight()) + 1)</b>
&nbsp;                          * currentHexSideByCos30) + (2 * margin) + buttonHeight;
&nbsp;
<b class="nc">&nbsp;        dirty = new boolean[(m_board.getWidth() / 10) + 1][(m_board.getHeight() / 10) + 1];</b>
<b class="nc">&nbsp;        dirtyMap = true;</b>
&nbsp;        
<b class="nc">&nbsp;        unitSize = unitSizes[zoom];</b>
&nbsp;
&nbsp;        // ensure its on screen
<b class="nc">&nbsp;        Rectangle virtualBounds = new Rectangle();</b>
&nbsp;        GraphicsEnvironment ge = GraphicsEnvironment
<b class="nc">&nbsp;                .getLocalGraphicsEnvironment();</b>
<b class="nc">&nbsp;        GraphicsDevice[] gs = ge.getScreenDevices();</b>
<b class="nc">&nbsp;        for (int j = 0; j &lt; gs.length; j++) {</b>
<b class="nc">&nbsp;            GraphicsDevice gd = gs[j];</b>
<b class="nc">&nbsp;            GraphicsConfiguration[] gc = gd.getConfigurations();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; gc.length; i++) {</b>
<b class="nc">&nbsp;                virtualBounds = virtualBounds.union(gc[i].getBounds());</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // zoom out if its too big for the screen
<b class="nc">&nbsp;        while ((zoom &gt; 0)</b>
&nbsp;               &amp;&amp; ((requiredWidth &gt; virtualBounds.width) || (requiredHeight &gt; virtualBounds.height))) {
<b class="nc">&nbsp;            zoom--;</b>
<b class="nc">&nbsp;            currentHexSide = hexSide[zoom];</b>
<b class="nc">&nbsp;            currentHexSideByCos30 = hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;            currentHexSideBySin30 = hexSideBySin30[zoom];</b>
<b class="nc">&nbsp;            requiredWidth = (m_board.getWidth()</b>
&nbsp;                             * (currentHexSide + currentHexSideBySin30))
&nbsp;                            + currentHexSideBySin30 + (2 * margin);
<b class="nc">&nbsp;            requiredHeight = (((2 * m_board.getHeight()) + 1)</b>
&nbsp;                              * currentHexSideByCos30) + (2 * margin) + buttonHeight;
&nbsp;        }
<b class="nc">&nbsp;        int x = getParent().getLocation().x;</b>
<b class="nc">&nbsp;        int y = getParent().getLocation().y;</b>
<b class="nc">&nbsp;        if ((x + requiredWidth) &gt; virtualBounds.getMaxX()) {</b>
<b class="nc">&nbsp;            x = (int) (virtualBounds.getMaxX() - requiredWidth);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (x &lt; virtualBounds.getMinX()) {</b>
<b class="nc">&nbsp;            x = (int) (virtualBounds.getMinX());</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((y + requiredHeight) &gt; virtualBounds.getMaxY()) {</b>
<b class="nc">&nbsp;            y = (int) (virtualBounds.getMaxY() - requiredHeight);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (y &lt; virtualBounds.getMinY()) {</b>
<b class="nc">&nbsp;            y = (int) (virtualBounds.getMinY());</b>
&nbsp;        }
<b class="nc">&nbsp;        getParent().setLocation(x, y);</b>
<b class="nc">&nbsp;        int xTemp = requiredWidth;</b>
<b class="nc">&nbsp;        int yTemp = requiredHeight;</b>
&nbsp;
<b class="nc">&nbsp;        if (m_dialog instanceof JScrollPane) {</b>
&nbsp;            //For the scrollPane, enforce the minimum size.
<b class="nc">&nbsp;            if (requiredWidth &lt; SCROLL_PANE_WIDTH) {</b>
<b class="nc">&nbsp;                xTemp = SCROLL_PANE_WIDTH;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (requiredHeight &lt; SCROLL_PANE_HEIGHT) {</b>
<b class="nc">&nbsp;                yTemp = SCROLL_PANE_HEIGHT;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (minimized) {</b>
<b class="nc">&nbsp;            yTemp = 14;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        setSize(xTemp, yTemp);</b>
<b class="nc">&nbsp;        setPreferredSize(new Dimension(xTemp, yTemp));</b>
<b class="nc">&nbsp;        if (m_dialog instanceof JDialog) {</b>
<b class="nc">&nbsp;            ((JDialog) m_dialog).pack();</b>
&nbsp;        }
&nbsp;        // m_dialog.setVisible(true);
<b class="nc">&nbsp;        m_mapImage = ImageUtil.createAcceleratedImage(getSize().width, getSize().height);</b>
&nbsp;
<b class="nc">&nbsp;        terrainBuffer = createImage(getSize().width, getSize().height);</b>
<b class="nc">&nbsp;        Graphics gg = terrainBuffer.getGraphics();</b>
<b class="nc">&nbsp;        gg.setColor(BACKGROUND);</b>
<b class="nc">&nbsp;        gg.fillRect(0, 0, getSize().width, getSize().height);</b>
&nbsp;
<b class="nc">&nbsp;        if (getSize().width &gt; requiredWidth) {</b>
<b class="nc">&nbsp;            leftMargin = ((getSize().width - requiredWidth) / 2) + margin;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getSize().height &gt; requiredHeight) {</b>
<b class="nc">&nbsp;            topMargin = ((getSize().height - requiredHeight) / 2) + margin;</b>
&nbsp;        }
<b class="nc">&nbsp;        drawMap();</b>
<b class="nc">&nbsp;        revalidate();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected long lastDrawMapReq = 0;</b>
<b class="nc">&nbsp;    protected long lastDrawStarted = 0;</b>
<b class="nc">&nbsp;    protected Runnable drawMapable = new Runnable() {</b>
<b class="nc">&nbsp;        protected final int redrawDelay = 0;</b>
&nbsp;
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                if ((System.currentTimeMillis() - lastDrawMapReq) &gt; redrawDelay) {</b>
<b class="nc">&nbsp;                    drawMapOrig();</b>
&nbsp;                } else {
&nbsp;                    try {
<b class="nc">&nbsp;                        Thread.sleep(50);</b>
<b class="nc">&nbsp;                    } catch (InterruptedException ie) {</b>
&nbsp;                        // should never happen
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    SwingUtilities.invokeLater(drawMapable);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable t) {</b>
<b class="nc">&nbsp;                t.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * this replaces the original drawmap to speed up updates this can be called
&nbsp;     * any time necessary
&nbsp;     */
&nbsp;    public synchronized void drawMap() {
<b class="nc">&nbsp;        lastDrawMapReq = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        SwingUtilities.invokeLater(drawMapable);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * update the backbuffer and repaint.. should not require a synchronized but
&nbsp;     * i left it there anyways
&nbsp;     */
&nbsp;    protected synchronized void drawMapOrig() {
<b class="nc">&nbsp;        if (lastDrawStarted &gt; lastDrawMapReq) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        lastDrawStarted = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        if (m_mapImage == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!m_dialog.isVisible()) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Graphics g = m_mapImage.getGraphics();</b>
&nbsp;        // Activate AA
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getAntiAliasing()) {</b>
<b class="nc">&nbsp;            ((Graphics2D)g).setRenderingHint(</b>
&nbsp;                    RenderingHints.KEY_ANTIALIASING,
&nbsp;                    RenderingHints.VALUE_ANTIALIAS_ON);
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        Color oldColor = g.getColor();</b>
<b class="nc">&nbsp;        g.setColor(oldColor);</b>
<b class="nc">&nbsp;        if (!minimized) {</b>
<b class="nc">&nbsp;            roadHexIndexes.removeAllElements();</b>
<b class="nc">&nbsp;            Graphics gg = terrainBuffer.getGraphics();</b>
&nbsp;            // Activate AA
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getAntiAliasing()) {</b>
<b class="nc">&nbsp;                ((Graphics2D)gg).setRenderingHint(</b>
&nbsp;                        RenderingHints.KEY_ANTIALIASING,
&nbsp;                        RenderingHints.VALUE_ANTIALIAS_ON);
&nbsp;            }
<b class="nc">&nbsp;            for (int j = 0; j &lt; m_board.getWidth(); j++) {</b>
<b class="nc">&nbsp;                for (int k = 0; k &lt; m_board.getHeight(); k++) {</b>
<b class="nc">&nbsp;                    IHex h = m_board.getHex(j, k);</b>
<b class="nc">&nbsp;                    if (dirtyMap || dirty[j / 10][k / 10]) {</b>
<b class="nc">&nbsp;                        gg.setColor(terrainColor(h, j, k));</b>
<b class="nc">&nbsp;                        paintCoord(gg, j, k, true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    addRoadElements(h, j, k);</b>
&nbsp;                    // Color invalid hexes red when in the Map Editor
<b class="nc">&nbsp;                    if ((m_game != null) &amp;&amp; </b>
<b class="nc">&nbsp;                            (m_game.getPhase() == IGame.Phase.PHASE_UNKNOWN)</b>
<b class="nc">&nbsp;                            &amp;&amp; !h.isValid(null)) {</b>
<b class="nc">&nbsp;                        gg.setColor(GUIPreferences.getInstance().getWarningColor());</b>
<b class="nc">&nbsp;                        paintCoord(gg, j, k, true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // draw backbuffer
<b class="nc">&nbsp;            g.drawImage(terrainBuffer, 0, 0, this);</b>
&nbsp;
<b class="nc">&nbsp;            if (firstLOS != null) {</b>
<b class="nc">&nbsp;                paintSingleCoordBorder(g, firstLOS.getX(), firstLOS.getY(), Color.red);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (secondLOS != null) {</b>
<b class="nc">&nbsp;                paintSingleCoordBorder(g, secondLOS.getX(), secondLOS.getY(), Color.red);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!roadHexIndexes.isEmpty()) {</b>
<b class="nc">&nbsp;                paintRoads(g);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (SHOW_NO_HEIGHT != heightDisplayMode) {</b>
<b class="nc">&nbsp;                for (int j = 0; j &lt; m_board.getWidth(); j++) {</b>
<b class="nc">&nbsp;                    for (int k = 0; k &lt; m_board.getHeight(); k++) {</b>
<b class="nc">&nbsp;                        IHex h = m_board.getHex(j, k);</b>
<b class="nc">&nbsp;                        paintHeight(g, h, j, k);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // draw Drop Zone
<b class="nc">&nbsp;            if ((null != m_client) &amp;&amp; (null != m_game)) { // sanity check!</b>
<b class="nc">&nbsp;                if (IGame.Phase.PHASE_DEPLOYMENT == m_game.getPhase()) {</b>
<b class="nc">&nbsp;                    GameTurn turn = m_game.getTurn();</b>
<b class="nc">&nbsp;                    if ((turn != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (turn.getPlayerNum() == m_client.getLocalPlayer()</b>
<b class="nc">&nbsp;                                                           .getId())) {</b>
<b class="nc">&nbsp;                        Entity depEnt = m_bview.getDeployingEntity();</b>
&nbsp;                        int dir;
&nbsp;                        // We need to draw the same deployment zone as boardview
<b class="nc">&nbsp;                        if (depEnt != null &amp;&amp;</b>
<b class="nc">&nbsp;                            depEnt.getOwnerId() == turn.getPlayerNum()) {</b>
<b class="nc">&nbsp;                            dir = depEnt.getStartingPos();</b>
&nbsp;                        } else { // if we can&#39;t get the deploy zone from the 
&nbsp;                            // board view, punt and use the players zone
<b class="nc">&nbsp;                            dir = m_client.getLocalPlayer().getStartingPos();</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        for (int j = 0; j &lt; m_board.getWidth(); j++) {</b>
<b class="nc">&nbsp;                            for (int k = 0; k &lt; m_board.getHeight(); k++) {</b>
<b class="nc">&nbsp;                                if (m_board.isLegalDeployment(</b>
&nbsp;                                        new Coords(j, k), dir)) {
<b class="nc">&nbsp;                                    paintSingleCoordBorder(g, j, k,</b>
&nbsp;                                                           Color.yellow);
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                
&nbsp;                // draw declared fire
<b class="nc">&nbsp;                if ((IGame.Phase.PHASE_FIRING == m_game.getPhase())</b>
<b class="nc">&nbsp;                    || (IGame.Phase.PHASE_PHYSICAL == m_game.getPhase())) {</b>
<b class="nc">&nbsp;                    for (Enumeration&lt;EntityAction&gt; iter = m_game.getActions(); iter</b>
<b class="nc">&nbsp;                            .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                        EntityAction action = iter.nextElement();</b>
<b class="nc">&nbsp;                        if (action instanceof AttackAction) {</b>
<b class="nc">&nbsp;                            paintAttack(g, (AttackAction) action);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                multiUnits.clear();</b>
<b class="nc">&nbsp;                for (Entity e : m_game.getEntitiesVector()) {</b>
<b class="nc">&nbsp;                    if (e.getPosition() == null) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    paintUnit(g, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            clean();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((m_client != null) &amp;&amp; (m_client.getArtilleryAutoHit() != null)) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; m_client.getArtilleryAutoHit().size(); i++) {</b>
<b class="nc">&nbsp;                drawAutoHit(g, m_client.getArtilleryAutoHit().get(i));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (m_dialog instanceof JDialog) {</b>
<b class="nc">&nbsp;            drawBtn(g);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        repaint();</b>
&nbsp;    }
&nbsp;    
&nbsp;    private void paintBVSection(Graphics g) {
<b class="nc">&nbsp;        if (minimized || (m_bview == null)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        double[] relSize = m_bview.getVisibleArea();</b>
<b class="nc">&nbsp;        for (int i=0;i&lt;4;i++) relSize[i] = Math.min(1, Math.max(0,relSize[i]));</b>
&nbsp;        
<b class="nc">&nbsp;        Color sc = g.getColor();</b>
<b class="nc">&nbsp;        Stroke sbs = ((Graphics2D) g).getStroke();</b>
&nbsp;        
&nbsp;        // thicker but translucent rect
<b class="nc">&nbsp;        g.setColor(new Color(100,100,160,80));</b>
<b class="nc">&nbsp;        ((Graphics2D) g).setStroke(new BasicStroke(zoom+2));</b>
&nbsp;        
<b class="nc">&nbsp;        g.drawRect(</b>
<b class="nc">&nbsp;                (int)(relSize[0]*             (hexSide[zoom] + hexSideBySin30[zoom])*m_board.getWidth())+leftMargin,</b>
<b class="nc">&nbsp;                (int)(relSize[1]*2*hexSideByCos30[zoom]*m_board.getHeight())+topMargin,</b>
<b class="nc">&nbsp;                (int)((relSize[2]-relSize[0])*(hexSide[zoom] + hexSideBySin30[zoom])*m_board.getWidth()),</b>
<b class="nc">&nbsp;                (int)((relSize[3]-relSize[1])*2*hexSideByCos30[zoom]*m_board.getHeight()));</b>
&nbsp;        
&nbsp;        // thin less translucent rect
<b class="nc">&nbsp;        g.setColor(new Color(255,255,255,180));</b>
<b class="nc">&nbsp;        ((Graphics2D) g).setStroke(new BasicStroke(zoom/2));</b>
&nbsp;
<b class="nc">&nbsp;        g.drawRect(</b>
<b class="nc">&nbsp;                (int)(relSize[0]*(hexSide[zoom] + hexSideBySin30[zoom])*m_board.getWidth())+leftMargin,</b>
<b class="nc">&nbsp;                (int)(relSize[1]*2*hexSideByCos30[zoom]*m_board.getHeight())+topMargin,</b>
<b class="nc">&nbsp;                (int)((relSize[2]-relSize[0])*(hexSide[zoom] + hexSideBySin30[zoom])*m_board.getWidth()),</b>
<b class="nc">&nbsp;                (int)((relSize[3]-relSize[1])*2*hexSideByCos30[zoom]*m_board.getHeight()));</b>
&nbsp;        
&nbsp;        // restore values
<b class="nc">&nbsp;        ((Graphics2D) g).setStroke(sbs);</b>
<b class="nc">&nbsp;        g.setColor(sc);</b>
&nbsp;        
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a red crosshair for artillery autohit hexes (predesignated only).
&nbsp;     */
&nbsp;    private void drawAutoHit(Graphics g, Coords hex) {
<b class="nc">&nbsp;        int baseX = (hex.getX() * (hexSide[zoom] + hexSideBySin30[zoom])) + leftMargin</b>
&nbsp;                    + hexSide[zoom];
<b class="nc">&nbsp;        int baseY = (((2 * hex.getY()) + 1 + (hex.getX() % 2)) * hexSideByCos30[zoom])</b>
&nbsp;                    + topMargin;
<b class="nc">&nbsp;        Color alt = g.getColor();</b>
<b class="nc">&nbsp;        g.setColor(Color.RED);</b>
<b class="nc">&nbsp;        g.drawOval(baseX - (unitSize - 1), baseY - (unitSize - 1),</b>
&nbsp;                   (2 * unitSize) - 2, (2 * unitSize) - 2);
<b class="nc">&nbsp;        g.drawLine(baseX - unitSize - 1, baseY, (baseX - unitSize) + 3, baseY);</b>
<b class="nc">&nbsp;        g.drawLine(baseX + unitSize + 1, baseY, (baseX + unitSize) - 3, baseY);</b>
<b class="nc">&nbsp;        g.drawLine(baseX, baseY - unitSize - 1, baseX, (baseY - unitSize) + 3);</b>
<b class="nc">&nbsp;        g.drawLine(baseX, baseY + unitSize + 1, baseX, (baseY + unitSize) - 3);</b>
<b class="nc">&nbsp;        g.setColor(alt);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws green JButton in the bottom to close and open mini map. Height of
&nbsp;     * button is fixed to 14pix.
&nbsp;     */
&nbsp;    private void drawBtn(Graphics g) {
<b class="nc">&nbsp;        int[] xPoints = new int[3];</b>
<b class="nc">&nbsp;        int[] yPoints = new int[3];</b>
<b class="nc">&nbsp;        Color oldColor = g.getColor();</b>
<b class="nc">&nbsp;        if (minimized) {</b>
<b class="nc">&nbsp;            xPoints[0] = Math.round((getSize().width - 11) / 2);</b>
<b class="nc">&nbsp;            yPoints[0] = getSize().height - 10;</b>
<b class="nc">&nbsp;            xPoints[1] = xPoints[0] + 11;</b>
<b class="nc">&nbsp;            yPoints[1] = yPoints[0];</b>
<b class="nc">&nbsp;            xPoints[2] = xPoints[0] + 6;</b>
<b class="nc">&nbsp;            yPoints[2] = yPoints[0] + 5;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            xPoints[0] = Math.round((getSize().width - 11) / 2);</b>
<b class="nc">&nbsp;            yPoints[0] = getSize().height - 4;</b>
<b class="nc">&nbsp;            xPoints[1] = xPoints[0] + 11;</b>
<b class="nc">&nbsp;            yPoints[1] = yPoints[0];</b>
<b class="nc">&nbsp;            xPoints[2] = xPoints[0] + 5;</b>
<b class="nc">&nbsp;            yPoints[2] = yPoints[0] - 5;</b>
&nbsp;        }
<b class="nc">&nbsp;        g.setColor(Color.green.darker().darker());</b>
<b class="nc">&nbsp;        g.fillRect(0, getSize().height - 14, getSize().width, 14);</b>
<b class="nc">&nbsp;        g.setColor(Color.green.darker());</b>
<b class="nc">&nbsp;        g.drawLine(0, getSize().height - 14, getSize().width,</b>
<b class="nc">&nbsp;                   getSize().height - 14);</b>
<b class="nc">&nbsp;        g.drawLine(0, getSize().height - 14, 0, getSize().height);</b>
<b class="nc">&nbsp;        g.setColor(Color.black);</b>
<b class="nc">&nbsp;        g.drawLine(0, getSize().height - 1, getSize().width,</b>
<b class="nc">&nbsp;                   getSize().height - 1);</b>
<b class="nc">&nbsp;        g.drawLine(getSize().width - 1, getSize().height - 14,</b>
<b class="nc">&nbsp;                   getSize().width - 1, getSize().height);</b>
<b class="nc">&nbsp;        g.setColor(Color.yellow);</b>
<b class="nc">&nbsp;        g.fillPolygon(xPoints, yPoints, 3);</b>
&nbsp;
&nbsp;        // drawing &quot;+&quot; and &quot;-&quot; buttons
<b class="nc">&nbsp;        if (!minimized) {</b>
<b class="nc">&nbsp;            g.setColor(Color.black);</b>
<b class="nc">&nbsp;            g.drawLine(14 - 1, getSize().height - 14, 14 - 1, getSize().height);</b>
<b class="nc">&nbsp;            g.drawLine(getSize().width - 14 - 1, getSize().height - 14,</b>
<b class="nc">&nbsp;                       getSize().width - 14 - 1, getSize().height);</b>
<b class="nc">&nbsp;            g.setColor(Color.green.darker());</b>
<b class="nc">&nbsp;            g.drawLine(14, getSize().height - 14, 14, getSize().height);</b>
<b class="nc">&nbsp;            g.drawLine(getSize().width - 14, getSize().height - 14,</b>
<b class="nc">&nbsp;                       getSize().width - 14, getSize().height);</b>
<b class="nc">&nbsp;            if (zoom == 0) {</b>
<b class="nc">&nbsp;                g.setColor(Color.gray.brighter());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                g.setColor(Color.yellow);</b>
&nbsp;            }
<b class="nc">&nbsp;            g.fillRect(3, (getSize().height - 14) + 6, 8, 2);</b>
<b class="nc">&nbsp;            if (zoom == (hexSide.length - 1)) {</b>
<b class="nc">&nbsp;                g.setColor(Color.gray.brighter());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                g.setColor(Color.yellow);</b>
&nbsp;            }
<b class="nc">&nbsp;            g.fillRect((getSize().width - 14) + 3, (getSize().height - 14) + 6, 8,</b>
&nbsp;                       2);
<b class="nc">&nbsp;            g.fillRect((getSize().width - 14) + 6, (getSize().height - 14) + 3, 2,</b>
&nbsp;                       8);
&nbsp;
<b class="nc">&nbsp;            if (zoom &gt; 2) {</b>
&nbsp;                // JButton for displying heights.
<b class="nc">&nbsp;                g.setColor(Color.black);</b>
<b class="nc">&nbsp;                g.drawLine(28 - 1, getSize().height - 14, 28 - 1,</b>
<b class="nc">&nbsp;                           getSize().height);</b>
<b class="nc">&nbsp;                g.setColor(Color.green.darker());</b>
<b class="nc">&nbsp;                g.drawLine(28, getSize().height - 14, 28, getSize().height);</b>
<b class="nc">&nbsp;                g.setColor(Color.yellow);</b>
&nbsp;                String label;
<b class="nc">&nbsp;                switch (heightDisplayMode) {</b>
&nbsp;                    case SHOW_NO_HEIGHT:
<b class="nc">&nbsp;                        label = Messages.getString(&quot;MiniMap.NoHeightLabel&quot;); </b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case SHOW_GROUND_HEIGHT:
<b class="nc">&nbsp;                        label = Messages.getString(&quot;MiniMap.GroundHeightLabel&quot;);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case SHOW_BUILDING_HEIGHT:
<b class="nc">&nbsp;                        label = Messages.getString(&quot;MiniMap.BuildingHeightLabel&quot;); </b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case SHOW_TOTAL_HEIGHT:
<b class="nc">&nbsp;                        label = Messages.getString(&quot;MiniMap.TotalHeightLabel&quot;); </b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        label = &quot;&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                g.drawString(label, 17, (getSize().height - 14) + 12);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        g.setColor(oldColor);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private void paintHeight(Graphics g, IHex h, int x, int y) {
<b class="nc">&nbsp;        if (heightDisplayMode == SHOW_NO_HEIGHT) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (zoom &gt; 2) {</b>
<b class="nc">&nbsp;            int baseX = (x * (hexSide[zoom] + hexSideBySin30[zoom])) + leftMargin;</b>
<b class="nc">&nbsp;            int baseY = (((2 * y) + 1 + (x % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
<b class="nc">&nbsp;            g.setColor(Color.white);</b>
<b class="nc">&nbsp;            int height = 0;</b>
<b class="nc">&nbsp;            if ((h.getTerrain(Terrains.BUILDING) != null)</b>
&nbsp;                &amp;&amp; (heightDisplayMode == SHOW_BUILDING_HEIGHT)) {
<b class="nc">&nbsp;                height = h.ceiling();</b>
<b class="nc">&nbsp;            } else if (heightDisplayMode == SHOW_GROUND_HEIGHT) {</b>
<b class="nc">&nbsp;                height = h.floor();</b>
<b class="nc">&nbsp;            } else if (heightDisplayMode == SHOW_TOTAL_HEIGHT) {</b>
<b class="nc">&nbsp;                height = ((h.getTerrain(Terrains.BUILDING) != null) || (h</b>
<b class="nc">&nbsp;                        .getTerrain(Terrains.FUEL_TANK) != null)) ? h.ceiling()</b>
<b class="nc">&nbsp;                        : h.floor();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (height != 0) {</b>
<b class="nc">&nbsp;                g.drawString(height + &quot;&quot;, baseX + 5, baseY + 5); //$NON-NLS-1$</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void paintSingleCoordBorder(Graphics g, int x, int y, Color c) {
<b class="nc">&nbsp;        int baseX = (x * (hexSide[zoom] + hexSideBySin30[zoom])) + leftMargin;</b>
<b class="nc">&nbsp;        int baseY = (((2 * y) + 1 + (x % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
<b class="nc">&nbsp;        int[] xPoints = new int[6];</b>
<b class="nc">&nbsp;        int[] yPoints = new int[6];</b>
<b class="nc">&nbsp;        xPoints[0] = baseX;</b>
<b class="nc">&nbsp;        yPoints[0] = baseY;</b>
<b class="nc">&nbsp;        xPoints[1] = baseX + hexSideBySin30[zoom];</b>
<b class="nc">&nbsp;        yPoints[1] = baseY + hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;        xPoints[2] = xPoints[1] + hexSide[zoom];</b>
<b class="nc">&nbsp;        yPoints[2] = yPoints[1];</b>
<b class="nc">&nbsp;        xPoints[3] = xPoints[2] + hexSideBySin30[zoom];</b>
<b class="nc">&nbsp;        yPoints[3] = baseY;</b>
<b class="nc">&nbsp;        xPoints[4] = xPoints[2];</b>
<b class="nc">&nbsp;        yPoints[4] = baseY - hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;        xPoints[5] = xPoints[1];</b>
<b class="nc">&nbsp;        yPoints[5] = yPoints[4];</b>
<b class="nc">&nbsp;        g.setColor(c);</b>
<b class="nc">&nbsp;        g.drawPolygon(xPoints, yPoints, 6);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void paintCoord(Graphics g, int x, int y, boolean border) {
<b class="nc">&nbsp;        int baseX = (x * (hexSide[zoom] + hexSideBySin30[zoom])) + leftMargin;</b>
<b class="nc">&nbsp;        int baseY = (((2 * y) + 1 + (x % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
<b class="nc">&nbsp;        int[] xPoints = new int[6];</b>
<b class="nc">&nbsp;        int[] yPoints = new int[6];</b>
<b class="nc">&nbsp;        xPoints[0] = baseX;</b>
<b class="nc">&nbsp;        yPoints[0] = baseY;</b>
<b class="nc">&nbsp;        xPoints[1] = baseX + hexSideBySin30[zoom];</b>
<b class="nc">&nbsp;        yPoints[1] = baseY + hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;        xPoints[2] = xPoints[1] + hexSide[zoom];</b>
<b class="nc">&nbsp;        yPoints[2] = yPoints[1];</b>
<b class="nc">&nbsp;        xPoints[3] = xPoints[2] + hexSideBySin30[zoom];</b>
<b class="nc">&nbsp;        yPoints[3] = baseY;</b>
<b class="nc">&nbsp;        xPoints[4] = xPoints[2];</b>
<b class="nc">&nbsp;        yPoints[4] = baseY - hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;        xPoints[5] = xPoints[1];</b>
<b class="nc">&nbsp;        yPoints[5] = yPoints[4];</b>
<b class="nc">&nbsp;        g.fillPolygon(xPoints, yPoints, 6);</b>
<b class="nc">&nbsp;        if (border) {</b>
<b class="nc">&nbsp;            Color oldColor = g.getColor();</b>
<b class="nc">&nbsp;            g.setColor(oldColor.darker());</b>
<b class="nc">&nbsp;            g.drawPolygon(xPoints, yPoints, 6);</b>
<b class="nc">&nbsp;            g.setColor(oldColor);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draw a line to represent an attack
&nbsp;     */
&nbsp;    private void paintAttack(Graphics g, AttackAction attack) {
<b class="nc">&nbsp;        Entity source = m_game.getEntity(attack.getEntityId());</b>
<b class="nc">&nbsp;        Targetable target = m_game.getTarget(attack.getTargetType(),</b>
<b class="nc">&nbsp;                attack.getTargetId());</b>
&nbsp;        // sanity check...
<b class="nc">&nbsp;        if ((null == source) || (null == target)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (attack.getTargetType() == Targetable.TYPE_INARC_POD) {</b>
&nbsp;            // iNarc pods don&#39;t have a position, so lets scrap this idea, shall
&nbsp;            // we?
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (attack instanceof WeaponAttackAction) {</b>
<b class="nc">&nbsp;            WeaponAttackAction waa = (WeaponAttackAction) attack;</b>
<b class="nc">&nbsp;            if ((attack.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)</b>
<b class="nc">&nbsp;                    &amp;&amp; (waa.getEntity(m_game).getOwner().getId() != m_client</b>
<b class="nc">&nbsp;                            .getLocalPlayer().getId())) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Color oldColor = g.getColor();</b>
&nbsp;
<b class="nc">&nbsp;        int[] xPoints = new int[4];</b>
<b class="nc">&nbsp;        int[] yPoints = new int[4];</b>
&nbsp;
<b class="nc">&nbsp;        xPoints[0] = ((source.getPosition().getX() * (hexSide[zoom] + hexSideBySin30[zoom]))</b>
&nbsp;                + leftMargin + ((int) 1.5 * hexSide[zoom])) - 2;
<b class="nc">&nbsp;        yPoints[0] = (((2 * source.getPosition().getY()) + 1 + (source</b>
<b class="nc">&nbsp;                .getPosition().getX() % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
<b class="nc">&nbsp;        xPoints[1] = ((target.getPosition().getX() * (hexSide[zoom] + hexSideBySin30[zoom]))</b>
&nbsp;                + leftMargin + ((int) 1.5 * hexSide[zoom])) - 2;
<b class="nc">&nbsp;        yPoints[1] = (((2 * target.getPosition().getY()) + 1 + (target</b>
<b class="nc">&nbsp;                .getPosition().getX() % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
<b class="nc">&nbsp;        xPoints[2] = xPoints[1] + 2;</b>
<b class="nc">&nbsp;        xPoints[3] = xPoints[0] + 2;</b>
<b class="nc">&nbsp;        if (((source.getPosition().getX() &gt; target.getPosition().getX()) &amp;&amp; (source</b>
<b class="nc">&nbsp;                .getPosition().getY() &lt; target.getPosition().getY()))</b>
<b class="nc">&nbsp;                || ((source.getPosition().getX() &lt; target.getPosition().getX()) &amp;&amp; (source</b>
<b class="nc">&nbsp;                        .getPosition().getY() &gt; target.getPosition().getY()))) {</b>
<b class="nc">&nbsp;            yPoints[3] = yPoints[0] + 2;</b>
<b class="nc">&nbsp;            yPoints[2] = yPoints[1] + 2;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            yPoints[3] = yPoints[0] - 2;</b>
<b class="nc">&nbsp;            yPoints[2] = yPoints[1] - 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        g.setColor(source.getOwner().getColour().getColour());</b>
<b class="nc">&nbsp;        g.fillPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;        g.setColor(Color.black);</b>
<b class="nc">&nbsp;        g.drawPolygon(xPoints, yPoints, 4);</b>
&nbsp;
&nbsp;        // if this is mutual fire, draw a half-and-half line
<b class="nc">&nbsp;        for (Enumeration&lt;EntityAction&gt; iter = m_game.getActions(); iter</b>
<b class="nc">&nbsp;                .hasMoreElements();) {</b>
<b class="nc">&nbsp;            EntityAction action = iter.nextElement();</b>
<b class="nc">&nbsp;            if (action instanceof AttackAction) {</b>
<b class="nc">&nbsp;                AttackAction otherAttack = (AttackAction) action;</b>
<b class="nc">&nbsp;                if ((attack.getEntityId() == otherAttack.getTargetId())</b>
<b class="nc">&nbsp;                        &amp;&amp; (otherAttack.getEntityId() == attack.getTargetId())) {</b>
&nbsp;                    // attackTarget _must_ be an entity since it&#39;s shooting back
&nbsp;                    // (?)
<b class="nc">&nbsp;                    Entity attackTarget = m_game.getEntity(otherAttack.getEntityId());</b>
<b class="nc">&nbsp;                    g.setColor(attackTarget.getOwner().getColour().getColour());</b>
&nbsp;
<b class="nc">&nbsp;                    xPoints[0] = xPoints[3];</b>
<b class="nc">&nbsp;                    yPoints[0] = yPoints[3];</b>
<b class="nc">&nbsp;                    xPoints[1] = xPoints[2];</b>
<b class="nc">&nbsp;                    yPoints[1] = yPoints[2];</b>
<b class="nc">&nbsp;                    xPoints[2] = xPoints[1] + 2;</b>
<b class="nc">&nbsp;                    xPoints[3] = xPoints[0] + 2;</b>
<b class="nc">&nbsp;                    if (((source.getPosition().getX() &gt; target.getPosition()</b>
<b class="nc">&nbsp;                            .getX()) &amp;&amp; (source.getPosition().getY() &lt; target</b>
<b class="nc">&nbsp;                            .getPosition().getY()))</b>
<b class="nc">&nbsp;                            || ((source.getPosition().getX() &lt; target</b>
<b class="nc">&nbsp;                                    .getPosition().getX()) &amp;&amp; (source</b>
<b class="nc">&nbsp;                                    .getPosition().getY() &gt; target</b>
<b class="nc">&nbsp;                                    .getPosition().getY()))) {</b>
<b class="nc">&nbsp;                        yPoints[3] = yPoints[0] + 2;</b>
<b class="nc">&nbsp;                        yPoints[2] = yPoints[1] + 2;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        yPoints[3] = yPoints[0] - 2;</b>
<b class="nc">&nbsp;                        yPoints[2] = yPoints[1] - 2;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    g.fillPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                    g.setColor(Color.black);</b>
<b class="nc">&nbsp;                    g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        g.setColor(oldColor);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void paintUnit(Graphics g, Entity entity) {
<b class="nc">&nbsp;        int baseX = (entity.getPosition().getX() * (hexSide[zoom] + hexSideBySin30[zoom]))</b>
&nbsp;                + leftMargin + hexSide[zoom];
<b class="nc">&nbsp;        int baseY = (((2 * entity.getPosition().getY()) + 1 + (entity</b>
<b class="nc">&nbsp;                .getPosition().getX() % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
&nbsp;        int[] xPoints;
&nbsp;        int[] yPoints;
&nbsp;
<b class="nc">&nbsp;        if (EntityVisibilityUtils.onlyDetectedBySensors(m_bview.getLocalPlayer(), entity)) { // Sensor Return</b>
<b class="nc">&nbsp;            String sensorReturn = &quot;?&quot;;           </b>
<b class="nc">&nbsp;            Font font = new Font(&quot;SansSerif&quot;, Font.BOLD, fontSize[zoom]); //$NON-NLS-1$            </b>
<b class="nc">&nbsp;            int width = getFontMetrics(font).stringWidth(sensorReturn) / 2;</b>
<b class="nc">&nbsp;            int height = getFontMetrics(font).getHeight() / 2 - 2;</b>
<b class="nc">&nbsp;            g.setFont(font);</b>
<b class="nc">&nbsp;            g.setColor(Color.RED);</b>
<b class="nc">&nbsp;            g.drawString(sensorReturn, baseX - width, baseY + height);</b>
&nbsp;            return;
<b class="nc">&nbsp;        } else if (!EntityVisibilityUtils.detectedOrHasVisual(m_bview.getLocalPlayer(), m_game, entity)) { // Unseen Unit</b>
&nbsp;            // Do nothing
&nbsp;            return;
<b class="nc">&nbsp;        } else if (entity instanceof Mech) {</b>
<b class="nc">&nbsp;            xPoints = new int[3];</b>
<b class="nc">&nbsp;            yPoints = new int[3];</b>
<b class="nc">&nbsp;            xPoints[0] = baseX;</b>
<b class="nc">&nbsp;            yPoints[0] = baseY - unitSize;</b>
<b class="nc">&nbsp;            xPoints[1] = baseX - unitSize;</b>
<b class="nc">&nbsp;            yPoints[1] = baseY + (unitSize / 2);</b>
<b class="nc">&nbsp;            xPoints[2] = baseX + unitSize;</b>
<b class="nc">&nbsp;            yPoints[2] = baseY + (unitSize / 2);</b>
<b class="nc">&nbsp;        } else if (entity instanceof VTOL) {</b>
<b class="nc">&nbsp;            xPoints = new int[8];</b>
<b class="nc">&nbsp;            yPoints = new int[8];</b>
<b class="nc">&nbsp;            xPoints[0] = baseX - unitSize;</b>
<b class="nc">&nbsp;            xPoints[1] = baseX - (unitSize / 3);</b>
<b class="nc">&nbsp;            xPoints[2] = baseX;</b>
<b class="nc">&nbsp;            xPoints[3] = baseX + (unitSize / 3);</b>
<b class="nc">&nbsp;            xPoints[4] = baseX + unitSize;</b>
<b class="nc">&nbsp;            xPoints[5] = xPoints[3];</b>
<b class="nc">&nbsp;            xPoints[6] = xPoints[2];</b>
<b class="nc">&nbsp;            xPoints[7] = xPoints[1];</b>
<b class="nc">&nbsp;            yPoints[0] = baseY;</b>
<b class="nc">&nbsp;            yPoints[1] = baseY - (unitSize / 3);</b>
<b class="nc">&nbsp;            yPoints[2] = baseY - unitSize;</b>
<b class="nc">&nbsp;            yPoints[3] = baseY - (unitSize / 3);</b>
<b class="nc">&nbsp;            yPoints[4] = baseY;</b>
<b class="nc">&nbsp;            yPoints[5] = baseY + (unitSize / 3);</b>
<b class="nc">&nbsp;            yPoints[6] = baseY + unitSize;</b>
<b class="nc">&nbsp;            yPoints[7] = baseY + (unitSize / 3);</b>
<b class="nc">&nbsp;        } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;            xPoints = new int[4];</b>
<b class="nc">&nbsp;            yPoints = new int[4];</b>
<b class="nc">&nbsp;            xPoints[0] = baseX - ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            yPoints[0] = baseY - ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            xPoints[1] = baseX - ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            yPoints[1] = baseY + ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            xPoints[2] = baseX + ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            yPoints[2] = baseY + ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            xPoints[3] = baseX + ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;            yPoints[3] = baseY - ((unitSize * 2) / 3);</b>
<b class="nc">&nbsp;        } else if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;            xPoints = new int[3];</b>
<b class="nc">&nbsp;            yPoints = new int[3];</b>
<b class="nc">&nbsp;            xPoints[0] = baseX;</b>
<b class="nc">&nbsp;            yPoints[0] = baseY + unitSize;</b>
<b class="nc">&nbsp;            xPoints[1] = baseX + unitSize;</b>
<b class="nc">&nbsp;            yPoints[1] = baseY - (unitSize / 2);</b>
<b class="nc">&nbsp;            xPoints[2] = baseX - unitSize;</b>
<b class="nc">&nbsp;            yPoints[2] = baseY - (unitSize / 2);</b>
<b class="nc">&nbsp;        } else if (entity instanceof GunEmplacement) {</b>
<b class="nc">&nbsp;            int twip = (unitSize * 2) / 3;</b>
<b class="nc">&nbsp;            xPoints = new int[8];</b>
<b class="nc">&nbsp;            yPoints = new int[8];</b>
<b class="nc">&nbsp;            xPoints[0] = baseX - (twip / 2);</b>
<b class="nc">&nbsp;            yPoints[0] = baseY - ((twip * 3) / 2);</b>
<b class="nc">&nbsp;            xPoints[1] = xPoints[0] - twip;</b>
<b class="nc">&nbsp;            yPoints[1] = yPoints[0] + twip;</b>
<b class="nc">&nbsp;            xPoints[2] = xPoints[1];</b>
<b class="nc">&nbsp;            yPoints[2] = yPoints[1] + twip;</b>
<b class="nc">&nbsp;            xPoints[3] = xPoints[2] + twip;</b>
<b class="nc">&nbsp;            yPoints[3] = yPoints[2] + twip;</b>
<b class="nc">&nbsp;            xPoints[4] = xPoints[3] + twip;</b>
<b class="nc">&nbsp;            yPoints[4] = yPoints[3];</b>
<b class="nc">&nbsp;            xPoints[5] = xPoints[4] + twip;</b>
<b class="nc">&nbsp;            yPoints[5] = yPoints[4] - twip;</b>
<b class="nc">&nbsp;            xPoints[6] = xPoints[5];</b>
<b class="nc">&nbsp;            yPoints[6] = yPoints[5] - twip;</b>
<b class="nc">&nbsp;            xPoints[7] = xPoints[6] - twip;</b>
<b class="nc">&nbsp;            yPoints[7] = yPoints[6] - twip;</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // entity instanceof Infantry
<b class="nc">&nbsp;            xPoints = new int[4];</b>
<b class="nc">&nbsp;            yPoints = new int[4];</b>
<b class="nc">&nbsp;            xPoints[0] = baseX;</b>
<b class="nc">&nbsp;            yPoints[0] = baseY - unitSize;</b>
<b class="nc">&nbsp;            xPoints[1] = baseX - unitSize;</b>
<b class="nc">&nbsp;            yPoints[1] = baseY;</b>
<b class="nc">&nbsp;            xPoints[2] = baseX;</b>
<b class="nc">&nbsp;            yPoints[2] = baseY + unitSize;</b>
<b class="nc">&nbsp;            xPoints[3] = baseX + unitSize;</b>
<b class="nc">&nbsp;            yPoints[3] = baseY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Graphics2D g2 = (Graphics2D)g;</b>
<b class="nc">&nbsp;        Stroke svStroke = g2.getStroke();</b>
&nbsp;
&nbsp;        // Choose player or team color depending on preferences
<b class="nc">&nbsp;        Color iconColor = entity.getOwner().getColour().getColour(false);</b>
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getTeamColoring() &amp;&amp; (m_client != null)) {</b>
<b class="nc">&nbsp;            boolean isLocalTeam = entity.getOwner().getTeam() == m_client.getLocalPlayer().getTeam();</b>
<b class="nc">&nbsp;            boolean isLocalPlayer = entity.getOwner().equals(m_client.getLocalPlayer());</b>
<b class="nc">&nbsp;            if (isLocalPlayer) {</b>
<b class="nc">&nbsp;                iconColor = GUIPreferences.getInstance().getMyUnitColor();</b>
<b class="nc">&nbsp;            } else if (isLocalTeam) {</b>
<b class="nc">&nbsp;                iconColor = GUIPreferences.getInstance().getAllyUnitColor();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                iconColor = GUIPreferences.getInstance().getEnemyUnitColor();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (GUIPreferences.getInstance().getBoolean(GUIPreferences.MMSYMBOL)) {</b>
<b class="nc">&nbsp;            AffineTransform svTransform = g2.getTransform();</b>
&nbsp;
&nbsp;            // Transform for placement and scaling
<b class="nc">&nbsp;            AffineTransform t = AffineTransform.getTranslateInstance(baseX, baseY);</b>
<b class="nc">&nbsp;            t.scale(stratZoom[zoom]/100.0d, fontSize[zoom]/100.0d);</b>
<b class="nc">&nbsp;            g2.transform(t);</b>
&nbsp;
&nbsp;            // Add a position shift if multiple units are present in this hex
<b class="nc">&nbsp;            Coords p = entity.getPosition();</b>
<b class="nc">&nbsp;            Integer eStack = multiUnits.get(p);</b>
<b class="nc">&nbsp;            if (eStack == null) eStack = 0;</b>
<b class="nc">&nbsp;            eStack++;</b>
<b class="nc">&nbsp;            multiUnits.put(p, eStack);</b>
<b class="nc">&nbsp;            g2.translate(20*(eStack-1), -20*(eStack-1));</b>
&nbsp;
&nbsp;            // White border to set off the icon from the background
<b class="nc">&nbsp;            g2.setStroke(new BasicStroke(30f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_BEVEL));</b>
<b class="nc">&nbsp;            g2.setColor(new Color(255,255,255,150));</b>
<b class="nc">&nbsp;            g2.draw(STRAT_BASERECT);</b>
&nbsp;
&nbsp;            // Black background to fill forms like the Dropship
<b class="nc">&nbsp;            g2.setColor(Color.BLACK);</b>
<b class="nc">&nbsp;            g2.fill(STRAT_BASERECT);</b>
&nbsp;
&nbsp;            // Rectangle border for all units
<b class="nc">&nbsp;            g2.setStroke(new BasicStroke(8f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));</b>
<b class="nc">&nbsp;            g2.draw(STRAT_BASERECT);</b>
&nbsp;
&nbsp;            // Select the correct form for the entity
&nbsp;            Path2D form;
<b class="nc">&nbsp;            if ((entity instanceof Mech) || (entity instanceof Protomech)) {</b>
<b class="nc">&nbsp;                form = STRAT_MECH;</b>
<b class="nc">&nbsp;                g2.setStroke(new BasicStroke(1f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));</b>
<b class="nc">&nbsp;            } else if (entity instanceof VTOL) {</b>
<b class="nc">&nbsp;                form = STRAT_VTOL;</b>
<b class="nc">&nbsp;                g2.setStroke(new BasicStroke(1f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));</b>
<b class="nc">&nbsp;            } else if (entity instanceof Tank) {</b>
<b class="nc">&nbsp;                if (entity.getMovementMode() == EntityMovementMode.HOVER) {</b>
<b class="nc">&nbsp;                    form = STRAT_HOVER;</b>
<b class="nc">&nbsp;                } else if (entity.getMovementMode() == EntityMovementMode.WHEELED) {</b>
<b class="nc">&nbsp;                    form = STRAT_WHEELED;</b>
<b class="nc">&nbsp;                } else if ((entity.getMovementMode() == EntityMovementMode.HYDROFOIL) ||</b>
<b class="nc">&nbsp;                        (entity.getMovementMode() == EntityMovementMode.NAVAL)) {</b>
<b class="nc">&nbsp;                    form = STRAT_NAVAL; </b>
&nbsp;                } else {
<b class="nc">&nbsp;                    form = STRAT_TANKTRACKED;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity.isAero()) {</b>
<b class="nc">&nbsp;                if (entity.isFighter()) {</b>
<b class="nc">&nbsp;                    form = STRAT_AERO;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    form = STRAT_SPHEROID;</b>
&nbsp;                }
<b class="nc">&nbsp;                g2.setStroke(new BasicStroke(1f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                form = STRAT_INFANTRY;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Fill the form in player color / team color
<b class="nc">&nbsp;            g.setColor(iconColor);</b>
<b class="nc">&nbsp;            g2.fill(form);</b>
&nbsp;
&nbsp;            // Add the weight class or other lettering for certain units
<b class="nc">&nbsp;            g.setColor(Color.BLACK);</b>
<b class="nc">&nbsp;            if ((entity instanceof Protomech) || (entity instanceof Mech) || (entity instanceof Aero)) {</b>
<b class="nc">&nbsp;                String s = &quot;&quot;;</b>
<b class="nc">&nbsp;                if (entity instanceof Protomech) {</b>
<b class="nc">&nbsp;                    s = &quot;P&quot;;</b>
<b class="nc">&nbsp;                } else if ((entity instanceof Mech) &amp;&amp; ((Mech)entity).isIndustrial()) {</b>
<b class="nc">&nbsp;                    s = &quot;I&quot;;</b>
<b class="nc">&nbsp;                } else if (entity.getWeightClass() &lt; 6) {</b>
<b class="nc">&nbsp;                    s = STRAT_WEIGHTS[entity.getWeightClass()];</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!s.equals(&quot;&quot;)) {</b>
<b class="nc">&nbsp;                    FontRenderContext fontContext = new FontRenderContext(null, true, true);</b>
<b class="nc">&nbsp;                    Font font = new Font(&quot;SansSerif&quot;, Font.BOLD, 100);</b>
<b class="nc">&nbsp;                    FontMetrics currentMetrics = getFontMetrics(font);</b>
<b class="nc">&nbsp;                    int stringWidth = currentMetrics.stringWidth(s);</b>
<b class="nc">&nbsp;                    GlyphVector gv = font.createGlyphVector(fontContext, s);</b>
<b class="nc">&nbsp;                    g2.fill(gv.getOutline((int)STRAT_CX-stringWidth/2,(float)SYMBOLSIZE.getHeight()/3.0f));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (entity instanceof MechWarrior) {</b>
<b class="nc">&nbsp;                g2.setColor(Color.black);</b>
<b class="nc">&nbsp;                g2.fillOval(0 - 25, 0 - 25, 50, 50);</b>
&nbsp;            }
&nbsp;            // Draw the unit icon in black
<b class="nc">&nbsp;            g2.draw(form);</b>
&nbsp;
<b class="nc">&nbsp;            g2.setTransform(svTransform);</b>
&nbsp;            
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // Drawn a circle for MechWarriors
<b class="nc">&nbsp;            if (entity instanceof MechWarrior) {</b>
&nbsp;                // Draw a slight dark border
<b class="nc">&nbsp;                int radius = unitSize - 3;</b>
<b class="nc">&nbsp;                int dia = radius * 2;</b>
<b class="nc">&nbsp;                ((Graphics2D)g).setStroke(new BasicStroke(unitBorder[zoom]+2));</b>
<b class="nc">&nbsp;                g.setColor(new Color(100,100,100,200));</b>
<b class="nc">&nbsp;                g.drawOval(baseX - radius, baseY - radius, dia, dia);</b>
&nbsp;
&nbsp;                // Fill the form in player color / team color
<b class="nc">&nbsp;                g.setColor(iconColor);</b>
<b class="nc">&nbsp;                g.fillOval(baseX - radius, baseY - radius, dia, dia);</b>
&nbsp;
&nbsp;                // Draw a white border to better show the player color
<b class="nc">&nbsp;                ((Graphics2D)g).setStroke(new BasicStroke(unitBorder[zoom]));</b>
<b class="nc">&nbsp;                g.setColor(Color.WHITE);</b>
<b class="nc">&nbsp;                g.drawOval(baseX - radius, baseY - radius, dia, dia);</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                // Draw a slight dark border to set off the icon from the background
<b class="nc">&nbsp;                ((Graphics2D)g).setStroke(new BasicStroke(unitBorder[zoom]+2));</b>
<b class="nc">&nbsp;                g.setColor(new Color(100,100,100,200));</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, xPoints.length);</b>
&nbsp;
&nbsp;                // Fill the form in player color / team color
<b class="nc">&nbsp;                g.setColor(iconColor);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, xPoints.length);</b>
&nbsp;
&nbsp;                // Draw a white border to better show the player color
&nbsp;                // maybe useful later: if (!entity.isSelectableThisTurn()) {
<b class="nc">&nbsp;                ((Graphics2D)g).setStroke(new BasicStroke(unitBorder[zoom]));</b>
<b class="nc">&nbsp;                g.setColor(Color.WHITE);</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, xPoints.length);</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;        
&nbsp;        // Create a colored circle if this is the selected unit
<b class="nc">&nbsp;        Entity se = (clientgui == null) ? null : </b>
<b class="nc">&nbsp;            m_game.getEntity(clientgui.getSelectedEntityNum());</b>
&nbsp;        
<b class="nc">&nbsp;        if (entity == se) {</b>
<b class="nc">&nbsp;            g2.setStroke(new BasicStroke(unitBorder[zoom]+1));</b>
<b class="nc">&nbsp;            g2.setColor(GUIPreferences.getInstance().getColor(</b>
&nbsp;                    GUIPreferences.ADVANCED_UNITOVERVIEW_SELECTED_COLOR));
<b class="nc">&nbsp;            int rad = unitSize*2-1;</b>
<b class="nc">&nbsp;            g2.drawOval(baseX-rad, baseY-rad, rad*2, rad*2);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        g2.setStroke(svStroke);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void paintRoads(Graphics g) {
<b class="nc">&nbsp;        int exits = 0;</b>
&nbsp;        int baseX, baseY, x, y;
<b class="nc">&nbsp;        int[] xPoints = new int[4];</b>
<b class="nc">&nbsp;        int[] yPoints = new int[4];</b>
<b class="nc">&nbsp;        Color oldColor = g.getColor();</b>
<b class="nc">&nbsp;        g.setColor(m_terrainColors[Terrains.ROAD]);</b>
<b class="nc">&nbsp;        for (Enumeration&lt;int[]&gt; iter = roadHexIndexes.elements(); iter</b>
<b class="nc">&nbsp;                .hasMoreElements(); ) {</b>
<b class="nc">&nbsp;            int[] hex = iter.nextElement();</b>
<b class="nc">&nbsp;            x = hex[0];</b>
<b class="nc">&nbsp;            y = hex[1];</b>
<b class="nc">&nbsp;            baseX = (x * (hexSide[zoom] + hexSideBySin30[zoom])) + leftMargin</b>
&nbsp;                    + hexSide[zoom];
<b class="nc">&nbsp;            baseY = (((2 * y) + 1 + (x % 2)) * hexSideByCos30[zoom]) + topMargin;</b>
<b class="nc">&nbsp;            exits = hex[2];</b>
&nbsp;            // Is there a North exit?
<b class="nc">&nbsp;            if (0 != (exits &amp; 0x0001)) {</b>
<b class="nc">&nbsp;                xPoints[0] = baseX - halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[0] = baseY;</b>
<b class="nc">&nbsp;                xPoints[1] = baseX - halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[1] = baseY - hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[2] = baseX + halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[2] = baseY - hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[3] = baseX + halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[3] = baseY;</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, 4);</b>
&nbsp;            }
&nbsp;            // Is there a North-East exit?
<b class="nc">&nbsp;            if (0 != (exits &amp; 0x0002)) {</b>
<b class="nc">&nbsp;                xPoints[0] = baseX - halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[0] = baseY - halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[1] = Math.round((baseX + ((3 * hexSide[zoom]) / 4))</b>
&nbsp;                                        - halfRoadWidthBySin30[zoom]);
<b class="nc">&nbsp;                yPoints[1] = Math.round(baseY - (hexSideByCos30[zoom] / 2)</b>
&nbsp;                                        - halfRoadWidthByCos30[zoom]);
<b class="nc">&nbsp;                xPoints[2] = xPoints[1] + (2 * halfRoadWidthBySin30[zoom]);</b>
<b class="nc">&nbsp;                yPoints[2] = yPoints[1] + (2 * halfRoadWidthByCos30[zoom]);</b>
<b class="nc">&nbsp;                xPoints[3] = baseX + halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[3] = baseY + halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, 4);</b>
&nbsp;            }
&nbsp;            // Is there a South-East exit?
<b class="nc">&nbsp;            if (0 != (exits &amp; 0x0004)) {</b>
<b class="nc">&nbsp;                xPoints[0] = baseX + halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[0] = baseY - halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[1] = Math.round(baseX + ((3 * hexSide[zoom]) / 4)</b>
&nbsp;                                        + halfRoadWidthBySin30[zoom]);
<b class="nc">&nbsp;                yPoints[1] = Math.round((baseY + (hexSideByCos30[zoom] / 2))</b>
&nbsp;                                        - halfRoadWidthByCos30[zoom]);
<b class="nc">&nbsp;                xPoints[2] = xPoints[1] - (2 * halfRoadWidthBySin30[zoom]);</b>
<b class="nc">&nbsp;                yPoints[2] = yPoints[1] + (2 * halfRoadWidthByCos30[zoom]);</b>
<b class="nc">&nbsp;                xPoints[3] = baseX - halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[3] = baseY + halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, 4);</b>
&nbsp;            }
&nbsp;            // Is there a South exit?
<b class="nc">&nbsp;            if (0 != (exits &amp; 0x0008)) {</b>
<b class="nc">&nbsp;                xPoints[0] = baseX + halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[0] = baseY;</b>
<b class="nc">&nbsp;                xPoints[1] = baseX + halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[1] = baseY + hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[2] = baseX - halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[2] = baseY + hexSideByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[3] = baseX - halfRoadWidth[zoom];</b>
<b class="nc">&nbsp;                yPoints[3] = baseY;</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, 4);</b>
&nbsp;            }
&nbsp;            // Is there a South-West exit?
<b class="nc">&nbsp;            if (0 != (exits &amp; 0x0010)) {</b>
<b class="nc">&nbsp;                xPoints[0] = baseX + halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[0] = baseY + halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[1] = Math.round((baseX - ((3 * hexSide[zoom]) / 4))</b>
&nbsp;                                        + halfRoadWidthBySin30[zoom]);
<b class="nc">&nbsp;                yPoints[1] = Math.round(baseY + (hexSideByCos30[zoom] / 2)</b>
&nbsp;                                        + halfRoadWidthByCos30[zoom]);
<b class="nc">&nbsp;                xPoints[2] = xPoints[1] - (2 * halfRoadWidthBySin30[zoom]);</b>
<b class="nc">&nbsp;                yPoints[2] = yPoints[1] - (2 * halfRoadWidthByCos30[zoom]);</b>
<b class="nc">&nbsp;                xPoints[3] = baseX - halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[3] = baseY - halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, 4);</b>
&nbsp;            }
&nbsp;            // Is there a North-West exit?
<b class="nc">&nbsp;            if (0 != (exits &amp; 0x0020)) {</b>
<b class="nc">&nbsp;                xPoints[0] = baseX - halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[0] = baseY + halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                xPoints[1] = Math.round(baseX - ((3 * hexSide[zoom]) / 4)</b>
&nbsp;                                        - halfRoadWidthBySin30[zoom]);
<b class="nc">&nbsp;                yPoints[1] = Math.round((baseY - (hexSideByCos30[zoom] / 2))</b>
&nbsp;                                        + halfRoadWidthByCos30[zoom]);
<b class="nc">&nbsp;                xPoints[2] = xPoints[1] + (2 * halfRoadWidthBySin30[zoom]);</b>
<b class="nc">&nbsp;                yPoints[2] = yPoints[1] - (2 * halfRoadWidthByCos30[zoom]);</b>
<b class="nc">&nbsp;                xPoints[3] = baseX + halfRoadWidthBySin30[zoom];</b>
<b class="nc">&nbsp;                yPoints[3] = baseY - halfRoadWidthByCos30[zoom];</b>
<b class="nc">&nbsp;                g.drawPolygon(xPoints, yPoints, 4);</b>
<b class="nc">&nbsp;                g.fillPolygon(xPoints, yPoints, 4);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        g.setColor(oldColor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * check if hex contains roadelements and if it does, add to roadHexIndexes
&nbsp;     */
&nbsp;    private void addRoadElements(IHex x, int boardX, int boardY) {
<b class="nc">&nbsp;        final int[] roadTypes = new int[]{Terrains.ROAD, Terrains.BRIDGE};</b>
<b class="nc">&nbsp;        for (int j : roadTypes) {</b>
<b class="nc">&nbsp;            if ((x.getTerrain(j) != null) &amp;&amp; (m_terrainColors[j] != null)) {</b>
<b class="nc">&nbsp;                int[] roadHex = {boardX, boardY, x.getTerrain(j).getExits()};</b>
<b class="nc">&nbsp;                roadHexIndexes.addElement(roadHex);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Color terrainColor(IHex x, int boardX, int boardY) {
<b class="nc">&nbsp;        Color terrColor = m_terrainColors[0];</b>
<b class="nc">&nbsp;        if (x.getLevel() &lt; 0) {</b>
&nbsp;            // sinkholes have their own colour
<b class="nc">&nbsp;            terrColor = SINKHOLE;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int terrain = 0;</b>
&nbsp;        // Check for Smoke and Fire - this overrides any other colors
<b class="nc">&nbsp;        if (x.containsTerrain(Terrains.SMOKE) &amp;&amp; x.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            terrColor = SMOKE_AND_FIRE;</b>
&nbsp;        // Check for Fire - this overrides any other colors
<b class="nc">&nbsp;        } else if (x.containsTerrain(Terrains.FIRE)) {</b>
<b class="nc">&nbsp;            terrColor = m_terrainColors[Terrains.FIRE];</b>
&nbsp;        } else { // Otherwise, color based on terrains - higher valued terrains take color precedence
<b class="nc">&nbsp;            for (int j = m_terrainColors.length - 1; j &gt;= 0; j--) {</b>
<b class="nc">&nbsp;                if ((x.getTerrain(j) != null) &amp;&amp; (m_terrainColors[j] != null)) {</b>
<b class="nc">&nbsp;                    if ((j == Terrains.ROAD) || (j == Terrains.BRIDGE)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    terrColor = m_terrainColors[j];</b>
<b class="nc">&nbsp;                    terrain = j;</b>
&nbsp;                    // make heavy woods darker
<b class="nc">&nbsp;                    if (((j == Terrains.WOODS) || (j == Terrains.JUNGLE)) &amp;&amp; (x.getTerrain(j).getLevel() == 2)) {</b>
<b class="nc">&nbsp;                        terrColor = HEAVY_WOODS;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (((j == Terrains.WOODS) || (j == Terrains.JUNGLE)) &amp;&amp; (x.getTerrain(j).getLevel() &gt; 2)) {</b>
<b class="nc">&nbsp;                        terrColor = ULTRA_HEAVY_WOODS;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        int level = 0;</b>
&nbsp;
&nbsp;        int r, g, b;
<b class="nc">&nbsp;        switch (terrain) {</b>
&nbsp;            case 0:
&nbsp;            case Terrains.WOODS:
&nbsp;            case Terrains.JUNGLE:
&nbsp;            case Terrains.ROUGH:
&nbsp;            case Terrains.RUBBLE:
&nbsp;            case Terrains.WATER:
&nbsp;            case Terrains.PAVEMENT:
&nbsp;            case Terrains.ICE:
&nbsp;            case Terrains.FIELDS:
<b class="nc">&nbsp;                level = Math.abs(x.floor());</b>
&nbsp;                // By experiment it is possible to make only 6 distinctive color
&nbsp;                // steps
<b class="nc">&nbsp;                if (level &gt; 10) {</b>
<b class="nc">&nbsp;                    level = 10;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = terrColor.getRed() - (level * 15);</b>
<b class="nc">&nbsp;                g = terrColor.getGreen() - (level * 15);</b>
<b class="nc">&nbsp;                b = terrColor.getBlue() - (level * 15);</b>
<b class="nc">&nbsp;                if (r &lt; 0) {</b>
<b class="nc">&nbsp;                    r = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (g &lt; 0) {</b>
<b class="nc">&nbsp;                    g = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (b &lt; 0) {</b>
<b class="nc">&nbsp;                    b = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                return new Color(r, g, b);</b>
&nbsp;            case Terrains.FUEL_TANK:
&nbsp;            case Terrains.BUILDING:
<b class="nc">&nbsp;                level = Math.abs(x.ceiling());</b>
&nbsp;                // By experiment it is possible to make only 6 distinctive color
&nbsp;                // steps
<b class="nc">&nbsp;                if (level &gt; 10) {</b>
<b class="nc">&nbsp;                    level = 10;</b>
&nbsp;                }
<b class="nc">&nbsp;                r = terrColor.getRed() - (level * 15);</b>
<b class="nc">&nbsp;                g = terrColor.getGreen() - (level * 15);</b>
<b class="nc">&nbsp;                b = terrColor.getBlue() - (level * 15);</b>
<b class="nc">&nbsp;                if (r &lt; 0) {</b>
<b class="nc">&nbsp;                    r = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (g &lt; 0) {</b>
<b class="nc">&nbsp;                    g = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (b &lt; 0) {</b>
<b class="nc">&nbsp;                    b = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                return new Color(r, g, b);</b>
&nbsp;
&nbsp;        }
&nbsp;        /*
&nbsp;         * if (terrain &lt; 5){ level = (int) Math.abs(x.floor()); // By experiment
&nbsp;         * it is possible to make only 6 distinctive color steps if (level &gt; 5)
&nbsp;         * level = 5; int r = terrColor.getRed()-level30; int g =
&nbsp;         * terrColor.getGreen()-level30; int b = terrColor.getBlue()-level30; if
&nbsp;         * (r &lt; 0) r = 0; if (g &lt; 0) g = 0; if (b &lt; 0) b = 0; return new
&nbsp;         * Color(r, g, b); }
&nbsp;         */
<b class="nc">&nbsp;        return terrColor;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Coords translateCoords(int x, int y) {
<b class="nc">&nbsp;        int gridX = (x / (hexSideBySin30[zoom] + hexSide[zoom]));</b>
<b class="nc">&nbsp;        int restX = x % (hexSideBySin30[zoom] + hexSide[zoom]);</b>
<b class="nc">&nbsp;        int gridY = (y / (2 * hexSideByCos30[zoom]));</b>
<b class="nc">&nbsp;        int restY = y % (2 * hexSideByCos30[zoom]);</b>
&nbsp;
<b class="nc">&nbsp;        boolean evenColumn = (gridX &amp; 1) == 0;</b>
&nbsp;
<b class="nc">&nbsp;        if (restY &lt; hexSideByCos30[zoom]) {</b>
<b class="nc">&nbsp;            if (evenColumn) {</b>
<b class="nc">&nbsp;                if (restX &lt; ((((restY - hexSideByCos30[zoom])</b>
&nbsp;                               * hexSideBySin30[zoom]) / hexSideByCos30[zoom]) * -1)) {
<b class="nc">&nbsp;                    gridX--;</b>
<b class="nc">&nbsp;                    gridY--;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (restX &lt; ((restY * hexSideBySin30[zoom]) / hexSideByCos30[zoom])) {</b>
<b class="nc">&nbsp;                    gridX--;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    gridY--;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            if (evenColumn) {</b>
<b class="nc">&nbsp;                if (restX &lt; (((restY - hexSideByCos30[zoom])</b>
&nbsp;                              * hexSideBySin30[zoom]) / hexSideByCos30[zoom])) {
<b class="nc">&nbsp;                    gridX--;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (restX &lt; ((((restY - (2 * hexSideByCos30[zoom]))</b>
&nbsp;                               * hexSideBySin30[zoom]) / hexSideByCos30[zoom]) * -1)) {
<b class="nc">&nbsp;                    gridX--;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        /*
&nbsp;         * restX = hexSideBySin30[zoom] + hexSide[zoom] - restX; restY -=
&nbsp;         * hexSideByCos30[zoom]; if (hexSideBySin30[zoom]restX &gt;
&nbsp;         * hexSideByCos30[zoom]restY) gridX ++; if (-hexSideBySin30[zoom]restX &gt;
&nbsp;         * hexSideByCos30[zoom]restY) gridY --;
&nbsp;         */
<b class="nc">&nbsp;        if (gridX &lt; 0) {</b>
<b class="nc">&nbsp;            gridX = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (gridY &lt; 0) {</b>
<b class="nc">&nbsp;            gridY = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new Coords(gridX, gridY);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void zoomIn() {
<b class="nc">&nbsp;        if (zoom == 0) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        zoom--;</b>
<b class="nc">&nbsp;        initializeMap();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void zoomOut() {
<b class="nc">&nbsp;        if (zoom == (hexSide.length - 1)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        zoom++;</b>
<b class="nc">&nbsp;        initializeMap();</b>
&nbsp;    }
&nbsp;
&nbsp;    void processMouseClick(int x, int y, MouseEvent me) {
<b class="nc">&nbsp;        if (y &gt; (getSize().height - 14) &amp;&amp; !dragging) {</b>
<b class="nc">&nbsp;            if (minimized) {</b>
<b class="nc">&nbsp;                setSize(getSize().width, heightBufer);</b>
<b class="nc">&nbsp;                m_mapImage =  ImageUtil.createAcceleratedImage(getSize().width, heightBufer);</b>
<b class="nc">&nbsp;                minimized = false;</b>
<b class="nc">&nbsp;                initializeMap();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (x &lt; 14) {</b>
<b class="nc">&nbsp;                    if (GUIPreferences.getInstance().getMouseWheelZoomFlip()) {</b>
<b class="nc">&nbsp;                        zoomIn();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        zoomOut();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if ((x &lt; 28) &amp;&amp; (zoom &gt; 2)) {</b>
<b class="nc">&nbsp;                    heightDisplayMode = ((++heightDisplayMode) &gt; NBR_MODES) ? 0 : heightDisplayMode;</b>
<b class="nc">&nbsp;                    initializeMap();</b>
<b class="nc">&nbsp;                } else if (x &gt; (getSize().width - 14)) {</b>
<b class="nc">&nbsp;                    if (GUIPreferences.getInstance().getMouseWheelZoomFlip()) {</b>
<b class="nc">&nbsp;                        zoomOut();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        zoomIn();</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // Minimize button
<b class="nc">&nbsp;                    heightBufer = getSize().height;</b>
<b class="nc">&nbsp;                    setSize(getSize().width, 14);</b>
&nbsp;
<b class="nc">&nbsp;                    m_mapImage = ImageUtil.createAcceleratedImage(Math.max(1, getSize().width), 14);</b>
&nbsp;
<b class="nc">&nbsp;                    minimized = true;</b>
<b class="nc">&nbsp;                    initializeMap();</b>
&nbsp;                }  
&nbsp;            }
<b class="nc">&nbsp;        } else if (m_bview != null) {</b>
<b class="nc">&nbsp;            if ((x &lt; margin) || (x &gt; (getSize().width - leftMargin))</b>
&nbsp;                || (y &lt; topMargin)
<b class="nc">&nbsp;                || (y &gt; (getSize().height - topMargin - 14))) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if ((me.getModifiers() &amp; InputEvent.CTRL_MASK) != 0) {</b>
<b class="nc">&nbsp;                m_bview.checkLOS(translateCoords(x - leftMargin, y - topMargin));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                m_bview.centerOnPointRel(</b>
<b class="nc">&nbsp;                        ((double)(x - leftMargin))/(double)((hexSideBySin30[zoom] + hexSide[zoom])*m_board.getWidth()),</b>
<b class="nc">&nbsp;                        ((double)(y - topMargin))/(double)(2 * hexSideByCos30[zoom]*m_board.getHeight()));</b>
<b class="nc">&nbsp;                m_bview.stopSoftCentering();</b>
<b class="nc">&nbsp;                repaint();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public int getZoom() {
<b class="nc">&nbsp;        return zoom;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setZoom(int z) {
<b class="nc">&nbsp;        zoom = z;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected BoardListener boardListener = new BoardListenerAdapter() {</b>
&nbsp;        @Override
&nbsp;        public void boardNewBoard(BoardEvent b) {
<b class="nc">&nbsp;            initializeMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void boardChangedHex(BoardEvent b) {
<b class="nc">&nbsp;            if (dirty == null) {</b>
<b class="nc">&nbsp;                dirtyMap = true;</b>
&nbsp;            } else {
&nbsp;                /*
&nbsp;                 * this must be tolerant since it might be called without
&nbsp;                 * notifying us of the boardsize first
&nbsp;                 */
<b class="nc">&nbsp;                int x = b.getCoords().getX();</b>
<b class="nc">&nbsp;                int y = b.getCoords().getY();</b>
<b class="nc">&nbsp;                if ((x &gt;= dirty.length) || (y &gt;= dirty[x].length)) {</b>
<b class="nc">&nbsp;                    dirtyMap = true;</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                dirty[x / 10][y / 10] = true;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    protected GameListener gameListener = new GameListenerAdapter() {</b>
&nbsp;        @Override
&nbsp;        public void gamePhaseChange(GamePhaseChangeEvent e) {
<b class="nc">&nbsp;            if (GUIPreferences.getInstance().getGameSummaryMiniMap() &amp;&amp; ((e.getOldPhase() == Phase.PHASE_DEPLOYMENT)</b>
<b class="nc">&nbsp;                    || (e.getOldPhase() == Phase.PHASE_MOVEMENT) || (e.getOldPhase() == Phase.PHASE_TARGETING)</b>
<b class="nc">&nbsp;                    || (e.getOldPhase() == Phase.PHASE_FIRING) || (e.getOldPhase() == Phase.PHASE_PHYSICAL))) {</b>
<b class="nc">&nbsp;                File dir = new File(Configuration.gameSummaryImagesMMDir(), m_game.getUUIDString());</b>
<b class="nc">&nbsp;                if (!dir.exists()) {</b>
<b class="nc">&nbsp;                    dir.mkdirs();</b>
&nbsp;                }
<b class="nc">&nbsp;				File imgFile = new File(dir, &quot;round_&quot; + m_game.getRoundCount() + &quot;_&quot; + e.getOldPhase().ordinal() + &quot;_&quot;</b>
<b class="nc">&nbsp;						+ IGame.Phase.getDisplayableName(e.getOldPhase()) + &quot;.png&quot;);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    ImageIO.write(m_mapImage, &quot;png&quot;, imgFile);</b>
<b class="nc">&nbsp;                } catch (IOException e1) {</b>
<b class="nc">&nbsp;                    e1.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameTurnChange(GameTurnChangeEvent e) {
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameBoardNew(GameBoardNewEvent e) {
<b class="nc">&nbsp;            IBoard b = e.getOldBoard();</b>
<b class="nc">&nbsp;            if (b != null) {</b>
<b class="nc">&nbsp;                b.removeBoardListener(boardListener);</b>
&nbsp;            }
<b class="nc">&nbsp;            b = e.getNewBoard();</b>
<b class="nc">&nbsp;            if (b != null) {</b>
<b class="nc">&nbsp;                b.addBoardListener(boardListener);</b>
&nbsp;            }
<b class="nc">&nbsp;            m_board = b;</b>
<b class="nc">&nbsp;            initializeMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void gameBoardChanged(GameBoardChangeEvent e) {
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    BoardViewListener boardViewListener = new BoardViewListenerAdapter() {</b>
&nbsp;        @Override
&nbsp;        public void hexCursor(BoardViewEvent b) {
<b class="nc">&nbsp;            update();</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public void hexMoused(BoardViewEvent b) {
<b class="nc">&nbsp;            update();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void boardHexHighlighted(BoardViewEvent b) {
<b class="nc">&nbsp;            update();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void hexSelected(BoardViewEvent b) {
<b class="nc">&nbsp;            update();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void firstLOSHex(BoardViewEvent b) {
<b class="nc">&nbsp;            secondLOS = null;</b>
<b class="nc">&nbsp;            firstLOS = b.getCoords();</b>
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void secondLOSHex(BoardViewEvent b, Coords c) {
<b class="nc">&nbsp;            firstLOS = c;</b>
<b class="nc">&nbsp;            secondLOS = b.getCoords();</b>
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        private void update() {
<b class="nc">&nbsp;            firstLOS = null;</b>
<b class="nc">&nbsp;            secondLOS = null;</b>
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    MouseListener mouseListener = new MouseAdapter() {</b>
&nbsp;
&nbsp;        public void mouseReleased(MouseEvent me) {
&nbsp;            // Center main map on clicked area, if there was no dragging
<b class="nc">&nbsp;            if (m_dialog instanceof JDialog &amp;&amp; !dragging) {</b>
<b class="nc">&nbsp;                processMouseClick(me.getX(), me.getY(), me);</b>
&nbsp;            }
&nbsp;            // Clear up variables related to dragging
<b class="nc">&nbsp;            dragging = false;</b>
<b class="nc">&nbsp;            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));</b>
&nbsp;        }
&nbsp;
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void mouseDragged(MouseEvent e) {
<b class="nc">&nbsp;            if (!dragging) {</b>
<b class="nc">&nbsp;                dragging = true;</b>
<b class="nc">&nbsp;                setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));</b>
&nbsp;            }
<b class="nc">&nbsp;            processMouseClick(e.getX(), e.getY(), e);</b>
&nbsp;        }
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    MouseWheelListener mouseWheelListener = new MouseWheelListener() {</b>
&nbsp;        public void mouseWheelMoved(MouseWheelEvent we) {
<b class="nc">&nbsp;            if (we.getWheelRotation() &lt; 0) {</b>
&nbsp;                //Zoom Out: The processMouseClick method uses absolute
&nbsp;                // positions within the minimap to determine what the click
&nbsp;                // does.  These parameters should activate the zoom-out features
<b class="nc">&nbsp;                processMouseClick(getSize().width - 12, getSize().height - 12, we);</b>
&nbsp;            } else {
&nbsp;                //Zoom In: The processMouseClick method uses absolute
&nbsp;                // positions within the minimap to determine what the click
&nbsp;                // does.  These parameters should activate the zoom-in features
<b class="nc">&nbsp;                processMouseClick(0, getSize().height - 12, we);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    ComponentListener componentListener = new ComponentAdapter() {</b>
&nbsp;        @Override
&nbsp;        public void componentShown(ComponentEvent ce) {
<b class="nc">&nbsp;            drawMap();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void componentResized(ComponentEvent ce) {
&nbsp;            // if (!minimized) initializeMap();
<b class="nc">&nbsp;        }</b>
&nbsp;    };
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
