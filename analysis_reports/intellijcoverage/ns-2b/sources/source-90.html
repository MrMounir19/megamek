


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > WeaponHandler</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common.weapons</a>
</div>

<h1>Coverage Summary for Class: WeaponHandler (megamek.common.weapons)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">WeaponHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1137)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * MegaMek - Copyright (C) 2004,2005 Ben Mazur (bmazur@sev.org)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.common.weapons;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;import megamek.MegaMek;
&nbsp;import megamek.common.Aero;
&nbsp;import megamek.common.AmmoType;
&nbsp;import megamek.common.BattleArmor;
&nbsp;import megamek.common.Building;
&nbsp;import megamek.common.Compute;
&nbsp;import megamek.common.Coords;
&nbsp;import megamek.common.Dropship;
&nbsp;import megamek.common.Entity;
&nbsp;import megamek.common.EquipmentMode;
&nbsp;import megamek.common.EquipmentType;
&nbsp;import megamek.common.HitData;
&nbsp;import megamek.common.IAero;
&nbsp;import megamek.common.IAimingModes;
&nbsp;import megamek.common.IGame;
&nbsp;import megamek.common.IHex;
&nbsp;import megamek.common.ITerrain;
&nbsp;import megamek.common.Infantry;
&nbsp;import megamek.common.LosEffects;
&nbsp;import megamek.common.Mech;
&nbsp;import megamek.common.Mounted;
&nbsp;import megamek.common.RangeType;
&nbsp;import megamek.common.Report;
&nbsp;import megamek.common.TagInfo;
&nbsp;import megamek.common.TargetRoll;
&nbsp;import megamek.common.Targetable;
&nbsp;import megamek.common.Terrains;
&nbsp;import megamek.common.ToHitData;
&nbsp;import megamek.common.WeaponType;
&nbsp;import megamek.common.actions.WeaponAttackAction;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.server.Server;
&nbsp;import megamek.server.Server.DamageType;
&nbsp;import megamek.server.SmokeCloud;
&nbsp;
&nbsp;/**
&nbsp; * @author Andrew Hunter A basic, simple attack handler. May or may not work for
&nbsp; *         any particular weapon; must be overloaded to support special rules.
&nbsp; */
&nbsp;public class WeaponHandler implements AttackHandler, Serializable {
&nbsp;
&nbsp;    private static final long serialVersionUID = 7137408139594693559L;
&nbsp;    public ToHitData toHit;
&nbsp;    protected HitData hit;
&nbsp;    public WeaponAttackAction waa;
&nbsp;    public int roll;
<b class="nc">&nbsp;    protected boolean isJammed = false;</b>
&nbsp;
&nbsp;    protected IGame game;
&nbsp;    protected transient Server server; // must not save the server
&nbsp;    protected boolean bMissed;
<b class="nc">&nbsp;    protected boolean bSalvo = false;</b>
<b class="nc">&nbsp;    protected boolean bGlancing = false;</b>
<b class="nc">&nbsp;    protected boolean bDirect = false;</b>
<b class="nc">&nbsp;    protected boolean bLowProfileGlancing = false;</b>
<b class="nc">&nbsp;    protected boolean nukeS2S = false;</b>
&nbsp;    protected WeaponType wtype;
&nbsp;    protected String typeName;
&nbsp;    protected Mounted weapon;
&nbsp;    protected Entity ae;
&nbsp;    protected Targetable target;
&nbsp;    protected int subjectId;
&nbsp;    protected int nRange;
&nbsp;    protected int nDamPerHit;
&nbsp;    protected int attackValue;
&nbsp;    protected boolean throughFront;
&nbsp;    protected boolean underWater;
<b class="nc">&nbsp;    protected boolean announcedEntityFiring = false;</b>
<b class="nc">&nbsp;    protected boolean missed = false;</b>
&nbsp;    protected DamageType damageType;
<b class="nc">&nbsp;    protected int generalDamageType = HitData.DAMAGE_NONE;</b>
<b class="nc">&nbsp;    protected Vector&lt;Integer&gt; insertedAttacks = new Vector&lt;Integer&gt;();</b>
&nbsp;    protected int nweapons; // for capital fighters/fighter squadrons
&nbsp;    protected int nweaponsHit; // for capital fighters/fighter squadrons
<b class="nc">&nbsp;    protected boolean secondShot = false;</b>
&nbsp;    protected int numRapidFireHits;
<b class="nc">&nbsp;    protected String sSalvoType = &quot; shot(s) &quot;;</b>
<b class="nc">&nbsp;    protected int nSalvoBonus = 0;</b>
&nbsp;    /**
&nbsp;     * Keeps track of whether we are processing the first hit in a series of
&nbsp;     * hits (like for cluster weapons)
&nbsp;     */
<b class="nc">&nbsp;    protected boolean firstHit = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Boolean flag that determines whether or not this attack is part of a
&nbsp;     * strafing run.
&nbsp;     */
<b class="nc">&nbsp;    protected boolean isStrafing = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Boolean flag that determiens if this shot was the first one by a
&nbsp;     * particular weapon in a strafing run. Used to ensure that heat is only
&nbsp;     * added once.
&nbsp;     */
<b class="nc">&nbsp;    protected boolean isStrafingFirstShot = false;</b>
&nbsp;    
&nbsp;    //Large Craft Point Defense/AMS Bay Stuff
&nbsp;    protected int CounterAV; //the combined attack value of all point defenses used against this weapon attack
&nbsp;    protected int CapMissileArmor; //the standard scale armor points of a capital missile bay
&nbsp;    protected int CapMissileAMSMod; //the to-hit mod inflicted against a capital missile attack if it isn&#39;t completely destroyed
<b class="nc">&nbsp;    protected boolean CapMissileMissed = false; //true if the AMSmod causes a capital missile attack to miss. Used for reporting.</b>
<b class="nc">&nbsp;    protected boolean amsBayEngaged = false; //true if one or more AMS bays engages this attack. Used for reporting if this is a standard missile (LRM, MRM, etc) attack.</b>
<b class="nc">&nbsp;    protected boolean pdBayEngaged = false; // true if one or more point defense bays engages this attack. Used for reporting if this is a standard missile (LRM, MRM, etc) attack.</b>
<b class="nc">&nbsp;    protected boolean pdOverheated = false; // true if counterfire + offensive weapon attacks made this round cause the defending unit to overheat. Used for reporting.</b>
<b class="nc">&nbsp;    protected boolean amsBayEngagedCap = false; //true if one or more AMS bays engages this attack. Used for reporting if this is a capital missile attack.</b>
<b class="nc">&nbsp;    protected boolean pdBayEngagedCap = false; // true if one or more point defense bays engages this attack. Used for reporting if this is a capital missile attack.</b>
<b class="nc">&nbsp;    protected boolean amsBayEngagedMissile = false; //true if one or more AMS bays engages this attack. Used for reporting if this is a single large missile (thunderbolt, etc) attack.</b>
<b class="nc">&nbsp;    protected boolean pdBayEngagedMissile = false; // true if one or more point defense bays engages this attack. Used for reporting if this is a single large missile (thunderbolt, etc) attack.</b>
<b class="nc">&nbsp;    protected boolean advancedPD = false; //true if advanced StratOps game rule is on</b>
<b class="nc">&nbsp;    protected WeaponHandler parentBayHandler = null; //Used for weapons bays when Aero Sanity is on</b>
<b class="nc">&nbsp;    protected int originalAV = 0; // Used to handle AMS damage to standard missile flights fired by capital fighters</b>
&nbsp;    
<b class="nc">&nbsp;    protected boolean amsEngaged = false;</b>
<b class="nc">&nbsp;    protected boolean apdsEngaged = false;</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns the heat generated by a large craft&#39;s weapons fire declarations during the round
&nbsp;     * Used to determine whether point defenses can engage.
&nbsp;     * @Param e - the entity you wish to get heat data from
&nbsp;     * See also TeleMissileAttackAction, which contains a modified version of this to work against 
&nbsp;     * a TeleMissile entity in the physical phase
&nbsp;     */
&nbsp;    protected int getLargeCraftHeat(Entity e) {
<b class="nc">&nbsp;        int totalheat = 0;</b>
<b class="nc">&nbsp;        if (e.hasETypeFlag(Entity.ETYPE_DROPSHIP) </b>
<b class="nc">&nbsp;                || e.hasETypeFlag(Entity.ETYPE_JUMPSHIP)) {</b>
<b class="nc">&nbsp;            if (e.usesWeaponBays()) {</b>
<b class="nc">&nbsp;                for (Enumeration&lt;AttackHandler&gt; i = game.getAttacks(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    AttackHandler ah = i.nextElement();</b>
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = ah.getWaa();</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == e.getId()) {</b>
<b class="nc">&nbsp;                        Mounted prevWeapon = e.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                        for (int wId : prevWeapon.getBayWeapons()) {</b>
<b class="nc">&nbsp;                            Mounted bayW = e.getEquipment(wId);</b>
<b class="nc">&nbsp;                            totalheat += bayW.getCurrentHeat();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                for (Enumeration&lt;AttackHandler&gt; i = game.getAttacks(); i.hasMoreElements();) {</b>
<b class="nc">&nbsp;                    AttackHandler ah = i.nextElement();</b>
<b class="nc">&nbsp;                    WeaponAttackAction prevAttack = ah.getWaa();</b>
<b class="nc">&nbsp;                    if (prevAttack.getEntityId() == e.getId()) {</b>
<b class="nc">&nbsp;                        Mounted prevWeapon = e.getEquipment(prevAttack.getWeaponId());</b>
<b class="nc">&nbsp;                        totalheat += prevWeapon.getCurrentHeat();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return totalheat;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Checks to see if the basic conditions needed for point defenses to work are in place
&nbsp;     * Artillery weapons need to change this slightly
&nbsp;     * See also TeleMissileAttackAction, which contains a modified version of this to work against 
&nbsp;     * a TeleMissile entity in the physical phase
&nbsp;     */
&nbsp;    protected boolean checkPDConditions() {
<b class="nc">&nbsp;        advancedPD = game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADV_POINTDEF);</b>
<b class="nc">&nbsp;        if ((target == null)</b>
<b class="nc">&nbsp;                || (target.getTargetType() != Targetable.TYPE_ENTITY)</b>
&nbsp;                || !advancedPD
&nbsp;                //Don&#39;t defend against ground fire with bay fire unless attacked by capital missile fire
&nbsp;                //Prevents ammo and heat being used twice for dropships defending here and with getAMSHitsMod()
<b class="nc">&nbsp;                || (waa.isGroundToAir(game) &amp;&amp; (!(wtype.isSubCapital() || wtype.isCapital())))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (target instanceof Dropship </b>
<b class="nc">&nbsp;                &amp;&amp; waa.isAirToGround(game)</b>
<b class="nc">&nbsp;                &amp;&amp; !ae.usesWeaponBays()) {</b>
&nbsp;            //Prevents a grounded dropship using individual weapons from engaging with AMSBays unless attacked by a dropship or capital fighter
&nbsp;            //You can get some blank missile weapons fire reports due to the attackvalue / ndamageperhit conversion if this isn&#39;t done
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Checks to see if this point defense/AMS bay can engage a capital missile
&nbsp;     * This should return true. Only when handling capital missile attacks can this be false.
&nbsp;     * See also TeleMissileAttackAction, which contains a modified version of this to work against 
&nbsp;     * a TeleMissile entity in the physical phase
&nbsp;     */
&nbsp;    protected boolean canEngageCapitalMissile(Mounted counter) {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the appropriate AMS Bay reporting flag depending on what type of missile this is
&nbsp;     * See also TeleMissileAttackAction, which contains a modified version of this to work against 
&nbsp;     * a TeleMissile entity in the physical phase
&nbsp;     */
&nbsp;    protected void setAMSBayReportingFlag() {
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the appropriate PD Bay reporting flag depending on what type of missile this is
&nbsp;     * See also TeleMissileAttackAction, which contains a modified version of this to work against 
&nbsp;     * a TeleMissile entity in the physical phase
&nbsp;     */
&nbsp;    protected void setPDBayReportingFlag() {
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets whether or not this weapon is considered a single, large missile for AMS resolution
&nbsp;     */
&nbsp;    protected boolean isTbolt() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculates the attack value of point defense weapons used against a missile bay attack
&nbsp;     * This is the main large craft point defense method
&nbsp;     * See also TeleMissileAttackAction, which contains a modified version of this to work against 
&nbsp;     * a TeleMissile entity in the physical phase
&nbsp;     */    
&nbsp;    protected int calcCounterAV() {
<b class="nc">&nbsp;        if (!checkPDConditions()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int counterAV = 0;</b>
<b class="nc">&nbsp;        int amsAV = 0;</b>
<b class="nc">&nbsp;        double pdAV = 0;</b>
<b class="nc">&nbsp;        Entity entityTarget = (Entity) target;</b>
&nbsp;        // any AMS bay attacks by the target?
<b class="nc">&nbsp;        ArrayList&lt;Mounted&gt; lCounters = waa.getCounterEquipment();</b>
&nbsp;        //We need to know how much heat has been assigned to offensive weapons fire by the defender this round
<b class="nc">&nbsp;        int weaponHeat = getLargeCraftHeat(entityTarget) + entityTarget.heatBuildup;</b>
<b class="nc">&nbsp;        if (null != lCounters) {</b>
<b class="nc">&nbsp;            for (Mounted counter : lCounters) {</b>
&nbsp;                // Point defenses only fire vs attacks against the arc they protect
<b class="nc">&nbsp;                Entity pdEnt = counter.getEntity();</b>
&nbsp;                boolean isInArc;
&nbsp;                // If the defending unit is the target, use attacker for arc
<b class="nc">&nbsp;                if (entityTarget.equals(pdEnt)) {</b>
<b class="nc">&nbsp;                    isInArc = Compute.isInArc(game, pdEnt.getId(),</b>
<b class="nc">&nbsp;                            pdEnt.getEquipmentNum(counter),</b>
&nbsp;                            ae);
&nbsp;                } else { // Otherwise, the attack must pass through an escort unit&#39;s hex
&nbsp;                    // TODO: We&#39;ll get here, eventually
<b class="nc">&nbsp;                    isInArc = Compute.isInArc(game, pdEnt.getId(),</b>
<b class="nc">&nbsp;                            pdEnt.getEquipmentNum(counter),</b>
&nbsp;                            entityTarget);
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                if (!isInArc) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // Point defenses can&#39;t fire if they&#39;re not ready for any other reason
<b class="nc">&nbsp;                if (!(counter.getType() instanceof WeaponType)</b>
<b class="nc">&nbsp;                         || !counter.isReady() || counter.isMissing()</b>
&nbsp;                            // shutdown means no Point defenses
<b class="nc">&nbsp;                            || pdEnt.isShutDown()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                }
&nbsp;                //Point defense/AMS bays with less than 2 weapons cannot engage capital missiles
<b class="nc">&nbsp;                if (!canEngageCapitalMissile(counter)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                
&nbsp;                //Set up differences between point defense and AMS bays
<b class="nc">&nbsp;                boolean isAMSBay = counter.getType().hasFlag(WeaponType.F_AMSBAY);</b>
<b class="nc">&nbsp;                boolean isPDBay = counter.getType().hasFlag(WeaponType.F_PDBAY);</b>
&nbsp;                
&nbsp;                //Point defense bays can only fire at one attack per round
<b class="nc">&nbsp;                if (isPDBay) {</b>
<b class="nc">&nbsp;                    if (counter.isUsedThisRound()) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                
&nbsp;                // Now for heat, damage and ammo we need the individual weapons in the bay
&nbsp;                // First, reset the temporary damage counters
<b class="nc">&nbsp;                amsAV = 0;</b>
<b class="nc">&nbsp;                pdAV = 0;</b>
<b class="nc">&nbsp;                for (int wId : counter.getBayWeapons()) {</b>
<b class="nc">&nbsp;                    Mounted bayW = pdEnt.getEquipment(wId);</b>
<b class="nc">&nbsp;                    Mounted bayWAmmo = bayW.getLinked();</b>
<b class="nc">&nbsp;                    WeaponType bayWType = ((WeaponType) bayW.getType());</b>
&nbsp;                    
&nbsp;                    // build up some heat
&nbsp;                    //First Check to see if we have enough heat capacity to fire
<b class="nc">&nbsp;                    if ((weaponHeat + bayW.getCurrentHeat()) &gt; pdEnt.getHeatCapacity()) {</b>
<b class="nc">&nbsp;                        pdOverheated = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (counter.getType().hasFlag(WeaponType.F_HEATASDICE)) {</b>
<b class="nc">&nbsp;                        int heatDice = Compute.d6(bayW</b>
<b class="nc">&nbsp;                                .getCurrentHeat());</b>
<b class="nc">&nbsp;                        pdEnt.heatBuildup += heatDice;</b>
<b class="nc">&nbsp;                        weaponHeat += heatDice;</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        pdEnt.heatBuildup += bayW.getCurrentHeat();</b>
<b class="nc">&nbsp;                        weaponHeat += bayW.getCurrentHeat();</b>
&nbsp;                    }
&nbsp;                    
&nbsp;                    //Bays use lots of ammo. Check to make sure we haven&#39;t run out
<b class="nc">&nbsp;                    if (bayWAmmo != null) {</b>
<b class="nc">&nbsp;                        if (bayWAmmo.getBaseShotsLeft() == 0) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;                        // decrement the ammo
<b class="nc">&nbsp;                        bayWAmmo.setShotsLeft(Math.max(0,</b>
<b class="nc">&nbsp;                            bayWAmmo.getBaseShotsLeft() - 1));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (isAMSBay) {</b>
&nbsp;                        // get the attack value
<b class="nc">&nbsp;                        amsAV += bayWType.getShortAV();</b>
&nbsp;                        // set the ams as having fired, if it did
<b class="nc">&nbsp;                        setAMSBayReportingFlag();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (isPDBay) {</b>
&nbsp;                        // get the attack value
<b class="nc">&nbsp;                        pdAV += bayWType.getShortAV();</b>
&nbsp;                        // set the pdbay as having fired, if it was able to
<b class="nc">&nbsp;                        counter.setUsedThisRound(true); </b>
<b class="nc">&nbsp;                        setPDBayReportingFlag();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;                // non-AMS only add half their damage, rounded up
<b class="nc">&nbsp;                counterAV += (int) Math.ceil(pdAV / 2.0); </b>
&nbsp;                // AMS add their full damage
<b class="nc">&nbsp;                counterAV += amsAV;</b>
<b class="nc">&nbsp;            } //end &quot;for Mounted counter&quot;</b>
&nbsp;        } // end check for counterfire
<b class="nc">&nbsp;        CounterAV = (int) counterAV;</b>
<b class="nc">&nbsp;        return counterAV;</b>
&nbsp;    }
&nbsp;
&nbsp;    
&nbsp;    /**
&nbsp;     * Return the attack value of point defense weapons used against a missile bay attack
&nbsp;     */ 
&nbsp;    protected int getCounterAV() {
<b class="nc">&nbsp;    	return CounterAV;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Used with Aero Sanity mod
&nbsp;     * Returns the handler for the BayWeapon this individual weapon belongs to
&nbsp;     */ 
&nbsp;    protected WeaponHandler getParentBayHandler() {
<b class="nc">&nbsp;        return parentBayHandler;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the parent handler for each sub-weapon handler called when looping through bay weapons
&nbsp;     * Used with Aero Sanity to pass counterAV through to the individual missile handler from the bay handler
&nbsp;     * 
&nbsp;     * @param bh - The &lt;code&gt;AttackHandler&lt;/code&gt; for the BayWeapon this individual weapon belongs to
&nbsp;     */ 
&nbsp;    protected void setParentBayHandler(WeaponHandler bh) {
<b class="nc">&nbsp;        parentBayHandler = bh;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Calculates the to-hit penalty inflicted on a capital missile attack by point defense fire
&nbsp;     * this should return 0 unless this is a capital missile attack (otherwise, reporting and to-hit get screwed up)
&nbsp;     */    
&nbsp;    protected int calcCapMissileAMSMod() {
<b class="nc">&nbsp;    	return 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Return the to-hit penalty inflicted on a capital missile attack by point defense fire
&nbsp;     */ 
&nbsp;    protected int getCapMissileAMSMod() {
<b class="nc">&nbsp;    	return CapMissileAMSMod;</b>
&nbsp;    }
&nbsp;    
&nbsp;    //End of Large Craft Point Defense Methods and Variables
&nbsp;    
&nbsp;    /**
&nbsp;     * Used to store reports from calls to &lt;code&gt;calcDamagePerHit&lt;/code&gt;.  This
&nbsp;     * is necessary because the method is called before the report needs to be
&nbsp;     * added.
&nbsp;     */
<b class="nc">&nbsp;    protected Vector&lt;Report&gt; calcDmgPerHitReport = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * return the &lt;code&gt;int&lt;/code&gt; Id of the attacking &lt;code&gt;Entity&lt;/code&gt;
&nbsp;     */
&nbsp;    public int getAttackerId() {
<b class="nc">&nbsp;        return ae.getId();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do we care about the specified phase?
&nbsp;     */
&nbsp;    public boolean cares(IGame.Phase phase) {
<b class="nc">&nbsp;        if (phase == IGame.Phase.PHASE_FIRING) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param vPhaseReport
&nbsp;     *            - A &lt;code&gt;Vector&lt;/code&gt; containing the phasereport.
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; value indicating wether or not the attack
&nbsp;     *         misses because of a failed check.
&nbsp;     */
&nbsp;    protected boolean doChecks(Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Carries out a check to see if the weapon in question explodes due to the &#39;ammo feed problem&#39; quirk
&nbsp;     * Not the case for weapons without ammo
&nbsp;     */
&nbsp;    protected boolean doAmmoFeedProblemCheck(Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void writeObject(ObjectOutputStream out) throws IOException {
<b class="nc">&nbsp;        out.defaultWriteObject();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void readObject(ObjectInputStream in) throws IOException,
&nbsp;            ClassNotFoundException {
<b class="nc">&nbsp;        in.defaultReadObject();</b>
&nbsp;
<b class="nc">&nbsp;        server = Server.getServerInstance();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; value indicating wether or not this attack
&nbsp;     *         needs further calculating, like a missed shot hitting a building,
&nbsp;     *         or an AMS only shooting down some missiles.
&nbsp;     */
&nbsp;    protected boolean handleSpecialMiss(Entity entityTarget,
&nbsp;            boolean bldgDamagedOnMiss, Building bldg,
&nbsp;            Vector&lt;Report&gt; vPhaseReport) {
&nbsp;        // Shots that miss an entity can set fires.
&nbsp;        // Buildings can&#39;t be accidentally ignited,
&nbsp;        // and some weapons can&#39;t ignite fires.
<b class="nc">&nbsp;        if ((entityTarget != null)</b>
<b class="nc">&nbsp;                &amp;&amp; !entityTarget.isAirborne()</b>
<b class="nc">&nbsp;                &amp;&amp; !entityTarget.isAirborneVTOLorWIGE()</b>
<b class="nc">&nbsp;                &amp;&amp; ((bldg == null) &amp;&amp; (wtype.getFireTN() != TargetRoll.IMPOSSIBLE))) {</b>
<b class="nc">&nbsp;            server.tryIgniteHex(target.getPosition(), subjectId, false, false,</b>
<b class="nc">&nbsp;                    new TargetRoll(wtype.getFireTN(), wtype.getName()), 3,</b>
&nbsp;                    vPhaseReport);
&nbsp;        }
&nbsp;
&nbsp;        // shots that miss an entity can also potential cause explosions in a
&nbsp;        // heavy industrial hex
<b class="nc">&nbsp;        server.checkExplodeIndustrialZone(target.getPosition(), vPhaseReport);</b>
&nbsp;
&nbsp;        // TW, pg. 171 - shots that miss a target in a building don&#39;t damage the
&nbsp;        // building, unless the attacker is adjacent
<b class="nc">&nbsp;        if (!bldgDamagedOnMiss</b>
<b class="nc">&nbsp;                || (toHit.getValue() == TargetRoll.AUTOMATIC_FAIL)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate the number of hits
&nbsp;     *
&nbsp;     * @param vPhaseReport
&nbsp;     *            - the &lt;code&gt;Vector&lt;/code&gt; containing the phase report.
&nbsp;     * @return an &lt;code&gt;int&lt;/code&gt; containing the number of hits.
&nbsp;     */
&nbsp;    protected int calcHits(Vector&lt;Report&gt; vPhaseReport) {
&nbsp;        // normal BA attacks (non-swarm, non single-trooper weapons)
&nbsp;        // do more than 1 hit
<b class="nc">&nbsp;        if ((ae instanceof BattleArmor)</b>
<b class="nc">&nbsp;                &amp;&amp; (weapon.getLocation() == BattleArmor.LOC_SQUAD)</b>
<b class="nc">&nbsp;                &amp;&amp; !(weapon.isSquadSupportWeapon())</b>
<b class="nc">&nbsp;                &amp;&amp; !(ae.getSwarmTargetId() == target.getTargetId())) {</b>
<b class="nc">&nbsp;            bSalvo = true;</b>
<b class="nc">&nbsp;            int toReturn = allShotsHit() ? ((BattleArmor) ae)</b>
<b class="nc">&nbsp;                    .getShootingStrength() : Compute</b>
<b class="nc">&nbsp;                    .missilesHit(((BattleArmor) ae).getShootingStrength());</b>
<b class="nc">&nbsp;            Report r = new Report(3325);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.add(toReturn);</b>
<b class="nc">&nbsp;            r.add(&quot; troopers &quot;);</b>
<b class="nc">&nbsp;            r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;            return toReturn;</b>
&nbsp;        }
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate the clustering of the hits
&nbsp;     *
&nbsp;     * @return a &lt;code&gt;int&lt;/code&gt; value saying how much hits are in each cluster
&nbsp;     *         of damage.
&nbsp;     */
&nbsp;    protected int calcnCluster() {
<b class="nc">&nbsp;        return 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int calcnClusterAero(Entity entityTarget) {
<b class="nc">&nbsp;        if (usesClusterTable() &amp;&amp; !ae.isCapitalFighter()</b>
<b class="nc">&nbsp;                &amp;&amp; (entityTarget != null) &amp;&amp; !entityTarget.isCapitalScale()) {</b>
<b class="nc">&nbsp;            return 5;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected int[] calcAeroDamage(Entity entityTarget,
&nbsp;            Vector&lt;Report&gt; vPhaseReport) {
&nbsp;        // Now I need to adjust this for attacks on aeros because they use
&nbsp;        // attack values and different rules
&nbsp;        // this will work differently for cluster and non-cluster
&nbsp;        // weapons, and differently for capital fighter/fighter
&nbsp;        // squadrons
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)) {</b>
&nbsp;            // everything will use the normal hits and clusters for hits weapon
&nbsp;            // unless
&nbsp;            // we have a squadron or capital scale entity
<b class="nc">&nbsp;            int reportSize = vPhaseReport.size();</b>
<b class="nc">&nbsp;            int hits = calcHits(vPhaseReport);</b>
<b class="nc">&nbsp;            int nCluster = calcnCluster();</b>
<b class="nc">&nbsp;            int AMSHits = 0;</b>
<b class="nc">&nbsp;            if (ae.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                Vector&lt;Report&gt; throwAwayReport = new Vector&lt;Report&gt;();</b>
&nbsp;                // for capital scale fighters, each non-cluster weapon hits a
&nbsp;                // different location
<b class="nc">&nbsp;                bSalvo = true;</b>
<b class="nc">&nbsp;                hits = 1;</b>
<b class="nc">&nbsp;                if (nweapons &gt; 1) {</b>
<b class="nc">&nbsp;                    if (allShotsHit()) {</b>
<b class="nc">&nbsp;                        nweaponsHit = nweapons;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        nweaponsHit = Compute.missilesHit(nweapons,</b>
<b class="nc">&nbsp;                                ((Aero) ae).getClusterMods());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (usesClusterTable()) {</b>
&nbsp;                        // remove the last reports because they showed the
&nbsp;                        // number of shots that hit
<b class="nc">&nbsp;                        while (vPhaseReport.size() &gt; reportSize) {</b>
<b class="nc">&nbsp;                            vPhaseReport.remove(vPhaseReport.size() - 1);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        hits = 0;</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; nweaponsHit; i++) {</b>
<b class="nc">&nbsp;                            hits += calcHits(throwAwayReport);</b>
&nbsp;                        }
&nbsp;                        //Report and apply point defense fire
<b class="nc">&nbsp;                        if (pdBayEngaged || amsBayEngaged) {</b>
<b class="nc">&nbsp;                            Report r = new Report(3367);</b>
<b class="nc">&nbsp;                            r.indent();</b>
<b class="nc">&nbsp;                            r.subject = subjectId;</b>
<b class="nc">&nbsp;                            r.add(getCounterAV());</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                            hits -= (CounterAV / nDamPerHit);</b>
<b class="nc">&nbsp;                        } else if (amsEngaged) {</b>
<b class="nc">&nbsp;                            Report r = new Report(3350);</b>
<b class="nc">&nbsp;                            r.subject = entityTarget.getId();</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Report r = new Report(3325);</b>
<b class="nc">&nbsp;                        r.subject = subjectId;</b>
<b class="nc">&nbsp;                        r.add(hits);</b>
<b class="nc">&nbsp;                        r.add(sSalvoType);</b>
<b class="nc">&nbsp;                        r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;                        r.newlines = 0;</b>
<b class="nc">&nbsp;                        vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        //If point defenses engage Large, single missiles
<b class="nc">&nbsp;                        if (pdBayEngagedMissile || amsBayEngagedMissile) {</b>
&nbsp;                            // remove the last reports because they showed the
&nbsp;                            // number of shots that hit
<b class="nc">&nbsp;                            while (vPhaseReport.size() &gt; reportSize) {</b>
<b class="nc">&nbsp;                                vPhaseReport.remove(vPhaseReport.size() - 1);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            AMSHits = 0;</b>
<b class="nc">&nbsp;                            Report r = new Report(3236);</b>
<b class="nc">&nbsp;                            r.subject = subjectId;</b>
<b class="nc">&nbsp;                            r.add(nweaponsHit);</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                            r = new Report(3230);</b>
<b class="nc">&nbsp;                            r.indent(1);</b>
<b class="nc">&nbsp;                            r.subject = subjectId;</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                            for (int i = 0; i &lt; nweaponsHit; i++) {</b>
<b class="nc">&nbsp;                                int destroyRoll = Compute.d6();</b>
<b class="nc">&nbsp;                                if (destroyRoll &lt;= 3) {</b>
<b class="nc">&nbsp;                                    r = new Report(3240);</b>
<b class="nc">&nbsp;                                    r.subject = subjectId;</b>
<b class="nc">&nbsp;                                    r.add(&quot;missile&quot;);</b>
<b class="nc">&nbsp;                                    r.add(destroyRoll);</b>
<b class="nc">&nbsp;                                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                                    AMSHits += 1;</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    r = new Report(3241);</b>
<b class="nc">&nbsp;                                    r.add(&quot;missile&quot;);</b>
<b class="nc">&nbsp;                                    r.add(destroyRoll);</b>
<b class="nc">&nbsp;                                    r.subject = subjectId;</b>
<b class="nc">&nbsp;                                    vPhaseReport.add(r);                                </b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            nweaponsHit = nweaponsHit - AMSHits;</b>
<b class="nc">&nbsp;                        } else if (amsEngaged || apdsEngaged) {</b>
&nbsp;                            // remove the last reports because they showed the
&nbsp;                            // number of shots that hit
<b class="nc">&nbsp;                            while (vPhaseReport.size() &gt; reportSize) {</b>
<b class="nc">&nbsp;                                vPhaseReport.remove(vPhaseReport.size() - 1);</b>
&nbsp;                            }
&nbsp;                            //If you&#39;re shooting at a target using single AMS
&nbsp;                            //Too many variables here as far as AMS numbers
&nbsp;                            //Just allow 1 missile to be shot down
<b class="nc">&nbsp;                            AMSHits = 0;</b>
<b class="nc">&nbsp;                            Report r = new Report(3236);</b>
<b class="nc">&nbsp;                            r.subject = subjectId;</b>
<b class="nc">&nbsp;                            r.add(nweaponsHit);</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                            if (amsEngaged) {</b>
<b class="nc">&nbsp;                                r = new Report(3230);</b>
<b class="nc">&nbsp;                                r.indent(1);</b>
<b class="nc">&nbsp;                                r.subject = subjectId;</b>
<b class="nc">&nbsp;                                vPhaseReport.add(r);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (apdsEngaged) {</b>
<b class="nc">&nbsp;                                r = new Report(3231);</b>
<b class="nc">&nbsp;                                r.indent(1);</b>
<b class="nc">&nbsp;                                r.subject = subjectId;</b>
<b class="nc">&nbsp;                                vPhaseReport.add(r);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            int destroyRoll = Compute.d6();</b>
<b class="nc">&nbsp;                            if (destroyRoll &lt;= 3) {</b>
<b class="nc">&nbsp;                                r = new Report(3240);</b>
<b class="nc">&nbsp;                                r.subject = subjectId;</b>
<b class="nc">&nbsp;                                r.add(&quot;missile&quot;);</b>
<b class="nc">&nbsp;                                r.add(destroyRoll);</b>
<b class="nc">&nbsp;                                vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                                AMSHits = 1;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                r = new Report(3241);</b>
<b class="nc">&nbsp;                                r.add(&quot;missile&quot;);</b>
<b class="nc">&nbsp;                                r.add(destroyRoll);</b>
<b class="nc">&nbsp;                                r.subject = subjectId;</b>
<b class="nc">&nbsp;                                vPhaseReport.add(r);                                </b>
&nbsp;                            }
<b class="nc">&nbsp;                            nweaponsHit = nweaponsHit - AMSHits;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        nCluster = 1;</b>
<b class="nc">&nbsp;                        if (!bMissed) {</b>
<b class="nc">&nbsp;                            Report r = new Report(3325);</b>
<b class="nc">&nbsp;                            r.subject = subjectId;</b>
<b class="nc">&nbsp;                            r.add(nweaponsHit);</b>
<b class="nc">&nbsp;                            r.add(&quot; weapon(s) &quot;);</b>
<b class="nc">&nbsp;                            r.add(&quot; &quot;);</b>
<b class="nc">&nbsp;                            r.newlines = 0;</b>
<b class="nc">&nbsp;                            hits = nweaponsHit;</b>
<b class="nc">&nbsp;                            vPhaseReport.add(r);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            int[] results = new int[2];</b>
<b class="nc">&nbsp;            results[0] = hits;</b>
<b class="nc">&nbsp;            results[1] = nCluster;</b>
<b class="nc">&nbsp;            return results;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            int hits = 1;</b>
<b class="nc">&nbsp;            int nCluster = calcnClusterAero(entityTarget);</b>
<b class="nc">&nbsp;            if (ae.isCapitalFighter()) {</b>
<b class="nc">&nbsp;                bSalvo = false;</b>
<b class="nc">&nbsp;                if (nweapons &gt; 1) {</b>
<b class="nc">&nbsp;                    nweaponsHit = Compute.missilesHit(nweapons,</b>
<b class="nc">&nbsp;                            ((IAero) ae).getClusterMods());</b>
<b class="nc">&nbsp;                    if (pdBayEngaged || amsBayEngaged) {</b>
&nbsp;                    	//Point Defenses engage standard (cluster) missiles
<b class="nc">&nbsp;                        int counterAV = 0;</b>
<b class="nc">&nbsp;                        counterAV = getCounterAV();</b>
<b class="nc">&nbsp;                        nDamPerHit = originalAV * nweaponsHit - counterAV;</b>
<b class="nc">&nbsp;                        hits = 1;</b>
<b class="nc">&nbsp;                        nCluster = 1;</b>
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                    	//If multiple large missile or non-missile weapons hit
<b class="nc">&nbsp;                    	Report r = new Report(3325);</b>
<b class="nc">&nbsp;                    	r.subject = subjectId;</b>
<b class="nc">&nbsp;                    	r.add(nweaponsHit);</b>
<b class="nc">&nbsp;                    	r.add(&quot; weapon(s) &quot;);</b>
<b class="nc">&nbsp;                    	r.add(&quot; &quot;);</b>
<b class="nc">&nbsp;                    	r.newlines = 1;</b>
<b class="nc">&nbsp;                    	vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    	nDamPerHit = attackValue * nweaponsHit;</b>
<b class="nc">&nbsp;                    	hits = 1;</b>
<b class="nc">&nbsp;                    	nCluster = 1;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } 
<b class="nc">&nbsp;            } else if (nCluster &gt; 1) {</b>
<b class="nc">&nbsp;                bSalvo = true;</b>
<b class="nc">&nbsp;                nDamPerHit = 1;</b>
<b class="nc">&nbsp;                hits = attackValue;</b>
&nbsp;            } else {
&nbsp;            	//If we&#39;re not a capital fighter / squadron
&nbsp;            	//Point Defenses engage any Large, single missiles
<b class="nc">&nbsp;            	getCounterAV();</b>
<b class="nc">&nbsp;                if (pdBayEngagedMissile || amsBayEngagedMissile) {</b>
<b class="nc">&nbsp;                    bSalvo = false;</b>
<b class="nc">&nbsp;                    Report r = new Report(3235);</b>
<b class="nc">&nbsp;                    r.subject = subjectId;</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    r = new Report(3230);</b>
<b class="nc">&nbsp;                    r.indent(1);</b>
<b class="nc">&nbsp;                    r.subject = subjectId;</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; nweaponsHit; i++) {</b>
<b class="nc">&nbsp;                    	int destroyRoll = Compute.d6();</b>
<b class="nc">&nbsp;                    	if (destroyRoll &lt;= 3) {</b>
<b class="nc">&nbsp;                    		r = new Report(3240);</b>
<b class="nc">&nbsp;                    		r.subject = subjectId;</b>
<b class="nc">&nbsp;                    		r.add(&quot;missile&quot;);</b>
<b class="nc">&nbsp;                    		r.add(destroyRoll);</b>
<b class="nc">&nbsp;                    		vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    		hits = 0;</b>
&nbsp;                    	} else {
<b class="nc">&nbsp;                    		r = new Report(3241);</b>
<b class="nc">&nbsp;                    		r.add(&quot;missile&quot;);</b>
<b class="nc">&nbsp;                    		r.add(destroyRoll);</b>
<b class="nc">&nbsp;                    		r.subject = subjectId;</b>
<b class="nc">&nbsp;                    		vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    		hits = 1;</b>
&nbsp;                    	}
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                bSalvo = false;</b>
<b class="nc">&nbsp;                nDamPerHit = attackValue;</b>
<b class="nc">&nbsp;                hits = 1;</b>
<b class="nc">&nbsp;                nCluster = 1;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            int[] results = new int[2];</b>
<b class="nc">&nbsp;            results[0] = hits;</b>
<b class="nc">&nbsp;            results[1] = nCluster;</b>
<b class="nc">&nbsp;            return results;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * handle this weapons firing
&nbsp;     *
&nbsp;     * @return a &lt;code&gt;boolean&lt;/code&gt; value indicating whether this should be
&nbsp;     *         kept or not
&nbsp;     */
&nbsp;    public boolean handle(IGame.Phase phase, Vector&lt;Report&gt; returnedReports) {
<b class="nc">&nbsp;        if (!cares(phase)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Report&gt; vPhaseReport = new Vector&lt;Report&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        boolean heatAdded = false;</b>
<b class="nc">&nbsp;        int numAttacks = 1;</b>
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UAC_TWOROLLS)</b>
<b class="nc">&nbsp;                &amp;&amp; ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA) || (wtype</b>
<b class="nc">&nbsp;                        .getAmmoType() == AmmoType.T_AC_ULTRA_THB))</b>
<b class="nc">&nbsp;                &amp;&amp; !weapon.curMode().equals(&quot;Single&quot;)) {</b>
<b class="nc">&nbsp;            numAttacks = 2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entity entityTarget = (target.getTargetType() == Targetable.TYPE_ENTITY) ? (Entity) target</b>
<b class="nc">&nbsp;                : null;</b>
<b class="nc">&nbsp;        final boolean targetInBuilding = Compute.isInBuilding(game,</b>
&nbsp;                entityTarget);
<b class="nc">&nbsp;        final boolean bldgDamagedOnMiss = targetInBuilding</b>
&nbsp;                &amp;&amp; !(target instanceof Infantry)
<b class="nc">&nbsp;                &amp;&amp; ae.getPosition().distance(target.getPosition()) &lt;= 1;</b>
&nbsp;
<b class="nc">&nbsp;        if (entityTarget != null) {</b>
<b class="nc">&nbsp;            ae.setLastTarget(entityTarget.getId());</b>
<b class="nc">&nbsp;            ae.setLastTargetDisplayName(entityTarget.getDisplayName());</b>
&nbsp;        }
&nbsp;        // Which building takes the damage?
<b class="nc">&nbsp;        Building bldg = game.getBoard().getBuildingAt(target.getPosition());</b>
<b class="nc">&nbsp;        String number = nweapons &gt; 1 ? &quot; (&quot; + nweapons + &quot;)&quot; : &quot;&quot;;</b>
<b class="nc">&nbsp;        for (int i = numAttacks; i &gt; 0; i--) {</b>
&nbsp;            // Report weapon attack and its to-hit value.
<b class="nc">&nbsp;            Report r = new Report(3115);</b>
<b class="nc">&nbsp;            r.indent();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.add(wtype.getName() + number);</b>
<b class="nc">&nbsp;            if (entityTarget != null) {</b>
<b class="nc">&nbsp;                if ((wtype.getAmmoType() != AmmoType.T_NA)</b>
<b class="nc">&nbsp;                        &amp;&amp; (weapon.getLinked() != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</b>
<b class="nc">&nbsp;                    AmmoType atype = (AmmoType) weapon.getLinked().getType();</b>
<b class="nc">&nbsp;                    if (atype.getMunitionType() != AmmoType.M_STANDARD) {</b>
<b class="nc">&nbsp;                        r.messageId = 3116;</b>
<b class="nc">&nbsp;                        r.add(atype.getSubMunitionName());</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                r.addDesc(entityTarget);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                r.messageId = 3120;</b>
<b class="nc">&nbsp;                r.add(target.getDisplayName(), true);</b>
&nbsp;            }
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;            
&nbsp;            //Point Defense fire vs Capital Missiles
&nbsp;            
&nbsp;            // are we a glancing hit?  Check for this here, report it later
<b class="nc">&nbsp;            setGlancingBlowFlags(entityTarget);</b>
&nbsp;            
&nbsp;            // Set Margin of Success/Failure and check for Direct Blows
<b class="nc">&nbsp;            toHit.setMoS(roll - Math.max(2, toHit.getValue()));</b>
<b class="nc">&nbsp;            bDirect = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_DIRECT_BLOW)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((toHit.getMoS() / 3) &gt;= 1) &amp;&amp; (entityTarget != null);</b>
&nbsp;
&nbsp;	        //This has to be up here so that we don&#39;t screw up glancing/direct blow reports
<b class="nc">&nbsp;	        attackValue = calcAttackValue();</b>
&nbsp;	        
&nbsp;	        //CalcAttackValue triggers counterfire, so now we can safely get this
<b class="nc">&nbsp;	        CapMissileAMSMod = getCapMissileAMSMod();</b>
&nbsp;	        
&nbsp;	        //Only do this if the missile wasn&#39;t destroyed
<b class="nc">&nbsp;	        if (CapMissileAMSMod &gt; 0 &amp;&amp; CapMissileArmor &gt; 0) {</b>
<b class="nc">&nbsp;	        	toHit.addModifier(CapMissileAMSMod, &quot;Damage from Point Defenses&quot;);</b>
<b class="nc">&nbsp;	        	if (roll &lt; toHit.getValue()) {</b>
<b class="nc">&nbsp;	        		CapMissileMissed = true;</b>
&nbsp;	        	}
&nbsp;	        }
&nbsp;
&nbsp;	        // Report any AMS bay action against Capital missiles that doesn&#39;t destroy them all.
<b class="nc">&nbsp;	        if (amsBayEngagedCap &amp;&amp; CapMissileArmor &gt; 0) {</b>
<b class="nc">&nbsp;                r = new Report(3358);</b>
<b class="nc">&nbsp;                r.add(CapMissileAMSMod);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            	        
&nbsp;	        // Report any PD bay action against Capital missiles that doesn&#39;t destroy them all.
<b class="nc">&nbsp;        	} else if (pdBayEngagedCap &amp;&amp; CapMissileArmor &gt; 0) {</b>
<b class="nc">&nbsp;                r = new Report(3357);</b>
<b class="nc">&nbsp;                r.add(CapMissileAMSMod);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            }
&nbsp;	        
&nbsp;	        // Report AMS/Pointdefense failure due to Overheating.
<b class="nc">&nbsp;            if (pdOverheated </b>
&nbsp;                    &amp;&amp; (!(amsBayEngaged
&nbsp;                            || amsBayEngagedCap
&nbsp;                            || amsBayEngagedMissile
&nbsp;                            || pdBayEngaged
&nbsp;                            || pdBayEngagedCap
&nbsp;                            || pdBayEngagedMissile))) {
<b class="nc">&nbsp;                r = new Report (3359);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;            } else if (pdOverheated) {</b>
&nbsp;                //Report a partial failure
<b class="nc">&nbsp;                r = new Report (3361);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r); </b>
&nbsp;            }
&nbsp;	        
<b class="nc">&nbsp;            if (toHit.getValue() == TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;                r = new Report(3135);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                returnedReports.addAll(vPhaseReport);</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else if (toHit.getValue() == TargetRoll.AUTOMATIC_FAIL) {</b>
<b class="nc">&nbsp;                r = new Report(3140);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;            } else if (toHit.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</b>
<b class="nc">&nbsp;                r = new Report(3145);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(toHit.getDesc());</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            } else {
&nbsp;                // roll to hit
<b class="nc">&nbsp;                r = new Report(3150);</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(toHit.getValue());</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            }
&nbsp;
&nbsp;            // dice have been rolled, thanks
<b class="nc">&nbsp;            r = new Report(3155);</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.add(roll);</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;
&nbsp;            // do we hit?
<b class="nc">&nbsp;            bMissed = roll &lt; toHit.getValue();</b>
&nbsp;       
&nbsp;
&nbsp;            //Report Glancing/Direct Blow here because of Capital Missile weirdness
&nbsp;            //TODO: Can&#39;t figure out a good way to make Capital Missile bays report direct/glancing blows
&nbsp;            //when Advanced Point Defense is on, but they work correctly.
<b class="nc">&nbsp;            if(!(amsBayEngagedCap || pdBayEngagedCap)) {</b>
<b class="nc">&nbsp;                addGlancingBlowReports(vPhaseReport);</b>
&nbsp;    
<b class="nc">&nbsp;                if (bDirect) {</b>
<b class="nc">&nbsp;                    r = new Report(3189);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.newlines = 0;</b>
<b class="nc">&nbsp;                    vPhaseReport.addElement(r);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Do this stuff first, because some weapon&#39;s miss report reference
&nbsp;            // the amount of shots fired and stuff.
<b class="nc">&nbsp;            Vector&lt;Report&gt; dmgPerHitReport = new Vector&lt;&gt;();</b>
<b class="nc">&nbsp;            nDamPerHit = calcDamagePerHit();</b>
<b class="nc">&nbsp;            if (!heatAdded) {</b>
<b class="nc">&nbsp;                addHeat();</b>
<b class="nc">&nbsp;                heatAdded = true;</b>
&nbsp;            }
&nbsp;	        
&nbsp;            
&nbsp;            
&nbsp;	        // Report any AMS bay action against standard missiles.
<b class="nc">&nbsp;            CounterAV = getCounterAV();</b>
&nbsp;            //use this if counterfire destroys all the missiles
<b class="nc">&nbsp;	        if (amsBayEngaged &amp;&amp; (attackValue &lt;= 0)) {</b>
<b class="nc">&nbsp;	        	r = new Report(3356);</b>
<b class="nc">&nbsp;	        	r.indent();</b>
<b class="nc">&nbsp;	        	r.subject = subjectId;</b>
<b class="nc">&nbsp;	        	vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;	        } else if (amsBayEngaged) {</b>
<b class="nc">&nbsp;	        	r = new Report(3354);</b>
<b class="nc">&nbsp;	        	r.indent();</b>
<b class="nc">&nbsp;	        	r.add(CounterAV);</b>
<b class="nc">&nbsp;	        	r.subject = subjectId;</b>
<b class="nc">&nbsp;	        	vPhaseReport.addElement(r);</b>
&nbsp;	        }
&nbsp;	        
&nbsp;            //use this if AMS counterfire destroys all the Capital missiles
<b class="nc">&nbsp;            if (amsBayEngagedCap &amp;&amp; (CapMissileArmor &lt;= 0)) {</b>
<b class="nc">&nbsp;                r = new Report(3356);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            } 
&nbsp;	        
&nbsp;	        // Report any Point Defense bay action against standard missiles.
<b class="nc">&nbsp;	        if (pdBayEngaged &amp;&amp; (attackValue &lt;= 0)) {</b>
<b class="nc">&nbsp;	        	r = new Report(3355);</b>
<b class="nc">&nbsp;	        	r.subject = subjectId;</b>
<b class="nc">&nbsp;	        	vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;	        } else if (pdBayEngaged) {</b>
<b class="nc">&nbsp;	        	r = new Report(3353);</b>
<b class="nc">&nbsp;	        	r.add(CounterAV);</b>
<b class="nc">&nbsp;	        	r.subject = subjectId;</b>
<b class="nc">&nbsp;	        	vPhaseReport.addElement(r);</b>
&nbsp;	        }
&nbsp;	        
&nbsp;            //use this if PD counterfire destroys all the Capital missiles
<b class="nc">&nbsp;            if (pdBayEngagedCap &amp;&amp; (CapMissileArmor &lt;= 0)) {</b>
<b class="nc">&nbsp;                r = new Report(3355);</b>
<b class="nc">&nbsp;                r.indent();</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            }
&nbsp;	        
&nbsp;            // Any necessary PSRs, jam checks, etc.
&nbsp;            // If this boolean is true, don&#39;t report
&nbsp;            // the miss later, as we already reported
&nbsp;            // it in doChecks
<b class="nc">&nbsp;            boolean missReported = doChecks(vPhaseReport);</b>
<b class="nc">&nbsp;            if (missReported) {</b>
<b class="nc">&nbsp;                bMissed = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Do we need some sort of special resolution (minefields,
&nbsp;            // artillery,
<b class="nc">&nbsp;            if (specialResolution(vPhaseReport, entityTarget) &amp;&amp; (i &lt; 2)) {</b>
<b class="nc">&nbsp;                returnedReports.addAll(vPhaseReport);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (bMissed &amp;&amp; !missReported) {</b>
<b class="nc">&nbsp;                if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UAC_TWOROLLS)</b>
<b class="nc">&nbsp;                        &amp;&amp; ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA) || (wtype</b>
<b class="nc">&nbsp;                                .getAmmoType() == AmmoType.T_AC_ULTRA_THB))</b>
&nbsp;                        &amp;&amp; (i == 2)) {
<b class="nc">&nbsp;                    reportMiss(vPhaseReport, true);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    reportMiss(vPhaseReport);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Works out fire setting, AMS shots, and whether continuation
&nbsp;                // is necessary.
<b class="nc">&nbsp;                if (!handleSpecialMiss(entityTarget, bldgDamagedOnMiss, bldg,</b>
&nbsp;                        vPhaseReport) &amp;&amp; (i &lt; 2)) {
<b class="nc">&nbsp;                    returnedReports.addAll(vPhaseReport);</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // yeech. handle damage. . different weapons do this in very
&nbsp;            // different
&nbsp;            // ways
<b class="nc">&nbsp;            int nCluster = calcnCluster();</b>
<b class="nc">&nbsp;            int id = vPhaseReport.size();</b>
<b class="nc">&nbsp;            int hits = calcHits(vPhaseReport);</b>
<b class="nc">&nbsp;            if ((target.isAirborne() &amp;&amp; !waa.isGroundToAir(game)) || game.getBoard().inSpace() || ae.usesWeaponBays()) {</b>
&nbsp;                // if we added a line to the phase report for calc hits, remove
&nbsp;                // it now
<b class="nc">&nbsp;                while (vPhaseReport.size() &gt; id) {</b>
<b class="nc">&nbsp;                    vPhaseReport.removeElementAt(vPhaseReport.size() - 1);</b>
&nbsp;                }
<b class="nc">&nbsp;                int[] aeroResults = calcAeroDamage(entityTarget, vPhaseReport);</b>
<b class="nc">&nbsp;                hits = aeroResults[0];</b>
&nbsp;                // If our capital missile was destroyed, it shouldn&#39;t hit
<b class="nc">&nbsp;                if ((amsBayEngagedCap || pdBayEngagedCap) &amp;&amp; (CapMissileArmor &lt;= 0)) {</b>
<b class="nc">&nbsp;                    hits = 0;</b>
&nbsp;                }
<b class="nc">&nbsp;                nCluster = aeroResults[1];</b>
&nbsp;            }
&nbsp;
&nbsp;            // We have to adjust the reports on a miss, so they line up
<b class="nc">&nbsp;            if (bMissed &amp;&amp; id != vPhaseReport.size()) {</b>
<b class="nc">&nbsp;                vPhaseReport.get(id - 1).newlines--;</b>
<b class="nc">&nbsp;                vPhaseReport.get(id).indent(2);</b>
<b class="nc">&nbsp;                vPhaseReport.get(vPhaseReport.size() - 1).newlines++;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!bMissed) {</b>
<b class="nc">&nbsp;                vPhaseReport.addAll(dmgPerHitReport);</b>
&nbsp;                // Buildings shield all units from a certain amount of damage.
&nbsp;                // Amount is based upon the building&#39;s CF at the phase&#39;s start.
<b class="nc">&nbsp;                int bldgAbsorbs = 0;</b>
<b class="nc">&nbsp;                if (targetInBuilding &amp;&amp; (bldg != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (toHit.getThruBldg() == null)) {</b>
<b class="nc">&nbsp;                    bldgAbsorbs = bldg.getAbsorbtion(target.getPosition());</b>
&nbsp;                }
&nbsp;                
&nbsp;                // Attacking infantry in buildings from same building
<b class="nc">&nbsp;                if (targetInBuilding &amp;&amp; (bldg != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; (toHit.getThruBldg() != null)</b>
&nbsp;                        &amp;&amp; (entityTarget instanceof Infantry)) {
&nbsp;                    // If elevation is the same, building doesn&#39;t absorb
<b class="nc">&nbsp;                    if (ae.getElevation() != entityTarget.getElevation()) {</b>
<b class="nc">&nbsp;                        int dmgClass = wtype.getInfantryDamageClass();</b>
&nbsp;                        int nDamage;
<b class="nc">&nbsp;                        if (dmgClass &lt; WeaponType.WEAPON_BURST_1D6) {</b>
<b class="nc">&nbsp;                            nDamage = nDamPerHit * Math.min(nCluster, hits);</b>
&nbsp;                        } else {
&nbsp;                            // Need to indicate to handleEntityDamage that the
&nbsp;                            // absorbed damage shouldn&#39;t reduce incoming damage,
&nbsp;                            // since the incoming damage was reduced in
&nbsp;                            // Compute.directBlowInfantryDamage
<b class="nc">&nbsp;                            nDamage = -wtype.getDamage(nRange)</b>
<b class="nc">&nbsp;                                    * Math.min(nCluster, hits);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        bldgAbsorbs = (int) Math.round(nDamage</b>
<b class="nc">&nbsp;                                * bldg.getInfDmgFromInside());</b>
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        // Used later to indicate a special report
<b class="nc">&nbsp;                        bldgAbsorbs = Integer.MIN_VALUE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Make sure the player knows when his attack causes no damage.
<b class="nc">&nbsp;                if (hits == 0) {</b>
<b class="nc">&nbsp;                    r = new Report(3365);</b>
<b class="nc">&nbsp;                    r.subject = subjectId;</b>
<b class="nc">&nbsp;                    vPhaseReport.addElement(r);</b>
&nbsp;                }
&nbsp;
&nbsp;                // for each cluster of hits, do a chunk of damage
<b class="nc">&nbsp;                while (hits &gt; 0) {</b>
&nbsp;                    int nDamage;
<b class="nc">&nbsp;                    if ((target.getTargetType() == Targetable.TYPE_HEX_TAG)</b>
<b class="nc">&nbsp;                            || (target.getTargetType() == Targetable.TYPE_BLDG_TAG)) {</b>
<b class="nc">&nbsp;                        int priority = 1;</b>
<b class="nc">&nbsp;                        EquipmentMode mode = (weapon.curMode());</b>
<b class="nc">&nbsp;                        if (mode != null) {</b>
<b class="nc">&nbsp;                            if (mode.getName() == &quot;1-shot&quot;) {</b>
<b class="nc">&nbsp;                                priority = 1;</b>
<b class="nc">&nbsp;                            } else if (mode.getName() == &quot;2-shot&quot;) {</b>
<b class="nc">&nbsp;                                priority = 2;</b>
<b class="nc">&nbsp;                            } else if (mode.getName() == &quot;3-shot&quot;) {</b>
<b class="nc">&nbsp;                                priority = 3;</b>
<b class="nc">&nbsp;                            } else if (mode.getName() == &quot;4-shot&quot;) {</b>
<b class="nc">&nbsp;                                priority = 4;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        TagInfo info = new TagInfo(ae.getId(),</b>
<b class="nc">&nbsp;                                target.getTargetType(), target, priority, false);</b>
<b class="nc">&nbsp;                        game.addTagInfo(info);</b>
&nbsp;                        
<b class="nc">&nbsp;                        ae.setSpotting(true);</b>
<b class="nc">&nbsp;                        ae.setSpotTargetId(target.getTargetId());</b>
&nbsp;                        
<b class="nc">&nbsp;                        r = new Report(3390);</b>
<b class="nc">&nbsp;                        r.subject = subjectId;</b>
<b class="nc">&nbsp;                        vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                        hits = 0;</b>
&nbsp;                    // targeting a hex for igniting    
<b class="nc">&nbsp;                    } else if ((target.getTargetType() == Targetable.TYPE_HEX_IGNITE)</b>
<b class="nc">&nbsp;                            || (target.getTargetType() == Targetable.TYPE_BLDG_IGNITE)) {</b>
<b class="nc">&nbsp;                        handleIgnitionDamage(vPhaseReport, bldg, hits);</b>
<b class="nc">&nbsp;                        hits = 0;</b>
&nbsp;                    // targeting a hex for clearing
<b class="nc">&nbsp;                    } else if (target.getTargetType() == Targetable.TYPE_HEX_CLEAR) {</b>
<b class="nc">&nbsp;                        nDamage = nDamPerHit * hits;</b>
<b class="nc">&nbsp;                        handleClearDamage(vPhaseReport, bldg, nDamage);</b>
<b class="nc">&nbsp;                        hits = 0;</b>
&nbsp;                    // Targeting a building.
<b class="nc">&nbsp;                    } else if (target.getTargetType() == Targetable.TYPE_BUILDING) {</b>
&nbsp;                        // The building takes the full brunt of the attack.
<b class="nc">&nbsp;                        nDamage = nDamPerHit * hits;</b>
<b class="nc">&nbsp;                        handleBuildingDamage(vPhaseReport, bldg, nDamage,</b>
<b class="nc">&nbsp;                                target.getPosition());</b>
<b class="nc">&nbsp;                        hits = 0;</b>
<b class="nc">&nbsp;                    } else if (entityTarget != null) {</b>
<b class="nc">&nbsp;                        handleEntityDamage(entityTarget, vPhaseReport, bldg,</b>
&nbsp;                                hits, nCluster, bldgAbsorbs);
<b class="nc">&nbsp;                        server.creditKill(entityTarget, ae);</b>
<b class="nc">&nbsp;                        hits -= nCluster;</b>
<b class="nc">&nbsp;                        firstHit = false;</b>
&nbsp;                    } else {
&nbsp;                        // we shouldn&#39;t be here, but if we get here, let&#39;s set hits to 0
&nbsp;                        // to avoid infinite loops
<b class="nc">&nbsp;                        hits = 0;</b>
<b class="nc">&nbsp;                        MegaMek.getLogger().error(&quot;Unexpected target type: &quot; + target.getTargetType());</b>
&nbsp;                    }
&nbsp;                } // Handle the next cluster.
<b class="nc">&nbsp;            } else { // We missed, but need to handle special miss cases</b>
&nbsp;
&nbsp;                // When shooting at a non-infantry unit in a building and the
&nbsp;                // shot misses, the building is damaged instead, TW pg 171
<b class="nc">&nbsp;                if (bldgDamagedOnMiss) {</b>
<b class="nc">&nbsp;                    r = new Report(6429);</b>
<b class="nc">&nbsp;                    r.indent(2);</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    r.newlines--;</b>
<b class="nc">&nbsp;                    vPhaseReport.add(r);</b>
<b class="nc">&nbsp;                    int nDamage = nDamPerHit * hits;</b>
&nbsp;                    // We want to set bSalvo to true to prevent
&nbsp;                    // handleBuildingDamage from reporting a hit
<b class="nc">&nbsp;                    boolean savedSalvo = bSalvo;</b>
<b class="nc">&nbsp;                    bSalvo = true;</b>
<b class="nc">&nbsp;                    handleBuildingDamage(vPhaseReport, bldg, nDamage,</b>
<b class="nc">&nbsp;                            target.getPosition());</b>
<b class="nc">&nbsp;                    bSalvo = savedSalvo;</b>
<b class="nc">&nbsp;                    hits = 0;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UAC_TWOROLLS)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA) || (wtype</b>
<b class="nc">&nbsp;                            .getAmmoType() == AmmoType.T_AC_ULTRA_THB))</b>
&nbsp;                    &amp;&amp; (i == 2)) {
&nbsp;                // Jammed weapon doesn&#39;t get 2nd shot...
<b class="nc">&nbsp;                if (isJammed) {</b>
<b class="nc">&nbsp;                    r = new Report(9905);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                    i--;</b>
&nbsp;                } else { // If not jammed, it gets the second shot...
<b class="nc">&nbsp;                    r = new Report(9900);</b>
<b class="nc">&nbsp;                    r.indent();</b>
<b class="nc">&nbsp;                    r.subject = ae.getId();</b>
<b class="nc">&nbsp;                    vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;                    if (null != ae.getCrew()) {</b>
<b class="nc">&nbsp;                        roll = ae.getCrew().rollGunnerySkill();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        roll = Compute.d6(2);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Report.addNewline(vPhaseReport);</b>
&nbsp;
<b class="nc">&nbsp;        insertAttacks(phase, vPhaseReport);</b>
&nbsp;
<b class="nc">&nbsp;        returnedReports.addAll(vPhaseReport);</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate the damage per hit.
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;int&lt;/code&gt; representing the damage dealt per hit.
&nbsp;     */
&nbsp;    protected int calcDamagePerHit() {
<b class="nc">&nbsp;        double toReturn = wtype.getDamage(nRange);</b>
&nbsp;
&nbsp;        // Check for BA vs BA weapon effectiveness, if option is on
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_BA_VS_BA)</b>
&nbsp;                &amp;&amp; (target instanceof BattleArmor)) {
&nbsp;            // We don&#39;t check to make sure the attacker is BA, as most weapons
&nbsp;            // will return their normal damage.
<b class="nc">&nbsp;            toReturn = Compute.directBlowBADamage(toReturn,</b>
<b class="nc">&nbsp;                    wtype.getBADamageClass(), (BattleArmor) target);</b>
&nbsp;        }
&nbsp;
&nbsp;        // we default to direct fire weapons for anti-infantry damage
<b class="nc">&nbsp;        if ((target instanceof Infantry) &amp;&amp; !(target instanceof BattleArmor)) {</b>
<b class="nc">&nbsp;            toReturn = Compute.directBlowInfantryDamage(toReturn,</b>
<b class="nc">&nbsp;                    bDirect ? toHit.getMoS() / 3 : 0,</b>
<b class="nc">&nbsp;                    wtype.getInfantryDamageClass(),</b>
<b class="nc">&nbsp;                    ((Infantry) target).isMechanized(),</b>
<b class="nc">&nbsp;                    toHit.getThruBldg() != null, ae.getId(), calcDmgPerHitReport);</b>
<b class="nc">&nbsp;        } else if (bDirect) {</b>
<b class="nc">&nbsp;            toReturn = Math.min(toReturn + (toHit.getMoS() / 3), toReturn * 2);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        toReturn = applyGlancingBlowModifier(toReturn, </b>
&nbsp;                            (target instanceof Infantry) &amp;&amp; !(target instanceof BattleArmor));
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE)</b>
<b class="nc">&nbsp;                &amp;&amp; (nRange &gt; wtype.getRanges(weapon)[RangeType.RANGE_LONG])) {</b>
<b class="nc">&nbsp;            toReturn = (int) Math.floor(toReturn * .75);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(</b>
&nbsp;                OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE)
<b class="nc">&nbsp;                &amp;&amp; (nRange &gt; wtype.getRanges(weapon)[RangeType.RANGE_EXTREME])) {</b>
<b class="nc">&nbsp;            toReturn = (int) Math.floor(toReturn * .5);</b>
&nbsp;        }
<b class="nc">&nbsp;        return (int) toReturn;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate the attack value based on range
&nbsp;     *
&nbsp;     * @return an &lt;code&gt;int&lt;/code&gt; representing the attack value at that range.
&nbsp;     */
&nbsp;    protected int calcAttackValue() {
<b class="nc">&nbsp;        int av = 0;</b>
&nbsp;        // if we have a ground firing unit, then AV should not be determined by
&nbsp;        // aero range brackets
<b class="nc">&nbsp;        if (!ae.isAirborne() || game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_UAC_TWOROLLS)) {</b>
<b class="nc">&nbsp;            if (usesClusterTable()) {</b>
&nbsp;                // for cluster weapons just use the short range AV
<b class="nc">&nbsp;                av = wtype.getRoundShortAV();</b>
&nbsp;            } else {
&nbsp;                // otherwise just use the full weapon damage by range
<b class="nc">&nbsp;                av = wtype.getDamage(nRange);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // we have an airborne attacker, so we need to use aero range
&nbsp;            // brackets
<b class="nc">&nbsp;            int range = RangeType.rangeBracket(nRange, wtype.getATRanges(),</b>
&nbsp;                    true, false);
<b class="nc">&nbsp;            if (range == WeaponType.RANGE_SHORT) {</b>
<b class="nc">&nbsp;                av = wtype.getRoundShortAV();</b>
<b class="nc">&nbsp;            } else if (range == WeaponType.RANGE_MED) {</b>
<b class="nc">&nbsp;                av = wtype.getRoundMedAV();</b>
<b class="nc">&nbsp;            } else if (range == WeaponType.RANGE_LONG) {</b>
<b class="nc">&nbsp;                av = wtype.getRoundLongAV();</b>
<b class="nc">&nbsp;            } else if (range == WeaponType.RANGE_EXT) {</b>
<b class="nc">&nbsp;                av = wtype.getRoundExtAV();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (bDirect) {</b>
<b class="nc">&nbsp;            av = Math.min(av + (toHit.getMoS() / 3), av * 2);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        av = applyGlancingBlowModifier(av, false);</b>
&nbsp;        
<b class="nc">&nbsp;        av = (int) Math.floor(getBracketingMultiplier() * av);</b>
&nbsp;
<b class="nc">&nbsp;        return av;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * * adjustment factor on attack value for fighter squadrons
&nbsp;     */
&nbsp;    protected double getBracketingMultiplier() {
<b class="nc">&nbsp;        double mult = 1.0;</b>
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(&quot;Bracket 80%&quot;)) {</b>
<b class="nc">&nbsp;            mult = 0.8;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(&quot;Bracket 60%&quot;)) {</b>
<b class="nc">&nbsp;            mult = 0.6;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (wtype.hasModes() &amp;&amp; weapon.curMode().equals(&quot;Bracket 40%&quot;)) {</b>
<b class="nc">&nbsp;            mult = 0.4;</b>
&nbsp;        }
<b class="nc">&nbsp;        return mult;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Return the capital missile target for criticals. Zero if not a capital
&nbsp;     * missile
&nbsp;     */
&nbsp;    protected int getCapMisMod() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handles potential damage to partial cover that absorbs a shot. The
&nbsp;     * &lt;code&gt;ToHitData&lt;/code&gt; is checked to what if there is any damagable cover
&nbsp;     * to be hit, and if so which cover gets hit (there are two possibilities in
&nbsp;     * some cases, such as 75% partial cover). The method then takes care of
&nbsp;     * assigning damage to the cover. Buildings are damaged directly, while
&nbsp;     * dropships call the &lt;code&gt;handleEntityDamage&lt;/code&gt; method.
&nbsp;     *
&nbsp;     * @param entityTarget
&nbsp;     *            The target Entity
&nbsp;     * @param vPhaseReport
&nbsp;     * @param pcHit
&nbsp;     * @param bldg
&nbsp;     * @param hits
&nbsp;     * @param nCluster
&nbsp;     * @param bldgAbsorbs
&nbsp;     */
&nbsp;    protected void handlePartialCoverHit(Entity entityTarget,
&nbsp;            Vector&lt;Report&gt; vPhaseReport, HitData pcHit, Building bldg,
&nbsp;            int hits, int nCluster, int bldgAbsorbs) {
&nbsp;
&nbsp;        // Report the hit and table description, if this isn&#39;t part of a salvo
&nbsp;        Report r;
<b class="nc">&nbsp;        if (!bSalvo) {</b>
<b class="nc">&nbsp;            r = new Report(3405);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;            r.add(entityTarget.getLocationAbbr(pcHit));</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;            if (weapon.isRapidfire()) {</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r = new Report(3225);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(numRapidFireHits * 3);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // Keep spacing consistent
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        r = new Report(3460);</b>
<b class="nc">&nbsp;        r.subject = subjectId;</b>
<b class="nc">&nbsp;        r.add(entityTarget.getShortName());</b>
<b class="nc">&nbsp;        r.add(entityTarget.getLocationAbbr(pcHit));</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        vPhaseReport.addElement(r);</b>
&nbsp;
<b class="nc">&nbsp;        int damagableCoverType = LosEffects.DAMAGABLE_COVER_NONE;</b>
<b class="nc">&nbsp;        Building coverBuilding = null;</b>
<b class="nc">&nbsp;        Entity coverDropship = null;</b>
<b class="nc">&nbsp;        Coords coverLoc = null;</b>
&nbsp;
&nbsp;        // Determine if there is primary and secondary cover,
&nbsp;        // and then determine which one gets hit
<b class="nc">&nbsp;        if ((toHit.getCover() == LosEffects.COVER_75RIGHT || toHit.getCover() == LosEffects.COVER_75LEFT)</b>
&nbsp;                ||
&nbsp;                // 75% cover has a primary and secondary
<b class="nc">&nbsp;                (toHit.getCover() == LosEffects.COVER_HORIZONTAL &amp;&amp; toHit</b>
<b class="nc">&nbsp;                        .getDamagableCoverTypeSecondary() != LosEffects.DAMAGABLE_COVER_NONE)) {</b>
&nbsp;            // Horiztonal cover provided by two 25%&#39;s, so primary and secondary
<b class="nc">&nbsp;            int hitLoc = pcHit.getLocation();</b>
&nbsp;            // Primary stores the left side, from the perspective of the
&nbsp;            // attacker
<b class="nc">&nbsp;            if (hitLoc == Mech.LOC_RLEG || hitLoc == Mech.LOC_RT</b>
&nbsp;                    || hitLoc == Mech.LOC_RARM) {
&nbsp;                // Left side is primary
<b class="nc">&nbsp;                damagableCoverType = toHit.getDamagableCoverTypePrimary();</b>
<b class="nc">&nbsp;                coverBuilding = toHit.getCoverBuildingPrimary();</b>
<b class="nc">&nbsp;                coverDropship = toHit.getCoverDropshipPrimary();</b>
<b class="nc">&nbsp;                coverLoc = toHit.getCoverLocPrimary();</b>
&nbsp;            } else {
&nbsp;                // If not left side, then right side, which is secondary
<b class="nc">&nbsp;                damagableCoverType = toHit.getDamagableCoverTypeSecondary();</b>
<b class="nc">&nbsp;                coverBuilding = toHit.getCoverBuildingSecondary();</b>
<b class="nc">&nbsp;                coverDropship = toHit.getCoverDropshipSecondary();</b>
<b class="nc">&nbsp;                coverLoc = toHit.getCoverLocSecondary();</b>
&nbsp;            }
<b class="nc">&nbsp;        } else { // Only primary cover exists</b>
<b class="nc">&nbsp;            damagableCoverType = toHit.getDamagableCoverTypePrimary();</b>
<b class="nc">&nbsp;            coverBuilding = toHit.getCoverBuildingPrimary();</b>
<b class="nc">&nbsp;            coverDropship = toHit.getCoverDropshipPrimary();</b>
<b class="nc">&nbsp;            coverLoc = toHit.getCoverLocPrimary();</b>
&nbsp;        }
&nbsp;        // Check if we need to damage the cover that absorbed the hit.
<b class="nc">&nbsp;        if (damagableCoverType == LosEffects.DAMAGABLE_COVER_DROPSHIP) {</b>
&nbsp;            // We need to adjust some state and then restore it later
&nbsp;            // This allows us to make a call to handleEntityDamage
<b class="nc">&nbsp;            ToHitData savedToHit = toHit;</b>
<b class="nc">&nbsp;            int savedAimingMode = waa.getAimingMode();</b>
<b class="nc">&nbsp;            waa.setAimingMode(IAimingModes.AIM_MODE_NONE);</b>
<b class="nc">&nbsp;            int savedAimedLocation = waa.getAimedLocation();</b>
<b class="nc">&nbsp;            waa.setAimedLocation(Entity.LOC_NONE);</b>
<b class="nc">&nbsp;            boolean savedSalvo = bSalvo;</b>
<b class="nc">&nbsp;            bSalvo = true;</b>
&nbsp;            // Create new toHitData
<b class="nc">&nbsp;            toHit = new ToHitData(0, &quot;&quot;, ToHitData.HIT_NORMAL,</b>
<b class="nc">&nbsp;                    Compute.targetSideTable(ae, coverDropship));</b>
&nbsp;            // Report cover was damaged
<b class="nc">&nbsp;            int sizeBefore = vPhaseReport.size();</b>
<b class="nc">&nbsp;            r = new Report(3465);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.add(coverDropship.getShortName());</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;            // Damage the dropship
<b class="nc">&nbsp;            handleEntityDamage(coverDropship, vPhaseReport, bldg, hits,</b>
&nbsp;                    nCluster, bldgAbsorbs);
&nbsp;            // Remove a blank line in the report list
<b class="nc">&nbsp;            if (vPhaseReport.elementAt(sizeBefore).newlines &gt; 0)</b>
<b class="nc">&nbsp;                vPhaseReport.elementAt(sizeBefore).newlines--;</b>
&nbsp;            // Indent reports related to the damage absorption
<b class="nc">&nbsp;            while (sizeBefore &lt; vPhaseReport.size()) {</b>
<b class="nc">&nbsp;                vPhaseReport.elementAt(sizeBefore).indent(3);</b>
<b class="nc">&nbsp;                sizeBefore++;</b>
&nbsp;            }
&nbsp;            // Restore state
<b class="nc">&nbsp;            toHit = savedToHit;</b>
<b class="nc">&nbsp;            waa.setAimingMode(savedAimingMode);</b>
<b class="nc">&nbsp;            waa.setAimedLocation(savedAimedLocation);</b>
<b class="nc">&nbsp;            bSalvo = savedSalvo;</b>
&nbsp;            // Damage a building that blocked a shot
<b class="nc">&nbsp;        } else if (damagableCoverType == LosEffects.DAMAGABLE_COVER_BUILDING) {</b>
&nbsp;            // Normal damage
<b class="nc">&nbsp;            int nDamage = nDamPerHit * Math.min(nCluster, hits);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = server.damageBuilding(</b>
&nbsp;                    coverBuilding, nDamage, &quot; blocks the shot and takes &quot;,
&nbsp;                    coverLoc);
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = subjectId;</b>
<b class="nc">&nbsp;                report.indent();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(buildingReport);</b>
&nbsp;            // Damage any infantry in the building.
<b class="nc">&nbsp;            Vector&lt;Report&gt; infantryReport = server.damageInfantryIn(</b>
&nbsp;                    coverBuilding, nDamage, coverLoc,
<b class="nc">&nbsp;                    wtype.getInfantryDamageClass());</b>
<b class="nc">&nbsp;            for (Report report : infantryReport) {</b>
<b class="nc">&nbsp;                report.indent(2);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(infantryReport);</b>
&nbsp;        }
<b class="nc">&nbsp;        missed = true;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handle damage against an entity, called once per hit by default.
&nbsp;     *
&nbsp;     * @param entityTarget
&nbsp;     * @param vPhaseReport
&nbsp;     * @param bldg
&nbsp;     * @param hits
&nbsp;     * @param nCluster
&nbsp;     * @param bldgAbsorbs
&nbsp;     */
&nbsp;    protected void handleEntityDamage(Entity entityTarget,
&nbsp;            Vector&lt;Report&gt; vPhaseReport, Building bldg, int hits, int nCluster,
&nbsp;            int bldgAbsorbs) {
&nbsp;        int nDamage;
<b class="nc">&nbsp;        missed = false;</b>
&nbsp;
<b class="nc">&nbsp;        initHit(entityTarget);</b>
&nbsp;        
<b class="nc">&nbsp;        boolean isIndirect = wtype.hasModes()</b>
<b class="nc">&nbsp;                &amp;&amp; weapon.curMode().equals(&quot;Indirect&quot;);</b>
<b class="nc">&nbsp;        IHex targetHex = game.getBoard().getHex(target.getPosition());</b>
&nbsp;
&nbsp;        //For indirect fire, remove leg hits only if target is in water partial cover
&nbsp;        //Per TW errata for indirect fire
<b class="nc">&nbsp;        if ((!isIndirect </b>
&nbsp;                || (isIndirect 
<b class="nc">&nbsp;                        &amp;&amp; targetHex.containsTerrain(Terrains.WATER) </b>
<b class="nc">&nbsp;                        &amp;&amp; entityTarget.relHeight() &lt;= targetHex.surface()))</b>
<b class="nc">&nbsp;                &amp;&amp; entityTarget.removePartialCoverHits(hit.getLocation(), toHit</b>
<b class="nc">&nbsp;                        .getCover(), Compute.targetSideTable(ae, entityTarget,</b>
<b class="nc">&nbsp;                        weapon.getCalledShot().getCall()))) {</b>
&nbsp;            // Weapon strikes Partial Cover.
<b class="nc">&nbsp;            handlePartialCoverHit(entityTarget, vPhaseReport, hit, bldg, hits,</b>
&nbsp;                    nCluster, bldgAbsorbs);
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!bSalvo) {</b>
&nbsp;            // Each hit in the salvo get&#39;s its own hit location.
<b class="nc">&nbsp;            Report r = new Report(3405);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.add(toHit.getTableDesc());</b>
<b class="nc">&nbsp;            r.add(entityTarget.getLocationAbbr(hit));</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;            if (weapon.isRapidfire()) {</b>
<b class="nc">&nbsp;                r.newlines = 0;</b>
<b class="nc">&nbsp;                r = new Report(3225);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                r.add(numRapidFireHits * 3);</b>
<b class="nc">&nbsp;                vPhaseReport.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
&nbsp;        }
&nbsp;
&nbsp;        // for non-salvo shots, report that the aimed shot was successfull
&nbsp;        // before applying damage
<b class="nc">&nbsp;        if (hit.hitAimedLocation() &amp;&amp; !bSalvo) {</b>
<b class="nc">&nbsp;            Report r = new Report(3410);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            vPhaseReport.lastElement().newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;        }
&nbsp;        // Resolve damage normally.
<b class="nc">&nbsp;        nDamage = nDamPerHit * Math.min(nCluster, hits);</b>
&nbsp;
<b class="nc">&nbsp;        if (bDirect) {</b>
<b class="nc">&nbsp;            hit.makeDirectBlow(toHit.getMoS() / 3);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Report calcDmgPerHitReports here
<b class="nc">&nbsp;        if (calcDmgPerHitReport.size() &gt; 0) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(calcDmgPerHitReport);</b>
&nbsp;        }
&nbsp;    
&nbsp;        // A building may be damaged, even if the squad is not.
<b class="nc">&nbsp;        if (bldgAbsorbs &gt; 0) {</b>
<b class="nc">&nbsp;            int toBldg = Math.min(bldgAbsorbs, nDamage);</b>
<b class="nc">&nbsp;            nDamage -= toBldg;</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = server.damageBuilding(bldg, toBldg,</b>
<b class="nc">&nbsp;                    entityTarget.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = subjectId;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(buildingReport);</b>
&nbsp;        // Units on same level, report building absorbs no damage
<b class="nc">&nbsp;        } else if (bldgAbsorbs == Integer.MIN_VALUE) {</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;            Report r = new Report(9976);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            vPhaseReport.add(r);</b>
&nbsp;        // Cases where absorbed damage doesn&#39;t reduce incoming damage
<b class="nc">&nbsp;        } else if (bldgAbsorbs &lt; 0) {</b>
<b class="nc">&nbsp;            int toBldg = -bldgAbsorbs;</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;            Vector&lt;Report&gt; buildingReport = server.damageBuilding(bldg, toBldg,</b>
<b class="nc">&nbsp;                    entityTarget.getPosition());</b>
<b class="nc">&nbsp;            for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;                report.subject = subjectId;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(buildingReport);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        nDamage = checkTerrain(nDamage, entityTarget, vPhaseReport);</b>
<b class="nc">&nbsp;        nDamage = checkLI(nDamage, entityTarget, vPhaseReport);</b>
&nbsp;
&nbsp;        // some buildings scale remaining damage that is not absorbed
&nbsp;        // TODO: this isn&#39;t quite right for castles brian
<b class="nc">&nbsp;        if (null != bldg) {</b>
<b class="nc">&nbsp;            nDamage = (int) Math.floor(bldg.getDamageToScale() * nDamage);</b>
&nbsp;        }
&nbsp;
&nbsp;        // A building may absorb the entire shot.
<b class="nc">&nbsp;        if (nDamage == 0) {</b>
<b class="nc">&nbsp;            Report r = new Report(3415);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.indent(2);</b>
<b class="nc">&nbsp;            r.addDesc(entityTarget);</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;            missed = true;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            if (bGlancing) {</b>
<b class="nc">&nbsp;                hit.makeGlancingBlow();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            if (bLowProfileGlancing) {</b>
<b class="nc">&nbsp;                hit.makeGlancingBlow();</b>
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            vPhaseReport</b>
<b class="nc">&nbsp;                    .addAll(server.damageEntity(entityTarget, hit, nDamage,</b>
<b class="nc">&nbsp;                            false, ae.getSwarmTargetId() == entityTarget</b>
<b class="nc">&nbsp;                                    .getId() ? DamageType.IGNORE_PASSENGER</b>
<b class="nc">&nbsp;                                    : damageType, false, false, throughFront,</b>
&nbsp;                            underWater, nukeS2S));
&nbsp;            // for salvo shots, report that the aimed location was hit after
&nbsp;            // applying damage, because the location is first reported when
&nbsp;            // dealing the damage
<b class="nc">&nbsp;            if (hit.hitAimedLocation() &amp;&amp; bSalvo) {</b>
<b class="nc">&nbsp;                Report r = new Report(3410);</b>
<b class="nc">&nbsp;                r.subject = subjectId;</b>
<b class="nc">&nbsp;                vPhaseReport.lastElement().newlines = 0;</b>
<b class="nc">&nbsp;                vPhaseReport.addElement(r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // If a BA squad is shooting at infantry, damage may be random and need
&nbsp;        // to be rerolled for the next hit (if any) from the same attack.
<b class="nc">&nbsp;        if ((ae instanceof BattleArmor) &amp;&amp; (target instanceof Infantry)) {</b>
<b class="nc">&nbsp;            nDamPerHit = calcDamagePerHit();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void handleIgnitionDamage(Vector&lt;Report&gt; vPhaseReport,
&nbsp;            Building bldg, int hits) {
<b class="nc">&nbsp;        if (!bSalvo) {</b>
&nbsp;            // hits!
<b class="nc">&nbsp;            Report r = new Report(2270);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        TargetRoll tn = new TargetRoll(wtype.getFireTN(), wtype.getName());</b>
<b class="nc">&nbsp;        if (tn.getValue() != TargetRoll.IMPOSSIBLE) {</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;            server.tryIgniteHex(target.getPosition(), subjectId, false, false,</b>
&nbsp;                    tn, true, -1, vPhaseReport);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void handleClearDamage(Vector&lt;Report&gt; vPhaseReport,
&nbsp;            Building bldg, int nDamage) {
<b class="nc">&nbsp;        handleClearDamage(vPhaseReport, bldg, nDamage, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void handleClearDamage(Vector&lt;Report&gt; vPhaseReport,
&nbsp;            Building bldg, int nDamage, boolean hitReport) {
<b class="nc">&nbsp;        if (!bSalvo &amp;&amp; hitReport) {</b>
&nbsp;            // hits!
<b class="nc">&nbsp;            Report r = new Report(2270);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;        }
&nbsp;        // report that damage was &quot;applied&quot; to terrain
<b class="nc">&nbsp;        Report r = new Report(3385);</b>
<b class="nc">&nbsp;        r.indent(2);</b>
<b class="nc">&nbsp;        r.subject = subjectId;</b>
<b class="nc">&nbsp;        r.add(nDamage);</b>
<b class="nc">&nbsp;        vPhaseReport.addElement(r);</b>
&nbsp;
&nbsp;        // Any clear attempt can result in accidental ignition, even
&nbsp;        // weapons that can&#39;t normally start fires. that&#39;s weird.
&nbsp;        // Buildings can&#39;t be accidentally ignited.
&nbsp;        // TODO: change this for TacOps - now you roll another 2d6 first and on
&nbsp;        // a 5 or less
&nbsp;        // you do a normal ignition as though for intentional fires
<b class="nc">&nbsp;        if ((bldg != null)</b>
<b class="nc">&nbsp;                &amp;&amp; server.tryIgniteHex(target.getPosition(), subjectId, false,</b>
&nbsp;                        false,
<b class="nc">&nbsp;                        new TargetRoll(wtype.getFireTN(), wtype.getName()), 5,</b>
&nbsp;                        vPhaseReport)) {
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        Vector&lt;Report&gt; clearReports = server.tryClearHex(target.getPosition(),</b>
&nbsp;                nDamage, subjectId);
<b class="nc">&nbsp;        if (clearReports.size() &gt; 0) {</b>
<b class="nc">&nbsp;            vPhaseReport.lastElement().newlines = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        vPhaseReport.addAll(clearReports);</b>
<b class="nc">&nbsp;        return;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void handleBuildingDamage(Vector&lt;Report&gt; vPhaseReport,
&nbsp;            Building bldg, int nDamage, Coords coords) {
<b class="nc">&nbsp;        if (!bSalvo) {</b>
&nbsp;            // hits!
<b class="nc">&nbsp;            Report r = new Report(3390);</b>
<b class="nc">&nbsp;            r.subject = subjectId;</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;        Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;        Vector&lt;Report&gt; buildingReport = server.damageBuilding(bldg, nDamage,</b>
&nbsp;                coords);
<b class="nc">&nbsp;        for (Report report : buildingReport) {</b>
<b class="nc">&nbsp;            report.subject = subjectId;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        vPhaseReport.addAll(buildingReport);</b>
&nbsp;
&nbsp;        // Damage any infantry in hex, unless attack between units in same bldg
<b class="nc">&nbsp;        if (toHit.getThruBldg() == null) {</b>
<b class="nc">&nbsp;            vPhaseReport.addAll(server.damageInfantryIn(bldg, nDamage, coords,</b>
<b class="nc">&nbsp;                    wtype.getInfantryDamageClass()));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected boolean allShotsHit() {
<b class="nc">&nbsp;        if ((((target.getTargetType() == Targetable.TYPE_BLDG_IGNITE) || (target</b>
<b class="nc">&nbsp;                .getTargetType() == Targetable.TYPE_BUILDING)) &amp;&amp; (nRange &lt;= 1))</b>
<b class="nc">&nbsp;                || (target.getTargetType() == Targetable.TYPE_HEX_CLEAR)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AERO_SANITY)</b>
<b class="nc">&nbsp;                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</b>
<b class="nc">&nbsp;                &amp;&amp; ((Entity) target).isCapitalScale()</b>
<b class="nc">&nbsp;                &amp;&amp; !((Entity) target).isCapitalFighter()</b>
<b class="nc">&nbsp;                &amp;&amp; !ae.isCapitalFighter()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void reportMiss(Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        reportMiss(vPhaseReport, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void reportMiss(Vector&lt;Report&gt; vPhaseReport, boolean singleNewline) {
&nbsp;        // Report the miss.
<b class="nc">&nbsp;        Report r = new Report(3220);</b>
<b class="nc">&nbsp;        r.subject = subjectId;</b>
<b class="nc">&nbsp;        if (singleNewline) {</b>
<b class="nc">&nbsp;            r.newlines = 1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            r.newlines = 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        vPhaseReport.addElement(r);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    protected WeaponHandler() {</b>
&nbsp;        // deserialization only
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Among other things, basically a refactored Server#preTreatWeaponAttack
<b class="nc">&nbsp;    public WeaponHandler(ToHitData t, WeaponAttackAction w, IGame g, Server s) {</b>
<b class="nc">&nbsp;        damageType = DamageType.NONE;</b>
<b class="nc">&nbsp;        toHit = t;</b>
<b class="nc">&nbsp;        waa = w;</b>
<b class="nc">&nbsp;        game = g;</b>
<b class="nc">&nbsp;        ae = game.getEntity(waa.getEntityId());</b>
<b class="nc">&nbsp;        weapon = ae.getEquipment(waa.getWeaponId());</b>
<b class="nc">&nbsp;        wtype = (WeaponType) weapon.getType();</b>
<b class="nc">&nbsp;        typeName = wtype.getInternalName();</b>
<b class="nc">&nbsp;        target = game.getTarget(waa.getTargetType(), waa.getTargetId());</b>
<b class="nc">&nbsp;        server = s;</b>
<b class="nc">&nbsp;        subjectId = getAttackerId();</b>
<b class="nc">&nbsp;        nRange = Compute.effectiveDistance(game, ae, target);</b>
<b class="nc">&nbsp;        if (target instanceof Mech) {</b>
<b class="nc">&nbsp;            throughFront = Compute.isThroughFrontHex(game, ae.getPosition(),</b>
&nbsp;                                                     (Entity) target);
&nbsp;        } else {
<b class="nc">&nbsp;            throughFront = true;</b>
&nbsp;        }
&nbsp;        // is this an underwater attack on a surface naval vessel?
<b class="nc">&nbsp;        underWater = toHit.getHitTable() == ToHitData.HIT_UNDERWATER;</b>
<b class="nc">&nbsp;        if (null != ae.getCrew()) {</b>
<b class="nc">&nbsp;            roll = ae.getCrew().rollGunnerySkill();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        nweapons = getNumberWeapons();</b>
<b class="nc">&nbsp;        nweaponsHit = 1;</b>
&nbsp;        // use ammo when creating this, so it works when shooting the last shot
&nbsp;        // a unit has and we fire multiple weapons of the same type
&nbsp;        // TODO: need to adjust this for cases where not all the ammo is
&nbsp;        // available
<b class="nc">&nbsp;        for (int i = 0; i &lt; nweapons; i++) {</b>
<b class="nc">&nbsp;            useAmmo();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (target instanceof Entity) {</b>
<b class="nc">&nbsp;            ((Entity) target).addAttackedByThisTurn(w.getEntityId());</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Worker function that initializes the actual hit, including a hit location and various other properties.
&nbsp;     * @param entityTarget Entity being hit.
&nbsp;     */
&nbsp;    protected void initHit(Entity entityTarget) {
<b class="nc">&nbsp;        hit = entityTarget.rollHitLocation(toHit.getHitTable(),</b>
<b class="nc">&nbsp;                toHit.getSideTable(), waa.getAimedLocation(),</b>
<b class="nc">&nbsp;                waa.getAimingMode(), toHit.getCover());</b>
<b class="nc">&nbsp;        hit.setGeneralDamageType(generalDamageType);</b>
<b class="nc">&nbsp;        hit.setCapital(wtype.isCapital());</b>
<b class="nc">&nbsp;        hit.setBoxCars(roll == 12);</b>
<b class="nc">&nbsp;        hit.setCapMisCritMod(getCapMisMod());</b>
<b class="nc">&nbsp;        hit.setFirstHit(firstHit);</b>
<b class="nc">&nbsp;        hit.setAttackerId(getAttackerId());</b>
&nbsp;        
<b class="nc">&nbsp;        if (weapon.isWeaponGroup()) {</b>
<b class="nc">&nbsp;            hit.setSingleAV(attackValue);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    protected void useAmmo() {
<b class="nc">&nbsp;        if (wtype.hasFlag(WeaponType.F_DOUBLE_ONESHOT)) {</b>
<b class="nc">&nbsp;            ArrayList&lt;Mounted&gt; chain = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Mounted current = weapon.getLinked(); current != null; current = current.getLinked()) {</b>
<b class="nc">&nbsp;                chain.add(current);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!chain.isEmpty()) {</b>
<b class="nc">&nbsp;                chain.sort((m1, m2) -&gt; Integer.compare(m2.getUsableShotsLeft(), m1.getUsableShotsLeft()));</b>
<b class="nc">&nbsp;                weapon.setLinked(chain.get(0));</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; chain.size() - 1; i++) {</b>
<b class="nc">&nbsp;                    chain.get(i).setLinked(chain.get(i + 1));</b>
&nbsp;                }
<b class="nc">&nbsp;                chain.get(chain.size() - 1).setLinked(null);</b>
<b class="nc">&nbsp;                if (weapon.getLinked().getUsableShotsLeft() == 0) {</b>
<b class="nc">&nbsp;                    weapon.setFired(true);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (wtype.hasFlag(WeaponType.F_ONESHOT)) {</b>
<b class="nc">&nbsp;            weapon.setFired(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        setDone();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void setDone() {
<b class="nc">&nbsp;        weapon.setUsedThisRound(true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected void addHeat() {
&nbsp;        // Only add heat for first shot in strafe
<b class="nc">&nbsp;        if (isStrafing &amp;&amp; !isStrafingFirstShot()) {</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!(toHit.getValue() == TargetRoll.IMPOSSIBLE)) {</b>
<b class="nc">&nbsp;            if (ae.usesWeaponBays() &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_HEAT_BY_BAY)) {</b>
<b class="nc">&nbsp;                int loc = weapon.getLocation();</b>
<b class="nc">&nbsp;                boolean rearMount = weapon.isRearMounted();</b>
<b class="nc">&nbsp;                if (!ae.hasArcFired(loc, rearMount)) {</b>
<b class="nc">&nbsp;                    ae.heatBuildup += ae.getHeatInArc(loc, rearMount);</b>
<b class="nc">&nbsp;                    ae.setArcFired(loc, rearMount);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                ae.heatBuildup += (weapon.getCurrentHeat());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Does this attack use the cluster hit table? necessary to determine how
&nbsp;     * Aero damage should be applied
&nbsp;     */
&nbsp;    protected boolean usesClusterTable() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * special resolution, like minefields and arty
&nbsp;     *
&nbsp;     * @param vPhaseReport - a &lt;code&gt;Vector&lt;/code&gt; containing the phase report
&nbsp;     * @param entityTarget - the &lt;code&gt;Entity&lt;/code&gt; targeted, or &lt;code&gt;null&lt;/code&gt;, if
&nbsp;     *                     no Entity targeted
&nbsp;     * @return true when done with processing, false when not
&nbsp;     */
&nbsp;    protected boolean specialResolution(Vector&lt;Report&gt; vPhaseReport,
&nbsp;                                        Entity entityTarget) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean announcedEntityFiring() {
<b class="nc">&nbsp;        return announcedEntityFiring;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setAnnouncedEntityFiring(boolean announcedEntityFiring) {
<b class="nc">&nbsp;        this.announcedEntityFiring = announcedEntityFiring;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public WeaponAttackAction getWaa() {
<b class="nc">&nbsp;        return waa;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int checkTerrain(int nDamage, Entity entityTarget,
&nbsp;            Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        if (entityTarget == null) {</b>
<b class="nc">&nbsp;            return nDamage;</b>
&nbsp;        }
<b class="nc">&nbsp;        IHex hex = game.getBoard().getHex(entityTarget.getPosition());</b>
<b class="nc">&nbsp;        boolean hasWoods = hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;        boolean isAboveWoods = (entityTarget.relHeight() + 1 &gt; hex.terrainLevel(Terrains.FOLIAGE_ELEV)) </b>
<b class="nc">&nbsp;                || entityTarget.isAirborne() || !hasWoods;</b>
&nbsp;        
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)</b>
&nbsp;                &amp;&amp; hasWoods
&nbsp;                &amp;&amp; !isAboveWoods
<b class="nc">&nbsp;                &amp;&amp; !(entityTarget.getSwarmAttackerId() == ae.getId())) {</b>
<b class="nc">&nbsp;            ITerrain woodHex = hex.getTerrain(Terrains.WOODS);</b>
<b class="nc">&nbsp;            ITerrain jungleHex = hex.getTerrain(Terrains.JUNGLE);</b>
<b class="nc">&nbsp;            int treeAbsorbs = 0;</b>
<b class="nc">&nbsp;            String hexType = &quot;&quot;;</b>
<b class="nc">&nbsp;            if (woodHex != null) {</b>
<b class="nc">&nbsp;                treeAbsorbs = woodHex.getLevel() * 2;</b>
<b class="nc">&nbsp;                hexType = &quot;wooded&quot;;</b>
<b class="nc">&nbsp;            } else if (jungleHex != null) {</b>
<b class="nc">&nbsp;                treeAbsorbs = jungleHex.getLevel() * 2;</b>
<b class="nc">&nbsp;                hexType = &quot;jungle&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Do not absorb more damage than the weapon can do.
<b class="nc">&nbsp;            treeAbsorbs = Math.min(nDamage, treeAbsorbs);</b>
&nbsp;
<b class="nc">&nbsp;            nDamage = Math.max(0, nDamage - treeAbsorbs);</b>
<b class="nc">&nbsp;            server.tryClearHex(entityTarget.getPosition(), treeAbsorbs,</b>
<b class="nc">&nbsp;                    ae.getId());</b>
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;            Report terrainReport = new Report(6427);</b>
<b class="nc">&nbsp;            terrainReport.subject = entityTarget.getId();</b>
<b class="nc">&nbsp;            terrainReport.add(hexType);</b>
<b class="nc">&nbsp;            terrainReport.add(treeAbsorbs);</b>
<b class="nc">&nbsp;            terrainReport.indent(2);</b>
<b class="nc">&nbsp;            terrainReport.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.add(terrainReport);</b>
&nbsp;        }
<b class="nc">&nbsp;        return nDamage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check for Laser Inhibiting smoke clouds
&nbsp;     */
&nbsp;    public int checkLI(int nDamage, Entity entityTarget,
&nbsp;            Vector&lt;Report&gt; vPhaseReport) {
&nbsp;
<b class="nc">&nbsp;        weapon = ae.getEquipment(waa.getWeaponId());</b>
<b class="nc">&nbsp;        wtype = (WeaponType) weapon.getType();</b>
&nbsp;
<b class="nc">&nbsp;        ArrayList&lt;Coords&gt; coords = Coords.intervening(ae.getPosition(),</b>
<b class="nc">&nbsp;                entityTarget.getPosition());</b>
<b class="nc">&nbsp;        int refrac = 0;</b>
<b class="nc">&nbsp;        double travel = 0;</b>
<b class="nc">&nbsp;        double range = ae.getPosition().distance(target.getPosition());</b>
<b class="nc">&nbsp;        double atkLev = ae.relHeight();</b>
<b class="nc">&nbsp;        double tarLev = entityTarget.relHeight();</b>
<b class="nc">&nbsp;        double levDif = Math.abs(atkLev - tarLev);</b>
<b class="nc">&nbsp;        String hexType = &quot;LASER inhibiting smoke&quot;;</b>
&nbsp;
&nbsp;        // loop through all intervening coords.
&nbsp;        // If you could move this to compute.java, then remove - import
&nbsp;        // java.util.ArrayList;
<b class="nc">&nbsp;        for (Coords curr : coords) {</b>
&nbsp;            // skip hexes not actually on the board
<b class="nc">&nbsp;            if (!game.getBoard().contains(curr)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            ITerrain smokeHex = game.getBoard().getHex(curr)</b>
<b class="nc">&nbsp;                    .getTerrain(Terrains.SMOKE);</b>
<b class="nc">&nbsp;            if (game.getBoard().getHex(curr).containsTerrain(Terrains.SMOKE)</b>
<b class="nc">&nbsp;                    &amp;&amp; wtype.hasFlag(WeaponType.F_ENERGY)</b>
<b class="nc">&nbsp;                    &amp;&amp; ((smokeHex.getLevel() == SmokeCloud.SMOKE_LI_LIGHT) || (smokeHex</b>
<b class="nc">&nbsp;                            .getLevel() == SmokeCloud.SMOKE_LI_HEAVY))) {</b>
&nbsp;
<b class="nc">&nbsp;                int levit = ((game.getBoard().getHex(curr).getLevel()) + 2);</b>
&nbsp;
&nbsp;                // does the hex contain LASER inhibiting smoke?
<b class="nc">&nbsp;                if ((tarLev &gt; atkLev)</b>
&nbsp;                        &amp;&amp; (levit &gt;= ((travel * (levDif / range)) + atkLev))) {
<b class="nc">&nbsp;                    refrac++;</b>
<b class="nc">&nbsp;                } else if ((atkLev &gt; tarLev)</b>
&nbsp;                        &amp;&amp; (levit &gt;= (((range - travel) * (levDif / range)) + tarLev))) {
<b class="nc">&nbsp;                    refrac++;</b>
<b class="nc">&nbsp;                } else if ((atkLev == tarLev) &amp;&amp; (levit &gt;= 0)) {</b>
<b class="nc">&nbsp;                    refrac++;</b>
&nbsp;                }
<b class="nc">&nbsp;                travel++;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (refrac != 0) {</b>
&nbsp;            // Damage reduced by 2 for each interviening smoke.
<b class="nc">&nbsp;            refrac = (refrac * 2);</b>
&nbsp;
&nbsp;            // Do not absorb more damage than the weapon can do. (Are both of
&nbsp;            // these really necessary?)
<b class="nc">&nbsp;            refrac = Math.min(nDamage, refrac);</b>
<b class="nc">&nbsp;            nDamage = Math.max(0, (nDamage - refrac));</b>
&nbsp;
<b class="nc">&nbsp;            Report.addNewline(vPhaseReport);</b>
<b class="nc">&nbsp;            Report fogReport = new Report(6427);</b>
<b class="nc">&nbsp;            fogReport.subject = entityTarget.getId();</b>
<b class="nc">&nbsp;            fogReport.add(hexType);</b>
<b class="nc">&nbsp;            fogReport.add(refrac);</b>
<b class="nc">&nbsp;            fogReport.indent(2);</b>
<b class="nc">&nbsp;            fogReport.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.add(fogReport);</b>
&nbsp;        }
<b class="nc">&nbsp;        return nDamage;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean canDoDirectBlowDamage() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Insert any additionaly attacks that should occur before this attack
&nbsp;     */
&nbsp;    protected void insertAttacks(IGame.Phase phase, Vector&lt;Report&gt; vPhaseReport) {
<b class="nc">&nbsp;        return;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the number of weapons of this type firing (for squadron weapon
&nbsp;     * groups)
&nbsp;     */
&nbsp;    protected int getNumberWeapons() {
<b class="nc">&nbsp;        return weapon.getNWeapons();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Restores the equipment from the name
&nbsp;     */
&nbsp;    public void restore() {
<b class="nc">&nbsp;        if (typeName == null) {</b>
<b class="nc">&nbsp;            typeName = wtype.getName();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wtype = (WeaponType) EquipmentType.get(typeName);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (wtype == null) {</b>
<b class="nc">&nbsp;            System.err</b>
<b class="nc">&nbsp;                    .println(&quot;WeaponHandler.restore: could not restore equipment type \&quot;&quot;</b>
&nbsp;                            + typeName + &quot;\&quot;&quot;);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected int getClusterModifiers(boolean clusterRangePenalty) {
<b class="nc">&nbsp;        int nMissilesModifier = nSalvoBonus;</b>
&nbsp;
<b class="nc">&nbsp;        int[] ranges = wtype.getRanges(weapon);</b>
<b class="nc">&nbsp;        if (clusterRangePenalty &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_CLUSTERHITPEN)) {</b>
<b class="nc">&nbsp;            if (nRange &lt;= 1) {</b>
<b class="nc">&nbsp;                nMissilesModifier += 1;</b>
<b class="nc">&nbsp;            } else if (nRange &lt;= ranges[RangeType.RANGE_MEDIUM]) {</b>
<b class="nc">&nbsp;                nMissilesModifier += 0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                nMissilesModifier -= 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE)</b>
&nbsp;            &amp;&amp; (nRange &gt; ranges[RangeType.RANGE_LONG])) {
<b class="nc">&nbsp;            nMissilesModifier -= 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE)</b>
&nbsp;                &amp;&amp; (nRange &gt; ranges[RangeType.RANGE_EXTREME])) {
<b class="nc">&nbsp;            nMissilesModifier -= 3;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (bGlancing) {</b>
<b class="nc">&nbsp;            nMissilesModifier -= 4;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (bLowProfileGlancing) {</b>
<b class="nc">&nbsp;            nMissilesModifier -= 4;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (bDirect) {</b>
<b class="nc">&nbsp;            nMissilesModifier += (toHit.getMoS() / 3) * 2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getPlanetaryConditions().hasEMI()) {</b>
<b class="nc">&nbsp;            nMissilesModifier -= 2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (null != ae.getCrew()) {</b>
<b class="nc">&nbsp;            if (ae.hasAbility(OptionsConstants.GUNNERY_SANDBLASTER, wtype.getName())) {</b>
<b class="nc">&nbsp;                if (nRange &gt; ranges[RangeType.RANGE_MEDIUM]) {</b>
<b class="nc">&nbsp;                    nMissilesModifier += 2;</b>
<b class="nc">&nbsp;                } else if (nRange &gt; ranges[RangeType.RANGE_SHORT]) {</b>
<b class="nc">&nbsp;                    nMissilesModifier += 3;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    nMissilesModifier += 4;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (ae.hasAbility(OptionsConstants.GUNNERY_CLUSTER_MASTER)) {</b>
<b class="nc">&nbsp;                nMissilesModifier += 2;</b>
<b class="nc">&nbsp;            } else if (ae.hasAbility(OptionsConstants.GUNNERY_CLUSTER_HITTER)) {</b>
<b class="nc">&nbsp;                nMissilesModifier += 1;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return nMissilesModifier;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isStrafing() {
<b class="nc">&nbsp;        return isStrafing;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStrafing(boolean isStrafing) {
<b class="nc">&nbsp;        this.isStrafing = isStrafing;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isStrafingFirstShot() {
<b class="nc">&nbsp;        return isStrafingFirstShot;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStrafingFirstShot(boolean isStrafingFirstShot) {
<b class="nc">&nbsp;        this.isStrafingFirstShot = isStrafingFirstShot;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determine the &quot;glancing blow&quot; divider.
&nbsp;     * 2 if the shot is &quot;glancing&quot; or &quot;glancing due to low profile&quot;
&nbsp;     * 4 if both
&nbsp;     * int version
&nbsp;     */
&nbsp;    protected int applyGlancingBlowModifier(int initialValue, boolean roundup) {
<b class="nc">&nbsp;        return (int) applyGlancingBlowModifier((double) initialValue, roundup);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Determine the &quot;glancing blow&quot; divider.
&nbsp;     * 2 if the shot is &quot;glancing&quot; or &quot;glancing due to low profile&quot;
&nbsp;     * 4 if both
&nbsp;     * double version
&nbsp;     */
&nbsp;    protected double applyGlancingBlowModifier(double initialValue, boolean roundup) {
&nbsp;        // if we&#39;re not going to be applying any glancing blow modifiers, just return what we came in with
<b class="nc">&nbsp;        if(!bGlancing &amp;&amp; !bLowProfileGlancing) {</b>
<b class="nc">&nbsp;            return initialValue;</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        double divisor = getTotalGlancingBlowFactor();        </b>
<b class="nc">&nbsp;        double intermediateValue = initialValue / divisor;</b>
<b class="nc">&nbsp;        return roundup ? Math.ceil(intermediateValue) : Math.floor(intermediateValue);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Logic to determine the glancing blow multiplier:
&nbsp;     * 1 if no glancing blow
&nbsp;     * 2 if one type of glancing blow (either usual or narrow/low profile)
&nbsp;     * 4 if both types of glancing blow
&nbsp;     */
&nbsp;    protected double getTotalGlancingBlowFactor() {
<b class="nc">&nbsp;        return (bGlancing ? 2.0 : 1.0) * (bLowProfileGlancing ? 2.0 : 1.0);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Worker function that sets the glancing blow flags for this attack for the target when appropriate
&nbsp;     */
&nbsp;    protected void setGlancingBlowFlags(Entity entityTarget) {
&nbsp;        // are we a glancing hit?  Check for this here, report it later
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_GLANCING_BLOWS)) {</b>
<b class="nc">&nbsp;            if (roll == toHit.getValue()) {</b>
<b class="nc">&nbsp;                bGlancing = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                bGlancing = false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // low profile glancing blows are triggered on roll = toHit or toHit - 1
<b class="nc">&nbsp;        bLowProfileGlancing = isLowProfileGlancingBlow(entityTarget, toHit);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Worker function that determines if the given hit on the given entity is a glancing blow
&nbsp;     * as per narrow/low profile quirk rules
&nbsp;     */
&nbsp;    protected boolean isLowProfileGlancingBlow(Entity entityTarget, ToHitData hitData) {
<b class="nc">&nbsp;        return (entityTarget != null) &amp;&amp;</b>
<b class="nc">&nbsp;                entityTarget.hasQuirk(OptionsConstants.QUIRK_POS_LOW_PROFILE) &amp;&amp;</b>
<b class="nc">&nbsp;                ((roll == hitData.getValue()) || (roll == hitData.getValue() + 1));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Worker function that adds the &#39;glancing blow&#39; reports
&nbsp;     */
&nbsp;    protected void addGlancingBlowReports(Vector&lt;Report&gt; vPhaseReport) {
&nbsp;        Report r;
&nbsp;        
<b class="nc">&nbsp;        if (bGlancing) {</b>
<b class="nc">&nbsp;            r = new Report(3186);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        if (bLowProfileGlancing) {</b>
<b class="nc">&nbsp;            r = new Report(9985);</b>
<b class="nc">&nbsp;            r.subject = ae.getId();</b>
<b class="nc">&nbsp;            r.newlines = 0;</b>
<b class="nc">&nbsp;            vPhaseReport.addElement(r);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-16 16:28</div>
</div>
</body>
</html>
